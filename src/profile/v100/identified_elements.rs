use std::ops::DerefMut;

use crate::prelude::*;

macro_rules! decl_identified_array_of {
	(
        $(
            #[doc = $expr: expr]
        )*
        $element_type: ty,
		$assert_not_empty: literal,
		$struct_type: ident,
		$collection_type: ty
    ) => {
        paste! {
            $(
                #[doc = $expr]
            )*
			#[derive(Clone, Eq, PartialEq, Hash, derive_more::Debug, derive_more::Display, Serialize, Deserialize)]
			pub struct $struct_type($collection_type);

			impl [< $struct_type >] {

                #[allow(clippy::should_implement_trait)]
				pub fn from_iter<I>([<  $struct_type:lower >]: I) -> Self
				where
					I: IntoIterator<Item = $element_type>,
				{
					let vector = IdentifiedVecVia::from_iter([< $struct_type:lower >]);
					if $assert_not_empty {
						assert_ne!(
							vector.len(),
							0,
							"Collection empty, which must never happen."
						)
					}

					Self(vector)
				}

				pub fn [< with_ $struct_type:lower >]<I>([< $struct_type:lower >]: I) -> Self
				where
					I: IntoIterator<Item = $element_type>,
				{
					Self::from_iter([< $struct_type:lower >])
				}

				pub fn [< with_ $element_type:lower >]([< $element_type:lower >]: $element_type) -> Self {
					Self::[< with_ $struct_type:lower >]([[< $element_type:lower >]])
				}
			}

			impl Deref for $struct_type {
				type Target = $collection_type;

				fn deref(&self) -> &Self::Target {
					&self.0
				}
			}

			impl DerefMut for $struct_type {
				fn deref_mut(&mut self) -> &mut Self::Target {
					&mut self.0
				}
			}
		}

		uniffi::custom_newtype!($struct_type, $collection_type);
	};
	(
        $(
            #[doc = $expr: expr]
        )*
        $element_type: ty,
		$assert_not_empty: literal
    ) => {
        paste! {
			decl_identified_array_of!(
				$(
                    #[doc = $expr]
                )*
				$element_type,
				$assert_not_empty,
				[< $element_type s >],
				IdentifiedVecVia<$element_type>
			);
		}
	};
}

decl_identified_array_of!(
    /// An ordered set of [`Account`]s on a specific network, most commonly
    /// the set is non-empty, since wallets guide user to create a first
    /// Account.
    Account,
    false
);

decl_identified_array_of!(
    /// An ordered set of [`Persona`]s on a specific network.
    Persona,
    false
);

decl_identified_array_of!(
    /// A collection of [`FactorSource`]s generated by a wallet or manually added by user.
    /// MUST never be empty.
    FactorSource,
    true
);
