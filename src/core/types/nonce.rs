pub use crate::prelude::*;

// Generate the FfiConverter needed by UniFFI for newtype `Nonce`.
uniffi::custom_newtype!(Nonce, u32);

/// A random number generated part of a transaction header,
/// ensuring every transaction os unique even though its
/// transaction manifest might be equal. This nonce is
/// generated by wallets for incoming transactions.
#[derive(
    Clone, Copy, PartialEq, Eq, Hash, derive_more::Display, derive_more::Debug,
)]
pub struct Nonce(pub u32);

impl Nonce {
    /// Generates 4 random bytes and creates a Nonce (u32) from it.
    pub fn random() -> Self {
        u32::from_be_bytes(
            generate_bytes::<4>()
                .as_slice()
                .try_into()
                .expect("It is 4 bytes."),
        )
        .into()
    }
}

impl From<u32> for Nonce {
    fn from(value: u32) -> Self {
        Self(value)
    }
}

impl From<Nonce> for u32 {
    fn from(value: Nonce) -> Self {
        value.0
    }
}

#[cfg(test)]
mod tests {
    use crate::prelude::*;

    #[test]
    fn from_u32() {
        let test = |u: u32| assert_eq!(u32::from(Nonce::from(u)), u);
        test(0);
        test(1);
        test(2);
        test(1337);
    }

    #[test]
    fn to_u32() {
        let test =
            |u: u32| assert_eq!(Nonce::from(u32::from(Nonce::from(u))).0, u);
        test(0);
        test(1);
        test(2);
        test(1337);
    }

    #[test]
    fn generate_new() {
        let mut set: HashSet<Nonce> = HashSet::new();
        let n = 100;
        for _ in 0..n {
            let sut = Nonce::random();
            set.insert(sut);
        }
        assert_eq!(set.len(), n); // with a low probability this might fail yes.
    }
}
