use crate::prelude::*;
use delegate::delegate;
use radix_engine_common::crypto::{Hash, IsHash};

/// Serializable 32 bytes which **always** serializes as a **hex** string, this is useful
/// since in Radix Wallet Kit we almost always want to serialize bytes into hex and this
/// allows us to skip using
#[derive(
    Clone,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    SerializeDisplay,
    DeserializeFromStr,
    derive_more::Display,
    derive_more::Debug,
    uniffi::Record,
)]
#[display("{}", self.to_hex())]
#[debug("{}", self.to_hex())]
pub struct Hex32Bytes {
    bag_of_bytes: BagOfBytes,
}

impl TryFrom<BagOfBytes> for Hex32Bytes {
    type Error = CommonError;

    fn try_from(value: BagOfBytes) -> Result<Self> {
        if value.len() != 32 {
            return Err(CommonError::InvalidByteCountExpected32(value.len()));
        }
        Ok(Self {
            bag_of_bytes: value,
        })
    }
}

impl Hex32Bytes {
    /// Instantiates a new `BagOfBytes` from bytes generated by
    /// a CSPRNG.
    pub fn generate() -> Self {
        Hex32Bytes {
            bag_of_bytes: BagOfBytes::from(generate_32_bytes()),
        }
    }

    /// Tries to decode the string `s` into a `Hex32Bytes`. Will fail
    /// if the string is not valid hex or if the decoded bytes does
    /// not have length 32.
    pub fn from_hex(s: &str) -> Result<Self> {
        Self::from_str(s)
    }

    /// Instantiates a new `Hex32Bytes` from the 32 bytes, by cloning them.
    pub fn from_bytes(bytes: &[u8; 32]) -> Self {
        Self {
            bag_of_bytes: bytes.into(),
        }
    }
}

impl Hex32Bytes {
    /// Returns a references to the inner array slice.
    pub fn bytes(&self) -> [u8; 32] {
        self.bag_of_bytes
            .to_vec()
            .as_slice()
            .try_into()
            .expect("32 bytes")
    }
}

impl TryFrom<Vec<u8>> for Hex32Bytes {
    type Error = CommonError;

    fn try_from(value: Vec<u8>) -> Result<Self> {
        BagOfBytes::from(value).try_into()
    }
}

impl FromStr for Hex32Bytes {
    type Err = CommonError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        s.parse::<BagOfBytes>().and_then(|v| v.try_into())
    }
}

impl From<Hash> for Hex32Bytes {
    /// Instantiates a new `Hex32Bytes` from the `Hash` (32 bytes).
    fn from(value: Hash) -> Self {
        Self::from_bytes(&value.into_bytes())
    }
}

impl Hex32Bytes {
    delegate! {
        to self.bag_of_bytes{
            pub fn to_hex(&self) -> String;
            pub fn to_vec(&self) -> Vec<u8>;
        }
    }
}

impl HasPlaceholder for Hex32Bytes {
    /// `deadbeef...``
    /// A placeholder used to facilitate unit tests.
    fn placeholder() -> Self {
        Self::placeholder_dead()
    }

    /// A placeholder used to facilitate unit tests.
    fn placeholder_other() -> Self {
        Self::placeholder_fade()
    }
}

impl Hex32Bytes {
    /// `aced...``
    /// A placeholder used to facilitate unit tests.
    pub fn placeholder_aced() -> Self {
        Self::from_str(&"aced".repeat(16)).expect("aced...")
    }

    /// `babe...``
    /// A placeholder used to facilitate unit tests.
    pub fn placeholder_babe() -> Self {
        Self::from_str(&"babe".repeat(16)).expect("babe...")
    }

    /// `cafe...``
    /// A placeholder used to facilitate unit tests.
    pub fn placeholder_cafe() -> Self {
        Self::from_str(&"cafe".repeat(16)).expect("cafe...")
    }

    /// `dead...``
    /// A placeholder used to facilitate unit tests.
    pub fn placeholder_dead() -> Self {
        Self::from_str(&"dead".repeat(16)).expect("dead...")
    }

    /// `ecad...``
    /// A placeholder used to facilitate unit tests.
    pub fn placeholder_ecad() -> Self {
        Self::from_str(&"ecad".repeat(16)).expect("ecad...")
    }

    /// `fade...``
    /// A placeholder used to facilitate unit tests.
    pub fn placeholder_fade() -> Self {
        Self::from_str(&"fade".repeat(16)).expect("fade...")
    }
}

#[uniffi::export]
pub fn new_hex32_bytes_from(bytes: Vec<u8>) -> Result<Hex32Bytes> {
    Hex32Bytes::try_from(bytes)
}

#[cfg(test)]
mod tests {

    use crate::prelude::*;

    #[allow(clippy::upper_case_acronyms)]
    type SUT = Hex32Bytes;

    #[test]
    fn equality() {
        assert_eq!(SUT::placeholder(), SUT::placeholder());
        assert_eq!(SUT::placeholder_other(), SUT::placeholder_other());
    }

    #[test]
    fn inequality() {
        assert_ne!(SUT::placeholder(), SUT::placeholder_other());
    }

    #[test]
    fn from_string_roundtrip() {
        let str =
            "0000000000000000000000000000000000000000000000000000000000000000";
        assert_eq!(SUT::from_hex(str).unwrap().to_string(), str);
    }

    #[test]
    fn debug() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(format!("{:?}", hex_bytes), str);
    }

    #[test]
    fn display() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(format!("{}", hex_bytes), str);
    }

    #[test]
    fn to_hex() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(hex_bytes.to_string(), str);
    }

    #[test]
    fn json_roundtrip() {
        let model = SUT::placeholder();
        assert_json_value_eq_after_roundtrip(
            &model,
            json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"),
        );
    }

    #[test]
    fn json_roundtrip_fails_for_invalid() {
        assert_json_value_fails::<SUT>(json!("not even hex"));
        assert_json_value_fails::<SUT>(json!("deadbeef"));
        assert_json_value_fails::<SUT>(json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"));
    }

    #[test]
    fn from_bytes_roundtrip() {
        let bytes = [0u8; 32];
        assert_eq!(SUT::from_bytes(&bytes).bytes(), bytes);
    }

    #[test]
    fn from_vec_roundtrip() {
        let vec = Vec::from([0u8; 32]);
        let sut: SUT = vec.clone().try_into().unwrap();
        assert_eq!(sut.to_vec(), vec);
    }

    #[test]
    fn invalid_str() {
        let s = "invalid str";
        assert_eq!(
            SUT::from_str(s),
            Err(CommonError::StringNotHex(s.to_owned()))
        );
    }

    #[test]
    fn invalid_len() {
        assert_eq!(
            SUT::try_from(Vec::from([0u8; 5])),
            Err(CommonError::InvalidByteCountExpected32(5))
        )
    }

    #[test]
    fn random() {
        let mut set: HashSet<Vec<u8>> = HashSet::new();
        let n = 100;
        for _ in 0..n {
            let bytes = SUT::generate();
            set.insert(bytes.to_vec());
        }
        assert_eq!(set.len(), n);
    }
}

#[cfg(test)]
mod uniffi_tests {
    use crate::prelude::*;

    #[test]
    fn new_ok() {
        let bytes = generate_32_bytes();
        assert_eq!(
            new_hex32_bytes_from(bytes.clone()).unwrap().to_vec(),
            bytes
        );
    }

    #[test]
    fn new_fail() {
        assert!(new_hex32_bytes_from(generate_bytes::<5>()).is_err());
    }
}
