use crate::prelude::*;
use delegate::delegate;
use paste::*;
use radix_engine_common::crypto::{Hash, IsHash};

#[derive(
    Clone,
    Copy,
    PartialEq,
    Eq,
    Hash,
    Ord,
    PartialOrd,
    SerializeDisplay,
    DeserializeFromStr,
    derive_more::Display,
    derive_more::Debug,
)]
#[display("{}", self.to_hex())]
#[debug("{}", self.to_hex())]
pub struct ExactlyNBytes<const N: usize> {
    bytes: [u8; N],
}

impl<const N: usize> crate::UniffiCustomTypeConverter for ExactlyNBytes<N> {
    type Builtin = BagOfBytes;

    #[cfg(not(tarpaulin_include))] // false negative, tested in bindgen tests
    fn into_custom(val: Self::Builtin) -> uniffi::Result<Self> {
        Self::try_from(val.as_ref()).map_err(|e| e.into())
    }

    #[cfg(not(tarpaulin_include))] // false negative, tested in bindgen tests
    fn from_custom(obj: Self) -> Self::Builtin {
        BagOfBytes::from(obj.bytes.as_slice())
    }
}

impl<const N: usize> ExactlyNBytes<N> {
    /// Instantiates a new `BagOfBytes` from bytes generated by
    /// a CSPRNG.
    pub fn generate() -> Self {
        Self {
            bytes: generate_byte_array::<N>(),
        }
    }

    /// Tries to decode the string `s` into a `ExactlyNBytes<N>`. Will fail
    /// if the string is not valid hex or if the decoded bytes does
    /// not have length `N`.
    pub fn from_hex(s: &str) -> Result<Self> {
        Self::from_str(s)
    }
}

impl<const N: usize> ExactlyNBytes<N> {
    /// Returns a references to the inner array slice.
    pub fn bytes(&self) -> &[u8; N] {
        &self.bytes
    }
}

impl<const N: usize> TryFrom<&[u8]> for ExactlyNBytes<N> {
    type Error = CommonError;

    fn try_from(value: &[u8]) -> Result<Self> {
        if value.len() == N {
            Ok(Self {
                bytes: value.try_into().unwrap(),
            })
        } else {
            Err(CommonError::InvalidByteCount {
                expected: N as u64,
                found: value.len() as u64,
            })
        }
    }
}

impl<const N: usize> TryFrom<Vec<u8>> for ExactlyNBytes<N> {
    type Error = CommonError;

    fn try_from(value: Vec<u8>) -> Result<Self> {
        <Self as TryFrom<&[u8]>>::try_from(value.as_ref())
    }
}

impl<const N: usize> TryFrom<BagOfBytes> for ExactlyNBytes<N> {
    type Error = CommonError;

    fn try_from(value: BagOfBytes) -> Result<Self> {
        Self::try_from(value.as_ref())
    }
}

impl<const N: usize> AsRef<[u8]> for ExactlyNBytes<N> {
    fn as_ref(&self) -> &[u8] {
        &self.bytes
    }
}

impl<const N: usize> From<&[u8; N]> for ExactlyNBytes<N> {
    fn from(value: &[u8; N]) -> Self {
        Self { bytes: *value }
    }
}

impl<const N: usize> From<&[u8; N]> for BagOfBytes {
    fn from(value: &[u8; N]) -> Self {
        Self {
            bytes: value.to_vec(),
        }
    }
}

impl<const N: usize> FromStr for ExactlyNBytes<N> {
    type Err = CommonError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        s.parse::<BagOfBytes>().and_then(|v| v.try_into())
    }
}

impl<const N: usize> ExactlyNBytes<N> {
    pub fn to_hex(&self) -> String {
        hex_encode(self.bytes)
    }
    pub fn to_vec(&self) -> Vec<u8> {
        self.bytes.to_vec()
    }
}
impl<const N: usize> HasSampleValues for ExactlyNBytes<N> {
    /// `deadbeef...``
    /// A sample used to facilitate unit tests.
    fn sample() -> Self {
        Self::sample_dead()
    }

    /// A sample used to facilitate unit tests.
    fn sample_other() -> Self {
        Self::sample_fade()
    }
}

impl<const N: usize> ExactlyNBytes<N> {
    fn declare_sample(r: &str) -> Self {
        let mut s = r.repeat(N / 2);
        if s.len() != N * 2 {
            s = format!("{}{}", N, s);
        }
        Self::from_str(&s).expect("Valid sample")
    }

    /// `aced...``
    /// A sample used to facilitate unit tests.
    pub fn sample_aced() -> Self {
        Self::declare_sample("aced")
    }

    /// `babe...``
    /// A sample used to facilitate unit tests.
    pub fn sample_babe() -> Self {
        Self::declare_sample("babe")
    }

    /// `cafe...``
    /// A sample used to facilitate unit tests.
    pub fn sample_cafe() -> Self {
        Self::declare_sample("cafe")
    }

    /// `dead...``
    /// A sample used to facilitate unit tests.
    pub fn sample_dead() -> Self {
        Self::declare_sample("dead")
    }

    /// `ecad...``
    /// A sample used to facilitate unit tests.
    pub fn sample_ecad() -> Self {
        Self::declare_sample("ecad")
    }

    /// `fade...``
    /// A sample used to facilitate unit tests.
    pub fn sample_fade() -> Self {
        Self::declare_sample("fade")
    }
}

/// Small macro to facilitate generation of UniFFI exported functions.
macro_rules! decl_exactly_n_bytes {
    (
        $(
            #[doc = $expr: expr]
        )*
        $byte_count:literal
    ) => {
        paste! {
            $(
                #[doc = $expr]
            )*
            #[derive(
                Clone,
                Copy,
                PartialEq,
                Eq,
                Hash,
                Ord,
                PartialOrd,
                SerializeDisplay,
                DeserializeFromStr,
                derive_more::FromStr,
                derive_more::Display,
                derive_more::Debug,
                uniffi::Record,
            )]
            #[display("{}", self.to_hex())]
            #[debug("{}", self.to_hex())]
            pub struct [<Exactly $byte_count Bytes>] {
                secret_magic: [<Exactly $byte_count Bytes SecretMagic>],
            }

            pub type [<Exactly $byte_count Bytes SecretMagic>] = ExactlyNBytes<$byte_count>;

            impl [<Exactly $byte_count Bytes>] {
                pub fn bytes(&self) -> &[u8; $byte_count] {
                    self.secret_magic.bytes()
                }

                /// Instantiates a new `BagOfBytes` from bytes generated by
                /// a CSPRNG.
                pub fn generate() -> Self {
                    <ExactlyNBytes<$byte_count>>::generate().into()
                }

                /// Tries to decode the string `s` into this type. Will fail
                // if the string is not valid hex or if the decoded bytes does
                // not have length `N`.
                pub fn from_hex(s: &str) -> Result<Self> {
                   Self::from_str(s)
                }

                delegate! {
                    to self.secret_magic {
                        pub fn to_hex(&self) -> String;
                        pub fn to_vec(&self) -> Vec<u8>;
                    }
                }
            }

            impl From<ExactlyNBytes<$byte_count>> for [<Exactly $byte_count Bytes>] {
                fn from(value: ExactlyNBytes<$byte_count>) -> Self {
                    Self {
                        secret_magic: value
                    }
                }
            }

            impl TryFrom<&[u8]> for [<Exactly $byte_count Bytes>] {
                type Error = CommonError;

                fn try_from(value: &[u8]) -> Result<Self> {
                    <ExactlyNBytes<$byte_count>>::try_from(value).map(Self::from)
                }
            }

            impl TryFrom<Vec<u8>> for [<Exactly $byte_count Bytes>] {
                type Error = CommonError;

                fn try_from(value: Vec<u8>) -> Result<Self> {
                    <ExactlyNBytes<$byte_count>>::try_from(value).map(Self::from)
                }
            }

            impl TryFrom<BagOfBytes> for [<Exactly $byte_count Bytes>] {
                type Error = CommonError;

                fn try_from(value: BagOfBytes) -> Result<Self> {
                    <ExactlyNBytes<$byte_count>>::try_from(value).map(Self::from)
                }
            }


            impl AsRef<[u8]> for [<Exactly $byte_count Bytes>] {
                fn as_ref(&self) -> &[u8] {
                    self.bytes()
                }
            }

            impl From<&[u8; $byte_count]> for [<Exactly $byte_count Bytes>] {
                fn from(value: &[u8; $byte_count]) -> Self {
                    <ExactlyNBytes<$byte_count>>::from(value).into()
                }
            }

            impl HasSampleValues for [<Exactly $byte_count Bytes>] {
                /// `deadbeef...``
                /// A sample used to facilitate unit tests.
                fn sample() -> Self {
                    <ExactlyNBytes<$byte_count>>::sample().into()
                }

                /// A sample used to facilitate unit tests.
                fn sample_other() -> Self {
                    <ExactlyNBytes<$byte_count>>::sample_other().into()
                }
            }

            impl [<Exactly $byte_count Bytes>] {


                /// `aced...``
                /// A sample used to facilitate unit tests.
                pub fn sample_aced() -> Self {
                    <ExactlyNBytes<$byte_count>>::sample_aced().into()
                }

                /// `babe...``
                /// A sample used to facilitate unit tests.
                pub fn sample_babe() -> Self {
                    <ExactlyNBytes<$byte_count>>::sample_babe().into()
                }

                /// `cafe...``
                /// A sample used to facilitate unit tests.
                pub fn sample_cafe() -> Self {
                    <ExactlyNBytes<$byte_count>>::sample_cafe().into()
                }

                /// `dead...``
                /// A sample used to facilitate unit tests.
                pub fn sample_dead() -> Self {
                    <ExactlyNBytes<$byte_count>>::sample_dead().into()
                }

                /// `ecad...``
                /// A sample used to facilitate unit tests.
                pub fn sample_ecad() -> Self {
                    <ExactlyNBytes<$byte_count>>::sample_ecad().into()
                }

                /// `fade...``
                /// A sample used to facilitate unit tests.
                pub fn sample_fade() -> Self {
                    <ExactlyNBytes<$byte_count>>::sample_fade().into()
                }
            }

            #[uniffi::export]
            pub fn [<new_exactly_ $byte_count _bytes>](
                bytes: BagOfBytes,
            ) -> Result<[< Exactly $byte_count Bytes >]> {
                [< Exactly $byte_count Bytes >]::try_from(bytes)
            }

            #[uniffi::export]
            pub fn [<new_exactly_ $byte_count _bytes_sample>](
            ) -> [< Exactly $byte_count Bytes >] {
                [< Exactly $byte_count Bytes >]::sample()
            }

            #[uniffi::export]
            pub fn [<new_exactly_ $byte_count _bytes_sample_other>](
            ) -> [< Exactly $byte_count Bytes >] {
                [< Exactly $byte_count Bytes >]::sample_other()
            }

            #[uniffi::export]
            pub fn [<exactly_ $byte_count _bytes_to_bytes>](
                bytes: &[< Exactly $byte_count Bytes >],
            ) -> BagOfBytes {
                BagOfBytes::from(bytes.bytes())
            }

            #[uniffi::export]
            pub fn [<exactly_ $byte_count _bytes_to_hex>](
                bytes: &[< Exactly $byte_count Bytes >],
            ) -> String {
                bytes.to_hex()
            }

            #[cfg(test)]
            mod [<test_exactly_ $byte_count _bytes_macro>] {

                use crate::prelude::*;

                #[allow(clippy::upper_case_acronyms)]
                type SUT = [< Exactly $byte_count Bytes >];

                #[test]
                fn equality() {
                    assert_eq!(SUT::sample(), SUT::sample());
                    assert_eq!(SUT::sample_other(), SUT::sample_other());
                }

                #[test]
                fn inequality() {
                    assert_ne!(SUT::sample(), SUT::sample_other());
                }

                #[test]
                fn ord() {
                    assert!(SUT::sample() < SUT::sample_other());
                }

                #[test]
                fn hash() {
                    assert_eq!(
                        HashSet::<SUT>::from_iter([
                            SUT::sample_aced(),
                            SUT::sample_babe(),
                            SUT::sample_cafe(),
                            SUT::sample_dead(),
                            SUT::sample_ecad(),
                            SUT::sample_fade(),
                            // Duplicates should be removed
                            SUT::sample_aced(),
                            SUT::sample_babe(),
                            SUT::sample_cafe(),
                            SUT::sample_dead(),
                            SUT::sample_ecad(),
                            SUT::sample_fade(),
                        ])
                        .len(),
                        6
                    );
                }

                #[test]
                fn from_roundtrip() {
                    let bytes = &[0u8; $byte_count];
                    assert_eq!(SUT::from(bytes).bytes(), bytes);
                }

                #[test]
                fn from_vec_roundtrip() {
                    let vec = Vec::from([0u8; $byte_count]);
                    let sut: SUT = vec.clone().try_into().unwrap();
                    assert_eq!(sut.to_vec(), vec);
                }

                #[test]
                fn invalid_str() {
                    let s = "invalid str";
                    assert_eq!(
                        SUT::from_str(s),
                        Err(CommonError::StringNotHex {
                            bad_value: s.to_owned()
                        })
                    );
                }

                #[test]
                fn invalid_len() {
                    assert_eq!(
                        SUT::try_from(Vec::from([0u8; 5])),
                        Err(CommonError::InvalidByteCount {
                            expected: $byte_count,
                            found: 5
                        })
                    )
                }

                #[test]
                fn random() {
                    let mut set: HashSet<Vec<u8>> = HashSet::new();
                    let n = 100;
                    for _ in 0..n {
                        let bytes = SUT::generate();
                        set.insert(bytes.to_vec());
                    }
                    assert_eq!(set.len(), n);
                }
            }

            #[cfg(test)]
            mod [<uniffi_ test_exactly_ $byte_count _bytes_macro>] {

                use crate::prelude::*;

                #[allow(clippy::upper_case_acronyms)]
                type SUT = [< Exactly $byte_count Bytes >];

                #[test]
                fn new_from_bag_of_bytes() {
                    let bytes = generate_bytes::<$byte_count>();
                    assert_eq!(
                        [<new_exactly_ $byte_count _bytes>](bytes.clone().into()).unwrap().to_vec(),
                        bytes
                    );
                }

                #[test]
                fn new_fail() {
                    assert!([<new_exactly_ $byte_count _bytes>](generate_bytes::<5>().into()).is_err());
                }

                #[test]
                fn to_bytes() {
                    let bytes = generate_byte_array::<$byte_count>();
                    let sut = SUT::from(&bytes);
                    assert_eq!(
                        [<exactly_ $byte_count _bytes_to_bytes>](&sut),
                        BagOfBytes::from(&bytes)
                    );
                }

                #[test]
                fn to_hex() {
                    let bytes = generate_byte_array::<$byte_count>();
                    let sut = SUT::from(&bytes);
                    assert_eq!(
                        [<exactly_ $byte_count _bytes_to_hex>](&sut),
                        hex_encode(&bytes)
                    );
                }
            }
        }
    };
}

decl_exactly_n_bytes!(
    /// 29 bytes, typically used as PublicKeyHash, or otherwise NodeId payload,
    /// implementation wise those bytes are stored inside a `BagOfBytes`
    /// (wrapper of `Vec<u8>`) for UniFFI compat.
    29
);

decl_exactly_n_bytes!(
    /// 32 bytes, most commonly used fixed length bytes, used by PrivateKeys,
    /// Ed25519PublicKey, and BIP39 entropy, implementation wise those bytes are
    /// stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
    32
);

decl_exactly_n_bytes!(
    /// 64 bytes, used by Ed25519Signatures, implementation wise those bytes are
    /// stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
    64
);

decl_exactly_n_bytes!(
    /// 33 bytes, used by Secp256k1PublicKeys, implementation wise those bytes are
    /// stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
    33
);

decl_exactly_n_bytes!(
    /// 65 bytes, used by Secp256k1Signatures, implementation wise those bytes are
    /// stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
    65
);

impl From<Hash> for Exactly32Bytes {
    /// Instantiates a new `ExactlyNBytes<N>` from the `Hash` (N bytes).
    fn from(value: Hash) -> Self {
        Self::from(&value.into_bytes())
    }
}

#[cfg(test)]
mod tests_exactly32_bytes_simple_soundness {

    use crate::prelude::*;

    #[allow(clippy::upper_case_acronyms)]
    type SUT = Exactly32Bytes;

    #[test]
    fn from_string_roundtrip() {
        let str =
            "0000000000000000000000000000000000000000000000000000000000000000";
        assert_eq!(SUT::from_hex(str).unwrap().to_string(), str);
    }

    #[test]
    fn debug() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::sample();
        assert_eq!(format!("{:?}", hex_bytes), str);
    }

    #[test]
    fn display() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::sample();
        assert_eq!(format!("{}", hex_bytes), str);
    }

    #[test]
    fn to_hex() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::sample();
        assert_eq!(hex_bytes.to_string(), str);
    }

    #[test]
    fn as_ref() {
        let b: &[u8] = &hex_decode(
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead",
        )
        .unwrap();
        assert_eq!(SUT::try_from(b).unwrap().as_ref(), b);
    }

    #[test]
    fn json_roundtrip() {
        let model = SUT::sample();
        assert_json_value_eq_after_roundtrip(
            &model,
            json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"),
        );
    }

    #[test]
    fn json_roundtrip_fails_for_invalid() {
        assert_json_value_fails::<SUT>(json!("not even hex"));
        assert_json_value_fails::<SUT>(json!("deadbeef"));
        assert_json_value_fails::<SUT>(json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"));
    }
}

// Copy paste

#[cfg(test)]
mod tests_exactly64_bytes_simple_soundness {

    use crate::prelude::*;

    #[allow(clippy::upper_case_acronyms)]
    type SUT = Exactly64Bytes;

    #[test]
    fn from_string_roundtrip() {
        let str =
            "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002";
        assert_eq!(SUT::from_hex(str).unwrap().to_string(), str);
    }

    #[test]
    fn debug() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::sample();
        assert_eq!(format!("{:?}", hex_bytes), str);
    }

    #[test]
    fn display() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::sample();
        assert_eq!(format!("{}", hex_bytes), str);
    }

    #[test]
    fn to_hex() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::sample();
        assert_eq!(hex_bytes.to_string(), str);
    }

    #[test]
    fn json_roundtrip() {
        let model = SUT::sample();
        assert_json_value_eq_after_roundtrip(
            &model,
            json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"),
        );
    }

    #[test]
    fn json_roundtrip_fails_for_invalid() {
        assert_json_value_fails::<SUT>(json!("not even hex"));
        assert_json_value_fails::<SUT>(json!("deadbeef"));
        assert_json_value_fails::<SUT>(json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"));
    }
}
