use crate::prelude::*;
use delegate::delegate;
use paste::*;
use radix_engine_common::crypto::{Hash, IsHash};

macro_rules! decl_bag_of_n_bytes {
    (
        $(
            #[doc = $expr: expr]
        )*
        $byte_count:literal
    ) => {
        paste! {
            $(
                #[doc = $expr]
            )*
            #[derive(
                Clone,
                PartialEq,
                Eq,
                Hash,
                SerializeDisplay,
                DeserializeFromStr,
                derive_more::Display,
                derive_more::Debug,
                uniffi::Record,
            )]
            #[display("{}", self.to_hex())]
            #[debug("{}", self.to_hex())]
            pub struct [< Hex $byte_count Bytes  >] {
                bag_of_bytes: BagOfBytes,
            }

            impl TryFrom<BagOfBytes> for [< Hex $byte_count Bytes  >] {
                type Error = CommonError;

                fn try_from(value: BagOfBytes) -> Result<Self> {
                    if value.len() != $byte_count {
                        return Err(CommonError::InvalidByteCount {
                            expected: $byte_count as u64,
                            found: value.len() as u64,
                        });
                    }
                    Ok(Self {
                        bag_of_bytes: value,
                    })
                }
            }

            impl [< Hex $byte_count Bytes  >] {

                /// Instantiates a new `BagOfBytes` from bytes generated by
                /// a CSPRNG.
                pub fn generate() -> Self {
                    [< Hex $byte_count Bytes  >] {
                        bag_of_bytes: BagOfBytes::from(
                            generate_bytes::<$byte_count>(),
                        ),
                    }
                }

                /// Tries to decode the string `s` into a `[< Hex $byte_count Bytes  >]`. Will fail
                /// if the string is not valid hex or if the decoded bytes does
                /// not have length `$byte_count`.
                pub fn from_hex(s: &str) -> Result<Self> {
                    Self::from_str(s)
                }

                /// Instantiates a new `[< Hex $byte_count Bytes  >]` from the $byte_count bytes, by cloning them.
                pub fn from_bytes(bytes: &[u8; $byte_count]) -> Self {
                    let bytes: &[u8] = bytes.as_slice().into();
                    let bag_of_bytes: BagOfBytes = bytes.into();
                    Self { bag_of_bytes }
                }
            }

            impl [< Hex $byte_count Bytes  >] {
                /// Returns a references to the inner array slice.
                pub fn bytes(&self) -> [u8; $byte_count] {
                    self.bag_of_bytes
                        .to_vec()
                        .as_slice()
                        .try_into()
                        .expect("$byte_count bytes")
                }
            }

            impl TryFrom<Vec<u8>> for [< Hex $byte_count Bytes  >] {
                type Error = CommonError;

                fn try_from(value: Vec<u8>) -> Result<Self> {
                    BagOfBytes::from(value).try_into()
                }
            }

            impl FromStr for [< Hex $byte_count Bytes  >] {
                type Err = CommonError;

                fn from_str(s: &str) -> Result<Self, Self::Err> {
                    s.parse::<BagOfBytes>().and_then(|v| v.try_into())
                }
            }

            impl [< Hex $byte_count Bytes  >] {
                delegate! {
                    to self.bag_of_bytes{
                        pub fn to_hex(&self) -> String;
                        pub fn to_vec(&self) -> Vec<u8>;
                    }
                }
            }
        }
    };
}

decl_bag_of_n_bytes!(
    /// 29 bytes, typically used as PublicKeyHash, or otherwise NodeId payload,
    /// implementation wise those bytes are stored inside a `BagOfBytes`
    /// (wrapper of `Vec<u8>`) for UniFFI compat.
    29
);

decl_bag_of_n_bytes!(
    /// 32 bytes, most commonly used fixed length bytes, used by PrivateKeys,
    /// Ed25519PublicKey, and BIP39 entropy, implementation wise those bytes are
    /// stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
    32
);

decl_bag_of_n_bytes!(
    /// 64 bytes, used by Ed25519Signatures, implementation wise those bytes are
    /// stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
    64
);

decl_bag_of_n_bytes!(
    /// 33 bytes, used by Secp256k1PublicKeys, implementation wise those bytes are
    /// stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
    33
);

decl_bag_of_n_bytes!(
    /// 65 bytes, used by Secp256k1Signatures, implementation wise those bytes are
    /// stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
    65
);

macro_rules! decl_placeholders_for_bag_of_n_bytes {
    ($struct_name:ident, $byte_count:expr) => {
        impl HasPlaceholder for $struct_name {
            /// `deadbeef...``
            /// A placeholder used to facilitate unit tests.
            fn placeholder() -> Self {
                Self::placeholder_dead()
            }

            /// A placeholder used to facilitate unit tests.
            fn placeholder_other() -> Self {
                Self::placeholder_fade()
            }
        }

        impl $struct_name {
            /// `aced...``
            /// A placeholder used to facilitate unit tests.
            pub fn placeholder_aced() -> Self {
                Self::from_str(&"aced".repeat($byte_count / 2))
                    .expect("aced...")
            }

            /// `babe...``
            /// A placeholder used to facilitate unit tests.
            pub fn placeholder_babe() -> Self {
                Self::from_str(&"babe".repeat($byte_count / 2))
                    .expect("babe...")
            }

            /// `cafe...``
            /// A placeholder used to facilitate unit tests.
            pub fn placeholder_cafe() -> Self {
                Self::from_str(&"cafe".repeat($byte_count / 2))
                    .expect("cafe...")
            }

            /// `dead...``
            /// A placeholder used to facilitate unit tests.
            pub fn placeholder_dead() -> Self {
                Self::from_str(&"dead".repeat($byte_count / 2))
                    .expect("dead...")
            }

            /// `ecad...``
            /// A placeholder used to facilitate unit tests.
            pub fn placeholder_ecad() -> Self {
                Self::from_str(&"ecad".repeat(16)).expect("ecad...")
            }

            /// `fade...``
            /// A placeholder used to facilitate unit tests.
            pub fn placeholder_fade() -> Self {
                Self::from_str(&"fade".repeat($byte_count / 2))
                    .expect("fade...")
            }
        }
    };
}

// The impl of placeholders require an equal number of bytes
decl_placeholders_for_bag_of_n_bytes!(Hex32Bytes, 32);
decl_placeholders_for_bag_of_n_bytes!(Hex64Bytes, 64);

impl HasPlaceholder for Hex33Bytes {
    /// `33deadbeefdead...``
    /// A placeholder used to facilitate unit tests.
    fn placeholder() -> Self {
        let s = "dead".repeat(16);
        Self::from_str(&format!("33{s}"))
            .expect("Should have declared a valid Hex33Bytes placeholder")
    }

    /// `33beefbeefbeef...``
    /// Another placeholder used to facilitate unit tests.
    fn placeholder_other() -> Self {
        let s = "beef".repeat(16);
        Self::from_str(&format!("33{s}"))
            .expect("Should have declared a valid Hex33Bytes placeholder")
    }
}

impl HasPlaceholder for Hex65Bytes {
    /// `65deadbeefdead...``
    /// A placeholder used to facilitate unit tests.
    fn placeholder() -> Self {
        let s = "dead".repeat(32);
        Self::from_str(&format!("65{s}"))
            .expect("Should have declared a valid Hex65Bytes placeholder")
    }

    /// `65beefbeefbeef...``
    /// Another placeholder used to facilitate unit tests.
    fn placeholder_other() -> Self {
        let s = "beef".repeat(32);
        Self::from_str(&format!("65{s}"))
            .expect("Should have declared a valid Hex65Bytes placeholder")
    }
}

impl HasPlaceholder for Hex29Bytes {
    /// `29deadbeefdead...``
    /// A placeholder used to facilitate unit tests.
    fn placeholder() -> Self {
        let s = "dead".repeat(14);
        Self::from_str(&format!("29{s}"))
            .expect("Should have declared a valid Hex29Bytes placeholder")
    }

    /// `20beefbeefbeef...``
    /// Another placeholder used to facilitate unit tests.
    fn placeholder_other() -> Self {
        let s = "beef".repeat(14);
        Self::from_str(&format!("29{s}"))
            .expect("Should have declared a valid Hex29Bytes placeholder")
    }
}

#[uniffi::export]
pub fn new_hex32_bytes_from(bytes: Vec<u8>) -> Result<Hex32Bytes> {
    Hex32Bytes::try_from(bytes)
}

#[uniffi::export]
pub fn new_hex32_bytes_from_bag(
    bag_of_bytes: BagOfBytes,
) -> Result<Hex32Bytes> {
    Hex32Bytes::try_from(bag_of_bytes)
}

impl From<Hash> for Hex32Bytes {
    /// Instantiates a new `[< Hex $byte_count Bytes  >]` from the `Hash` ($byte_count bytes).
    fn from(value: Hash) -> Self {
        Self::from_bytes(&value.into_bytes())
    }
}

#[uniffi::export]
pub fn new_hex64_bytes_from(bytes: Vec<u8>) -> Result<Hex64Bytes> {
    Hex64Bytes::try_from(bytes)
}
#[uniffi::export]
pub fn new_hex64_bytes_from_bag(
    bag_of_bytes: BagOfBytes,
) -> Result<Hex64Bytes> {
    Hex64Bytes::try_from(bag_of_bytes)
}

#[uniffi::export]
pub fn new_hex33_bytes_from(bytes: Vec<u8>) -> Result<Hex33Bytes> {
    Hex33Bytes::try_from(bytes)
}

#[uniffi::export]
pub fn new_hex33_bytes_from_bag(
    bag_of_bytes: BagOfBytes,
) -> Result<Hex33Bytes> {
    Hex33Bytes::try_from(bag_of_bytes)
}

#[uniffi::export]
pub fn new_hex65_bytes_from(bytes: Vec<u8>) -> Result<Hex65Bytes> {
    Hex65Bytes::try_from(bytes)
}

#[uniffi::export]
pub fn new_hex65_bytes_from_bag(
    bag_of_bytes: BagOfBytes,
) -> Result<Hex65Bytes> {
    Hex65Bytes::try_from(bag_of_bytes)
}

#[uniffi::export]
pub fn new_hex29_bytes_from(bytes: Vec<u8>) -> Result<Hex29Bytes> {
    Hex29Bytes::try_from(bytes)
}

#[uniffi::export]
pub fn new_hex29_bytes_from_bag(
    bag_of_bytes: BagOfBytes,
) -> Result<Hex29Bytes> {
    Hex29Bytes::try_from(bag_of_bytes)
}

#[cfg(test)]
mod tests_hex32_bytes {

    use crate::prelude::*;

    #[allow(clippy::upper_case_acronyms)]
    type SUT = Hex32Bytes;

    #[test]
    fn equality() {
        assert_eq!(SUT::placeholder(), SUT::placeholder());
        assert_eq!(SUT::placeholder_other(), SUT::placeholder_other());
    }

    #[test]
    fn inequality() {
        assert_ne!(SUT::placeholder(), SUT::placeholder_other());
    }

    #[test]
    fn from_string_roundtrip() {
        let str =
            "0000000000000000000000000000000000000000000000000000000000000000";
        assert_eq!(SUT::from_hex(str).unwrap().to_string(), str);
    }

    #[test]
    fn debug() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(format!("{:?}", hex_bytes), str);
    }

    #[test]
    fn display() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(format!("{}", hex_bytes), str);
    }

    #[test]
    fn to_hex() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(hex_bytes.to_string(), str);
    }

    #[test]
    fn json_roundtrip() {
        let model = SUT::placeholder();
        assert_json_value_eq_after_roundtrip(
            &model,
            json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"),
        );
    }

    #[test]
    fn json_roundtrip_fails_for_invalid() {
        assert_json_value_fails::<SUT>(json!("not even hex"));
        assert_json_value_fails::<SUT>(json!("deadbeef"));
        assert_json_value_fails::<SUT>(json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"));
    }

    #[test]
    fn from_bytes_roundtrip() {
        let bytes = [0u8; 32];
        assert_eq!(SUT::from_bytes(&bytes).bytes(), bytes);
    }

    #[test]
    fn from_vec_roundtrip() {
        let vec = Vec::from([0u8; 32]);
        let sut: SUT = vec.clone().try_into().unwrap();
        assert_eq!(sut.to_vec(), vec);
    }

    #[test]
    fn invalid_str() {
        let s = "invalid str";
        assert_eq!(
            SUT::from_str(s),
            Err(CommonError::StringNotHex {
                bad_value: s.to_owned()
            })
        );
    }

    #[test]
    fn invalid_len() {
        assert_eq!(
            SUT::try_from(Vec::from([0u8; 5])),
            Err(CommonError::InvalidByteCount {
                expected: 32,
                found: 5
            })
        )
    }

    #[test]
    fn random() {
        let mut set: HashSet<Vec<u8>> = HashSet::new();
        let n = 100;
        for _ in 0..n {
            let bytes = SUT::generate();
            set.insert(bytes.to_vec());
        }
        assert_eq!(set.len(), n);
    }
}

#[cfg(test)]
mod hex32_uniffi_tests {
    use crate::prelude::*;

    #[test]
    fn new_ok() {
        let bytes = generate_32_bytes();
        assert_eq!(
            new_hex32_bytes_from(bytes.clone()).unwrap().to_vec(),
            bytes
        );
    }

    #[test]
    fn new_from_bag_of_bytes() {
        let bytes = generate_bytes::<32>();
        assert_eq!(
            new_hex32_bytes_from_bag(bytes.clone().into())
                .unwrap()
                .to_vec(),
            bytes
        );
    }

    #[test]
    fn new_fail() {
        assert!(new_hex32_bytes_from(generate_bytes::<5>()).is_err());
    }
}

// Copy paste

#[cfg(test)]
mod tests_hex64_bytes {

    use crate::prelude::*;

    #[allow(clippy::upper_case_acronyms)]
    type SUT = Hex64Bytes;

    #[test]
    fn equality() {
        assert_eq!(SUT::placeholder(), SUT::placeholder());
        assert_eq!(SUT::placeholder_other(), SUT::placeholder_other());
    }

    #[test]
    fn inequality() {
        assert_ne!(SUT::placeholder(), SUT::placeholder_other());
    }

    #[test]
    fn from_string_roundtrip() {
        let str =
            "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002";
        assert_eq!(SUT::from_hex(str).unwrap().to_string(), str);
    }

    #[test]
    fn debug() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(format!("{:?}", hex_bytes), str);
    }

    #[test]
    fn display() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(format!("{}", hex_bytes), str);
    }

    #[test]
    fn to_hex() {
        let str =
            "deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(hex_bytes.to_string(), str);
    }

    #[test]
    fn json_roundtrip() {
        let model = SUT::placeholder();
        assert_json_value_eq_after_roundtrip(
            &model,
            json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"),
        );
    }

    #[test]
    fn json_roundtrip_fails_for_invalid() {
        assert_json_value_fails::<SUT>(json!("not even hex"));
        assert_json_value_fails::<SUT>(json!("deadbeef"));
        assert_json_value_fails::<SUT>(json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"));
    }

    #[test]
    fn from_bytes_roundtrip() {
        let bytes = [0u8; 64];
        assert_eq!(SUT::from_bytes(&bytes).bytes(), bytes);
    }

    #[test]
    fn from_vec_roundtrip() {
        let vec = Vec::from([0u8; 64]);
        let sut: SUT = vec.clone().try_into().unwrap();
        assert_eq!(sut.to_vec(), vec);
    }

    #[test]
    fn invalid_str() {
        let s = "invalid str";
        assert_eq!(
            SUT::from_str(s),
            Err(CommonError::StringNotHex {
                bad_value: s.to_owned()
            })
        );
    }

    #[test]
    fn invalid_len() {
        assert_eq!(
            SUT::try_from(Vec::from([0u8; 5])),
            Err(CommonError::InvalidByteCount {
                expected: 64,
                found: 5
            })
        )
    }

    #[test]
    fn random() {
        let mut set: HashSet<Vec<u8>> = HashSet::new();
        let n = 100;
        for _ in 0..n {
            let bytes = SUT::generate();
            set.insert(bytes.to_vec());
        }
        assert_eq!(set.len(), n);
    }
}

#[cfg(test)]
mod hex64_uniffi_tests {
    use crate::prelude::*;

    #[test]
    fn new_ok() {
        let bytes = generate_64_bytes();
        assert_eq!(
            new_hex64_bytes_from(bytes.clone()).unwrap().to_vec(),
            bytes
        );
    }

    #[test]
    fn new_from_bag_of_bytes() {
        let bytes = generate_bytes::<64>();
        assert_eq!(
            new_hex64_bytes_from_bag(bytes.clone().into())
                .unwrap()
                .to_vec(),
            bytes
        );
    }

    #[test]
    fn new_fail() {
        assert!(new_hex64_bytes_from(generate_bytes::<5>()).is_err());
    }
}

// Copy paste

#[cfg(test)]
mod tests_hex33_bytes {

    use crate::prelude::*;

    #[allow(clippy::upper_case_acronyms)]
    type SUT = Hex33Bytes;

    #[test]
    fn equality() {
        assert_eq!(SUT::placeholder(), SUT::placeholder());
        assert_eq!(SUT::placeholder_other(), SUT::placeholder_other());
    }

    #[test]
    fn inequality() {
        assert_ne!(SUT::placeholder(), SUT::placeholder_other());
    }

    #[test]
    fn from_string_roundtrip() {
        let str =
            "100000000000000000000000000000000000000000000000000000000000000002";
        assert_eq!(SUT::from_hex(str).unwrap().to_string(), str);
    }

    #[test]
    fn debug() {
        let str =
            "33deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(format!("{:?}", hex_bytes), str);
    }

    #[test]
    fn display() {
        let str =
            "33deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(format!("{}", hex_bytes), str);
    }

    #[test]
    fn to_hex() {
        let str =
            "33deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(hex_bytes.to_string(), str);
    }

    #[test]
    fn json_roundtrip() {
        let model = SUT::placeholder();
        assert_json_value_eq_after_roundtrip(
            &model,
            json!("33deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"),
        );
    }

    #[test]
    fn json_roundtrip_fails_for_invalid() {
        assert_json_value_fails::<SUT>(json!("not even hex"));
        assert_json_value_fails::<SUT>(json!("deadbeef"));
        assert_json_value_fails::<SUT>(json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"));
    }

    #[test]
    fn from_bytes_roundtrip() {
        let bytes = [0u8; 33];
        assert_eq!(SUT::from_bytes(&bytes).bytes(), bytes);
    }

    #[test]
    fn from_vec_roundtrip() {
        let vec = Vec::from([0u8; 33]);
        let sut: SUT = vec.clone().try_into().unwrap();
        assert_eq!(sut.to_vec(), vec);
    }

    #[test]
    fn invalid_str() {
        let s = "invalid str";
        assert_eq!(
            SUT::from_str(s),
            Err(CommonError::StringNotHex {
                bad_value: s.to_owned()
            })
        );
    }

    #[test]
    fn invalid_len() {
        assert_eq!(
            SUT::try_from(Vec::from([0u8; 5])),
            Err(CommonError::InvalidByteCount {
                expected: 33,
                found: 5
            })
        )
    }

    #[test]
    fn random() {
        let mut set: HashSet<Vec<u8>> = HashSet::new();
        let n = 100;
        for _ in 0..n {
            let bytes = SUT::generate();
            set.insert(bytes.to_vec());
        }
        assert_eq!(set.len(), n);
    }
}

#[cfg(test)]
mod hex33_uniffi_tests {
    use crate::prelude::*;

    #[test]
    fn new_ok() {
        let bytes = generate_bytes::<33>();
        assert_eq!(
            new_hex33_bytes_from(bytes.clone()).unwrap().to_vec(),
            bytes
        );
    }

    #[test]
    fn new_from_bag_of_bytes() {
        let bytes = generate_bytes::<33>();
        assert_eq!(
            new_hex33_bytes_from_bag(bytes.clone().into())
                .unwrap()
                .to_vec(),
            bytes
        );
    }

    #[test]
    fn new_fail() {
        assert!(new_hex33_bytes_from(generate_bytes::<5>()).is_err());
    }
}

// Copy paste

#[cfg(test)]
mod tests_hex65_bytes {

    use crate::prelude::*;

    #[allow(clippy::upper_case_acronyms)]
    type SUT = Hex65Bytes;

    #[test]
    fn equality() {
        assert_eq!(SUT::placeholder(), SUT::placeholder());
        assert_eq!(SUT::placeholder_other(), SUT::placeholder_other());
    }

    #[test]
    fn inequality() {
        assert_ne!(SUT::placeholder(), SUT::placeholder_other());
    }

    #[test]
    fn from_string_roundtrip() {
        let str =
            "6510000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002";
        assert_eq!(SUT::from_hex(str).unwrap().to_string(), str);
    }

    #[test]
    fn debug() {
        let str =
            "65deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(format!("{:?}", hex_bytes), str);
    }

    #[test]
    fn display() {
        let str =
            "65deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(format!("{}", hex_bytes), str);
    }

    #[test]
    fn to_hex() {
        let str =
            "65deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(hex_bytes.to_string(), str);
    }

    #[test]
    fn json_roundtrip() {
        let model = SUT::placeholder();
        assert_json_value_eq_after_roundtrip(
            &model,
            json!("65deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"),
        );
    }

    #[test]
    fn json_roundtrip_fails_for_invalid() {
        assert_json_value_fails::<SUT>(json!("not even hex"));
        assert_json_value_fails::<SUT>(json!("deadbeef"));
        assert_json_value_fails::<SUT>(json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"));
    }

    #[test]
    fn from_bytes_roundtrip() {
        let bytes = [0u8; 65];
        assert_eq!(SUT::from_bytes(&bytes).bytes(), bytes);
    }

    #[test]
    fn from_vec_roundtrip() {
        let vec = Vec::from([0u8; 65]);
        let sut: SUT = vec.clone().try_into().unwrap();
        assert_eq!(sut.to_vec(), vec);
    }

    #[test]
    fn invalid_str() {
        let s = "invalid str";
        assert_eq!(
            SUT::from_str(s),
            Err(CommonError::StringNotHex {
                bad_value: s.to_owned()
            })
        );
    }

    #[test]
    fn invalid_len() {
        assert_eq!(
            SUT::try_from(Vec::from([0u8; 5])),
            Err(CommonError::InvalidByteCount {
                expected: 65,
                found: 5
            })
        )
    }

    #[test]
    fn random() {
        let mut set: HashSet<Vec<u8>> = HashSet::new();
        let n = 100;
        for _ in 0..n {
            let bytes = SUT::generate();
            set.insert(bytes.to_vec());
        }
        assert_eq!(set.len(), n);
    }
}

#[cfg(test)]
mod hex65_uniffi_tests {
    use crate::prelude::*;

    #[test]
    fn new_ok() {
        let bytes = generate_bytes::<65>();
        assert_eq!(
            new_hex65_bytes_from(bytes.clone()).unwrap().to_vec(),
            bytes
        );
    }

    #[test]
    fn new_from_bag_of_bytes() {
        let bytes = generate_bytes::<65>();
        assert_eq!(
            new_hex65_bytes_from_bag(bytes.clone().into())
                .unwrap()
                .to_vec(),
            bytes
        );
    }

    #[test]
    fn new_fail() {
        assert!(new_hex65_bytes_from(generate_bytes::<5>()).is_err());
    }
}

// Copy paste

#[cfg(test)]
mod tests_hex29_bytes {

    use crate::prelude::*;

    #[allow(clippy::upper_case_acronyms)]
    type SUT = Hex29Bytes;

    #[test]
    fn equality() {
        assert_eq!(SUT::placeholder(), SUT::placeholder());
        assert_eq!(SUT::placeholder_other(), SUT::placeholder_other());
    }

    #[test]
    fn inequality() {
        assert_ne!(SUT::placeholder(), SUT::placeholder_other());
    }

    #[test]
    fn from_string_roundtrip() {
        let str = "29deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        assert_eq!(SUT::from_hex(str).unwrap().to_string(), str);
    }

    #[test]
    fn debug() {
        let str = "29deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(format!("{:?}", hex_bytes), str);
    }

    #[test]
    fn display() {
        let str = "29deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(format!("{}", hex_bytes), str);
    }

    #[test]
    fn to_hex() {
        let str = "29deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead";
        let hex_bytes = SUT::placeholder();
        assert_eq!(hex_bytes.to_string(), str);
    }

    #[test]
    fn json_roundtrip() {
        let model = SUT::placeholder();
        assert_json_value_eq_after_roundtrip(
            &model,
            json!("29deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"),
        );
    }

    #[test]
    fn json_roundtrip_fails_for_invalid() {
        assert_json_value_fails::<SUT>(json!("not even hex"));
        assert_json_value_fails::<SUT>(json!("deadbeef"));
        assert_json_value_fails::<SUT>(json!("deaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddeaddead"));
    }

    #[test]
    fn from_bytes_roundtrip() {
        let bytes = [0u8; 29];
        assert_eq!(SUT::from_bytes(&bytes).bytes(), bytes);
    }

    #[test]
    fn from_vec_roundtrip() {
        let vec = Vec::from([0u8; 29]);
        let sut: SUT = vec.clone().try_into().unwrap();
        assert_eq!(sut.to_vec(), vec);
    }

    #[test]
    fn invalid_str() {
        let s = "invalid str";
        assert_eq!(
            SUT::from_str(s),
            Err(CommonError::StringNotHex {
                bad_value: s.to_owned()
            })
        );
    }

    #[test]
    fn invalid_len() {
        assert_eq!(
            SUT::try_from(Vec::from([0u8; 5])),
            Err(CommonError::InvalidByteCount {
                expected: 29,
                found: 5
            })
        )
    }

    #[test]
    fn random() {
        let mut set: HashSet<Vec<u8>> = HashSet::new();
        let n = 100;
        for _ in 0..n {
            let bytes = SUT::generate();
            set.insert(bytes.to_vec());
        }
        assert_eq!(set.len(), n);
    }
}

#[cfg(test)]
mod hex29_uniffi_tests {
    use crate::prelude::*;

    #[test]
    fn new_ok() {
        let bytes = generate_bytes::<29>();
        assert_eq!(
            new_hex29_bytes_from(bytes.clone()).unwrap().to_vec(),
            bytes
        );
    }

    #[test]
    fn new_from_bag_of_bytes() {
        let bytes = generate_bytes::<29>();
        assert_eq!(
            new_hex29_bytes_from_bag(bytes.clone().into())
                .unwrap()
                .to_vec(),
            bytes
        );
    }

    #[test]
    fn new_fail() {
        assert!(new_hex29_bytes_from(generate_bytes::<5>()).is_err());
    }
}
