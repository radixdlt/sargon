// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(SargonFFI)
    import SargonFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_sargon_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_sargon_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

private struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return try Data(readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

public protocol SecureStorage: AnyObject {
    func loadData(key: SecureStorageKey) throws -> Data?

    func saveData(key: SecureStorageKey, data: Data) throws

    func deleteDataForKey(key: SecureStorageKey) throws
}

public class SecureStorageImpl:
    SecureStorage
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_securestorage(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_sargon_fn_free_securestorage(pointer, $0) }
    }

    public func loadData(key: SecureStorageKey) throws -> Data? {
        return try FfiConverterOptionData.lift(
            rustCallWithError(FfiConverterTypeCommonError.lift) {
                uniffi_sargon_fn_method_securestorage_load_data(self.uniffiClonePointer(),
                                                                FfiConverterTypeSecureStorageKey.lower(key), $0)
            }
        )
    }

    public func saveData(key: SecureStorageKey, data: Data) throws {
        try
            rustCallWithError(FfiConverterTypeCommonError.lift) {
                uniffi_sargon_fn_method_securestorage_save_data(self.uniffiClonePointer(),
                                                                FfiConverterTypeSecureStorageKey.lower(key),
                                                                FfiConverterData.lower(data), $0)
            }
    }

    public func deleteDataForKey(key: SecureStorageKey) throws {
        try
            rustCallWithError(FfiConverterTypeCommonError.lift) {
                uniffi_sargon_fn_method_securestorage_delete_data_for_key(self.uniffiClonePointer(),
                                                                          FfiConverterTypeSecureStorageKey.lower(key), $0)
            }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private typealias UniFFICallbackHandle = UInt64
private class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 1
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for SecureStorage Callback Interface

private let uniffiCallbackInterfaceSecureStorage: ForeignCallback = { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in

    func invokeLoadData(_ swiftCallbackInterface: SecureStorage, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result = try swiftCallbackInterface.loadData(
                key: FfiConverterTypeSecureStorageKey.read(from: &reader)
            )
            var writer = [UInt8]()
            FfiConverterOptionData.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        do {
            return try makeCall()
        } catch let error as CommonError {
            out_buf.pointee = FfiConverterTypeCommonError.lower(error)
            return UNIFFI_CALLBACK_ERROR
        }
    }

    func invokeSaveData(_ swiftCallbackInterface: SecureStorage, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.saveData(
                key: FfiConverterTypeSecureStorageKey.read(from: &reader),
                data: FfiConverterData.read(from: &reader)
            )
            return UNIFFI_CALLBACK_SUCCESS
        }
        do {
            return try makeCall()
        } catch let error as CommonError {
            out_buf.pointee = FfiConverterTypeCommonError.lower(error)
            return UNIFFI_CALLBACK_ERROR
        }
    }

    func invokeDeleteDataForKey(_ swiftCallbackInterface: SecureStorage, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.deleteDataForKey(
                key: FfiConverterTypeSecureStorageKey.read(from: &reader)
            )
            return UNIFFI_CALLBACK_SUCCESS
        }
        do {
            return try makeCall()
        } catch let error as CommonError {
            out_buf.pointee = FfiConverterTypeCommonError.lower(error)
            return UNIFFI_CALLBACK_ERROR
        }
    }

    switch method {
    case IDX_CALLBACK_FREE:
        FfiConverterTypeSecureStorage.handleMap.remove(handle: handle)
        // Successful return
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_SUCCESS
    case 1:
        guard let cb = FfiConverterTypeSecureStorage.handleMap.get(handle: handle) else {
            out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
        do {
            return try invokeLoadData(cb, argsData, argsLen, out_buf)
        } catch {
            out_buf.pointee = FfiConverterString.lower(String(describing: error))
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
    case 2:
        guard let cb = FfiConverterTypeSecureStorage.handleMap.get(handle: handle) else {
            out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
        do {
            return try invokeSaveData(cb, argsData, argsLen, out_buf)
        } catch {
            out_buf.pointee = FfiConverterString.lower(String(describing: error))
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
    case 3:
        guard let cb = FfiConverterTypeSecureStorage.handleMap.get(handle: handle) else {
            out_buf.pointee = FfiConverterString.lower("No callback in handlemap; this is a Uniffi bug")
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }
        do {
            return try invokeDeleteDataForKey(cb, argsData, argsLen, out_buf)
        } catch {
            out_buf.pointee = FfiConverterString.lower(String(describing: error))
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
        }

    // This should never happen, because an out of bounds method index won't
    // ever be used. Once we can catch errors, we should return an InternalError.
    // https://github.com/mozilla/uniffi-rs/issues/351
    default:
        // An unexpected error happened.
        // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
        return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

private func uniffiCallbackInitSecureStorage() {
    uniffi_sargon_fn_init_callback_securestorage(uniffiCallbackInterfaceSecureStorage)
}

public struct FfiConverterTypeSecureStorage: FfiConverter {
    fileprivate static var handleMap = UniFFICallbackHandleMap<SecureStorage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SecureStorage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecureStorage {
        return SecureStorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SecureStorage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SecureStorage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeSecureStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecureStorage {
    return try FfiConverterTypeSecureStorage.lift(pointer)
}

public func FfiConverterTypeSecureStorage_lower(_ value: SecureStorage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSecureStorage.lower(value)
}

public protocol WalletProtocol: AnyObject {
    /**
     * Returns `Ok(())` if the `account` was new and successfully added. If saving failed or if the account was already present in Profile, an
     * error is returned.
     */
    func addAccount(account: Account) throws

    /**
     * Updates the display name of account with the provided address, throws an error if the account is unknown to the wallet.
     */
    func changeNameOfAccount(address: AccountAddress, to: DisplayName) throws -> Account

    /**
     * Create a new Account and adds it to the active Profile.
     */
    func createAndSaveNewAccount(networkId: NetworkId, name: DisplayName) throws -> Account

    /**
     * Creates a new non securified account **WITHOUT** add it to Profile, using the *main* "Babylon"
     * `DeviceFactorSource` and the "next" index for this FactorSource as derivation path.
     *
     * If you want to add it to Profile, call `wallet.add_account(account)`
     */
    func createNewAccount(networkId: NetworkId, name: DisplayName) throws -> Account

    /**
     * Takes a snapshot of the profile and serialize it as a String of JSON.
     */
    func jsonSnapshot() -> String

    /**
     * Tries to load the  `MnemonicWithPassphrase` for the main "Babylon"
     * `DeviceFactorSource` from secure storage.
     */
    func mainBdfsMnemonicWithPassphrase() throws -> MnemonicWithPassphrase

    /**
     * Tries to load a `MnemonicWithPassphrase` from secure storage
     * by `factor_source_id`.
     */
    func mnemonicWithPassphraseOfDeviceFactorSourceByFactorSourceId(factorSourceId: FactorSourceId) throws -> MnemonicWithPassphrase

    /**
     * Clone the profile and return it.
     */
    func profile() -> Profile

    /**
     * Updates `account` as a whole, if it exists, else an error is thrown.
     */
    func updateAccount(to: Account) throws -> Account
}

public class Wallet:
    WalletProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_wallet(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_sargon_fn_free_wallet(pointer, $0) }
    }

    /**
     * Creates a new Mnemonic from `entropy` (without BIP39 passphrase) and creates a new Profile,
     * saving both the Mnemonic and Profile into secure storage and returns a new Wallet.
     */
    public static func byCreatingNewProfileAndSecretsWithEntropy(entropy: Data, walletClientModel: WalletClientModel, walletClientName: String, secureStorage: SecureStorage) throws -> Wallet {
        return try Wallet(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_constructor_wallet_by_creating_new_profile_and_secrets_with_entropy(
                FfiConverterData.lower(entropy),
                FfiConverterTypeWalletClientModel.lower(walletClientModel),
                FfiConverterString.lower(walletClientName),
                FfiConverterTypeSecureStorage.lower(secureStorage), $0
            )
        })
    }

    /**
     * Creates wallet by *importing* a Profile.
     */
    public static func byImportingProfile(profile: Profile, secureStorage: SecureStorage) -> Wallet {
        return Wallet(unsafeFromRawPointer: try! rustCall {
            uniffi_sargon_fn_constructor_wallet_by_importing_profile(
                FfiConverterTypeProfile.lower(profile),
                FfiConverterTypeSecureStorage.lower(secureStorage), $0
            )
        })
    }

    public static func byLoadingProfile(secureStorage: SecureStorage) throws -> Wallet {
        return try Wallet(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_constructor_wallet_by_loading_profile(
                FfiConverterTypeSecureStorage.lower(secureStorage), $0
            )
        })
    }

    public static func byLoadingProfileWithId(profileId: ProfileID, secureStorage: SecureStorage) throws -> Wallet {
        return try Wallet(unsafeFromRawPointer: rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_constructor_wallet_by_loading_profile_with_id(
                FfiConverterTypeProfileID.lower(profileId),
                FfiConverterTypeSecureStorage.lower(secureStorage), $0
            )
        })
    }

    /**
     * Returns `Ok(())` if the `account` was new and successfully added. If saving failed or if the account was already present in Profile, an
     * error is returned.
     */
    public func addAccount(account: Account) throws {
        try
            rustCallWithError(FfiConverterTypeCommonError.lift) {
                uniffi_sargon_fn_method_wallet_add_account(self.uniffiClonePointer(),
                                                           FfiConverterTypeAccount.lower(account), $0)
            }
    }

    /**
     * Updates the display name of account with the provided address, throws an error if the account is unknown to the wallet.
     */
    public func changeNameOfAccount(address: AccountAddress, to: DisplayName) throws -> Account {
        return try FfiConverterTypeAccount.lift(
            rustCallWithError(FfiConverterTypeCommonError.lift) {
                uniffi_sargon_fn_method_wallet_change_name_of_account(self.uniffiClonePointer(),
                                                                      FfiConverterTypeAccountAddress.lower(address),
                                                                      FfiConverterTypeDisplayName.lower(to), $0)
            }
        )
    }

    /**
     * Create a new Account and adds it to the active Profile.
     */
    public func createAndSaveNewAccount(networkId: NetworkId, name: DisplayName) throws -> Account {
        return try FfiConverterTypeAccount.lift(
            rustCallWithError(FfiConverterTypeCommonError.lift) {
                uniffi_sargon_fn_method_wallet_create_and_save_new_account(self.uniffiClonePointer(),
                                                                           FfiConverterTypeNetworkID.lower(networkId),
                                                                           FfiConverterTypeDisplayName.lower(name), $0)
            }
        )
    }

    /**
     * Creates a new non securified account **WITHOUT** add it to Profile, using the *main* "Babylon"
     * `DeviceFactorSource` and the "next" index for this FactorSource as derivation path.
     *
     * If you want to add it to Profile, call `wallet.add_account(account)`
     */
    public func createNewAccount(networkId: NetworkId, name: DisplayName) throws -> Account {
        return try FfiConverterTypeAccount.lift(
            rustCallWithError(FfiConverterTypeCommonError.lift) {
                uniffi_sargon_fn_method_wallet_create_new_account(self.uniffiClonePointer(),
                                                                  FfiConverterTypeNetworkID.lower(networkId),
                                                                  FfiConverterTypeDisplayName.lower(name), $0)
            }
        )
    }

    /**
     * Takes a snapshot of the profile and serialize it as a String of JSON.
     */
    public func jsonSnapshot() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_sargon_fn_method_wallet_json_snapshot(self.uniffiClonePointer(), $0)
                }
        )
    }

    /**
     * Tries to load the  `MnemonicWithPassphrase` for the main "Babylon"
     * `DeviceFactorSource` from secure storage.
     */
    public func mainBdfsMnemonicWithPassphrase() throws -> MnemonicWithPassphrase {
        return try FfiConverterTypeMnemonicWithPassphrase.lift(
            rustCallWithError(FfiConverterTypeCommonError.lift) {
                uniffi_sargon_fn_method_wallet_main_bdfs_mnemonic_with_passphrase(self.uniffiClonePointer(), $0)
            }
        )
    }

    /**
     * Tries to load a `MnemonicWithPassphrase` from secure storage
     * by `factor_source_id`.
     */
    public func mnemonicWithPassphraseOfDeviceFactorSourceByFactorSourceId(factorSourceId: FactorSourceId) throws -> MnemonicWithPassphrase {
        return try FfiConverterTypeMnemonicWithPassphrase.lift(
            rustCallWithError(FfiConverterTypeCommonError.lift) {
                uniffi_sargon_fn_method_wallet_mnemonic_with_passphrase_of_device_factor_source_by_factor_source_id(self.uniffiClonePointer(),
                                                                                                                    FfiConverterTypeFactorSourceID.lower(factorSourceId), $0)
            }
        )
    }

    /**
     * Clone the profile and return it.
     */
    public func profile() -> Profile {
        return try! FfiConverterTypeProfile.lift(
            try!
                rustCall {
                    uniffi_sargon_fn_method_wallet_profile(self.uniffiClonePointer(), $0)
                }
        )
    }

    /**
     * Updates `account` as a whole, if it exists, else an error is thrown.
     */
    public func updateAccount(to: Account) throws -> Account {
        return try FfiConverterTypeAccount.lift(
            rustCallWithError(FfiConverterTypeCommonError.lift) {
                uniffi_sargon_fn_method_wallet_update_account(self.uniffiClonePointer(),
                                                              FfiConverterTypeAccount.lower(to), $0)
            }
        )
    }
}

public struct FfiConverterTypeWallet: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wallet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
        return Wallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Wallet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Wallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Wallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
    return try FfiConverterTypeWallet.lift(pointer)
}

public func FfiConverterTypeWallet_lower(_ value: Wallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWallet.lower(value)
}

public struct AccessControllerAddress {
    public var inner: InnerAccessControllerAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        inner: InnerAccessControllerAddress)
    {
        self.inner = inner
    }
}

extension AccessControllerAddress: Equatable, Hashable {
    public static func == (lhs: AccessControllerAddress, rhs: AccessControllerAddress) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeAccessControllerAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccessControllerAddress {
        return
            try AccessControllerAddress(
                inner: FfiConverterTypeInnerAccessControllerAddress.read(from: &buf)
            )
    }

    public static func write(_ value: AccessControllerAddress, into buf: inout [UInt8]) {
        FfiConverterTypeInnerAccessControllerAddress.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeAccessControllerAddress_lift(_ buf: RustBuffer) throws -> AccessControllerAddress {
    return try FfiConverterTypeAccessControllerAddress.lift(buf)
}

public func FfiConverterTypeAccessControllerAddress_lower(_ value: AccessControllerAddress) -> RustBuffer {
    return FfiConverterTypeAccessControllerAddress.lower(value)
}

/**
 * A network unique account with a unique public address and a set of cryptographic
 * factors used to control it.
 *
 * Used to own and control assets on the radix network. Uniquely identified by an
 * account address, e.g.
 *
 * `account_rdx16xlfcpp0vf7e3gqnswv8j9k58n6rjccu58vvspmdva22kf3aplease`
 *
 * But most commonly users see the address on its abbreviated form:
 *
 * `acco...please`
 *
 * Accounts have a display name and an appearance id.
 *
 * An account can be either controlled by a "Babylon" DeviceFactorSource or a
 * Legacy one imported from Olympia, or a Ledger hardware wallet, which too might
 * have been imported from Olympia.
 */
public struct Account {
    /**
     * The ID of the network this account can be used with.
     */
    public var networkId: NetworkId
    /**
     * A globally unique identifier of this account, being a human readable
     * address of an account. Always starts with `"account_"``, for example:
     *
     * `account_rdx16xlfcpp0vf7e3gqnswv8j9k58n6rjccu58vvspmdva22kf3aplease`
     *
     * Most commonly the user will see this address in its abbreviated
     * form which is:
     *
     * `acco...please`
     *
     * No two addresses will ever be the same even for the same factor source
     * but on different networks, since the public keys controlling the
     * accounts depend on the network id.
     */
    public var address: AccountAddress
    /**
     * An off-ledger display name or description chosen by the user when she
     * created this account.
     */
    public var displayName: DisplayName
    /**
     * Security state of this account, either "securified" or not.
     */
    public var securityState: EntitySecurityState
    /**
     * The visual cue user learns to associated this account with, typically
     * a beautiful colorful gradient.
     */
    public var appearanceId: AppearanceId
    /**
     * An order set of `EntityFlag`s used to describe certain Off-ledger
     * user state about Accounts or Personas, such as if an entity is
     * marked as hidden or not.
     */
    public var flags: [EntityFlag]
    /**
     * The on ledger synced settings for this account, contains e.g.
     * ThirdPartyDeposit settings, with deposit rules for assets.
     */
    public var onLedgerSettings: OnLedgerSettings

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network this account can be used with.
         */
        networkId: NetworkId,
        /**
            * A globally unique identifier of this account, being a human readable
            * address of an account. Always starts with `"account_"``, for example:
            *
            * `account_rdx16xlfcpp0vf7e3gqnswv8j9k58n6rjccu58vvspmdva22kf3aplease`
            *
            * Most commonly the user will see this address in its abbreviated
            * form which is:
            *
            * `acco...please`
            *
            * No two addresses will ever be the same even for the same factor source
            * but on different networks, since the public keys controlling the
            * accounts depend on the network id.
            */
        address: AccountAddress,
        /**
            * An off-ledger display name or description chosen by the user when she
            * created this account.
            */
        displayName: DisplayName,
        /**
            * Security state of this account, either "securified" or not.
            */
        securityState: EntitySecurityState,
        /**
            * The visual cue user learns to associated this account with, typically
            * a beautiful colorful gradient.
            */
        appearanceId: AppearanceId,
        /**
            * An order set of `EntityFlag`s used to describe certain Off-ledger
            * user state about Accounts or Personas, such as if an entity is
            * marked as hidden or not.
            */
        flags: [EntityFlag],
        /**
            * The on ledger synced settings for this account, contains e.g.
            * ThirdPartyDeposit settings, with deposit rules for assets.
            */
        onLedgerSettings: OnLedgerSettings
    ) {
        self.networkId = networkId
        self.address = address
        self.displayName = displayName
        self.securityState = securityState
        self.appearanceId = appearanceId
        self.flags = flags
        self.onLedgerSettings = onLedgerSettings
    }
}

extension Account: Equatable, Hashable {
    public static func == (lhs: Account, rhs: Account) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.securityState != rhs.securityState {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        if lhs.onLedgerSettings != rhs.onLedgerSettings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(securityState)
        hasher.combine(appearanceId)
        hasher.combine(flags)
        hasher.combine(onLedgerSettings)
    }
}

public struct FfiConverterTypeAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Account {
        return
            try Account(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                address: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                securityState: FfiConverterTypeEntitySecurityState.read(from: &buf),
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf),
                flags: FfiConverterSequenceTypeEntityFlag.read(from: &buf),
                onLedgerSettings: FfiConverterTypeOnLedgerSettings.read(from: &buf)
            )
    }

    public static func write(_ value: Account, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeEntitySecurityState.write(value.securityState, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
        FfiConverterSequenceTypeEntityFlag.write(value.flags, into: &buf)
        FfiConverterTypeOnLedgerSettings.write(value.onLedgerSettings, into: &buf)
    }
}

public func FfiConverterTypeAccount_lift(_ buf: RustBuffer) throws -> Account {
    return try FfiConverterTypeAccount.lift(buf)
}

public func FfiConverterTypeAccount_lower(_ value: Account) -> RustBuffer {
    return FfiConverterTypeAccount.lower(value)
}

/**
 * Human readable address of an account. Always starts with `"account_"``, for example:
 *
 * `account_rdx16xlfcpp0vf7e3gqnswv8j9k58n6rjccu58vvspmdva22kf3aplease`
 *
 * Most commonly the user will see this address in its abbreviated
 * form which is:
 *
 * `acco...please`
 *
 * Addresses are checksummed, as per Bech32. **Only** *Account* addresses starts with
 * the prefix `account_`.
 */
public struct AccountAddress {
    public var inner: InnerAccountAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        inner: InnerAccountAddress)
    {
        self.inner = inner
    }
}

extension AccountAddress: Equatable, Hashable {
    public static func == (lhs: AccountAddress, rhs: AccountAddress) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeAccountAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountAddress {
        return
            try AccountAddress(
                inner: FfiConverterTypeInnerAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: AccountAddress, into buf: inout [UInt8]) {
        FfiConverterTypeInnerAccountAddress.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeAccountAddress_lift(_ buf: RustBuffer) throws -> AccountAddress {
    return try FfiConverterTypeAccountAddress.lift(buf)
}

public func FfiConverterTypeAccountAddress_lower(_ value: AccountAddress) -> RustBuffer {
    return FfiConverterTypeAccountAddress.lower(value)
}

public struct AccountPath {
    public var path: HdPath
    public var networkId: NetworkId
    public var entityKind: Cap26EntityKind
    public var keyKind: Cap26KeyKind
    public var index: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        path: HdPath,
        networkId: NetworkId,
        entityKind: Cap26EntityKind,
        keyKind: Cap26KeyKind,
        index: UInt32
    ) {
        self.path = path
        self.networkId = networkId
        self.entityKind = entityKind
        self.keyKind = keyKind
        self.index = index
    }
}

extension AccountPath: Equatable, Hashable {
    public static func == (lhs: AccountPath, rhs: AccountPath) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.entityKind != rhs.entityKind {
            return false
        }
        if lhs.keyKind != rhs.keyKind {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(networkId)
        hasher.combine(entityKind)
        hasher.combine(keyKind)
        hasher.combine(index)
    }
}

public struct FfiConverterTypeAccountPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountPath {
        return
            try AccountPath(
                path: FfiConverterTypeHDPath.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                entityKind: FfiConverterTypeCAP26EntityKind.read(from: &buf),
                keyKind: FfiConverterTypeCAP26KeyKind.read(from: &buf),
                index: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: AccountPath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPath.write(value.path, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeCAP26EntityKind.write(value.entityKind, into: &buf)
        FfiConverterTypeCAP26KeyKind.write(value.keyKind, into: &buf)
        FfiConverterUInt32.write(value.index, into: &buf)
    }
}

public func FfiConverterTypeAccountPath_lift(_ buf: RustBuffer) throws -> AccountPath {
    return try FfiConverterTypeAccountPath.lift(buf)
}

public func FfiConverterTypeAccountPath_lower(_ value: AccountPath) -> RustBuffer {
    return FfiConverterTypeAccountPath.lower(value)
}

/**
 * Settings related to displaying of information to the user inside the app.
 *
 * **N.B. neither of these settings are in fact not yet used by clients.**
 */
public struct AppDisplay {
    /**
     * If we should show the aggregate value of users portfolio in fiat currency
     * of hide it.
     */
    public var isCurrencyAmountVisible: Bool
    /**
     * Which fiat currency the prices are measured in.
     */
    public var fiatCurrencyPriceTarget: FiatCurrency

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If we should show the aggregate value of users portfolio in fiat currency
         * of hide it.
         */
        isCurrencyAmountVisible: Bool,
        /**
            * Which fiat currency the prices are measured in.
            */
        fiatCurrencyPriceTarget: FiatCurrency
    ) {
        self.isCurrencyAmountVisible = isCurrencyAmountVisible
        self.fiatCurrencyPriceTarget = fiatCurrencyPriceTarget
    }
}

extension AppDisplay: Equatable, Hashable {
    public static func == (lhs: AppDisplay, rhs: AppDisplay) -> Bool {
        if lhs.isCurrencyAmountVisible != rhs.isCurrencyAmountVisible {
            return false
        }
        if lhs.fiatCurrencyPriceTarget != rhs.fiatCurrencyPriceTarget {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCurrencyAmountVisible)
        hasher.combine(fiatCurrencyPriceTarget)
    }
}

public struct FfiConverterTypeAppDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppDisplay {
        return
            try AppDisplay(
                isCurrencyAmountVisible: FfiConverterBool.read(from: &buf),
                fiatCurrencyPriceTarget: FfiConverterTypeFiatCurrency.read(from: &buf)
            )
    }

    public static func write(_ value: AppDisplay, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCurrencyAmountVisible, into: &buf)
        FfiConverterTypeFiatCurrency.write(value.fiatCurrencyPriceTarget, into: &buf)
    }
}

public func FfiConverterTypeAppDisplay_lift(_ buf: RustBuffer) throws -> AppDisplay {
    return try FfiConverterTypeAppDisplay.lift(buf)
}

public func FfiConverterTypeAppDisplay_lower(_ value: AppDisplay) -> RustBuffer {
    return FfiConverterTypeAppDisplay.lower(value)
}

/**
 * Collection of all settings, preferences and configuration related to how the wallet
 * behaves and looks.
 *
 * Current and other saved Gateways, security settings, connected P2P clients,
 * App Display settings and preferences for transaction.
 */
public struct AppPreferences {
    /**
     * Display settings in the wallet app, such as appearances, currency etc.
     */
    public var display: AppDisplay
    /**
     * The gateway of the active network and collection of other saved gateways.
     */
    public var gateways: Gateways
    /**
     * Collection of clients user have connected P2P with, typically these
     * are WebRTC connections with DApps, but might be Android or iPhone
     * clients as well.
     */
    public var p2pLinks: [P2pLink]
    /**
     * Controls e.g. if Profile Snapshot gets synced to iCloud/Google backup or not.
     */
    public var security: Security
    /**
     * Default config related to making of transactions
     */
    public var transaction: TransactionPreferences

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Display settings in the wallet app, such as appearances, currency etc.
         */
        display: AppDisplay,
        /**
            * The gateway of the active network and collection of other saved gateways.
            */
        gateways: Gateways,
        /**
            * Collection of clients user have connected P2P with, typically these
            * are WebRTC connections with DApps, but might be Android or iPhone
            * clients as well.
            */
        p2pLinks: [P2pLink],
        /**
            * Controls e.g. if Profile Snapshot gets synced to iCloud/Google backup or not.
            */
        security: Security,
        /**
            * Default config related to making of transactions
            */
        transaction: TransactionPreferences
    ) {
        self.display = display
        self.gateways = gateways
        self.p2pLinks = p2pLinks
        self.security = security
        self.transaction = transaction
    }
}

extension AppPreferences: Equatable, Hashable {
    public static func == (lhs: AppPreferences, rhs: AppPreferences) -> Bool {
        if lhs.display != rhs.display {
            return false
        }
        if lhs.gateways != rhs.gateways {
            return false
        }
        if lhs.p2pLinks != rhs.p2pLinks {
            return false
        }
        if lhs.security != rhs.security {
            return false
        }
        if lhs.transaction != rhs.transaction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(display)
        hasher.combine(gateways)
        hasher.combine(p2pLinks)
        hasher.combine(security)
        hasher.combine(transaction)
    }
}

public struct FfiConverterTypeAppPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppPreferences {
        return
            try AppPreferences(
                display: FfiConverterTypeAppDisplay.read(from: &buf),
                gateways: FfiConverterTypeGateways.read(from: &buf),
                p2pLinks: FfiConverterSequenceTypeP2PLink.read(from: &buf),
                security: FfiConverterTypeSecurity.read(from: &buf),
                transaction: FfiConverterTypeTransactionPreferences.read(from: &buf)
            )
    }

    public static func write(_ value: AppPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeAppDisplay.write(value.display, into: &buf)
        FfiConverterTypeGateways.write(value.gateways, into: &buf)
        FfiConverterSequenceTypeP2PLink.write(value.p2pLinks, into: &buf)
        FfiConverterTypeSecurity.write(value.security, into: &buf)
        FfiConverterTypeTransactionPreferences.write(value.transaction, into: &buf)
    }
}

public func FfiConverterTypeAppPreferences_lift(_ buf: RustBuffer) throws -> AppPreferences {
    return try FfiConverterTypeAppPreferences.lift(buf)
}

public func FfiConverterTypeAppPreferences_lower(_ value: AppPreferences) -> RustBuffer {
    return FfiConverterTypeAppPreferences.lower(value)
}

public struct AppearanceId {
    public var value: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        value: UInt8)
    {
        self.value = value
    }
}

extension AppearanceId: Equatable, Hashable {
    public static func == (lhs: AppearanceId, rhs: AppearanceId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeAppearanceID: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppearanceId {
        return
            try AppearanceId(
                value: FfiConverterUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: AppearanceId, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeAppearanceID_lift(_ buf: RustBuffer) throws -> AppearanceId {
    return try FfiConverterTypeAppearanceID.lift(buf)
}

public func FfiConverterTypeAppearanceID_lower(_ value: AppearanceId) -> RustBuffer {
    return FfiConverterTypeAppearanceID.lower(value)
}

/**
 * The specific Asset exception rule, which overrides the general
 * `deposit_rule` of a `ThirdPartyDeposits` settings.
 */
public struct AssetException {
    /**
     * Address of an asset to either deny or allow, as an exception overriding the `ThirdPartyDeposits`'s general `deposit_rule`.
     */
    public var address: ResourceAddress
    /**
     * Either deny or allow the `address`.
     */
    public var exceptionRule: DepositAddressExceptionRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Address of an asset to either deny or allow, as an exception overriding the `ThirdPartyDeposits`'s general `deposit_rule`.
         */
        address: ResourceAddress,
        /**
            * Either deny or allow the `address`.
            */
        exceptionRule: DepositAddressExceptionRule
    ) {
        self.address = address
        self.exceptionRule = exceptionRule
    }
}

extension AssetException: Equatable, Hashable {
    public static func == (lhs: AssetException, rhs: AssetException) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.exceptionRule != rhs.exceptionRule {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(exceptionRule)
    }
}

public struct FfiConverterTypeAssetException: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetException {
        return
            try AssetException(
                address: FfiConverterTypeResourceAddress.read(from: &buf),
                exceptionRule: FfiConverterTypeDepositAddressExceptionRule.read(from: &buf)
            )
    }

    public static func write(_ value: AssetException, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.address, into: &buf)
        FfiConverterTypeDepositAddressExceptionRule.write(value.exceptionRule, into: &buf)
    }
}

public func FfiConverterTypeAssetException_lift(_ buf: RustBuffer) throws -> AssetException {
    return try FfiConverterTypeAssetException.lift(buf)
}

public func FfiConverterTypeAssetException_lower(_ value: AssetException) -> RustBuffer {
    return FfiConverterTypeAssetException.lower(value)
}

/**
 * A connection made between a Radix Dapp and the user.
 */
public struct AuthorizedDapp {
    /**
     * The ID of the network the authorized Dapp is on.
     */
    public var networkId: NetworkId
    /**
     * A `DappDefinitionAddress` is in fact just an alias for
     * [`AccountAddress`], it is the address of the account
     * which owns controls the Dapp.
     */
    public var dappDefinitionAddress: AccountAddress
    /**
     * The Display name as sent by the Dapp in any interaction
     * request (CAP21), e.g. "Radix Dashboard".
     */
    public var displayName: String?
    /**
     * An order set of `AuthorizedPersonaSimple`s, which is a collection of all
     * the Personas the user has used to interact with this Dapp, it is called
     * "references to", since the Personas are not stored in full, that would be
     * bad duplication of data (which might go stale), instead we refer to the
     * necessary data by IDs.
     */
    public var referencesToAuthorizedPersonas: [AuthorizedPersonaSimple]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network the authorized Dapp is on.
         */
        networkId: NetworkId,
        /**
            * A `DappDefinitionAddress` is in fact just an alias for
            * [`AccountAddress`], it is the address of the account
            * which owns controls the Dapp.
            */
        dappDefinitionAddress: AccountAddress,
        /**
            * The Display name as sent by the Dapp in any interaction
            * request (CAP21), e.g. "Radix Dashboard".
            */
        displayName: String?,
        /**
            * An order set of `AuthorizedPersonaSimple`s, which is a collection of all
            * the Personas the user has used to interact with this Dapp, it is called
            * "references to", since the Personas are not stored in full, that would be
            * bad duplication of data (which might go stale), instead we refer to the
            * necessary data by IDs.
            */
        referencesToAuthorizedPersonas: [AuthorizedPersonaSimple]
    ) {
        self.networkId = networkId
        self.dappDefinitionAddress = dappDefinitionAddress
        self.displayName = displayName
        self.referencesToAuthorizedPersonas = referencesToAuthorizedPersonas
    }
}

extension AuthorizedDapp: Equatable, Hashable {
    public static func == (lhs: AuthorizedDapp, rhs: AuthorizedDapp) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.referencesToAuthorizedPersonas != rhs.referencesToAuthorizedPersonas {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(dappDefinitionAddress)
        hasher.combine(displayName)
        hasher.combine(referencesToAuthorizedPersonas)
    }
}

public struct FfiConverterTypeAuthorizedDapp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDapp {
        return
            try AuthorizedDapp(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterOptionString.read(from: &buf),
                referencesToAuthorizedPersonas: FfiConverterSequenceTypeAuthorizedPersonaSimple.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedDapp, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterSequenceTypeAuthorizedPersonaSimple.write(value.referencesToAuthorizedPersonas, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedDapp_lift(_ buf: RustBuffer) throws -> AuthorizedDapp {
    return try FfiConverterTypeAuthorizedDapp.lift(buf)
}

public func FfiConverterTypeAuthorizedDapp_lower(_ value: AuthorizedDapp) -> RustBuffer {
    return FfiConverterTypeAuthorizedDapp.lower(value)
}

/**
 * Simple data representation of a Persona the user has shared with a Dapp.
 * Simple meaning "the bare minimum amount of data" that enabled `Sargon` to
 * be able to reconstruct a `AuthorizedPersonaDetailed` value, used to populate
 * views.
 *
 * N.B. as of 2024-01-31 of `Sargon` we have not yet implemented the struct
 * `AuthorizedPersonaDetailed` since it is not JSON, but logic, and we have yet
 * to migrate `Sargon` into iOS/Android clients, thus we will defer the work
 * of mapping `AuthorizedPersonaSimple` -> `AuthorizedPersonaDetailed`.
 */
public struct AuthorizedPersonaSimple {
    /**
     * The globally unique identifier of a Persona is its address, used
     * to lookup persona
     */
    public var identityAddress: IdentityAddress
    /**
     * Date of last login for this persona.
     */
    public var lastLogin: Timestamp
    /**
     * List of "ongoing accountAddresses" that user given the dApp access to.
     */
    public var sharedAccounts: SharedToDappWithPersonaAccountAddresses?
    /**
     * ID to PersonaData entries to user has shared with a Dapp.
     */
    public var sharedPersonaData: SharedPersonaData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The globally unique identifier of a Persona is its address, used
         * to lookup persona
         */
        identityAddress: IdentityAddress,
        /**
            * Date of last login for this persona.
            */
        lastLogin: Timestamp,
        /**
            * List of "ongoing accountAddresses" that user given the dApp access to.
            */
        sharedAccounts: SharedToDappWithPersonaAccountAddresses?,
        /**
            * ID to PersonaData entries to user has shared with a Dapp.
            */
        sharedPersonaData: SharedPersonaData
    ) {
        self.identityAddress = identityAddress
        self.lastLogin = lastLogin
        self.sharedAccounts = sharedAccounts
        self.sharedPersonaData = sharedPersonaData
    }
}

extension AuthorizedPersonaSimple: Equatable, Hashable {
    public static func == (lhs: AuthorizedPersonaSimple, rhs: AuthorizedPersonaSimple) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.lastLogin != rhs.lastLogin {
            return false
        }
        if lhs.sharedAccounts != rhs.sharedAccounts {
            return false
        }
        if lhs.sharedPersonaData != rhs.sharedPersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(lastLogin)
        hasher.combine(sharedAccounts)
        hasher.combine(sharedPersonaData)
    }
}

public struct FfiConverterTypeAuthorizedPersonaSimple: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedPersonaSimple {
        return
            try AuthorizedPersonaSimple(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
                lastLogin: FfiConverterTypeTimestamp.read(from: &buf),
                sharedAccounts: FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses.read(from: &buf),
                sharedPersonaData: FfiConverterTypeSharedPersonaData.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedPersonaSimple, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastLogin, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses.write(value.sharedAccounts, into: &buf)
        FfiConverterTypeSharedPersonaData.write(value.sharedPersonaData, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedPersonaSimple_lift(_ buf: RustBuffer) throws -> AuthorizedPersonaSimple {
    return try FfiConverterTypeAuthorizedPersonaSimple.lift(buf)
}

public func FfiConverterTypeAuthorizedPersonaSimple_lower(_ value: AuthorizedPersonaSimple) -> RustBuffer {
    return FfiConverterTypeAuthorizedPersonaSimple.lower(value)
}

/**
 * A word in the BIP39 word list of `language` at known `index` (0-2047).
 */
public struct Bip39Word {
    public var word: String
    public var index: U11
    public var language: Bip39Language

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        word: String,
        index: U11,
        language: Bip39Language
    ) {
        self.word = word
        self.index = index
        self.language = language
    }
}

extension Bip39Word: Equatable, Hashable {
    public static func == (lhs: Bip39Word, rhs: Bip39Word) -> Bool {
        if lhs.word != rhs.word {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(word)
        hasher.combine(index)
        hasher.combine(language)
    }
}

public struct FfiConverterTypeBIP39Word: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Word {
        return
            try Bip39Word(
                word: FfiConverterString.read(from: &buf),
                index: FfiConverterTypeU11.read(from: &buf),
                language: FfiConverterTypeBIP39Language.read(from: &buf)
            )
    }

    public static func write(_ value: Bip39Word, into buf: inout [UInt8]) {
        FfiConverterString.write(value.word, into: &buf)
        FfiConverterTypeU11.write(value.index, into: &buf)
        FfiConverterTypeBIP39Language.write(value.language, into: &buf)
    }
}

public func FfiConverterTypeBIP39Word_lift(_ buf: RustBuffer) throws -> Bip39Word {
    return try FfiConverterTypeBIP39Word.lift(buf)
}

public func FfiConverterTypeBIP39Word_lower(_ value: Bip39Word) -> RustBuffer {
    return FfiConverterTypeBIP39Word.lower(value)
}

public struct Bip44LikePath {
    public var path: HdPath

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        path: HdPath)
    {
        self.path = path
    }
}

extension Bip44LikePath: Equatable, Hashable {
    public static func == (lhs: Bip44LikePath, rhs: Bip44LikePath) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
    }
}

public struct FfiConverterTypeBIP44LikePath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip44LikePath {
        return
            try Bip44LikePath(
                path: FfiConverterTypeHDPath.read(from: &buf)
            )
    }

    public static func write(_ value: Bip44LikePath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPath.write(value.path, into: &buf)
    }
}

public func FfiConverterTypeBIP44LikePath_lift(_ buf: RustBuffer) throws -> Bip44LikePath {
    return try FfiConverterTypeBIP44LikePath.lift(buf)
}

public func FfiConverterTypeBIP44LikePath_lower(_ value: Bip44LikePath) -> RustBuffer {
    return FfiConverterTypeBIP44LikePath.lower(value)
}

/**
 * A collection of identifiable PersonaData Entries.
 */
public struct CollectionOfEmailAddresses {
    public var collection: [PersonaDataIdentifiedEmailAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        collection: [PersonaDataIdentifiedEmailAddress])
    {
        self.collection = collection
    }
}

extension CollectionOfEmailAddresses: Equatable, Hashable {
    public static func == (lhs: CollectionOfEmailAddresses, rhs: CollectionOfEmailAddresses) -> Bool {
        if lhs.collection != rhs.collection {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(collection)
    }
}

public struct FfiConverterTypeCollectionOfEmailAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionOfEmailAddresses {
        return
            try CollectionOfEmailAddresses(
                collection: FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress.read(from: &buf)
            )
    }

    public static func write(_ value: CollectionOfEmailAddresses, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress.write(value.collection, into: &buf)
    }
}

public func FfiConverterTypeCollectionOfEmailAddresses_lift(_ buf: RustBuffer) throws -> CollectionOfEmailAddresses {
    return try FfiConverterTypeCollectionOfEmailAddresses.lift(buf)
}

public func FfiConverterTypeCollectionOfEmailAddresses_lower(_ value: CollectionOfEmailAddresses) -> RustBuffer {
    return FfiConverterTypeCollectionOfEmailAddresses.lower(value)
}

/**
 * A collection of identifiable PersonaData Entries.
 */
public struct CollectionOfPhoneNumbers {
    public var collection: [PersonaDataIdentifiedPhoneNumber]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        collection: [PersonaDataIdentifiedPhoneNumber])
    {
        self.collection = collection
    }
}

extension CollectionOfPhoneNumbers: Equatable, Hashable {
    public static func == (lhs: CollectionOfPhoneNumbers, rhs: CollectionOfPhoneNumbers) -> Bool {
        if lhs.collection != rhs.collection {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(collection)
    }
}

public struct FfiConverterTypeCollectionOfPhoneNumbers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionOfPhoneNumbers {
        return
            try CollectionOfPhoneNumbers(
                collection: FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber.read(from: &buf)
            )
    }

    public static func write(_ value: CollectionOfPhoneNumbers, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber.write(value.collection, into: &buf)
    }
}

public func FfiConverterTypeCollectionOfPhoneNumbers_lift(_ buf: RustBuffer) throws -> CollectionOfPhoneNumbers {
    return try FfiConverterTypeCollectionOfPhoneNumbers.lift(buf)
}

public func FfiConverterTypeCollectionOfPhoneNumbers_lower(_ value: CollectionOfPhoneNumbers) -> RustBuffer {
    return FfiConverterTypeCollectionOfPhoneNumbers.lower(value)
}

public struct ComponentAddress {
    public var inner: InnerComponentAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        inner: InnerComponentAddress)
    {
        self.inner = inner
    }
}

extension ComponentAddress: Equatable, Hashable {
    public static func == (lhs: ComponentAddress, rhs: ComponentAddress) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeComponentAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComponentAddress {
        return
            try ComponentAddress(
                inner: FfiConverterTypeInnerComponentAddress.read(from: &buf)
            )
    }

    public static func write(_ value: ComponentAddress, into buf: inout [UInt8]) {
        FfiConverterTypeInnerComponentAddress.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeComponentAddress_lift(_ buf: RustBuffer) throws -> ComponentAddress {
    return try FfiConverterTypeComponentAddress.lift(buf)
}

public func FfiConverterTypeComponentAddress_lower(_ value: ComponentAddress) -> RustBuffer {
    return FfiConverterTypeComponentAddress.lower(value)
}

/**
 * A hint describing the contents of a Profile, acting as a
 * summary of a Profile used by a ProfileSnapshot Header.
 *
 * Important to know that this is just a **hint**, the values
 * SHOULD be kept up to date, might might not be, since they
 * are stored values which must be kept in sync.
 */
public struct ContentHint {
    /**
     * The total number of accounts on all networks.
     *
     * Important to remember that this is a counter inside a
     * content **hint**. This counter SHOULD be update when
     * new accounts are created, but failing to do is of no
     * real consequence.
     *
     * This counter includes any by user hidden accounts.
     */
    public var numberOfAccountsOnAllNetworksInTotal: UInt16
    /**
     * The total number of personas on all networks.
     *
     * Important to remember that this is a counter inside a
     * content **hint**. This counter SHOULD be update when
     * new accounts are created, but failing to do is of no
     * real consequence.
     *
     * This counter includes any by user hidden personas.
     */
    public var numberOfPersonasOnAllNetworksInTotal: UInt16
    /**
     * The total number of networks that the user has used, i.e.
     * on which she has any accounts or personas.
     */
    public var numberOfNetworks: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The total number of accounts on all networks.
         *
         * Important to remember that this is a counter inside a
         * content **hint**. This counter SHOULD be update when
         * new accounts are created, but failing to do is of no
         * real consequence.
         *
         * This counter includes any by user hidden accounts.
         */
        numberOfAccountsOnAllNetworksInTotal: UInt16,
        /**
            * The total number of personas on all networks.
            *
            * Important to remember that this is a counter inside a
            * content **hint**. This counter SHOULD be update when
            * new accounts are created, but failing to do is of no
            * real consequence.
            *
            * This counter includes any by user hidden personas.
            */
        numberOfPersonasOnAllNetworksInTotal: UInt16,
        /**
            * The total number of networks that the user has used, i.e.
            * on which she has any accounts or personas.
            */
        numberOfNetworks: UInt16
    ) {
        self.numberOfAccountsOnAllNetworksInTotal = numberOfAccountsOnAllNetworksInTotal
        self.numberOfPersonasOnAllNetworksInTotal = numberOfPersonasOnAllNetworksInTotal
        self.numberOfNetworks = numberOfNetworks
    }
}

extension ContentHint: Equatable, Hashable {
    public static func == (lhs: ContentHint, rhs: ContentHint) -> Bool {
        if lhs.numberOfAccountsOnAllNetworksInTotal != rhs.numberOfAccountsOnAllNetworksInTotal {
            return false
        }
        if lhs.numberOfPersonasOnAllNetworksInTotal != rhs.numberOfPersonasOnAllNetworksInTotal {
            return false
        }
        if lhs.numberOfNetworks != rhs.numberOfNetworks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numberOfAccountsOnAllNetworksInTotal)
        hasher.combine(numberOfPersonasOnAllNetworksInTotal)
        hasher.combine(numberOfNetworks)
    }
}

public struct FfiConverterTypeContentHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContentHint {
        return
            try ContentHint(
                numberOfAccountsOnAllNetworksInTotal: FfiConverterUInt16.read(from: &buf),
                numberOfPersonasOnAllNetworksInTotal: FfiConverterUInt16.read(from: &buf),
                numberOfNetworks: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: ContentHint, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.numberOfAccountsOnAllNetworksInTotal, into: &buf)
        FfiConverterUInt16.write(value.numberOfPersonasOnAllNetworksInTotal, into: &buf)
        FfiConverterUInt16.write(value.numberOfNetworks, into: &buf)
    }
}

public func FfiConverterTypeContentHint_lift(_ buf: RustBuffer) throws -> ContentHint {
    return try FfiConverterTypeContentHint.lift(buf)
}

public func FfiConverterTypeContentHint_lower(_ value: ContentHint) -> RustBuffer {
    return FfiConverterTypeContentHint.lower(value)
}

/**
 * `Decimal192` represents a 192 bit representation of a fixed-scale decimal number.
 *
 * The finite set of values are of the form `m / 10^18`, where `m` is
 * an integer such that `-2^(192 - 1) <= m < 2^(192 - 1)`.
 *
 * Fractional part: ~60 bits/18 digits
 * Integer part   : 132 bits /40 digits
 * Max            :  3138550867693340381917894711603833208051.177722232017256447
 * Min            : -3138550867693340381917894711603833208051.177722232017256448
 *
 * Unless otherwise specified, all operations will panic if underflow/overflow.
 *
 * Powering it is the [Scrypto Decimal type, see docs][scrypto].
 *
 * Note: This type cannot be called `Decimal`, since it results in naming collision
 * in the Swift land (clash with `Foundation.Decimal`) instead we have created a
 * type alias `Decimal = Decimal192` which we use in Rust land.
 *
 * [scrypto]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/math/decimal.rs#L42
 */
public struct Decimal192 {
    /**
     * @Kotlin / Swift developer: Do NOT use this property/field. Instead use all the provided methods on the `Decimal192` type.
     * (which are in fact vendored as freestanding global functions,
     * due to limitations in UniFII as of Feb 2024, but you should
     * create extension methods on Decimal192 in FFI land, translating
     * these functions into methods.)
     */
    public var inner: InnerDecimal

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * @Kotlin / Swift developer: Do NOT use this property/field. Instead use all the provided methods on the `Decimal192` type.
         * (which are in fact vendored as freestanding global functions,
         * due to limitations in UniFII as of Feb 2024, but you should
         * create extension methods on Decimal192 in FFI land, translating
         * these functions into methods.)
         */
        inner: InnerDecimal
    ) {
        self.inner = inner
    }
}

extension Decimal192: Equatable, Hashable {
    public static func == (lhs: Decimal192, rhs: Decimal192) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeDecimal192: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Decimal192 {
        return
            try Decimal192(
                inner: FfiConverterTypeInnerDecimal.read(from: &buf)
            )
    }

    public static func write(_ value: Decimal192, into buf: inout [UInt8]) {
        FfiConverterTypeInnerDecimal.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeDecimal192_lift(_ buf: RustBuffer) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(buf)
}

public func FfiConverterTypeDecimal192_lower(_ value: Decimal192) -> RustBuffer {
    return FfiConverterTypeDecimal192.lower(value)
}

/**
 * A factor source representing the device that the Radix Wallet is running on
 * typically an iPhone or Android device. This is the initial factor source of
 * all new Accounts and Personas an users authenticate signing by authorizing
 * the client (Wallet App) to access a mnemonic stored in secure storage on
 * the device.
 */
public struct DeviceFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     *
     * Has interior mutability since we must be able to update the
     * last used date.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a DeviceFactorSource to help user disambiguate between it and another one.
     */
    public var hint: DeviceFactorSourceHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic.
         */
        id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            *
            * Has interior mutability since we must be able to update the
            * last used date.
            */
        common: FactorSourceCommon,
        /**
            * Properties describing a DeviceFactorSource to help user disambiguate between it and another one.
            */
        hint: DeviceFactorSourceHint
    ) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}

extension DeviceFactorSource: Equatable, Hashable {
    public static func == (lhs: DeviceFactorSource, rhs: DeviceFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}

public struct FfiConverterTypeDeviceFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSource {
        return
            try DeviceFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                hint: FfiConverterTypeDeviceFactorSourceHint.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeDeviceFactorSourceHint.write(value.hint, into: &buf)
    }
}

public func FfiConverterTypeDeviceFactorSource_lift(_ buf: RustBuffer) throws -> DeviceFactorSource {
    return try FfiConverterTypeDeviceFactorSource.lift(buf)
}

public func FfiConverterTypeDeviceFactorSource_lower(_ value: DeviceFactorSource) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSource.lower(value)
}

/**
 * Properties describing a DeviceFactorSource to help user disambiguate between
 * it and another one.
 */
public struct DeviceFactorSourceHint {
    /**
     * "iPhone RED"
     */
    public var name: String
    /**
     * "iPhone SE 2nd gen"
     */
    public var model: String
    /**
     * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
     * standard, a multiple of 3, from 12 to 24 words.
     */
    public var mnemonicWordCount: Bip39WordCount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * "iPhone RED"
         */
        name: String,
        /**
            * "iPhone SE 2nd gen"
            */
        model: String,
        /**
            * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
            * standard, a multiple of 3, from 12 to 24 words.
            */
        mnemonicWordCount: Bip39WordCount
    ) {
        self.name = name
        self.model = model
        self.mnemonicWordCount = mnemonicWordCount
    }
}

extension DeviceFactorSourceHint: Equatable, Hashable {
    public static func == (lhs: DeviceFactorSourceHint, rhs: DeviceFactorSourceHint) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        if lhs.mnemonicWordCount != rhs.mnemonicWordCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
        hasher.combine(mnemonicWordCount)
    }
}

public struct FfiConverterTypeDeviceFactorSourceHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSourceHint {
        return
            try DeviceFactorSourceHint(
                name: FfiConverterString.read(from: &buf),
                model: FfiConverterString.read(from: &buf),
                mnemonicWordCount: FfiConverterTypeBIP39WordCount.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceFactorSourceHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.model, into: &buf)
        FfiConverterTypeBIP39WordCount.write(value.mnemonicWordCount, into: &buf)
    }
}

public func FfiConverterTypeDeviceFactorSourceHint_lift(_ buf: RustBuffer) throws -> DeviceFactorSourceHint {
    return try FfiConverterTypeDeviceFactorSourceHint.lift(buf)
}

public func FfiConverterTypeDeviceFactorSourceHint_lower(_ value: DeviceFactorSourceHint) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSourceHint.lower(value)
}

/**
 * A short summary of a device the Profile is being used
 * on, typically an iPhone or an Android phone.
 */
public struct DeviceInfo {
    /**
     * A best effort stable and unique identifier of this
     * device.
     *
     * Apple has made it so that iOS devices cannot
     * query iOS for a unique identifier of the device, thus
     * the iOS team has made their own impl of a best effort
     * stable identifier.
     */
    public var id: Uuid
    /**
     * The date this description of the device was made, might
     * be equal to when the app was first ever launched on the
     * device.
     */
    public var date: Timestamp
    /**
     * A short description of the device, we devices should
     * read the device model and a given name from the device
     * if they are able to.
     *
     * E.g. "My Red Phone (iPhone SE 2nd Gen)"
     */
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A best effort stable and unique identifier of this
         * device.
         *
         * Apple has made it so that iOS devices cannot
         * query iOS for a unique identifier of the device, thus
         * the iOS team has made their own impl of a best effort
         * stable identifier.
         */
        id: Uuid,
        /**
            * The date this description of the device was made, might
            * be equal to when the app was first ever launched on the
            * device.
            */
        date: Timestamp,
        /**
            * A short description of the device, we devices should
            * read the device model and a given name from the device
            * if they are able to.
            *
            * E.g. "My Red Phone (iPhone SE 2nd Gen)"
            */
        description: String
    ) {
        self.id = id
        self.date = date
        self.description = description
    }
}

extension DeviceInfo: Equatable, Hashable {
    public static func == (lhs: DeviceInfo, rhs: DeviceInfo) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.date != rhs.date {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(date)
        hasher.combine(description)
    }
}

public struct FfiConverterTypeDeviceInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceInfo {
        return
            try DeviceInfo(
                id: FfiConverterTypeUuid.read(from: &buf),
                date: FfiConverterTypeTimestamp.read(from: &buf),
                description: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceInfo, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeTimestamp.write(value.date, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}

public func FfiConverterTypeDeviceInfo_lift(_ buf: RustBuffer) throws -> DeviceInfo {
    return try FfiConverterTypeDeviceInfo.lift(buf)
}

public func FfiConverterTypeDeviceInfo_lower(_ value: DeviceInfo) -> RustBuffer {
    return FfiConverterTypeDeviceInfo.lower(value)
}

public struct DisplayName {
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        value: String)
    {
        self.value = value
    }
}

extension DisplayName: Equatable, Hashable {
    public static func == (lhs: DisplayName, rhs: DisplayName) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeDisplayName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DisplayName {
        return
            try DisplayName(
                value: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DisplayName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeDisplayName_lift(_ buf: RustBuffer) throws -> DisplayName {
    return try FfiConverterTypeDisplayName.lift(buf)
}

public func FfiConverterTypeDisplayName_lower(_ value: DisplayName) -> RustBuffer {
    return FfiConverterTypeDisplayName.lower(value)
}

/**
 * An Ed25519 public key used to verify cryptographic signatures (EdDSA signatures).
 */
public struct Ed25519PublicKey {
    public var inner: ScryptoEd25519PublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        inner: ScryptoEd25519PublicKey)
    {
        self.inner = inner
    }
}

extension Ed25519PublicKey: Equatable, Hashable {
    public static func == (lhs: Ed25519PublicKey, rhs: Ed25519PublicKey) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeEd25519PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519PublicKey {
        return
            try Ed25519PublicKey(
                inner: FfiConverterTypeScryptoEd25519PublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: Ed25519PublicKey, into buf: inout [UInt8]) {
        FfiConverterTypeScryptoEd25519PublicKey.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeEd25519PublicKey_lift(_ buf: RustBuffer) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(buf)
}

public func FfiConverterTypeEd25519PublicKey_lower(_ value: Ed25519PublicKey) -> RustBuffer {
    return FfiConverterTypeEd25519PublicKey.lower(value)
}

/**
 * Represents an ED25519 signature.
 */
public struct Ed25519Signature {
    public var bytes: Hex64Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        bytes: Hex64Bytes)
    {
        self.bytes = bytes
    }
}

extension Ed25519Signature: Equatable, Hashable {
    public static func == (lhs: Ed25519Signature, rhs: Ed25519Signature) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}

public struct FfiConverterTypeEd25519Signature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519Signature {
        return
            try Ed25519Signature(
                bytes: FfiConverterTypeHex64Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: Ed25519Signature, into buf: inout [UInt8]) {
        FfiConverterTypeHex64Bytes.write(value.bytes, into: &buf)
    }
}

public func FfiConverterTypeEd25519Signature_lift(_ buf: RustBuffer) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(buf)
}

public func FfiConverterTypeEd25519Signature_lower(_ value: Ed25519Signature) -> RustBuffer {
    return FfiConverterTypeEd25519Signature.lower(value)
}

public struct ExecutionSummary {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension ExecutionSummary: Equatable, Hashable {
    public static func == (_: ExecutionSummary, _: ExecutionSummary) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeExecutionSummary: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> ExecutionSummary {
        return
            ExecutionSummary()
    }

    public static func write(_: ExecutionSummary, into _: inout [UInt8]) {}
}

public func FfiConverterTypeExecutionSummary_lift(_ buf: RustBuffer) throws -> ExecutionSummary {
    return try FfiConverterTypeExecutionSummary.lift(buf)
}

public func FfiConverterTypeExecutionSummary_lower(_ value: ExecutionSummary) -> RustBuffer {
    return FfiConverterTypeExecutionSummary.lower(value)
}

public struct FactorInstance {
    /**
     * The ID of the `FactorSource` that was used to produce this
     * factor instance. We will lookup the `FactorSource` in the
     * `Profile` and can present user with instruction to re-access
     * this factor source in order control the `badge`.
     */
    public var factorSourceId: FactorSourceId
    /**
     * Either a "physical" badge (NFT) or some source for recreation of a producer
     * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
     * is derived which produces virtual badges (signatures).
     */
    public var badge: FactorInstanceBadge

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the `FactorSource` that was used to produce this
         * factor instance. We will lookup the `FactorSource` in the
         * `Profile` and can present user with instruction to re-access
         * this factor source in order control the `badge`.
         */
        factorSourceId: FactorSourceId,
        /**
            * Either a "physical" badge (NFT) or some source for recreation of a producer
            * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
            * is derived which produces virtual badges (signatures).
            */
        badge: FactorInstanceBadge
    ) {
        self.factorSourceId = factorSourceId
        self.badge = badge
    }
}

extension FactorInstance: Equatable, Hashable {
    public static func == (lhs: FactorInstance, rhs: FactorInstance) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.badge != rhs.badge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(badge)
    }
}

public struct FfiConverterTypeFactorInstance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstance {
        return
            try FactorInstance(
                factorSourceId: FfiConverterTypeFactorSourceID.read(from: &buf),
                badge: FfiConverterTypeFactorInstanceBadge.read(from: &buf)
            )
    }

    public static func write(_ value: FactorInstance, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceID.write(value.factorSourceId, into: &buf)
        FfiConverterTypeFactorInstanceBadge.write(value.badge, into: &buf)
    }
}

public func FfiConverterTypeFactorInstance_lift(_ buf: RustBuffer) throws -> FactorInstance {
    return try FfiConverterTypeFactorInstance.lift(buf)
}

public func FfiConverterTypeFactorInstance_lower(_ value: FactorInstance) -> RustBuffer {
    return FfiConverterTypeFactorInstance.lower(value)
}

/**
 * Common properties shared between FactorSources of different kinds, describing
 * its state, when added, and supported cryptographic parameters.
 */
public struct FactorSourceCommon {
    /**
     * Cryptographic parameters a certain FactorSource supports, e.g. Elliptic Curves.
     *
     * Has interior mutability since Radix Wallet App version 1.3.0, it is
     * possible to add crypto parameters to a FactorSource, e.g. when a user
     * with a DeviceFactorSource with babylon crypto parameters, lets call it `B`,
     * with mnemonic `M` adds `M` again but as an "Olympia" factor source, then
     * the olympia crypto parameters are added to `B`.
     */
    public var cryptoParameters: FactorSourceCryptoParameters
    /**
     * When this factor source for originally added by the user.
     */
    public var addedOn: Timestamp
    /**
     * Date of last usage of this factor source
     *
     * This is the only mutable property, it is mutable
     * since we will update it every time this FactorSource
     * is used.
     */
    public var lastUsedOn: Timestamp
    /**
     * Flags which describe a certain state a FactorSource might be in, e.g. `Main` (BDFS).
     */
    public var flags: [FactorSourceFlag]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Cryptographic parameters a certain FactorSource supports, e.g. Elliptic Curves.
         *
         * Has interior mutability since Radix Wallet App version 1.3.0, it is
         * possible to add crypto parameters to a FactorSource, e.g. when a user
         * with a DeviceFactorSource with babylon crypto parameters, lets call it `B`,
         * with mnemonic `M` adds `M` again but as an "Olympia" factor source, then
         * the olympia crypto parameters are added to `B`.
         */
        cryptoParameters: FactorSourceCryptoParameters,
        /**
            * When this factor source for originally added by the user.
            */
        addedOn: Timestamp,
        /**
            * Date of last usage of this factor source
            *
            * This is the only mutable property, it is mutable
            * since we will update it every time this FactorSource
            * is used.
            */
        lastUsedOn: Timestamp,
        /**
            * Flags which describe a certain state a FactorSource might be in, e.g. `Main` (BDFS).
            */
        flags: [FactorSourceFlag]
    ) {
        self.cryptoParameters = cryptoParameters
        self.addedOn = addedOn
        self.lastUsedOn = lastUsedOn
        self.flags = flags
    }
}

extension FactorSourceCommon: Equatable, Hashable {
    public static func == (lhs: FactorSourceCommon, rhs: FactorSourceCommon) -> Bool {
        if lhs.cryptoParameters != rhs.cryptoParameters {
            return false
        }
        if lhs.addedOn != rhs.addedOn {
            return false
        }
        if lhs.lastUsedOn != rhs.lastUsedOn {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cryptoParameters)
        hasher.combine(addedOn)
        hasher.combine(lastUsedOn)
        hasher.combine(flags)
    }
}

public struct FfiConverterTypeFactorSourceCommon: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceCommon {
        return
            try FactorSourceCommon(
                cryptoParameters: FfiConverterTypeFactorSourceCryptoParameters.read(from: &buf),
                addedOn: FfiConverterTypeTimestamp.read(from: &buf),
                lastUsedOn: FfiConverterTypeTimestamp.read(from: &buf),
                flags: FfiConverterSequenceTypeFactorSourceFlag.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceCommon, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceCryptoParameters.write(value.cryptoParameters, into: &buf)
        FfiConverterTypeTimestamp.write(value.addedOn, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastUsedOn, into: &buf)
        FfiConverterSequenceTypeFactorSourceFlag.write(value.flags, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceCommon_lift(_ buf: RustBuffer) throws -> FactorSourceCommon {
    return try FfiConverterTypeFactorSourceCommon.lift(buf)
}

public func FfiConverterTypeFactorSourceCommon_lower(_ value: FactorSourceCommon) -> RustBuffer {
    return FfiConverterTypeFactorSourceCommon.lower(value)
}

/**
 * Cryptographic parameters a certain FactorSource supports, e.g. which Elliptic Curves
 * it supports and which Hierarchical Deterministic (HD) derivations schemes it supports,
 * if any.
 */
public struct FactorSourceCryptoParameters {
    /**
     * Describes with which Elliptic Curves a Factor Source can be used, e.g. a
     * "Babylon" `DeviceFactorSource` is not capable of deriving keys on the curve
     * `secp256k1` - only Olympia imported FactorSources can do that.
     *
     * Either `[curve25519]` or `[secp256k1, curve25519]`
     *
     * Must not be empty.
     */
    public var supportedCurves: [Slip10Curve]
    /**
     * If not empty: Describes which kind of Hierarchical Deterministic (HD)
     * derivations a FactorSource is capable of doing - if empty: the
     * FactorSource does not support HD derivation.
     *
     * Either BIP44 or CAP26 (SLIP10)
     */
    public var supportedDerivationPathSchemes: [DerivationPathScheme]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Describes with which Elliptic Curves a Factor Source can be used, e.g. a
         * "Babylon" `DeviceFactorSource` is not capable of deriving keys on the curve
         * `secp256k1` - only Olympia imported FactorSources can do that.
         *
         * Either `[curve25519]` or `[secp256k1, curve25519]`
         *
         * Must not be empty.
         */
        supportedCurves: [Slip10Curve],
        /**
            * If not empty: Describes which kind of Hierarchical Deterministic (HD)
            * derivations a FactorSource is capable of doing - if empty: the
            * FactorSource does not support HD derivation.
            *
            * Either BIP44 or CAP26 (SLIP10)
            */
        supportedDerivationPathSchemes: [DerivationPathScheme]
    ) {
        self.supportedCurves = supportedCurves
        self.supportedDerivationPathSchemes = supportedDerivationPathSchemes
    }
}

extension FactorSourceCryptoParameters: Equatable, Hashable {
    public static func == (lhs: FactorSourceCryptoParameters, rhs: FactorSourceCryptoParameters) -> Bool {
        if lhs.supportedCurves != rhs.supportedCurves {
            return false
        }
        if lhs.supportedDerivationPathSchemes != rhs.supportedDerivationPathSchemes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(supportedCurves)
        hasher.combine(supportedDerivationPathSchemes)
    }
}

public struct FfiConverterTypeFactorSourceCryptoParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceCryptoParameters {
        return
            try FactorSourceCryptoParameters(
                supportedCurves: FfiConverterSequenceTypeSLIP10Curve.read(from: &buf),
                supportedDerivationPathSchemes: FfiConverterSequenceTypeDerivationPathScheme.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceCryptoParameters, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeSLIP10Curve.write(value.supportedCurves, into: &buf)
        FfiConverterSequenceTypeDerivationPathScheme.write(value.supportedDerivationPathSchemes, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceCryptoParameters_lift(_ buf: RustBuffer) throws -> FactorSourceCryptoParameters {
    return try FfiConverterTypeFactorSourceCryptoParameters.lift(buf)
}

public func FfiConverterTypeFactorSourceCryptoParameters_lower(_ value: FactorSourceCryptoParameters) -> RustBuffer {
    return FfiConverterTypeFactorSourceCryptoParameters.lower(value)
}

/**
 * FactorSourceID from an AccountAddress, typically used by `trustedContact` FactorSource.
 */
public struct FactorSourceIdFromAddress {
    /**
     * The kind of the FactorSource this ID refers to, typically `trustedContact`.
     */
    public var kind: FactorSourceKind
    /**
     * An account address which the FactorSource this ID refers uses/needs.
     */
    public var body: AccountAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The kind of the FactorSource this ID refers to, typically `trustedContact`.
         */
        kind: FactorSourceKind,
        /**
            * An account address which the FactorSource this ID refers uses/needs.
            */
        body: AccountAddress
    ) {
        self.kind = kind
        self.body = body
    }
}

extension FactorSourceIdFromAddress: Equatable, Hashable {
    public static func == (lhs: FactorSourceIdFromAddress, rhs: FactorSourceIdFromAddress) -> Bool {
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kind)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeFactorSourceIDFromAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIdFromAddress {
        return
            try FactorSourceIdFromAddress(
                kind: FfiConverterTypeFactorSourceKind.read(from: &buf),
                body: FfiConverterTypeAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceIdFromAddress, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.kind, into: &buf)
        FfiConverterTypeAccountAddress.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceIDFromAddress_lift(_ buf: RustBuffer) throws -> FactorSourceIdFromAddress {
    return try FfiConverterTypeFactorSourceIDFromAddress.lift(buf)
}

public func FfiConverterTypeFactorSourceIDFromAddress_lower(_ value: FactorSourceIdFromAddress) -> RustBuffer {
    return FfiConverterTypeFactorSourceIDFromAddress.lower(value)
}

/**
 * FactorSourceID from the blake2b hash of the special HD public key derived at `CAP26::GetID`,
 * for a certain `FactorSourceKind`
 */
public struct FactorSourceIdFromHash {
    /**
     * The kind of the FactorSource this ID refers to, typically `device` or `ledger`.
     */
    public var kind: FactorSourceKind
    /**
     * The blake2b hash of the special HD public key derived at `CAP26::GetID`.
     */
    public var body: Hex32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The kind of the FactorSource this ID refers to, typically `device` or `ledger`.
         */
        kind: FactorSourceKind,
        /**
            * The blake2b hash of the special HD public key derived at `CAP26::GetID`.
            */
        body: Hex32Bytes
    ) {
        self.kind = kind
        self.body = body
    }
}

extension FactorSourceIdFromHash: Equatable, Hashable {
    public static func == (lhs: FactorSourceIdFromHash, rhs: FactorSourceIdFromHash) -> Bool {
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kind)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeFactorSourceIDFromHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIdFromHash {
        return
            try FactorSourceIdFromHash(
                kind: FfiConverterTypeFactorSourceKind.read(from: &buf),
                body: FfiConverterTypeHex32Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceIdFromHash, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.kind, into: &buf)
        FfiConverterTypeHex32Bytes.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceIDFromHash_lift(_ buf: RustBuffer) throws -> FactorSourceIdFromHash {
    return try FfiConverterTypeFactorSourceIDFromHash.lift(buf)
}

public func FfiConverterTypeFactorSourceIDFromHash_lower(_ value: FactorSourceIdFromHash) -> RustBuffer {
    return FfiConverterTypeFactorSourceIDFromHash.lower(value)
}

/**
 * A gateway to some Radix Network, which is a high level REST API which clients (wallets) can
 * consume in order to query asset balances and submit transactions.
 */
public struct Gateway {
    /**
     * The Radix network the API is a Gateway to.
     */
    public var network: NetworkDefinition
    /**
     * The URL to the gateways API endpoint
     */
    public var url: Url

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The Radix network the API is a Gateway to.
         */
        network: NetworkDefinition,
        /**
            * The URL to the gateways API endpoint
            */
        url: Url
    ) {
        self.network = network
        self.url = url
    }
}

extension Gateway: Equatable, Hashable {
    public static func == (lhs: Gateway, rhs: Gateway) -> Bool {
        if lhs.network != rhs.network {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(network)
        hasher.combine(url)
    }
}

public struct FfiConverterTypeGateway: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Gateway {
        return
            try Gateway(
                network: FfiConverterTypeNetworkDefinition.read(from: &buf),
                url: FfiConverterTypeUrl.read(from: &buf)
            )
    }

    public static func write(_ value: Gateway, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkDefinition.write(value.network, into: &buf)
        FfiConverterTypeUrl.write(value.url, into: &buf)
    }
}

public func FfiConverterTypeGateway_lift(_ buf: RustBuffer) throws -> Gateway {
    return try FfiConverterTypeGateway.lift(buf)
}

public func FfiConverterTypeGateway_lower(_ value: Gateway) -> RustBuffer {
    return FfiConverterTypeGateway.lower(value)
}

/**
 * The currently used Gateway and a collection of other by user added
 * or predefined Gateways the user can switch to.
 */
public struct Gateways {
    /**
     * The currently used Gateway, when a user query's asset balances of
     * accounts or submits transactions, this Gateway will be used.
     */
    public var current: Gateway
    /**
     * Other by user added or predefined Gateways the user can switch to.
     * It might be Gateways with different URLs on the SAME network, or
     * other networks, the identifier of a Gateway is the URL.
     */
    public var other: [Gateway]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The currently used Gateway, when a user query's asset balances of
         * accounts or submits transactions, this Gateway will be used.
         */
        current: Gateway,
        /**
            * Other by user added or predefined Gateways the user can switch to.
            * It might be Gateways with different URLs on the SAME network, or
            * other networks, the identifier of a Gateway is the URL.
            */
        other: [Gateway]
    ) {
        self.current = current
        self.other = other
    }
}

extension Gateways: Equatable, Hashable {
    public static func == (lhs: Gateways, rhs: Gateways) -> Bool {
        if lhs.current != rhs.current {
            return false
        }
        if lhs.other != rhs.other {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(current)
        hasher.combine(other)
    }
}

public struct FfiConverterTypeGateways: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Gateways {
        return
            try Gateways(
                current: FfiConverterTypeGateway.read(from: &buf),
                other: FfiConverterSequenceTypeGateway.read(from: &buf)
            )
    }

    public static func write(_ value: Gateways, into buf: inout [UInt8]) {
        FfiConverterTypeGateway.write(value.current, into: &buf)
        FfiConverterSequenceTypeGateway.write(value.other, into: &buf)
    }
}

public func FfiConverterTypeGateways_lift(_ buf: RustBuffer) throws -> Gateways {
    return try FfiConverterTypeGateways.lift(buf)
}

public func FfiConverterTypeGateways_lower(_ value: Gateways) -> RustBuffer {
    return FfiConverterTypeGateways.lower(value)
}

/**
 * Use it with `GetIDPath::default()` to create the path `m/44'/1022'/365'`
 * which is used by all hierarchal deterministic factor sources to derive
 * the special root key which we hash to form the `FactorSourceIDFromHash`
 */
public struct GetIdPath {
    public var path: HdPath

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        path: HdPath)
    {
        self.path = path
    }
}

extension GetIdPath: Equatable, Hashable {
    public static func == (lhs: GetIdPath, rhs: GetIdPath) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
    }
}

public struct FfiConverterTypeGetIDPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetIdPath {
        return
            try GetIdPath(
                path: FfiConverterTypeHDPath.read(from: &buf)
            )
    }

    public static func write(_ value: GetIdPath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPath.write(value.path, into: &buf)
    }
}

public func FfiConverterTypeGetIDPath_lift(_ buf: RustBuffer) throws -> GetIdPath {
    return try FfiConverterTypeGetIDPath.lift(buf)
}

public func FfiConverterTypeGetIDPath_lower(_ value: GetIdPath) -> RustBuffer {
    return FfiConverterTypeGetIDPath.lower(value)
}

public struct HdPath {
    public var components: [HdPathComponent]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        components: [HdPathComponent])
    {
        self.components = components
    }
}

extension HdPath: Equatable, Hashable {
    public static func == (lhs: HdPath, rhs: HdPath) -> Bool {
        if lhs.components != rhs.components {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(components)
    }
}

public struct FfiConverterTypeHDPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdPath {
        return
            try HdPath(
                components: FfiConverterSequenceTypeHDPathComponent.read(from: &buf)
            )
    }

    public static func write(_ value: HdPath, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeHDPathComponent.write(value.components, into: &buf)
    }
}

public func FfiConverterTypeHDPath_lift(_ buf: RustBuffer) throws -> HdPath {
    return try FfiConverterTypeHDPath.lift(buf)
}

public func FfiConverterTypeHDPath_lower(_ value: HdPath) -> RustBuffer {
    return FfiConverterTypeHDPath.lower(value)
}

public struct HdPathComponent {
    public var value: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        value: UInt32)
    {
        self.value = value
    }
}

extension HdPathComponent: Equatable, Hashable {
    public static func == (lhs: HdPathComponent, rhs: HdPathComponent) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeHDPathComponent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdPathComponent {
        return
            try HdPathComponent(
                value: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: HdPathComponent, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeHDPathComponent_lift(_ buf: RustBuffer) throws -> HdPathComponent {
    return try FfiConverterTypeHDPathComponent.lift(buf)
}

public func FfiConverterTypeHDPathComponent_lower(_ value: HdPathComponent) -> RustBuffer {
    return FfiConverterTypeHDPathComponent.lower(value)
}

/**
 * The header of a Profile(Snapshot) contains crucial metadata
 * about this Profile, such as which JSON data format it is
 * compatible with and which device was used to create it and
 * a hint about its contents.
 */
public struct Header {
    /**
     * A versioning number that is increased when breaking
     * changes is made to ProfileSnapshot JSON data format.
     */
    public var snapshotVersion: ProfileSnapshotVersion
    /**
     * An immutable and unique identifier of a Profile.
     */
    public var id: ProfileID
    /**
     * The device which was used to create the Profile.
     */
    public var creatingDevice: DeviceInfo
    /**
     * The device on which the profile was last used.
     */
    public var lastUsedOnDevice: DeviceInfo
    /**
     * When the Profile was last modified.
     */
    public var lastModified: Timestamp
    /**
     * Hint about the contents of the profile, e.g. number of Accounts and Personas.
     */
    public var contentHint: ContentHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A versioning number that is increased when breaking
         * changes is made to ProfileSnapshot JSON data format.
         */
        snapshotVersion: ProfileSnapshotVersion,
        /**
            * An immutable and unique identifier of a Profile.
            */
        id: ProfileID,
        /**
            * The device which was used to create the Profile.
            */
        creatingDevice: DeviceInfo,
        /**
            * The device on which the profile was last used.
            */
        lastUsedOnDevice: DeviceInfo,
        /**
            * When the Profile was last modified.
            */
        lastModified: Timestamp,
        /**
            * Hint about the contents of the profile, e.g. number of Accounts and Personas.
            */
        contentHint: ContentHint
    ) {
        self.snapshotVersion = snapshotVersion
        self.id = id
        self.creatingDevice = creatingDevice
        self.lastUsedOnDevice = lastUsedOnDevice
        self.lastModified = lastModified
        self.contentHint = contentHint
    }
}

extension Header: Equatable, Hashable {
    public static func == (lhs: Header, rhs: Header) -> Bool {
        if lhs.snapshotVersion != rhs.snapshotVersion {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.creatingDevice != rhs.creatingDevice {
            return false
        }
        if lhs.lastUsedOnDevice != rhs.lastUsedOnDevice {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.contentHint != rhs.contentHint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(snapshotVersion)
        hasher.combine(id)
        hasher.combine(creatingDevice)
        hasher.combine(lastUsedOnDevice)
        hasher.combine(lastModified)
        hasher.combine(contentHint)
    }
}

public struct FfiConverterTypeHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Header {
        return
            try Header(
                snapshotVersion: FfiConverterTypeProfileSnapshotVersion.read(from: &buf),
                id: FfiConverterTypeProfileID.read(from: &buf),
                creatingDevice: FfiConverterTypeDeviceInfo.read(from: &buf),
                lastUsedOnDevice: FfiConverterTypeDeviceInfo.read(from: &buf),
                lastModified: FfiConverterTypeTimestamp.read(from: &buf),
                contentHint: FfiConverterTypeContentHint.read(from: &buf)
            )
    }

    public static func write(_ value: Header, into buf: inout [UInt8]) {
        FfiConverterTypeProfileSnapshotVersion.write(value.snapshotVersion, into: &buf)
        FfiConverterTypeProfileID.write(value.id, into: &buf)
        FfiConverterTypeDeviceInfo.write(value.creatingDevice, into: &buf)
        FfiConverterTypeDeviceInfo.write(value.lastUsedOnDevice, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastModified, into: &buf)
        FfiConverterTypeContentHint.write(value.contentHint, into: &buf)
    }
}

public func FfiConverterTypeHeader_lift(_ buf: RustBuffer) throws -> Header {
    return try FfiConverterTypeHeader.lift(buf)
}

public func FfiConverterTypeHeader_lower(_ value: Header) -> RustBuffer {
    return FfiConverterTypeHeader.lower(value)
}

/**
 * Serializable $byte_count bytes which **always** serializes as a **hex** string, this is useful
 * since in Radix Wallet Kit we almost always want to serialize bytes into hex and this
 * allows us to skip using
 */
public struct Hex32Bytes {
    public var bagOfBytes: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        bagOfBytes: BagOfBytes)
    {
        self.bagOfBytes = bagOfBytes
    }
}

extension Hex32Bytes: Equatable, Hashable {
    public static func == (lhs: Hex32Bytes, rhs: Hex32Bytes) -> Bool {
        if lhs.bagOfBytes != rhs.bagOfBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bagOfBytes)
    }
}

public struct FfiConverterTypeHex32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hex32Bytes {
        return
            try Hex32Bytes(
                bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Hex32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
    }
}

public func FfiConverterTypeHex32Bytes_lift(_ buf: RustBuffer) throws -> Hex32Bytes {
    return try FfiConverterTypeHex32Bytes.lift(buf)
}

public func FfiConverterTypeHex32Bytes_lower(_ value: Hex32Bytes) -> RustBuffer {
    return FfiConverterTypeHex32Bytes.lower(value)
}

/**
 * Serializable $byte_count bytes which **always** serializes as a **hex** string, this is useful
 * since in Radix Wallet Kit we almost always want to serialize bytes into hex and this
 * allows us to skip using
 */
public struct Hex33Bytes {
    public var bagOfBytes: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        bagOfBytes: BagOfBytes)
    {
        self.bagOfBytes = bagOfBytes
    }
}

extension Hex33Bytes: Equatable, Hashable {
    public static func == (lhs: Hex33Bytes, rhs: Hex33Bytes) -> Bool {
        if lhs.bagOfBytes != rhs.bagOfBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bagOfBytes)
    }
}

public struct FfiConverterTypeHex33Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hex33Bytes {
        return
            try Hex33Bytes(
                bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Hex33Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
    }
}

public func FfiConverterTypeHex33Bytes_lift(_ buf: RustBuffer) throws -> Hex33Bytes {
    return try FfiConverterTypeHex33Bytes.lift(buf)
}

public func FfiConverterTypeHex33Bytes_lower(_ value: Hex33Bytes) -> RustBuffer {
    return FfiConverterTypeHex33Bytes.lower(value)
}

/**
 * Serializable $byte_count bytes which **always** serializes as a **hex** string, this is useful
 * since in Radix Wallet Kit we almost always want to serialize bytes into hex and this
 * allows us to skip using
 */
public struct Hex64Bytes {
    public var bagOfBytes: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        bagOfBytes: BagOfBytes)
    {
        self.bagOfBytes = bagOfBytes
    }
}

extension Hex64Bytes: Equatable, Hashable {
    public static func == (lhs: Hex64Bytes, rhs: Hex64Bytes) -> Bool {
        if lhs.bagOfBytes != rhs.bagOfBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bagOfBytes)
    }
}

public struct FfiConverterTypeHex64Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hex64Bytes {
        return
            try Hex64Bytes(
                bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Hex64Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
    }
}

public func FfiConverterTypeHex64Bytes_lift(_ buf: RustBuffer) throws -> Hex64Bytes {
    return try FfiConverterTypeHex64Bytes.lift(buf)
}

public func FfiConverterTypeHex64Bytes_lower(_ value: Hex64Bytes) -> RustBuffer {
    return FfiConverterTypeHex64Bytes.lower(value)
}

/**
 * Serializable $byte_count bytes which **always** serializes as a **hex** string, this is useful
 * since in Radix Wallet Kit we almost always want to serialize bytes into hex and this
 * allows us to skip using
 */
public struct Hex65Bytes {
    public var bagOfBytes: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        bagOfBytes: BagOfBytes)
    {
        self.bagOfBytes = bagOfBytes
    }
}

extension Hex65Bytes: Equatable, Hashable {
    public static func == (lhs: Hex65Bytes, rhs: Hex65Bytes) -> Bool {
        if lhs.bagOfBytes != rhs.bagOfBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bagOfBytes)
    }
}

public struct FfiConverterTypeHex65Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hex65Bytes {
        return
            try Hex65Bytes(
                bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Hex65Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
    }
}

public func FfiConverterTypeHex65Bytes_lift(_ buf: RustBuffer) throws -> Hex65Bytes {
    return try FfiConverterTypeHex65Bytes.lift(buf)
}

public func FfiConverterTypeHex65Bytes_lower(_ value: Hex65Bytes) -> RustBuffer {
    return FfiConverterTypeHex65Bytes.lower(value)
}

/**
 * A virtual hierarchical deterministic `FactorInstance`
 */
public struct HierarchicalDeterministicFactorInstance {
    public var factorSourceId: FactorSourceIdFromHash
    public var publicKey: HierarchicalDeterministicPublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        factorSourceId: FactorSourceIdFromHash,
        publicKey: HierarchicalDeterministicPublicKey
    ) {
        self.factorSourceId = factorSourceId
        self.publicKey = publicKey
    }
}

extension HierarchicalDeterministicFactorInstance: Equatable, Hashable {
    public static func == (lhs: HierarchicalDeterministicFactorInstance, rhs: HierarchicalDeterministicFactorInstance) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(publicKey)
    }
}

public struct FfiConverterTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HierarchicalDeterministicFactorInstance {
        return
            try HierarchicalDeterministicFactorInstance(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                publicKey: FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: HierarchicalDeterministicFactorInstance, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterTypeHierarchicalDeterministicPublicKey.write(value.publicKey, into: &buf)
    }
}

public func FfiConverterTypeHierarchicalDeterministicFactorInstance_lift(_ buf: RustBuffer) throws -> HierarchicalDeterministicFactorInstance {
    return try FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(buf)
}

public func FfiConverterTypeHierarchicalDeterministicFactorInstance_lower(_ value: HierarchicalDeterministicFactorInstance) -> RustBuffer {
    return FfiConverterTypeHierarchicalDeterministicFactorInstance.lower(value)
}

/**
 * The **source** of a virtual hierarchical deterministic badge, contains a
 * derivation path and public key, from which a private key is derived which
 * produces virtual badges (signatures).
 *
 * The `.device` `FactorSource` produces `FactorInstance`s with this kind if badge source.
 */
public struct HierarchicalDeterministicPublicKey {
    /**
     * The expected public key of the private key derived at `derivationPath`
     */
    public var publicKey: PublicKey
    /**
     * The HD derivation path for the key pair which produces virtual badges (signatures).
     */
    public var derivationPath: DerivationPath

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The expected public key of the private key derived at `derivationPath`
         */
        publicKey: PublicKey,
        /**
            * The HD derivation path for the key pair which produces virtual badges (signatures).
            */
        derivationPath: DerivationPath
    ) {
        self.publicKey = publicKey
        self.derivationPath = derivationPath
    }
}

extension HierarchicalDeterministicPublicKey: Equatable, Hashable {
    public static func == (lhs: HierarchicalDeterministicPublicKey, rhs: HierarchicalDeterministicPublicKey) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.derivationPath != rhs.derivationPath {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(derivationPath)
    }
}

public struct FfiConverterTypeHierarchicalDeterministicPublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HierarchicalDeterministicPublicKey {
        return
            try HierarchicalDeterministicPublicKey(
                publicKey: FfiConverterTypePublicKey.read(from: &buf),
                derivationPath: FfiConverterTypeDerivationPath.read(from: &buf)
            )
    }

    public static func write(_ value: HierarchicalDeterministicPublicKey, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterTypeDerivationPath.write(value.derivationPath, into: &buf)
    }
}

public func FfiConverterTypeHierarchicalDeterministicPublicKey_lift(_ buf: RustBuffer) throws -> HierarchicalDeterministicPublicKey {
    return try FfiConverterTypeHierarchicalDeterministicPublicKey.lift(buf)
}

public func FfiConverterTypeHierarchicalDeterministicPublicKey_lower(_ value: HierarchicalDeterministicPublicKey) -> RustBuffer {
    return FfiConverterTypeHierarchicalDeterministicPublicKey.lower(value)
}

/**
 * Human readable address of an identity, which are used by Personas. Always starts with
 * the prefix `"identity_"`, for example:
 *
 * `identity_rdx12tgzjrz9u0xz4l28vf04hz87eguclmfaq4d2p8f8lv7zg9ssnzku8j`
 *
 * Addresses are checksummed, as per Bech32. **Only** *Identity* addresses starts with
 * the prefix `"identity_"`.
 */
public struct IdentityAddress {
    public var inner: InnerIdentityAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        inner: InnerIdentityAddress)
    {
        self.inner = inner
    }
}

extension IdentityAddress: Equatable, Hashable {
    public static func == (lhs: IdentityAddress, rhs: IdentityAddress) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeIdentityAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityAddress {
        return
            try IdentityAddress(
                inner: FfiConverterTypeInnerIdentityAddress.read(from: &buf)
            )
    }

    public static func write(_ value: IdentityAddress, into buf: inout [UInt8]) {
        FfiConverterTypeInnerIdentityAddress.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeIdentityAddress_lift(_ buf: RustBuffer) throws -> IdentityAddress {
    return try FfiConverterTypeIdentityAddress.lift(buf)
}

public func FfiConverterTypeIdentityAddress_lower(_ value: IdentityAddress) -> RustBuffer {
    return FfiConverterTypeIdentityAddress.lower(value)
}

public struct IdentityPath {
    public var path: HdPath
    public var networkId: NetworkId
    public var entityKind: Cap26EntityKind
    public var keyKind: Cap26KeyKind
    public var index: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        path: HdPath,
        networkId: NetworkId,
        entityKind: Cap26EntityKind,
        keyKind: Cap26KeyKind,
        index: UInt32
    ) {
        self.path = path
        self.networkId = networkId
        self.entityKind = entityKind
        self.keyKind = keyKind
        self.index = index
    }
}

extension IdentityPath: Equatable, Hashable {
    public static func == (lhs: IdentityPath, rhs: IdentityPath) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.entityKind != rhs.entityKind {
            return false
        }
        if lhs.keyKind != rhs.keyKind {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(networkId)
        hasher.combine(entityKind)
        hasher.combine(keyKind)
        hasher.combine(index)
    }
}

public struct FfiConverterTypeIdentityPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityPath {
        return
            try IdentityPath(
                path: FfiConverterTypeHDPath.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                entityKind: FfiConverterTypeCAP26EntityKind.read(from: &buf),
                keyKind: FfiConverterTypeCAP26KeyKind.read(from: &buf),
                index: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: IdentityPath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPath.write(value.path, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeCAP26EntityKind.write(value.entityKind, into: &buf)
        FfiConverterTypeCAP26KeyKind.write(value.keyKind, into: &buf)
        FfiConverterUInt32.write(value.index, into: &buf)
    }
}

public func FfiConverterTypeIdentityPath_lift(_ buf: RustBuffer) throws -> IdentityPath {
    return try FfiConverterTypeIdentityPath.lift(buf)
}

public func FfiConverterTypeIdentityPath_lower(_ value: IdentityPath) -> RustBuffer {
    return FfiConverterTypeIdentityPath.lower(value)
}

public struct LedgerHardwareWalletFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic,
     * that is secured by the Ledger Hardware Wallet device.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     *
     * Has interior mutability since we must be able to update the
     * last used date.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a LedgerHardwareWalletFactorSource to help user disambiguate between it and another one.
     */
    public var hint: LedgerHardwareWalletHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic,
         * that is secured by the Ledger Hardware Wallet device.
         */
        id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            *
            * Has interior mutability since we must be able to update the
            * last used date.
            */
        common: FactorSourceCommon,
        /**
            * Properties describing a LedgerHardwareWalletFactorSource to help user disambiguate between it and another one.
            */
        hint: LedgerHardwareWalletHint
    ) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}

extension LedgerHardwareWalletFactorSource: Equatable, Hashable {
    public static func == (lhs: LedgerHardwareWalletFactorSource, rhs: LedgerHardwareWalletFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}

public struct FfiConverterTypeLedgerHardwareWalletFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletFactorSource {
        return
            try LedgerHardwareWalletFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                hint: FfiConverterTypeLedgerHardwareWalletHint.read(from: &buf)
            )
    }

    public static func write(_ value: LedgerHardwareWalletFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeLedgerHardwareWalletHint.write(value.hint, into: &buf)
    }
}

public func FfiConverterTypeLedgerHardwareWalletFactorSource_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletFactorSource {
    return try FfiConverterTypeLedgerHardwareWalletFactorSource.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletFactorSource_lower(_ value: LedgerHardwareWalletFactorSource) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletFactorSource.lower(value)
}

public struct LedgerHardwareWalletHint {
    /**
     * "Orange, scratched"
     */
    public var name: String
    /**
     * E.g. `nanoS+`
     */
    public var model: LedgerHardwareWalletModel

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * "Orange, scratched"
         */
        name: String,
        /**
            * E.g. `nanoS+`
            */
        model: LedgerHardwareWalletModel
    ) {
        self.name = name
        self.model = model
    }
}

extension LedgerHardwareWalletHint: Equatable, Hashable {
    public static func == (lhs: LedgerHardwareWalletHint, rhs: LedgerHardwareWalletHint) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
    }
}

public struct FfiConverterTypeLedgerHardwareWalletHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletHint {
        return
            try LedgerHardwareWalletHint(
                name: FfiConverterString.read(from: &buf),
                model: FfiConverterTypeLedgerHardwareWalletModel.read(from: &buf)
            )
    }

    public static func write(_ value: LedgerHardwareWalletHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeLedgerHardwareWalletModel.write(value.model, into: &buf)
    }
}

public func FfiConverterTypeLedgerHardwareWalletHint_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletHint {
    return try FfiConverterTypeLedgerHardwareWalletHint.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletHint_lower(_ value: LedgerHardwareWalletHint) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletHint.lower(value)
}

public struct LocaleConfig {
    public var decimalSeparator: String?
    public var groupingSeparator: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        decimalSeparator: String?,
        groupingSeparator: String?
    ) {
        self.decimalSeparator = decimalSeparator
        self.groupingSeparator = groupingSeparator
    }
}

extension LocaleConfig: Equatable, Hashable {
    public static func == (lhs: LocaleConfig, rhs: LocaleConfig) -> Bool {
        if lhs.decimalSeparator != rhs.decimalSeparator {
            return false
        }
        if lhs.groupingSeparator != rhs.groupingSeparator {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(decimalSeparator)
        hasher.combine(groupingSeparator)
    }
}

public struct FfiConverterTypeLocaleConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocaleConfig {
        return
            try LocaleConfig(
                decimalSeparator: FfiConverterOptionString.read(from: &buf),
                groupingSeparator: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: LocaleConfig, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.decimalSeparator, into: &buf)
        FfiConverterOptionString.write(value.groupingSeparator, into: &buf)
    }
}

public func FfiConverterTypeLocaleConfig_lift(_ buf: RustBuffer) throws -> LocaleConfig {
    return try FfiConverterTypeLocaleConfig.lift(buf)
}

public func FfiConverterTypeLocaleConfig_lower(_ value: LocaleConfig) -> RustBuffer {
    return FfiConverterTypeLocaleConfig.lower(value)
}

public struct ManifestSummary {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension ManifestSummary: Equatable, Hashable {
    public static func == (_: ManifestSummary, _: ManifestSummary) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeManifestSummary: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> ManifestSummary {
        return
            ManifestSummary()
    }

    public static func write(_: ManifestSummary, into _: inout [UInt8]) {}
}

public func FfiConverterTypeManifestSummary_lift(_ buf: RustBuffer) throws -> ManifestSummary {
    return try FfiConverterTypeManifestSummary.lift(buf)
}

public func FfiConverterTypeManifestSummary_lower(_ value: ManifestSummary) -> RustBuffer {
    return FfiConverterTypeManifestSummary.lower(value)
}

public struct Mnemonic {
    public var words: [Bip39Word]
    public var wordCount: Bip39WordCount
    public var language: Bip39Language

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        words: [Bip39Word],
        wordCount: Bip39WordCount,
        language: Bip39Language
    ) {
        self.words = words
        self.wordCount = wordCount
        self.language = language
    }
}

extension Mnemonic: Equatable, Hashable {
    public static func == (lhs: Mnemonic, rhs: Mnemonic) -> Bool {
        if lhs.words != rhs.words {
            return false
        }
        if lhs.wordCount != rhs.wordCount {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(words)
        hasher.combine(wordCount)
        hasher.combine(language)
    }
}

public struct FfiConverterTypeMnemonic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        return
            try Mnemonic(
                words: FfiConverterSequenceTypeBIP39Word.read(from: &buf),
                wordCount: FfiConverterTypeBIP39WordCount.read(from: &buf),
                language: FfiConverterTypeBIP39Language.read(from: &buf)
            )
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBIP39Word.write(value.words, into: &buf)
        FfiConverterTypeBIP39WordCount.write(value.wordCount, into: &buf)
        FfiConverterTypeBIP39Language.write(value.language, into: &buf)
    }
}

public func FfiConverterTypeMnemonic_lift(_ buf: RustBuffer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(buf)
}

public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> RustBuffer {
    return FfiConverterTypeMnemonic.lower(value)
}

/**
 * A BIP39 Mnemonic and BIP39 passphrase - aka "25th word" tuple,
 * from which we can derive a HD Root used for derivation.
 */
public struct MnemonicWithPassphrase {
    public var mnemonic: Mnemonic
    public var passphrase: BIP39Passphrase

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        mnemonic: Mnemonic,
        passphrase: BIP39Passphrase
    ) {
        self.mnemonic = mnemonic
        self.passphrase = passphrase
    }
}

extension MnemonicWithPassphrase: Equatable, Hashable {
    public static func == (lhs: MnemonicWithPassphrase, rhs: MnemonicWithPassphrase) -> Bool {
        if lhs.mnemonic != rhs.mnemonic {
            return false
        }
        if lhs.passphrase != rhs.passphrase {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonic)
        hasher.combine(passphrase)
    }
}

public struct FfiConverterTypeMnemonicWithPassphrase: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicWithPassphrase {
        return
            try MnemonicWithPassphrase(
                mnemonic: FfiConverterTypeMnemonic.read(from: &buf),
                passphrase: FfiConverterTypeBIP39Passphrase.read(from: &buf)
            )
    }

    public static func write(_ value: MnemonicWithPassphrase, into buf: inout [UInt8]) {
        FfiConverterTypeMnemonic.write(value.mnemonic, into: &buf)
        FfiConverterTypeBIP39Passphrase.write(value.passphrase, into: &buf)
    }
}

public func FfiConverterTypeMnemonicWithPassphrase_lift(_ buf: RustBuffer) throws -> MnemonicWithPassphrase {
    return try FfiConverterTypeMnemonicWithPassphrase.lift(buf)
}

public func FfiConverterTypeMnemonicWithPassphrase_lower(_ value: MnemonicWithPassphrase) -> RustBuffer {
    return FfiConverterTypeMnemonicWithPassphrase.lower(value)
}

/**
 * A version of the Radix Network, for a NetworkID with an identifier (name) and display description (display name)
 */
public struct NetworkDefinition {
    /**
     * A String identifier (always lowercase) with the name of the Network that MUST match what Gateway returns.
     */
    public var logicalName: String
    /**
     * The canonical identifier of this network.
     */
    public var id: NetworkId
    /**
     * A name of the network intended for display purposes only.
     */
    public var displayDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A String identifier (always lowercase) with the name of the Network that MUST match what Gateway returns.
         */
        logicalName: String,
        /**
            * The canonical identifier of this network.
            */
        id: NetworkId,
        /**
            * A name of the network intended for display purposes only.
            */
        displayDescription: String
    ) {
        self.logicalName = logicalName
        self.id = id
        self.displayDescription = displayDescription
    }
}

extension NetworkDefinition: Equatable, Hashable {
    public static func == (lhs: NetworkDefinition, rhs: NetworkDefinition) -> Bool {
        if lhs.logicalName != rhs.logicalName {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.displayDescription != rhs.displayDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(logicalName)
        hasher.combine(id)
        hasher.combine(displayDescription)
    }
}

public struct FfiConverterTypeNetworkDefinition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkDefinition {
        return
            try NetworkDefinition(
                logicalName: FfiConverterString.read(from: &buf),
                id: FfiConverterTypeNetworkID.read(from: &buf),
                displayDescription: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: NetworkDefinition, into buf: inout [UInt8]) {
        FfiConverterString.write(value.logicalName, into: &buf)
        FfiConverterTypeNetworkID.write(value.id, into: &buf)
        FfiConverterString.write(value.displayDescription, into: &buf)
    }
}

public func FfiConverterTypeNetworkDefinition_lift(_ buf: RustBuffer) throws -> NetworkDefinition {
    return try FfiConverterTypeNetworkDefinition.lift(buf)
}

public func FfiConverterTypeNetworkDefinition_lower(_ value: NetworkDefinition) -> RustBuffer {
    return FfiConverterTypeNetworkDefinition.lower(value)
}

public struct NonFungibleGlobalId {
    public var resourceAddress: ResourceAddress
    public var nonFungibleLocalId: NonFungibleLocalId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        resourceAddress: ResourceAddress,
        nonFungibleLocalId: NonFungibleLocalId
    ) {
        self.resourceAddress = resourceAddress
        self.nonFungibleLocalId = nonFungibleLocalId
    }
}

extension NonFungibleGlobalId: Equatable, Hashable {
    public static func == (lhs: NonFungibleGlobalId, rhs: NonFungibleGlobalId) -> Bool {
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.nonFungibleLocalId != rhs.nonFungibleLocalId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resourceAddress)
        hasher.combine(nonFungibleLocalId)
    }
}

public struct FfiConverterTypeNonFungibleGlobalId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleGlobalId {
        return
            try NonFungibleGlobalId(
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                nonFungibleLocalId: FfiConverterTypeNonFungibleLocalId.read(from: &buf)
            )
    }

    public static func write(_ value: NonFungibleGlobalId, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeNonFungibleLocalId.write(value.nonFungibleLocalId, into: &buf)
    }
}

public func FfiConverterTypeNonFungibleGlobalId_lift(_ buf: RustBuffer) throws -> NonFungibleGlobalId {
    return try FfiConverterTypeNonFungibleGlobalId.lift(buf)
}

public func FfiConverterTypeNonFungibleGlobalId_lower(_ value: NonFungibleGlobalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleGlobalId.lower(value)
}

public struct NotarizedTransaction {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension NotarizedTransaction: Equatable, Hashable {
    public static func == (_: NotarizedTransaction, _: NotarizedTransaction) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeNotarizedTransaction: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> NotarizedTransaction {
        return
            NotarizedTransaction()
    }

    public static func write(_: NotarizedTransaction, into _: inout [UInt8]) {}
}

public func FfiConverterTypeNotarizedTransaction_lift(_ buf: RustBuffer) throws -> NotarizedTransaction {
    return try FfiConverterTypeNotarizedTransaction.lift(buf)
}

public func FfiConverterTypeNotarizedTransaction_lower(_ value: NotarizedTransaction) -> RustBuffer {
    return FfiConverterTypeNotarizedTransaction.lower(value)
}

/**
 * Account settings that user has set on the account component
 * On-Ledger, that is set via a transaction mutating the state
 * on the network.
 *
 * This settings include third-party deposits, controlling who
 * can send which assets to this account.
 *
 * These settings SHOULD be kept in sync between local state
 * (in Profile) and On-Ledger.
 */
public struct OnLedgerSettings {
    /**
     * Controls the ability of third-parties to deposit into this account
     */
    public var thirdPartyDeposits: ThirdPartyDeposits

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Controls the ability of third-parties to deposit into this account
         */
        thirdPartyDeposits: ThirdPartyDeposits
    ) {
        self.thirdPartyDeposits = thirdPartyDeposits
    }
}

extension OnLedgerSettings: Equatable, Hashable {
    public static func == (lhs: OnLedgerSettings, rhs: OnLedgerSettings) -> Bool {
        if lhs.thirdPartyDeposits != rhs.thirdPartyDeposits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thirdPartyDeposits)
    }
}

public struct FfiConverterTypeOnLedgerSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnLedgerSettings {
        return
            try OnLedgerSettings(
                thirdPartyDeposits: FfiConverterTypeThirdPartyDeposits.read(from: &buf)
            )
    }

    public static func write(_ value: OnLedgerSettings, into buf: inout [UInt8]) {
        FfiConverterTypeThirdPartyDeposits.write(value.thirdPartyDeposits, into: &buf)
    }
}

public func FfiConverterTypeOnLedgerSettings_lift(_ buf: RustBuffer) throws -> OnLedgerSettings {
    return try FfiConverterTypeOnLedgerSettings.lift(buf)
}

public func FfiConverterTypeOnLedgerSettings_lower(_ value: OnLedgerSettings) -> RustBuffer {
    return FfiConverterTypeOnLedgerSettings.lower(value)
}

/**
 * A client the user have connected P2P with, typically a
 * WebRTC connections with a DApp, but might be Android or iPhone
 * client as well.
 */
public struct P2pLink {
    /**
     * The most important property of this struct, the `ConnectionPassword`,
     * is used to be able to re-establish the P2P connection and also acts as the seed
     * for the `ID`.
     */
    public var connectionPassword: RadixConnectPassword
    /**
     * Client name, e.g. "Chrome on Macbook" or "My work Android" or "My wifes iPhone SE".
     */
    public var displayName: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The most important property of this struct, the `ConnectionPassword`,
         * is used to be able to re-establish the P2P connection and also acts as the seed
         * for the `ID`.
         */
        connectionPassword: RadixConnectPassword,
        /**
            * Client name, e.g. "Chrome on Macbook" or "My work Android" or "My wifes iPhone SE".
            */
        displayName: String
    ) {
        self.connectionPassword = connectionPassword
        self.displayName = displayName
    }
}

extension P2pLink: Equatable, Hashable {
    public static func == (lhs: P2pLink, rhs: P2pLink) -> Bool {
        if lhs.connectionPassword != rhs.connectionPassword {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(connectionPassword)
        hasher.combine(displayName)
    }
}

public struct FfiConverterTypeP2PLink: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> P2pLink {
        return
            try P2pLink(
                connectionPassword: FfiConverterTypeRadixConnectPassword.read(from: &buf),
                displayName: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: P2pLink, into buf: inout [UInt8]) {
        FfiConverterTypeRadixConnectPassword.write(value.connectionPassword, into: &buf)
        FfiConverterString.write(value.displayName, into: &buf)
    }
}

public func FfiConverterTypeP2PLink_lift(_ buf: RustBuffer) throws -> P2pLink {
    return try FfiConverterTypeP2PLink.lift(buf)
}

public func FfiConverterTypeP2PLink_lower(_ value: P2pLink) -> RustBuffer {
    return FfiConverterTypeP2PLink.lower(value)
}

public struct PackageAddress {
    public var inner: InnerPackageAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        inner: InnerPackageAddress)
    {
        self.inner = inner
    }
}

extension PackageAddress: Equatable, Hashable {
    public static func == (lhs: PackageAddress, rhs: PackageAddress) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypePackageAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PackageAddress {
        return
            try PackageAddress(
                inner: FfiConverterTypeInnerPackageAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PackageAddress, into buf: inout [UInt8]) {
        FfiConverterTypeInnerPackageAddress.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypePackageAddress_lift(_ buf: RustBuffer) throws -> PackageAddress {
    return try FfiConverterTypePackageAddress.lift(buf)
}

public func FfiConverterTypePackageAddress_lower(_ value: PackageAddress) -> RustBuffer {
    return FfiConverterTypePackageAddress.lower(value)
}

/**
 * A Persona is an identity a user choses to login to a dApp with, using
 * RadixConnect - Radix decentralized login solution. A persona is very
 * similar to [`Account`]s, in the sense that they are On-Network/On-Ledger
 * components, with a unique network dependent address ([`IdentityAddress`])
 * and with a security state (see [`EntitySecurityState`]) knowing which
 * factor instances that control this component, but with one important
 * difference: a Persona cannot hold funds. It is impossible to transfer
 * any asset to a Persona. The On-Network component representation of
 * the Persona is called `Identity`. The concept "Persona" is a Radix
 * Wallet (Profile) *application* of an Identity.
 *
 * Personas have data (see [`PersonaData`]), which is personal information
 * a user has associated with a this Persona, of different kinds, such as name,
 * email address(es) or phone number(s). The `PersonaData` is **never** uploaded
 * to the Radix Network, i.e. it is a pure Radix Wallet (Profile) construct,
 * On-Network Identities does not know of PersonaData, and never will (well
 * technically, nothing stops a user from building their own wallet and uploading
 * personal information to the metadata of the Identity component... but `Sargon`
 * never will, nor will the Radix Wallet.).
 */
public struct Persona {
    /**
     * The ID of the network this account can be used with.
     */
    public var networkId: NetworkId
    /**
     * The address of an identity, used by Personas, a bech32 encoding of a public key hash
     * that starts with the prefix `"identity_"`, dependent on NetworkID, meaning the same
     * public key used for two IdentityAddresses on two different networks will not have
     * the same address.
     */
    public var address: IdentityAddress
    /**
     * An off-ledger display name or description chosen by the user when they
     * created this persona.
     */
    public var displayName: DisplayName
    /**
     * Describes the state this Persona is in, in regards to how
     * the user controls it, i.e. if it is controlled by a single factor (private key)
     * or an `AccessController` with a potential Multi-Factor setup.
     */
    public var securityState: EntitySecurityState
    /**
     * An order set of `EntityFlag`s used to describe certain Off-ledger
     * user state about this Persona, e.g. if it is marked as hidden or not.
     */
    public var flags: [EntityFlag]
    /**
     * Personal information a user has associated with a certain Persona, of different kinds, such as name,
     * email address(es) or phone number(s). This information is only ever stored in Profile and is never
     * uploaded to the Radix Network.
     */
    public var personaData: PersonaData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network this account can be used with.
         */
        networkId: NetworkId,
        /**
            * The address of an identity, used by Personas, a bech32 encoding of a public key hash
            * that starts with the prefix `"identity_"`, dependent on NetworkID, meaning the same
            * public key used for two IdentityAddresses on two different networks will not have
            * the same address.
            */
        address: IdentityAddress,
        /**
            * An off-ledger display name or description chosen by the user when they
            * created this persona.
            */
        displayName: DisplayName,
        /**
            * Describes the state this Persona is in, in regards to how
            * the user controls it, i.e. if it is controlled by a single factor (private key)
            * or an `AccessController` with a potential Multi-Factor setup.
            */
        securityState: EntitySecurityState,
        /**
            * An order set of `EntityFlag`s used to describe certain Off-ledger
            * user state about this Persona, e.g. if it is marked as hidden or not.
            */
        flags: [EntityFlag],
        /**
            * Personal information a user has associated with a certain Persona, of different kinds, such as name,
            * email address(es) or phone number(s). This information is only ever stored in Profile and is never
            * uploaded to the Radix Network.
            */
        personaData: PersonaData
    ) {
        self.networkId = networkId
        self.address = address
        self.displayName = displayName
        self.securityState = securityState
        self.flags = flags
        self.personaData = personaData
    }
}

extension Persona: Equatable, Hashable {
    public static func == (lhs: Persona, rhs: Persona) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.securityState != rhs.securityState {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        if lhs.personaData != rhs.personaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(securityState)
        hasher.combine(flags)
        hasher.combine(personaData)
    }
}

public struct FfiConverterTypePersona: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Persona {
        return
            try Persona(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                address: FfiConverterTypeIdentityAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                securityState: FfiConverterTypeEntitySecurityState.read(from: &buf),
                flags: FfiConverterSequenceTypeEntityFlag.read(from: &buf),
                personaData: FfiConverterTypePersonaData.read(from: &buf)
            )
    }

    public static func write(_ value: Persona, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeIdentityAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeEntitySecurityState.write(value.securityState, into: &buf)
        FfiConverterSequenceTypeEntityFlag.write(value.flags, into: &buf)
        FfiConverterTypePersonaData.write(value.personaData, into: &buf)
    }
}

public func FfiConverterTypePersona_lift(_ buf: RustBuffer) throws -> Persona {
    return try FfiConverterTypePersona.lift(buf)
}

public func FfiConverterTypePersona_lower(_ value: Persona) -> RustBuffer {
    return FfiConverterTypePersona.lower(value)
}

/**
 * Personal information a user has associated with a certain Persona, of different kinds, such as name,
 * email address(es) or phone number(s). This information is only ever stored in Profile and is never
 * uploaded to the Radix Network.
 *
 * These entries of different kinds can be queried for in a request sent by a dApp, e.g.
 * Radix Dashboard might ask "Give me ongoing access to Name and 2 Email addresses for
 * a Persona" (just a silly example, Radix Dashboard would never ask for that and why 2 email addresses?).
 *
 * The Profile will then use the fact that each Persona Data Entry has a stable ID so that Profile can
 * refer the entry just by the ID, and Profile can thus record which Persona Data Entry a user has selected
 * to share with the dApp, without duplicating the value of that entry (just like how we use FactorSourceIDs).
 * Since a dApp can ask for *ongoing* access next time the user interacts with the same dApp, if user has
 * not revoked the dApps access, the wallet clients will automatically send back the Persona Data Entry values
 * even if they have been updated - the value might have changed but their IDs have not. Thus if a user
 * deletes a Persona Data Entry (e.g. a phone number), and later re-inputs the same phone number, even
 * it the exact same value is used, it will still be treated as a new entry since its ID is new, meaning
 * that the next time the user interacts with a previously authorized dApp the wallet cannot automatically
 * respond back to dApp with the PersonaData, but user will have to re-authorize the request for ongoing
 * access for the requested PersonaData entries.
 */
public struct PersonaData {
    /**
     * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
     * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
     *
     * Note that the type is Option of `PersonaDataIdentifiedName` and not of type [`PersonaDataEntryName`][name],
     * `PersonaDataIdentifiedName` is essentially a tuple of `(Uuid, PersonaDataEntryName)`.
     *
     * [name]: PersonaDataEntryName
     */
    public var name: PersonaDataIdentifiedName?
    /**
     * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
     * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
     * contain elements with the same value, but under different IDs.
     */
    public var phoneNumbers: CollectionOfPhoneNumbers
    /**
     * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
     * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
     * contain elements with the same value, but under different IDs.
     */
    public var emailAddresses: CollectionOfEmailAddresses

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
         * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
         *
         * Note that the type is Option of `PersonaDataIdentifiedName` and not of type [`PersonaDataEntryName`][name],
         * `PersonaDataIdentifiedName` is essentially a tuple of `(Uuid, PersonaDataEntryName)`.
         *
         * [name]: PersonaDataEntryName
         */
        name: PersonaDataIdentifiedName?,
        /**
            * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
            * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
            * contain elements with the same value, but under different IDs.
            */
        phoneNumbers: CollectionOfPhoneNumbers,
        /**
            * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
            * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
            * contain elements with the same value, but under different IDs.
            */
        emailAddresses: CollectionOfEmailAddresses
    ) {
        self.name = name
        self.phoneNumbers = phoneNumbers
        self.emailAddresses = emailAddresses
    }
}

extension PersonaData: Equatable, Hashable {
    public static func == (lhs: PersonaData, rhs: PersonaData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(phoneNumbers)
        hasher.combine(emailAddresses)
    }
}

public struct FfiConverterTypePersonaData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaData {
        return
            try PersonaData(
                name: FfiConverterOptionTypePersonaDataIdentifiedName.read(from: &buf),
                phoneNumbers: FfiConverterTypeCollectionOfPhoneNumbers.read(from: &buf),
                emailAddresses: FfiConverterTypeCollectionOfEmailAddresses.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaData, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataIdentifiedName.write(value.name, into: &buf)
        FfiConverterTypeCollectionOfPhoneNumbers.write(value.phoneNumbers, into: &buf)
        FfiConverterTypeCollectionOfEmailAddresses.write(value.emailAddresses, into: &buf)
    }
}

public func FfiConverterTypePersonaData_lift(_ buf: RustBuffer) throws -> PersonaData {
    return try FfiConverterTypePersonaData.lift(buf)
}

public func FfiConverterTypePersonaData_lower(_ value: PersonaData) -> RustBuffer {
    return FfiConverterTypePersonaData.lower(value)
}

/**
 * A persons email address they have chosen to associated with a Persona, e.g.
 * `satoshi@btc.org`.
 *
 * Current implementation does not validate the email address other than it
 * cannot be empty (in the future we might add some simple validation).
 */
public struct PersonaDataEntryEmailAddress {
    public var email: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        email: String)
    {
        self.email = email
    }
}

extension PersonaDataEntryEmailAddress: Equatable, Hashable {
    public static func == (lhs: PersonaDataEntryEmailAddress, rhs: PersonaDataEntryEmailAddress) -> Bool {
        if lhs.email != rhs.email {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(email)
    }
}

public struct FfiConverterTypePersonaDataEntryEmailAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryEmailAddress {
        return
            try PersonaDataEntryEmailAddress(
                email: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataEntryEmailAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.email, into: &buf)
    }
}

public func FfiConverterTypePersonaDataEntryEmailAddress_lift(_ buf: RustBuffer) throws -> PersonaDataEntryEmailAddress {
    return try FfiConverterTypePersonaDataEntryEmailAddress.lift(buf)
}

public func FfiConverterTypePersonaDataEntryEmailAddress_lower(_ value: PersonaDataEntryEmailAddress) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryEmailAddress.lower(value)
}

/**
 * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
 * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
 *
 * Nickname is optional in the sense that it can be left blank. Family name and given names are never empty.
 *
 * If a name has multiple given names, they all go into the `given_names` String, e.g. Pippi Longstocking's real name -
 * her Swedish name - is in full: "Pippilotta Viktualia Rullgardina Krusmynta Efraimsdotter Lngstrump", where her
 * given names: "Pippilotta Viktualia Rullgardina Krusmynta Efraimsdotter" are put in the `given_names` field, and
 * "Lngstrump" (Longstocking) is her family name.
 */
public struct PersonaDataEntryName {
    public var variant: Variant
    public var familyName: String
    public var givenNames: String
    public var nickname: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        variant: Variant,
        familyName: String,
        givenNames: String,
        nickname: String
    ) {
        self.variant = variant
        self.familyName = familyName
        self.givenNames = givenNames
        self.nickname = nickname
    }
}

extension PersonaDataEntryName: Equatable, Hashable {
    public static func == (lhs: PersonaDataEntryName, rhs: PersonaDataEntryName) -> Bool {
        if lhs.variant != rhs.variant {
            return false
        }
        if lhs.familyName != rhs.familyName {
            return false
        }
        if lhs.givenNames != rhs.givenNames {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(variant)
        hasher.combine(familyName)
        hasher.combine(givenNames)
        hasher.combine(nickname)
    }
}

public struct FfiConverterTypePersonaDataEntryName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryName {
        return
            try PersonaDataEntryName(
                variant: FfiConverterTypeVariant.read(from: &buf),
                familyName: FfiConverterString.read(from: &buf),
                givenNames: FfiConverterString.read(from: &buf),
                nickname: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataEntryName, into buf: inout [UInt8]) {
        FfiConverterTypeVariant.write(value.variant, into: &buf)
        FfiConverterString.write(value.familyName, into: &buf)
        FfiConverterString.write(value.givenNames, into: &buf)
        FfiConverterString.write(value.nickname, into: &buf)
    }
}

public func FfiConverterTypePersonaDataEntryName_lift(_ buf: RustBuffer) throws -> PersonaDataEntryName {
    return try FfiConverterTypePersonaDataEntryName.lift(buf)
}

public func FfiConverterTypePersonaDataEntryName_lower(_ value: PersonaDataEntryName) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryName.lower(value)
}

/**
 * A persons telephone number they have chosen to associated with a Persona, e.g.
 * `+46 987 654 321` (don't try calling this number, it does not exist).
 *
 * Current implementation does not validate the phone number other than it
 * cannot be empty, since telephone number validation is tricky.
 */
public struct PersonaDataEntryPhoneNumber {
    public var number: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        number: String)
    {
        self.number = number
    }
}

extension PersonaDataEntryPhoneNumber: Equatable, Hashable {
    public static func == (lhs: PersonaDataEntryPhoneNumber, rhs: PersonaDataEntryPhoneNumber) -> Bool {
        if lhs.number != rhs.number {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(number)
    }
}

public struct FfiConverterTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryPhoneNumber {
        return
            try PersonaDataEntryPhoneNumber(
                number: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataEntryPhoneNumber, into buf: inout [UInt8]) {
        FfiConverterString.write(value.number, into: &buf)
    }
}

public func FfiConverterTypePersonaDataEntryPhoneNumber_lift(_ buf: RustBuffer) throws -> PersonaDataEntryPhoneNumber {
    return try FfiConverterTypePersonaDataEntryPhoneNumber.lift(buf)
}

public func FfiConverterTypePersonaDataEntryPhoneNumber_lower(_ value: PersonaDataEntryPhoneNumber) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryPhoneNumber.lower(value)
}

public struct PersonaDataIdentifiedEmailAddress {
    public var id: PersonaDataEntryID
    public var value: PersonaDataEntryEmailAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: PersonaDataEntryID,
        value: PersonaDataEntryEmailAddress
    ) {
        self.id = id
        self.value = value
    }
}

extension PersonaDataIdentifiedEmailAddress: Equatable, Hashable {
    public static func == (lhs: PersonaDataIdentifiedEmailAddress, rhs: PersonaDataIdentifiedEmailAddress) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}

public struct FfiConverterTypePersonaDataIdentifiedEmailAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedEmailAddress {
        return
            try PersonaDataIdentifiedEmailAddress(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
                value: FfiConverterTypePersonaDataEntryEmailAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataIdentifiedEmailAddress, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypePersonaDataEntryEmailAddress.write(value.value, into: &buf)
    }
}

public func FfiConverterTypePersonaDataIdentifiedEmailAddress_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedEmailAddress {
    return try FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedEmailAddress_lower(_ value: PersonaDataIdentifiedEmailAddress) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedEmailAddress.lower(value)
}

public struct PersonaDataIdentifiedName {
    public var id: PersonaDataEntryID
    public var value: PersonaDataEntryName

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: PersonaDataEntryID,
        value: PersonaDataEntryName
    ) {
        self.id = id
        self.value = value
    }
}

extension PersonaDataIdentifiedName: Equatable, Hashable {
    public static func == (lhs: PersonaDataIdentifiedName, rhs: PersonaDataIdentifiedName) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}

public struct FfiConverterTypePersonaDataIdentifiedName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedName {
        return
            try PersonaDataIdentifiedName(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
                value: FfiConverterTypePersonaDataEntryName.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataIdentifiedName, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypePersonaDataEntryName.write(value.value, into: &buf)
    }
}

public func FfiConverterTypePersonaDataIdentifiedName_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedName {
    return try FfiConverterTypePersonaDataIdentifiedName.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedName_lower(_ value: PersonaDataIdentifiedName) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedName.lower(value)
}

public struct PersonaDataIdentifiedPhoneNumber {
    public var id: PersonaDataEntryID
    public var value: PersonaDataEntryPhoneNumber

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: PersonaDataEntryID,
        value: PersonaDataEntryPhoneNumber
    ) {
        self.id = id
        self.value = value
    }
}

extension PersonaDataIdentifiedPhoneNumber: Equatable, Hashable {
    public static func == (lhs: PersonaDataIdentifiedPhoneNumber, rhs: PersonaDataIdentifiedPhoneNumber) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}

public struct FfiConverterTypePersonaDataIdentifiedPhoneNumber: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedPhoneNumber {
        return
            try PersonaDataIdentifiedPhoneNumber(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
                value: FfiConverterTypePersonaDataEntryPhoneNumber.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataIdentifiedPhoneNumber, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypePersonaDataEntryPhoneNumber.write(value.value, into: &buf)
    }
}

public func FfiConverterTypePersonaDataIdentifiedPhoneNumber_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedPhoneNumber {
    return try FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedPhoneNumber_lower(_ value: PersonaDataIdentifiedPhoneNumber) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedPhoneNumber.lower(value)
}

public struct PoolAddress {
    public var inner: InnerPoolAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        inner: InnerPoolAddress)
    {
        self.inner = inner
    }
}

extension PoolAddress: Equatable, Hashable {
    public static func == (lhs: PoolAddress, rhs: PoolAddress) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypePoolAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PoolAddress {
        return
            try PoolAddress(
                inner: FfiConverterTypeInnerPoolAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PoolAddress, into buf: inout [UInt8]) {
        FfiConverterTypeInnerPoolAddress.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypePoolAddress_lift(_ buf: RustBuffer) throws -> PoolAddress {
    return try FfiConverterTypePoolAddress.lift(buf)
}

public func FfiConverterTypePoolAddress_lower(_ value: PoolAddress) -> RustBuffer {
    return FfiConverterTypePoolAddress.lower(value)
}

public struct PrivateHierarchicalDeterministicFactorSource {
    public var mnemonicWithPassphrase: MnemonicWithPassphrase
    public var factorSource: DeviceFactorSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        mnemonicWithPassphrase: MnemonicWithPassphrase,
        factorSource: DeviceFactorSource
    ) {
        self.mnemonicWithPassphrase = mnemonicWithPassphrase
        self.factorSource = factorSource
    }
}

extension PrivateHierarchicalDeterministicFactorSource: Equatable, Hashable {
    public static func == (lhs: PrivateHierarchicalDeterministicFactorSource, rhs: PrivateHierarchicalDeterministicFactorSource) -> Bool {
        if lhs.mnemonicWithPassphrase != rhs.mnemonicWithPassphrase {
            return false
        }
        if lhs.factorSource != rhs.factorSource {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonicWithPassphrase)
        hasher.combine(factorSource)
    }
}

public struct FfiConverterTypePrivateHierarchicalDeterministicFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrivateHierarchicalDeterministicFactorSource {
        return
            try PrivateHierarchicalDeterministicFactorSource(
                mnemonicWithPassphrase: FfiConverterTypeMnemonicWithPassphrase.read(from: &buf),
                factorSource: FfiConverterTypeDeviceFactorSource.read(from: &buf)
            )
    }

    public static func write(_ value: PrivateHierarchicalDeterministicFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeMnemonicWithPassphrase.write(value.mnemonicWithPassphrase, into: &buf)
        FfiConverterTypeDeviceFactorSource.write(value.factorSource, into: &buf)
    }
}

public func FfiConverterTypePrivateHierarchicalDeterministicFactorSource_lift(_ buf: RustBuffer) throws -> PrivateHierarchicalDeterministicFactorSource {
    return try FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(buf)
}

public func FfiConverterTypePrivateHierarchicalDeterministicFactorSource_lower(_ value: PrivateHierarchicalDeterministicFactorSource) -> RustBuffer {
    return FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lower(value)
}

/**
 * Representation of the Radix Wallet, contains a list of
 * users Accounts, Personas, Authorized Dapps per network
 * the user has used. It also contains all FactorSources,
 * FactorInstances and wallet App preferences.
 */
public struct Profile {
    /**
     * The header of a Profile(Snapshot) contains crucial metadata
     * about this Profile, such as which JSON data format it is
     * compatible with and which device was used to create it and
     * a hint about its contents.
     */
    public var header: Header
    /**
     * All sources of factors, used for authorization such as spending funds, contains no
     * secrets.
     */
    public var factorSources: [FactorSource]
    /**
     * Settings for this profile in the app, contains default security configs
     * as well as display settings.
     */
    public var appPreferences: AppPreferences
    /**
     * An ordered mapping of NetworkID -> `Profile.Network`, containing
     * all the users Accounts, Personas and AuthorizedDapps the user
     * has created and interacted with on this network.
     */
    public var networks: [ProfileNetwork]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The header of a Profile(Snapshot) contains crucial metadata
         * about this Profile, such as which JSON data format it is
         * compatible with and which device was used to create it and
         * a hint about its contents.
         */
        header: Header,
        /**
            * All sources of factors, used for authorization such as spending funds, contains no
            * secrets.
            */
        factorSources: [FactorSource],
        /**
            * Settings for this profile in the app, contains default security configs
            * as well as display settings.
            */
        appPreferences: AppPreferences,
        /**
            * An ordered mapping of NetworkID -> `Profile.Network`, containing
            * all the users Accounts, Personas and AuthorizedDapps the user
            * has created and interacted with on this network.
            */
        networks: [ProfileNetwork]
    ) {
        self.header = header
        self.factorSources = factorSources
        self.appPreferences = appPreferences
        self.networks = networks
    }
}

extension Profile: Equatable, Hashable {
    public static func == (lhs: Profile, rhs: Profile) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.factorSources != rhs.factorSources {
            return false
        }
        if lhs.appPreferences != rhs.appPreferences {
            return false
        }
        if lhs.networks != rhs.networks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(factorSources)
        hasher.combine(appPreferences)
        hasher.combine(networks)
    }
}

public struct FfiConverterTypeProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Profile {
        return
            try Profile(
                header: FfiConverterTypeHeader.read(from: &buf),
                factorSources: FfiConverterSequenceTypeFactorSource.read(from: &buf),
                appPreferences: FfiConverterTypeAppPreferences.read(from: &buf),
                networks: FfiConverterSequenceTypeProfileNetwork.read(from: &buf)
            )
    }

    public static func write(_ value: Profile, into buf: inout [UInt8]) {
        FfiConverterTypeHeader.write(value.header, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.factorSources, into: &buf)
        FfiConverterTypeAppPreferences.write(value.appPreferences, into: &buf)
        FfiConverterSequenceTypeProfileNetwork.write(value.networks, into: &buf)
    }
}

public func FfiConverterTypeProfile_lift(_ buf: RustBuffer) throws -> Profile {
    return try FfiConverterTypeProfile.lift(buf)
}

public func FfiConverterTypeProfile_lower(_ value: Profile) -> RustBuffer {
    return FfiConverterTypeProfile.lower(value)
}

/**
 * [`Accounts`], [`Personas`] and [`AuthorizedDapps`] for some [`ProfileNetwork`]
 * which user has created/interacted with, all on the same [Radix Network][`NetworkDefinition`],
 * identified by `id` ([`NetworkID`]).
 */
public struct ProfileNetwork {
    /**
     * The ID of the network that has been used to generate the `accounts` and `personas`
     * and on which the `authorizedDapps` have been deployed on.
     */
    public var id: NetworkId
    /**
     * An ordered set of [`Accounts`]` on this network, which are [`Account`]s
     * the user has created on this network.
     */
    public var accounts: [Account]
    /**
     * An ordered set of [`Personas`] on this network, which are [`Persona`]s
     * the user has created on this network.
     */
    public var personas: [Persona]
    /**
     * An ordered set of [`AuthorizedDapps`] on this network, which are
     * [`AuthorizedDapp`]s that the user has interacted with.
     */
    public var authorizedDapps: [AuthorizedDapp]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network that has been used to generate the `accounts` and `personas`
         * and on which the `authorizedDapps` have been deployed on.
         */
        id: NetworkId,
        /**
            * An ordered set of [`Accounts`]` on this network, which are [`Account`]s
            * the user has created on this network.
            */
        accounts: [Account],
        /**
            * An ordered set of [`Personas`] on this network, which are [`Persona`]s
            * the user has created on this network.
            */
        personas: [Persona],
        /**
            * An ordered set of [`AuthorizedDapps`] on this network, which are
            * [`AuthorizedDapp`]s that the user has interacted with.
            */
        authorizedDapps: [AuthorizedDapp]
    ) {
        self.id = id
        self.accounts = accounts
        self.personas = personas
        self.authorizedDapps = authorizedDapps
    }
}

extension ProfileNetwork: Equatable, Hashable {
    public static func == (lhs: ProfileNetwork, rhs: ProfileNetwork) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.personas != rhs.personas {
            return false
        }
        if lhs.authorizedDapps != rhs.authorizedDapps {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(accounts)
        hasher.combine(personas)
        hasher.combine(authorizedDapps)
    }
}

public struct FfiConverterTypeProfileNetwork: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileNetwork {
        return
            try ProfileNetwork(
                id: FfiConverterTypeNetworkID.read(from: &buf),
                accounts: FfiConverterSequenceTypeAccount.read(from: &buf),
                personas: FfiConverterSequenceTypePersona.read(from: &buf),
                authorizedDapps: FfiConverterSequenceTypeAuthorizedDapp.read(from: &buf)
            )
    }

    public static func write(_ value: ProfileNetwork, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.id, into: &buf)
        FfiConverterSequenceTypeAccount.write(value.accounts, into: &buf)
        FfiConverterSequenceTypePersona.write(value.personas, into: &buf)
        FfiConverterSequenceTypeAuthorizedDapp.write(value.authorizedDapps, into: &buf)
    }
}

public func FfiConverterTypeProfileNetwork_lift(_ buf: RustBuffer) throws -> ProfileNetwork {
    return try FfiConverterTypeProfileNetwork.lift(buf)
}

public func FfiConverterTypeProfileNetwork_lower(_ value: ProfileNetwork) -> RustBuffer {
    return FfiConverterTypeProfileNetwork.lower(value)
}

/**
 * The hash of the connection password is used to connect to the Radix Connect Signaling Server,
 * over web sockets. The actual `ConnectionPassword` is used to encrypt all messages sent via
 * the Signaling Server.
 */
public struct RadixConnectPassword {
    public var value: Hex32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        value: Hex32Bytes)
    {
        self.value = value
    }
}

extension RadixConnectPassword: Equatable, Hashable {
    public static func == (lhs: RadixConnectPassword, rhs: RadixConnectPassword) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeRadixConnectPassword: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectPassword {
        return
            try RadixConnectPassword(
                value: FfiConverterTypeHex32Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: RadixConnectPassword, into buf: inout [UInt8]) {
        FfiConverterTypeHex32Bytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeRadixConnectPassword_lift(_ buf: RustBuffer) throws -> RadixConnectPassword {
    return try FfiConverterTypeRadixConnectPassword.lift(buf)
}

public func FfiConverterTypeRadixConnectPassword_lower(_ value: RadixConnectPassword) -> RustBuffer {
    return FfiConverterTypeRadixConnectPassword.lower(value)
}

/**
 * A requested (by Dapp) quantity, e.g. "I want AT LEAST 3 account addresses" or
 * "I want EXACTLY 2 email addresses".
 */
public struct RequestedQuantity {
    public var quantifier: RequestedNumberQuantifier
    public var quantity: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        quantifier: RequestedNumberQuantifier,
        quantity: UInt16
    ) {
        self.quantifier = quantifier
        self.quantity = quantity
    }
}

extension RequestedQuantity: Equatable, Hashable {
    public static func == (lhs: RequestedQuantity, rhs: RequestedQuantity) -> Bool {
        if lhs.quantifier != rhs.quantifier {
            return false
        }
        if lhs.quantity != rhs.quantity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(quantifier)
        hasher.combine(quantity)
    }
}

public struct FfiConverterTypeRequestedQuantity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedQuantity {
        return
            try RequestedQuantity(
                quantifier: FfiConverterTypeRequestedNumberQuantifier.read(from: &buf),
                quantity: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: RequestedQuantity, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedNumberQuantifier.write(value.quantifier, into: &buf)
        FfiConverterUInt16.write(value.quantity, into: &buf)
    }
}

public func FfiConverterTypeRequestedQuantity_lift(_ buf: RustBuffer) throws -> RequestedQuantity {
    return try FfiConverterTypeRequestedQuantity.lift(buf)
}

public func FfiConverterTypeRequestedQuantity_lower(_ value: RequestedQuantity) -> RustBuffer {
    return FfiConverterTypeRequestedQuantity.lower(value)
}

/**
 * The address of an Account, a bech32 encoding of a public key hash
 * that starts with the prefix `"account_"`, dependent on NetworkID, meaning the same
 * public key used for two AccountAddresses on two different networks will not have
 * the same address.
 */
public struct ResourceAddress {
    public var inner: InnerResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        inner: InnerResourceAddress)
    {
        self.inner = inner
    }
}

extension ResourceAddress: Equatable, Hashable {
    public static func == (lhs: ResourceAddress, rhs: ResourceAddress) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeResourceAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAddress {
        return
            try ResourceAddress(
                inner: FfiConverterTypeInnerResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: ResourceAddress, into buf: inout [UInt8]) {
        FfiConverterTypeInnerResourceAddress.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeResourceAddress_lift(_ buf: RustBuffer) throws -> ResourceAddress {
    return try FfiConverterTypeResourceAddress.lift(buf)
}

public func FfiConverterTypeResourceAddress_lower(_ value: ResourceAddress) -> RustBuffer {
    return FfiConverterTypeResourceAddress.lower(value)
}

/**
 * A `secp256k1` public key used to verify cryptographic signatures (ECDSA signatures).
 */
public struct Secp256k1PublicKey {
    public var inner: ScryptoSecp256k1PublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        inner: ScryptoSecp256k1PublicKey)
    {
        self.inner = inner
    }
}

extension Secp256k1PublicKey: Equatable, Hashable {
    public static func == (lhs: Secp256k1PublicKey, rhs: Secp256k1PublicKey) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeSecp256k1PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1PublicKey {
        return
            try Secp256k1PublicKey(
                inner: FfiConverterTypeScryptoSecp256k1PublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: Secp256k1PublicKey, into buf: inout [UInt8]) {
        FfiConverterTypeScryptoSecp256k1PublicKey.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeSecp256k1PublicKey_lift(_ buf: RustBuffer) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(buf)
}

public func FfiConverterTypeSecp256k1PublicKey_lower(_ value: Secp256k1PublicKey) -> RustBuffer {
    return FfiConverterTypeSecp256k1PublicKey.lower(value)
}

/**
 * Represents an Secp256k1 signature.
 */
public struct Secp256k1Signature {
    public var bytes: Hex65Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        bytes: Hex65Bytes)
    {
        self.bytes = bytes
    }
}

extension Secp256k1Signature: Equatable, Hashable {
    public static func == (lhs: Secp256k1Signature, rhs: Secp256k1Signature) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}

public struct FfiConverterTypeSecp256k1Signature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1Signature {
        return
            try Secp256k1Signature(
                bytes: FfiConverterTypeHex65Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: Secp256k1Signature, into buf: inout [UInt8]) {
        FfiConverterTypeHex65Bytes.write(value.bytes, into: &buf)
    }
}

public func FfiConverterTypeSecp256k1Signature_lift(_ buf: RustBuffer) throws -> Secp256k1Signature {
    return try FfiConverterTypeSecp256k1Signature.lift(buf)
}

public func FfiConverterTypeSecp256k1Signature_lower(_ value: Secp256k1Signature) -> RustBuffer {
    return FfiConverterTypeSecp256k1Signature.lower(value)
}

/**
 * Controls e.g. if Profile Snapshot gets synced to iCloud or not, and whether
 * developer mode is enabled or not. In future (MFA) we will also save a list of
 * MFA security structure configurations.
 */
public struct Security {
    public var isCloudProfileSyncEnabled: Bool
    public var isDeveloperModeEnabled: Bool
    public var structureConfigurationReferences: [Bool]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        isCloudProfileSyncEnabled: Bool,
        isDeveloperModeEnabled: Bool,
        structureConfigurationReferences: [Bool]
    ) {
        self.isCloudProfileSyncEnabled = isCloudProfileSyncEnabled
        self.isDeveloperModeEnabled = isDeveloperModeEnabled
        self.structureConfigurationReferences = structureConfigurationReferences
    }
}

extension Security: Equatable, Hashable {
    public static func == (lhs: Security, rhs: Security) -> Bool {
        if lhs.isCloudProfileSyncEnabled != rhs.isCloudProfileSyncEnabled {
            return false
        }
        if lhs.isDeveloperModeEnabled != rhs.isDeveloperModeEnabled {
            return false
        }
        if lhs.structureConfigurationReferences != rhs.structureConfigurationReferences {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCloudProfileSyncEnabled)
        hasher.combine(isDeveloperModeEnabled)
        hasher.combine(structureConfigurationReferences)
    }
}

public struct FfiConverterTypeSecurity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Security {
        return
            try Security(
                isCloudProfileSyncEnabled: FfiConverterBool.read(from: &buf),
                isDeveloperModeEnabled: FfiConverterBool.read(from: &buf),
                structureConfigurationReferences: FfiConverterSequenceBool.read(from: &buf)
            )
    }

    public static func write(_ value: Security, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCloudProfileSyncEnabled, into: &buf)
        FfiConverterBool.write(value.isDeveloperModeEnabled, into: &buf)
        FfiConverterSequenceBool.write(value.structureConfigurationReferences, into: &buf)
    }
}

public func FfiConverterTypeSecurity_lift(_ buf: RustBuffer) throws -> Security {
    return try FfiConverterTypeSecurity.lift(buf)
}

public func FfiConverterTypeSecurity_lower(_ value: Security) -> RustBuffer {
    return FfiConverterTypeSecurity.lower(value)
}

/**
 * Identities for PersonaData entry values a user have shared with a dApp.
 */
public struct SharedPersonaData {
    /**
     * ID of a `PersonaDataEntryName` the user has shared with some dApp on some network,
     * can be `None`.
     */
    public var name: PersonaDataEntryID?
    /**
     * IDs of a `PersonaDataEntryEmailAddress`es the user has shared with some dApp on some network
     * can be `None`, or can be `Some(<EMPTY>)`.
     */
    public var emailAddresses: SharedToDappWithPersonaIDsOfPersonaDataEntries?
    /**
     * IDs of a `PersonaDataEntryPhoneNumber`s the user has shared with some dApp on some network
     * can be `None`, or can be `Some(<EMPTY>)`.
     */
    public var phoneNumbers: SharedToDappWithPersonaIDsOfPersonaDataEntries?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * ID of a `PersonaDataEntryName` the user has shared with some dApp on some network,
         * can be `None`.
         */
        name: PersonaDataEntryID?,
        /**
            * IDs of a `PersonaDataEntryEmailAddress`es the user has shared with some dApp on some network
            * can be `None`, or can be `Some(<EMPTY>)`.
            */
        emailAddresses: SharedToDappWithPersonaIDsOfPersonaDataEntries?,
        /**
            * IDs of a `PersonaDataEntryPhoneNumber`s the user has shared with some dApp on some network
            * can be `None`, or can be `Some(<EMPTY>)`.
            */
        phoneNumbers: SharedToDappWithPersonaIDsOfPersonaDataEntries?
    ) {
        self.name = name
        self.emailAddresses = emailAddresses
        self.phoneNumbers = phoneNumbers
    }
}

extension SharedPersonaData: Equatable, Hashable {
    public static func == (lhs: SharedPersonaData, rhs: SharedPersonaData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(emailAddresses)
        hasher.combine(phoneNumbers)
    }
}

public struct FfiConverterTypeSharedPersonaData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedPersonaData {
        return
            try SharedPersonaData(
                name: FfiConverterOptionTypePersonaDataEntryID.read(from: &buf),
                emailAddresses: FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf),
                phoneNumbers: FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf)
            )
    }

    public static func write(_ value: SharedPersonaData, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataEntryID.write(value.name, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value.emailAddresses, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value.phoneNumbers, into: &buf)
    }
}

public func FfiConverterTypeSharedPersonaData_lift(_ buf: RustBuffer) throws -> SharedPersonaData {
    return try FfiConverterTypeSharedPersonaData.lift(buf)
}

public func FfiConverterTypeSharedPersonaData_lower(_ value: SharedPersonaData) -> RustBuffer {
    return FfiConverterTypeSharedPersonaData.lower(value)
}

/**
 * IDs that have been shared with an Dapp the user has interacted with
 * that fulfill a Dapp request's specified [`RequestedQuantity`].
 */
public struct SharedToDappWithPersonaAccountAddresses {
    /**
     * The requested quantity to be shared by user, sent by a Dapp.
     */
    public var request: RequestedQuantity
    /**
     * The by user shared IDs of data identifiable data shared with the
     * Dapp.
     */
    public var ids: [AccountAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The requested quantity to be shared by user, sent by a Dapp.
         */
        request: RequestedQuantity,
        /**
            * The by user shared IDs of data identifiable data shared with the
            * Dapp.
            */
        ids: [AccountAddress]
    ) {
        self.request = request
        self.ids = ids
    }
}

extension SharedToDappWithPersonaAccountAddresses: Equatable, Hashable {
    public static func == (lhs: SharedToDappWithPersonaAccountAddresses, rhs: SharedToDappWithPersonaAccountAddresses) -> Bool {
        if lhs.request != rhs.request {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(request)
        hasher.combine(ids)
    }
}

public struct FfiConverterTypeSharedToDappWithPersonaAccountAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedToDappWithPersonaAccountAddresses {
        return
            try SharedToDappWithPersonaAccountAddresses(
                request: FfiConverterTypeRequestedQuantity.read(from: &buf),
                ids: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: SharedToDappWithPersonaAccountAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.request, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.ids, into: &buf)
    }
}

public func FfiConverterTypeSharedToDappWithPersonaAccountAddresses_lift(_ buf: RustBuffer) throws -> SharedToDappWithPersonaAccountAddresses {
    return try FfiConverterTypeSharedToDappWithPersonaAccountAddresses.lift(buf)
}

public func FfiConverterTypeSharedToDappWithPersonaAccountAddresses_lower(_ value: SharedToDappWithPersonaAccountAddresses) -> RustBuffer {
    return FfiConverterTypeSharedToDappWithPersonaAccountAddresses.lower(value)
}

/**
 * IDs that have been shared with an Dapp the user has interacted with
 * that fulfill a Dapp request's specified [`RequestedQuantity`].
 */
public struct SharedToDappWithPersonaIDsOfPersonaDataEntries {
    /**
     * The requested quantity to be shared by user, sent by a Dapp.
     */
    public var request: RequestedQuantity
    /**
     * The by user shared IDs of data identifiable data shared with the
     * Dapp.
     */
    public var ids: [PersonaDataEntryID]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The requested quantity to be shared by user, sent by a Dapp.
         */
        request: RequestedQuantity,
        /**
            * The by user shared IDs of data identifiable data shared with the
            * Dapp.
            */
        ids: [PersonaDataEntryID]
    ) {
        self.request = request
        self.ids = ids
    }
}

extension SharedToDappWithPersonaIDsOfPersonaDataEntries: Equatable, Hashable {
    public static func == (lhs: SharedToDappWithPersonaIDsOfPersonaDataEntries, rhs: SharedToDappWithPersonaIDsOfPersonaDataEntries) -> Bool {
        if lhs.request != rhs.request {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(request)
        hasher.combine(ids)
    }
}

public struct FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedToDappWithPersonaIDsOfPersonaDataEntries {
        return
            try SharedToDappWithPersonaIDsOfPersonaDataEntries(
                request: FfiConverterTypeRequestedQuantity.read(from: &buf),
                ids: FfiConverterSequenceTypePersonaDataEntryID.read(from: &buf)
            )
    }

    public static func write(_ value: SharedToDappWithPersonaIDsOfPersonaDataEntries, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.request, into: &buf)
        FfiConverterSequenceTypePersonaDataEntryID.write(value.ids, into: &buf)
    }
}

public func FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries_lift(_ buf: RustBuffer) throws -> SharedToDappWithPersonaIDsOfPersonaDataEntries {
    return try FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.lift(buf)
}

public func FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries_lower(_ value: SharedToDappWithPersonaIDsOfPersonaDataEntries) -> RustBuffer {
    return FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.lower(value)
}

/**
 * Controls the ability of third-parties to deposit into a certain account, this is
 * useful for users who wish to not be able to receive airdrops.
 */
public struct ThirdPartyDeposits {
    /**
     * Controls the ability of third-parties to deposit into this account
     */
    public var depositRule: DepositRule
    /**
     * Denies or allows third-party deposits of specific assets by ignoring the `depositMode`
     */
    public var assetsExceptionList: [AssetException]
    /**
     * Allows certain third-party depositors to deposit assets freely.
     * Note: There is no `deny` counterpart for this.
     */
    public var depositorsAllowList: [ResourceOrNonFungible]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Controls the ability of third-parties to deposit into this account
         */
        depositRule: DepositRule,
        /**
            * Denies or allows third-party deposits of specific assets by ignoring the `depositMode`
            */
        assetsExceptionList: [AssetException],
        /**
            * Allows certain third-party depositors to deposit assets freely.
            * Note: There is no `deny` counterpart for this.
            */
        depositorsAllowList: [ResourceOrNonFungible]
    ) {
        self.depositRule = depositRule
        self.assetsExceptionList = assetsExceptionList
        self.depositorsAllowList = depositorsAllowList
    }
}

extension ThirdPartyDeposits: Equatable, Hashable {
    public static func == (lhs: ThirdPartyDeposits, rhs: ThirdPartyDeposits) -> Bool {
        if lhs.depositRule != rhs.depositRule {
            return false
        }
        if lhs.assetsExceptionList != rhs.assetsExceptionList {
            return false
        }
        if lhs.depositorsAllowList != rhs.depositorsAllowList {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(depositRule)
        hasher.combine(assetsExceptionList)
        hasher.combine(depositorsAllowList)
    }
}

public struct FfiConverterTypeThirdPartyDeposits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThirdPartyDeposits {
        return
            try ThirdPartyDeposits(
                depositRule: FfiConverterTypeDepositRule.read(from: &buf),
                assetsExceptionList: FfiConverterSequenceTypeAssetException.read(from: &buf),
                depositorsAllowList: FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
            )
    }

    public static func write(_ value: ThirdPartyDeposits, into buf: inout [UInt8]) {
        FfiConverterTypeDepositRule.write(value.depositRule, into: &buf)
        FfiConverterSequenceTypeAssetException.write(value.assetsExceptionList, into: &buf)
        FfiConverterSequenceTypeResourceOrNonFungible.write(value.depositorsAllowList, into: &buf)
    }
}

public func FfiConverterTypeThirdPartyDeposits_lift(_ buf: RustBuffer) throws -> ThirdPartyDeposits {
    return try FfiConverterTypeThirdPartyDeposits.lift(buf)
}

public func FfiConverterTypeThirdPartyDeposits_lower(_ value: ThirdPartyDeposits) -> RustBuffer {
    return FfiConverterTypeThirdPartyDeposits.lower(value)
}

public struct TransactionHash {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension TransactionHash: Equatable, Hashable {
    public static func == (_: TransactionHash, _: TransactionHash) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeTransactionHash: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> TransactionHash {
        return
            TransactionHash()
    }

    public static func write(_: TransactionHash, into _: inout [UInt8]) {}
}

public func FfiConverterTypeTransactionHash_lift(_ buf: RustBuffer) throws -> TransactionHash {
    return try FfiConverterTypeTransactionHash.lift(buf)
}

public func FfiConverterTypeTransactionHash_lower(_ value: TransactionHash) -> RustBuffer {
    return FfiConverterTypeTransactionHash.lower(value)
}

public struct TransactionHeader {
    public var networkId: NetworkId
    public var startEpochInclusive: Epoch
    public var endEpochExclusive: Epoch
    public var nonce: Nonce
    public var notaryPublicKey: PublicKey
    public var notaryIsSignatory: Bool
    public var tipPercentage: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        networkId: NetworkId,
        startEpochInclusive: Epoch,
        endEpochExclusive: Epoch,
        nonce: Nonce,
        notaryPublicKey: PublicKey,
        notaryIsSignatory: Bool,
        tipPercentage: UInt16
    ) {
        self.networkId = networkId
        self.startEpochInclusive = startEpochInclusive
        self.endEpochExclusive = endEpochExclusive
        self.nonce = nonce
        self.notaryPublicKey = notaryPublicKey
        self.notaryIsSignatory = notaryIsSignatory
        self.tipPercentage = tipPercentage
    }
}

extension TransactionHeader: Equatable, Hashable {
    public static func == (lhs: TransactionHeader, rhs: TransactionHeader) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.startEpochInclusive != rhs.startEpochInclusive {
            return false
        }
        if lhs.endEpochExclusive != rhs.endEpochExclusive {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.notaryPublicKey != rhs.notaryPublicKey {
            return false
        }
        if lhs.notaryIsSignatory != rhs.notaryIsSignatory {
            return false
        }
        if lhs.tipPercentage != rhs.tipPercentage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(startEpochInclusive)
        hasher.combine(endEpochExclusive)
        hasher.combine(nonce)
        hasher.combine(notaryPublicKey)
        hasher.combine(notaryIsSignatory)
        hasher.combine(tipPercentage)
    }
}

public struct FfiConverterTypeTransactionHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHeader {
        return
            try TransactionHeader(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                startEpochInclusive: FfiConverterTypeEpoch.read(from: &buf),
                endEpochExclusive: FfiConverterTypeEpoch.read(from: &buf),
                nonce: FfiConverterTypeNonce.read(from: &buf),
                notaryPublicKey: FfiConverterTypePublicKey.read(from: &buf),
                notaryIsSignatory: FfiConverterBool.read(from: &buf),
                tipPercentage: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionHeader, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeEpoch.write(value.startEpochInclusive, into: &buf)
        FfiConverterTypeEpoch.write(value.endEpochExclusive, into: &buf)
        FfiConverterTypeNonce.write(value.nonce, into: &buf)
        FfiConverterTypePublicKey.write(value.notaryPublicKey, into: &buf)
        FfiConverterBool.write(value.notaryIsSignatory, into: &buf)
        FfiConverterUInt16.write(value.tipPercentage, into: &buf)
    }
}

public func FfiConverterTypeTransactionHeader_lift(_ buf: RustBuffer) throws -> TransactionHeader {
    return try FfiConverterTypeTransactionHeader.lift(buf)
}

public func FfiConverterTypeTransactionHeader_lower(_ value: TransactionHeader) -> RustBuffer {
    return FfiConverterTypeTransactionHeader.lower(value)
}

public struct TransactionIntent {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension TransactionIntent: Equatable, Hashable {
    public static func == (_: TransactionIntent, _: TransactionIntent) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeTransactionIntent: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> TransactionIntent {
        return
            TransactionIntent()
    }

    public static func write(_: TransactionIntent, into _: inout [UInt8]) {}
}

public func FfiConverterTypeTransactionIntent_lift(_ buf: RustBuffer) throws -> TransactionIntent {
    return try FfiConverterTypeTransactionIntent.lift(buf)
}

public func FfiConverterTypeTransactionIntent_lower(_ value: TransactionIntent) -> RustBuffer {
    return FfiConverterTypeTransactionIntent.lower(value)
}

public struct TransactionManifest {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension TransactionManifest: Equatable, Hashable {
    public static func == (_: TransactionManifest, _: TransactionManifest) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeTransactionManifest: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> TransactionManifest {
        return
            TransactionManifest()
    }

    public static func write(_: TransactionManifest, into _: inout [UInt8]) {}
}

public func FfiConverterTypeTransactionManifest_lift(_ buf: RustBuffer) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(buf)
}

public func FfiConverterTypeTransactionManifest_lower(_ value: TransactionManifest) -> RustBuffer {
    return FfiConverterTypeTransactionManifest.lower(value)
}

/**
 * User Preferences relating to submission of transactions.
 */
public struct TransactionPreferences {
    /**
     * The deposit guarantee that will automatically be added for
     * all deposits in transactions.
     */
    public var defaultDepositGuarantee: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The deposit guarantee that will automatically be added for
         * all deposits in transactions.
         */
        defaultDepositGuarantee: Decimal192
    ) {
        self.defaultDepositGuarantee = defaultDepositGuarantee
    }
}

extension TransactionPreferences: Equatable, Hashable {
    public static func == (lhs: TransactionPreferences, rhs: TransactionPreferences) -> Bool {
        if lhs.defaultDepositGuarantee != rhs.defaultDepositGuarantee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(defaultDepositGuarantee)
    }
}

public struct FfiConverterTypeTransactionPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionPreferences {
        return
            try TransactionPreferences(
                defaultDepositGuarantee: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.defaultDepositGuarantee, into: &buf)
    }
}

public func FfiConverterTypeTransactionPreferences_lift(_ buf: RustBuffer) throws -> TransactionPreferences {
    return try FfiConverterTypeTransactionPreferences.lift(buf)
}

public func FfiConverterTypeTransactionPreferences_lower(_ value: TransactionPreferences) -> RustBuffer {
    return FfiConverterTypeTransactionPreferences.lower(value)
}

public struct U11 {
    public var inner: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        inner: UInt16)
    {
        self.inner = inner
    }
}

extension U11: Equatable, Hashable {
    public static func == (lhs: U11, rhs: U11) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeU11: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U11 {
        return
            try U11(
                inner: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: U11, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeU11_lift(_ buf: RustBuffer) throws -> U11 {
    return try FfiConverterTypeU11.lift(buf)
}

public func FfiConverterTypeU11_lower(_ value: U11) -> RustBuffer {
    return FfiConverterTypeU11.lower(value)
}

/**
 * Basic security control of an unsecured entity. When said entity
 * is "securified" it will no longer be controlled by this `UnsecuredEntityControl`
 * but rather by an `AccessControl`. It is a name space holding the
 * single factor instance which was used to create
 */
public struct UnsecuredEntityControl {
    public var transactionSigning: HierarchicalDeterministicFactorInstance
    /**
     * The factor instance which can be used for ROLA.
     */
    public var authenticationSigning: HierarchicalDeterministicFactorInstance?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        transactionSigning: HierarchicalDeterministicFactorInstance,
        /**
            * The factor instance which can be used for ROLA.
            */
        authenticationSigning: HierarchicalDeterministicFactorInstance?
    ) {
        self.transactionSigning = transactionSigning
        self.authenticationSigning = authenticationSigning
    }
}

extension UnsecuredEntityControl: Equatable, Hashable {
    public static func == (lhs: UnsecuredEntityControl, rhs: UnsecuredEntityControl) -> Bool {
        if lhs.transactionSigning != rhs.transactionSigning {
            return false
        }
        if lhs.authenticationSigning != rhs.authenticationSigning {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionSigning)
        hasher.combine(authenticationSigning)
    }
}

public struct FfiConverterTypeUnsecuredEntityControl: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsecuredEntityControl {
        return
            try UnsecuredEntityControl(
                transactionSigning: FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf),
                authenticationSigning: FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
            )
    }

    public static func write(_ value: UnsecuredEntityControl, into buf: inout [UInt8]) {
        FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value.transactionSigning, into: &buf)
        FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.write(value.authenticationSigning, into: &buf)
    }
}

public func FfiConverterTypeUnsecuredEntityControl_lift(_ buf: RustBuffer) throws -> UnsecuredEntityControl {
    return try FfiConverterTypeUnsecuredEntityControl.lift(buf)
}

public func FfiConverterTypeUnsecuredEntityControl_lower(_ value: UnsecuredEntityControl) -> RustBuffer {
    return FfiConverterTypeUnsecuredEntityControl.lower(value)
}

public struct ValidatorAddress {
    public var inner: InnerValidatorAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        inner: InnerValidatorAddress)
    {
        self.inner = inner
    }
}

extension ValidatorAddress: Equatable, Hashable {
    public static func == (lhs: ValidatorAddress, rhs: ValidatorAddress) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeValidatorAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorAddress {
        return
            try ValidatorAddress(
                inner: FfiConverterTypeInnerValidatorAddress.read(from: &buf)
            )
    }

    public static func write(_ value: ValidatorAddress, into buf: inout [UInt8]) {
        FfiConverterTypeInnerValidatorAddress.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeValidatorAddress_lift(_ buf: RustBuffer) throws -> ValidatorAddress {
    return try FfiConverterTypeValidatorAddress.lift(buf)
}

public func FfiConverterTypeValidatorAddress_lower(_ value: ValidatorAddress) -> RustBuffer {
    return FfiConverterTypeValidatorAddress.lower(value)
}

public struct VaultAddress {
    public var inner: InnerVaultAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        inner: InnerVaultAddress)
    {
        self.inner = inner
    }
}

extension VaultAddress: Equatable, Hashable {
    public static func == (lhs: VaultAddress, rhs: VaultAddress) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeVaultAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VaultAddress {
        return
            try VaultAddress(
                inner: FfiConverterTypeInnerVaultAddress.read(from: &buf)
            )
    }

    public static func write(_ value: VaultAddress, into buf: inout [UInt8]) {
        FfiConverterTypeInnerVaultAddress.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeVaultAddress_lift(_ buf: RustBuffer) throws -> VaultAddress {
    return try FfiConverterTypeVaultAddress.lift(buf)
}

public func FfiConverterTypeVaultAddress_lower(_ value: VaultAddress) -> RustBuffer {
    return FfiConverterTypeVaultAddress.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Language to be used for the mnemonic phrase.
 *
 * The English language is always available, other languages are enabled using
 * the compilation features.
 */
public enum Bip39Language {
    /**
     * The English language.
     */
    case english
}

public struct FfiConverterTypeBIP39Language: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Language

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Language {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .english

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Language, into buf: inout [UInt8]) {
        switch value {
        case .english:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeBIP39Language_lift(_ buf: RustBuffer) throws -> Bip39Language {
    return try FfiConverterTypeBIP39Language.lift(buf)
}

public func FfiConverterTypeBIP39Language_lower(_ value: Bip39Language) -> RustBuffer {
    return FfiConverterTypeBIP39Language.lower(value)
}

extension Bip39Language: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
 * standard, a multiple of 3, from 12 to 24 words. All "Babylon" `DeviceFactorSource`s
 * use 24 words.
 */
public enum Bip39WordCount {
    /**
     * 24 words, used by all "Babylon" `DeviceFactorSource`s
     */
    case twentyFour
    /**
     * 21 words, potentially used by third-party Olympia wallets.
     */
    case twentyOne
    /**
     * 18 words, potentially used by third-party Olympia wallets.
     */
    case eighteen
    /**
     * 15 words, potentially used by third-party Olympia wallets.
     */
    case fifteen
    /**
     * 12 words, used by Radix Olympia legacy wallet.
     */
    case twelve
}

public struct FfiConverterTypeBIP39WordCount: FfiConverterRustBuffer {
    typealias SwiftType = Bip39WordCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39WordCount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .twentyFour

        case 2: return .twentyOne

        case 3: return .eighteen

        case 4: return .fifteen

        case 5: return .twelve

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39WordCount, into buf: inout [UInt8]) {
        switch value {
        case .twentyFour:
            writeInt(&buf, Int32(1))

        case .twentyOne:
            writeInt(&buf, Int32(2))

        case .eighteen:
            writeInt(&buf, Int32(3))

        case .fifteen:
            writeInt(&buf, Int32(4))

        case .twelve:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeBIP39WordCount_lift(_ buf: RustBuffer) throws -> Bip39WordCount {
    return try FfiConverterTypeBIP39WordCount.lift(buf)
}

public func FfiConverterTypeBIP39WordCount_lower(_ value: Bip39WordCount) -> RustBuffer {
    return FfiConverterTypeBIP39WordCount.lower(value)
}

extension Bip39WordCount: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Account or Identity (used by Personas) part of a CAP26 derivation
 * path.
 */
public enum Cap26EntityKind {
    /**
     * An Account entity type
     */
    case account
    /**
     * An Identity entity type (used by Personas)
     */
    case identity
}

public struct FfiConverterTypeCAP26EntityKind: FfiConverterRustBuffer {
    typealias SwiftType = Cap26EntityKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26EntityKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .account

        case 2: return .identity

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26EntityKind, into buf: inout [UInt8]) {
        switch value {
        case .account:
            writeInt(&buf, Int32(1))

        case .identity:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeCAP26EntityKind_lift(_ buf: RustBuffer) throws -> Cap26EntityKind {
    return try FfiConverterTypeCAP26EntityKind.lift(buf)
}

public func FfiConverterTypeCAP26EntityKind_lower(_ value: Cap26EntityKind) -> RustBuffer {
    return FfiConverterTypeCAP26EntityKind.lower(value)
}

extension Cap26EntityKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Cap26KeyKind {
    /**
     * For a key to be used for signing transactions.
     * The value is the ascii sum of `"TRANSACTION_SIGNING"`
     */
    case transactionSigning
    /**
     * For a key to be used for signing authentication..
     * The value is the ascii sum of `"AUTHENTICATION_SIGNING"`
     */
    case authenticationSigning
    /**
     * For a key to be used for encrypting messages.
     * The value is the ascii sum of `"MESSAGE_ENCRYPTION"`
     */
    case messageEncryption
}

public struct FfiConverterTypeCAP26KeyKind: FfiConverterRustBuffer {
    typealias SwiftType = Cap26KeyKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26KeyKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .transactionSigning

        case 2: return .authenticationSigning

        case 3: return .messageEncryption

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26KeyKind, into buf: inout [UInt8]) {
        switch value {
        case .transactionSigning:
            writeInt(&buf, Int32(1))

        case .authenticationSigning:
            writeInt(&buf, Int32(2))

        case .messageEncryption:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeCAP26KeyKind_lift(_ buf: RustBuffer) throws -> Cap26KeyKind {
    return try FfiConverterTypeCAP26KeyKind.lift(buf)
}

public func FfiConverterTypeCAP26KeyKind_lower(_ value: Cap26KeyKind) -> RustBuffer {
    return FfiConverterTypeCAP26KeyKind.lower(value)
}

extension Cap26KeyKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A derivation path design specifically for Radix Babylon wallets used by Accounts and Personas
 * to be unique per network with separate key spaces for Accounts/Identities (Personas) and key
 * kind: sign transaction or sign auth.
 */
public enum Cap26Path {
    case getId(
        value: GetIdPath
    )
    case account(
        value: AccountPath
    )
    case identity(
        value: IdentityPath
    )
}

public struct FfiConverterTypeCAP26Path: FfiConverterRustBuffer {
    typealias SwiftType = Cap26Path

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26Path {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .getId(
                value: FfiConverterTypeGetIDPath.read(from: &buf)
            )

        case 2: return try .account(
                value: FfiConverterTypeAccountPath.read(from: &buf)
            )

        case 3: return try .identity(
                value: FfiConverterTypeIdentityPath.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26Path, into buf: inout [UInt8]) {
        switch value {
        case let .getId(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeGetIDPath.write(value, into: &buf)

        case let .account(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountPath.write(value, into: &buf)

        case let .identity(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeIdentityPath.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeCAP26Path_lift(_ buf: RustBuffer) throws -> Cap26Path {
    return try FfiConverterTypeCAP26Path.lift(buf)
}

public func FfiConverterTypeCAP26Path_lower(_ value: Cap26Path) -> RustBuffer {
    return FfiConverterTypeCAP26Path.lower(value)
}

extension Cap26Path: Equatable, Hashable {}

public enum CommonError {
    case Unknown(message: String)

    case InvalidEd25519PrivateKeyFromBytes(message: String)

    case InvalidEd25519PrivateKeyFromString(message: String)

    case InvalidSecp256k1PrivateKeyFromBytes(message: String)

    case InvalidSecp256k1PrivateKeyFromString(message: String)

    case InvalidEd25519PublicKeyFromBytes(message: String)

    case InvalidEd25519PublicKeyFromString(message: String)

    case InvalidSecp256k1PublicKeyFromBytes(message: String)

    case InvalidSecp256k1PublicKeyFromString(message: String)

    case InvalidSecp256k1PublicKeyPointNotOnCurve(message: String)

    case InvalidEd25519PublicKeyPointNotOnCurve(message: String)

    case StringNotHex(message: String)

    case InvalidByteCount(message: String)

    case InvalidBip32Path(message: String)

    case InvalidDepthOfBip44Path(message: String)

    case InvalidBip44LikePathAccountWasNotHardened(message: String)

    case InvalidBip44LikePathChangeWasUnexpectedlyHardened(message: String)

    /**
     * Radix Olympia did follow BIP44, we accidentally hardened the last component `"index"`,
     * and for backwards compatibility we require it to be hardened in Babylon too.
     */
    case InvalidBip44LikePathIndexWasNotHardened(message: String)

    case InvalidDepthOfCap26Path(message: String)

    case NotAllComponentsAreHardened(message: String)

    case Bip44PurposeNotFound(message: String)

    case CoinTypeNotFound(message: String)

    case InvalidNetworkIdExceedsLimit(message: String)

    case InvalidEntityKind(message: String)

    case WrongEntityKind(message: String)

    case InvalidKeyKind(message: String)

    case UnsupportedNetworkId(message: String)

    case InvalidGetIdPath(message: String)

    case UnknownBip39Word(message: String)

    case InvalidMnemonicPhrase(message: String)

    case InvalidBip39WordCount(message: String)

    case InvalidAppearanceId(message: String)

    case InvalidAccountAddress(message: String)

    case UnsupportedEntityType(message: String)

    case FailedToDecodeAddressFromBech32(message: String)

    case MismatchingEntityTypeWhileDecodingAddress(message: String)

    case MismatchingHrpWhileDecodingAddress(message: String)

    case UnknownNetworkId(message: String)

    case InvalidNonFungibleGlobalId(message: String)

    case FactorSourceCryptoParametersSupportedCurvesInvalidSize(message: String)

    case BadgeIsNotVirtualHierarchicalDeterministic(message: String)

    case FactorSourceIdNotFromHash(message: String)

    case ExpectedAccountPathButGotSomethingElse(message: String)

    case WrongEntityKindOfInFactorInstancesPath(message: String)

    case WrongKeyKindOfTransactionSigningFactorInstance(message: String)

    case WrongKeyKindOfAuthenticationSigningFactorInstance(message: String)

    case ExpectedDeviceFactorSourceGotSomethingElse(message: String)

    case ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse(message: String)

    case UnknownNetworkWithName(message: String)

    case UnknownNetworkForId(message: String)

    case GatewaysDiscrepancyOtherShouldNotContainCurrent(message: String)

    case InvalidGatewaysJsonCurrentNotFoundAmongstSaved(message: String)

    case InvalidUrl(message: String)

    case AccountOnWrongNetwork(message: String)

    case FactorSourcesMustNotBeEmpty(message: String)

    case UpdateFactorSourceMutateFailed(message: String)

    case CastFactorSourceWrongKind(message: String)

    case InvalidLength(message: String)

    case InvalidNonFungibleLocalIdString(message: String)

    case InvalidNonFungibleLocalIdBytes(message: String)

    case DecimalError(message: String)

    case InvalidBip39Index(message: String)

    case InvalidDisplayNameEmpty(message: String)

    case InvalidDisplayNameTooLong(message: String)

    case InvalidIso8601String(message: String)

    case UnknownAccount(message: String)

    case SecureStorageReadError(message: String)

    case UnableToLoadDeviceFactorSourceFromSecureStorage(message: String)

    case SecureStorageWriteError(message: String)

    case FailedToSerializeToJson(message: String)

    case FailedToDeserializeJsonToValue(message: String)

    case InvalidProfileId(message: String)

    case FailedToLoadProfileHeadersList(message: String)

    case ProfileDoesNotContainFactorSourceWithId(message: String)

    case NoActiveProfileIdSet(message: String)

    case ProfileSnapshotNotFound(message: String)

    case AccountAlreadyPresent(message: String)

    case UnableToAcquireWriteLockForProfile(message: String)

    case UnableToSaveMnemonicToSecureStorage(message: String)

    case UnableToLoadMnemonicFromSecureStorage(message: String)

    case UnableToSaveFactorSourceToProfile(message: String)

    case ExpectedIdentityPathButGotSomethingElse(message: String)

    case PersonaDataInvalidPhoneNumberEmpty(message: String)

    case PersonaDataInvalidEmailAddressEmpty(message: String)

    case PersonaDataInvalidNameFamilyNameEmpty(message: String)

    case PersonaDataInvalidNameGivenNamesEmpty(message: String)

    case InvalidUuiDv4(message: String)

    case UnrecognizedLocaleIdentifier(message: String)

    case FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(message: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeCommonError.lift(error)
    }
}

public struct FfiConverterTypeCommonError: FfiConverterRustBuffer {
    typealias SwiftType = CommonError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CommonError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .Unknown(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .InvalidEd25519PrivateKeyFromBytes(
                message: FfiConverterString.read(from: &buf)
            )

        case 3: return try .InvalidEd25519PrivateKeyFromString(
                message: FfiConverterString.read(from: &buf)
            )

        case 4: return try .InvalidSecp256k1PrivateKeyFromBytes(
                message: FfiConverterString.read(from: &buf)
            )

        case 5: return try .InvalidSecp256k1PrivateKeyFromString(
                message: FfiConverterString.read(from: &buf)
            )

        case 6: return try .InvalidEd25519PublicKeyFromBytes(
                message: FfiConverterString.read(from: &buf)
            )

        case 7: return try .InvalidEd25519PublicKeyFromString(
                message: FfiConverterString.read(from: &buf)
            )

        case 8: return try .InvalidSecp256k1PublicKeyFromBytes(
                message: FfiConverterString.read(from: &buf)
            )

        case 9: return try .InvalidSecp256k1PublicKeyFromString(
                message: FfiConverterString.read(from: &buf)
            )

        case 10: return try .InvalidSecp256k1PublicKeyPointNotOnCurve(
                message: FfiConverterString.read(from: &buf)
            )

        case 11: return try .InvalidEd25519PublicKeyPointNotOnCurve(
                message: FfiConverterString.read(from: &buf)
            )

        case 12: return try .StringNotHex(
                message: FfiConverterString.read(from: &buf)
            )

        case 13: return try .InvalidByteCount(
                message: FfiConverterString.read(from: &buf)
            )

        case 14: return try .InvalidBip32Path(
                message: FfiConverterString.read(from: &buf)
            )

        case 15: return try .InvalidDepthOfBip44Path(
                message: FfiConverterString.read(from: &buf)
            )

        case 16: return try .InvalidBip44LikePathAccountWasNotHardened(
                message: FfiConverterString.read(from: &buf)
            )

        case 17: return try .InvalidBip44LikePathChangeWasUnexpectedlyHardened(
                message: FfiConverterString.read(from: &buf)
            )

        case 18: return try .InvalidBip44LikePathIndexWasNotHardened(
                message: FfiConverterString.read(from: &buf)
            )

        case 19: return try .InvalidDepthOfCap26Path(
                message: FfiConverterString.read(from: &buf)
            )

        case 20: return try .NotAllComponentsAreHardened(
                message: FfiConverterString.read(from: &buf)
            )

        case 21: return try .Bip44PurposeNotFound(
                message: FfiConverterString.read(from: &buf)
            )

        case 22: return try .CoinTypeNotFound(
                message: FfiConverterString.read(from: &buf)
            )

        case 23: return try .InvalidNetworkIdExceedsLimit(
                message: FfiConverterString.read(from: &buf)
            )

        case 24: return try .InvalidEntityKind(
                message: FfiConverterString.read(from: &buf)
            )

        case 25: return try .WrongEntityKind(
                message: FfiConverterString.read(from: &buf)
            )

        case 26: return try .InvalidKeyKind(
                message: FfiConverterString.read(from: &buf)
            )

        case 27: return try .UnsupportedNetworkId(
                message: FfiConverterString.read(from: &buf)
            )

        case 28: return try .InvalidGetIdPath(
                message: FfiConverterString.read(from: &buf)
            )

        case 29: return try .UnknownBip39Word(
                message: FfiConverterString.read(from: &buf)
            )

        case 30: return try .InvalidMnemonicPhrase(
                message: FfiConverterString.read(from: &buf)
            )

        case 31: return try .InvalidBip39WordCount(
                message: FfiConverterString.read(from: &buf)
            )

        case 32: return try .InvalidAppearanceId(
                message: FfiConverterString.read(from: &buf)
            )

        case 33: return try .InvalidAccountAddress(
                message: FfiConverterString.read(from: &buf)
            )

        case 34: return try .UnsupportedEntityType(
                message: FfiConverterString.read(from: &buf)
            )

        case 35: return try .FailedToDecodeAddressFromBech32(
                message: FfiConverterString.read(from: &buf)
            )

        case 36: return try .MismatchingEntityTypeWhileDecodingAddress(
                message: FfiConverterString.read(from: &buf)
            )

        case 37: return try .MismatchingHrpWhileDecodingAddress(
                message: FfiConverterString.read(from: &buf)
            )

        case 38: return try .UnknownNetworkId(
                message: FfiConverterString.read(from: &buf)
            )

        case 39: return try .InvalidNonFungibleGlobalId(
                message: FfiConverterString.read(from: &buf)
            )

        case 40: return try .FactorSourceCryptoParametersSupportedCurvesInvalidSize(
                message: FfiConverterString.read(from: &buf)
            )

        case 41: return try .BadgeIsNotVirtualHierarchicalDeterministic(
                message: FfiConverterString.read(from: &buf)
            )

        case 42: return try .FactorSourceIdNotFromHash(
                message: FfiConverterString.read(from: &buf)
            )

        case 43: return try .ExpectedAccountPathButGotSomethingElse(
                message: FfiConverterString.read(from: &buf)
            )

        case 44: return try .WrongEntityKindOfInFactorInstancesPath(
                message: FfiConverterString.read(from: &buf)
            )

        case 45: return try .WrongKeyKindOfTransactionSigningFactorInstance(
                message: FfiConverterString.read(from: &buf)
            )

        case 46: return try .WrongKeyKindOfAuthenticationSigningFactorInstance(
                message: FfiConverterString.read(from: &buf)
            )

        case 47: return try .ExpectedDeviceFactorSourceGotSomethingElse(
                message: FfiConverterString.read(from: &buf)
            )

        case 48: return try .ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse(
                message: FfiConverterString.read(from: &buf)
            )

        case 49: return try .UnknownNetworkWithName(
                message: FfiConverterString.read(from: &buf)
            )

        case 50: return try .UnknownNetworkForId(
                message: FfiConverterString.read(from: &buf)
            )

        case 51: return try .GatewaysDiscrepancyOtherShouldNotContainCurrent(
                message: FfiConverterString.read(from: &buf)
            )

        case 52: return try .InvalidGatewaysJsonCurrentNotFoundAmongstSaved(
                message: FfiConverterString.read(from: &buf)
            )

        case 53: return try .InvalidUrl(
                message: FfiConverterString.read(from: &buf)
            )

        case 54: return try .AccountOnWrongNetwork(
                message: FfiConverterString.read(from: &buf)
            )

        case 55: return try .FactorSourcesMustNotBeEmpty(
                message: FfiConverterString.read(from: &buf)
            )

        case 56: return try .UpdateFactorSourceMutateFailed(
                message: FfiConverterString.read(from: &buf)
            )

        case 57: return try .CastFactorSourceWrongKind(
                message: FfiConverterString.read(from: &buf)
            )

        case 58: return try .InvalidLength(
                message: FfiConverterString.read(from: &buf)
            )

        case 59: return try .InvalidNonFungibleLocalIdString(
                message: FfiConverterString.read(from: &buf)
            )

        case 60: return try .InvalidNonFungibleLocalIdBytes(
                message: FfiConverterString.read(from: &buf)
            )

        case 61: return try .DecimalError(
                message: FfiConverterString.read(from: &buf)
            )

        case 62: return try .InvalidBip39Index(
                message: FfiConverterString.read(from: &buf)
            )

        case 63: return try .InvalidDisplayNameEmpty(
                message: FfiConverterString.read(from: &buf)
            )

        case 64: return try .InvalidDisplayNameTooLong(
                message: FfiConverterString.read(from: &buf)
            )

        case 65: return try .InvalidIso8601String(
                message: FfiConverterString.read(from: &buf)
            )

        case 66: return try .UnknownAccount(
                message: FfiConverterString.read(from: &buf)
            )

        case 67: return try .SecureStorageReadError(
                message: FfiConverterString.read(from: &buf)
            )

        case 68: return try .UnableToLoadDeviceFactorSourceFromSecureStorage(
                message: FfiConverterString.read(from: &buf)
            )

        case 69: return try .SecureStorageWriteError(
                message: FfiConverterString.read(from: &buf)
            )

        case 70: return try .FailedToSerializeToJson(
                message: FfiConverterString.read(from: &buf)
            )

        case 71: return try .FailedToDeserializeJsonToValue(
                message: FfiConverterString.read(from: &buf)
            )

        case 72: return try .InvalidProfileId(
                message: FfiConverterString.read(from: &buf)
            )

        case 73: return try .FailedToLoadProfileHeadersList(
                message: FfiConverterString.read(from: &buf)
            )

        case 74: return try .ProfileDoesNotContainFactorSourceWithId(
                message: FfiConverterString.read(from: &buf)
            )

        case 75: return try .NoActiveProfileIdSet(
                message: FfiConverterString.read(from: &buf)
            )

        case 76: return try .ProfileSnapshotNotFound(
                message: FfiConverterString.read(from: &buf)
            )

        case 77: return try .AccountAlreadyPresent(
                message: FfiConverterString.read(from: &buf)
            )

        case 78: return try .UnableToAcquireWriteLockForProfile(
                message: FfiConverterString.read(from: &buf)
            )

        case 79: return try .UnableToSaveMnemonicToSecureStorage(
                message: FfiConverterString.read(from: &buf)
            )

        case 80: return try .UnableToLoadMnemonicFromSecureStorage(
                message: FfiConverterString.read(from: &buf)
            )

        case 81: return try .UnableToSaveFactorSourceToProfile(
                message: FfiConverterString.read(from: &buf)
            )

        case 82: return try .ExpectedIdentityPathButGotSomethingElse(
                message: FfiConverterString.read(from: &buf)
            )

        case 83: return try .PersonaDataInvalidPhoneNumberEmpty(
                message: FfiConverterString.read(from: &buf)
            )

        case 84: return try .PersonaDataInvalidEmailAddressEmpty(
                message: FfiConverterString.read(from: &buf)
            )

        case 85: return try .PersonaDataInvalidNameFamilyNameEmpty(
                message: FfiConverterString.read(from: &buf)
            )

        case 86: return try .PersonaDataInvalidNameGivenNamesEmpty(
                message: FfiConverterString.read(from: &buf)
            )

        case 87: return try .InvalidUuiDv4(
                message: FfiConverterString.read(from: &buf)
            )

        case 88: return try .UnrecognizedLocaleIdentifier(
                message: FfiConverterString.read(from: &buf)
            )

        case 89: return try .FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CommonError, into buf: inout [UInt8]) {
        switch value {
        case .Unknown(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        case .InvalidEd25519PrivateKeyFromBytes(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(2))
        case .InvalidEd25519PrivateKeyFromString(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(3))
        case .InvalidSecp256k1PrivateKeyFromBytes(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(4))
        case .InvalidSecp256k1PrivateKeyFromString(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(5))
        case .InvalidEd25519PublicKeyFromBytes(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(6))
        case .InvalidEd25519PublicKeyFromString(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(7))
        case .InvalidSecp256k1PublicKeyFromBytes(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(8))
        case .InvalidSecp256k1PublicKeyFromString(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(9))
        case .InvalidSecp256k1PublicKeyPointNotOnCurve(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(10))
        case .InvalidEd25519PublicKeyPointNotOnCurve(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(11))
        case .StringNotHex(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(12))
        case .InvalidByteCount(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(13))
        case .InvalidBip32Path(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(14))
        case .InvalidDepthOfBip44Path(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(15))
        case .InvalidBip44LikePathAccountWasNotHardened(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(16))
        case .InvalidBip44LikePathChangeWasUnexpectedlyHardened(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(17))
        case .InvalidBip44LikePathIndexWasNotHardened(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(18))
        case .InvalidDepthOfCap26Path(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(19))
        case .NotAllComponentsAreHardened(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(20))
        case .Bip44PurposeNotFound(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(21))
        case .CoinTypeNotFound(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(22))
        case .InvalidNetworkIdExceedsLimit(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(23))
        case .InvalidEntityKind(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(24))
        case .WrongEntityKind(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(25))
        case .InvalidKeyKind(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(26))
        case .UnsupportedNetworkId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(27))
        case .InvalidGetIdPath(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(28))
        case .UnknownBip39Word(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(29))
        case .InvalidMnemonicPhrase(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(30))
        case .InvalidBip39WordCount(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(31))
        case .InvalidAppearanceId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(32))
        case .InvalidAccountAddress(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(33))
        case .UnsupportedEntityType(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(34))
        case .FailedToDecodeAddressFromBech32(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(35))
        case .MismatchingEntityTypeWhileDecodingAddress(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(36))
        case .MismatchingHrpWhileDecodingAddress(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(37))
        case .UnknownNetworkId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(38))
        case .InvalidNonFungibleGlobalId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(39))
        case .FactorSourceCryptoParametersSupportedCurvesInvalidSize(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(40))
        case .BadgeIsNotVirtualHierarchicalDeterministic(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(41))
        case .FactorSourceIdNotFromHash(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(42))
        case .ExpectedAccountPathButGotSomethingElse(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(43))
        case .WrongEntityKindOfInFactorInstancesPath(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(44))
        case .WrongKeyKindOfTransactionSigningFactorInstance(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(45))
        case .WrongKeyKindOfAuthenticationSigningFactorInstance(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(46))
        case .ExpectedDeviceFactorSourceGotSomethingElse(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(47))
        case .ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(48))
        case .UnknownNetworkWithName(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(49))
        case .UnknownNetworkForId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(50))
        case .GatewaysDiscrepancyOtherShouldNotContainCurrent(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(51))
        case .InvalidGatewaysJsonCurrentNotFoundAmongstSaved(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(52))
        case .InvalidUrl(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(53))
        case .AccountOnWrongNetwork(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(54))
        case .FactorSourcesMustNotBeEmpty(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(55))
        case .UpdateFactorSourceMutateFailed(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(56))
        case .CastFactorSourceWrongKind(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(57))
        case .InvalidLength(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(58))
        case .InvalidNonFungibleLocalIdString(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(59))
        case .InvalidNonFungibleLocalIdBytes(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(60))
        case .DecimalError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(61))
        case .InvalidBip39Index(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(62))
        case .InvalidDisplayNameEmpty(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(63))
        case .InvalidDisplayNameTooLong(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(64))
        case .InvalidIso8601String(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(65))
        case .UnknownAccount(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(66))
        case .SecureStorageReadError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(67))
        case .UnableToLoadDeviceFactorSourceFromSecureStorage(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(68))
        case .SecureStorageWriteError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(69))
        case .FailedToSerializeToJson(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(70))
        case .FailedToDeserializeJsonToValue(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(71))
        case .InvalidProfileId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(72))
        case .FailedToLoadProfileHeadersList(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(73))
        case .ProfileDoesNotContainFactorSourceWithId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(74))
        case .NoActiveProfileIdSet(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(75))
        case .ProfileSnapshotNotFound(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(76))
        case .AccountAlreadyPresent(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(77))
        case .UnableToAcquireWriteLockForProfile(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(78))
        case .UnableToSaveMnemonicToSecureStorage(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(79))
        case .UnableToLoadMnemonicFromSecureStorage(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(80))
        case .UnableToSaveFactorSourceToProfile(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(81))
        case .ExpectedIdentityPathButGotSomethingElse(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(82))
        case .PersonaDataInvalidPhoneNumberEmpty(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(83))
        case .PersonaDataInvalidEmailAddressEmpty(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(84))
        case .PersonaDataInvalidNameFamilyNameEmpty(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(85))
        case .PersonaDataInvalidNameGivenNamesEmpty(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(86))
        case .InvalidUuiDv4(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(87))
        case .UnrecognizedLocaleIdentifier(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(88))
        case .FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(89))
        }
    }
}

extension CommonError: Equatable, Hashable {}

extension CommonError: Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The exception kind for deposit address
 */
public enum DepositAddressExceptionRule {
    /**
     * A resource can always be deposited in to the account by third-parties
     */
    case allow
    /**
     * A resource can never be deposited in to the account by third-parties
     */
    case deny
}

public struct FfiConverterTypeDepositAddressExceptionRule: FfiConverterRustBuffer {
    typealias SwiftType = DepositAddressExceptionRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositAddressExceptionRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .allow

        case 2: return .deny

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositAddressExceptionRule, into buf: inout [UInt8]) {
        switch value {
        case .allow:
            writeInt(&buf, Int32(1))

        case .deny:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeDepositAddressExceptionRule_lift(_ buf: RustBuffer) throws -> DepositAddressExceptionRule {
    return try FfiConverterTypeDepositAddressExceptionRule.lift(buf)
}

public func FfiConverterTypeDepositAddressExceptionRule_lower(_ value: DepositAddressExceptionRule) -> RustBuffer {
    return FfiConverterTypeDepositAddressExceptionRule.lower(value)
}

extension DepositAddressExceptionRule: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The general deposit rule to apply
 */
public enum DepositRule {
    /**
     * The account accepts **all** assets by default, except for exceptions (if any) which might not deposit/be deposited into this account.
     */
    case acceptKnown
    /**
     * The account accepts **known** assets by default, except for exceptions (if any) which might not deposit/be deposited into this account. By known we mean assets this account has received in the past.
     */
    case acceptAll
    /**
     * The account denies **all** assets by default, except for exceptions (if any) which might in fact deposit/be deposited into this account.
     */
    case denyAll
}

public struct FfiConverterTypeDepositRule: FfiConverterRustBuffer {
    typealias SwiftType = DepositRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .acceptKnown

        case 2: return .acceptAll

        case 3: return .denyAll

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositRule, into buf: inout [UInt8]) {
        switch value {
        case .acceptKnown:
            writeInt(&buf, Int32(1))

        case .acceptAll:
            writeInt(&buf, Int32(2))

        case .denyAll:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeDepositRule_lift(_ buf: RustBuffer) throws -> DepositRule {
    return try FfiConverterTypeDepositRule.lift(buf)
}

public func FfiConverterTypeDepositRule_lower(_ value: DepositRule) -> RustBuffer {
    return FfiConverterTypeDepositRule.lower(value)
}

extension DepositRule: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A derivation path on either supported schemes, either Babylon (CAP26) or Olympia (BIP44Like).
 */
public enum DerivationPath {
    case cap26(
        value: Cap26Path
    )
    case bip44Like(
        value: Bip44LikePath
    )
}

public struct FfiConverterTypeDerivationPath: FfiConverterRustBuffer {
    typealias SwiftType = DerivationPath

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPath {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .cap26(
                value: FfiConverterTypeCAP26Path.read(from: &buf)
            )

        case 2: return try .bip44Like(
                value: FfiConverterTypeBIP44LikePath.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivationPath, into buf: inout [UInt8]) {
        switch value {
        case let .cap26(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeCAP26Path.write(value, into: &buf)

        case let .bip44Like(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBIP44LikePath.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeDerivationPath_lift(_ buf: RustBuffer) throws -> DerivationPath {
    return try FfiConverterTypeDerivationPath.lift(buf)
}

public func FfiConverterTypeDerivationPath_lower(_ value: DerivationPath) -> RustBuffer {
    return FfiConverterTypeDerivationPath.lower(value)
}

extension DerivationPath: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Which derivation path to used for some particular HD operations
 * such as signing or public key derivation. Radix Babylon introduces
 * a new scheme call Cap26 but we also need to support BIP44-like used
 * by Olympia.
 */
public enum DerivationPathScheme {
    /**
     * A BIP32 based derivation path scheme, using SLIP10.
     */
    case cap26
    /**
     * A BIP32 based similar to BIP44, but not strict BIP44 since the
     * last path component is hardened (a mistake made during Olympia),
     * used to support legacy accounts imported from Olympia wallet.
     */
    case bip44Olympia
}

public struct FfiConverterTypeDerivationPathScheme: FfiConverterRustBuffer {
    typealias SwiftType = DerivationPathScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPathScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .cap26

        case 2: return .bip44Olympia

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivationPathScheme, into buf: inout [UInt8]) {
        switch value {
        case .cap26:
            writeInt(&buf, Int32(1))

        case .bip44Olympia:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeDerivationPathScheme_lift(_ buf: RustBuffer) throws -> DerivationPathScheme {
    return try FfiConverterTypeDerivationPathScheme.lift(buf)
}

public func FfiConverterTypeDerivationPathScheme_lower(_ value: DerivationPathScheme) -> RustBuffer {
    return FfiConverterTypeDerivationPathScheme.lower(value)
}

extension DerivationPathScheme: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Flags used to mark state of an Account or Persona such as whether
 * user has marked it as deleted or not.
 */
public enum EntityFlag {
    /**
     * The entity is marked as deleted by user. Entity should still be kept in Profile
     */
    case deletedByUser
}

public struct FfiConverterTypeEntityFlag: FfiConverterRustBuffer {
    typealias SwiftType = EntityFlag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityFlag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .deletedByUser

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityFlag, into buf: inout [UInt8]) {
        switch value {
        case .deletedByUser:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeEntityFlag_lift(_ buf: RustBuffer) throws -> EntityFlag {
    return try FfiConverterTypeEntityFlag.lift(buf)
}

public func FfiConverterTypeEntityFlag_lower(_ value: EntityFlag) -> RustBuffer {
    return FfiConverterTypeEntityFlag.lower(value)
}

extension EntityFlag: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EntityKind {
    case persona
    case accounts
}

public struct FfiConverterTypeEntityKind: FfiConverterRustBuffer {
    typealias SwiftType = EntityKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .persona

        case 2: return .accounts

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityKind, into buf: inout [UInt8]) {
        switch value {
        case .persona:
            writeInt(&buf, Int32(1))

        case .accounts:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeEntityKind_lift(_ buf: RustBuffer) throws -> EntityKind {
    return try FfiConverterTypeEntityKind.lift(buf)
}

public func FfiConverterTypeEntityKind_lower(_ value: EntityKind) -> RustBuffer {
    return FfiConverterTypeEntityKind.lower(value)
}

extension EntityKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the state an entity - Account or Persona - is in, in regards to how
 * the user controls it, i.e. if it is controlled by a single factor (private key)
 * or an `AccessController` with a potential Multi-Factor setup.
 */
public enum EntitySecurityState {
    /**
     * The account is controlled by a single factor (private key)
     */
    case unsecured(
        value: UnsecuredEntityControl
    )
}

public struct FfiConverterTypeEntitySecurityState: FfiConverterRustBuffer {
    typealias SwiftType = EntitySecurityState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntitySecurityState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .unsecured(
                value: FfiConverterTypeUnsecuredEntityControl.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntitySecurityState, into buf: inout [UInt8]) {
        switch value {
        case let .unsecured(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUnsecuredEntityControl.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeEntitySecurityState_lift(_ buf: RustBuffer) throws -> EntitySecurityState {
    return try FfiConverterTypeEntitySecurityState.lift(buf)
}

public func FfiConverterTypeEntitySecurityState_lower(_ value: EntitySecurityState) -> RustBuffer {
    return FfiConverterTypeEntitySecurityState.lower(value)
}

extension EntitySecurityState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either a "physical" badge (NFT) or some source for recreation of a producer
 * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
 * is derived which produces virtual badges (signatures).
 */
public enum FactorInstanceBadge {
    case virtual(
        value: FactorInstanceBadgeVirtualSource
    )
}

public struct FfiConverterTypeFactorInstanceBadge: FfiConverterRustBuffer {
    typealias SwiftType = FactorInstanceBadge

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceBadge {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .virtual(
                value: FfiConverterTypeFactorInstanceBadgeVirtualSource.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorInstanceBadge, into buf: inout [UInt8]) {
        switch value {
        case let .virtual(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFactorInstanceBadgeVirtualSource.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorInstanceBadge_lift(_ buf: RustBuffer) throws -> FactorInstanceBadge {
    return try FfiConverterTypeFactorInstanceBadge.lift(buf)
}

public func FfiConverterTypeFactorInstanceBadge_lower(_ value: FactorInstanceBadge) -> RustBuffer {
    return FfiConverterTypeFactorInstanceBadge.lower(value)
}

extension FactorInstanceBadge: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FactorInstanceBadgeVirtualSource {
    case hierarchicalDeterministic(
        value: HierarchicalDeterministicPublicKey
    )
}

public struct FfiConverterTypeFactorInstanceBadgeVirtualSource: FfiConverterRustBuffer {
    typealias SwiftType = FactorInstanceBadgeVirtualSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceBadgeVirtualSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .hierarchicalDeterministic(
                value: FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorInstanceBadgeVirtualSource, into buf: inout [UInt8]) {
        switch value {
        case let .hierarchicalDeterministic(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeHierarchicalDeterministicPublicKey.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorInstanceBadgeVirtualSource_lift(_ buf: RustBuffer) throws -> FactorInstanceBadgeVirtualSource {
    return try FfiConverterTypeFactorInstanceBadgeVirtualSource.lift(buf)
}

public func FfiConverterTypeFactorInstanceBadgeVirtualSource_lower(_ value: FactorInstanceBadgeVirtualSource) -> RustBuffer {
    return FfiConverterTypeFactorInstanceBadgeVirtualSource.lower(value)
}

extension FactorInstanceBadgeVirtualSource: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FactorSource {
    case device(
        value: DeviceFactorSource
    )
    case ledger(
        value: LedgerHardwareWalletFactorSource
    )
}

public struct FfiConverterTypeFactorSource: FfiConverterRustBuffer {
    typealias SwiftType = FactorSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .device(
                value: FfiConverterTypeDeviceFactorSource.read(from: &buf)
            )

        case 2: return try .ledger(
                value: FfiConverterTypeLedgerHardwareWalletFactorSource.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSource, into buf: inout [UInt8]) {
        switch value {
        case let .device(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDeviceFactorSource.write(value, into: &buf)

        case let .ledger(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLedgerHardwareWalletFactorSource.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorSource_lift(_ buf: RustBuffer) throws -> FactorSource {
    return try FfiConverterTypeFactorSource.lift(buf)
}

public func FfiConverterTypeFactorSource_lower(_ value: FactorSource) -> RustBuffer {
    return FfiConverterTypeFactorSource.lower(value)
}

extension FactorSource: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Flags which describe a certain state a FactorSource might be in, primarily used
 * by DeviceFactorSource's to mark which "Babylon" FactorSource is the **main** one.
 */
public enum FactorSourceFlag {
    /**
     * Used to mark a "babylon" `.device` FactorSource as "main". All new accounts
     * and Personas are created using the `main` `DeviceFactorSource`.
     *
     * We can only ever have one.
     * We might have zero `main` flags across all  `DeviceFactorSource`s if and only if we have only one  `DeviceFactorSource`s. If we have two or more  `DeviceFactorSource`s one of them MUST
     * be marked with `main`.
     */
    case main
    /**
     * Until we have implemented "proper" deletion, we will "flag" a
     * FactorSource as deleted by the user and hide it, meaning e.g.
     * that in Multi-Factor Setup flows it will not show up.
     */
    case deletedByUser
}

public struct FfiConverterTypeFactorSourceFlag: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceFlag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceFlag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .main

        case 2: return .deletedByUser

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceFlag, into buf: inout [UInt8]) {
        switch value {
        case .main:
            writeInt(&buf, Int32(1))

        case .deletedByUser:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeFactorSourceFlag_lift(_ buf: RustBuffer) throws -> FactorSourceFlag {
    return try FfiConverterTypeFactorSourceFlag.lift(buf)
}

public func FfiConverterTypeFactorSourceFlag_lower(_ value: FactorSourceFlag) -> RustBuffer {
    return FfiConverterTypeFactorSourceFlag.lower(value)
}

extension FactorSourceFlag: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A unique and stable identifier of a FactorSource, e.g. a
 * DeviceFactorSource being a mnemonic securely stored in a
 * device (phone), where the ID of it is the hash of a special
 * key derived near the root of it.
 */
public enum FactorSourceId {
    /**
     * FactorSourceID from the blake2b hash of the special HD public key derived at `CAP26::GetID`,
     * for a certain `FactorSourceKind`
     */
    case hash(
        value: FactorSourceIdFromHash
    )
    /**
     * FactorSourceID from an AccountAddress, typically used by `trustedContact` FactorSource.
     */
    case address(
        value: FactorSourceIdFromAddress
    )
}

public struct FfiConverterTypeFactorSourceID: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .hash(
                value: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )

        case 2: return try .address(
                value: FfiConverterTypeFactorSourceIDFromAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceId, into buf: inout [UInt8]) {
        switch value {
        case let .hash(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFactorSourceIDFromHash.write(value, into: &buf)

        case let .address(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFactorSourceIDFromAddress.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorSourceID_lift(_ buf: RustBuffer) throws -> FactorSourceId {
    return try FfiConverterTypeFactorSourceID.lift(buf)
}

public func FfiConverterTypeFactorSourceID_lower(_ value: FactorSourceId) -> RustBuffer {
    return FfiConverterTypeFactorSourceID.lower(value)
}

extension FactorSourceId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The **kind** (or "type") of FactorSource describes how it is used.
 */
public enum FactorSourceKind {
    /**
     * A user owned unencrypted mnemonic (and optional BIP39 passphrase) stored on device,
     * thus directly usable. This kind is used as the standard factor source for all new
     * wallet users.
     *
     * Attributes:
     * * Mine
     * * On device
     * * Hierarchical deterministic (Mnemonic)
     * * Entity creating
     */
    case device
    /**
     * A user owned hardware wallet by vendor Ledger HQ, most commonly
     * a Ledger Nano S or Ledger Nano X. Less common models are Ledger Nano S Plus
     * Ledger Stax.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hardware (requires Browser Connector Extension to communicate with wallet)
     * * Hierarchical deterministic
     * * Entity creating (accounts only)
     */
    case ledgerHqHardwareWallet
    /**
     * A user owned mnemonic (and optional BIP39 passphrase) user has to input when used,
     * e.g. during signing.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic  (Mnemonic)
     */
    case offDeviceMnemonic
    /**
     * A contact, friend, company, organization or otherwise third party the user trusts enough
     * to be given a recovery token user has minted and sent the this contact.
     *
     * Attributes:
     * * **Not** mine
     * * Off device
     */
    case trustedContact
    /**
     * An encrypted user owned mnemonic (*never* any BIP39 passphrase) which can
     * be decrypted by answers to **security question**, which are personal questions
     * that should be only known to the user.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic  (**Encrypted** mnemonic)
     */
    case securityQuestions
}

public struct FfiConverterTypeFactorSourceKind: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .device

        case 2: return .ledgerHqHardwareWallet

        case 3: return .offDeviceMnemonic

        case 4: return .trustedContact

        case 5: return .securityQuestions

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceKind, into buf: inout [UInt8]) {
        switch value {
        case .device:
            writeInt(&buf, Int32(1))

        case .ledgerHqHardwareWallet:
            writeInt(&buf, Int32(2))

        case .offDeviceMnemonic:
            writeInt(&buf, Int32(3))

        case .trustedContact:
            writeInt(&buf, Int32(4))

        case .securityQuestions:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeFactorSourceKind_lift(_ buf: RustBuffer) throws -> FactorSourceKind {
    return try FfiConverterTypeFactorSourceKind.lift(buf)
}

public func FfiConverterTypeFactorSourceKind_lower(_ value: FactorSourceKind) -> RustBuffer {
    return FfiConverterTypeFactorSourceKind.lower(value)
}

extension FactorSourceKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Fiat currency to measure and display the value of some XRD or other Radix assets value/worth in.
 */
public enum FiatCurrency {
    /**
     * American dollars.
     */
    case usd
}

public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = FiatCurrency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .usd

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        switch value {
        case .usd:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(buf)
}

public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
    return FfiConverterTypeFiatCurrency.lower(value)
}

extension FiatCurrency: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The model of a Ledger HQ hardware wallet NanoS, e.g.
 * *Ledger Nano S+*.
 */
public enum LedgerHardwareWalletModel {
    case nanoS
    case nanoSPlus
    case nanoX
}

public struct FfiConverterTypeLedgerHardwareWalletModel: FfiConverterRustBuffer {
    typealias SwiftType = LedgerHardwareWalletModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletModel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .nanoS

        case 2: return .nanoSPlus

        case 3: return .nanoX

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LedgerHardwareWalletModel, into buf: inout [UInt8]) {
        switch value {
        case .nanoS:
            writeInt(&buf, Int32(1))

        case .nanoSPlus:
            writeInt(&buf, Int32(2))

        case .nanoX:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeLedgerHardwareWalletModel_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletModel {
    return try FfiConverterTypeLedgerHardwareWalletModel.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletModel_lower(_ value: LedgerHardwareWalletModel) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletModel.lower(value)
}

extension LedgerHardwareWalletModel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Message {
    case plainText(
        string: String
    )
}

public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .plainText(
                string: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        switch value {
        case let .plainText(string):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(string, into: &buf)
        }
    }
}

public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}

extension Message: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NetworkId {
    /**
     * Mainnet (0x01 / 0d01)
     *
     * The Radix public network.
     *
     * https://github.com/radixdlt/radixdlt-scrypto/blob/v1.0.1/radix-engine-common/src/network/mod.rs#L79
     */
    case mainnet
    /**
     * Stokenet (0x02 / 0d02)
     *
     * The public testnet for Radix.
     *
     * https://github.com/radixdlt/radixdlt-scrypto/blob/v1.0.1/radix-engine-common/src/network/mod.rs#L71
     */
    case stokenet
    /**
     * Adapanet (0x0a / 0d10
     */
    case adapanet
    /**
     * Nebunet (0x0b / 0d11 )
     *
     * The first Betanet of Babylon
     */
    case nebunet
    /**
     * Kisharnet (0x0c / 0d12)
     *
     * The first release candidate of Babylon (RCnet v1)
     */
    case kisharnet
    /**
     * Ansharnet (0x0d / 0d13)
     *
     * The second release candidate of Babylon (RCnet v2)
     */
    case ansharnet
    /**
     * Zabanet (0x0e / 0d14)
     *
     * The third release candidate of Babylon (RCnet v3)
     */
    case zabanet
    /**
     * Enkinet (0x21 / 0d33)
     *
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L94
     */
    case enkinet
    /**
     * Hammunet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L95
     * Decimal value: 34
     */
    case hammunet
    /**
     * Nergalnet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L96
     * Decimal value: 35
     */
    case nergalnet
    /**
     * Mardunet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L97
     * Decimal value: 36
     */
    case mardunet
    /**
     * Simulator (0xf2 / 0d242)
     */
    case simulator
}

public struct FfiConverterTypeNetworkID: FfiConverterRustBuffer {
    typealias SwiftType = NetworkId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .mainnet

        case 2: return .stokenet

        case 3: return .adapanet

        case 4: return .nebunet

        case 5: return .kisharnet

        case 6: return .ansharnet

        case 7: return .zabanet

        case 8: return .enkinet

        case 9: return .hammunet

        case 10: return .nergalnet

        case 11: return .mardunet

        case 12: return .simulator

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NetworkId, into buf: inout [UInt8]) {
        switch value {
        case .mainnet:
            writeInt(&buf, Int32(1))

        case .stokenet:
            writeInt(&buf, Int32(2))

        case .adapanet:
            writeInt(&buf, Int32(3))

        case .nebunet:
            writeInt(&buf, Int32(4))

        case .kisharnet:
            writeInt(&buf, Int32(5))

        case .ansharnet:
            writeInt(&buf, Int32(6))

        case .zabanet:
            writeInt(&buf, Int32(7))

        case .enkinet:
            writeInt(&buf, Int32(8))

        case .hammunet:
            writeInt(&buf, Int32(9))

        case .nergalnet:
            writeInt(&buf, Int32(10))

        case .mardunet:
            writeInt(&buf, Int32(11))

        case .simulator:
            writeInt(&buf, Int32(12))
        }
    }
}

public func FfiConverterTypeNetworkID_lift(_ buf: RustBuffer) throws -> NetworkId {
    return try FfiConverterTypeNetworkID.lift(buf)
}

public func FfiConverterTypeNetworkID_lower(_ value: NetworkId) -> RustBuffer {
    return FfiConverterTypeNetworkID.lower(value)
}

extension NetworkId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NonFungibleLocalId {
    case integer(
        value: UInt64
    )
    case str(
        value: String
    )
    case bytes(
        value: BagOfBytes
    )
    case ruid(
        value: BagOfBytes
    )
}

public struct FfiConverterTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleLocalId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .integer(
                value: FfiConverterUInt64.read(from: &buf)
            )

        case 2: return try .str(
                value: FfiConverterString.read(from: &buf)
            )

        case 3: return try .bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )

        case 4: return try .ruid(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleLocalId, into buf: inout [UInt8]) {
        switch value {
        case let .integer(value):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(value, into: &buf)

        case let .str(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)

        case let .bytes(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBagOfBytes.write(value, into: &buf)

        case let .ruid(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBagOfBytes.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeNonFungibleLocalId_lift(_ buf: RustBuffer) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalId_lower(_ value: NonFungibleLocalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalId.lower(value)
}

extension NonFungibleLocalId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The version of the Profile Snapshot data format (JSON).
 */
public enum ProfileSnapshotVersion {
    /**
     * The version we went live with on Babylon mainnet 2023-09-28,
     * shipped with iOS 1.0.0 (7) and Android v 1.0.0.
     */
    case v100
}

public struct FfiConverterTypeProfileSnapshotVersion: FfiConverterRustBuffer {
    typealias SwiftType = ProfileSnapshotVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileSnapshotVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .v100

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileSnapshotVersion, into buf: inout [UInt8]) {
        switch value {
        case .v100:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeProfileSnapshotVersion_lift(_ buf: RustBuffer) throws -> ProfileSnapshotVersion {
    return try FfiConverterTypeProfileSnapshotVersion.lift(buf)
}

public func FfiConverterTypeProfileSnapshotVersion_lower(_ value: ProfileSnapshotVersion) -> RustBuffer {
    return FfiConverterTypeProfileSnapshotVersion.lower(value)
}

extension ProfileSnapshotVersion: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of supported public keys on different curves, supported
 * curves are `secp256k1` and `Curve25519`
 */
public enum PublicKey {
    /**
     * An Ed25519 public key used to verify cryptographic signatures.
     */
    case ed25519(
        value: Ed25519PublicKey
    )
    /**
     * A secp256k1 public key used to verify cryptographic signatures (ECDSA signatures).
     */
    case secp256k1(
        value: Secp256k1PublicKey
    )
}

public struct FfiConverterTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .ed25519(
                value: FfiConverterTypeEd25519PublicKey.read(from: &buf)
            )

        case 2: return try .secp256k1(
                value: FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        switch value {
        case let .ed25519(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEd25519PublicKey.write(value, into: &buf)

        case let .secp256k1(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecp256k1PublicKey.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypePublicKey_lift(_ buf: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(buf)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}

extension PublicKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A quantifier of a quantity, either `atLeast` or `exactly`, as in
 * "I want AT LEAST 3" or "I want EXACTLY 10".
 *
 * This is typically sent by a Dapp when requesting access to accounts
 * or PersonaData.
 */
public enum RequestedNumberQuantifier {
    /**
     * (Request access to) *exactly* N many of something, where quantity `N` is
     * not part of this enum, e.g. "I want EXACTLY 2 accounts"
     */
    case exactly
    /**
     * (Request access to) *at least* N many of something, where quantity `N` is
     * not part of this enum, e.g. "I want AT LEAST 3 accounts"
     */
    case atLeast
}

public struct FfiConverterTypeRequestedNumberQuantifier: FfiConverterRustBuffer {
    typealias SwiftType = RequestedNumberQuantifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedNumberQuantifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .exactly

        case 2: return .atLeast

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestedNumberQuantifier, into buf: inout [UInt8]) {
        switch value {
        case .exactly:
            writeInt(&buf, Int32(1))

        case .atLeast:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeRequestedNumberQuantifier_lift(_ buf: RustBuffer) throws -> RequestedNumberQuantifier {
    return try FfiConverterTypeRequestedNumberQuantifier.lift(buf)
}

public func FfiConverterTypeRequestedNumberQuantifier_lower(_ value: RequestedNumberQuantifier) -> RustBuffer {
    return FfiConverterTypeRequestedNumberQuantifier.lower(value)
}

extension RequestedNumberQuantifier: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The addresses that can be added as exception to the `DepositRule`
 */
public enum ResourceOrNonFungible {
    case resource(
        value: ResourceAddress
    )
    case nonFungible(
        value: NonFungibleGlobalId
    )
}

public struct FfiConverterTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = ResourceOrNonFungible

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceOrNonFungible {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .resource(
                value: FfiConverterTypeResourceAddress.read(from: &buf)
            )

        case 2: return try .nonFungible(
                value: FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceOrNonFungible, into buf: inout [UInt8]) {
        switch value {
        case let .resource(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(value, into: &buf)

        case let .nonFungible(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNonFungibleGlobalId.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeResourceOrNonFungible_lift(_ buf: RustBuffer) throws -> ResourceOrNonFungible {
    return try FfiConverterTypeResourceOrNonFungible.lift(buf)
}

public func FfiConverterTypeResourceOrNonFungible_lower(_ value: ResourceOrNonFungible) -> RustBuffer {
    return FfiConverterTypeResourceOrNonFungible.lower(value)
}

extension ResourceOrNonFungible: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Defines the rounding strategy used when you round e.g. `Decimal192`.
 *
 * Following the same naming convention as https://docs.rs/rust_decimal/latest/rust_decimal/enum.RoundingStrategy.html.
 */
public enum RoundingMode {
    /**
     * The number is always rounded toward positive infinity, e.g. `3.1 -> 4`, `-3.1 -> -3`.
     */
    case toPositiveInfinity
    /**
     * The number is always rounded toward negative infinity, e.g. `3.1 -> 3`, `-3.1 -> -4`.
     */
    case toNegativeInfinity
    /**
     * The number is always rounded toward zero, e.g. `3.1 -> 3`, `-3.1 -> -3`.
     */
    case toZero
    /**
     * The number is always rounded away from zero, e.g. `3.1 -> 4`, `-3.1 -> -4`.
     */
    case awayFromZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded toward zero, e.g. `3.5 -> 3`, `-3.5 -> -3`.
     */
    case toNearestMidpointTowardZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded away from zero, e.g. `3.5 -> 4`, `-3.5 -> -4`.
     */
    case toNearestMidpointAwayFromZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded toward the nearest even number. Also known as "Bankers Rounding".
     */
    case toNearestMidpointToEven
}

public struct FfiConverterTypeRoundingMode: FfiConverterRustBuffer {
    typealias SwiftType = RoundingMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoundingMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .toPositiveInfinity

        case 2: return .toNegativeInfinity

        case 3: return .toZero

        case 4: return .awayFromZero

        case 5: return .toNearestMidpointTowardZero

        case 6: return .toNearestMidpointAwayFromZero

        case 7: return .toNearestMidpointToEven

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoundingMode, into buf: inout [UInt8]) {
        switch value {
        case .toPositiveInfinity:
            writeInt(&buf, Int32(1))

        case .toNegativeInfinity:
            writeInt(&buf, Int32(2))

        case .toZero:
            writeInt(&buf, Int32(3))

        case .awayFromZero:
            writeInt(&buf, Int32(4))

        case .toNearestMidpointTowardZero:
            writeInt(&buf, Int32(5))

        case .toNearestMidpointAwayFromZero:
            writeInt(&buf, Int32(6))

        case .toNearestMidpointToEven:
            writeInt(&buf, Int32(7))
        }
    }
}

public func FfiConverterTypeRoundingMode_lift(_ buf: RustBuffer) throws -> RoundingMode {
    return try FfiConverterTypeRoundingMode.lift(buf)
}

public func FfiConverterTypeRoundingMode_lower(_ value: RoundingMode) -> RustBuffer {
    return FfiConverterTypeRoundingMode.lower(value)
}

extension RoundingMode: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Elliptic Curves which the SLIP10 derivation algorithm supports.
 *
 * We use SLIP10 for hierarchical deterministic derivation since we
 * prefer using Curve25519 - which is incompatible with BIP32 (BIP44).
 *
 * For for information see [SLIP10 reference](https://github.com/satoshilabs/slips/blob/master/slip-0010.md)
 */
public enum Slip10Curve {
    /**
     * Curve25519 which we use for Ed25519 for EdDSA signatures.
     */
    case curve25519
    /**
     * The bitcoin curve, used by Radix Olympia and still valid
     * to support legacy accounts.
     */
    case secp256k1
}

public struct FfiConverterTypeSLIP10Curve: FfiConverterRustBuffer {
    typealias SwiftType = Slip10Curve

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Slip10Curve {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .curve25519

        case 2: return .secp256k1

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Slip10Curve, into buf: inout [UInt8]) {
        switch value {
        case .curve25519:
            writeInt(&buf, Int32(1))

        case .secp256k1:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeSLIP10Curve_lift(_ buf: RustBuffer) throws -> Slip10Curve {
    return try FfiConverterTypeSLIP10Curve.lift(buf)
}

public func FfiConverterTypeSLIP10Curve_lower(_ value: Slip10Curve) -> RustBuffer {
    return FfiConverterTypeSLIP10Curve.lower(value)
}

extension Slip10Curve: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SecureStorageKey {
    case snapshotHeadersList
    case activeProfileId
    case deviceFactorSourceMnemonic(
        factorSourceId: FactorSourceIdFromHash
    )
    case profileSnapshot(
        profileId: ProfileID
    )
}

public struct FfiConverterTypeSecureStorageKey: FfiConverterRustBuffer {
    typealias SwiftType = SecureStorageKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .snapshotHeadersList

        case 2: return .activeProfileId

        case 3: return try .deviceFactorSourceMnemonic(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )

        case 4: return try .profileSnapshot(
                profileId: FfiConverterTypeProfileID.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecureStorageKey, into buf: inout [UInt8]) {
        switch value {
        case .snapshotHeadersList:
            writeInt(&buf, Int32(1))

        case .activeProfileId:
            writeInt(&buf, Int32(2))

        case let .deviceFactorSourceMnemonic(factorSourceId):
            writeInt(&buf, Int32(3))
            FfiConverterTypeFactorSourceIDFromHash.write(factorSourceId, into: &buf)

        case let .profileSnapshot(profileId):
            writeInt(&buf, Int32(4))
            FfiConverterTypeProfileID.write(profileId, into: &buf)
        }
    }
}

public func FfiConverterTypeSecureStorageKey_lift(_ buf: RustBuffer) throws -> SecureStorageKey {
    return try FfiConverterTypeSecureStorageKey.lift(buf)
}

public func FfiConverterTypeSecureStorageKey_lower(_ value: SecureStorageKey) -> RustBuffer {
    return FfiConverterTypeSecureStorageKey.lower(value)
}

extension SecureStorageKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either a Signature on `Curve25519` or `Secp256k1`
 */
public enum Signature {
    case secp256k1(
        value: Secp256k1Signature
    )
    case ed25519(
        value: Ed25519Signature
    )
}

public struct FfiConverterTypeSignature: FfiConverterRustBuffer {
    typealias SwiftType = Signature

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Signature {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(
                value: FfiConverterTypeSecp256k1Signature.read(from: &buf)
            )

        case 2: return try .ed25519(
                value: FfiConverterTypeEd25519Signature.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Signature, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecp256k1Signature.write(value, into: &buf)

        case let .ed25519(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEd25519Signature.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeSignature_lift(_ buf: RustBuffer) throws -> Signature {
    return try FfiConverterTypeSignature.lift(buf)
}

public func FfiConverterTypeSignature_lower(_ value: Signature) -> RustBuffer {
    return FfiConverterTypeSignature.lower(value)
}

extension Signature: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Variant {
    case western
    case eastern
}

public struct FfiConverterTypeVariant: FfiConverterRustBuffer {
    typealias SwiftType = Variant

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Variant {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .western

        case 2: return .eastern

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Variant, into buf: inout [UInt8]) {
        switch value {
        case .western:
            writeInt(&buf, Int32(1))

        case .eastern:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeVariant_lift(_ buf: RustBuffer) throws -> Variant {
    return try FfiConverterTypeVariant.lift(buf)
}

public func FfiConverterTypeVariant_lower(_ value: Variant) -> RustBuffer {
    return FfiConverterTypeVariant.lower(value)
}

extension Variant: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum WalletClientModel {
    case iphone
    case android
    case unknown
}

public struct FfiConverterTypeWalletClientModel: FfiConverterRustBuffer {
    typealias SwiftType = WalletClientModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletClientModel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .iphone

        case 2: return .android

        case 3: return .unknown

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletClientModel, into buf: inout [UInt8]) {
        switch value {
        case .iphone:
            writeInt(&buf, Int32(1))

        case .android:
            writeInt(&buf, Int32(2))

        case .unknown:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeWalletClientModel_lift(_ buf: RustBuffer) throws -> WalletClientModel {
    return try FfiConverterTypeWalletClientModel.lift(buf)
}

public func FfiConverterTypeWalletClientModel_lower(_ value: WalletClientModel) -> RustBuffer {
    return FfiConverterTypeWalletClientModel.lower(value)
}

extension WalletClientModel: Equatable, Hashable {}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
    typealias SwiftType = HierarchicalDeterministicFactorInstance?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePersonaDataIdentifiedName: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataIdentifiedName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataIdentifiedName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataIdentifiedName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses: FfiConverterRustBuffer {
    typealias SwiftType = SharedToDappWithPersonaAccountAddresses?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSharedToDappWithPersonaAccountAddresses.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSharedToDappWithPersonaAccountAddresses.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries: FfiConverterRustBuffer {
    typealias SwiftType = SharedToDappWithPersonaIDsOfPersonaDataEntries?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePersonaDataEntryID: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataEntryID?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataEntryID.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataEntryID.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceInt8: FfiConverterRustBuffer {
    typealias SwiftType = [Int8]

    public static func write(_ value: [Int8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int8] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceBool: FfiConverterRustBuffer {
    typealias SwiftType = [Bool]

    public static func write(_ value: [Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterBool.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bool] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bool]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterBool.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccount: FfiConverterRustBuffer {
    typealias SwiftType = [Account]

    public static func write(_ value: [Account], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Account] {
        let len: Int32 = try readInt(&buf)
        var seq = [Account]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccount.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountAddress: FfiConverterRustBuffer {
    typealias SwiftType = [AccountAddress]

    public static func write(_ value: [AccountAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAppearanceID: FfiConverterRustBuffer {
    typealias SwiftType = [AppearanceId]

    public static func write(_ value: [AppearanceId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAppearanceID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AppearanceId] {
        let len: Int32 = try readInt(&buf)
        var seq = [AppearanceId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAppearanceID.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAssetException: FfiConverterRustBuffer {
    typealias SwiftType = [AssetException]

    public static func write(_ value: [AssetException], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAssetException.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetException] {
        let len: Int32 = try readInt(&buf)
        var seq = [AssetException]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAssetException.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAuthorizedDapp: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedDapp]

    public static func write(_ value: [AuthorizedDapp], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedDapp.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedDapp] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedDapp]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAuthorizedDapp.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAuthorizedPersonaSimple: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedPersonaSimple]

    public static func write(_ value: [AuthorizedPersonaSimple], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedPersonaSimple.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedPersonaSimple] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedPersonaSimple]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAuthorizedPersonaSimple.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeBIP39Word: FfiConverterRustBuffer {
    typealias SwiftType = [Bip39Word]

    public static func write(_ value: [Bip39Word], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBIP39Word.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip39Word] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bip39Word]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeBIP39Word.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeGateway: FfiConverterRustBuffer {
    typealias SwiftType = [Gateway]

    public static func write(_ value: [Gateway], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGateway.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Gateway] {
        let len: Int32 = try readInt(&buf)
        var seq = [Gateway]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeGateway.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHDPathComponent: FfiConverterRustBuffer {
    typealias SwiftType = [HdPathComponent]

    public static func write(_ value: [HdPathComponent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHDPathComponent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HdPathComponent] {
        let len: Int32 = try readInt(&buf)
        var seq = [HdPathComponent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeHDPathComponent.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeP2PLink: FfiConverterRustBuffer {
    typealias SwiftType = [P2pLink]

    public static func write(_ value: [P2pLink], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeP2PLink.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [P2pLink] {
        let len: Int32 = try readInt(&buf)
        var seq = [P2pLink]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeP2PLink.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersona: FfiConverterRustBuffer {
    typealias SwiftType = [Persona]

    public static func write(_ value: [Persona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Persona] {
        let len: Int32 = try readInt(&buf)
        var seq = [Persona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersona.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataIdentifiedEmailAddress]

    public static func write(_ value: [PersonaDataIdentifiedEmailAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataIdentifiedEmailAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataIdentifiedEmailAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataIdentifiedEmailAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataIdentifiedEmailAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataIdentifiedPhoneNumber]

    public static func write(_ value: [PersonaDataIdentifiedPhoneNumber], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataIdentifiedPhoneNumber.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataIdentifiedPhoneNumber] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataIdentifiedPhoneNumber]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataIdentifiedPhoneNumber.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeProfileNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [ProfileNetwork]

    public static func write(_ value: [ProfileNetwork], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProfileNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ProfileNetwork] {
        let len: Int32 = try readInt(&buf)
        var seq = [ProfileNetwork]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeProfileNetwork.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeDerivationPathScheme: FfiConverterRustBuffer {
    typealias SwiftType = [DerivationPathScheme]

    public static func write(_ value: [DerivationPathScheme], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivationPathScheme.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationPathScheme] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivationPathScheme]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeDerivationPathScheme.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeEntityFlag: FfiConverterRustBuffer {
    typealias SwiftType = [EntityFlag]

    public static func write(_ value: [EntityFlag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEntityFlag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityFlag] {
        let len: Int32 = try readInt(&buf)
        var seq = [EntityFlag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeEntityFlag.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorSource: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSource]

    public static func write(_ value: [FactorSource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSource] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorSource.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorSourceFlag: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSourceFlag]

    public static func write(_ value: [FactorSourceFlag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSourceFlag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceFlag] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSourceFlag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorSourceFlag.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceOrNonFungible]

    public static func write(_ value: [ResourceOrNonFungible], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceOrNonFungible.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceOrNonFungible] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceOrNonFungible]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceOrNonFungible.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSLIP10Curve: FfiConverterRustBuffer {
    typealias SwiftType = [Slip10Curve]

    public static func write(_ value: [Slip10Curve], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSLIP10Curve.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Slip10Curve] {
        let len: Int32 = try readInt(&buf)
        var seq = [Slip10Curve]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSLIP10Curve.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataEntryID: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryID]

    public static func write(_ value: [PersonaDataEntryID], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataEntryID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataEntryID] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataEntryID]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataEntryID.read(from: &buf))
        }
        return seq
    }
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BIP39Passphrase = String
public struct FfiConverterTypeBIP39Passphrase: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BIP39Passphrase {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: BIP39Passphrase, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BIP39Passphrase {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: BIP39Passphrase) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeBIP39Passphrase_lift(_ value: RustBuffer) throws -> BIP39Passphrase {
    return try FfiConverterTypeBIP39Passphrase.lift(value)
}

public func FfiConverterTypeBIP39Passphrase_lower(_ value: BIP39Passphrase) -> RustBuffer {
    return FfiConverterTypeBIP39Passphrase.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BagOfBytes = Data

public struct FfiConverterTypeBagOfBytes: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BagOfBytes {
        let builtinValue = try FfiConverterSequenceInt8.read(from: &buf)
        return Data(builtinValue.map { i8 in UInt8(bitPattern: i8) })
    }

    public static func write(_ value: BagOfBytes, into buf: inout [UInt8]) {
        let builtinValue = value.map { u8 in Int8(bitPattern: u8) }
        return FfiConverterSequenceInt8.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BagOfBytes {
        let builtinValue = try FfiConverterSequenceInt8.lift(value)
        return Data(builtinValue.map { i8 in UInt8(bitPattern: i8) })
    }

    public static func lower(_ value: BagOfBytes) -> RustBuffer {
        let builtinValue = value.map { u8 in Int8(bitPattern: u8) }
        return FfiConverterSequenceInt8.lower(builtinValue)
    }
}

public func FfiConverterTypeBagOfBytes_lift(_ value: RustBuffer) throws -> BagOfBytes {
    return try FfiConverterTypeBagOfBytes.lift(value)
}

public func FfiConverterTypeBagOfBytes_lower(_ value: BagOfBytes) -> RustBuffer {
    return FfiConverterTypeBagOfBytes.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Epoch = UInt64
public struct FfiConverterTypeEpoch: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Epoch {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: Epoch, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> Epoch {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: Epoch) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}

public func FfiConverterTypeEpoch_lift(_ value: UInt64) throws -> Epoch {
    return try FfiConverterTypeEpoch.lift(value)
}

public func FfiConverterTypeEpoch_lower(_ value: Epoch) -> UInt64 {
    return FfiConverterTypeEpoch.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias InnerAccessControllerAddress = String
public struct FfiConverterTypeInnerAccessControllerAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InnerAccessControllerAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: InnerAccessControllerAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> InnerAccessControllerAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: InnerAccessControllerAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeInnerAccessControllerAddress_lift(_ value: RustBuffer) throws -> InnerAccessControllerAddress {
    return try FfiConverterTypeInnerAccessControllerAddress.lift(value)
}

public func FfiConverterTypeInnerAccessControllerAddress_lower(_ value: InnerAccessControllerAddress) -> RustBuffer {
    return FfiConverterTypeInnerAccessControllerAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias InnerAccountAddress = String
public struct FfiConverterTypeInnerAccountAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InnerAccountAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: InnerAccountAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> InnerAccountAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: InnerAccountAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeInnerAccountAddress_lift(_ value: RustBuffer) throws -> InnerAccountAddress {
    return try FfiConverterTypeInnerAccountAddress.lift(value)
}

public func FfiConverterTypeInnerAccountAddress_lower(_ value: InnerAccountAddress) -> RustBuffer {
    return FfiConverterTypeInnerAccountAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias InnerComponentAddress = String
public struct FfiConverterTypeInnerComponentAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InnerComponentAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: InnerComponentAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> InnerComponentAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: InnerComponentAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeInnerComponentAddress_lift(_ value: RustBuffer) throws -> InnerComponentAddress {
    return try FfiConverterTypeInnerComponentAddress.lift(value)
}

public func FfiConverterTypeInnerComponentAddress_lower(_ value: InnerComponentAddress) -> RustBuffer {
    return FfiConverterTypeInnerComponentAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias InnerDecimal = String
public struct FfiConverterTypeInnerDecimal: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InnerDecimal {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: InnerDecimal, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> InnerDecimal {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: InnerDecimal) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeInnerDecimal_lift(_ value: RustBuffer) throws -> InnerDecimal {
    return try FfiConverterTypeInnerDecimal.lift(value)
}

public func FfiConverterTypeInnerDecimal_lower(_ value: InnerDecimal) -> RustBuffer {
    return FfiConverterTypeInnerDecimal.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias InnerIdentityAddress = String
public struct FfiConverterTypeInnerIdentityAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InnerIdentityAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: InnerIdentityAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> InnerIdentityAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: InnerIdentityAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeInnerIdentityAddress_lift(_ value: RustBuffer) throws -> InnerIdentityAddress {
    return try FfiConverterTypeInnerIdentityAddress.lift(value)
}

public func FfiConverterTypeInnerIdentityAddress_lower(_ value: InnerIdentityAddress) -> RustBuffer {
    return FfiConverterTypeInnerIdentityAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias InnerPackageAddress = String
public struct FfiConverterTypeInnerPackageAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InnerPackageAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: InnerPackageAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> InnerPackageAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: InnerPackageAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeInnerPackageAddress_lift(_ value: RustBuffer) throws -> InnerPackageAddress {
    return try FfiConverterTypeInnerPackageAddress.lift(value)
}

public func FfiConverterTypeInnerPackageAddress_lower(_ value: InnerPackageAddress) -> RustBuffer {
    return FfiConverterTypeInnerPackageAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias InnerPoolAddress = String
public struct FfiConverterTypeInnerPoolAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InnerPoolAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: InnerPoolAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> InnerPoolAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: InnerPoolAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeInnerPoolAddress_lift(_ value: RustBuffer) throws -> InnerPoolAddress {
    return try FfiConverterTypeInnerPoolAddress.lift(value)
}

public func FfiConverterTypeInnerPoolAddress_lower(_ value: InnerPoolAddress) -> RustBuffer {
    return FfiConverterTypeInnerPoolAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias InnerResourceAddress = String
public struct FfiConverterTypeInnerResourceAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InnerResourceAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: InnerResourceAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> InnerResourceAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: InnerResourceAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeInnerResourceAddress_lift(_ value: RustBuffer) throws -> InnerResourceAddress {
    return try FfiConverterTypeInnerResourceAddress.lift(value)
}

public func FfiConverterTypeInnerResourceAddress_lower(_ value: InnerResourceAddress) -> RustBuffer {
    return FfiConverterTypeInnerResourceAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias InnerValidatorAddress = String
public struct FfiConverterTypeInnerValidatorAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InnerValidatorAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: InnerValidatorAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> InnerValidatorAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: InnerValidatorAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeInnerValidatorAddress_lift(_ value: RustBuffer) throws -> InnerValidatorAddress {
    return try FfiConverterTypeInnerValidatorAddress.lift(value)
}

public func FfiConverterTypeInnerValidatorAddress_lower(_ value: InnerValidatorAddress) -> RustBuffer {
    return FfiConverterTypeInnerValidatorAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias InnerVaultAddress = String
public struct FfiConverterTypeInnerVaultAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InnerVaultAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: InnerVaultAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> InnerVaultAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: InnerVaultAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeInnerVaultAddress_lift(_ value: RustBuffer) throws -> InnerVaultAddress {
    return try FfiConverterTypeInnerVaultAddress.lift(value)
}

public func FfiConverterTypeInnerVaultAddress_lower(_ value: InnerVaultAddress) -> RustBuffer {
    return FfiConverterTypeInnerVaultAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Nonce = UInt32
public struct FfiConverterTypeNonce: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nonce {
        return try FfiConverterUInt32.read(from: &buf)
    }

    public static func write(_ value: Nonce, into buf: inout [UInt8]) {
        return FfiConverterUInt32.write(value, into: &buf)
    }

    public static func lift(_ value: UInt32) throws -> Nonce {
        return try FfiConverterUInt32.lift(value)
    }

    public static func lower(_ value: Nonce) -> UInt32 {
        return FfiConverterUInt32.lower(value)
    }
}

public func FfiConverterTypeNonce_lift(_ value: UInt32) throws -> Nonce {
    return try FfiConverterTypeNonce.lift(value)
}

public func FfiConverterTypeNonce_lower(_ value: Nonce) -> UInt32 {
    return FfiConverterTypeNonce.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PersonaDataEntryID = Uuid
public struct FfiConverterTypePersonaDataEntryID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryID {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: PersonaDataEntryID, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PersonaDataEntryID {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: PersonaDataEntryID) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypePersonaDataEntryID_lift(_ value: RustBuffer) throws -> PersonaDataEntryID {
    return try FfiConverterTypePersonaDataEntryID.lift(value)
}

public func FfiConverterTypePersonaDataEntryID_lower(_ value: PersonaDataEntryID) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ProfileID = Uuid
public struct FfiConverterTypeProfileID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileID {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: ProfileID, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ProfileID {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: ProfileID) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypeProfileID_lift(_ value: RustBuffer) throws -> ProfileID {
    return try FfiConverterTypeProfileID.lift(value)
}

public func FfiConverterTypeProfileID_lower(_ value: ProfileID) -> RustBuffer {
    return FfiConverterTypeProfileID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ScryptoEd25519PublicKey = BagOfBytes
public struct FfiConverterTypeScryptoEd25519PublicKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScryptoEd25519PublicKey {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: ScryptoEd25519PublicKey, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ScryptoEd25519PublicKey {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: ScryptoEd25519PublicKey) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeScryptoEd25519PublicKey_lift(_ value: RustBuffer) throws -> ScryptoEd25519PublicKey {
    return try FfiConverterTypeScryptoEd25519PublicKey.lift(value)
}

public func FfiConverterTypeScryptoEd25519PublicKey_lower(_ value: ScryptoEd25519PublicKey) -> RustBuffer {
    return FfiConverterTypeScryptoEd25519PublicKey.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ScryptoSecp256k1PublicKey = BagOfBytes
public struct FfiConverterTypeScryptoSecp256k1PublicKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScryptoSecp256k1PublicKey {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: ScryptoSecp256k1PublicKey, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ScryptoSecp256k1PublicKey {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: ScryptoSecp256k1PublicKey) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeScryptoSecp256k1PublicKey_lift(_ value: RustBuffer) throws -> ScryptoSecp256k1PublicKey {
    return try FfiConverterTypeScryptoSecp256k1PublicKey.lift(value)
}

public func FfiConverterTypeScryptoSecp256k1PublicKey_lower(_ value: ScryptoSecp256k1PublicKey) -> RustBuffer {
    return FfiConverterTypeScryptoSecp256k1PublicKey.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Timestamp = Date

public struct FfiConverterTypeTimestamp: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timestamp {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return { let df = DateFormatter(); df.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ"; return df.date(from: builtinValue)! }()
    }

    public static func write(_ value: Timestamp, into buf: inout [UInt8]) {
        let builtinValue = { let df = DateFormatter(); df.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ"; return df.string(from: value) }()
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Timestamp {
        let builtinValue = try FfiConverterString.lift(value)
        return { let df = DateFormatter(); df.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ"; return df.date(from: builtinValue)! }()
    }

    public static func lower(_ value: Timestamp) -> RustBuffer {
        let builtinValue = { let df = DateFormatter(); df.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ"; return df.string(from: value) }()
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeTimestamp_lift(_ value: RustBuffer) throws -> Timestamp {
    return try FfiConverterTypeTimestamp.lift(value)
}

public func FfiConverterTypeTimestamp_lower(_ value: Timestamp) -> RustBuffer {
    return FfiConverterTypeTimestamp.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Url = URL

public struct FfiConverterTypeUrl: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Url {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return URL(string: builtinValue)!
    }

    public static func write(_ value: Url, into buf: inout [UInt8]) {
        let builtinValue = String(describing: value)
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Url {
        let builtinValue = try FfiConverterString.lift(value)
        return URL(string: builtinValue)!
    }

    public static func lower(_ value: Url) -> RustBuffer {
        let builtinValue = String(describing: value)
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeUrl_lift(_ value: RustBuffer) throws -> Url {
    return try FfiConverterTypeUrl.lift(value)
}

public func FfiConverterTypeUrl_lower(_ value: Url) -> RustBuffer {
    return FfiConverterTypeUrl.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Uuid = UUID

public struct FfiConverterTypeUuid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return UUID(uuidString: builtinValue)!
    }

    public static func write(_ value: Uuid, into buf: inout [UInt8]) {
        let builtinValue = value.uuidString
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Uuid {
        let builtinValue = try FfiConverterString.lift(value)
        return UUID(uuidString: builtinValue)!
    }

    public static func lower(_ value: Uuid) -> RustBuffer {
        let builtinValue = value.uuidString
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeUuid_lift(_ value: RustBuffer) throws -> Uuid {
    return try FfiConverterTypeUuid.lift(value)
}

public func FfiConverterTypeUuid_lower(_ value: Uuid) -> RustBuffer {
    return FfiConverterTypeUuid.lower(value)
}

public func accesscontrollerAddressBech32Address(address: AccessControllerAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_accesscontroller_address_bech32_address(
                FfiConverterTypeAccessControllerAddress.lower(address), $0
            )
        }
    )
}

public func accesscontrollerAddressNetworkId(address: AccessControllerAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(
        try! rustCall {
            uniffi_sargon_fn_func_accesscontroller_address_network_id(
                FfiConverterTypeAccessControllerAddress.lower(address), $0
            )
        }
    )
}

public func accountAddressBech32Address(address: AccountAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_account_address_bech32_address(
                FfiConverterTypeAccountAddress.lower(address), $0
            )
        }
    )
}

public func accountAddressIsLegacy(address: AccountAddress) -> Bool {
    return try! FfiConverterBool.lift(
        try! rustCall {
            uniffi_sargon_fn_func_account_address_is_legacy(
                FfiConverterTypeAccountAddress.lower(address), $0
            )
        }
    )
}

public func accountAddressNetworkId(address: AccountAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(
        try! rustCall {
            uniffi_sargon_fn_func_account_address_network_id(
                FfiConverterTypeAccountAddress.lower(address), $0
            )
        }
    )
}

/**
 * Formats the AccountAddress to its abbreviated form which is what the user
 * is most used to, since it is what we most commonly display in the Radix
 * ecosystem.
 *
 * The abbreviated form returns:
 *
 * `acco...please`
 *
 * For the account address:
 *
 * `account_rdx16xlfcpp0vf7e3gqnswv8j9k58n6rjccu58vvspmdva22kf3aplease`

 */
public func accountAddressToShort(address: AccountAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_account_address_to_short(
                FfiConverterTypeAccountAddress.lower(address), $0
            )
        }
    )
}

public func appearanceIdsAll() -> [AppearanceId] {
    return try! FfiConverterSequenceTypeAppearanceID.lift(
        try! rustCall {
            uniffi_sargon_fn_func_appearance_ids_all($0)
        }
    )
}

public func bagOfBytesAppendCafe(to: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(
        try! rustCall {
            uniffi_sargon_fn_func_bag_of_bytes_append_cafe(
                FfiConverterTypeBagOfBytes.lower(to), $0
            )
        }
    )
}

public func bagOfBytesAppendDeadbeef(to: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(
        try! rustCall {
            uniffi_sargon_fn_func_bag_of_bytes_append_deadbeef(
                FfiConverterTypeBagOfBytes.lower(to), $0
            )
        }
    )
}

public func bagOfBytesPrependCafe(inFrontOf: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(
        try! rustCall {
            uniffi_sargon_fn_func_bag_of_bytes_prepend_cafe(
                FfiConverterTypeBagOfBytes.lower(inFrontOf), $0
            )
        }
    )
}

public func bagOfBytesPrependDeadbeef(inFrontOf: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(
        try! rustCall {
            uniffi_sargon_fn_func_bag_of_bytes_prepend_deadbeef(
                FfiConverterTypeBagOfBytes.lower(inFrontOf), $0
            )
        }
    )
}

public func componentAddressBech32Address(address: ComponentAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_component_address_bech32_address(
                FfiConverterTypeComponentAddress.lower(address), $0
            )
        }
    )
}

public func componentAddressNetworkId(address: ComponentAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(
        try! rustCall {
            uniffi_sargon_fn_func_component_address_network_id(
                FfiConverterTypeComponentAddress.lower(address), $0
            )
        }
    )
}

/**
 * Returns `decimal.abs()`, panics if `decimal` is `Decimal192::MIN`
 */
public func decimalAbs(decimal: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_abs(
                FfiConverterTypeDecimal192.lower(decimal), $0
            )
        }
    )
}

/**
 * `lhs + rhs``
 */
public func decimalAdd(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_add(
                FfiConverterTypeDecimal192.lower(lhs),
                FfiConverterTypeDecimal192.lower(rhs), $0
            )
        }
    )
}

/**
 * Clamps `decimal` to zero, i.e. `max(decimal, 0)`
 */
public func decimalClampedToZero(decimal: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_clamped_to_zero(
                FfiConverterTypeDecimal192.lower(decimal), $0
            )
        }
    )
}

/**
 * `lhs / rhs``
 */
public func decimalDiv(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_div(
                FfiConverterTypeDecimal192.lower(lhs),
                FfiConverterTypeDecimal192.lower(rhs), $0
            )
        }
    )
}

/**
 * `lhs > rhs`
 */
public func decimalGreaterThan(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_greater_than(
                FfiConverterTypeDecimal192.lower(lhs),
                FfiConverterTypeDecimal192.lower(rhs), $0
            )
        }
    )
}

/**
 * `lhs >= rhs`
 */
public func decimalGreaterThanOrEqual(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_greater_than_or_equal(
                FfiConverterTypeDecimal192.lower(lhs),
                FfiConverterTypeDecimal192.lower(rhs), $0
            )
        }
    )
}

/**
 * Whether this decimal is negative.
 */
public func decimalIsNegative(decimal: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_is_negative(
                FfiConverterTypeDecimal192.lower(decimal), $0
            )
        }
    )
}

/**
 * Whether this decimal is positive.
 */
public func decimalIsPositive(decimal: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_is_positive(
                FfiConverterTypeDecimal192.lower(decimal), $0
            )
        }
    )
}

/**
 * Whether this decimal is zero.
 */
public func decimalIsZero(decimal: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_is_zero(
                FfiConverterTypeDecimal192.lower(decimal), $0
            )
        }
    )
}

/**
 * `lhs < rhs`
 */
public func decimalLessThan(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_less_than(
                FfiConverterTypeDecimal192.lower(lhs),
                FfiConverterTypeDecimal192.lower(rhs), $0
            )
        }
    )
}

/**
 * `lhs <= rhs`
 */
public func decimalLessThanOrEqual(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_less_than_or_equal(
                FfiConverterTypeDecimal192.lower(lhs),
                FfiConverterTypeDecimal192.lower(rhs), $0
            )
        }
    )
}

/**
 * The maximum possible value of `Decimal192`, being:
 * `3138550867693340381917894711603833208051.177722232017256447`
 */
public func decimalMax() -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_max($0)
        }
    )
}

/**
 * The minimum possible value of `Decimal192`, being:
 * `-3138550867693340381917894711603833208051.177722232017256448`
 */
public func decimalMin() -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_min($0)
        }
    )
}

/**
 * `lhs * rhs``
 */
public func decimalMul(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_mul(
                FfiConverterTypeDecimal192.lower(lhs),
                FfiConverterTypeDecimal192.lower(rhs), $0
            )
        }
    )
}

/**
 * Negates the `decimal`
 */
public func decimalNeg(decimal: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_neg(
                FfiConverterTypeDecimal192.lower(decimal), $0
            )
        }
    )
}

/**
 * Rounds this number to the specified decimal places.
 *
 * # Panics
 * - Panic if the number of decimal places is not within [0..SCALE(=18)]
 */
public func decimalRound(decimal: Decimal192, decimalPlaces: Int32, roundingMode: RoundingMode) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_decimal_round(
                FfiConverterTypeDecimal192.lower(decimal),
                FfiConverterInt32.lower(decimalPlaces),
                FfiConverterTypeRoundingMode.lower(roundingMode), $0
            )
        }
    )
}

/**
 * `lhs - rhs``
 */
public func decimalSub(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_sub(
                FfiConverterTypeDecimal192.lower(lhs),
                FfiConverterTypeDecimal192.lower(rhs), $0
            )
        }
    )
}

/**
 * `decimal.to_string()`
 */
public func decimalToString(decimal: Decimal192) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_decimal_to_string(
                FfiConverterTypeDecimal192.lower(decimal), $0
            )
        }
    )
}

public func ed25519PublicKeyToBytes(publicKey: Ed25519PublicKey) -> Data {
    return try! FfiConverterData.lift(
        try! rustCall {
            uniffi_sargon_fn_func_ed25519_public_key_to_bytes(
                FfiConverterTypeEd25519PublicKey.lower(publicKey), $0
            )
        }
    )
}

/**
 * Encodes the `Ed25519PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"b7a3c12dc0c8c748ab07525b701122b88bd78f600c76342d27f25e5f92444cde"`
 */
public func ed25519PublicKeyToHex(publicKey: Ed25519PublicKey) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_ed25519_public_key_to_hex(
                FfiConverterTypeEd25519PublicKey.lower(publicKey), $0
            )
        }
    )
}

public func gatewayMainnet() -> Gateway {
    return try! FfiConverterTypeGateway.lift(
        try! rustCall {
            uniffi_sargon_fn_func_gateway_mainnet($0)
        }
    )
}

public func gatewayStokenet() -> Gateway {
    return try! FfiConverterTypeGateway.lift(
        try! rustCall {
            uniffi_sargon_fn_func_gateway_stokenet($0)
        }
    )
}

public func identityAddressBech32Address(address: IdentityAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_identity_address_bech32_address(
                FfiConverterTypeIdentityAddress.lower(address), $0
            )
        }
    )
}

public func identityAddressNetworkId(address: IdentityAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(
        try! rustCall {
            uniffi_sargon_fn_func_identity_address_network_id(
                FfiConverterTypeIdentityAddress.lower(address), $0
            )
        }
    )
}

/**
 * Returns the words of a mnemonic as a String joined by spaces, e.g. "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong"
 */
public func mnemonicPhrase(from: Mnemonic) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_mnemonic_phrase(
                FfiConverterTypeMnemonic.lower(from), $0
            )
        }
    )
}

public func newAccesscontrollerAddress(bech32: String) throws -> AccessControllerAddress {
    return try FfiConverterTypeAccessControllerAddress.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_accesscontroller_address(
                FfiConverterString.lower(bech32), $0
            )
        }
    )
}

public func newAccountAddress(bech32: String) throws -> AccountAddress {
    return try FfiConverterTypeAccountAddress.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_account_address(
                FfiConverterString.lower(bech32), $0
            )
        }
    )
}

public func newAccountAddressFrom(publicKey: PublicKey, networkId: NetworkId) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_account_address_from(
                FfiConverterTypePublicKey.lower(publicKey),
                FfiConverterTypeNetworkID.lower(networkId), $0
            )
        }
    )
}

public func newAppPreferencesPlaceholder() -> AppPreferences {
    return try! FfiConverterTypeAppPreferences.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_app_preferences_placeholder($0)
        }
    )
}

public func newAppPreferencesPlaceholderOther() -> AppPreferences {
    return try! FfiConverterTypeAppPreferences.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_app_preferences_placeholder_other($0)
        }
    )
}

public func newAppearanceId(validating: UInt8) throws -> AppearanceId {
    return try FfiConverterTypeAppearanceID.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_appearance_id(
                FfiConverterUInt8.lower(validating), $0
            )
        }
    )
}

public func newAppearanceIdPlaceholder() -> AppearanceId {
    return try! FfiConverterTypeAppearanceID.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_appearance_id_placeholder($0)
        }
    )
}

public func newAppearanceIdPlaceholderOther() -> AppearanceId {
    return try! FfiConverterTypeAppearanceID.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_appearance_id_placeholder_other($0)
        }
    )
}

public func newBagOfBytesFrom(bytes: Data) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_bag_of_bytes_from(
                FfiConverterData.lower(bytes), $0
            )
        }
    )
}

public func newBagOfBytesPlaceholderAced() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_bag_of_bytes_placeholder_aced($0)
        }
    )
}

public func newBagOfBytesPlaceholderBabe() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_bag_of_bytes_placeholder_babe($0)
        }
    )
}

public func newBagOfBytesPlaceholderCafe() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_bag_of_bytes_placeholder_cafe($0)
        }
    )
}

public func newBagOfBytesPlaceholderDead() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_bag_of_bytes_placeholder_dead($0)
        }
    )
}

public func newBagOfBytesPlaceholderEcad() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_bag_of_bytes_placeholder_ecad($0)
        }
    )
}

public func newBagOfBytesPlaceholderFade() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_bag_of_bytes_placeholder_fade($0)
        }
    )
}

public func newComponentAddress(bech32: String) throws -> ComponentAddress {
    return try FfiConverterTypeComponentAddress.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_component_address(
                FfiConverterString.lower(bech32), $0
            )
        }
    )
}

/**
 * Creates the Decimal192 `10^exponent`
 */
public func newDecimalExponent(exponent: UInt8) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_decimal_exponent(
                FfiConverterUInt8.lower(exponent), $0
            )
        }
    )
}

/**
 * Creates a new `Decimal192` from a f32 float, it does
 * so by first converting the float to a String, using
 * Rust's `to_string` on the float.
 */
public func newDecimalFromF32(value: Float) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_decimal_from_f32(
                FfiConverterFloat.lower(value), $0
            )
        }
    )
}

/**
 * Tries to creates a new `Decimal192` from a formatted String for
 * a specific locale.
 */
public func newDecimalFromFormattedString(formattedString: String, locale: LocaleConfig) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_decimal_from_formatted_string(
                FfiConverterString.lower(formattedString),
                FfiConverterTypeLocaleConfig.lower(locale), $0
            )
        }
    )
}

/**
 * Creates a new `Decimal192` from a i32 integer.
 */
public func newDecimalFromI32(value: Int32) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_decimal_from_i32(
                FfiConverterInt32.lower(value), $0
            )
        }
    )
}

/**
 * Creates a new `Decimal192` from a i64 integer.
 */
public func newDecimalFromI64(value: Int64) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_decimal_from_i64(
                FfiConverterInt64.lower(value), $0
            )
        }
    )
}

/**
 * Tries to creates a new `Decimal192` from a String, throws a `CommonError`
 * if the `string` was not a valid Decimal192.
 */
public func newDecimalFromString(string: String) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_decimal_from_string(
                FfiConverterString.lower(string), $0
            )
        }
    )
}

/**
 * Creates a new `Decimal192` from a u32 integer.
 */
public func newDecimalFromU32(value: UInt32) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_decimal_from_u32(
                FfiConverterUInt32.lower(value), $0
            )
        }
    )
}

/**
 * Creates a new `Decimal192` from a u64 integer.
 */
public func newDecimalFromU64(value: UInt64) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_decimal_from_u64(
                FfiConverterUInt64.lower(value), $0
            )
        }
    )
}

public func newDisplayName(name: String) throws -> DisplayName {
    return try FfiConverterTypeDisplayName.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_display_name(
                FfiConverterString.lower(name), $0
            )
        }
    )
}

public func newEd25519PublicKeyFromBytes(bytes: Data) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_ed25519_public_key_from_bytes(
                FfiConverterData.lower(bytes), $0
            )
        }
    )
}

public func newEd25519PublicKeyFromHex(hex: String) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_ed25519_public_key_from_hex(
                FfiConverterString.lower(hex), $0
            )
        }
    )
}

public func newEd25519PublicKeyPlaceholder() -> Ed25519PublicKey {
    return try! FfiConverterTypeEd25519PublicKey.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_ed25519_public_key_placeholder($0)
        }
    )
}

public func newEd25519PublicKeyPlaceholderOther() -> Ed25519PublicKey {
    return try! FfiConverterTypeEd25519PublicKey.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_ed25519_public_key_placeholder_other($0)
        }
    )
}

public func newFactorSourcesPlaceholder() -> [FactorSource] {
    return try! FfiConverterSequenceTypeFactorSource.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_factor_sources_placeholder($0)
        }
    )
}

public func newFactorSourcesPlaceholderOther() -> [FactorSource] {
    return try! FfiConverterSequenceTypeFactorSource.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_factor_sources_placeholder_other($0)
        }
    )
}

/**
 * Constructs `Gateways` with `current` set as active Gateway.
 */
public func newGateways(current: Gateway) -> Gateways {
    return try! FfiConverterTypeGateways.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_gateways(
                FfiConverterTypeGateway.lower(current), $0
            )
        }
    )
}

/**
 * A placeholder value useful for tests and previews.
 */
public func newGatewaysPlaceholder() -> Gateways {
    return try! FfiConverterTypeGateways.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_gateways_placeholder($0)
        }
    )
}

/**
 * A placeholder value useful for tests and previews.
 */
public func newGatewaysPlaceholderOther() -> Gateways {
    return try! FfiConverterTypeGateways.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_gateways_placeholder_other($0)
        }
    )
}

public func newHeaderPlaceholder() -> Header {
    return try! FfiConverterTypeHeader.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_header_placeholder($0)
        }
    )
}

public func newHeaderPlaceholderOther() -> Header {
    return try! FfiConverterTypeHeader.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_header_placeholder_other($0)
        }
    )
}

public func newHex32BytesFrom(bytes: Data) throws -> Hex32Bytes {
    return try FfiConverterTypeHex32Bytes.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_hex32_bytes_from(
                FfiConverterData.lower(bytes), $0
            )
        }
    )
}

public func newHex32BytesFromBag(bagOfBytes: BagOfBytes) throws -> Hex32Bytes {
    return try FfiConverterTypeHex32Bytes.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_hex32_bytes_from_bag(
                FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
            )
        }
    )
}

public func newHex33BytesFrom(bytes: Data) throws -> Hex33Bytes {
    return try FfiConverterTypeHex33Bytes.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_hex33_bytes_from(
                FfiConverterData.lower(bytes), $0
            )
        }
    )
}

public func newHex33BytesFromBag(bagOfBytes: BagOfBytes) throws -> Hex33Bytes {
    return try FfiConverterTypeHex33Bytes.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_hex33_bytes_from_bag(
                FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
            )
        }
    )
}

public func newHex64BytesFrom(bytes: Data) throws -> Hex64Bytes {
    return try FfiConverterTypeHex64Bytes.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_hex64_bytes_from(
                FfiConverterData.lower(bytes), $0
            )
        }
    )
}

public func newHex64BytesFromBag(bagOfBytes: BagOfBytes) throws -> Hex64Bytes {
    return try FfiConverterTypeHex64Bytes.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_hex64_bytes_from_bag(
                FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
            )
        }
    )
}

public func newHex65BytesFrom(bytes: Data) throws -> Hex65Bytes {
    return try FfiConverterTypeHex65Bytes.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_hex65_bytes_from(
                FfiConverterData.lower(bytes), $0
            )
        }
    )
}

public func newHex65BytesFromBag(bagOfBytes: BagOfBytes) throws -> Hex65Bytes {
    return try FfiConverterTypeHex65Bytes.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_hex65_bytes_from_bag(
                FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
            )
        }
    )
}

public func newIdentityAddress(bech32: String) throws -> IdentityAddress {
    return try FfiConverterTypeIdentityAddress.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_identity_address(
                FfiConverterString.lower(bech32), $0
            )
        }
    )
}

public func newIdentityAddressFrom(publicKey: PublicKey, networkId: NetworkId) -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_identity_address_from(
                FfiConverterTypePublicKey.lower(publicKey),
                FfiConverterTypeNetworkID.lower(networkId), $0
            )
        }
    )
}

public func newPackageAddress(bech32: String) throws -> PackageAddress {
    return try FfiConverterTypePackageAddress.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_package_address(
                FfiConverterString.lower(bech32), $0
            )
        }
    )
}

public func newPoolAddress(bech32: String) throws -> PoolAddress {
    return try FfiConverterTypePoolAddress.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_pool_address(
                FfiConverterString.lower(bech32), $0
            )
        }
    )
}

public func newPrivateHdFactorSource(entropy: Data, walletClientModel: WalletClientModel) throws -> PrivateHierarchicalDeterministicFactorSource {
    return try FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_private_hd_factor_source(
                FfiConverterData.lower(entropy),
                FfiConverterTypeWalletClientModel.lower(walletClientModel), $0
            )
        }
    )
}

public func newProfile(privateHdFactorSource: PrivateHierarchicalDeterministicFactorSource, creatingDeviceName: String) -> Profile {
    return try! FfiConverterTypeProfile.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_profile(
                FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lower(privateHdFactorSource),
                FfiConverterString.lower(creatingDeviceName), $0
            )
        }
    )
}

public func newProfilePlaceholder() -> Profile {
    return try! FfiConverterTypeProfile.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_profile_placeholder($0)
        }
    )
}

public func newProfilePlaceholderOther() -> Profile {
    return try! FfiConverterTypeProfile.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_profile_placeholder_other($0)
        }
    )
}

public func newRadixConnectPassword(bytes: Hex32Bytes) -> RadixConnectPassword {
    return try! FfiConverterTypeRadixConnectPassword.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_radix_connect_password(
                FfiConverterTypeHex32Bytes.lower(bytes), $0
            )
        }
    )
}

public func newRadixConnectPasswordPlaceholder() -> RadixConnectPassword {
    return try! FfiConverterTypeRadixConnectPassword.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_radix_connect_password_placeholder($0)
        }
    )
}

public func newRadixConnectPasswordPlaceholderOther() -> RadixConnectPassword {
    return try! FfiConverterTypeRadixConnectPassword.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_radix_connect_password_placeholder_other($0)
        }
    )
}

public func newResourceAddress(bech32: String) throws -> ResourceAddress {
    return try FfiConverterTypeResourceAddress.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_resource_address(
                FfiConverterString.lower(bech32), $0
            )
        }
    )
}

public func newSecp256k1PublicKeyFromBytes(bytes: Data) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_secp256k1_public_key_from_bytes(
                FfiConverterData.lower(bytes), $0
            )
        }
    )
}

public func newSecp256k1PublicKeyFromHex(hex: String) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_secp256k1_public_key_from_hex(
                FfiConverterString.lower(hex), $0
            )
        }
    )
}

public func newSecp256k1PublicKeyPlaceholder() -> Secp256k1PublicKey {
    return try! FfiConverterTypeSecp256k1PublicKey.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_secp256k1_public_key_placeholder($0)
        }
    )
}

public func newSecp256k1PublicKeyPlaceholderOther() -> Secp256k1PublicKey {
    return try! FfiConverterTypeSecp256k1PublicKey.lift(
        try! rustCall {
            uniffi_sargon_fn_func_new_secp256k1_public_key_placeholder_other($0)
        }
    )
}

public func newValidatorAddress(bech32: String) throws -> ValidatorAddress {
    return try FfiConverterTypeValidatorAddress.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_validator_address(
                FfiConverterString.lower(bech32), $0
            )
        }
    )
}

public func newVaultAddress(bech32: String) throws -> VaultAddress {
    return try FfiConverterTypeVaultAddress.lift(
        rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_func_new_vault_address(
                FfiConverterString.lower(bech32), $0
            )
        }
    )
}

public func nonFungibleLocalIdToString(id: NonFungibleLocalId) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_non_fungible_local_id_to_string(
                FfiConverterTypeNonFungibleLocalId.lower(id), $0
            )
        }
    )
}

public func packageAddressBech32Address(address: PackageAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_package_address_bech32_address(
                FfiConverterTypePackageAddress.lower(address), $0
            )
        }
    )
}

public func packageAddressNetworkId(address: PackageAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(
        try! rustCall {
            uniffi_sargon_fn_func_package_address_network_id(
                FfiConverterTypePackageAddress.lower(address), $0
            )
        }
    )
}

public func poolAddressBech32Address(address: PoolAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_pool_address_bech32_address(
                FfiConverterTypePoolAddress.lower(address), $0
            )
        }
    )
}

public func poolAddressNetworkId(address: PoolAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(
        try! rustCall {
            uniffi_sargon_fn_func_pool_address_network_id(
                FfiConverterTypePoolAddress.lower(address), $0
            )
        }
    )
}

public func resourceAddressBech32Address(address: ResourceAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_resource_address_bech32_address(
                FfiConverterTypeResourceAddress.lower(address), $0
            )
        }
    )
}

public func resourceAddressIsFungible(address: ResourceAddress) -> Bool {
    return try! FfiConverterBool.lift(
        try! rustCall {
            uniffi_sargon_fn_func_resource_address_is_fungible(
                FfiConverterTypeResourceAddress.lower(address), $0
            )
        }
    )
}

public func resourceAddressIsNonFungible(address: ResourceAddress) -> Bool {
    return try! FfiConverterBool.lift(
        try! rustCall {
            uniffi_sargon_fn_func_resource_address_is_non_fungible(
                FfiConverterTypeResourceAddress.lower(address), $0
            )
        }
    )
}

public func resourceAddressNetworkId(address: ResourceAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(
        try! rustCall {
            uniffi_sargon_fn_func_resource_address_network_id(
                FfiConverterTypeResourceAddress.lower(address), $0
            )
        }
    )
}

public func secp256k1PublicKeyToBytes(publicKey: Secp256k1PublicKey) -> Data {
    return try! FfiConverterData.lift(
        try! rustCall {
            uniffi_sargon_fn_func_secp256k1_public_key_to_bytes(
                FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
            )
        }
    )
}

/**
 * Encodes the compressed form (33 bytes) of a `Secp256k1PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"033083620d1596d3f8988ff3270e42970dd2a031e2b9b6488052a4170ff999f3e8"`
 */
public func secp256k1PublicKeyToHex(publicKey: Secp256k1PublicKey) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_secp256k1_public_key_to_hex(
                FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
            )
        }
    )
}

public func secureStorageKeyIdentifier(key: SecureStorageKey) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_secure_storage_key_identifier(
                FfiConverterTypeSecureStorageKey.lower(key), $0
            )
        }
    )
}

public func validatorAddressBech32Address(address: ValidatorAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_validator_address_bech32_address(
                FfiConverterTypeValidatorAddress.lower(address), $0
            )
        }
    )
}

public func validatorAddressNetworkId(address: ValidatorAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(
        try! rustCall {
            uniffi_sargon_fn_func_validator_address_network_id(
                FfiConverterTypeValidatorAddress.lower(address), $0
            )
        }
    )
}

public func vaultAddressBech32Address(address: VaultAddress) -> String {
    return try! FfiConverterString.lift(
        try! rustCall {
            uniffi_sargon_fn_func_vault_address_bech32_address(
                FfiConverterTypeVaultAddress.lower(address), $0
            )
        }
    )
}

public func vaultAddressIsFungible(address: VaultAddress) -> Bool {
    return try! FfiConverterBool.lift(
        try! rustCall {
            uniffi_sargon_fn_func_vault_address_is_fungible(
                FfiConverterTypeVaultAddress.lower(address), $0
            )
        }
    )
}

public func vaultAddressIsNonFungible(address: VaultAddress) -> Bool {
    return try! FfiConverterBool.lift(
        try! rustCall {
            uniffi_sargon_fn_func_vault_address_is_non_fungible(
                FfiConverterTypeVaultAddress.lower(address), $0
            )
        }
    )
}

public func vaultAddressNetworkId(address: VaultAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(
        try! rustCall {
            uniffi_sargon_fn_func_vault_address_network_id(
                FfiConverterTypeVaultAddress.lower(address), $0
            )
        }
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_sargon_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_sargon_checksum_func_accesscontroller_address_bech32_address() != 63850 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_accesscontroller_address_network_id() != 59691 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_bech32_address() != 1871 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_is_legacy() != 34575 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_network_id() != 2179 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_to_short() != 17327 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_appearance_ids_all() != 44342 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bag_of_bytes_append_cafe() != 43605 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bag_of_bytes_append_deadbeef() != 883 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bag_of_bytes_prepend_cafe() != 47543 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bag_of_bytes_prepend_deadbeef() != 6895 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_bech32_address() != 55186 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_network_id() != 63003 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_abs() != 44067 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_add() != 697 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_clamped_to_zero() != 64928 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_div() != 19189 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_greater_than() != 48331 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_greater_than_or_equal() != 2033 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_is_negative() != 64178 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_is_positive() != 6024 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_is_zero() != 49608 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_less_than() != 56621 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_less_than_or_equal() != 59719 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_max() != 7974 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_min() != 12755 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_mul() != 26895 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_neg() != 41456 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_round() != 8832 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_sub() != 35224 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_to_string() != 38303 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ed25519_public_key_to_bytes() != 22077 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ed25519_public_key_to_hex() != 58559 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_mainnet() != 6356 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_stokenet() != 5043 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_identity_address_bech32_address() != 60833 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_identity_address_network_id() != 32709 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_mnemonic_phrase() != 1392 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accesscontroller_address() != 38016 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address() != 35088 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_from() != 38710 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_app_preferences_placeholder() != 33404 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_app_preferences_placeholder_other() != 29534 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_appearance_id() != 46951 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_appearance_id_placeholder() != 3829 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_appearance_id_placeholder_other() != 21005 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_from() != 64184 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_placeholder_aced() != 43415 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_placeholder_babe() != 17713 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_placeholder_cafe() != 27093 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_placeholder_dead() != 13817 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_placeholder_ecad() != 24823 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_placeholder_fade() != 10852 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address() != 37962 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_exponent() != 14207 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_f32() != 3137 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_formatted_string() != 41914 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_i32() != 18727 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_i64() != 60170 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_string() != 44503 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_u32() != 9150 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_u64() != 426 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_display_name() != 12714 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_from_bytes() != 242 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_from_hex() != 47151 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_placeholder() != 22770 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_placeholder_other() != 58474 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_sources_placeholder() != 16421 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_sources_placeholder_other() != 57151 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateways() != 62531 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateways_placeholder() != 57602 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateways_placeholder_other() != 22882 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_header_placeholder() != 56934 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_header_placeholder_other() != 44721 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hex32_bytes_from() != 59466 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hex32_bytes_from_bag() != 38499 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hex33_bytes_from() != 56282 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hex33_bytes_from_bag() != 31999 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hex64_bytes_from() != 2534 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hex64_bytes_from_bag() != 5701 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hex65_bytes_from() != 50943 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hex65_bytes_from_bag() != 55989 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address() != 58386 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_from() != 35055 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address() != 9704 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address() != 55001 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_private_hd_factor_source() != 4402 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile() != 24696 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_placeholder() != 29783 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_placeholder_other() != 35035 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_password() != 61837 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_password_placeholder() != 63995 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_password_placeholder_other() != 6824 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address() != 17661 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_public_key_from_bytes() != 54701 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_public_key_from_hex() != 48532 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_public_key_placeholder() != 4135 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_public_key_placeholder_other() != 25637 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address() != 30897 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address() != 1877 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_local_id_to_string() != 48364 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_package_address_bech32_address() != 44213 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_package_address_network_id() != 58530 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_pool_address_bech32_address() != 24983 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_pool_address_network_id() != 46890 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_bech32_address() != 37621 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_is_fungible() != 30452 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_is_non_fungible() != 12700 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_network_id() != 38225 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secp256k1_public_key_to_bytes() != 687 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secp256k1_public_key_to_hex() != 54699 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secure_storage_key_identifier() != 8445 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_validator_address_bech32_address() != 31829 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_validator_address_network_id() != 51927 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_bech32_address() != 17324 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_is_fungible() != 45184 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_is_non_fungible() != 65188 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_network_id() != 51714 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_securestorage_load_data() != 12707 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_securestorage_save_data() != 54414 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_securestorage_delete_data_for_key() != 21565 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_add_account() != 59293 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_change_name_of_account() != 31672 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_create_and_save_new_account() != 29285 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_create_new_account() != 50478 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_json_snapshot() != 24850 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_main_bdfs_mnemonic_with_passphrase() != 59906 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_mnemonic_with_passphrase_of_device_factor_source_by_factor_source_id() != 48090 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_profile() != 5221 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_update_account() != 37118 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_wallet_by_creating_new_profile_and_secrets_with_entropy() != 11905 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_wallet_by_importing_profile() != 8084 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_wallet_by_loading_profile() != 38339 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_wallet_by_loading_profile_with_id() != 4488 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitSecureStorage()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
