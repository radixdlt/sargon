// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(SargonFFI)
    import SargonFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len: 0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_sargon_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_sargon_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_UNEXPECTED_ERROR:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void
) {
    do {
        try writeReturn(makeCall())
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void,
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

    func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        map.count
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

private struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

private struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return try Data(readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

/**
 * An HTTP client for consuming the Radix ⛩️ Gateway API ([docs]).
 *
 * The implementing FFI clients can then consume the Radix Gateway API to e.g.
 * fetch the XRD balance of an account address or submit a signed transaction.
 *
 * [docs]: https://radix-babylon-gateway-api.redoc.ly/
 */
public protocol GatewayClientProtocol: AnyObject {
    /**
     * Returns the current `Epoch` of the Radix Network of the provided gateway.
     */
    func currentEpoch() async throws -> Epoch

    /**
     * Returns the "EncodedReceipt" by running a "dry run" of a
     * transaction - a preview of the transaction. The "EncodedReceipt" is
     * required by the [`execution_summary` method](TransactionManifest::execution_summary)
     * on [`TransactionManifest`].
     */
    func dryRunTransaction(intent: TransactionIntent, signerPublicKeys: [PublicKey]) async throws -> BagOfBytes

    /**
     * Submits a signed transaction payload to the network.
     *
     * Returns `Ok(IntentHash)` if the transaction was submitted and not a duplicate.
     */
    func submitNotarizedTransaction(notarizedTransaction: NotarizedTransaction) async throws -> IntentHash

    /**
     * Fetched the XRD balance of account of `address`, returns `None` if
     * it has no balance.
     */
    func xrdBalanceOfAccount(address: AccountAddress) async throws -> Decimal192?

    /**
     * Fetched the XRD balance of account of `address`, returns `0` if
     * it has no balance.
     */
    func xrdBalanceOfAccountOrZero(address: AccountAddress) async throws -> Decimal192
}

/**
 * An HTTP client for consuming the Radix ⛩️ Gateway API ([docs]).
 *
 * The implementing FFI clients can then consume the Radix Gateway API to e.g.
 * fetch the XRD balance of an account address or submit a signed transaction.
 *
 * [docs]: https://radix-babylon-gateway-api.redoc.ly/
 */
open class GatewayClient:
    GatewayClientProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_gatewayclient(self.pointer, $0) }
    }

    /**
     * Constructs a new `GatewayClient` with a NetworkAntenna for a specified
     * network, by looking up an Radix DLT provided Gateway on that network.
     *
     * # Panics
     * Panics if Radix DLT does not provide a Gateway for the specified
     * `network_id` - e.g. will panic if you specify `NetworkID::Simulator` (duh).
     */
    public convenience init(networkAntenna: NetworkAntenna, networkId: NetworkId) {
        let pointer =
            try! rustCall {
                uniffi_sargon_fn_constructor_gatewayclient_new(
                    FfiConverterTypeNetworkAntenna.lower(networkAntenna),
                    FfiConverterTypeNetworkID.lower(networkId), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_gatewayclient(pointer, $0) }
    }

    /**
     * Constructs a new `GatewayClient` with a NetworkAntenna for a specified
     * `Gateway`.
     */
    public static func withGateway(networkAntenna: NetworkAntenna, gateway: Gateway) -> GatewayClient {
        return try! FfiConverterTypeGatewayClient.lift(try! rustCall {
            uniffi_sargon_fn_constructor_gatewayclient_with_gateway(
                FfiConverterTypeNetworkAntenna.lower(networkAntenna),
                FfiConverterTypeGateway.lower(gateway), $0
            )
        })
    }

    /**
     * Returns the current `Epoch` of the Radix Network of the provided gateway.
     */
    open func currentEpoch() async throws -> Epoch {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_gatewayclient_current_epoch(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_u64,
                completeFunc: ffi_sargon_rust_future_complete_u64,
                freeFunc: ffi_sargon_rust_future_free_u64,
                liftFunc: FfiConverterTypeEpoch.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Returns the "EncodedReceipt" by running a "dry run" of a
     * transaction - a preview of the transaction. The "EncodedReceipt" is
     * required by the [`execution_summary` method](TransactionManifest::execution_summary)
     * on [`TransactionManifest`].
     */
    open func dryRunTransaction(intent: TransactionIntent, signerPublicKeys: [PublicKey]) async throws -> BagOfBytes {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_gatewayclient_dry_run_transaction(
                        self.uniffiClonePointer(),
                        FfiConverterTypeTransactionIntent.lower(intent), FfiConverterSequenceTypePublicKey.lower(signerPublicKeys)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeBagOfBytes.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Submits a signed transaction payload to the network.
     *
     * Returns `Ok(IntentHash)` if the transaction was submitted and not a duplicate.
     */
    open func submitNotarizedTransaction(notarizedTransaction: NotarizedTransaction) async throws -> IntentHash {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_gatewayclient_submit_notarized_transaction(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNotarizedTransaction.lower(notarizedTransaction)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeIntentHash.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Fetched the XRD balance of account of `address`, returns `None` if
     * it has no balance.
     */
    open func xrdBalanceOfAccount(address: AccountAddress) async throws -> Decimal192? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_gatewayclient_xrd_balance_of_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeAccountAddress.lower(address)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionTypeDecimal192.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Fetched the XRD balance of account of `address`, returns `0` if
     * it has no balance.
     */
    open func xrdBalanceOfAccountOrZero(address: AccountAddress) async throws -> Decimal192 {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_gatewayclient_xrd_balance_of_account_or_zero(
                        self.uniffiClonePointer(),
                        FfiConverterTypeAccountAddress.lower(address)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeDecimal192.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

public struct FfiConverterTypeGatewayClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GatewayClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GatewayClient {
        return GatewayClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GatewayClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GatewayClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GatewayClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeGatewayClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> GatewayClient {
    return try FfiConverterTypeGatewayClient.lift(pointer)
}

public func FfiConverterTypeGatewayClient_lower(_ value: GatewayClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGatewayClient.lower(value)
}

/**
 * Trait for executing network requests, to be  implemented on the FFI side
 * (iOS/Android), so that Sargon can with some HTTP client perform make network
 * requests.
 */
public protocol NetworkAntenna: AnyObject {
    /**
     * Method invoked by Sargon Rust side, telling an implementing type to
     * execute a `NetworkRequest` and pass the Result back to Sargon Rust side.
     *
     * Either: `Err` or `Ok(NetworkResponse)`.
     */
    func executeNetworkRequest(request: NetworkRequest) async throws -> NetworkResponse
}

/**
 * Trait for executing network requests, to be  implemented on the FFI side
 * (iOS/Android), so that Sargon can with some HTTP client perform make network
 * requests.
 */
open class NetworkAntennaImpl:
    NetworkAntenna
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_networkantenna(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_networkantenna(pointer, $0) }
    }

    /**
     * Method invoked by Sargon Rust side, telling an implementing type to
     * execute a `NetworkRequest` and pass the Result back to Sargon Rust side.
     *
     * Either: `Err` or `Ok(NetworkResponse)`.
     */
    open func executeNetworkRequest(request: NetworkRequest) async throws -> NetworkResponse {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_networkantenna_execute_network_request(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNetworkRequest.lower(request)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeNetworkResponse.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceNetworkAntenna {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceNetworkAntenna = .init(
        executeNetworkRequest: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> NetworkResponse in
                guard let uniffiObj = try? FfiConverterTypeNetworkAntenna.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.executeNetworkRequest(
                    request: FfiConverterTypeNetworkRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: NetworkResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeNetworkResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeNetworkAntenna.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface NetworkAntenna: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitNetworkAntenna() {
    uniffi_sargon_fn_init_callback_vtable_networkantenna(&UniffiCallbackInterfaceNetworkAntenna.vtable)
}

public struct FfiConverterTypeNetworkAntenna: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<NetworkAntenna>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NetworkAntenna

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkAntenna {
        return NetworkAntennaImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NetworkAntenna) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkAntenna {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NetworkAntenna, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeNetworkAntenna_lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkAntenna {
    return try FfiConverterTypeNetworkAntenna.lift(pointer)
}

public func FfiConverterTypeNetworkAntenna_lower(_ value: NetworkAntenna) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNetworkAntenna.lower(value)
}

public protocol SecureStorage: AnyObject {
    func loadData(key: SecureStorageKey) throws -> Data?

    func saveData(key: SecureStorageKey, data: Data) throws

    func deleteDataForKey(key: SecureStorageKey) throws
}

open class SecureStorageImpl:
    SecureStorage
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_securestorage(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_securestorage(pointer, $0) }
    }

    open func loadData(key: SecureStorageKey) throws -> Data? {
        return try FfiConverterOptionData.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_securestorage_load_data(self.uniffiClonePointer(),
                                                            FfiConverterTypeSecureStorageKey.lower(key), $0)
        })
    }

    open func saveData(key: SecureStorageKey, data: Data) throws { try rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_method_securestorage_save_data(self.uniffiClonePointer(),
                                                        FfiConverterTypeSecureStorageKey.lower(key),
                                                        FfiConverterData.lower(data), $0)
    }
    }

    open func deleteDataForKey(key: SecureStorageKey) throws { try rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_method_securestorage_delete_data_for_key(self.uniffiClonePointer(),
                                                                  FfiConverterTypeSecureStorageKey.lower(key), $0)
    }
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceSecureStorage {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSecureStorage = .init(
        loadData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Data? in
                guard let uniffiObj = try? FfiConverterTypeSecureStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.loadData(
                    key: FfiConverterTypeSecureStorageKey.lift(key)
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionData.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeCommonError.lower
            )
        },
        saveData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            data: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterTypeSecureStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.saveData(
                    key: FfiConverterTypeSecureStorageKey.lift(key),
                    data: FfiConverterData.lift(data)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeCommonError.lower
            )
        },
        deleteDataForKey: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterTypeSecureStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.deleteDataForKey(
                    key: FfiConverterTypeSecureStorageKey.lift(key)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeCommonError.lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeSecureStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SecureStorage: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSecureStorage() {
    uniffi_sargon_fn_init_callback_vtable_securestorage(&UniffiCallbackInterfaceSecureStorage.vtable)
}

public struct FfiConverterTypeSecureStorage: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<SecureStorage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SecureStorage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecureStorage {
        return SecureStorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SecureStorage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SecureStorage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeSecureStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecureStorage {
    return try FfiConverterTypeSecureStorage.lift(pointer)
}

public func FfiConverterTypeSecureStorage_lower(_ value: SecureStorage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSecureStorage.lower(value)
}

public protocol WalletProtocol: AnyObject {
    /**
     * Returns `Ok(())` if the `account` was new and successfully added. If saving failed or if the account was already present in Profile, an
     * error is returned.
     */
    func addAccount(account: Account) throws

    /**
     * Updates the display name of account with the provided address, throws an error if the account is unknown to the wallet.
     */
    func changeNameOfAccount(address: AccountAddress, to: DisplayName) throws -> Account

    /**
     * Create a new Account and adds it to the active Profile.
     */
    func createAndSaveNewAccount(networkId: NetworkId, name: DisplayName) throws -> Account

    /**
     * Creates a new non securified account **WITHOUT** add it to Profile, using the *main* "Babylon"
     * `DeviceFactorSource` and the "next" index for this FactorSource as derivation path.
     *
     * If you want to add it to Profile, call `wallet.add_account(account)`
     */
    func createNewAccount(networkId: NetworkId, name: DisplayName) throws -> Account

    /**
     * Takes a snapshot of the profile and serialize it as a String of JSON.
     */
    func jsonSnapshot() -> String

    /**
     * Tries to load the  `MnemonicWithPassphrase` for the main "Babylon"
     * `DeviceFactorSource` from secure storage.
     */
    func mainBdfsMnemonicWithPassphrase() throws -> MnemonicWithPassphrase

    /**
     * Tries to load a `MnemonicWithPassphrase` from secure storage
     * by `factor_source_id`.
     */
    func mnemonicWithPassphraseOfDeviceFactorSourceByFactorSourceId(factorSourceId: FactorSourceId) throws -> MnemonicWithPassphrase

    /**
     * Clone the profile and return it.
     */
    func profile() -> Profile

    /**
     * Updates `account` as a whole, if it exists, else an error is thrown.
     */
    func updateAccount(to: Account) throws -> Account
}

open class Wallet:
    WalletProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_wallet(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_wallet(pointer, $0) }
    }

    /**
     * Creates a new Mnemonic from `entropy` (without BIP39 passphrase) and creates a new Profile,
     * saving both the Mnemonic and Profile into secure storage and returns a new Wallet.
     */
    public static func byCreatingNewProfileAndSecretsWithEntropy(entropy: NonEmptyMax32Bytes, walletClientModel: WalletClientModel, walletClientName: String, secureStorage: SecureStorage) throws -> Wallet {
        return try FfiConverterTypeWallet.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_constructor_wallet_by_creating_new_profile_and_secrets_with_entropy(
                FfiConverterTypeNonEmptyMax32Bytes.lower(entropy),
                FfiConverterTypeWalletClientModel.lower(walletClientModel),
                FfiConverterString.lower(walletClientName),
                FfiConverterTypeSecureStorage.lower(secureStorage), $0
            )
        })
    }

    /**
     * Creates wallet by *importing* a Profile.
     */
    public static func byImportingProfile(profile: Profile, secureStorage: SecureStorage) -> Wallet {
        return try! FfiConverterTypeWallet.lift(try! rustCall {
            uniffi_sargon_fn_constructor_wallet_by_importing_profile(
                FfiConverterTypeProfile.lower(profile),
                FfiConverterTypeSecureStorage.lower(secureStorage), $0
            )
        })
    }

    public static func byLoadingProfile(secureStorage: SecureStorage) throws -> Wallet {
        return try FfiConverterTypeWallet.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_constructor_wallet_by_loading_profile(
                FfiConverterTypeSecureStorage.lower(secureStorage), $0
            )
        })
    }

    public static func byLoadingProfileWithId(profileId: ProfileId, secureStorage: SecureStorage) throws -> Wallet {
        return try FfiConverterTypeWallet.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_constructor_wallet_by_loading_profile_with_id(
                FfiConverterTypeProfileID.lower(profileId),
                FfiConverterTypeSecureStorage.lower(secureStorage), $0
            )
        })
    }

    /**
     * Returns `Ok(())` if the `account` was new and successfully added. If saving failed or if the account was already present in Profile, an
     * error is returned.
     */
    open func addAccount(account: Account) throws { try rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_method_wallet_add_account(self.uniffiClonePointer(),
                                                   FfiConverterTypeAccount.lower(account), $0)
    }
    }

    /**
     * Updates the display name of account with the provided address, throws an error if the account is unknown to the wallet.
     */
    open func changeNameOfAccount(address: AccountAddress, to: DisplayName) throws -> Account {
        return try FfiConverterTypeAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_wallet_change_name_of_account(self.uniffiClonePointer(),
                                                                  FfiConverterTypeAccountAddress.lower(address),
                                                                  FfiConverterTypeDisplayName.lower(to), $0)
        })
    }

    /**
     * Create a new Account and adds it to the active Profile.
     */
    open func createAndSaveNewAccount(networkId: NetworkId, name: DisplayName) throws -> Account {
        return try FfiConverterTypeAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_wallet_create_and_save_new_account(self.uniffiClonePointer(),
                                                                       FfiConverterTypeNetworkID.lower(networkId),
                                                                       FfiConverterTypeDisplayName.lower(name), $0)
        })
    }

    /**
     * Creates a new non securified account **WITHOUT** add it to Profile, using the *main* "Babylon"
     * `DeviceFactorSource` and the "next" index for this FactorSource as derivation path.
     *
     * If you want to add it to Profile, call `wallet.add_account(account)`
     */
    open func createNewAccount(networkId: NetworkId, name: DisplayName) throws -> Account {
        return try FfiConverterTypeAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_wallet_create_new_account(self.uniffiClonePointer(),
                                                              FfiConverterTypeNetworkID.lower(networkId),
                                                              FfiConverterTypeDisplayName.lower(name), $0)
        })
    }

    /**
     * Takes a snapshot of the profile and serialize it as a String of JSON.
     */
    open func jsonSnapshot() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_sargon_fn_method_wallet_json_snapshot(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Tries to load the  `MnemonicWithPassphrase` for the main "Babylon"
     * `DeviceFactorSource` from secure storage.
     */
    open func mainBdfsMnemonicWithPassphrase() throws -> MnemonicWithPassphrase {
        return try FfiConverterTypeMnemonicWithPassphrase.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_wallet_main_bdfs_mnemonic_with_passphrase(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Tries to load a `MnemonicWithPassphrase` from secure storage
     * by `factor_source_id`.
     */
    open func mnemonicWithPassphraseOfDeviceFactorSourceByFactorSourceId(factorSourceId: FactorSourceId) throws -> MnemonicWithPassphrase {
        return try FfiConverterTypeMnemonicWithPassphrase.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_wallet_mnemonic_with_passphrase_of_device_factor_source_by_factor_source_id(self.uniffiClonePointer(),
                                                                                                                FfiConverterTypeFactorSourceID.lower(factorSourceId), $0)
        })
    }

    /**
     * Clone the profile and return it.
     */
    open func profile() -> Profile {
        return try! FfiConverterTypeProfile.lift(try! rustCall {
            uniffi_sargon_fn_method_wallet_profile(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Updates `account` as a whole, if it exists, else an error is thrown.
     */
    open func updateAccount(to: Account) throws -> Account {
        return try FfiConverterTypeAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_wallet_update_account(self.uniffiClonePointer(),
                                                          FfiConverterTypeAccount.lower(to), $0)
        })
    }
}

public struct FfiConverterTypeWallet: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wallet

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
        return Wallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Wallet) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Wallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Wallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
    return try FfiConverterTypeWallet.lift(pointer)
}

public func FfiConverterTypeWallet_lower(_ value: Wallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWallet.lower(value)
}

/**
 * Address to an AccessController that controls an Account or Identity (Persona),
 * it said entity has been "securified", e.g.:
 * `"accesscontroller_rdx1c0duj4lq0dc3cpl8qd420fpn5eckh8ljeysvjm894lyl5ja5yq6y5a"`
 *
 * When a user applies a SecurityStructureConfiguration for the first time on a
 * non-securified entity (and signs and submit the resulting TX) said entity is
 * "assigned" an AccessControllerAddress by the network.
 *
 * An `AccessControllerAddress` has the [Scrypto's `EntityType`][entt] `GlobalAccessController`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalAccessControllerAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L247-L248
 */
public struct AccessControllerAddress {
    fileprivate let secretMagic: RetAccessControllerAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetAccessControllerAddress) {
        self.secretMagic = secretMagic
    }
}

extension AccessControllerAddress: Sendable {}
extension AccessControllerAddress: Equatable, Hashable {
    public static func == (lhs: AccessControllerAddress, rhs: AccessControllerAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeAccessControllerAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccessControllerAddress {
        return
            try AccessControllerAddress(
                secretMagic: FfiConverterTypeRetAccessControllerAddress.read(from: &buf)
            )
    }

    public static func write(_ value: AccessControllerAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetAccessControllerAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeAccessControllerAddress_lift(_ buf: RustBuffer) throws -> AccessControllerAddress {
    return try FfiConverterTypeAccessControllerAddress.lift(buf)
}

public func FfiConverterTypeAccessControllerAddress_lower(_ value: AccessControllerAddress) -> RustBuffer {
    return FfiConverterTypeAccessControllerAddress.lower(value)
}

/**
 * A network unique account with a unique public address and a set of cryptographic
 * factors used to control it.
 *
 * Used to own and control assets on the radix network. Uniquely identified by an
 * account address, e.g.
 *
 * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
 *
 * But most commonly users see the address on its abbreviated form:
 *
 * `acco...nvjdwr`
 *
 * Accounts have a display name and an appearance id.
 *
 * An account can be either controlled by a "Babylon" DeviceFactorSource or a
 * Legacy one imported from Olympia, or a Ledger hardware wallet, which too might
 * have been imported from Olympia.
 */
public struct Account {
    /**
     * The ID of the network this account can be used with.
     */
    public var networkId: NetworkId
    /**
     * A globally unique identifier of this account, being a human readable
     * address of an account. Always starts with `"account_"``, for example:
     *
     * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
     *
     * Most commonly the user will see this address in its abbreviated
     * form which is:
     *
     * `acco...nvjdwr`
     *
     * No two addresses will ever be the same even for the same factor source
     * but on different networks, since the public keys controlling the
     * accounts depend on the network id.
     */
    public var address: AccountAddress
    /**
     * An off-ledger display name or description chosen by the user when she
     * created this account.
     */
    public var displayName: DisplayName
    /**
     * Security state of this account, either "securified" or not.
     */
    public var securityState: EntitySecurityState
    /**
     * The visual cue user learns to associated this account with, typically
     * a beautiful colorful gradient.
     */
    public var appearanceId: AppearanceId
    /**
     * An order set of `EntityFlag`s used to describe certain Off-ledger
     * user state about Accounts or Personas, such as if an entity is
     * marked as hidden or not.
     */
    public var flags: [EntityFlag]
    /**
     * The on ledger synced settings for this account, contains e.g.
     * ThirdPartyDeposit settings, with deposit rules for assets.
     */
    public var onLedgerSettings: OnLedgerSettings

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network this account can be used with.
         */ networkId: NetworkId,
        /**
            * A globally unique identifier of this account, being a human readable
            * address of an account. Always starts with `"account_"``, for example:
            *
            * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
            *
            * Most commonly the user will see this address in its abbreviated
            * form which is:
            *
            * `acco...nvjdwr`
            *
            * No two addresses will ever be the same even for the same factor source
            * but on different networks, since the public keys controlling the
            * accounts depend on the network id.
            */ address: AccountAddress,
        /**
            * An off-ledger display name or description chosen by the user when she
            * created this account.
            */ displayName: DisplayName,
        /**
            * Security state of this account, either "securified" or not.
            */ securityState: EntitySecurityState,
        /**
            * The visual cue user learns to associated this account with, typically
            * a beautiful colorful gradient.
            */ appearanceId: AppearanceId,
        /**
            * An order set of `EntityFlag`s used to describe certain Off-ledger
            * user state about Accounts or Personas, such as if an entity is
            * marked as hidden or not.
            */ flags: [EntityFlag],
        /**
            * The on ledger synced settings for this account, contains e.g.
            * ThirdPartyDeposit settings, with deposit rules for assets.
            */ onLedgerSettings: OnLedgerSettings
    ) {
        self.networkId = networkId
        self.address = address
        self.displayName = displayName
        self.securityState = securityState
        self.appearanceId = appearanceId
        self.flags = flags
        self.onLedgerSettings = onLedgerSettings
    }
}

extension Account: Sendable {}
extension Account: Equatable, Hashable {
    public static func == (lhs: Account, rhs: Account) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.securityState != rhs.securityState {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        if lhs.onLedgerSettings != rhs.onLedgerSettings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(securityState)
        hasher.combine(appearanceId)
        hasher.combine(flags)
        hasher.combine(onLedgerSettings)
    }
}

public struct FfiConverterTypeAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Account {
        return
            try Account(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                address: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                securityState: FfiConverterTypeEntitySecurityState.read(from: &buf),
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf),
                flags: FfiConverterSequenceTypeEntityFlag.read(from: &buf),
                onLedgerSettings: FfiConverterTypeOnLedgerSettings.read(from: &buf)
            )
    }

    public static func write(_ value: Account, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeEntitySecurityState.write(value.securityState, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
        FfiConverterSequenceTypeEntityFlag.write(value.flags, into: &buf)
        FfiConverterTypeOnLedgerSettings.write(value.onLedgerSettings, into: &buf)
    }
}

public func FfiConverterTypeAccount_lift(_ buf: RustBuffer) throws -> Account {
    return try FfiConverterTypeAccount.lift(buf)
}

public func FfiConverterTypeAccount_lower(_ value: Account) -> RustBuffer {
    return FfiConverterTypeAccount.lower(value)
}

/**
 * Human readable address of an account. Always starts with `"account_"``, for example:
 *
 * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
 *
 * Most commonly the user will see this address in its abbreviated
 * form which is:
 *
 * `acco...nvjdwr`
 *
 * Addresses are checksummed, as per Bech32. **Only** *Account* addresses starts with
 * the prefix `account_`.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of AccountAddresses:
 * * GlobalAccount
 * * GlobalVirtualSecp256k1Account
 * * GlobalVirtualEd25519Account
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalAccountAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L224-L228
 */
public struct AccountAddress {
    fileprivate let secretMagic: RetAccountAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetAccountAddress) {
        self.secretMagic = secretMagic
    }
}

extension AccountAddress: Sendable {}
extension AccountAddress: Equatable, Hashable {
    public static func == (lhs: AccountAddress, rhs: AccountAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeAccountAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountAddress {
        return
            try AccountAddress(
                secretMagic: FfiConverterTypeRetAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: AccountAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetAccountAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeAccountAddress_lift(_ buf: RustBuffer) throws -> AccountAddress {
    return try FfiConverterTypeAccountAddress.lift(buf)
}

public func FfiConverterTypeAccountAddress_lower(_ value: AccountAddress) -> RustBuffer {
    return FfiConverterTypeAccountAddress.lower(value)
}

/**
 * A minimal version of an [`Account`] meant for
 * display purposes within wallet
 */
public struct AccountForDisplay {
    public var address: AccountAddress
    public var label: DisplayName
    public var appearanceId: AppearanceId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: AccountAddress, label: DisplayName, appearanceId: AppearanceId) {
        self.address = address
        self.label = label
        self.appearanceId = appearanceId
    }
}

extension AccountForDisplay: Sendable {}
extension AccountForDisplay: Equatable, Hashable {
    public static func == (lhs: AccountForDisplay, rhs: AccountForDisplay) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(label)
        hasher.combine(appearanceId)
    }
}

public struct FfiConverterTypeAccountForDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountForDisplay {
        return
            try AccountForDisplay(
                address: FfiConverterTypeAccountAddress.read(from: &buf),
                label: FfiConverterTypeDisplayName.read(from: &buf),
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf)
            )
    }

    public static func write(_ value: AccountForDisplay, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.label, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
    }
}

public func FfiConverterTypeAccountForDisplay_lift(_ buf: RustBuffer) throws -> AccountForDisplay {
    return try FfiConverterTypeAccountForDisplay.lift(buf)
}

public func FfiConverterTypeAccountForDisplay_lower(_ value: AccountForDisplay) -> RustBuffer {
    return FfiConverterTypeAccountForDisplay.lower(value)
}

public struct AccountPath {
    public var path: HdPath
    public var networkId: NetworkId
    public var entityKind: Cap26EntityKind
    public var keyKind: Cap26KeyKind
    public var index: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: HdPath, networkId: NetworkId, entityKind: Cap26EntityKind, keyKind: Cap26KeyKind, index: UInt32) {
        self.path = path
        self.networkId = networkId
        self.entityKind = entityKind
        self.keyKind = keyKind
        self.index = index
    }
}

extension AccountPath: Sendable {}
extension AccountPath: Equatable, Hashable {
    public static func == (lhs: AccountPath, rhs: AccountPath) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.entityKind != rhs.entityKind {
            return false
        }
        if lhs.keyKind != rhs.keyKind {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(networkId)
        hasher.combine(entityKind)
        hasher.combine(keyKind)
        hasher.combine(index)
    }
}

public struct FfiConverterTypeAccountPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountPath {
        return
            try AccountPath(
                path: FfiConverterTypeHDPath.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                entityKind: FfiConverterTypeCAP26EntityKind.read(from: &buf),
                keyKind: FfiConverterTypeCAP26KeyKind.read(from: &buf),
                index: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: AccountPath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPath.write(value.path, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeCAP26EntityKind.write(value.entityKind, into: &buf)
        FfiConverterTypeCAP26KeyKind.write(value.keyKind, into: &buf)
        FfiConverterUInt32.write(value.index, into: &buf)
    }
}

public func FfiConverterTypeAccountPath_lift(_ buf: RustBuffer) throws -> AccountPath {
    return try FfiConverterTypeAccountPath.lift(buf)
}

public func FfiConverterTypeAccountPath_lower(_ value: AccountPath) -> RustBuffer {
    return FfiConverterTypeAccountPath.lower(value)
}

/**
 * Settings related to displaying of information to the user inside the app.
 *
 * **N.B. neither of these settings are in fact not yet used by clients.**
 */
public struct AppDisplay {
    /**
     * If we should show the aggregate value of users portfolio in fiat currency
     * of hide it.
     */
    public var isCurrencyAmountVisible: Bool
    /**
     * Which fiat currency the prices are measured in.
     */
    public var fiatCurrencyPriceTarget: FiatCurrency

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If we should show the aggregate value of users portfolio in fiat currency
         * of hide it.
         */ isCurrencyAmountVisible: Bool,
        /**
            * Which fiat currency the prices are measured in.
            */ fiatCurrencyPriceTarget: FiatCurrency
    ) {
        self.isCurrencyAmountVisible = isCurrencyAmountVisible
        self.fiatCurrencyPriceTarget = fiatCurrencyPriceTarget
    }
}

extension AppDisplay: Sendable {}
extension AppDisplay: Equatable, Hashable {
    public static func == (lhs: AppDisplay, rhs: AppDisplay) -> Bool {
        if lhs.isCurrencyAmountVisible != rhs.isCurrencyAmountVisible {
            return false
        }
        if lhs.fiatCurrencyPriceTarget != rhs.fiatCurrencyPriceTarget {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCurrencyAmountVisible)
        hasher.combine(fiatCurrencyPriceTarget)
    }
}

public struct FfiConverterTypeAppDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppDisplay {
        return
            try AppDisplay(
                isCurrencyAmountVisible: FfiConverterBool.read(from: &buf),
                fiatCurrencyPriceTarget: FfiConverterTypeFiatCurrency.read(from: &buf)
            )
    }

    public static func write(_ value: AppDisplay, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCurrencyAmountVisible, into: &buf)
        FfiConverterTypeFiatCurrency.write(value.fiatCurrencyPriceTarget, into: &buf)
    }
}

public func FfiConverterTypeAppDisplay_lift(_ buf: RustBuffer) throws -> AppDisplay {
    return try FfiConverterTypeAppDisplay.lift(buf)
}

public func FfiConverterTypeAppDisplay_lower(_ value: AppDisplay) -> RustBuffer {
    return FfiConverterTypeAppDisplay.lower(value)
}

/**
 * Collection of all settings, preferences and configuration related to how the wallet
 * behaves and looks.
 *
 * Current and other saved Gateways, security settings,
 * App Display settings and preferences for transaction.
 */
public struct AppPreferences {
    /**
     * Display settings in the wallet app, such as appearances, currency etc.
     */
    public var display: AppDisplay
    /**
     * The gateway of the active network and collection of other saved gateways.
     */
    public var gateways: SavedGateways
    /**
     * Controls e.g. if Profile Snapshot gets synced to iCloud/Google backup or not.
     */
    public var security: Security
    /**
     * Default config related to making of transactions
     */
    public var transaction: TransactionPreferences

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Display settings in the wallet app, such as appearances, currency etc.
         */ display: AppDisplay,
        /**
            * The gateway of the active network and collection of other saved gateways.
            */ gateways: SavedGateways,
        /**
            * Controls e.g. if Profile Snapshot gets synced to iCloud/Google backup or not.
            */ security: Security,
        /**
            * Default config related to making of transactions
            */ transaction: TransactionPreferences
    ) {
        self.display = display
        self.gateways = gateways
        self.security = security
        self.transaction = transaction
    }
}

extension AppPreferences: Sendable {}
extension AppPreferences: Equatable, Hashable {
    public static func == (lhs: AppPreferences, rhs: AppPreferences) -> Bool {
        if lhs.display != rhs.display {
            return false
        }
        if lhs.gateways != rhs.gateways {
            return false
        }
        if lhs.security != rhs.security {
            return false
        }
        if lhs.transaction != rhs.transaction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(display)
        hasher.combine(gateways)
        hasher.combine(security)
        hasher.combine(transaction)
    }
}

public struct FfiConverterTypeAppPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppPreferences {
        return
            try AppPreferences(
                display: FfiConverterTypeAppDisplay.read(from: &buf),
                gateways: FfiConverterTypeSavedGateways.read(from: &buf),
                security: FfiConverterTypeSecurity.read(from: &buf),
                transaction: FfiConverterTypeTransactionPreferences.read(from: &buf)
            )
    }

    public static func write(_ value: AppPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeAppDisplay.write(value.display, into: &buf)
        FfiConverterTypeSavedGateways.write(value.gateways, into: &buf)
        FfiConverterTypeSecurity.write(value.security, into: &buf)
        FfiConverterTypeTransactionPreferences.write(value.transaction, into: &buf)
    }
}

public func FfiConverterTypeAppPreferences_lift(_ buf: RustBuffer) throws -> AppPreferences {
    return try FfiConverterTypeAppPreferences.lift(buf)
}

public func FfiConverterTypeAppPreferences_lower(_ value: AppPreferences) -> RustBuffer {
    return FfiConverterTypeAppPreferences.lower(value)
}

public struct AppearanceId {
    public var value: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt8) {
        self.value = value
    }
}

extension AppearanceId: Sendable {}
extension AppearanceId: Equatable, Hashable {
    public static func == (lhs: AppearanceId, rhs: AppearanceId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeAppearanceID: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppearanceId {
        return
            try AppearanceId(
                value: FfiConverterUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: AppearanceId, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeAppearanceID_lift(_ buf: RustBuffer) throws -> AppearanceId {
    return try FfiConverterTypeAppearanceID.lift(buf)
}

public func FfiConverterTypeAppearanceID_lower(_ value: AppearanceId) -> RustBuffer {
    return FfiConverterTypeAppearanceID.lower(value)
}

/**
 * The specific Asset exception rule, which overrides the general
 * `deposit_rule` of a `ThirdPartyDeposits` settings.
 */
public struct AssetException {
    /**
     * Address of an asset to either deny or allow, as an exception overriding the `ThirdPartyDeposits`'s general `deposit_rule`.
     */
    public var address: ResourceAddress
    /**
     * Either deny or allow the `address`.
     */
    public var exceptionRule: DepositAddressExceptionRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Address of an asset to either deny or allow, as an exception overriding the `ThirdPartyDeposits`'s general `deposit_rule`.
         */ address: ResourceAddress,
        /**
            * Either deny or allow the `address`.
            */ exceptionRule: DepositAddressExceptionRule
    ) {
        self.address = address
        self.exceptionRule = exceptionRule
    }
}

extension AssetException: Sendable {}
extension AssetException: Equatable, Hashable {
    public static func == (lhs: AssetException, rhs: AssetException) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.exceptionRule != rhs.exceptionRule {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(exceptionRule)
    }
}

public struct FfiConverterTypeAssetException: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetException {
        return
            try AssetException(
                address: FfiConverterTypeResourceAddress.read(from: &buf),
                exceptionRule: FfiConverterTypeDepositAddressExceptionRule.read(from: &buf)
            )
    }

    public static func write(_ value: AssetException, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.address, into: &buf)
        FfiConverterTypeDepositAddressExceptionRule.write(value.exceptionRule, into: &buf)
    }
}

public func FfiConverterTypeAssetException_lift(_ buf: RustBuffer) throws -> AssetException {
    return try FfiConverterTypeAssetException.lift(buf)
}

public func FfiConverterTypeAssetException_lower(_ value: AssetException) -> RustBuffer {
    return FfiConverterTypeAssetException.lower(value)
}

/**
 * A connection made between a Radix Dapp and the user.
 */
public struct AuthorizedDapp {
    /**
     * The ID of the network the authorized Dapp is on.
     */
    public var networkId: NetworkId
    /**
     * A `DappDefinitionAddress` is in fact just an alias for
     * [`AccountAddress`], it is the address of the account
     * which owns controls the Dapp.
     */
    public var dappDefinitionAddress: AccountAddress
    /**
     * The Display name as sent by the Dapp in any interaction
     * request (CAP21), e.g. "Radix Dashboard".
     */
    public var displayName: String?
    /**
     * An order set of `AuthorizedPersonaSimple`s, which is a collection of all
     * the Personas the user has used to interact with this Dapp, it is called
     * "references to", since the Personas are not stored in full, that would be
     * bad duplication of data (which might go stale), instead we refer to the
     * necessary data by IDs.
     */
    public var referencesToAuthorizedPersonas: [AuthorizedPersonaSimple]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network the authorized Dapp is on.
         */ networkId: NetworkId,
        /**
            * A `DappDefinitionAddress` is in fact just an alias for
            * [`AccountAddress`], it is the address of the account
            * which owns controls the Dapp.
            */ dappDefinitionAddress: AccountAddress,
        /**
            * The Display name as sent by the Dapp in any interaction
            * request (CAP21), e.g. "Radix Dashboard".
            */ displayName: String?,
        /**
            * An order set of `AuthorizedPersonaSimple`s, which is a collection of all
            * the Personas the user has used to interact with this Dapp, it is called
            * "references to", since the Personas are not stored in full, that would be
            * bad duplication of data (which might go stale), instead we refer to the
            * necessary data by IDs.
            */ referencesToAuthorizedPersonas: [AuthorizedPersonaSimple]
    ) {
        self.networkId = networkId
        self.dappDefinitionAddress = dappDefinitionAddress
        self.displayName = displayName
        self.referencesToAuthorizedPersonas = referencesToAuthorizedPersonas
    }
}

extension AuthorizedDapp: Sendable {}
extension AuthorizedDapp: Equatable, Hashable {
    public static func == (lhs: AuthorizedDapp, rhs: AuthorizedDapp) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.referencesToAuthorizedPersonas != rhs.referencesToAuthorizedPersonas {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(dappDefinitionAddress)
        hasher.combine(displayName)
        hasher.combine(referencesToAuthorizedPersonas)
    }
}

public struct FfiConverterTypeAuthorizedDapp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDapp {
        return
            try AuthorizedDapp(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterOptionString.read(from: &buf),
                referencesToAuthorizedPersonas: FfiConverterSequenceTypeAuthorizedPersonaSimple.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedDapp, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterSequenceTypeAuthorizedPersonaSimple.write(value.referencesToAuthorizedPersonas, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedDapp_lift(_ buf: RustBuffer) throws -> AuthorizedDapp {
    return try FfiConverterTypeAuthorizedDapp.lift(buf)
}

public func FfiConverterTypeAuthorizedDapp_lower(_ value: AuthorizedDapp) -> RustBuffer {
    return FfiConverterTypeAuthorizedDapp.lower(value)
}

public struct AuthorizedDappDetailed {
    public var networkId: NetworkId
    public var dappDefinitionAddress: AccountAddress
    public var displayName: DisplayName?
    public var detailedAuthorizedPersonas: [AuthorizedPersonaDetailed]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, dappDefinitionAddress: AccountAddress, displayName: DisplayName?, detailedAuthorizedPersonas: [AuthorizedPersonaDetailed]) {
        self.networkId = networkId
        self.dappDefinitionAddress = dappDefinitionAddress
        self.displayName = displayName
        self.detailedAuthorizedPersonas = detailedAuthorizedPersonas
    }
}

extension AuthorizedDappDetailed: Sendable {}
extension AuthorizedDappDetailed: Equatable, Hashable {
    public static func == (lhs: AuthorizedDappDetailed, rhs: AuthorizedDappDetailed) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.detailedAuthorizedPersonas != rhs.detailedAuthorizedPersonas {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(dappDefinitionAddress)
        hasher.combine(displayName)
        hasher.combine(detailedAuthorizedPersonas)
    }
}

public struct FfiConverterTypeAuthorizedDappDetailed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappDetailed {
        return
            try AuthorizedDappDetailed(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterOptionTypeDisplayName.read(from: &buf),
                detailedAuthorizedPersonas: FfiConverterSequenceTypeAuthorizedPersonaDetailed.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedDappDetailed, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
        FfiConverterOptionTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterSequenceTypeAuthorizedPersonaDetailed.write(value.detailedAuthorizedPersonas, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedDappDetailed_lift(_ buf: RustBuffer) throws -> AuthorizedDappDetailed {
    return try FfiConverterTypeAuthorizedDappDetailed.lift(buf)
}

public func FfiConverterTypeAuthorizedDappDetailed_lower(_ value: AuthorizedDappDetailed) -> RustBuffer {
    return FfiConverterTypeAuthorizedDappDetailed.lower(value)
}

public struct AuthorizedPersonaDetailed {
    /**
     * Address that globally and uniquely identifies this Persona.
     */
    public var identityAddress: IdentityAddress
    /**
     * The display name of the Persona, as stored in `Persona`
     */
    public var displayName: DisplayName
    /**
     * Information of accounts the user has given the Dapp access to,
     * being the triple `(accountAddress, displayName, appearanceID)`
     */
    public var simpleAccounts: [AccountForDisplay]?
    /**
     * The persona data that the user has given the Dapp access to
     */
    public var sharedPersonaData: PersonaData
    /**
     * If this persona has an auth sign key created
     */
    public var hasAuthenticationSigningKey: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Address that globally and uniquely identifies this Persona.
         */ identityAddress: IdentityAddress,
        /**
            * The display name of the Persona, as stored in `Persona`
            */ displayName: DisplayName,
        /**
            * Information of accounts the user has given the Dapp access to,
            * being the triple `(accountAddress, displayName, appearanceID)`
            */ simpleAccounts: [AccountForDisplay]?,
        /**
            * The persona data that the user has given the Dapp access to
            */ sharedPersonaData: PersonaData,
        /**
            * If this persona has an auth sign key created
            */ hasAuthenticationSigningKey: Bool
    ) {
        self.identityAddress = identityAddress
        self.displayName = displayName
        self.simpleAccounts = simpleAccounts
        self.sharedPersonaData = sharedPersonaData
        self.hasAuthenticationSigningKey = hasAuthenticationSigningKey
    }
}

extension AuthorizedPersonaDetailed: Sendable {}
extension AuthorizedPersonaDetailed: Equatable, Hashable {
    public static func == (lhs: AuthorizedPersonaDetailed, rhs: AuthorizedPersonaDetailed) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.simpleAccounts != rhs.simpleAccounts {
            return false
        }
        if lhs.sharedPersonaData != rhs.sharedPersonaData {
            return false
        }
        if lhs.hasAuthenticationSigningKey != rhs.hasAuthenticationSigningKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(displayName)
        hasher.combine(simpleAccounts)
        hasher.combine(sharedPersonaData)
        hasher.combine(hasAuthenticationSigningKey)
    }
}

public struct FfiConverterTypeAuthorizedPersonaDetailed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedPersonaDetailed {
        return
            try AuthorizedPersonaDetailed(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                simpleAccounts: FfiConverterOptionSequenceTypeAccountForDisplay.read(from: &buf),
                sharedPersonaData: FfiConverterTypePersonaData.read(from: &buf),
                hasAuthenticationSigningKey: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedPersonaDetailed, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterOptionSequenceTypeAccountForDisplay.write(value.simpleAccounts, into: &buf)
        FfiConverterTypePersonaData.write(value.sharedPersonaData, into: &buf)
        FfiConverterBool.write(value.hasAuthenticationSigningKey, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedPersonaDetailed_lift(_ buf: RustBuffer) throws -> AuthorizedPersonaDetailed {
    return try FfiConverterTypeAuthorizedPersonaDetailed.lift(buf)
}

public func FfiConverterTypeAuthorizedPersonaDetailed_lower(_ value: AuthorizedPersonaDetailed) -> RustBuffer {
    return FfiConverterTypeAuthorizedPersonaDetailed.lower(value)
}

/**
 * Simple data representation of a Persona the user has shared with a Dapp.
 * Simple meaning "the bare minimum amount of data" that enabled `Sargon` to
 * be able to reconstruct a `AuthorizedPersonaDetailed` value, used to populate
 * views.
 *
 * N.B. as of 2024-01-31 of `Sargon` we have not yet implemented the struct
 * `AuthorizedPersonaDetailed` since it is not JSON, but logic, and we have yet
 * to migrate `Sargon` into iOS/Android clients, thus we will defer the work
 * of mapping `AuthorizedPersonaSimple` -> `AuthorizedPersonaDetailed`.
 */
public struct AuthorizedPersonaSimple {
    /**
     * The globally unique identifier of a Persona is its address, used
     * to lookup persona
     */
    public var identityAddress: IdentityAddress
    /**
     * Date of last login for this persona.
     */
    public var lastLogin: Timestamp
    /**
     * List of "ongoing accountAddresses" that user given the dApp access to.
     */
    public var sharedAccounts: SharedToDappWithPersonaAccountAddresses?
    /**
     * ID to PersonaData entries to user has shared with a Dapp.
     */
    public var sharedPersonaData: SharedPersonaData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The globally unique identifier of a Persona is its address, used
         * to lookup persona
         */ identityAddress: IdentityAddress,
        /**
            * Date of last login for this persona.
            */ lastLogin: Timestamp,
        /**
            * List of "ongoing accountAddresses" that user given the dApp access to.
            */ sharedAccounts: SharedToDappWithPersonaAccountAddresses?,
        /**
            * ID to PersonaData entries to user has shared with a Dapp.
            */ sharedPersonaData: SharedPersonaData
    ) {
        self.identityAddress = identityAddress
        self.lastLogin = lastLogin
        self.sharedAccounts = sharedAccounts
        self.sharedPersonaData = sharedPersonaData
    }
}

extension AuthorizedPersonaSimple: Sendable {}
extension AuthorizedPersonaSimple: Equatable, Hashable {
    public static func == (lhs: AuthorizedPersonaSimple, rhs: AuthorizedPersonaSimple) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.lastLogin != rhs.lastLogin {
            return false
        }
        if lhs.sharedAccounts != rhs.sharedAccounts {
            return false
        }
        if lhs.sharedPersonaData != rhs.sharedPersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(lastLogin)
        hasher.combine(sharedAccounts)
        hasher.combine(sharedPersonaData)
    }
}

public struct FfiConverterTypeAuthorizedPersonaSimple: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedPersonaSimple {
        return
            try AuthorizedPersonaSimple(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
                lastLogin: FfiConverterTypeTimestamp.read(from: &buf),
                sharedAccounts: FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses.read(from: &buf),
                sharedPersonaData: FfiConverterTypeSharedPersonaData.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedPersonaSimple, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastLogin, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses.write(value.sharedAccounts, into: &buf)
        FfiConverterTypeSharedPersonaData.write(value.sharedPersonaData, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedPersonaSimple_lift(_ buf: RustBuffer) throws -> AuthorizedPersonaSimple {
    return try FfiConverterTypeAuthorizedPersonaSimple.lift(buf)
}

public func FfiConverterTypeAuthorizedPersonaSimple_lower(_ value: AuthorizedPersonaSimple) -> RustBuffer {
    return FfiConverterTypeAuthorizedPersonaSimple.lower(value)
}

/**
 * A BIP39 seed for hierarchal deterministic wallets, as per the [BIP39 standard][doc].
 *
 * We typically obtain this by calling [`to_seed` on `MnemonicWithPassphrase`][MnemonicWithPassphrase::to_seed].
 *
 * [doc]: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#user-content-From_mnemonic_to_seed
 */
public struct Bip39Seed {
    fileprivate let secretMagic: Bip39SeedSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Bip39SeedSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Bip39Seed: Sendable {}
extension Bip39Seed: Equatable, Hashable {
    public static func == (lhs: Bip39Seed, rhs: Bip39Seed) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeBIP39Seed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Seed {
        return
            try Bip39Seed(
                secretMagic: FfiConverterTypeBIP39SeedSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Bip39Seed, into buf: inout [UInt8]) {
        FfiConverterTypeBIP39SeedSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeBIP39Seed_lift(_ buf: RustBuffer) throws -> Bip39Seed {
    return try FfiConverterTypeBIP39Seed.lift(buf)
}

public func FfiConverterTypeBIP39Seed_lower(_ value: Bip39Seed) -> RustBuffer {
    return FfiConverterTypeBIP39Seed.lower(value)
}

/**
 * A word in the BIP39 word list of `language` at known `index` (0-2047).
 */
public struct Bip39Word {
    public var word: String
    public var index: U11
    public var language: Bip39Language

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(word: String, index: U11, language: Bip39Language) {
        self.word = word
        self.index = index
        self.language = language
    }
}

extension Bip39Word: Sendable {}
extension Bip39Word: Equatable, Hashable {
    public static func == (lhs: Bip39Word, rhs: Bip39Word) -> Bool {
        if lhs.word != rhs.word {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(word)
        hasher.combine(index)
        hasher.combine(language)
    }
}

public struct FfiConverterTypeBIP39Word: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Word {
        return
            try Bip39Word(
                word: FfiConverterString.read(from: &buf),
                index: FfiConverterTypeU11.read(from: &buf),
                language: FfiConverterTypeBIP39Language.read(from: &buf)
            )
    }

    public static func write(_ value: Bip39Word, into buf: inout [UInt8]) {
        FfiConverterString.write(value.word, into: &buf)
        FfiConverterTypeU11.write(value.index, into: &buf)
        FfiConverterTypeBIP39Language.write(value.language, into: &buf)
    }
}

public func FfiConverterTypeBIP39Word_lift(_ buf: RustBuffer) throws -> Bip39Word {
    return try FfiConverterTypeBIP39Word.lift(buf)
}

public func FfiConverterTypeBIP39Word_lower(_ value: Bip39Word) -> RustBuffer {
    return FfiConverterTypeBIP39Word.lower(value)
}

/**
 * Either a canonical BIP44 derivation path like so:
 *
 * `m / purpose' / coin_type' / account' / change / address_index`
 *
 * Or an Radix Olympia BIP44 "like" path, where the `address_index` accidentally
 * was made hardened, i.e.:
 *
 * `m / purpose' / coin_type' / account' / change / address_index'`
 *
 * This was a mistake made during implementation of Radix Olympia.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * fn parse(s: &str) -> Result<BIP44LikePath> {
 * s.parse::<BIP44LikePath>()
 * }
 *
 * assert!(parse("m/44'/1022'/0'/0/0").is_ok()); // Canonical BIP44
 * assert!(parse("m/44'/1022'/0'/0/0'").is_ok()); // BIP44 like
 *
 * assert_eq!(parse("m/44'/1022'/0'/0'/0"), Err(CommonError::InvalidBIP44LikePathChangeWasUnexpectedlyHardened));
 * assert_eq!(parse("m/44'/1022'/0'/0'/0'"), Err(CommonError::InvalidBIP44LikePathChangeWasUnexpectedlyHardened));
 * assert_eq!(parse("m/44'/0'/0'/0/0'"), Err(CommonError::CoinTypeNotFound { bad_value: 0 }));
 * ```
 */
public struct Bip44LikePath {
    public var path: HdPath

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: HdPath) {
        self.path = path
    }
}

extension Bip44LikePath: Sendable {}
extension Bip44LikePath: Equatable, Hashable {
    public static func == (lhs: Bip44LikePath, rhs: Bip44LikePath) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
    }
}

public struct FfiConverterTypeBIP44LikePath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip44LikePath {
        return
            try Bip44LikePath(
                path: FfiConverterTypeHDPath.read(from: &buf)
            )
    }

    public static func write(_ value: Bip44LikePath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPath.write(value.path, into: &buf)
    }
}

public func FfiConverterTypeBIP44LikePath_lift(_ buf: RustBuffer) throws -> Bip44LikePath {
    return try FfiConverterTypeBIP44LikePath.lift(buf)
}

public func FfiConverterTypeBIP44LikePath_lower(_ value: Bip44LikePath) -> RustBuffer {
    return FfiConverterTypeBIP44LikePath.lower(value)
}

/**
 * Blob is a wrapper a bag of bytes
 */
public struct Blob {
    fileprivate let secretMagic: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BagOfBytes) {
        self.secretMagic = secretMagic
    }
}

extension Blob: Sendable {}
extension Blob: Equatable, Hashable {
    public static func == (lhs: Blob, rhs: Blob) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeBlob: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Blob {
        return
            try Blob(
                secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Blob, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeBlob_lift(_ buf: RustBuffer) throws -> Blob {
    return try FfiConverterTypeBlob.lift(buf)
}

public func FfiConverterTypeBlob_lower(_ value: Blob) -> RustBuffer {
    return FfiConverterTypeBlob.lower(value)
}

/**
 * Vec of Blobs
 */
public struct Blobs {
    fileprivate let secretMagic: BlobsSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BlobsSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Blobs: Sendable {}
extension Blobs: Equatable, Hashable {
    public static func == (lhs: Blobs, rhs: Blobs) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeBlobs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Blobs {
        return
            try Blobs(
                secretMagic: FfiConverterTypeBlobsSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Blobs, into buf: inout [UInt8]) {
        FfiConverterTypeBlobsSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeBlobs_lift(_ buf: RustBuffer) throws -> Blobs {
    return try FfiConverterTypeBlobs.lift(buf)
}

public func FfiConverterTypeBlobs_lower(_ value: Blobs) -> RustBuffer {
    return FfiConverterTypeBlobs.lower(value)
}

/**
 * Vec of Blobs
 */
public struct BlobsSecretMagic {
    fileprivate let secretMagic: [Blob]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: [Blob]) {
        self.secretMagic = secretMagic
    }
}

extension BlobsSecretMagic: Sendable {}
extension BlobsSecretMagic: Equatable, Hashable {
    public static func == (lhs: BlobsSecretMagic, rhs: BlobsSecretMagic) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeBlobsSecretMagic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlobsSecretMagic {
        return
            try BlobsSecretMagic(
                secretMagic: FfiConverterSequenceTypeBlob.read(from: &buf)
            )
    }

    public static func write(_ value: BlobsSecretMagic, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBlob.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeBlobsSecretMagic_lift(_ buf: RustBuffer) throws -> BlobsSecretMagic {
    return try FfiConverterTypeBlobsSecretMagic.lift(buf)
}

public func FfiConverterTypeBlobsSecretMagic_lower(_ value: BlobsSecretMagic) -> RustBuffer {
    return FfiConverterTypeBlobsSecretMagic.lower(value)
}

/**
 * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
 * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
 * contain elements with the same value, but under different IDs.
 */
public struct CollectionOfEmailAddresses {
    public var collection: [PersonaDataIdentifiedEmailAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(collection: [PersonaDataIdentifiedEmailAddress]) {
        self.collection = collection
    }
}

extension CollectionOfEmailAddresses: Sendable {}
extension CollectionOfEmailAddresses: Equatable, Hashable {
    public static func == (lhs: CollectionOfEmailAddresses, rhs: CollectionOfEmailAddresses) -> Bool {
        if lhs.collection != rhs.collection {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(collection)
    }
}

public struct FfiConverterTypeCollectionOfEmailAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionOfEmailAddresses {
        return
            try CollectionOfEmailAddresses(
                collection: FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress.read(from: &buf)
            )
    }

    public static func write(_ value: CollectionOfEmailAddresses, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress.write(value.collection, into: &buf)
    }
}

public func FfiConverterTypeCollectionOfEmailAddresses_lift(_ buf: RustBuffer) throws -> CollectionOfEmailAddresses {
    return try FfiConverterTypeCollectionOfEmailAddresses.lift(buf)
}

public func FfiConverterTypeCollectionOfEmailAddresses_lower(_ value: CollectionOfEmailAddresses) -> RustBuffer {
    return FfiConverterTypeCollectionOfEmailAddresses.lower(value)
}

/**
 * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
 * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
 * contain elements with the same value, but under different IDs.
 */
public struct CollectionOfPhoneNumbers {
    public var collection: [PersonaDataIdentifiedPhoneNumber]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(collection: [PersonaDataIdentifiedPhoneNumber]) {
        self.collection = collection
    }
}

extension CollectionOfPhoneNumbers: Sendable {}
extension CollectionOfPhoneNumbers: Equatable, Hashable {
    public static func == (lhs: CollectionOfPhoneNumbers, rhs: CollectionOfPhoneNumbers) -> Bool {
        if lhs.collection != rhs.collection {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(collection)
    }
}

public struct FfiConverterTypeCollectionOfPhoneNumbers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionOfPhoneNumbers {
        return
            try CollectionOfPhoneNumbers(
                collection: FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber.read(from: &buf)
            )
    }

    public static func write(_ value: CollectionOfPhoneNumbers, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber.write(value.collection, into: &buf)
    }
}

public func FfiConverterTypeCollectionOfPhoneNumbers_lift(_ buf: RustBuffer) throws -> CollectionOfPhoneNumbers {
    return try FfiConverterTypeCollectionOfPhoneNumbers.lift(buf)
}

public func FfiConverterTypeCollectionOfPhoneNumbers_lower(_ value: CollectionOfPhoneNumbers) -> RustBuffer {
    return FfiConverterTypeCollectionOfPhoneNumbers.lower(value)
}

public struct CompiledNotarizedIntent {
    fileprivate let secretMagic: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BagOfBytes) {
        self.secretMagic = secretMagic
    }
}

extension CompiledNotarizedIntent: Sendable {}
extension CompiledNotarizedIntent: Equatable, Hashable {
    public static func == (lhs: CompiledNotarizedIntent, rhs: CompiledNotarizedIntent) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeCompiledNotarizedIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompiledNotarizedIntent {
        return
            try CompiledNotarizedIntent(
                secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: CompiledNotarizedIntent, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeCompiledNotarizedIntent_lift(_ buf: RustBuffer) throws -> CompiledNotarizedIntent {
    return try FfiConverterTypeCompiledNotarizedIntent.lift(buf)
}

public func FfiConverterTypeCompiledNotarizedIntent_lower(_ value: CompiledNotarizedIntent) -> RustBuffer {
    return FfiConverterTypeCompiledNotarizedIntent.lower(value)
}

/**
 * An address to some On-Ledger (OnNetwork) component, e.g. a Dapp, being an instantiation
 * of some Scrypto blueprint, e.g:
 * `"component_rdx1cptxxxxxxxxxfaucetxxxxxxxxx000527798379xxxxxxxxxfaucet"`
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of ComponentAddress:
 * * GlobalGenericComponent
 * * InternalGenericComponent
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalComponentAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L243-L246
 */
public struct ComponentAddress {
    fileprivate let secretMagic: RetComponentAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetComponentAddress) {
        self.secretMagic = secretMagic
    }
}

extension ComponentAddress: Sendable {}
extension ComponentAddress: Equatable, Hashable {
    public static func == (lhs: ComponentAddress, rhs: ComponentAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeComponentAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComponentAddress {
        return
            try ComponentAddress(
                secretMagic: FfiConverterTypeRetComponentAddress.read(from: &buf)
            )
    }

    public static func write(_ value: ComponentAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetComponentAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeComponentAddress_lift(_ buf: RustBuffer) throws -> ComponentAddress {
    return try FfiConverterTypeComponentAddress.lift(buf)
}

public func FfiConverterTypeComponentAddress_lower(_ value: ComponentAddress) -> RustBuffer {
    return FfiConverterTypeComponentAddress.lower(value)
}

/**
 * A hint describing the contents of a Profile, acting as a
 * summary of a Profile used by a ProfileSnapshot Header.
 *
 * Important to know that this is just a **hint**, the values
 * SHOULD be kept up to date, might might not be, since they
 * are stored values which must be kept in sync.
 */
public struct ContentHint {
    /**
     * The total number of accounts on all networks.
     *
     * Important to remember that this is a counter inside a
     * content **hint**. This counter SHOULD be update when
     * new accounts are created, but failing to do is of no
     * real consequence.
     *
     * This counter includes any by user hidden accounts.
     */
    public var numberOfAccountsOnAllNetworksInTotal: UInt16
    /**
     * The total number of personas on all networks.
     *
     * Important to remember that this is a counter inside a
     * content **hint**. This counter SHOULD be update when
     * new accounts are created, but failing to do is of no
     * real consequence.
     *
     * This counter includes any by user hidden personas.
     */
    public var numberOfPersonasOnAllNetworksInTotal: UInt16
    /**
     * The total number of networks that the user has used, i.e.
     * on which she has any accounts or personas.
     */
    public var numberOfNetworks: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The total number of accounts on all networks.
         *
         * Important to remember that this is a counter inside a
         * content **hint**. This counter SHOULD be update when
         * new accounts are created, but failing to do is of no
         * real consequence.
         *
         * This counter includes any by user hidden accounts.
         */ numberOfAccountsOnAllNetworksInTotal: UInt16,
        /**
            * The total number of personas on all networks.
            *
            * Important to remember that this is a counter inside a
            * content **hint**. This counter SHOULD be update when
            * new accounts are created, but failing to do is of no
            * real consequence.
            *
            * This counter includes any by user hidden personas.
            */ numberOfPersonasOnAllNetworksInTotal: UInt16,
        /**
            * The total number of networks that the user has used, i.e.
            * on which she has any accounts or personas.
            */ numberOfNetworks: UInt16
    ) {
        self.numberOfAccountsOnAllNetworksInTotal = numberOfAccountsOnAllNetworksInTotal
        self.numberOfPersonasOnAllNetworksInTotal = numberOfPersonasOnAllNetworksInTotal
        self.numberOfNetworks = numberOfNetworks
    }
}

extension ContentHint: Sendable {}
extension ContentHint: Equatable, Hashable {
    public static func == (lhs: ContentHint, rhs: ContentHint) -> Bool {
        if lhs.numberOfAccountsOnAllNetworksInTotal != rhs.numberOfAccountsOnAllNetworksInTotal {
            return false
        }
        if lhs.numberOfPersonasOnAllNetworksInTotal != rhs.numberOfPersonasOnAllNetworksInTotal {
            return false
        }
        if lhs.numberOfNetworks != rhs.numberOfNetworks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numberOfAccountsOnAllNetworksInTotal)
        hasher.combine(numberOfPersonasOnAllNetworksInTotal)
        hasher.combine(numberOfNetworks)
    }
}

public struct FfiConverterTypeContentHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContentHint {
        return
            try ContentHint(
                numberOfAccountsOnAllNetworksInTotal: FfiConverterUInt16.read(from: &buf),
                numberOfPersonasOnAllNetworksInTotal: FfiConverterUInt16.read(from: &buf),
                numberOfNetworks: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: ContentHint, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.numberOfAccountsOnAllNetworksInTotal, into: &buf)
        FfiConverterUInt16.write(value.numberOfPersonasOnAllNetworksInTotal, into: &buf)
        FfiConverterUInt16.write(value.numberOfNetworks, into: &buf)
    }
}

public func FfiConverterTypeContentHint_lift(_ buf: RustBuffer) throws -> ContentHint {
    return try FfiConverterTypeContentHint.lift(buf)
}

public func FfiConverterTypeContentHint_lower(_ value: ContentHint) -> RustBuffer {
    return FfiConverterTypeContentHint.lower(value)
}

public struct DappToWalletInteraction {
    public var interactionId: WalletInteractionId
    public var items: DappToWalletInteractionItems
    public var metadata: DappToWalletInteractionMetadata

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, items: DappToWalletInteractionItems, metadata: DappToWalletInteractionMetadata) {
        self.interactionId = interactionId
        self.items = items
        self.metadata = metadata
    }
}

extension DappToWalletInteraction: Sendable {}
extension DappToWalletInteraction: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteraction, rhs: DappToWalletInteraction) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(items)
        hasher.combine(metadata)
    }
}

public struct FfiConverterTypeDappToWalletInteraction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteraction {
        return
            try DappToWalletInteraction(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                items: FfiConverterTypeDappToWalletInteractionItems.read(from: &buf),
                metadata: FfiConverterTypeDappToWalletInteractionMetadata.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteraction, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeDappToWalletInteractionItems.write(value.items, into: &buf)
        FfiConverterTypeDappToWalletInteractionMetadata.write(value.metadata, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteraction_lift(_ buf: RustBuffer) throws -> DappToWalletInteraction {
    return try FfiConverterTypeDappToWalletInteraction.lift(buf)
}

public func FfiConverterTypeDappToWalletInteraction_lower(_ value: DappToWalletInteraction) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteraction.lower(value)
}

public struct DappToWalletInteractionAccountsRequestItem {
    public var numberOfAccounts: RequestedQuantity
    public var challenge: Exactly32Bytes?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(numberOfAccounts: RequestedQuantity, challenge: Exactly32Bytes?) {
        self.numberOfAccounts = numberOfAccounts
        self.challenge = challenge
    }
}

extension DappToWalletInteractionAccountsRequestItem: Sendable {}
extension DappToWalletInteractionAccountsRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionAccountsRequestItem, rhs: DappToWalletInteractionAccountsRequestItem) -> Bool {
        if lhs.numberOfAccounts != rhs.numberOfAccounts {
            return false
        }
        if lhs.challenge != rhs.challenge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numberOfAccounts)
        hasher.combine(challenge)
    }
}

public struct FfiConverterTypeDappToWalletInteractionAccountsRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAccountsRequestItem {
        return
            try DappToWalletInteractionAccountsRequestItem(
                numberOfAccounts: FfiConverterTypeRequestedQuantity.read(from: &buf),
                challenge: FfiConverterOptionTypeExactly32Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionAccountsRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.numberOfAccounts, into: &buf)
        FfiConverterOptionTypeExactly32Bytes.write(value.challenge, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionAccountsRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAccountsRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAccountsRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAccountsRequestItem_lower(_ value: DappToWalletInteractionAccountsRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAccountsRequestItem.lower(value)
}

public struct DappToWalletInteractionAuthLoginWithChallengeRequestItem {
    public var challenge: Exactly32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(challenge: Exactly32Bytes) {
        self.challenge = challenge
    }
}

extension DappToWalletInteractionAuthLoginWithChallengeRequestItem: Sendable {}
extension DappToWalletInteractionAuthLoginWithChallengeRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionAuthLoginWithChallengeRequestItem, rhs: DappToWalletInteractionAuthLoginWithChallengeRequestItem) -> Bool {
        if lhs.challenge != rhs.challenge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challenge)
    }
}

public struct FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthLoginWithChallengeRequestItem {
        return
            try DappToWalletInteractionAuthLoginWithChallengeRequestItem(
                challenge: FfiConverterTypeExactly32Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionAuthLoginWithChallengeRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeExactly32Bytes.write(value.challenge, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthLoginWithChallengeRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem_lower(_ value: DappToWalletInteractionAuthLoginWithChallengeRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.lower(value)
}

public struct DappToWalletInteractionAuthUsePersonaRequestItem {
    public var identityAddress: IdentityAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityAddress: IdentityAddress) {
        self.identityAddress = identityAddress
    }
}

extension DappToWalletInteractionAuthUsePersonaRequestItem: Sendable {}
extension DappToWalletInteractionAuthUsePersonaRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionAuthUsePersonaRequestItem, rhs: DappToWalletInteractionAuthUsePersonaRequestItem) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
    }
}

public struct FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthUsePersonaRequestItem {
        return
            try DappToWalletInteractionAuthUsePersonaRequestItem(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionAuthUsePersonaRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthUsePersonaRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem_lower(_ value: DappToWalletInteractionAuthUsePersonaRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.lower(value)
}

public struct DappToWalletInteractionAuthorizedRequestItems {
    public var auth: DappToWalletInteractionAuthRequestItem
    public var reset: DappToWalletInteractionResetRequestItem?
    public var ongoingAccounts: DappToWalletInteractionAccountsRequestItem?
    public var ongoingPersonaData: DappToWalletInteractionPersonaDataRequestItem?
    public var oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?
    public var oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(auth: DappToWalletInteractionAuthRequestItem, reset: DappToWalletInteractionResetRequestItem?, ongoingAccounts: DappToWalletInteractionAccountsRequestItem?, ongoingPersonaData: DappToWalletInteractionPersonaDataRequestItem?, oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?, oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?) {
        self.auth = auth
        self.reset = reset
        self.ongoingAccounts = ongoingAccounts
        self.ongoingPersonaData = ongoingPersonaData
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
    }
}

extension DappToWalletInteractionAuthorizedRequestItems: Sendable {}
extension DappToWalletInteractionAuthorizedRequestItems: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionAuthorizedRequestItems, rhs: DappToWalletInteractionAuthorizedRequestItems) -> Bool {
        if lhs.auth != rhs.auth {
            return false
        }
        if lhs.reset != rhs.reset {
            return false
        }
        if lhs.ongoingAccounts != rhs.ongoingAccounts {
            return false
        }
        if lhs.ongoingPersonaData != rhs.ongoingPersonaData {
            return false
        }
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(auth)
        hasher.combine(reset)
        hasher.combine(ongoingAccounts)
        hasher.combine(ongoingPersonaData)
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
    }
}

public struct FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthorizedRequestItems {
        return
            try DappToWalletInteractionAuthorizedRequestItems(
                auth: FfiConverterTypeDappToWalletInteractionAuthRequestItem.read(from: &buf),
                reset: FfiConverterOptionTypeDappToWalletInteractionResetRequestItem.read(from: &buf),
                ongoingAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf),
                ongoingPersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf),
                oneTimeAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf),
                oneTimePersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionAuthorizedRequestItems, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionAuthRequestItem.write(value.auth, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionResetRequestItem.write(value.reset, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.ongoingAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.ongoingPersonaData, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.oneTimePersonaData, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthorizedRequestItems {
    return try FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems_lower(_ value: DappToWalletInteractionAuthorizedRequestItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.lower(value)
}

public struct DappToWalletInteractionMetadata {
    public var version: WalletInteractionVersion
    public var networkId: NetworkId
    public var origin: Url
    public var dappDefinitionAddress: AccountAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: WalletInteractionVersion, networkId: NetworkId, origin: Url, dappDefinitionAddress: AccountAddress) {
        self.version = version
        self.networkId = networkId
        self.origin = origin
        self.dappDefinitionAddress = dappDefinitionAddress
    }
}

extension DappToWalletInteractionMetadata: Sendable {}
extension DappToWalletInteractionMetadata: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionMetadata, rhs: DappToWalletInteractionMetadata) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(networkId)
        hasher.combine(origin)
        hasher.combine(dappDefinitionAddress)
    }
}

public struct FfiConverterTypeDappToWalletInteractionMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionMetadata {
        return
            try DappToWalletInteractionMetadata(
                version: FfiConverterTypeWalletInteractionVersion.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                origin: FfiConverterTypeUrl.read(from: &buf),
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionVersion.write(value.version, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeUrl.write(value.origin, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionMetadata_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionMetadata {
    return try FfiConverterTypeDappToWalletInteractionMetadata.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionMetadata_lower(_ value: DappToWalletInteractionMetadata) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionMetadata.lower(value)
}

public struct DappToWalletInteractionMetadataUnvalidated {
    public var version: WalletInteractionVersion
    public var networkId: NetworkId
    public var origin: Url
    public var dappDefinitionAddress: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: WalletInteractionVersion, networkId: NetworkId, origin: Url, dappDefinitionAddress: String) {
        self.version = version
        self.networkId = networkId
        self.origin = origin
        self.dappDefinitionAddress = dappDefinitionAddress
    }
}

extension DappToWalletInteractionMetadataUnvalidated: Sendable {}
extension DappToWalletInteractionMetadataUnvalidated: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionMetadataUnvalidated, rhs: DappToWalletInteractionMetadataUnvalidated) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(networkId)
        hasher.combine(origin)
        hasher.combine(dappDefinitionAddress)
    }
}

public struct FfiConverterTypeDappToWalletInteractionMetadataUnvalidated: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionMetadataUnvalidated {
        return
            try DappToWalletInteractionMetadataUnvalidated(
                version: FfiConverterTypeWalletInteractionVersion.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                origin: FfiConverterTypeUrl.read(from: &buf),
                dappDefinitionAddress: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionMetadataUnvalidated, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionVersion.write(value.version, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeUrl.write(value.origin, into: &buf)
        FfiConverterString.write(value.dappDefinitionAddress, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionMetadataUnvalidated_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionMetadataUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionMetadataUnvalidated_lower(_ value: DappToWalletInteractionMetadataUnvalidated) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.lower(value)
}

public struct DappToWalletInteractionPersonaDataRequestItem {
    public var isRequestingName: Bool?
    public var numberOfRequestedEmailAddresses: RequestedQuantity?
    public var numberOfRequestedPhoneNumbers: RequestedQuantity?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isRequestingName: Bool?, numberOfRequestedEmailAddresses: RequestedQuantity?, numberOfRequestedPhoneNumbers: RequestedQuantity?) {
        self.isRequestingName = isRequestingName
        self.numberOfRequestedEmailAddresses = numberOfRequestedEmailAddresses
        self.numberOfRequestedPhoneNumbers = numberOfRequestedPhoneNumbers
    }
}

extension DappToWalletInteractionPersonaDataRequestItem: Sendable {}
extension DappToWalletInteractionPersonaDataRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionPersonaDataRequestItem, rhs: DappToWalletInteractionPersonaDataRequestItem) -> Bool {
        if lhs.isRequestingName != rhs.isRequestingName {
            return false
        }
        if lhs.numberOfRequestedEmailAddresses != rhs.numberOfRequestedEmailAddresses {
            return false
        }
        if lhs.numberOfRequestedPhoneNumbers != rhs.numberOfRequestedPhoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isRequestingName)
        hasher.combine(numberOfRequestedEmailAddresses)
        hasher.combine(numberOfRequestedPhoneNumbers)
    }
}

public struct FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionPersonaDataRequestItem {
        return
            try DappToWalletInteractionPersonaDataRequestItem(
                isRequestingName: FfiConverterOptionBool.read(from: &buf),
                numberOfRequestedEmailAddresses: FfiConverterOptionTypeRequestedQuantity.read(from: &buf),
                numberOfRequestedPhoneNumbers: FfiConverterOptionTypeRequestedQuantity.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionPersonaDataRequestItem, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.isRequestingName, into: &buf)
        FfiConverterOptionTypeRequestedQuantity.write(value.numberOfRequestedEmailAddresses, into: &buf)
        FfiConverterOptionTypeRequestedQuantity.write(value.numberOfRequestedPhoneNumbers, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionPersonaDataRequestItem {
    return try FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem_lower(_ value: DappToWalletInteractionPersonaDataRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.lower(value)
}

public struct DappToWalletInteractionResetRequestItem {
    public var accounts: Bool
    public var personaData: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accounts: Bool, personaData: Bool) {
        self.accounts = accounts
        self.personaData = personaData
    }
}

extension DappToWalletInteractionResetRequestItem: Sendable {}
extension DappToWalletInteractionResetRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionResetRequestItem, rhs: DappToWalletInteractionResetRequestItem) -> Bool {
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.personaData != rhs.personaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accounts)
        hasher.combine(personaData)
    }
}

public struct FfiConverterTypeDappToWalletInteractionResetRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionResetRequestItem {
        return
            try DappToWalletInteractionResetRequestItem(
                accounts: FfiConverterBool.read(from: &buf),
                personaData: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionResetRequestItem, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.accounts, into: &buf)
        FfiConverterBool.write(value.personaData, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionResetRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionResetRequestItem {
    return try FfiConverterTypeDappToWalletInteractionResetRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionResetRequestItem_lower(_ value: DappToWalletInteractionResetRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionResetRequestItem.lower(value)
}

public struct DappToWalletInteractionSendTransactionItem {
    public var transactionManifest: String
    public var version: TxVersion
    public var blobs: [String]?
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionManifest: String, version: TxVersion, blobs: [String]?, message: String?) {
        self.transactionManifest = transactionManifest
        self.version = version
        self.blobs = blobs
        self.message = message
    }
}

extension DappToWalletInteractionSendTransactionItem: Sendable {}
extension DappToWalletInteractionSendTransactionItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionSendTransactionItem, rhs: DappToWalletInteractionSendTransactionItem) -> Bool {
        if lhs.transactionManifest != rhs.transactionManifest {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.blobs != rhs.blobs {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionManifest)
        hasher.combine(version)
        hasher.combine(blobs)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeDappToWalletInteractionSendTransactionItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSendTransactionItem {
        return
            try DappToWalletInteractionSendTransactionItem(
                transactionManifest: FfiConverterString.read(from: &buf),
                version: FfiConverterTypeTXVersion.read(from: &buf),
                blobs: FfiConverterOptionSequenceString.read(from: &buf),
                message: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionSendTransactionItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.transactionManifest, into: &buf)
        FfiConverterTypeTXVersion.write(value.version, into: &buf)
        FfiConverterOptionSequenceString.write(value.blobs, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionSendTransactionItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSendTransactionItem {
    return try FfiConverterTypeDappToWalletInteractionSendTransactionItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSendTransactionItem_lower(_ value: DappToWalletInteractionSendTransactionItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSendTransactionItem.lower(value)
}

public struct DappToWalletInteractionTransactionItems {
    public var send: DappToWalletInteractionSendTransactionItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(send: DappToWalletInteractionSendTransactionItem) {
        self.send = send
    }
}

extension DappToWalletInteractionTransactionItems: Sendable {}
extension DappToWalletInteractionTransactionItems: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionTransactionItems, rhs: DappToWalletInteractionTransactionItems) -> Bool {
        if lhs.send != rhs.send {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(send)
    }
}

public struct FfiConverterTypeDappToWalletInteractionTransactionItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionTransactionItems {
        return
            try DappToWalletInteractionTransactionItems(
                send: FfiConverterTypeDappToWalletInteractionSendTransactionItem.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionTransactionItems, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionSendTransactionItem.write(value.send, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionTransactionItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionTransactionItems {
    return try FfiConverterTypeDappToWalletInteractionTransactionItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionTransactionItems_lower(_ value: DappToWalletInteractionTransactionItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionTransactionItems.lower(value)
}

public struct DappToWalletInteractionUnauthorizedRequestItems {
    public var oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?
    public var oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?, oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?) {
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
    }
}

extension DappToWalletInteractionUnauthorizedRequestItems: Sendable {}
extension DappToWalletInteractionUnauthorizedRequestItems: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionUnauthorizedRequestItems, rhs: DappToWalletInteractionUnauthorizedRequestItems) -> Bool {
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
    }
}

public struct FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionUnauthorizedRequestItems {
        return
            try DappToWalletInteractionUnauthorizedRequestItems(
                oneTimeAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf),
                oneTimePersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionUnauthorizedRequestItems, into buf: inout [UInt8]) {
        FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.oneTimePersonaData, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionUnauthorizedRequestItems {
    return try FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems_lower(_ value: DappToWalletInteractionUnauthorizedRequestItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.lower(value)
}

public struct DappToWalletInteractionUnvalidated {
    public var interactionId: WalletInteractionId
    public var items: DappToWalletInteractionItems
    public var metadata: DappToWalletInteractionMetadataUnvalidated

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, items: DappToWalletInteractionItems, metadata: DappToWalletInteractionMetadataUnvalidated) {
        self.interactionId = interactionId
        self.items = items
        self.metadata = metadata
    }
}

extension DappToWalletInteractionUnvalidated: Sendable {}
extension DappToWalletInteractionUnvalidated: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionUnvalidated, rhs: DappToWalletInteractionUnvalidated) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(items)
        hasher.combine(metadata)
    }
}

public struct FfiConverterTypeDappToWalletInteractionUnvalidated: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionUnvalidated {
        return
            try DappToWalletInteractionUnvalidated(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                items: FfiConverterTypeDappToWalletInteractionItems.read(from: &buf),
                metadata: FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionUnvalidated, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeDappToWalletInteractionItems.write(value.items, into: &buf)
        FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.write(value.metadata, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionUnvalidated_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionUnvalidated.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionUnvalidated_lower(_ value: DappToWalletInteractionUnvalidated) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionUnvalidated.lower(value)
}

public struct DappWalletInteractionPersona {
    public var identityAddress: IdentityAddress
    public var label: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityAddress: IdentityAddress, label: String) {
        self.identityAddress = identityAddress
        self.label = label
    }
}

extension DappWalletInteractionPersona: Sendable {}
extension DappWalletInteractionPersona: Equatable, Hashable {
    public static func == (lhs: DappWalletInteractionPersona, rhs: DappWalletInteractionPersona) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(label)
    }
}

public struct FfiConverterTypeDappWalletInteractionPersona: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappWalletInteractionPersona {
        return
            try DappWalletInteractionPersona(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
                label: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DappWalletInteractionPersona, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
    }
}

public func FfiConverterTypeDappWalletInteractionPersona_lift(_ buf: RustBuffer) throws -> DappWalletInteractionPersona {
    return try FfiConverterTypeDappWalletInteractionPersona.lift(buf)
}

public func FfiConverterTypeDappWalletInteractionPersona_lower(_ value: DappWalletInteractionPersona) -> RustBuffer {
    return FfiConverterTypeDappWalletInteractionPersona.lower(value)
}

/**
 * `Decimal192` represents a 192 bit representation of a fixed-scale decimal number.
 *
 * The finite set of values are of the form `m / 10^18`, where `m` is
 * an integer such that `-2^(192 - 1) <= m < 2^(192 - 1)`.
 *
 * Fractional part: ~60 bits/18 digits
 * Integer part   : 132 bits /40 digits
 * Max            :  3138550867693340381917894711603833208051.177722232017256447
 * Min            : -3138550867693340381917894711603833208051.177722232017256448
 *
 * Unless otherwise specified, all operations will panic if underflow/overflow.
 *
 * Powering it is the [Scrypto Decimal type, see docs][scrypto].
 *
 * Note: This type cannot be called `Decimal`, since it results in naming collision
 * in the Swift land (clash with `Foundation.Decimal`) instead we have created a
 * type alias `Decimal = Decimal192` which we use in Rust land.
 *
 * [scrypto]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/math/decimal.rs#L42
 */
public struct Decimal192 {
    fileprivate let secretMagic: ScryptoDecimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: ScryptoDecimal192) {
        self.secretMagic = secretMagic
    }
}

extension Decimal192: Sendable {}
extension Decimal192: Equatable, Hashable {
    public static func == (lhs: Decimal192, rhs: Decimal192) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeDecimal192: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Decimal192 {
        return
            try Decimal192(
                secretMagic: FfiConverterTypeScryptoDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: Decimal192, into buf: inout [UInt8]) {
        FfiConverterTypeScryptoDecimal192.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeDecimal192_lift(_ buf: RustBuffer) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(buf)
}

public func FfiConverterTypeDecimal192_lower(_ value: Decimal192) -> RustBuffer {
    return FfiConverterTypeDecimal192.lower(value)
}

/**
 * A factor source representing the device that the Radix Wallet is running on
 * typically an iPhone or Android device. This is the initial factor source of
 * all new Accounts and Personas an users authenticate signing by authorizing
 * the client (Wallet App) to access a mnemonic stored in secure storage on
 * the device.
 */
public struct DeviceFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     *
     * Has interior mutability since we must be able to update the
     * last used date.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a DeviceFactorSource to help user disambiguate between it and another one.
     */
    public var hint: DeviceFactorSourceHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            *
            * Has interior mutability since we must be able to update the
            * last used date.
            */ common: FactorSourceCommon,
        /**
            * Properties describing a DeviceFactorSource to help user disambiguate between it and another one.
            */ hint: DeviceFactorSourceHint
    ) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}

extension DeviceFactorSource: Sendable {}
extension DeviceFactorSource: Equatable, Hashable {
    public static func == (lhs: DeviceFactorSource, rhs: DeviceFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}

public struct FfiConverterTypeDeviceFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSource {
        return
            try DeviceFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                hint: FfiConverterTypeDeviceFactorSourceHint.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeDeviceFactorSourceHint.write(value.hint, into: &buf)
    }
}

public func FfiConverterTypeDeviceFactorSource_lift(_ buf: RustBuffer) throws -> DeviceFactorSource {
    return try FfiConverterTypeDeviceFactorSource.lift(buf)
}

public func FfiConverterTypeDeviceFactorSource_lower(_ value: DeviceFactorSource) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSource.lower(value)
}

/**
 * Properties describing a DeviceFactorSource to help user disambiguate between
 * it and another one.
 */
public struct DeviceFactorSourceHint {
    /**
     * "iPhone RED"
     */
    public var name: String
    /**
     * "iPhone SE 2nd gen"
     */
    public var model: String
    /**
     * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
     * standard, a multiple of 3, from 12 to 24 words.
     */
    public var mnemonicWordCount: Bip39WordCount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * "iPhone RED"
         */ name: String,
        /**
            * "iPhone SE 2nd gen"
            */ model: String,
        /**
            * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
            * standard, a multiple of 3, from 12 to 24 words.
            */ mnemonicWordCount: Bip39WordCount
    ) {
        self.name = name
        self.model = model
        self.mnemonicWordCount = mnemonicWordCount
    }
}

extension DeviceFactorSourceHint: Sendable {}
extension DeviceFactorSourceHint: Equatable, Hashable {
    public static func == (lhs: DeviceFactorSourceHint, rhs: DeviceFactorSourceHint) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        if lhs.mnemonicWordCount != rhs.mnemonicWordCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
        hasher.combine(mnemonicWordCount)
    }
}

public struct FfiConverterTypeDeviceFactorSourceHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSourceHint {
        return
            try DeviceFactorSourceHint(
                name: FfiConverterString.read(from: &buf),
                model: FfiConverterString.read(from: &buf),
                mnemonicWordCount: FfiConverterTypeBIP39WordCount.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceFactorSourceHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.model, into: &buf)
        FfiConverterTypeBIP39WordCount.write(value.mnemonicWordCount, into: &buf)
    }
}

public func FfiConverterTypeDeviceFactorSourceHint_lift(_ buf: RustBuffer) throws -> DeviceFactorSourceHint {
    return try FfiConverterTypeDeviceFactorSourceHint.lift(buf)
}

public func FfiConverterTypeDeviceFactorSourceHint_lower(_ value: DeviceFactorSourceHint) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSourceHint.lower(value)
}

/**
 * A short summary of a device the Profile is being used
 * on, typically an iPhone or an Android phone.
 */
public struct DeviceInfo {
    /**
     * A best effort stable and unique identifier of this
     * device.
     *
     * Apple has made it so that iOS devices cannot
     * query iOS for a unique identifier of the device, thus
     * the iOS team has made their own impl of a best effort
     * stable identifier.
     */
    public var id: Uuid
    /**
     * The date this description of the device was made, might
     * be equal to when the app was first ever launched on the
     * device.
     */
    public var date: Timestamp
    /**
     * A short description of the device, we devices should
     * read the device model and a given name from the device
     * if they are able to.
     *
     * E.g. "My Red Phone (iPhone SE 2nd Gen)"
     */
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A best effort stable and unique identifier of this
         * device.
         *
         * Apple has made it so that iOS devices cannot
         * query iOS for a unique identifier of the device, thus
         * the iOS team has made their own impl of a best effort
         * stable identifier.
         */ id: Uuid,
        /**
            * The date this description of the device was made, might
            * be equal to when the app was first ever launched on the
            * device.
            */ date: Timestamp,
        /**
            * A short description of the device, we devices should
            * read the device model and a given name from the device
            * if they are able to.
            *
            * E.g. "My Red Phone (iPhone SE 2nd Gen)"
            */ description: String
    ) {
        self.id = id
        self.date = date
        self.description = description
    }
}

extension DeviceInfo: Sendable {}
extension DeviceInfo: Equatable, Hashable {
    public static func == (lhs: DeviceInfo, rhs: DeviceInfo) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.date != rhs.date {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(date)
        hasher.combine(description)
    }
}

public struct FfiConverterTypeDeviceInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceInfo {
        return
            try DeviceInfo(
                id: FfiConverterTypeUuid.read(from: &buf),
                date: FfiConverterTypeTimestamp.read(from: &buf),
                description: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceInfo, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeTimestamp.write(value.date, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}

public func FfiConverterTypeDeviceInfo_lift(_ buf: RustBuffer) throws -> DeviceInfo {
    return try FfiConverterTypeDeviceInfo.lift(buf)
}

public func FfiConverterTypeDeviceInfo_lower(_ value: DeviceInfo) -> RustBuffer {
    return FfiConverterTypeDeviceInfo.lower(value)
}

/**
 * A max 30 chars long string used for display purposes, e.g.
 * the name of an Account or Persona.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 * #[allow(clippy::upper_case_acronyms)]
 * type SUT = DisplayName;
 *
 * assert_eq!(SUT::MAX_LEN, 30);
 * assert_eq!("Satoshi".parse::<SUT>().unwrap().to_string(), "Satoshi");
 * ```

 */
public struct DisplayName {
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: String) {
        self.value = value
    }
}

extension DisplayName: Sendable {}
extension DisplayName: Equatable, Hashable {
    public static func == (lhs: DisplayName, rhs: DisplayName) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeDisplayName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DisplayName {
        return
            try DisplayName(
                value: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DisplayName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeDisplayName_lift(_ buf: RustBuffer) throws -> DisplayName {
    return try FfiConverterTypeDisplayName.lift(buf)
}

public func FfiConverterTypeDisplayName_lower(_ value: DisplayName) -> RustBuffer {
    return FfiConverterTypeDisplayName.lower(value)
}

/**
 * An Ed25519 public key used to verify cryptographic signatures (EdDSA signatures).
 */
public struct Ed25519PublicKey {
    fileprivate let secretMagic: ScryptoEd25519PublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: ScryptoEd25519PublicKey) {
        self.secretMagic = secretMagic
    }
}

extension Ed25519PublicKey: Sendable {}
extension Ed25519PublicKey: Equatable, Hashable {
    public static func == (lhs: Ed25519PublicKey, rhs: Ed25519PublicKey) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEd25519PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519PublicKey {
        return
            try Ed25519PublicKey(
                secretMagic: FfiConverterTypeScryptoEd25519PublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: Ed25519PublicKey, into buf: inout [UInt8]) {
        FfiConverterTypeScryptoEd25519PublicKey.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEd25519PublicKey_lift(_ buf: RustBuffer) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(buf)
}

public func FfiConverterTypeEd25519PublicKey_lower(_ value: Ed25519PublicKey) -> RustBuffer {
    return FfiConverterTypeEd25519PublicKey.lower(value)
}

/**
 * Represents an ED25519 signature.
 */
public struct Ed25519Signature {
    public var bytes: Exactly64Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Exactly64Bytes) {
        self.bytes = bytes
    }
}

extension Ed25519Signature: Sendable {}
extension Ed25519Signature: Equatable, Hashable {
    public static func == (lhs: Ed25519Signature, rhs: Ed25519Signature) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}

public struct FfiConverterTypeEd25519Signature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519Signature {
        return
            try Ed25519Signature(
                bytes: FfiConverterTypeExactly64Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: Ed25519Signature, into buf: inout [UInt8]) {
        FfiConverterTypeExactly64Bytes.write(value.bytes, into: &buf)
    }
}

public func FfiConverterTypeEd25519Signature_lift(_ buf: RustBuffer) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(buf)
}

public func FfiConverterTypeEd25519Signature_lower(_ value: Ed25519Signature) -> RustBuffer {
    return FfiConverterTypeEd25519Signature.lower(value)
}

public struct Entropy16Bytes {
    fileprivate let secretMagic: Entropy16BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Entropy16BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Entropy16Bytes: Sendable {}
extension Entropy16Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy16Bytes, rhs: Entropy16Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEntropy16Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy16Bytes {
        return
            try Entropy16Bytes(
                secretMagic: FfiConverterTypeEntropy16BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy16Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeEntropy16BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEntropy16Bytes_lift(_ buf: RustBuffer) throws -> Entropy16Bytes {
    return try FfiConverterTypeEntropy16Bytes.lift(buf)
}

public func FfiConverterTypeEntropy16Bytes_lower(_ value: Entropy16Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy16Bytes.lower(value)
}

public struct Entropy20Bytes {
    fileprivate let secretMagic: Entropy20BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Entropy20BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Entropy20Bytes: Sendable {}
extension Entropy20Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy20Bytes, rhs: Entropy20Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEntropy20Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy20Bytes {
        return
            try Entropy20Bytes(
                secretMagic: FfiConverterTypeEntropy20BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy20Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeEntropy20BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEntropy20Bytes_lift(_ buf: RustBuffer) throws -> Entropy20Bytes {
    return try FfiConverterTypeEntropy20Bytes.lift(buf)
}

public func FfiConverterTypeEntropy20Bytes_lower(_ value: Entropy20Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy20Bytes.lower(value)
}

public struct Entropy24Bytes {
    fileprivate let secretMagic: Entropy24BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Entropy24BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Entropy24Bytes: Sendable {}
extension Entropy24Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy24Bytes, rhs: Entropy24Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEntropy24Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy24Bytes {
        return
            try Entropy24Bytes(
                secretMagic: FfiConverterTypeEntropy24BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy24Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeEntropy24BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEntropy24Bytes_lift(_ buf: RustBuffer) throws -> Entropy24Bytes {
    return try FfiConverterTypeEntropy24Bytes.lift(buf)
}

public func FfiConverterTypeEntropy24Bytes_lower(_ value: Entropy24Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy24Bytes.lower(value)
}

public struct Entropy28Bytes {
    fileprivate let secretMagic: Entropy28BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Entropy28BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Entropy28Bytes: Sendable {}
extension Entropy28Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy28Bytes, rhs: Entropy28Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEntropy28Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy28Bytes {
        return
            try Entropy28Bytes(
                secretMagic: FfiConverterTypeEntropy28BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy28Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeEntropy28BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEntropy28Bytes_lift(_ buf: RustBuffer) throws -> Entropy28Bytes {
    return try FfiConverterTypeEntropy28Bytes.lift(buf)
}

public func FfiConverterTypeEntropy28Bytes_lower(_ value: Entropy28Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy28Bytes.lower(value)
}

public struct Entropy32Bytes {
    fileprivate let secretMagic: Entropy32BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Entropy32BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Entropy32Bytes: Sendable {}
extension Entropy32Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy32Bytes, rhs: Entropy32Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEntropy32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy32Bytes {
        return
            try Entropy32Bytes(
                secretMagic: FfiConverterTypeEntropy32BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeEntropy32BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEntropy32Bytes_lift(_ buf: RustBuffer) throws -> Entropy32Bytes {
    return try FfiConverterTypeEntropy32Bytes.lift(buf)
}

public func FfiConverterTypeEntropy32Bytes_lower(_ value: Entropy32Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy32Bytes.lower(value)
}

/**
 * 12 bytes, used by AES encryption, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly12Bytes {
    fileprivate let secretMagic: Exactly12BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly12BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly12Bytes: Sendable {}
extension Exactly12Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly12Bytes, rhs: Exactly12Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly12Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly12Bytes {
        return
            try Exactly12Bytes(
                secretMagic: FfiConverterTypeExactly12BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly12Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly12BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly12Bytes_lift(_ buf: RustBuffer) throws -> Exactly12Bytes {
    return try FfiConverterTypeExactly12Bytes.lift(buf)
}

public func FfiConverterTypeExactly12Bytes_lower(_ value: Exactly12Bytes) -> RustBuffer {
    return FfiConverterTypeExactly12Bytes.lower(value)
}

/**
 * 29 bytes, typically used as PublicKeyHash, or otherwise NodeId payload,
 * implementation wise those bytes are stored inside a `BagOfBytes`
 * (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly29Bytes {
    fileprivate let secretMagic: Exactly29BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly29BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly29Bytes: Sendable {}
extension Exactly29Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly29Bytes, rhs: Exactly29Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly29Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly29Bytes {
        return
            try Exactly29Bytes(
                secretMagic: FfiConverterTypeExactly29BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly29Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly29BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly29Bytes_lift(_ buf: RustBuffer) throws -> Exactly29Bytes {
    return try FfiConverterTypeExactly29Bytes.lift(buf)
}

public func FfiConverterTypeExactly29Bytes_lower(_ value: Exactly29Bytes) -> RustBuffer {
    return FfiConverterTypeExactly29Bytes.lower(value)
}

/**
 * 32 bytes, most commonly used fixed length bytes, used by PrivateKeys,
 * Ed25519PublicKey, and BIP39 entropy, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly32Bytes {
    fileprivate let secretMagic: Exactly32BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly32BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly32Bytes: Sendable {}
extension Exactly32Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly32Bytes, rhs: Exactly32Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly32Bytes {
        return
            try Exactly32Bytes(
                secretMagic: FfiConverterTypeExactly32BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly32BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly32Bytes_lift(_ buf: RustBuffer) throws -> Exactly32Bytes {
    return try FfiConverterTypeExactly32Bytes.lift(buf)
}

public func FfiConverterTypeExactly32Bytes_lower(_ value: Exactly32Bytes) -> RustBuffer {
    return FfiConverterTypeExactly32Bytes.lower(value)
}

/**
 * 33 bytes, used by Secp256k1PublicKeys, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly33Bytes {
    fileprivate let secretMagic: Exactly33BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly33BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly33Bytes: Sendable {}
extension Exactly33Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly33Bytes, rhs: Exactly33Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly33Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly33Bytes {
        return
            try Exactly33Bytes(
                secretMagic: FfiConverterTypeExactly33BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly33Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly33BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly33Bytes_lift(_ buf: RustBuffer) throws -> Exactly33Bytes {
    return try FfiConverterTypeExactly33Bytes.lift(buf)
}

public func FfiConverterTypeExactly33Bytes_lower(_ value: Exactly33Bytes) -> RustBuffer {
    return FfiConverterTypeExactly33Bytes.lower(value)
}

/**
 * 64 bytes, used by Ed25519Signatures, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly64Bytes {
    fileprivate let secretMagic: Exactly64BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly64BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly64Bytes: Sendable {}
extension Exactly64Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly64Bytes, rhs: Exactly64Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly64Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly64Bytes {
        return
            try Exactly64Bytes(
                secretMagic: FfiConverterTypeExactly64BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly64Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly64BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly64Bytes_lift(_ buf: RustBuffer) throws -> Exactly64Bytes {
    return try FfiConverterTypeExactly64Bytes.lift(buf)
}

public func FfiConverterTypeExactly64Bytes_lower(_ value: Exactly64Bytes) -> RustBuffer {
    return FfiConverterTypeExactly64Bytes.lower(value)
}

/**
 * 65 bytes, used by Secp256k1Signatures, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly65Bytes {
    fileprivate let secretMagic: Exactly65BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly65BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly65Bytes: Sendable {}
extension Exactly65Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly65Bytes, rhs: Exactly65Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly65Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly65Bytes {
        return
            try Exactly65Bytes(
                secretMagic: FfiConverterTypeExactly65BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly65Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly65BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly65Bytes_lift(_ buf: RustBuffer) throws -> Exactly65Bytes {
    return try FfiConverterTypeExactly65Bytes.lift(buf)
}

public func FfiConverterTypeExactly65Bytes_lower(_ value: Exactly65Bytes) -> RustBuffer {
    return FfiConverterTypeExactly65Bytes.lower(value)
}

/**
 * A summary of the execution of the manifest and the information that helps
 * wallets present the contents of a transaction.
 */
public struct ExecutionSummary {
    /**
     * Per account, a list of all token balances that has been withdrawn from that account.
     */
    public var withdrawals: [AccountAddress: [ResourceIndicator]]
    /**
     * Per account, a list of all token balances that has been deposited into that account.
     */
    public var deposits: [AccountAddress: [ResourceIndicator]]
    /**
     * Addresses of accounts encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the accounts of all those addresses, which might be multiple
     * signatures per Account, if MFA has been setup.
     */
    public var addressesOfAccountsRequiringAuth: [AccountAddress]
    /**
     * Addresses of identities (Personas) encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the identities of all those addresses, which might be multiple
     * signatures per Persona, if MFA has been setup.
     */
    public var addressesOfIdentitiesRequiringAuth: [IdentityAddress]
    /**
     * Information on the global entities created in the transaction.
     */
    public var newEntities: NewEntities
    /**
     * The various classifications that this manifest matched against. Note
     * that an empty set means that the manifest is non-conforming.
     */
    public var detailedClassification: [DetailedManifestClass]
    /**
     * List of newly created Non-Fungibles during this transaction.
     */
    public var newlyCreatedNonFungibles: [NonFungibleGlobalId]
    /**
     * The set of instructions encountered in the manifest that are reserved
     * and can only be included in the manifest by the wallet itself.
     */
    public var reservedInstructions: [ReservedInstruction]
    /**
     * The list of the resources of proofs that were presented in the manifest.
     */
    public var presentedProofs: [ResourceAddress]
    /**
     * The set of all the encountered `ComponentAddress`es` in the manifest. This is
     * to be primarily used for the "using dApps" section of the wallet's tx
     * review screen.
     */
    public var encounteredComponentAddresses: [ComponentAddress]
    /**
     * Information on how much fees were contingent and how much were not.
     */
    public var feeLocks: FeeLocks
    /**
     * Detailed information on the amount of cost units consumed.
     */
    public var feeSummary: FeeSummary

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Per account, a list of all token balances that has been withdrawn from that account.
         */ withdrawals: [AccountAddress: [ResourceIndicator]],
        /**
            * Per account, a list of all token balances that has been deposited into that account.
            */ deposits: [AccountAddress: [ResourceIndicator]],
        /**
            * Addresses of accounts encountered in the manifest where privileged
            * methods were called. The wallets will need to collect signatures
            * of the accounts of all those addresses, which might be multiple
            * signatures per Account, if MFA has been setup.
            */ addressesOfAccountsRequiringAuth: [AccountAddress],
        /**
            * Addresses of identities (Personas) encountered in the manifest where privileged
            * methods were called. The wallets will need to collect signatures
            * of the identities of all those addresses, which might be multiple
            * signatures per Persona, if MFA has been setup.
            */ addressesOfIdentitiesRequiringAuth: [IdentityAddress],
        /**
            * Information on the global entities created in the transaction.
            */ newEntities: NewEntities,
        /**
            * The various classifications that this manifest matched against. Note
            * that an empty set means that the manifest is non-conforming.
            */ detailedClassification: [DetailedManifestClass],
        /**
            * List of newly created Non-Fungibles during this transaction.
            */ newlyCreatedNonFungibles: [NonFungibleGlobalId],
        /**
            * The set of instructions encountered in the manifest that are reserved
            * and can only be included in the manifest by the wallet itself.
            */ reservedInstructions: [ReservedInstruction],
        /**
            * The list of the resources of proofs that were presented in the manifest.
            */ presentedProofs: [ResourceAddress],
        /**
            * The set of all the encountered `ComponentAddress`es` in the manifest. This is
            * to be primarily used for the "using dApps" section of the wallet's tx
            * review screen.
            */ encounteredComponentAddresses: [ComponentAddress],
        /**
            * Information on how much fees were contingent and how much were not.
            */ feeLocks: FeeLocks,
        /**
            * Detailed information on the amount of cost units consumed.
            */ feeSummary: FeeSummary
    ) {
        self.withdrawals = withdrawals
        self.deposits = deposits
        self.addressesOfAccountsRequiringAuth = addressesOfAccountsRequiringAuth
        self.addressesOfIdentitiesRequiringAuth = addressesOfIdentitiesRequiringAuth
        self.newEntities = newEntities
        self.detailedClassification = detailedClassification
        self.newlyCreatedNonFungibles = newlyCreatedNonFungibles
        self.reservedInstructions = reservedInstructions
        self.presentedProofs = presentedProofs
        self.encounteredComponentAddresses = encounteredComponentAddresses
        self.feeLocks = feeLocks
        self.feeSummary = feeSummary
    }
}

extension ExecutionSummary: Sendable {}
extension ExecutionSummary: Equatable, Hashable {
    public static func == (lhs: ExecutionSummary, rhs: ExecutionSummary) -> Bool {
        if lhs.withdrawals != rhs.withdrawals {
            return false
        }
        if lhs.deposits != rhs.deposits {
            return false
        }
        if lhs.addressesOfAccountsRequiringAuth != rhs.addressesOfAccountsRequiringAuth {
            return false
        }
        if lhs.addressesOfIdentitiesRequiringAuth != rhs.addressesOfIdentitiesRequiringAuth {
            return false
        }
        if lhs.newEntities != rhs.newEntities {
            return false
        }
        if lhs.detailedClassification != rhs.detailedClassification {
            return false
        }
        if lhs.newlyCreatedNonFungibles != rhs.newlyCreatedNonFungibles {
            return false
        }
        if lhs.reservedInstructions != rhs.reservedInstructions {
            return false
        }
        if lhs.presentedProofs != rhs.presentedProofs {
            return false
        }
        if lhs.encounteredComponentAddresses != rhs.encounteredComponentAddresses {
            return false
        }
        if lhs.feeLocks != rhs.feeLocks {
            return false
        }
        if lhs.feeSummary != rhs.feeSummary {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(withdrawals)
        hasher.combine(deposits)
        hasher.combine(addressesOfAccountsRequiringAuth)
        hasher.combine(addressesOfIdentitiesRequiringAuth)
        hasher.combine(newEntities)
        hasher.combine(detailedClassification)
        hasher.combine(newlyCreatedNonFungibles)
        hasher.combine(reservedInstructions)
        hasher.combine(presentedProofs)
        hasher.combine(encounteredComponentAddresses)
        hasher.combine(feeLocks)
        hasher.combine(feeSummary)
    }
}

public struct FfiConverterTypeExecutionSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExecutionSummary {
        return
            try ExecutionSummary(
                withdrawals: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.read(from: &buf),
                deposits: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.read(from: &buf),
                addressesOfAccountsRequiringAuth: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
                addressesOfIdentitiesRequiringAuth: FfiConverterSequenceTypeIdentityAddress.read(from: &buf),
                newEntities: FfiConverterTypeNewEntities.read(from: &buf),
                detailedClassification: FfiConverterSequenceTypeDetailedManifestClass.read(from: &buf),
                newlyCreatedNonFungibles: FfiConverterSequenceTypeNonFungibleGlobalId.read(from: &buf),
                reservedInstructions: FfiConverterSequenceTypeReservedInstruction.read(from: &buf),
                presentedProofs: FfiConverterSequenceTypeResourceAddress.read(from: &buf),
                encounteredComponentAddresses: FfiConverterSequenceTypeComponentAddress.read(from: &buf),
                feeLocks: FfiConverterTypeFeeLocks.read(from: &buf),
                feeSummary: FfiConverterTypeFeeSummary.read(from: &buf)
            )
    }

    public static func write(_ value: ExecutionSummary, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.write(value.withdrawals, into: &buf)
        FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.write(value.deposits, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsRequiringAuth, into: &buf)
        FfiConverterSequenceTypeIdentityAddress.write(value.addressesOfIdentitiesRequiringAuth, into: &buf)
        FfiConverterTypeNewEntities.write(value.newEntities, into: &buf)
        FfiConverterSequenceTypeDetailedManifestClass.write(value.detailedClassification, into: &buf)
        FfiConverterSequenceTypeNonFungibleGlobalId.write(value.newlyCreatedNonFungibles, into: &buf)
        FfiConverterSequenceTypeReservedInstruction.write(value.reservedInstructions, into: &buf)
        FfiConverterSequenceTypeResourceAddress.write(value.presentedProofs, into: &buf)
        FfiConverterSequenceTypeComponentAddress.write(value.encounteredComponentAddresses, into: &buf)
        FfiConverterTypeFeeLocks.write(value.feeLocks, into: &buf)
        FfiConverterTypeFeeSummary.write(value.feeSummary, into: &buf)
    }
}

public func FfiConverterTypeExecutionSummary_lift(_ buf: RustBuffer) throws -> ExecutionSummary {
    return try FfiConverterTypeExecutionSummary.lift(buf)
}

public func FfiConverterTypeExecutionSummary_lower(_ value: ExecutionSummary) -> RustBuffer {
    return FfiConverterTypeExecutionSummary.lower(value)
}

public struct FactorInstance {
    /**
     * The ID of the `FactorSource` that was used to produce this
     * factor instance. We will lookup the `FactorSource` in the
     * `Profile` and can present user with instruction to re-access
     * this factor source in order control the `badge`.
     */
    public var factorSourceId: FactorSourceId
    /**
     * Either a "physical" badge (NFT) or some source for recreation of a producer
     * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
     * is derived which produces virtual badges (signatures).
     */
    public var badge: FactorInstanceBadge

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the `FactorSource` that was used to produce this
         * factor instance. We will lookup the `FactorSource` in the
         * `Profile` and can present user with instruction to re-access
         * this factor source in order control the `badge`.
         */ factorSourceId: FactorSourceId,
        /**
            * Either a "physical" badge (NFT) or some source for recreation of a producer
            * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
            * is derived which produces virtual badges (signatures).
            */ badge: FactorInstanceBadge
    ) {
        self.factorSourceId = factorSourceId
        self.badge = badge
    }
}

extension FactorInstance: Sendable {}
extension FactorInstance: Equatable, Hashable {
    public static func == (lhs: FactorInstance, rhs: FactorInstance) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.badge != rhs.badge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(badge)
    }
}

public struct FfiConverterTypeFactorInstance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstance {
        return
            try FactorInstance(
                factorSourceId: FfiConverterTypeFactorSourceID.read(from: &buf),
                badge: FfiConverterTypeFactorInstanceBadge.read(from: &buf)
            )
    }

    public static func write(_ value: FactorInstance, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceID.write(value.factorSourceId, into: &buf)
        FfiConverterTypeFactorInstanceBadge.write(value.badge, into: &buf)
    }
}

public func FfiConverterTypeFactorInstance_lift(_ buf: RustBuffer) throws -> FactorInstance {
    return try FfiConverterTypeFactorInstance.lift(buf)
}

public func FfiConverterTypeFactorInstance_lower(_ value: FactorInstance) -> RustBuffer {
    return FfiConverterTypeFactorInstance.lower(value)
}

/**
 * Common properties shared between FactorSources of different kinds, describing
 * its state, when added, and supported cryptographic parameters.
 */
public struct FactorSourceCommon {
    /**
     * Cryptographic parameters a certain FactorSource supports, e.g. Elliptic Curves.
     *
     * Has interior mutability since Radix Wallet App version 1.3.0, it is
     * possible to add crypto parameters to a FactorSource, e.g. when a user
     * with a DeviceFactorSource with babylon crypto parameters, lets call it `B`,
     * with mnemonic `M` adds `M` again but as an "Olympia" factor source, then
     * the olympia crypto parameters are added to `B`.
     */
    public var cryptoParameters: FactorSourceCryptoParameters
    /**
     * When this factor source for originally added by the user.
     */
    public var addedOn: Timestamp
    /**
     * Date of last usage of this factor source
     *
     * This is the only mutable property, it is mutable
     * since we will update it every time this FactorSource
     * is used.
     */
    public var lastUsedOn: Timestamp
    /**
     * Flags which describe a certain state a FactorSource might be in, e.g. `Main` (BDFS).
     */
    public var flags: [FactorSourceFlag]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Cryptographic parameters a certain FactorSource supports, e.g. Elliptic Curves.
         *
         * Has interior mutability since Radix Wallet App version 1.3.0, it is
         * possible to add crypto parameters to a FactorSource, e.g. when a user
         * with a DeviceFactorSource with babylon crypto parameters, lets call it `B`,
         * with mnemonic `M` adds `M` again but as an "Olympia" factor source, then
         * the olympia crypto parameters are added to `B`.
         */ cryptoParameters: FactorSourceCryptoParameters,
        /**
            * When this factor source for originally added by the user.
            */ addedOn: Timestamp,
        /**
            * Date of last usage of this factor source
            *
            * This is the only mutable property, it is mutable
            * since we will update it every time this FactorSource
            * is used.
            */ lastUsedOn: Timestamp,
        /**
            * Flags which describe a certain state a FactorSource might be in, e.g. `Main` (BDFS).
            */ flags: [FactorSourceFlag]
    ) {
        self.cryptoParameters = cryptoParameters
        self.addedOn = addedOn
        self.lastUsedOn = lastUsedOn
        self.flags = flags
    }
}

extension FactorSourceCommon: Sendable {}
extension FactorSourceCommon: Equatable, Hashable {
    public static func == (lhs: FactorSourceCommon, rhs: FactorSourceCommon) -> Bool {
        if lhs.cryptoParameters != rhs.cryptoParameters {
            return false
        }
        if lhs.addedOn != rhs.addedOn {
            return false
        }
        if lhs.lastUsedOn != rhs.lastUsedOn {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cryptoParameters)
        hasher.combine(addedOn)
        hasher.combine(lastUsedOn)
        hasher.combine(flags)
    }
}

public struct FfiConverterTypeFactorSourceCommon: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceCommon {
        return
            try FactorSourceCommon(
                cryptoParameters: FfiConverterTypeFactorSourceCryptoParameters.read(from: &buf),
                addedOn: FfiConverterTypeTimestamp.read(from: &buf),
                lastUsedOn: FfiConverterTypeTimestamp.read(from: &buf),
                flags: FfiConverterSequenceTypeFactorSourceFlag.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceCommon, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceCryptoParameters.write(value.cryptoParameters, into: &buf)
        FfiConverterTypeTimestamp.write(value.addedOn, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastUsedOn, into: &buf)
        FfiConverterSequenceTypeFactorSourceFlag.write(value.flags, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceCommon_lift(_ buf: RustBuffer) throws -> FactorSourceCommon {
    return try FfiConverterTypeFactorSourceCommon.lift(buf)
}

public func FfiConverterTypeFactorSourceCommon_lower(_ value: FactorSourceCommon) -> RustBuffer {
    return FfiConverterTypeFactorSourceCommon.lower(value)
}

/**
 * Cryptographic parameters a certain FactorSource supports, e.g. which Elliptic Curves
 * it supports and which Hierarchical Deterministic (HD) derivations schemes it supports,
 * if any.
 */
public struct FactorSourceCryptoParameters {
    /**
     * Describes with which Elliptic Curves a Factor Source can be used, e.g. a
     * "Babylon" `DeviceFactorSource` is not capable of deriving keys on the curve
     * `secp256k1` - only Olympia imported FactorSources can do that.
     *
     * Either `[curve25519]` or `[secp256k1, curve25519]`
     *
     * Must not be empty.
     */
    public var supportedCurves: [Slip10Curve]
    /**
     * If not empty: Describes which kind of Hierarchical Deterministic (HD)
     * derivations a FactorSource is capable of doing - if empty: the
     * FactorSource does not support HD derivation.
     *
     * Either BIP44 or CAP26 (SLIP10)
     */
    public var supportedDerivationPathSchemes: [DerivationPathScheme]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Describes with which Elliptic Curves a Factor Source can be used, e.g. a
         * "Babylon" `DeviceFactorSource` is not capable of deriving keys on the curve
         * `secp256k1` - only Olympia imported FactorSources can do that.
         *
         * Either `[curve25519]` or `[secp256k1, curve25519]`
         *
         * Must not be empty.
         */ supportedCurves: [Slip10Curve],
        /**
            * If not empty: Describes which kind of Hierarchical Deterministic (HD)
            * derivations a FactorSource is capable of doing - if empty: the
            * FactorSource does not support HD derivation.
            *
            * Either BIP44 or CAP26 (SLIP10)
            */ supportedDerivationPathSchemes: [DerivationPathScheme]
    ) {
        self.supportedCurves = supportedCurves
        self.supportedDerivationPathSchemes = supportedDerivationPathSchemes
    }
}

extension FactorSourceCryptoParameters: Sendable {}
extension FactorSourceCryptoParameters: Equatable, Hashable {
    public static func == (lhs: FactorSourceCryptoParameters, rhs: FactorSourceCryptoParameters) -> Bool {
        if lhs.supportedCurves != rhs.supportedCurves {
            return false
        }
        if lhs.supportedDerivationPathSchemes != rhs.supportedDerivationPathSchemes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(supportedCurves)
        hasher.combine(supportedDerivationPathSchemes)
    }
}

public struct FfiConverterTypeFactorSourceCryptoParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceCryptoParameters {
        return
            try FactorSourceCryptoParameters(
                supportedCurves: FfiConverterSequenceTypeSLIP10Curve.read(from: &buf),
                supportedDerivationPathSchemes: FfiConverterSequenceTypeDerivationPathScheme.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceCryptoParameters, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeSLIP10Curve.write(value.supportedCurves, into: &buf)
        FfiConverterSequenceTypeDerivationPathScheme.write(value.supportedDerivationPathSchemes, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceCryptoParameters_lift(_ buf: RustBuffer) throws -> FactorSourceCryptoParameters {
    return try FfiConverterTypeFactorSourceCryptoParameters.lift(buf)
}

public func FfiConverterTypeFactorSourceCryptoParameters_lower(_ value: FactorSourceCryptoParameters) -> RustBuffer {
    return FfiConverterTypeFactorSourceCryptoParameters.lower(value)
}

/**
 * FactorSourceID from an AccountAddress, typically used by `trustedContact` FactorSource.
 */
public struct FactorSourceIdFromAddress {
    /**
     * The kind of the FactorSource this ID refers to, typically `trustedContact`.
     */
    public var kind: FactorSourceKind
    /**
     * An account address which the FactorSource this ID refers uses/needs.
     */
    public var body: AccountAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The kind of the FactorSource this ID refers to, typically `trustedContact`.
         */ kind: FactorSourceKind,
        /**
            * An account address which the FactorSource this ID refers uses/needs.
            */ body: AccountAddress
    ) {
        self.kind = kind
        self.body = body
    }
}

extension FactorSourceIdFromAddress: Sendable {}
extension FactorSourceIdFromAddress: Equatable, Hashable {
    public static func == (lhs: FactorSourceIdFromAddress, rhs: FactorSourceIdFromAddress) -> Bool {
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kind)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeFactorSourceIDFromAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIdFromAddress {
        return
            try FactorSourceIdFromAddress(
                kind: FfiConverterTypeFactorSourceKind.read(from: &buf),
                body: FfiConverterTypeAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceIdFromAddress, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.kind, into: &buf)
        FfiConverterTypeAccountAddress.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceIDFromAddress_lift(_ buf: RustBuffer) throws -> FactorSourceIdFromAddress {
    return try FfiConverterTypeFactorSourceIDFromAddress.lift(buf)
}

public func FfiConverterTypeFactorSourceIDFromAddress_lower(_ value: FactorSourceIdFromAddress) -> RustBuffer {
    return FfiConverterTypeFactorSourceIDFromAddress.lower(value)
}

/**
 * FactorSourceID from the blake2b hash of the special HD public key derived at `CAP26::GetID`,
 * for a certain `FactorSourceKind`
 */
public struct FactorSourceIdFromHash {
    /**
     * The kind of the FactorSource this ID refers to, typically `device` or `ledger`.
     */
    public var kind: FactorSourceKind
    /**
     * The blake2b hash of the special HD public key derived at `CAP26::GetID`.
     */
    public var body: Exactly32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The kind of the FactorSource this ID refers to, typically `device` or `ledger`.
         */ kind: FactorSourceKind,
        /**
            * The blake2b hash of the special HD public key derived at `CAP26::GetID`.
            */ body: Exactly32Bytes
    ) {
        self.kind = kind
        self.body = body
    }
}

extension FactorSourceIdFromHash: Sendable {}
extension FactorSourceIdFromHash: Equatable, Hashable {
    public static func == (lhs: FactorSourceIdFromHash, rhs: FactorSourceIdFromHash) -> Bool {
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kind)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeFactorSourceIDFromHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIdFromHash {
        return
            try FactorSourceIdFromHash(
                kind: FfiConverterTypeFactorSourceKind.read(from: &buf),
                body: FfiConverterTypeExactly32Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceIdFromHash, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.kind, into: &buf)
        FfiConverterTypeExactly32Bytes.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceIDFromHash_lift(_ buf: RustBuffer) throws -> FactorSourceIdFromHash {
    return try FfiConverterTypeFactorSourceIDFromHash.lift(buf)
}

public func FfiConverterTypeFactorSourceIDFromHash_lower(_ value: FactorSourceIdFromHash) -> RustBuffer {
    return FfiConverterTypeFactorSourceIDFromHash.lower(value)
}

/**
 * Information on how much fees were contingent and how much were not.
 */
public struct FeeLocks {
    public var lock: Decimal192
    public var contingentLock: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lock: Decimal192, contingentLock: Decimal192) {
        self.lock = lock
        self.contingentLock = contingentLock
    }
}

extension FeeLocks: Sendable {}
extension FeeLocks: Equatable, Hashable {
    public static func == (lhs: FeeLocks, rhs: FeeLocks) -> Bool {
        if lhs.lock != rhs.lock {
            return false
        }
        if lhs.contingentLock != rhs.contingentLock {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lock)
        hasher.combine(contingentLock)
    }
}

public struct FfiConverterTypeFeeLocks: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeLocks {
        return
            try FeeLocks(
                lock: FfiConverterTypeDecimal192.read(from: &buf),
                contingentLock: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: FeeLocks, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.lock, into: &buf)
        FfiConverterTypeDecimal192.write(value.contingentLock, into: &buf)
    }
}

public func FfiConverterTypeFeeLocks_lift(_ buf: RustBuffer) throws -> FeeLocks {
    return try FfiConverterTypeFeeLocks.lift(buf)
}

public func FfiConverterTypeFeeLocks_lower(_ value: FeeLocks) -> RustBuffer {
    return FfiConverterTypeFeeLocks.lower(value)
}

/**
 * Detailed information on the amount of cost units consumed.
 */
public struct FeeSummary {
    public var executionCost: Decimal192
    public var finalizationCost: Decimal192
    public var royaltyCost: Decimal192
    public var storageExpansionCost: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(executionCost: Decimal192, finalizationCost: Decimal192, royaltyCost: Decimal192, storageExpansionCost: Decimal192) {
        self.executionCost = executionCost
        self.finalizationCost = finalizationCost
        self.royaltyCost = royaltyCost
        self.storageExpansionCost = storageExpansionCost
    }
}

extension FeeSummary: Sendable {}
extension FeeSummary: Equatable, Hashable {
    public static func == (lhs: FeeSummary, rhs: FeeSummary) -> Bool {
        if lhs.executionCost != rhs.executionCost {
            return false
        }
        if lhs.finalizationCost != rhs.finalizationCost {
            return false
        }
        if lhs.royaltyCost != rhs.royaltyCost {
            return false
        }
        if lhs.storageExpansionCost != rhs.storageExpansionCost {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(executionCost)
        hasher.combine(finalizationCost)
        hasher.combine(royaltyCost)
        hasher.combine(storageExpansionCost)
    }
}

public struct FfiConverterTypeFeeSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSummary {
        return
            try FeeSummary(
                executionCost: FfiConverterTypeDecimal192.read(from: &buf),
                finalizationCost: FfiConverterTypeDecimal192.read(from: &buf),
                royaltyCost: FfiConverterTypeDecimal192.read(from: &buf),
                storageExpansionCost: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: FeeSummary, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.executionCost, into: &buf)
        FfiConverterTypeDecimal192.write(value.finalizationCost, into: &buf)
        FfiConverterTypeDecimal192.write(value.royaltyCost, into: &buf)
        FfiConverterTypeDecimal192.write(value.storageExpansionCost, into: &buf)
    }
}

public func FfiConverterTypeFeeSummary_lift(_ buf: RustBuffer) throws -> FeeSummary {
    return try FfiConverterTypeFeeSummary.lift(buf)
}

public func FfiConverterTypeFeeSummary_lower(_ value: FeeSummary) -> RustBuffer {
    return FfiConverterTypeFeeSummary.lower(value)
}

public struct FungibleResourcesCollection {
    public var items: [FungibleResourcesCollectionItem]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [FungibleResourcesCollectionItem]) {
        self.items = items
    }
}

extension FungibleResourcesCollection: Sendable {}
extension FungibleResourcesCollection: Equatable, Hashable {
    public static func == (lhs: FungibleResourcesCollection, rhs: FungibleResourcesCollection) -> Bool {
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(items)
    }
}

public struct FfiConverterTypeFungibleResourcesCollection: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourcesCollection {
        return
            try FungibleResourcesCollection(
                items: FfiConverterSequenceTypeFungibleResourcesCollectionItem.read(from: &buf)
            )
    }

    public static func write(_ value: FungibleResourcesCollection, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFungibleResourcesCollectionItem.write(value.items, into: &buf)
    }
}

public func FfiConverterTypeFungibleResourcesCollection_lift(_ buf: RustBuffer) throws -> FungibleResourcesCollection {
    return try FfiConverterTypeFungibleResourcesCollection.lift(buf)
}

public func FfiConverterTypeFungibleResourcesCollection_lower(_ value: FungibleResourcesCollection) -> RustBuffer {
    return FfiConverterTypeFungibleResourcesCollection.lower(value)
}

public struct FungibleResourcesCollectionItemGloballyAggregated {
    public var amount: Decimal192
    public var resourceAddress: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal192, resourceAddress: ResourceAddress) {
        self.amount = amount
        self.resourceAddress = resourceAddress
    }
}

extension FungibleResourcesCollectionItemGloballyAggregated: Sendable {}
extension FungibleResourcesCollectionItemGloballyAggregated: Equatable, Hashable {
    public static func == (lhs: FungibleResourcesCollectionItemGloballyAggregated, rhs: FungibleResourcesCollectionItemGloballyAggregated) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(resourceAddress)
    }
}

public struct FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourcesCollectionItemGloballyAggregated {
        return
            try FungibleResourcesCollectionItemGloballyAggregated(
                amount: FfiConverterTypeDecimal192.read(from: &buf),
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: FungibleResourcesCollectionItemGloballyAggregated, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
    }
}

public func FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated_lift(_ buf: RustBuffer) throws -> FungibleResourcesCollectionItemGloballyAggregated {
    return try FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated.lift(buf)
}

public func FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated_lower(_ value: FungibleResourcesCollectionItemGloballyAggregated) -> RustBuffer {
    return FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated.lower(value)
}

/**
 * A gateway to some Radix Network, which is a high level REST API which clients (wallets) can
 * consume in order to query asset balances and submit transactions.
 */
public struct Gateway {
    /**
     * The Radix network the API is a Gateway to.
     */
    public var network: NetworkDefinition
    /**
     * The URL to the gateways API endpoint
     */
    public var url: Url

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The Radix network the API is a Gateway to.
         */ network: NetworkDefinition,
        /**
            * The URL to the gateways API endpoint
            */ url: Url
    ) {
        self.network = network
        self.url = url
    }
}

extension Gateway: Sendable {}
extension Gateway: Equatable, Hashable {
    public static func == (lhs: Gateway, rhs: Gateway) -> Bool {
        if lhs.network != rhs.network {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(network)
        hasher.combine(url)
    }
}

public struct FfiConverterTypeGateway: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Gateway {
        return
            try Gateway(
                network: FfiConverterTypeNetworkDefinition.read(from: &buf),
                url: FfiConverterTypeUrl.read(from: &buf)
            )
    }

    public static func write(_ value: Gateway, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkDefinition.write(value.network, into: &buf)
        FfiConverterTypeUrl.write(value.url, into: &buf)
    }
}

public func FfiConverterTypeGateway_lift(_ buf: RustBuffer) throws -> Gateway {
    return try FfiConverterTypeGateway.lift(buf)
}

public func FfiConverterTypeGateway_lower(_ value: Gateway) -> RustBuffer {
    return FfiConverterTypeGateway.lower(value)
}

/**
 * Use it with `GetIDPath::default()` to create the path `m/44'/1022'/365'`
 * which is used by all hierarchal deterministic factor sources to derive
 * the special root key which we hash to form the `FactorSourceIDFromHash`
 */
public struct GetIdPath {
    public var path: HdPath

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: HdPath) {
        self.path = path
    }
}

extension GetIdPath: Sendable {}
extension GetIdPath: Equatable, Hashable {
    public static func == (lhs: GetIdPath, rhs: GetIdPath) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
    }
}

public struct FfiConverterTypeGetIDPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetIdPath {
        return
            try GetIdPath(
                path: FfiConverterTypeHDPath.read(from: &buf)
            )
    }

    public static func write(_ value: GetIdPath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPath.write(value.path, into: &buf)
    }
}

public func FfiConverterTypeGetIDPath_lift(_ buf: RustBuffer) throws -> GetIdPath {
    return try FfiConverterTypeGetIDPath.lift(buf)
}

public func FfiConverterTypeGetIDPath_lower(_ value: GetIdPath) -> RustBuffer {
    return FfiConverterTypeGetIDPath.lower(value)
}

public struct HdPath {
    public var components: [HdPathComponent]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(components: [HdPathComponent]) {
        self.components = components
    }
}

extension HdPath: Sendable {}
extension HdPath: Equatable, Hashable {
    public static func == (lhs: HdPath, rhs: HdPath) -> Bool {
        if lhs.components != rhs.components {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(components)
    }
}

public struct FfiConverterTypeHDPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdPath {
        return
            try HdPath(
                components: FfiConverterSequenceTypeHDPathComponent.read(from: &buf)
            )
    }

    public static func write(_ value: HdPath, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeHDPathComponent.write(value.components, into: &buf)
    }
}

public func FfiConverterTypeHDPath_lift(_ buf: RustBuffer) throws -> HdPath {
    return try FfiConverterTypeHDPath.lift(buf)
}

public func FfiConverterTypeHDPath_lower(_ value: HdPath) -> RustBuffer {
    return FfiConverterTypeHDPath.lower(value)
}

public struct HdPathComponent {
    public var value: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt32) {
        self.value = value
    }
}

extension HdPathComponent: Sendable {}
extension HdPathComponent: Equatable, Hashable {
    public static func == (lhs: HdPathComponent, rhs: HdPathComponent) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeHDPathComponent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdPathComponent {
        return
            try HdPathComponent(
                value: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: HdPathComponent, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeHDPathComponent_lift(_ buf: RustBuffer) throws -> HdPathComponent {
    return try FfiConverterTypeHDPathComponent.lift(buf)
}

public func FfiConverterTypeHDPathComponent_lower(_ value: HdPathComponent) -> RustBuffer {
    return FfiConverterTypeHDPathComponent.lower(value)
}

/**
 * Represents a 32-byte hash digest.
 *
 * Made UniFFI convertible via HashSecretMagic,
 * exposed in Swift/Kotlin as its own struct/data class, with
 * hidden secret magic.
 */
public struct Hash {
    fileprivate let secretMagic: HashSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: HashSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Hash: Sendable {}
extension Hash: Equatable, Hashable {
    public static func == (lhs: Hash, rhs: Hash) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hash {
        return
            try Hash(
                secretMagic: FfiConverterTypeHashSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Hash, into buf: inout [UInt8]) {
        FfiConverterTypeHashSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeHash_lift(_ buf: RustBuffer) throws -> Hash {
    return try FfiConverterTypeHash.lift(buf)
}

public func FfiConverterTypeHash_lower(_ value: Hash) -> RustBuffer {
    return FfiConverterTypeHash.lower(value)
}

/**
 * The header of a Profile(Snapshot) contains crucial metadata
 * about this Profile, such as which JSON data format it is
 * compatible with and which device was used to create it and
 * a hint about its contents.
 */
public struct Header {
    /**
     * A versioning number that is increased when breaking
     * changes is made to ProfileSnapshot JSON data format.
     */
    public var snapshotVersion: ProfileSnapshotVersion
    /**
     * An immutable and unique identifier of a Profile.
     */
    public var id: ProfileId
    /**
     * The device which was used to create the Profile.
     */
    public var creatingDevice: DeviceInfo
    /**
     * The device on which the profile was last used.
     */
    public var lastUsedOnDevice: DeviceInfo
    /**
     * When the Profile was last modified.
     */
    public var lastModified: Timestamp
    /**
     * Hint about the contents of the profile, e.g. number of Accounts and Personas.
     */
    public var contentHint: ContentHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A versioning number that is increased when breaking
         * changes is made to ProfileSnapshot JSON data format.
         */ snapshotVersion: ProfileSnapshotVersion,
        /**
            * An immutable and unique identifier of a Profile.
            */ id: ProfileId,
        /**
            * The device which was used to create the Profile.
            */ creatingDevice: DeviceInfo,
        /**
            * The device on which the profile was last used.
            */ lastUsedOnDevice: DeviceInfo,
        /**
            * When the Profile was last modified.
            */ lastModified: Timestamp,
        /**
            * Hint about the contents of the profile, e.g. number of Accounts and Personas.
            */ contentHint: ContentHint
    ) {
        self.snapshotVersion = snapshotVersion
        self.id = id
        self.creatingDevice = creatingDevice
        self.lastUsedOnDevice = lastUsedOnDevice
        self.lastModified = lastModified
        self.contentHint = contentHint
    }
}

extension Header: Sendable {}
extension Header: Equatable, Hashable {
    public static func == (lhs: Header, rhs: Header) -> Bool {
        if lhs.snapshotVersion != rhs.snapshotVersion {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.creatingDevice != rhs.creatingDevice {
            return false
        }
        if lhs.lastUsedOnDevice != rhs.lastUsedOnDevice {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.contentHint != rhs.contentHint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(snapshotVersion)
        hasher.combine(id)
        hasher.combine(creatingDevice)
        hasher.combine(lastUsedOnDevice)
        hasher.combine(lastModified)
        hasher.combine(contentHint)
    }
}

public struct FfiConverterTypeHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Header {
        return
            try Header(
                snapshotVersion: FfiConverterTypeProfileSnapshotVersion.read(from: &buf),
                id: FfiConverterTypeProfileID.read(from: &buf),
                creatingDevice: FfiConverterTypeDeviceInfo.read(from: &buf),
                lastUsedOnDevice: FfiConverterTypeDeviceInfo.read(from: &buf),
                lastModified: FfiConverterTypeTimestamp.read(from: &buf),
                contentHint: FfiConverterTypeContentHint.read(from: &buf)
            )
    }

    public static func write(_ value: Header, into buf: inout [UInt8]) {
        FfiConverterTypeProfileSnapshotVersion.write(value.snapshotVersion, into: &buf)
        FfiConverterTypeProfileID.write(value.id, into: &buf)
        FfiConverterTypeDeviceInfo.write(value.creatingDevice, into: &buf)
        FfiConverterTypeDeviceInfo.write(value.lastUsedOnDevice, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastModified, into: &buf)
        FfiConverterTypeContentHint.write(value.contentHint, into: &buf)
    }
}

public func FfiConverterTypeHeader_lift(_ buf: RustBuffer) throws -> Header {
    return try FfiConverterTypeHeader.lift(buf)
}

public func FfiConverterTypeHeader_lower(_ value: Header) -> RustBuffer {
    return FfiConverterTypeHeader.lower(value)
}

/**
 * A virtual hierarchical deterministic `FactorInstance`
 */
public struct HierarchicalDeterministicFactorInstance {
    public var factorSourceId: FactorSourceIdFromHash
    public var publicKey: HierarchicalDeterministicPublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceId: FactorSourceIdFromHash, publicKey: HierarchicalDeterministicPublicKey) {
        self.factorSourceId = factorSourceId
        self.publicKey = publicKey
    }
}

extension HierarchicalDeterministicFactorInstance: Sendable {}
extension HierarchicalDeterministicFactorInstance: Equatable, Hashable {
    public static func == (lhs: HierarchicalDeterministicFactorInstance, rhs: HierarchicalDeterministicFactorInstance) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(publicKey)
    }
}

public struct FfiConverterTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HierarchicalDeterministicFactorInstance {
        return
            try HierarchicalDeterministicFactorInstance(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                publicKey: FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: HierarchicalDeterministicFactorInstance, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterTypeHierarchicalDeterministicPublicKey.write(value.publicKey, into: &buf)
    }
}

public func FfiConverterTypeHierarchicalDeterministicFactorInstance_lift(_ buf: RustBuffer) throws -> HierarchicalDeterministicFactorInstance {
    return try FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(buf)
}

public func FfiConverterTypeHierarchicalDeterministicFactorInstance_lower(_ value: HierarchicalDeterministicFactorInstance) -> RustBuffer {
    return FfiConverterTypeHierarchicalDeterministicFactorInstance.lower(value)
}

/**
 * The **source** of a virtual hierarchical deterministic badge, contains a
 * derivation path and public key, from which a private key is derived which
 * produces virtual badges (signatures).
 *
 * The `.device` `FactorSource` produces `FactorInstance`s with this kind if badge source.
 */
public struct HierarchicalDeterministicPublicKey {
    /**
     * The expected public key of the private key derived at `derivationPath`
     */
    public var publicKey: PublicKey
    /**
     * The HD derivation path for the key pair which produces virtual badges (signatures).
     */
    public var derivationPath: DerivationPath

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The expected public key of the private key derived at `derivationPath`
         */ publicKey: PublicKey,
        /**
            * The HD derivation path for the key pair which produces virtual badges (signatures).
            */ derivationPath: DerivationPath
    ) {
        self.publicKey = publicKey
        self.derivationPath = derivationPath
    }
}

extension HierarchicalDeterministicPublicKey: Sendable {}
extension HierarchicalDeterministicPublicKey: Equatable, Hashable {
    public static func == (lhs: HierarchicalDeterministicPublicKey, rhs: HierarchicalDeterministicPublicKey) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.derivationPath != rhs.derivationPath {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(derivationPath)
    }
}

public struct FfiConverterTypeHierarchicalDeterministicPublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HierarchicalDeterministicPublicKey {
        return
            try HierarchicalDeterministicPublicKey(
                publicKey: FfiConverterTypePublicKey.read(from: &buf),
                derivationPath: FfiConverterTypeDerivationPath.read(from: &buf)
            )
    }

    public static func write(_ value: HierarchicalDeterministicPublicKey, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterTypeDerivationPath.write(value.derivationPath, into: &buf)
    }
}

public func FfiConverterTypeHierarchicalDeterministicPublicKey_lift(_ buf: RustBuffer) throws -> HierarchicalDeterministicPublicKey {
    return try FfiConverterTypeHierarchicalDeterministicPublicKey.lift(buf)
}

public func FfiConverterTypeHierarchicalDeterministicPublicKey_lower(_ value: HierarchicalDeterministicPublicKey) -> RustBuffer {
    return FfiConverterTypeHierarchicalDeterministicPublicKey.lower(value)
}

/**
 * Human readable address of an identity, which are used by Personas. Always starts with
 * the prefix `"identity_"`, for example:
 *
 * `identity_rdx12tgzjrz9u0xz4l28vf04hz87eguclmfaq4d2p8f8lv7zg9ssnzku8j`
 *
 * Addresses are checksummed, as per Bech32. **Only** *Identity* addresses starts with
 * the prefix `"identity_"`.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of IdentityAddresses:
 * * GlobalIdentity,
 * * GlobalVirtualSecp256k1Identity,
 * * GlobalVirtualEd25519Identity
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert_eq!(
 * "identity_rdx12tgzjrz9u0xz4l28vf04hz87eguclmfaq4d2p8f8lv7zg9ssnzku8j".parse::<IdentityAddress>().unwrap().network_id(),
 * NetworkID::Mainnet
 * );
 * ```
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalIdentityAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L229-L234
 */
public struct IdentityAddress {
    fileprivate let secretMagic: RetIdentityAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetIdentityAddress) {
        self.secretMagic = secretMagic
    }
}

extension IdentityAddress: Sendable {}
extension IdentityAddress: Equatable, Hashable {
    public static func == (lhs: IdentityAddress, rhs: IdentityAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeIdentityAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityAddress {
        return
            try IdentityAddress(
                secretMagic: FfiConverterTypeRetIdentityAddress.read(from: &buf)
            )
    }

    public static func write(_ value: IdentityAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetIdentityAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeIdentityAddress_lift(_ buf: RustBuffer) throws -> IdentityAddress {
    return try FfiConverterTypeIdentityAddress.lift(buf)
}

public func FfiConverterTypeIdentityAddress_lower(_ value: IdentityAddress) -> RustBuffer {
    return FfiConverterTypeIdentityAddress.lower(value)
}

public struct IdentityPath {
    public var path: HdPath
    public var networkId: NetworkId
    public var entityKind: Cap26EntityKind
    public var keyKind: Cap26KeyKind
    public var index: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: HdPath, networkId: NetworkId, entityKind: Cap26EntityKind, keyKind: Cap26KeyKind, index: UInt32) {
        self.path = path
        self.networkId = networkId
        self.entityKind = entityKind
        self.keyKind = keyKind
        self.index = index
    }
}

extension IdentityPath: Sendable {}
extension IdentityPath: Equatable, Hashable {
    public static func == (lhs: IdentityPath, rhs: IdentityPath) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.entityKind != rhs.entityKind {
            return false
        }
        if lhs.keyKind != rhs.keyKind {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(networkId)
        hasher.combine(entityKind)
        hasher.combine(keyKind)
        hasher.combine(index)
    }
}

public struct FfiConverterTypeIdentityPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityPath {
        return
            try IdentityPath(
                path: FfiConverterTypeHDPath.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                entityKind: FfiConverterTypeCAP26EntityKind.read(from: &buf),
                keyKind: FfiConverterTypeCAP26KeyKind.read(from: &buf),
                index: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: IdentityPath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPath.write(value.path, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeCAP26EntityKind.write(value.entityKind, into: &buf)
        FfiConverterTypeCAP26KeyKind.write(value.keyKind, into: &buf)
        FfiConverterUInt32.write(value.index, into: &buf)
    }
}

public func FfiConverterTypeIdentityPath_lift(_ buf: RustBuffer) throws -> IdentityPath {
    return try FfiConverterTypeIdentityPath.lift(buf)
}

public func FfiConverterTypeIdentityPath_lower(_ value: IdentityPath) -> RustBuffer {
    return FfiConverterTypeIdentityPath.lower(value)
}

public struct Instructions {
    fileprivate let secretMagic: InstructionsSecretMagic
    public var networkId: NetworkId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: InstructionsSecretMagic, networkId: NetworkId) {
        self.secretMagic = secretMagic
        self.networkId = networkId
    }
}

extension Instructions: Sendable {}
extension Instructions: Equatable, Hashable {
    public static func == (lhs: Instructions, rhs: Instructions) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
        hasher.combine(networkId)
    }
}

public struct FfiConverterTypeInstructions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Instructions {
        return
            try Instructions(
                secretMagic: FfiConverterTypeInstructionsSecretMagic.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
            )
    }

    public static func write(_ value: Instructions, into buf: inout [UInt8]) {
        FfiConverterTypeInstructionsSecretMagic.write(value.secretMagic, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
    }
}

public func FfiConverterTypeInstructions_lift(_ buf: RustBuffer) throws -> Instructions {
    return try FfiConverterTypeInstructions.lift(buf)
}

public func FfiConverterTypeInstructions_lower(_ value: Instructions) -> RustBuffer {
    return FfiConverterTypeInstructions.lower(value)
}

/**
 * `IntentHash` used to identify transactions.
 * Representation is bech32 encoded string starting with `txid_` e.g.:
 * `"txid_rdx19rpveua6xuhvz0axu0mwpqk8fywr83atv8mkrugchvw6uuslgppqh9cnj4"`
 */
public struct IntentHash {
    /**
     * Which network this transaction hash is used on
     */
    public var networkId: NetworkId
    /**
     * the hash of the intent
     */
    public var hash: Hash
    /**
     * Bech32 encoded TX id
     */
    public var bech32EncodedTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Which network this transaction hash is used on
         */ networkId: NetworkId,
        /**
            * the hash of the intent
            */ hash: Hash,
        /**
            * Bech32 encoded TX id
            */ bech32EncodedTxId: String
    ) {
        self.networkId = networkId
        self.hash = hash
        self.bech32EncodedTxId = bech32EncodedTxId
    }
}

extension IntentHash: Sendable {}
extension IntentHash: Equatable, Hashable {
    public static func == (lhs: IntentHash, rhs: IntentHash) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(hash)
        hasher.combine(bech32EncodedTxId)
    }
}

public struct FfiConverterTypeIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentHash {
        return
            try IntentHash(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                hash: FfiConverterTypeHash.read(from: &buf),
                bech32EncodedTxId: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: IntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeHash.write(value.hash, into: &buf)
        FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
    }
}

public func FfiConverterTypeIntentHash_lift(_ buf: RustBuffer) throws -> IntentHash {
    return try FfiConverterTypeIntentHash.lift(buf)
}

public func FfiConverterTypeIntentHash_lower(_ value: IntentHash) -> RustBuffer {
    return FfiConverterTypeIntentHash.lower(value)
}

public struct IntentSignature {
    fileprivate let secretMagic: SignatureWithPublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: SignatureWithPublicKey) {
        self.secretMagic = secretMagic
    }
}

extension IntentSignature: Sendable {}
extension IntentSignature: Equatable, Hashable {
    public static func == (lhs: IntentSignature, rhs: IntentSignature) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeIntentSignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentSignature {
        return
            try IntentSignature(
                secretMagic: FfiConverterTypeSignatureWithPublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: IntentSignature, into buf: inout [UInt8]) {
        FfiConverterTypeSignatureWithPublicKey.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeIntentSignature_lift(_ buf: RustBuffer) throws -> IntentSignature {
    return try FfiConverterTypeIntentSignature.lift(buf)
}

public func FfiConverterTypeIntentSignature_lower(_ value: IntentSignature) -> RustBuffer {
    return FfiConverterTypeIntentSignature.lower(value)
}

public struct IntentSignatures {
    public var signatures: [IntentSignature]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signatures: [IntentSignature]) {
        self.signatures = signatures
    }
}

extension IntentSignatures: Sendable {}
extension IntentSignatures: Equatable, Hashable {
    public static func == (lhs: IntentSignatures, rhs: IntentSignatures) -> Bool {
        if lhs.signatures != rhs.signatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signatures)
    }
}

public struct FfiConverterTypeIntentSignatures: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentSignatures {
        return
            try IntentSignatures(
                signatures: FfiConverterSequenceTypeIntentSignature.read(from: &buf)
            )
    }

    public static func write(_ value: IntentSignatures, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeIntentSignature.write(value.signatures, into: &buf)
    }
}

public func FfiConverterTypeIntentSignatures_lift(_ buf: RustBuffer) throws -> IntentSignatures {
    return try FfiConverterTypeIntentSignatures.lift(buf)
}

public func FfiConverterTypeIntentSignatures_lower(_ value: IntentSignatures) -> RustBuffer {
    return FfiConverterTypeIntentSignatures.lower(value)
}

public struct LedgerHardwareWalletFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic,
     * that is secured by the Ledger Hardware Wallet device.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     *
     * Has interior mutability since we must be able to update the
     * last used date.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a LedgerHardwareWalletFactorSource to help user disambiguate between it and another one.
     */
    public var hint: LedgerHardwareWalletHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic,
         * that is secured by the Ledger Hardware Wallet device.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            *
            * Has interior mutability since we must be able to update the
            * last used date.
            */ common: FactorSourceCommon,
        /**
            * Properties describing a LedgerHardwareWalletFactorSource to help user disambiguate between it and another one.
            */ hint: LedgerHardwareWalletHint
    ) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}

extension LedgerHardwareWalletFactorSource: Sendable {}
extension LedgerHardwareWalletFactorSource: Equatable, Hashable {
    public static func == (lhs: LedgerHardwareWalletFactorSource, rhs: LedgerHardwareWalletFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}

public struct FfiConverterTypeLedgerHardwareWalletFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletFactorSource {
        return
            try LedgerHardwareWalletFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                hint: FfiConverterTypeLedgerHardwareWalletHint.read(from: &buf)
            )
    }

    public static func write(_ value: LedgerHardwareWalletFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeLedgerHardwareWalletHint.write(value.hint, into: &buf)
    }
}

public func FfiConverterTypeLedgerHardwareWalletFactorSource_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletFactorSource {
    return try FfiConverterTypeLedgerHardwareWalletFactorSource.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletFactorSource_lower(_ value: LedgerHardwareWalletFactorSource) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletFactorSource.lower(value)
}

public struct LedgerHardwareWalletHint {
    /**
     * "Orange, scratched"
     */
    public var name: String
    /**
     * E.g. `nanoS+`
     */
    public var model: LedgerHardwareWalletModel

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * "Orange, scratched"
         */ name: String,
        /**
            * E.g. `nanoS+`
            */ model: LedgerHardwareWalletModel
    ) {
        self.name = name
        self.model = model
    }
}

extension LedgerHardwareWalletHint: Sendable {}
extension LedgerHardwareWalletHint: Equatable, Hashable {
    public static func == (lhs: LedgerHardwareWalletHint, rhs: LedgerHardwareWalletHint) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
    }
}

public struct FfiConverterTypeLedgerHardwareWalletHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletHint {
        return
            try LedgerHardwareWalletHint(
                name: FfiConverterString.read(from: &buf),
                model: FfiConverterTypeLedgerHardwareWalletModel.read(from: &buf)
            )
    }

    public static func write(_ value: LedgerHardwareWalletHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeLedgerHardwareWalletModel.write(value.model, into: &buf)
    }
}

public func FfiConverterTypeLedgerHardwareWalletHint_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletHint {
    return try FfiConverterTypeLedgerHardwareWalletHint.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletHint_lower(_ value: LedgerHardwareWalletHint) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletHint.lower(value)
}

/**
 * The ledger state against which the response was generated. Can be used to detect if the Network Gateway is returning up-to-date information.
 */
public struct LedgerState {
    /**
     * The logical name of the network
     */
    public var network: String
    /**
     * The state version of the ledger. Each transaction increments the state version by 1.
     */
    public var stateVersion: UInt64
    /**
     * The proposer round timestamp of the consensus round when this transaction was committed to ledger. This is not guaranteed to be strictly increasing, as it is computed as an average across the validator set. If this is significantly behind the current timestamp, the Network Gateway is likely reporting out-dated information, or the network has stalled.
     */
    public var proposerRoundTimestamp: String
    /**
     * The epoch number of the ledger at this state version.
     */
    public var epoch: UInt64
    /**
     * The consensus round in the epoch that this state version was committed in.
     */
    public var round: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The logical name of the network
         */ network: String,
        /**
            * The state version of the ledger. Each transaction increments the state version by 1.
            */ stateVersion: UInt64,
        /**
            * The proposer round timestamp of the consensus round when this transaction was committed to ledger. This is not guaranteed to be strictly increasing, as it is computed as an average across the validator set. If this is significantly behind the current timestamp, the Network Gateway is likely reporting out-dated information, or the network has stalled.
            */ proposerRoundTimestamp: String,
        /**
            * The epoch number of the ledger at this state version.
            */ epoch: UInt64,
        /**
            * The consensus round in the epoch that this state version was committed in.
            */ round: UInt64
    ) {
        self.network = network
        self.stateVersion = stateVersion
        self.proposerRoundTimestamp = proposerRoundTimestamp
        self.epoch = epoch
        self.round = round
    }
}

extension LedgerState: Sendable {}
extension LedgerState: Equatable, Hashable {
    public static func == (lhs: LedgerState, rhs: LedgerState) -> Bool {
        if lhs.network != rhs.network {
            return false
        }
        if lhs.stateVersion != rhs.stateVersion {
            return false
        }
        if lhs.proposerRoundTimestamp != rhs.proposerRoundTimestamp {
            return false
        }
        if lhs.epoch != rhs.epoch {
            return false
        }
        if lhs.round != rhs.round {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(network)
        hasher.combine(stateVersion)
        hasher.combine(proposerRoundTimestamp)
        hasher.combine(epoch)
        hasher.combine(round)
    }
}

public struct FfiConverterTypeLedgerState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerState {
        return
            try LedgerState(
                network: FfiConverterString.read(from: &buf),
                stateVersion: FfiConverterUInt64.read(from: &buf),
                proposerRoundTimestamp: FfiConverterString.read(from: &buf),
                epoch: FfiConverterUInt64.read(from: &buf),
                round: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: LedgerState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.network, into: &buf)
        FfiConverterUInt64.write(value.stateVersion, into: &buf)
        FfiConverterString.write(value.proposerRoundTimestamp, into: &buf)
        FfiConverterUInt64.write(value.epoch, into: &buf)
        FfiConverterUInt64.write(value.round, into: &buf)
    }
}

public func FfiConverterTypeLedgerState_lift(_ buf: RustBuffer) throws -> LedgerState {
    return try FfiConverterTypeLedgerState.lift(buf)
}

public func FfiConverterTypeLedgerState_lower(_ value: LedgerState) -> RustBuffer {
    return FfiConverterTypeLedgerState.lower(value)
}

public struct LegacyOlympiaAccountAddress {
    fileprivate let secretMagic: LegacyOlympiaAccountAddressSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: LegacyOlympiaAccountAddressSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension LegacyOlympiaAccountAddress: Sendable {}
extension LegacyOlympiaAccountAddress: Equatable, Hashable {
    public static func == (lhs: LegacyOlympiaAccountAddress, rhs: LegacyOlympiaAccountAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeLegacyOlympiaAccountAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyOlympiaAccountAddress {
        return
            try LegacyOlympiaAccountAddress(
                secretMagic: FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: LegacyOlympiaAccountAddress, into buf: inout [UInt8]) {
        FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeLegacyOlympiaAccountAddress_lift(_ buf: RustBuffer) throws -> LegacyOlympiaAccountAddress {
    return try FfiConverterTypeLegacyOlympiaAccountAddress.lift(buf)
}

public func FfiConverterTypeLegacyOlympiaAccountAddress_lower(_ value: LegacyOlympiaAccountAddress) -> RustBuffer {
    return FfiConverterTypeLegacyOlympiaAccountAddress.lower(value)
}

/**
 * The QR code data scanned from the Connector Extension
 */
public struct LinkConnectionQrData {
    /**
     * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
     * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
     * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
     */
    public var purpose: RadixConnectPurpose
    /**
     * Used to be able to re-establish the P2P connection
     */
    public var password: RadixConnectPassword
    /**
     * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
     * Each client keeps a record of linked clients' public keys to prevent duplicate links.
     * This is the public key of the other client and it also serves as the seed for the link `ID`.
     */
    public var publicKeyOfOtherParty: Ed25519PublicKey
    /**
     * Represents a signature produced by Connector Extension by signing the hash of the `password`
     * with the private key of the `public_key_of_other_party`.
     */
    public var signature: Ed25519Signature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
         * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
         * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
         */ purpose: RadixConnectPurpose,
        /**
            * Used to be able to re-establish the P2P connection
            */ password: RadixConnectPassword,
        /**
            * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
            * Each client keeps a record of linked clients' public keys to prevent duplicate links.
            * This is the public key of the other client and it also serves as the seed for the link `ID`.
            */ publicKeyOfOtherParty: Ed25519PublicKey,
        /**
            * Represents a signature produced by Connector Extension by signing the hash of the `password`
            * with the private key of the `public_key_of_other_party`.
            */ signature: Ed25519Signature
    ) {
        self.purpose = purpose
        self.password = password
        self.publicKeyOfOtherParty = publicKeyOfOtherParty
        self.signature = signature
    }
}

extension LinkConnectionQrData: Sendable {}
extension LinkConnectionQrData: Equatable, Hashable {
    public static func == (lhs: LinkConnectionQrData, rhs: LinkConnectionQrData) -> Bool {
        if lhs.purpose != rhs.purpose {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.publicKeyOfOtherParty != rhs.publicKeyOfOtherParty {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(purpose)
        hasher.combine(password)
        hasher.combine(publicKeyOfOtherParty)
        hasher.combine(signature)
    }
}

public struct FfiConverterTypeLinkConnectionQRData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LinkConnectionQrData {
        return
            try LinkConnectionQrData(
                purpose: FfiConverterTypeRadixConnectPurpose.read(from: &buf),
                password: FfiConverterTypeRadixConnectPassword.read(from: &buf),
                publicKeyOfOtherParty: FfiConverterTypeEd25519PublicKey.read(from: &buf),
                signature: FfiConverterTypeEd25519Signature.read(from: &buf)
            )
    }

    public static func write(_ value: LinkConnectionQrData, into buf: inout [UInt8]) {
        FfiConverterTypeRadixConnectPurpose.write(value.purpose, into: &buf)
        FfiConverterTypeRadixConnectPassword.write(value.password, into: &buf)
        FfiConverterTypeEd25519PublicKey.write(value.publicKeyOfOtherParty, into: &buf)
        FfiConverterTypeEd25519Signature.write(value.signature, into: &buf)
    }
}

public func FfiConverterTypeLinkConnectionQRData_lift(_ buf: RustBuffer) throws -> LinkConnectionQrData {
    return try FfiConverterTypeLinkConnectionQRData.lift(buf)
}

public func FfiConverterTypeLinkConnectionQRData_lower(_ value: LinkConnectionQrData) -> RustBuffer {
    return FfiConverterTypeLinkConnectionQRData.lower(value)
}

public struct LocaleConfig {
    public var decimalSeparator: String?
    public var groupingSeparator: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(decimalSeparator: String?, groupingSeparator: String?) {
        self.decimalSeparator = decimalSeparator
        self.groupingSeparator = groupingSeparator
    }
}

extension LocaleConfig: Sendable {}
extension LocaleConfig: Equatable, Hashable {
    public static func == (lhs: LocaleConfig, rhs: LocaleConfig) -> Bool {
        if lhs.decimalSeparator != rhs.decimalSeparator {
            return false
        }
        if lhs.groupingSeparator != rhs.groupingSeparator {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(decimalSeparator)
        hasher.combine(groupingSeparator)
    }
}

public struct FfiConverterTypeLocaleConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocaleConfig {
        return
            try LocaleConfig(
                decimalSeparator: FfiConverterOptionString.read(from: &buf),
                groupingSeparator: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: LocaleConfig, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.decimalSeparator, into: &buf)
        FfiConverterOptionString.write(value.groupingSeparator, into: &buf)
    }
}

public func FfiConverterTypeLocaleConfig_lift(_ buf: RustBuffer) throws -> LocaleConfig {
    return try FfiConverterTypeLocaleConfig.lift(buf)
}

public func FfiConverterTypeLocaleConfig_lower(_ value: LocaleConfig) -> RustBuffer {
    return FfiConverterTypeLocaleConfig.lower(value)
}

/**
 * A summary of the manifest
 */
public struct ManifestSummary {
    /**
     * Addresses of accounts withdrawn from in the manifest.
     */
    public var addressesOfAccountsWithdrawnFrom: [AccountAddress]
    /**
     * Addresses of accounts deposited into in the manifest.
     */
    public var addressesOfAccountsDepositedInto: [AccountAddress]
    /**
     * Addresses of accounts encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the accounts of all those addresses, which might be multiple
     * signatures per Account, if MFA has been setup.
     */
    public var addressesOfAccountsRequiringAuth: [AccountAddress]
    /**
     * Addresses of identities (Personas) encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the identities of all those addresses, which might be multiple
     * signatures per Persona, if MFA has been setup.
     */
    public var addressesOfPersonasRequiringAuth: [IdentityAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Addresses of accounts withdrawn from in the manifest.
         */ addressesOfAccountsWithdrawnFrom: [AccountAddress],
        /**
            * Addresses of accounts deposited into in the manifest.
            */ addressesOfAccountsDepositedInto: [AccountAddress],
        /**
            * Addresses of accounts encountered in the manifest where privileged
            * methods were called. The wallets will need to collect signatures
            * of the accounts of all those addresses, which might be multiple
            * signatures per Account, if MFA has been setup.
            */ addressesOfAccountsRequiringAuth: [AccountAddress],
        /**
            * Addresses of identities (Personas) encountered in the manifest where privileged
            * methods were called. The wallets will need to collect signatures
            * of the identities of all those addresses, which might be multiple
            * signatures per Persona, if MFA has been setup.
            */ addressesOfPersonasRequiringAuth: [IdentityAddress]
    ) {
        self.addressesOfAccountsWithdrawnFrom = addressesOfAccountsWithdrawnFrom
        self.addressesOfAccountsDepositedInto = addressesOfAccountsDepositedInto
        self.addressesOfAccountsRequiringAuth = addressesOfAccountsRequiringAuth
        self.addressesOfPersonasRequiringAuth = addressesOfPersonasRequiringAuth
    }
}

extension ManifestSummary: Sendable {}
extension ManifestSummary: Equatable, Hashable {
    public static func == (lhs: ManifestSummary, rhs: ManifestSummary) -> Bool {
        if lhs.addressesOfAccountsWithdrawnFrom != rhs.addressesOfAccountsWithdrawnFrom {
            return false
        }
        if lhs.addressesOfAccountsDepositedInto != rhs.addressesOfAccountsDepositedInto {
            return false
        }
        if lhs.addressesOfAccountsRequiringAuth != rhs.addressesOfAccountsRequiringAuth {
            return false
        }
        if lhs.addressesOfPersonasRequiringAuth != rhs.addressesOfPersonasRequiringAuth {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addressesOfAccountsWithdrawnFrom)
        hasher.combine(addressesOfAccountsDepositedInto)
        hasher.combine(addressesOfAccountsRequiringAuth)
        hasher.combine(addressesOfPersonasRequiringAuth)
    }
}

public struct FfiConverterTypeManifestSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestSummary {
        return
            try ManifestSummary(
                addressesOfAccountsWithdrawnFrom: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
                addressesOfAccountsDepositedInto: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
                addressesOfAccountsRequiringAuth: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
                addressesOfPersonasRequiringAuth: FfiConverterSequenceTypeIdentityAddress.read(from: &buf)
            )
    }

    public static func write(_ value: ManifestSummary, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsWithdrawnFrom, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsDepositedInto, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsRequiringAuth, into: &buf)
        FfiConverterSequenceTypeIdentityAddress.write(value.addressesOfPersonasRequiringAuth, into: &buf)
    }
}

public func FfiConverterTypeManifestSummary_lift(_ buf: RustBuffer) throws -> ManifestSummary {
    return try FfiConverterTypeManifestSummary.lift(buf)
}

public func FfiConverterTypeManifestSummary_lower(_ value: ManifestSummary) -> RustBuffer {
    return FfiConverterTypeManifestSummary.lower(value)
}

public struct Mnemonic {
    public var words: [Bip39Word]
    public var wordCount: Bip39WordCount
    public var language: Bip39Language

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(words: [Bip39Word], wordCount: Bip39WordCount, language: Bip39Language) {
        self.words = words
        self.wordCount = wordCount
        self.language = language
    }
}

extension Mnemonic: Sendable {}
extension Mnemonic: Equatable, Hashable {
    public static func == (lhs: Mnemonic, rhs: Mnemonic) -> Bool {
        if lhs.words != rhs.words {
            return false
        }
        if lhs.wordCount != rhs.wordCount {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(words)
        hasher.combine(wordCount)
        hasher.combine(language)
    }
}

public struct FfiConverterTypeMnemonic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        return
            try Mnemonic(
                words: FfiConverterSequenceTypeBIP39Word.read(from: &buf),
                wordCount: FfiConverterTypeBIP39WordCount.read(from: &buf),
                language: FfiConverterTypeBIP39Language.read(from: &buf)
            )
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBIP39Word.write(value.words, into: &buf)
        FfiConverterTypeBIP39WordCount.write(value.wordCount, into: &buf)
        FfiConverterTypeBIP39Language.write(value.language, into: &buf)
    }
}

public func FfiConverterTypeMnemonic_lift(_ buf: RustBuffer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(buf)
}

public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> RustBuffer {
    return FfiConverterTypeMnemonic.lower(value)
}

/**
 * A BIP39 Mnemonic and BIP39 passphrase - aka "25th word" tuple,
 * from which we can derive a HD Root used for derivation.
 */
public struct MnemonicWithPassphrase {
    public var mnemonic: Mnemonic
    public var passphrase: Bip39Passphrase

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonic: Mnemonic, passphrase: Bip39Passphrase) {
        self.mnemonic = mnemonic
        self.passphrase = passphrase
    }
}

extension MnemonicWithPassphrase: Sendable {}
extension MnemonicWithPassphrase: Equatable, Hashable {
    public static func == (lhs: MnemonicWithPassphrase, rhs: MnemonicWithPassphrase) -> Bool {
        if lhs.mnemonic != rhs.mnemonic {
            return false
        }
        if lhs.passphrase != rhs.passphrase {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonic)
        hasher.combine(passphrase)
    }
}

public struct FfiConverterTypeMnemonicWithPassphrase: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicWithPassphrase {
        return
            try MnemonicWithPassphrase(
                mnemonic: FfiConverterTypeMnemonic.read(from: &buf),
                passphrase: FfiConverterTypeBIP39Passphrase.read(from: &buf)
            )
    }

    public static func write(_ value: MnemonicWithPassphrase, into buf: inout [UInt8]) {
        FfiConverterTypeMnemonic.write(value.mnemonic, into: &buf)
        FfiConverterTypeBIP39Passphrase.write(value.passphrase, into: &buf)
    }
}

public func FfiConverterTypeMnemonicWithPassphrase_lift(_ buf: RustBuffer) throws -> MnemonicWithPassphrase {
    return try FfiConverterTypeMnemonicWithPassphrase.lift(buf)
}

public func FfiConverterTypeMnemonicWithPassphrase_lower(_ value: MnemonicWithPassphrase) -> RustBuffer {
    return FfiConverterTypeMnemonicWithPassphrase.lower(value)
}

/**
 * A version of the Radix Network, for a NetworkID with an identifier (name) and display description (display name)
 */
public struct NetworkDefinition {
    /**
     * A String identifier (always lowercase) with the name of the Network that MUST match what Gateway returns.
     */
    public var logicalName: String
    /**
     * The canonical identifier of this network.
     */
    public var id: NetworkId
    /**
     * A name of the network intended for display purposes only.
     */
    public var displayDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A String identifier (always lowercase) with the name of the Network that MUST match what Gateway returns.
         */ logicalName: String,
        /**
            * The canonical identifier of this network.
            */ id: NetworkId,
        /**
            * A name of the network intended for display purposes only.
            */ displayDescription: String
    ) {
        self.logicalName = logicalName
        self.id = id
        self.displayDescription = displayDescription
    }
}

extension NetworkDefinition: Sendable {}
extension NetworkDefinition: Equatable, Hashable {
    public static func == (lhs: NetworkDefinition, rhs: NetworkDefinition) -> Bool {
        if lhs.logicalName != rhs.logicalName {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.displayDescription != rhs.displayDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(logicalName)
        hasher.combine(id)
        hasher.combine(displayDescription)
    }
}

public struct FfiConverterTypeNetworkDefinition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkDefinition {
        return
            try NetworkDefinition(
                logicalName: FfiConverterString.read(from: &buf),
                id: FfiConverterTypeNetworkID.read(from: &buf),
                displayDescription: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: NetworkDefinition, into buf: inout [UInt8]) {
        FfiConverterString.write(value.logicalName, into: &buf)
        FfiConverterTypeNetworkID.write(value.id, into: &buf)
        FfiConverterString.write(value.displayDescription, into: &buf)
    }
}

public func FfiConverterTypeNetworkDefinition_lift(_ buf: RustBuffer) throws -> NetworkDefinition {
    return try FfiConverterTypeNetworkDefinition.lift(buf)
}

public func FfiConverterTypeNetworkDefinition_lower(_ value: NetworkDefinition) -> RustBuffer {
    return FfiConverterTypeNetworkDefinition.lower(value)
}

public struct NetworkRequest {
    public var url: Url
    public var method: NetworkMethod
    public var headers: [String: String]
    public var body: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: Url, method: NetworkMethod, headers: [String: String], body: BagOfBytes) {
        self.url = url
        self.method = method
        self.headers = headers
        self.body = body
    }
}

extension NetworkRequest: Sendable {}
extension NetworkRequest: Equatable, Hashable {
    public static func == (lhs: NetworkRequest, rhs: NetworkRequest) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(method)
        hasher.combine(headers)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeNetworkRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkRequest {
        return
            try NetworkRequest(
                url: FfiConverterTypeUrl.read(from: &buf),
                method: FfiConverterTypeNetworkMethod.read(from: &buf),
                headers: FfiConverterDictionaryStringString.read(from: &buf),
                body: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: NetworkRequest, into buf: inout [UInt8]) {
        FfiConverterTypeUrl.write(value.url, into: &buf)
        FfiConverterTypeNetworkMethod.write(value.method, into: &buf)
        FfiConverterDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterTypeBagOfBytes.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeNetworkRequest_lift(_ buf: RustBuffer) throws -> NetworkRequest {
    return try FfiConverterTypeNetworkRequest.lift(buf)
}

public func FfiConverterTypeNetworkRequest_lower(_ value: NetworkRequest) -> RustBuffer {
    return FfiConverterTypeNetworkRequest.lower(value)
}

public struct NetworkResponse {
    public var statusCode: UInt16
    /**
     * Can be empty.
     */
    public var body: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(statusCode: UInt16,
                /**
                    * Can be empty.
                    */ body: BagOfBytes)
    {
        self.statusCode = statusCode
        self.body = body
    }
}

extension NetworkResponse: Sendable {}
extension NetworkResponse: Equatable, Hashable {
    public static func == (lhs: NetworkResponse, rhs: NetworkResponse) -> Bool {
        if lhs.statusCode != rhs.statusCode {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(statusCode)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeNetworkResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkResponse {
        return
            try NetworkResponse(
                statusCode: FfiConverterUInt16.read(from: &buf),
                body: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: NetworkResponse, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.statusCode, into: &buf)
        FfiConverterTypeBagOfBytes.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeNetworkResponse_lift(_ buf: RustBuffer) throws -> NetworkResponse {
    return try FfiConverterTypeNetworkResponse.lift(buf)
}

public func FfiConverterTypeNetworkResponse_lower(_ value: NetworkResponse) -> RustBuffer {
    return FfiConverterTypeNetworkResponse.lower(value)
}

/**
 * Information on the global entities created in the transaction.
 */
public struct NewEntities {
    public var metadata: [ResourceAddress: NewlyCreatedResource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(metadata: [ResourceAddress: NewlyCreatedResource]) {
        self.metadata = metadata
    }
}

extension NewEntities: Sendable {}
extension NewEntities: Equatable, Hashable {
    public static func == (lhs: NewEntities, rhs: NewEntities) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
    }
}

public struct FfiConverterTypeNewEntities: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewEntities {
        return
            try NewEntities(
                metadata: FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource.read(from: &buf)
            )
    }

    public static func write(_ value: NewEntities, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource.write(value.metadata, into: &buf)
    }
}

public func FfiConverterTypeNewEntities_lift(_ buf: RustBuffer) throws -> NewEntities {
    return try FfiConverterTypeNewEntities.lift(buf)
}

public func FfiConverterTypeNewEntities_lower(_ value: NewEntities) -> RustBuffer {
    return FfiConverterTypeNewEntities.lower(value)
}

/**
 * Metadata about a newly created Resource
 */
public struct NewlyCreatedResource {
    public var name: String?
    public var symbol: String?
    public var description: String?
    public var iconUrl: String?
    public var tags: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String?, symbol: String?, description: String?, iconUrl: String?, tags: [String]) {
        self.name = name
        self.symbol = symbol
        self.description = description
        self.iconUrl = iconUrl
        self.tags = tags
    }
}

extension NewlyCreatedResource: Sendable {}
extension NewlyCreatedResource: Equatable, Hashable {
    public static func == (lhs: NewlyCreatedResource, rhs: NewlyCreatedResource) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.iconUrl != rhs.iconUrl {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(symbol)
        hasher.combine(description)
        hasher.combine(iconUrl)
        hasher.combine(tags)
    }
}

public struct FfiConverterTypeNewlyCreatedResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewlyCreatedResource {
        return
            try NewlyCreatedResource(
                name: FfiConverterOptionString.read(from: &buf),
                symbol: FfiConverterOptionString.read(from: &buf),
                description: FfiConverterOptionString.read(from: &buf),
                iconUrl: FfiConverterOptionString.read(from: &buf),
                tags: FfiConverterSequenceString.read(from: &buf)
            )
    }

    public static func write(_ value: NewlyCreatedResource, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.symbol, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.iconUrl, into: &buf)
        FfiConverterSequenceString.write(value.tags, into: &buf)
    }
}

public func FfiConverterTypeNewlyCreatedResource_lift(_ buf: RustBuffer) throws -> NewlyCreatedResource {
    return try FfiConverterTypeNewlyCreatedResource.lift(buf)
}

public func FfiConverterTypeNewlyCreatedResource_lower(_ value: NewlyCreatedResource) -> RustBuffer {
    return FfiConverterTypeNewlyCreatedResource.lower(value)
}

/**
 * 32 bytes, typically used as entropy for Mnemonics.
 */
public struct NonEmptyMax32Bytes {
    public var bagOfBytes: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bagOfBytes: BagOfBytes) {
        self.bagOfBytes = bagOfBytes
    }
}

extension NonEmptyMax32Bytes: Sendable {}
extension NonEmptyMax32Bytes: Equatable, Hashable {
    public static func == (lhs: NonEmptyMax32Bytes, rhs: NonEmptyMax32Bytes) -> Bool {
        if lhs.bagOfBytes != rhs.bagOfBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bagOfBytes)
    }
}

public struct FfiConverterTypeNonEmptyMax32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonEmptyMax32Bytes {
        return
            try NonEmptyMax32Bytes(
                bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: NonEmptyMax32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
    }
}

public func FfiConverterTypeNonEmptyMax32Bytes_lift(_ buf: RustBuffer) throws -> NonEmptyMax32Bytes {
    return try FfiConverterTypeNonEmptyMax32Bytes.lift(buf)
}

public func FfiConverterTypeNonEmptyMax32Bytes_lower(_ value: NonEmptyMax32Bytes) -> RustBuffer {
    return FfiConverterTypeNonEmptyMax32Bytes.lower(value)
}

/**
 * 64 bytes, typically used by NonFungibleLocalId::Bytes
 */
public struct NonEmptyMax64Bytes {
    public var bagOfBytes: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bagOfBytes: BagOfBytes) {
        self.bagOfBytes = bagOfBytes
    }
}

extension NonEmptyMax64Bytes: Sendable {}
extension NonEmptyMax64Bytes: Equatable, Hashable {
    public static func == (lhs: NonEmptyMax64Bytes, rhs: NonEmptyMax64Bytes) -> Bool {
        if lhs.bagOfBytes != rhs.bagOfBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bagOfBytes)
    }
}

public struct FfiConverterTypeNonEmptyMax64Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonEmptyMax64Bytes {
        return
            try NonEmptyMax64Bytes(
                bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: NonEmptyMax64Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
    }
}

public func FfiConverterTypeNonEmptyMax64Bytes_lift(_ buf: RustBuffer) throws -> NonEmptyMax64Bytes {
    return try FfiConverterTypeNonEmptyMax64Bytes.lift(buf)
}

public func FfiConverterTypeNonEmptyMax64Bytes_lower(_ value: NonEmptyMax64Bytes) -> RustBuffer {
    return FfiConverterTypeNonEmptyMax64Bytes.lower(value)
}

public struct NonFungibleGlobalId {
    public var resourceAddress: ResourceAddress
    public var nonFungibleLocalId: NonFungibleLocalId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: ResourceAddress, nonFungibleLocalId: NonFungibleLocalId) {
        self.resourceAddress = resourceAddress
        self.nonFungibleLocalId = nonFungibleLocalId
    }
}

extension NonFungibleGlobalId: Sendable {}
extension NonFungibleGlobalId: Equatable, Hashable {
    public static func == (lhs: NonFungibleGlobalId, rhs: NonFungibleGlobalId) -> Bool {
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.nonFungibleLocalId != rhs.nonFungibleLocalId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resourceAddress)
        hasher.combine(nonFungibleLocalId)
    }
}

public struct FfiConverterTypeNonFungibleGlobalId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleGlobalId {
        return
            try NonFungibleGlobalId(
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                nonFungibleLocalId: FfiConverterTypeNonFungibleLocalId.read(from: &buf)
            )
    }

    public static func write(_ value: NonFungibleGlobalId, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeNonFungibleLocalId.write(value.nonFungibleLocalId, into: &buf)
    }
}

public func FfiConverterTypeNonFungibleGlobalId_lift(_ buf: RustBuffer) throws -> NonFungibleGlobalId {
    return try FfiConverterTypeNonFungibleGlobalId.lift(buf)
}

public func FfiConverterTypeNonFungibleGlobalId_lower(_ value: NonFungibleGlobalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleGlobalId.lower(value)
}

/**
 * A string matching `[_0-9a-zA-Z]{1,64}`.
 *
 * This is an internal wrapping of Scrypto's `StringNonFungibleLocalId`
 * with a UniFFI custom converter using `String` as `Builtin`.
 *
 * Using this type instead of `String` directly in `NonFungibleLocalId::Str`,
 * allows us to do impl `From<NonFungibleLocalId> for NonFungibleLocalId` instead
 * of `TryFrom<NonFungibleLocalId>`.
 */
public struct NonFungibleLocalIdString {
    fileprivate let secretMagic: ScryptoStringNonFungibleLocalId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: ScryptoStringNonFungibleLocalId) {
        self.secretMagic = secretMagic
    }
}

extension NonFungibleLocalIdString: Sendable {}
extension NonFungibleLocalIdString: Equatable, Hashable {
    public static func == (lhs: NonFungibleLocalIdString, rhs: NonFungibleLocalIdString) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeNonFungibleLocalIdString: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalIdString {
        return
            try NonFungibleLocalIdString(
                secretMagic: FfiConverterTypeScryptoStringNonFungibleLocalId.read(from: &buf)
            )
    }

    public static func write(_ value: NonFungibleLocalIdString, into buf: inout [UInt8]) {
        FfiConverterTypeScryptoStringNonFungibleLocalId.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeNonFungibleLocalIdString_lift(_ buf: RustBuffer) throws -> NonFungibleLocalIdString {
    return try FfiConverterTypeNonFungibleLocalIdString.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalIdString_lower(_ value: NonFungibleLocalIdString) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalIdString.lower(value)
}

/**
 * NonFungibleResourceAddress is a specialized ResourceAddress for resources
 * which are non fungible, it ALWAYS has an `'n'` after bech32 separator `'1'`, e.g.:
 * `"resource_rdx1nfyg2f68jw7hfdlg5hzvd8ylsa7e0kjl68t5t62v3ttamtejc9wlxa"`.
 *
 * As opposed to a fungible resource address, e.g. that of XRD which has `'t'`
 * after bech32 separator `'1'`, see:
 * `"resource_rdx1tknxxxxxxxxxradxrdxxxxxxxxx009923554798xxxxxxxxxradxrd"`
 *
 * This means that given an instance of `NonFungibleResourceAddress`, it is
 * guaranteed that its entity type is [`::GlobalNonFungibleResourceManager`],
 * and not `::GlobalFungibleResourceManager`.
 *
 * This type can safely be used with [`StakeClaim`]s, unfortunately since Radix Engine
 * and/or network does not validate the resource address of a `NonFungibleGlobalId`,
 * we cannot use this for that type.
 */
public struct NonFungibleResourceAddress {
    fileprivate let secretMagic: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: ResourceAddress) {
        self.secretMagic = secretMagic
    }
}

extension NonFungibleResourceAddress: Sendable {}
extension NonFungibleResourceAddress: Equatable, Hashable {
    public static func == (lhs: NonFungibleResourceAddress, rhs: NonFungibleResourceAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeNonFungibleResourceAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleResourceAddress {
        return
            try NonFungibleResourceAddress(
                secretMagic: FfiConverterTypeResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: NonFungibleResourceAddress, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeNonFungibleResourceAddress_lift(_ buf: RustBuffer) throws -> NonFungibleResourceAddress {
    return try FfiConverterTypeNonFungibleResourceAddress.lift(buf)
}

public func FfiConverterTypeNonFungibleResourceAddress_lower(_ value: NonFungibleResourceAddress) -> RustBuffer {
    return FfiConverterTypeNonFungibleResourceAddress.lower(value)
}

/**
 * A random number generated part of a transaction header,
 * ensuring every transaction os unique even though its
 * transaction manifest might be equal. This nonce is
 * generated by wallets for incoming transactions.
 */
public struct Nonce {
    fileprivate let secretMagic: NonceSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: NonceSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Nonce: Sendable {}
extension Nonce: Equatable, Hashable {
    public static func == (lhs: Nonce, rhs: Nonce) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeNonce: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nonce {
        return
            try Nonce(
                secretMagic: FfiConverterTypeNonceSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Nonce, into buf: inout [UInt8]) {
        FfiConverterTypeNonceSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeNonce_lift(_ buf: RustBuffer) throws -> Nonce {
    return try FfiConverterTypeNonce.lift(buf)
}

public func FfiConverterTypeNonce_lower(_ value: Nonce) -> RustBuffer {
    return FfiConverterTypeNonce.lower(value)
}

public struct NotarizedTransaction {
    public var signedIntent: SignedIntent
    public var notarySignature: NotarySignature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signedIntent: SignedIntent, notarySignature: NotarySignature) {
        self.signedIntent = signedIntent
        self.notarySignature = notarySignature
    }
}

extension NotarizedTransaction: Sendable {}
extension NotarizedTransaction: Equatable, Hashable {
    public static func == (lhs: NotarizedTransaction, rhs: NotarizedTransaction) -> Bool {
        if lhs.signedIntent != rhs.signedIntent {
            return false
        }
        if lhs.notarySignature != rhs.notarySignature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signedIntent)
        hasher.combine(notarySignature)
    }
}

public struct FfiConverterTypeNotarizedTransaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarizedTransaction {
        return
            try NotarizedTransaction(
                signedIntent: FfiConverterTypeSignedIntent.read(from: &buf),
                notarySignature: FfiConverterTypeNotarySignature.read(from: &buf)
            )
    }

    public static func write(_ value: NotarizedTransaction, into buf: inout [UInt8]) {
        FfiConverterTypeSignedIntent.write(value.signedIntent, into: &buf)
        FfiConverterTypeNotarySignature.write(value.notarySignature, into: &buf)
    }
}

public func FfiConverterTypeNotarizedTransaction_lift(_ buf: RustBuffer) throws -> NotarizedTransaction {
    return try FfiConverterTypeNotarizedTransaction.lift(buf)
}

public func FfiConverterTypeNotarizedTransaction_lower(_ value: NotarizedTransaction) -> RustBuffer {
    return FfiConverterTypeNotarizedTransaction.lower(value)
}

public struct NotarySignature {
    fileprivate let secretMagic: Signature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Signature) {
        self.secretMagic = secretMagic
    }
}

extension NotarySignature: Sendable {}
extension NotarySignature: Equatable, Hashable {
    public static func == (lhs: NotarySignature, rhs: NotarySignature) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeNotarySignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarySignature {
        return
            try NotarySignature(
                secretMagic: FfiConverterTypeSignature.read(from: &buf)
            )
    }

    public static func write(_ value: NotarySignature, into buf: inout [UInt8]) {
        FfiConverterTypeSignature.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeNotarySignature_lift(_ buf: RustBuffer) throws -> NotarySignature {
    return try FfiConverterTypeNotarySignature.lift(buf)
}

public func FfiConverterTypeNotarySignature_lower(_ value: NotarySignature) -> RustBuffer {
    return FfiConverterTypeNotarySignature.lower(value)
}

/**
 * Account settings that user has set on the account component
 * On-Ledger, that is set via a transaction mutating the state
 * on the network.
 *
 * This settings include third-party deposits, controlling who
 * can send which assets to this account.
 *
 * These settings SHOULD be kept in sync between local state
 * (in Profile) and On-Ledger.
 */
public struct OnLedgerSettings {
    /**
     * Controls the ability of third-parties to deposit into this account
     */
    public var thirdPartyDeposits: ThirdPartyDeposits

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Controls the ability of third-parties to deposit into this account
         */ thirdPartyDeposits: ThirdPartyDeposits
    ) {
        self.thirdPartyDeposits = thirdPartyDeposits
    }
}

extension OnLedgerSettings: Sendable {}
extension OnLedgerSettings: Equatable, Hashable {
    public static func == (lhs: OnLedgerSettings, rhs: OnLedgerSettings) -> Bool {
        if lhs.thirdPartyDeposits != rhs.thirdPartyDeposits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thirdPartyDeposits)
    }
}

public struct FfiConverterTypeOnLedgerSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnLedgerSettings {
        return
            try OnLedgerSettings(
                thirdPartyDeposits: FfiConverterTypeThirdPartyDeposits.read(from: &buf)
            )
    }

    public static func write(_ value: OnLedgerSettings, into buf: inout [UInt8]) {
        FfiConverterTypeThirdPartyDeposits.write(value.thirdPartyDeposits, into: &buf)
    }
}

public func FfiConverterTypeOnLedgerSettings_lift(_ buf: RustBuffer) throws -> OnLedgerSettings {
    return try FfiConverterTypeOnLedgerSettings.lift(buf)
}

public func FfiConverterTypeOnLedgerSettings_lower(_ value: OnLedgerSettings) -> RustBuffer {
    return FfiConverterTypeOnLedgerSettings.lower(value)
}

/**
 * A client the user have connected P2P with, typically a WebRTC connection with the dApp or Connector Extension.
 * Each client generates a curve25119 keypair. The public key is used as an identifier for the client.
 * The hash of the connection password is used to establish the P2P connection.
 * There can be multiple types of links (trusted vs untrusted) differentiated by `RadixConnectPurpose`.
 * Here are the [CAP-36][doc] requirements.
 *
 * [doc]: https://radixdlt.atlassian.net/wiki/spaces/AT/pages/3251863610/CAP-36+WebRTC+Clients+Protocol
 */
public struct P2pLink {
    /**
     * The most important property of this struct, the `RadixConnectPassword`,
     * is used to be able to re-establish the P2P connection
     */
    public var connectionPassword: RadixConnectPassword
    /**
     * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
     * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
     * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
     */
    public var connectionPurpose: RadixConnectPurpose
    /**
     * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
     * Each client keeps a record of linked clients' public keys to prevent duplicate links.
     * This is the public key of the other client and it also serves as the seed for the link `ID`.
     */
    public var publicKey: Ed25519PublicKey
    /**
     * Client name, e.g. "Chrome on Macbook" or "My work Android" or "My wifes iPhone SE".
     */
    public var displayName: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The most important property of this struct, the `RadixConnectPassword`,
         * is used to be able to re-establish the P2P connection
         */ connectionPassword: RadixConnectPassword,
        /**
            * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
            * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
            * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
            */ connectionPurpose: RadixConnectPurpose,
        /**
            * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
            * Each client keeps a record of linked clients' public keys to prevent duplicate links.
            * This is the public key of the other client and it also serves as the seed for the link `ID`.
            */ publicKey: Ed25519PublicKey,
        /**
            * Client name, e.g. "Chrome on Macbook" or "My work Android" or "My wifes iPhone SE".
            */ displayName: String
    ) {
        self.connectionPassword = connectionPassword
        self.connectionPurpose = connectionPurpose
        self.publicKey = publicKey
        self.displayName = displayName
    }
}

extension P2pLink: Sendable {}
extension P2pLink: Equatable, Hashable {
    public static func == (lhs: P2pLink, rhs: P2pLink) -> Bool {
        if lhs.connectionPassword != rhs.connectionPassword {
            return false
        }
        if lhs.connectionPurpose != rhs.connectionPurpose {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(connectionPassword)
        hasher.combine(connectionPurpose)
        hasher.combine(publicKey)
        hasher.combine(displayName)
    }
}

public struct FfiConverterTypeP2PLink: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> P2pLink {
        return
            try P2pLink(
                connectionPassword: FfiConverterTypeRadixConnectPassword.read(from: &buf),
                connectionPurpose: FfiConverterTypeRadixConnectPurpose.read(from: &buf),
                publicKey: FfiConverterTypeEd25519PublicKey.read(from: &buf),
                displayName: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: P2pLink, into buf: inout [UInt8]) {
        FfiConverterTypeRadixConnectPassword.write(value.connectionPassword, into: &buf)
        FfiConverterTypeRadixConnectPurpose.write(value.connectionPurpose, into: &buf)
        FfiConverterTypeEd25519PublicKey.write(value.publicKey, into: &buf)
        FfiConverterString.write(value.displayName, into: &buf)
    }
}

public func FfiConverterTypeP2PLink_lift(_ buf: RustBuffer) throws -> P2pLink {
    return try FfiConverterTypeP2PLink.lift(buf)
}

public func FfiConverterTypeP2PLink_lower(_ value: P2pLink) -> RustBuffer {
    return FfiConverterTypeP2PLink.lower(value)
}

/**
 * The unique address identifying a package - which is a collection of blueprints on Ledger, e.g.:
 * `"package_rdx1pkgxxxxxxxxxfaucetxxxxxxxxx000034355863xxxxxxxxxfaucet"`
 *
 * PackageAddress has [Scrypto's `EntityType`][entt] type `GlobalPackage`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalPackageAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L241C29-L241C42
 */
public struct PackageAddress {
    fileprivate let secretMagic: RetPackageAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetPackageAddress) {
        self.secretMagic = secretMagic
    }
}

extension PackageAddress: Sendable {}
extension PackageAddress: Equatable, Hashable {
    public static func == (lhs: PackageAddress, rhs: PackageAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypePackageAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PackageAddress {
        return
            try PackageAddress(
                secretMagic: FfiConverterTypeRetPackageAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PackageAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetPackageAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypePackageAddress_lift(_ buf: RustBuffer) throws -> PackageAddress {
    return try FfiConverterTypePackageAddress.lift(buf)
}

public func FfiConverterTypePackageAddress_lower(_ value: PackageAddress) -> RustBuffer {
    return FfiConverterTypePackageAddress.lower(value)
}

public struct PerAssetFungibleResource {
    public var resourceAddress: ResourceAddress
    public var divisibility: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: ResourceAddress, divisibility: UInt8?) {
        self.resourceAddress = resourceAddress
        self.divisibility = divisibility
    }
}

extension PerAssetFungibleResource: Sendable {}
extension PerAssetFungibleResource: Equatable, Hashable {
    public static func == (lhs: PerAssetFungibleResource, rhs: PerAssetFungibleResource) -> Bool {
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.divisibility != rhs.divisibility {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resourceAddress)
        hasher.combine(divisibility)
    }
}

public struct FfiConverterTypePerAssetFungibleResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetFungibleResource {
        return
            try PerAssetFungibleResource(
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                divisibility: FfiConverterOptionUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetFungibleResource, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterOptionUInt8.write(value.divisibility, into: &buf)
    }
}

public func FfiConverterTypePerAssetFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetFungibleResource {
    return try FfiConverterTypePerAssetFungibleResource.lift(buf)
}

public func FfiConverterTypePerAssetFungibleResource_lower(_ value: PerAssetFungibleResource) -> RustBuffer {
    return FfiConverterTypePerAssetFungibleResource.lower(value)
}

/**
 * A fungible transfer to `recipient`, with a specified amount of tokens to send.
 */
public struct PerAssetFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * Amount
     */
    public var amount: Decimal192
    /**
     * The account or account address to send the tokens to.
     */
    public var recipient: AccountOrAddressOf

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */ useTryDepositOrAbort: Bool,
        /**
            * Amount
            */ amount: Decimal192,
        /**
            * The account or account address to send the tokens to.
            */ recipient: AccountOrAddressOf
    ) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.amount = amount
        self.recipient = recipient
    }
}

extension PerAssetFungibleTransfer: Sendable {}
extension PerAssetFungibleTransfer: Equatable, Hashable {
    public static func == (lhs: PerAssetFungibleTransfer, rhs: PerAssetFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.recipient != rhs.recipient {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(amount)
        hasher.combine(recipient)
    }
}

public struct FfiConverterTypePerAssetFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetFungibleTransfer {
        return
            try PerAssetFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
                amount: FfiConverterTypeDecimal192.read(from: &buf),
                recipient: FfiConverterTypeAccountOrAddressOf.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterTypeAccountOrAddressOf.write(value.recipient, into: &buf)
    }
}

public func FfiConverterTypePerAssetFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerAssetFungibleTransfer {
    return try FfiConverterTypePerAssetFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerAssetFungibleTransfer_lower(_ value: PerAssetFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerAssetFungibleTransfer.lower(value)
}

/**
 * A non fungible transfer to `recipient`, with specified Local IDs to send.
 */
public struct PerAssetNonFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * Amount
     */
    public var nonFungibleLocalIds: [NonFungibleLocalId]
    /**
     * The account or account address to send the tokens to.
     */
    public var recipient: AccountOrAddressOf

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */ useTryDepositOrAbort: Bool,
        /**
            * Amount
            */ nonFungibleLocalIds: [NonFungibleLocalId],
        /**
            * The account or account address to send the tokens to.
            */ recipient: AccountOrAddressOf
    ) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.nonFungibleLocalIds = nonFungibleLocalIds
        self.recipient = recipient
    }
}

extension PerAssetNonFungibleTransfer: Sendable {}
extension PerAssetNonFungibleTransfer: Equatable, Hashable {
    public static func == (lhs: PerAssetNonFungibleTransfer, rhs: PerAssetNonFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.nonFungibleLocalIds != rhs.nonFungibleLocalIds {
            return false
        }
        if lhs.recipient != rhs.recipient {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(nonFungibleLocalIds)
        hasher.combine(recipient)
    }
}

public struct FfiConverterTypePerAssetNonFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetNonFungibleTransfer {
        return
            try PerAssetNonFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
                nonFungibleLocalIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                recipient: FfiConverterTypeAccountOrAddressOf.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetNonFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.nonFungibleLocalIds, into: &buf)
        FfiConverterTypeAccountOrAddressOf.write(value.recipient, into: &buf)
    }
}

public func FfiConverterTypePerAssetNonFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerAssetNonFungibleTransfer {
    return try FfiConverterTypePerAssetNonFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerAssetNonFungibleTransfer_lower(_ value: PerAssetNonFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerAssetNonFungibleTransfer.lower(value)
}

public struct PerAssetTransfers {
    public var fromAccount: AccountAddress
    public var fungibleResources: [PerAssetTransfersOfFungibleResource]
    public var nonFungibleResources: [PerAssetTransfersOfNonFungibleResource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fromAccount: AccountAddress, fungibleResources: [PerAssetTransfersOfFungibleResource], nonFungibleResources: [PerAssetTransfersOfNonFungibleResource]) {
        self.fromAccount = fromAccount
        self.fungibleResources = fungibleResources
        self.nonFungibleResources = nonFungibleResources
    }
}

extension PerAssetTransfers: Sendable {}
extension PerAssetTransfers: Equatable, Hashable {
    public static func == (lhs: PerAssetTransfers, rhs: PerAssetTransfers) -> Bool {
        if lhs.fromAccount != rhs.fromAccount {
            return false
        }
        if lhs.fungibleResources != rhs.fungibleResources {
            return false
        }
        if lhs.nonFungibleResources != rhs.nonFungibleResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fromAccount)
        hasher.combine(fungibleResources)
        hasher.combine(nonFungibleResources)
    }
}

public struct FfiConverterTypePerAssetTransfers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfers {
        return
            try PerAssetTransfers(
                fromAccount: FfiConverterTypeAccountAddress.read(from: &buf),
                fungibleResources: FfiConverterSequenceTypePerAssetTransfersOfFungibleResource.read(from: &buf),
                nonFungibleResources: FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetTransfers, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.fromAccount, into: &buf)
        FfiConverterSequenceTypePerAssetTransfersOfFungibleResource.write(value.fungibleResources, into: &buf)
        FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource.write(value.nonFungibleResources, into: &buf)
    }
}

public func FfiConverterTypePerAssetTransfers_lift(_ buf: RustBuffer) throws -> PerAssetTransfers {
    return try FfiConverterTypePerAssetTransfers.lift(buf)
}

public func FfiConverterTypePerAssetTransfers_lower(_ value: PerAssetTransfers) -> RustBuffer {
    return FfiConverterTypePerAssetTransfers.lower(value)
}

public struct PerAssetTransfersOfFungibleResource {
    public var resource: PerAssetFungibleResource
    public var transfers: [PerAssetFungibleTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resource: PerAssetFungibleResource, transfers: [PerAssetFungibleTransfer]) {
        self.resource = resource
        self.transfers = transfers
    }
}

extension PerAssetTransfersOfFungibleResource: Sendable {}
extension PerAssetTransfersOfFungibleResource: Equatable, Hashable {
    public static func == (lhs: PerAssetTransfersOfFungibleResource, rhs: PerAssetTransfersOfFungibleResource) -> Bool {
        if lhs.resource != rhs.resource {
            return false
        }
        if lhs.transfers != rhs.transfers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resource)
        hasher.combine(transfers)
    }
}

public struct FfiConverterTypePerAssetTransfersOfFungibleResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfersOfFungibleResource {
        return
            try PerAssetTransfersOfFungibleResource(
                resource: FfiConverterTypePerAssetFungibleResource.read(from: &buf),
                transfers: FfiConverterSequenceTypePerAssetFungibleTransfer.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetTransfersOfFungibleResource, into buf: inout [UInt8]) {
        FfiConverterTypePerAssetFungibleResource.write(value.resource, into: &buf)
        FfiConverterSequenceTypePerAssetFungibleTransfer.write(value.transfers, into: &buf)
    }
}

public func FfiConverterTypePerAssetTransfersOfFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetTransfersOfFungibleResource {
    return try FfiConverterTypePerAssetTransfersOfFungibleResource.lift(buf)
}

public func FfiConverterTypePerAssetTransfersOfFungibleResource_lower(_ value: PerAssetTransfersOfFungibleResource) -> RustBuffer {
    return FfiConverterTypePerAssetTransfersOfFungibleResource.lower(value)
}

public struct PerAssetTransfersOfNonFungibleResource {
    public var resource: ResourceAddress
    public var transfers: [PerAssetNonFungibleTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resource: ResourceAddress, transfers: [PerAssetNonFungibleTransfer]) {
        self.resource = resource
        self.transfers = transfers
    }
}

extension PerAssetTransfersOfNonFungibleResource: Sendable {}
extension PerAssetTransfersOfNonFungibleResource: Equatable, Hashable {
    public static func == (lhs: PerAssetTransfersOfNonFungibleResource, rhs: PerAssetTransfersOfNonFungibleResource) -> Bool {
        if lhs.resource != rhs.resource {
            return false
        }
        if lhs.transfers != rhs.transfers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resource)
        hasher.combine(transfers)
    }
}

public struct FfiConverterTypePerAssetTransfersOfNonFungibleResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfersOfNonFungibleResource {
        return
            try PerAssetTransfersOfNonFungibleResource(
                resource: FfiConverterTypeResourceAddress.read(from: &buf),
                transfers: FfiConverterSequenceTypePerAssetNonFungibleTransfer.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetTransfersOfNonFungibleResource, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resource, into: &buf)
        FfiConverterSequenceTypePerAssetNonFungibleTransfer.write(value.transfers, into: &buf)
    }
}

public func FfiConverterTypePerAssetTransfersOfNonFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetTransfersOfNonFungibleResource {
    return try FfiConverterTypePerAssetTransfersOfNonFungibleResource.lift(buf)
}

public func FfiConverterTypePerAssetTransfersOfNonFungibleResource_lower(_ value: PerAssetTransfersOfNonFungibleResource) -> RustBuffer {
    return FfiConverterTypePerAssetTransfersOfNonFungibleResource.lower(value)
}

public struct PerRecipientAssetTransfer {
    public var recipient: AccountOrAddressOf
    public var fungibles: [PerRecipientFungibleTransfer]
    public var nonFungibles: [PerRecipientNonFungiblesTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(recipient: AccountOrAddressOf, fungibles: [PerRecipientFungibleTransfer], nonFungibles: [PerRecipientNonFungiblesTransfer]) {
        self.recipient = recipient
        self.fungibles = fungibles
        self.nonFungibles = nonFungibles
    }
}

extension PerRecipientAssetTransfer: Sendable {}
extension PerRecipientAssetTransfer: Equatable, Hashable {
    public static func == (lhs: PerRecipientAssetTransfer, rhs: PerRecipientAssetTransfer) -> Bool {
        if lhs.recipient != rhs.recipient {
            return false
        }
        if lhs.fungibles != rhs.fungibles {
            return false
        }
        if lhs.nonFungibles != rhs.nonFungibles {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(recipient)
        hasher.combine(fungibles)
        hasher.combine(nonFungibles)
    }
}

public struct FfiConverterTypePerRecipientAssetTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientAssetTransfer {
        return
            try PerRecipientAssetTransfer(
                recipient: FfiConverterTypeAccountOrAddressOf.read(from: &buf),
                fungibles: FfiConverterSequenceTypePerRecipientFungibleTransfer.read(from: &buf),
                nonFungibles: FfiConverterSequenceTypePerRecipientNonFungiblesTransfer.read(from: &buf)
            )
    }

    public static func write(_ value: PerRecipientAssetTransfer, into buf: inout [UInt8]) {
        FfiConverterTypeAccountOrAddressOf.write(value.recipient, into: &buf)
        FfiConverterSequenceTypePerRecipientFungibleTransfer.write(value.fungibles, into: &buf)
        FfiConverterSequenceTypePerRecipientNonFungiblesTransfer.write(value.nonFungibles, into: &buf)
    }
}

public func FfiConverterTypePerRecipientAssetTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientAssetTransfer {
    return try FfiConverterTypePerRecipientAssetTransfer.lift(buf)
}

public func FfiConverterTypePerRecipientAssetTransfer_lower(_ value: PerRecipientAssetTransfer) -> RustBuffer {
    return FfiConverterTypePerRecipientAssetTransfer.lower(value)
}

public struct PerRecipientAssetTransfers {
    public var addressOfSender: AccountAddress
    public var transfers: [PerRecipientAssetTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addressOfSender: AccountAddress, transfers: [PerRecipientAssetTransfer]) {
        self.addressOfSender = addressOfSender
        self.transfers = transfers
    }
}

extension PerRecipientAssetTransfers: Sendable {}
extension PerRecipientAssetTransfers: Equatable, Hashable {
    public static func == (lhs: PerRecipientAssetTransfers, rhs: PerRecipientAssetTransfers) -> Bool {
        if lhs.addressOfSender != rhs.addressOfSender {
            return false
        }
        if lhs.transfers != rhs.transfers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addressOfSender)
        hasher.combine(transfers)
    }
}

public struct FfiConverterTypePerRecipientAssetTransfers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientAssetTransfers {
        return
            try PerRecipientAssetTransfers(
                addressOfSender: FfiConverterTypeAccountAddress.read(from: &buf),
                transfers: FfiConverterSequenceTypePerRecipientAssetTransfer.read(from: &buf)
            )
    }

    public static func write(_ value: PerRecipientAssetTransfers, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.addressOfSender, into: &buf)
        FfiConverterSequenceTypePerRecipientAssetTransfer.write(value.transfers, into: &buf)
    }
}

public func FfiConverterTypePerRecipientAssetTransfers_lift(_ buf: RustBuffer) throws -> PerRecipientAssetTransfers {
    return try FfiConverterTypePerRecipientAssetTransfers.lift(buf)
}

public func FfiConverterTypePerRecipientAssetTransfers_lower(_ value: PerRecipientAssetTransfers) -> RustBuffer {
    return FfiConverterTypePerRecipientAssetTransfers.lower(value)
}

/**
 * A fungible transfer of `resource_address` token, with a specified amount
 * of tokens and divisibility.
 */
public struct PerRecipientFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * Amount
     */
    public var amount: Decimal192
    public var divisibility: UInt8?
    /**
     * The address of the resource being sent
     */
    public var resourceAddress: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */ useTryDepositOrAbort: Bool,
        /**
            * Amount
            */ amount: Decimal192, divisibility: UInt8?,
        /**
            * The address of the resource being sent
            */ resourceAddress: ResourceAddress
    ) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.amount = amount
        self.divisibility = divisibility
        self.resourceAddress = resourceAddress
    }
}

extension PerRecipientFungibleTransfer: Sendable {}
extension PerRecipientFungibleTransfer: Equatable, Hashable {
    public static func == (lhs: PerRecipientFungibleTransfer, rhs: PerRecipientFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.divisibility != rhs.divisibility {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(amount)
        hasher.combine(divisibility)
        hasher.combine(resourceAddress)
    }
}

public struct FfiConverterTypePerRecipientFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientFungibleTransfer {
        return
            try PerRecipientFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
                amount: FfiConverterTypeDecimal192.read(from: &buf),
                divisibility: FfiConverterOptionUInt8.read(from: &buf),
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PerRecipientFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterOptionUInt8.write(value.divisibility, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
    }
}

public func FfiConverterTypePerRecipientFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientFungibleTransfer {
    return try FfiConverterTypePerRecipientFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerRecipientFungibleTransfer_lower(_ value: PerRecipientFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerRecipientFungibleTransfer.lower(value)
}

/**
 * A non fungible transfer of `resource_address` token, with specified Local IDs to send.
 */
public struct PerRecipientNonFungiblesTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * The local IDS of the NonFungible tokens being sent
     */
    public var localIds: [NonFungibleLocalId]
    /**
     * The address of the resource being sent
     */
    public var resourceAddress: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */ useTryDepositOrAbort: Bool,
        /**
            * The local IDS of the NonFungible tokens being sent
            */ localIds: [NonFungibleLocalId],
        /**
            * The address of the resource being sent
            */ resourceAddress: ResourceAddress
    ) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.localIds = localIds
        self.resourceAddress = resourceAddress
    }
}

extension PerRecipientNonFungiblesTransfer: Sendable {}
extension PerRecipientNonFungiblesTransfer: Equatable, Hashable {
    public static func == (lhs: PerRecipientNonFungiblesTransfer, rhs: PerRecipientNonFungiblesTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.localIds != rhs.localIds {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(localIds)
        hasher.combine(resourceAddress)
    }
}

public struct FfiConverterTypePerRecipientNonFungiblesTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientNonFungiblesTransfer {
        return
            try PerRecipientNonFungiblesTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
                localIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PerRecipientNonFungiblesTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.localIds, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
    }
}

public func FfiConverterTypePerRecipientNonFungiblesTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientNonFungiblesTransfer {
    return try FfiConverterTypePerRecipientNonFungiblesTransfer.lift(buf)
}

public func FfiConverterTypePerRecipientNonFungiblesTransfer_lower(_ value: PerRecipientNonFungiblesTransfer) -> RustBuffer {
    return FfiConverterTypePerRecipientNonFungiblesTransfer.lower(value)
}

/**
 * A Persona is an identity a user chooses to login to a dApp with, using
 * RadixConnect - Radix decentralized login solution. A persona is very
 * similar to [`Account`]s, in the sense that they are On-Network/On-Ledger
 * components, with a unique network dependent address ([`IdentityAddress`])
 * and with a security state (see [`EntitySecurityState`]) knowing which
 * factor instances that control this component, but with one important
 * difference: a Persona cannot hold funds. It is impossible to transfer
 * any asset to a Persona. The On-Network component representation of
 * the Persona is called `Identity`. The concept "Persona" is a Radix
 * Wallet (Profile) *application* of an Identity.
 *
 * Personas have data (see [`PersonaData`]), which is personal information
 * a user has associated with a this Persona, of different kinds, such as name,
 * email address(es) or phone number(s). The `PersonaData` is **never** uploaded
 * to the Radix Network, i.e. it is a pure Radix Wallet (Profile) construct,
 * On-Network Identities does not know of PersonaData, and never will (well
 * technically, nothing stops a user from building their own wallet and uploading
 * personal information to the metadata of the Identity component... but `Sargon`
 * never will, nor will the Radix Wallet.).
 */
public struct Persona {
    /**
     * The ID of the network this account can be used with.
     */
    public var networkId: NetworkId
    /**
     * The address of an identity, used by Personas, a bech32 encoding of a public key hash
     * that starts with the prefix `"identity_"`, dependent on NetworkID, meaning the same
     * public key used for two IdentityAddresses on two different networks will not have
     * the same address.
     */
    public var address: IdentityAddress
    /**
     * An off-ledger display name or description chosen by the user when they
     * created this persona.
     */
    public var displayName: DisplayName
    /**
     * Describes the state this Persona is in, in regards to how
     * the user controls it, i.e. if it is controlled by a single factor (private key)
     * or an `AccessController` with a potential Multi-Factor setup.
     */
    public var securityState: EntitySecurityState
    /**
     * An order set of `EntityFlag`s used to describe certain Off-ledger
     * user state about this Persona, e.g. if it is marked as hidden or not.
     */
    public var flags: [EntityFlag]
    /**
     * Personal information a user has associated with a certain Persona, of different kinds, such as name,
     * email address(es) or phone number(s). This information is only ever stored in Profile and is never
     * uploaded to the Radix Network.
     */
    public var personaData: PersonaData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network this account can be used with.
         */ networkId: NetworkId,
        /**
            * The address of an identity, used by Personas, a bech32 encoding of a public key hash
            * that starts with the prefix `"identity_"`, dependent on NetworkID, meaning the same
            * public key used for two IdentityAddresses on two different networks will not have
            * the same address.
            */ address: IdentityAddress,
        /**
            * An off-ledger display name or description chosen by the user when they
            * created this persona.
            */ displayName: DisplayName,
        /**
            * Describes the state this Persona is in, in regards to how
            * the user controls it, i.e. if it is controlled by a single factor (private key)
            * or an `AccessController` with a potential Multi-Factor setup.
            */ securityState: EntitySecurityState,
        /**
            * An order set of `EntityFlag`s used to describe certain Off-ledger
            * user state about this Persona, e.g. if it is marked as hidden or not.
            */ flags: [EntityFlag],
        /**
            * Personal information a user has associated with a certain Persona, of different kinds, such as name,
            * email address(es) or phone number(s). This information is only ever stored in Profile and is never
            * uploaded to the Radix Network.
            */ personaData: PersonaData
    ) {
        self.networkId = networkId
        self.address = address
        self.displayName = displayName
        self.securityState = securityState
        self.flags = flags
        self.personaData = personaData
    }
}

extension Persona: Sendable {}
extension Persona: Equatable, Hashable {
    public static func == (lhs: Persona, rhs: Persona) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.securityState != rhs.securityState {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        if lhs.personaData != rhs.personaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(securityState)
        hasher.combine(flags)
        hasher.combine(personaData)
    }
}

public struct FfiConverterTypePersona: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Persona {
        return
            try Persona(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                address: FfiConverterTypeIdentityAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                securityState: FfiConverterTypeEntitySecurityState.read(from: &buf),
                flags: FfiConverterSequenceTypeEntityFlag.read(from: &buf),
                personaData: FfiConverterTypePersonaData.read(from: &buf)
            )
    }

    public static func write(_ value: Persona, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeIdentityAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeEntitySecurityState.write(value.securityState, into: &buf)
        FfiConverterSequenceTypeEntityFlag.write(value.flags, into: &buf)
        FfiConverterTypePersonaData.write(value.personaData, into: &buf)
    }
}

public func FfiConverterTypePersona_lift(_ buf: RustBuffer) throws -> Persona {
    return try FfiConverterTypePersona.lift(buf)
}

public func FfiConverterTypePersona_lower(_ value: Persona) -> RustBuffer {
    return FfiConverterTypePersona.lower(value)
}

/**
 * Personal information a user has associated with a certain Persona, of different kinds, such as name,
 * email address(es) or phone number(s). This information is only ever stored in Profile and is never
 * uploaded to the Radix Network.
 *
 * These entries of different kinds can be queried for in a request sent by a dApp, e.g.
 * Radix Dashboard might ask "Give me ongoing access to Name and 2 Email addresses for
 * a Persona" (just a silly example, Radix Dashboard would never ask for that and why 2 email addresses?).
 *
 * The Profile will then use the fact that each Persona Data Entry has a stable ID so that Profile can
 * refer the entry just by the ID, and Profile can thus record which Persona Data Entry a user has selected
 * to share with the dApp, without duplicating the value of that entry (just like how we use FactorSourceIDs).
 * Since a dApp can ask for *ongoing* access next time the user interacts with the same dApp, if user has
 * not revoked the dApps access, the wallet clients will automatically send back the Persona Data Entry values
 * even if they have been updated - the value might have changed but their IDs have not. Thus if a user
 * deletes a Persona Data Entry (e.g. a phone number), and later re-inputs the same phone number, even
 * it the exact same value is used, it will still be treated as a new entry since its ID is new, meaning
 * that the next time the user interacts with a previously authorized dApp the wallet cannot automatically
 * respond back to dApp with the PersonaData, but user will have to re-authorize the request for ongoing
 * access for the requested PersonaData entries.
 */
public struct PersonaData {
    /**
     * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
     * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
     *
     * Note that the type is Option of `PersonaDataIdentifiedName` and not of type [`PersonaDataEntryName`][name],
     * `PersonaDataIdentifiedName` is essentially a tuple of `(Uuid, PersonaDataEntryName)`.
     *
     * [name]: PersonaDataEntryName
     */
    public var name: PersonaDataIdentifiedName?
    /**
     * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
     * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
     * contain elements with the same value, but under different IDs.
     */
    public var phoneNumbers: CollectionOfPhoneNumbers
    /**
     * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
     * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
     * contain elements with the same value, but under different IDs.
     */
    public var emailAddresses: CollectionOfEmailAddresses

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
         * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
         *
         * Note that the type is Option of `PersonaDataIdentifiedName` and not of type [`PersonaDataEntryName`][name],
         * `PersonaDataIdentifiedName` is essentially a tuple of `(Uuid, PersonaDataEntryName)`.
         *
         * [name]: PersonaDataEntryName
         */ name: PersonaDataIdentifiedName?,
        /**
            * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
            * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
            * contain elements with the same value, but under different IDs.
            */ phoneNumbers: CollectionOfPhoneNumbers,
        /**
            * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
            * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
            * contain elements with the same value, but under different IDs.
            */ emailAddresses: CollectionOfEmailAddresses
    ) {
        self.name = name
        self.phoneNumbers = phoneNumbers
        self.emailAddresses = emailAddresses
    }
}

extension PersonaData: Sendable {}
extension PersonaData: Equatable, Hashable {
    public static func == (lhs: PersonaData, rhs: PersonaData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(phoneNumbers)
        hasher.combine(emailAddresses)
    }
}

public struct FfiConverterTypePersonaData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaData {
        return
            try PersonaData(
                name: FfiConverterOptionTypePersonaDataIdentifiedName.read(from: &buf),
                phoneNumbers: FfiConverterTypeCollectionOfPhoneNumbers.read(from: &buf),
                emailAddresses: FfiConverterTypeCollectionOfEmailAddresses.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaData, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataIdentifiedName.write(value.name, into: &buf)
        FfiConverterTypeCollectionOfPhoneNumbers.write(value.phoneNumbers, into: &buf)
        FfiConverterTypeCollectionOfEmailAddresses.write(value.emailAddresses, into: &buf)
    }
}

public func FfiConverterTypePersonaData_lift(_ buf: RustBuffer) throws -> PersonaData {
    return try FfiConverterTypePersonaData.lift(buf)
}

public func FfiConverterTypePersonaData_lower(_ value: PersonaData) -> RustBuffer {
    return FfiConverterTypePersonaData.lower(value)
}

/**
 * A persons email address they have chosen to associated with a Persona, e.g.
 * `satoshi@btc.org`.
 *
 * Current implementation does not validate the email address other than it
 * cannot be empty (in the future we might add some simple validation).
 */
public struct PersonaDataEntryEmailAddress {
    public var email: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(email: String) {
        self.email = email
    }
}

extension PersonaDataEntryEmailAddress: Sendable {}
extension PersonaDataEntryEmailAddress: Equatable, Hashable {
    public static func == (lhs: PersonaDataEntryEmailAddress, rhs: PersonaDataEntryEmailAddress) -> Bool {
        if lhs.email != rhs.email {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(email)
    }
}

public struct FfiConverterTypePersonaDataEntryEmailAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryEmailAddress {
        return
            try PersonaDataEntryEmailAddress(
                email: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataEntryEmailAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.email, into: &buf)
    }
}

public func FfiConverterTypePersonaDataEntryEmailAddress_lift(_ buf: RustBuffer) throws -> PersonaDataEntryEmailAddress {
    return try FfiConverterTypePersonaDataEntryEmailAddress.lift(buf)
}

public func FfiConverterTypePersonaDataEntryEmailAddress_lower(_ value: PersonaDataEntryEmailAddress) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryEmailAddress.lower(value)
}

/**
 * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
 * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
 *
 * Nickname is optional in the sense that it can be left blank. Family name and given names are never empty.
 *
 * If a name has multiple given names, they all go into the `given_names` String, e.g. Pippi Longstocking's real name -
 * her Swedish name - is in full: "Pippilotta Viktualia Rullgardina Krusmynta Efraimsdotter Långstrump", where her
 * given names: "Pippilotta Viktualia Rullgardina Krusmynta Efraimsdotter" are put in the `given_names` field, and
 * "Långstrump" (Longstocking) is her family name.
 */
public struct PersonaDataEntryName {
    public var variant: PersonaDataNameVariant
    public var familyName: String
    public var givenNames: String
    public var nickname: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(variant: PersonaDataNameVariant, familyName: String, givenNames: String, nickname: String) {
        self.variant = variant
        self.familyName = familyName
        self.givenNames = givenNames
        self.nickname = nickname
    }
}

extension PersonaDataEntryName: Sendable {}
extension PersonaDataEntryName: Equatable, Hashable {
    public static func == (lhs: PersonaDataEntryName, rhs: PersonaDataEntryName) -> Bool {
        if lhs.variant != rhs.variant {
            return false
        }
        if lhs.familyName != rhs.familyName {
            return false
        }
        if lhs.givenNames != rhs.givenNames {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(variant)
        hasher.combine(familyName)
        hasher.combine(givenNames)
        hasher.combine(nickname)
    }
}

public struct FfiConverterTypePersonaDataEntryName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryName {
        return
            try PersonaDataEntryName(
                variant: FfiConverterTypePersonaDataNameVariant.read(from: &buf),
                familyName: FfiConverterString.read(from: &buf),
                givenNames: FfiConverterString.read(from: &buf),
                nickname: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataEntryName, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataNameVariant.write(value.variant, into: &buf)
        FfiConverterString.write(value.familyName, into: &buf)
        FfiConverterString.write(value.givenNames, into: &buf)
        FfiConverterString.write(value.nickname, into: &buf)
    }
}

public func FfiConverterTypePersonaDataEntryName_lift(_ buf: RustBuffer) throws -> PersonaDataEntryName {
    return try FfiConverterTypePersonaDataEntryName.lift(buf)
}

public func FfiConverterTypePersonaDataEntryName_lower(_ value: PersonaDataEntryName) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryName.lower(value)
}

/**
 * A persons telephone number they have chosen to associated with a Persona, e.g.
 * `+46 987 654 321` (don't try calling this number, it does not exist).
 *
 * Current implementation does not validate the phone number other than it
 * cannot be empty, since telephone number validation is tricky.
 */
public struct PersonaDataEntryPhoneNumber {
    public var number: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(number: String) {
        self.number = number
    }
}

extension PersonaDataEntryPhoneNumber: Sendable {}
extension PersonaDataEntryPhoneNumber: Equatable, Hashable {
    public static func == (lhs: PersonaDataEntryPhoneNumber, rhs: PersonaDataEntryPhoneNumber) -> Bool {
        if lhs.number != rhs.number {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(number)
    }
}

public struct FfiConverterTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryPhoneNumber {
        return
            try PersonaDataEntryPhoneNumber(
                number: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataEntryPhoneNumber, into buf: inout [UInt8]) {
        FfiConverterString.write(value.number, into: &buf)
    }
}

public func FfiConverterTypePersonaDataEntryPhoneNumber_lift(_ buf: RustBuffer) throws -> PersonaDataEntryPhoneNumber {
    return try FfiConverterTypePersonaDataEntryPhoneNumber.lift(buf)
}

public func FfiConverterTypePersonaDataEntryPhoneNumber_lower(_ value: PersonaDataEntryPhoneNumber) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryPhoneNumber.lower(value)
}

/**
 * An identifiable Persona email address. Essentially it is a tuple of a
 * [`(PersonaDataEntryEmailAddress, Uuid)`].
 */
public struct PersonaDataIdentifiedEmailAddress {
    public var id: PersonaDataEntryId
    public var value: PersonaDataEntryEmailAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PersonaDataEntryId, value: PersonaDataEntryEmailAddress) {
        self.id = id
        self.value = value
    }
}

extension PersonaDataIdentifiedEmailAddress: Sendable {}
extension PersonaDataIdentifiedEmailAddress: Equatable, Hashable {
    public static func == (lhs: PersonaDataIdentifiedEmailAddress, rhs: PersonaDataIdentifiedEmailAddress) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}

public struct FfiConverterTypePersonaDataIdentifiedEmailAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedEmailAddress {
        return
            try PersonaDataIdentifiedEmailAddress(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
                value: FfiConverterTypePersonaDataEntryEmailAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataIdentifiedEmailAddress, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypePersonaDataEntryEmailAddress.write(value.value, into: &buf)
    }
}

public func FfiConverterTypePersonaDataIdentifiedEmailAddress_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedEmailAddress {
    return try FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedEmailAddress_lower(_ value: PersonaDataIdentifiedEmailAddress) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedEmailAddress.lower(value)
}

/**
 * An identifiable Persona name. Essentially it is a tuple of a
 * [`(PersonaDataEntryName, Uuid)`].
 */
public struct PersonaDataIdentifiedName {
    public var id: PersonaDataEntryId
    public var value: PersonaDataEntryName

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PersonaDataEntryId, value: PersonaDataEntryName) {
        self.id = id
        self.value = value
    }
}

extension PersonaDataIdentifiedName: Sendable {}
extension PersonaDataIdentifiedName: Equatable, Hashable {
    public static func == (lhs: PersonaDataIdentifiedName, rhs: PersonaDataIdentifiedName) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}

public struct FfiConverterTypePersonaDataIdentifiedName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedName {
        return
            try PersonaDataIdentifiedName(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
                value: FfiConverterTypePersonaDataEntryName.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataIdentifiedName, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypePersonaDataEntryName.write(value.value, into: &buf)
    }
}

public func FfiConverterTypePersonaDataIdentifiedName_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedName {
    return try FfiConverterTypePersonaDataIdentifiedName.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedName_lower(_ value: PersonaDataIdentifiedName) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedName.lower(value)
}

/**
 * An identifiable Persona phone number. Essentially it is a tuple of a
 * [`(PersonaDataEntryPhoneNumber, Uuid)`].
 */
public struct PersonaDataIdentifiedPhoneNumber {
    public var id: PersonaDataEntryId
    public var value: PersonaDataEntryPhoneNumber

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PersonaDataEntryId, value: PersonaDataEntryPhoneNumber) {
        self.id = id
        self.value = value
    }
}

extension PersonaDataIdentifiedPhoneNumber: Sendable {}
extension PersonaDataIdentifiedPhoneNumber: Equatable, Hashable {
    public static func == (lhs: PersonaDataIdentifiedPhoneNumber, rhs: PersonaDataIdentifiedPhoneNumber) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}

public struct FfiConverterTypePersonaDataIdentifiedPhoneNumber: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedPhoneNumber {
        return
            try PersonaDataIdentifiedPhoneNumber(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
                value: FfiConverterTypePersonaDataEntryPhoneNumber.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataIdentifiedPhoneNumber, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypePersonaDataEntryPhoneNumber.write(value.value, into: &buf)
    }
}

public func FfiConverterTypePersonaDataIdentifiedPhoneNumber_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedPhoneNumber {
    return try FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedPhoneNumber_lower(_ value: PersonaDataIdentifiedPhoneNumber) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedPhoneNumber.lower(value)
}

public struct PlaintextMessage {
    public var mimeType: String
    public var message: MessageContents

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mimeType: String, message: MessageContents) {
        self.mimeType = mimeType
        self.message = message
    }
}

extension PlaintextMessage: Sendable {}
extension PlaintextMessage: Equatable, Hashable {
    public static func == (lhs: PlaintextMessage, rhs: PlaintextMessage) -> Bool {
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mimeType)
        hasher.combine(message)
    }
}

public struct FfiConverterTypePlaintextMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlaintextMessage {
        return
            try PlaintextMessage(
                mimeType: FfiConverterString.read(from: &buf),
                message: FfiConverterTypeMessageContents.read(from: &buf)
            )
    }

    public static func write(_ value: PlaintextMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mimeType, into: &buf)
        FfiConverterTypeMessageContents.write(value.message, into: &buf)
    }
}

public func FfiConverterTypePlaintextMessage_lift(_ buf: RustBuffer) throws -> PlaintextMessage {
    return try FfiConverterTypePlaintextMessage.lift(buf)
}

public func FfiConverterTypePlaintextMessage_lower(_ value: PlaintextMessage) -> RustBuffer {
    return FfiConverterTypePlaintextMessage.lower(value)
}

/**
 * Addresses identifying an OnLedger (OnNetwork) Liquidity Pool (LP) of tokens that users can contribute
 * Liquidity too, e.g.:
 * `"pool_rdx1c325zs6dz3un8ykkjavy9fkvvyzarkaehgsl408qup6f95aup3le3w"`
 *
 * Typically users contribute to Liquidity Pools by using a Dapp and the Radix Wallet.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of PoolAddresses:
 * * GlobalOneResourcePool
 * * GlobalTwoResourcePool
 * * GlobalMultiResourcePool
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalPoolAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L256-L261
 */
public struct PoolAddress {
    fileprivate let secretMagic: RetPoolAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetPoolAddress) {
        self.secretMagic = secretMagic
    }
}

extension PoolAddress: Sendable {}
extension PoolAddress: Equatable, Hashable {
    public static func == (lhs: PoolAddress, rhs: PoolAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypePoolAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PoolAddress {
        return
            try PoolAddress(
                secretMagic: FfiConverterTypeRetPoolAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PoolAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetPoolAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypePoolAddress_lift(_ buf: RustBuffer) throws -> PoolAddress {
    return try FfiConverterTypePoolAddress.lift(buf)
}

public func FfiConverterTypePoolAddress_lower(_ value: PoolAddress) -> RustBuffer {
    return FfiConverterTypePoolAddress.lower(value)
}

/**
 * A PredictedDecimal is not a guaranteed amount, but a approximated based
 * on the contents of the transaction manifest and the state of the ledger
 * at the time of analysis (preview).
 */
public struct PredictedDecimal {
    public var value: Decimal192
    public var instructionIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Decimal192, instructionIndex: UInt64) {
        self.value = value
        self.instructionIndex = instructionIndex
    }
}

extension PredictedDecimal: Sendable {}
extension PredictedDecimal: Equatable, Hashable {
    public static func == (lhs: PredictedDecimal, rhs: PredictedDecimal) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(instructionIndex)
    }
}

public struct FfiConverterTypePredictedDecimal: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredictedDecimal {
        return
            try PredictedDecimal(
                value: FfiConverterTypeDecimal192.read(from: &buf),
                instructionIndex: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: PredictedDecimal, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
    }
}

public func FfiConverterTypePredictedDecimal_lift(_ buf: RustBuffer) throws -> PredictedDecimal {
    return try FfiConverterTypePredictedDecimal.lift(buf)
}

public func FfiConverterTypePredictedDecimal_lower(_ value: PredictedDecimal) -> RustBuffer {
    return FfiConverterTypePredictedDecimal.lower(value)
}

/**
 * A prediction of a collection of NonFungibleLocalId
 */
public struct PredictedNonFungibleLocalIds {
    public var value: [NonFungibleLocalId]
    public var instructionIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: [NonFungibleLocalId], instructionIndex: UInt64) {
        self.value = value
        self.instructionIndex = instructionIndex
    }
}

extension PredictedNonFungibleLocalIds: Sendable {}
extension PredictedNonFungibleLocalIds: Equatable, Hashable {
    public static func == (lhs: PredictedNonFungibleLocalIds, rhs: PredictedNonFungibleLocalIds) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(instructionIndex)
    }
}

public struct FfiConverterTypePredictedNonFungibleLocalIds: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredictedNonFungibleLocalIds {
        return
            try PredictedNonFungibleLocalIds(
                value: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                instructionIndex: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: PredictedNonFungibleLocalIds, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
    }
}

public func FfiConverterTypePredictedNonFungibleLocalIds_lift(_ buf: RustBuffer) throws -> PredictedNonFungibleLocalIds {
    return try FfiConverterTypePredictedNonFungibleLocalIds.lift(buf)
}

public func FfiConverterTypePredictedNonFungibleLocalIds_lower(_ value: PredictedNonFungibleLocalIds) -> RustBuffer {
    return FfiConverterTypePredictedNonFungibleLocalIds.lower(value)
}

public struct PrivateHierarchicalDeterministicFactorSource {
    public var mnemonicWithPassphrase: MnemonicWithPassphrase
    public var factorSource: DeviceFactorSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonicWithPassphrase: MnemonicWithPassphrase, factorSource: DeviceFactorSource) {
        self.mnemonicWithPassphrase = mnemonicWithPassphrase
        self.factorSource = factorSource
    }
}

extension PrivateHierarchicalDeterministicFactorSource: Sendable {}
extension PrivateHierarchicalDeterministicFactorSource: Equatable, Hashable {
    public static func == (lhs: PrivateHierarchicalDeterministicFactorSource, rhs: PrivateHierarchicalDeterministicFactorSource) -> Bool {
        if lhs.mnemonicWithPassphrase != rhs.mnemonicWithPassphrase {
            return false
        }
        if lhs.factorSource != rhs.factorSource {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonicWithPassphrase)
        hasher.combine(factorSource)
    }
}

public struct FfiConverterTypePrivateHierarchicalDeterministicFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrivateHierarchicalDeterministicFactorSource {
        return
            try PrivateHierarchicalDeterministicFactorSource(
                mnemonicWithPassphrase: FfiConverterTypeMnemonicWithPassphrase.read(from: &buf),
                factorSource: FfiConverterTypeDeviceFactorSource.read(from: &buf)
            )
    }

    public static func write(_ value: PrivateHierarchicalDeterministicFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeMnemonicWithPassphrase.write(value.mnemonicWithPassphrase, into: &buf)
        FfiConverterTypeDeviceFactorSource.write(value.factorSource, into: &buf)
    }
}

public func FfiConverterTypePrivateHierarchicalDeterministicFactorSource_lift(_ buf: RustBuffer) throws -> PrivateHierarchicalDeterministicFactorSource {
    return try FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(buf)
}

public func FfiConverterTypePrivateHierarchicalDeterministicFactorSource_lower(_ value: PrivateHierarchicalDeterministicFactorSource) -> RustBuffer {
    return FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lower(value)
}

/**
 * Representation of the Radix Wallet, contains a list of
 * users Accounts, Personas, Authorized Dapps per network
 * the user has used. It also contains all FactorSources,
 * FactorInstances and wallet App preferences.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert_eq!(Profile::sample(), Profile::sample())
 * ```
 */
public struct Profile {
    /**
     * The header of a Profile(Snapshot) contains crucial metadata
     * about this Profile, such as which JSON data format it is
     * compatible with and which device was used to create it and
     * a hint about its contents.
     */
    public var header: Header
    /**
     * All sources of factors, used for authorization such as spending funds, contains no
     * secrets.
     */
    public var factorSources: [FactorSource]
    /**
     * Settings for this profile in the app, contains default security configs
     * as well as display settings.
     */
    public var appPreferences: AppPreferences
    /**
     * An ordered mapping of NetworkID -> `Profile.Network`, containing
     * all the users Accounts, Personas and AuthorizedDapps the user
     * has created and interacted with on this network.
     */
    public var networks: [ProfileNetwork]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The header of a Profile(Snapshot) contains crucial metadata
         * about this Profile, such as which JSON data format it is
         * compatible with and which device was used to create it and
         * a hint about its contents.
         */ header: Header,
        /**
            * All sources of factors, used for authorization such as spending funds, contains no
            * secrets.
            */ factorSources: [FactorSource],
        /**
            * Settings for this profile in the app, contains default security configs
            * as well as display settings.
            */ appPreferences: AppPreferences,
        /**
            * An ordered mapping of NetworkID -> `Profile.Network`, containing
            * all the users Accounts, Personas and AuthorizedDapps the user
            * has created and interacted with on this network.
            */ networks: [ProfileNetwork]
    ) {
        self.header = header
        self.factorSources = factorSources
        self.appPreferences = appPreferences
        self.networks = networks
    }
}

extension Profile: Sendable {}
extension Profile: Equatable, Hashable {
    public static func == (lhs: Profile, rhs: Profile) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.factorSources != rhs.factorSources {
            return false
        }
        if lhs.appPreferences != rhs.appPreferences {
            return false
        }
        if lhs.networks != rhs.networks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(factorSources)
        hasher.combine(appPreferences)
        hasher.combine(networks)
    }
}

public struct FfiConverterTypeProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Profile {
        return
            try Profile(
                header: FfiConverterTypeHeader.read(from: &buf),
                factorSources: FfiConverterSequenceTypeFactorSource.read(from: &buf),
                appPreferences: FfiConverterTypeAppPreferences.read(from: &buf),
                networks: FfiConverterSequenceTypeProfileNetwork.read(from: &buf)
            )
    }

    public static func write(_ value: Profile, into buf: inout [UInt8]) {
        FfiConverterTypeHeader.write(value.header, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.factorSources, into: &buf)
        FfiConverterTypeAppPreferences.write(value.appPreferences, into: &buf)
        FfiConverterSequenceTypeProfileNetwork.write(value.networks, into: &buf)
    }
}

public func FfiConverterTypeProfile_lift(_ buf: RustBuffer) throws -> Profile {
    return try FfiConverterTypeProfile.lift(buf)
}

public func FfiConverterTypeProfile_lower(_ value: Profile) -> RustBuffer {
    return FfiConverterTypeProfile.lower(value)
}

/**
 * [`Accounts`], [`Personas`] and [`AuthorizedDapps`] for some [`ProfileNetwork`]
 * which user has created/interacted with, all on the same [Radix Network][`NetworkDefinition`],
 * identified by `id` ([`NetworkID`]).
 */
public struct ProfileNetwork {
    /**
     * The ID of the network that has been used to generate the `accounts` and `personas`
     * and on which the `authorizedDapps` have been deployed on.
     */
    public var id: NetworkId
    /**
     * An ordered set of [`Accounts`]` on this network, which are [`Account`]s
     * the user has created on this network.
     */
    public var accounts: [Account]
    /**
     * An ordered set of [`Personas`] on this network, which are [`Persona`]s
     * the user has created on this network.
     */
    public var personas: [Persona]
    /**
     * An ordered set of [`AuthorizedDapps`] on this network, which are
     * [`AuthorizedDapp`]s that the user has interacted with.
     */
    public var authorizedDapps: [AuthorizedDapp]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network that has been used to generate the `accounts` and `personas`
         * and on which the `authorizedDapps` have been deployed on.
         */ id: NetworkId,
        /**
            * An ordered set of [`Accounts`]` on this network, which are [`Account`]s
            * the user has created on this network.
            */ accounts: [Account],
        /**
            * An ordered set of [`Personas`] on this network, which are [`Persona`]s
            * the user has created on this network.
            */ personas: [Persona],
        /**
            * An ordered set of [`AuthorizedDapps`] on this network, which are
            * [`AuthorizedDapp`]s that the user has interacted with.
            */ authorizedDapps: [AuthorizedDapp]
    ) {
        self.id = id
        self.accounts = accounts
        self.personas = personas
        self.authorizedDapps = authorizedDapps
    }
}

extension ProfileNetwork: Sendable {}
extension ProfileNetwork: Equatable, Hashable {
    public static func == (lhs: ProfileNetwork, rhs: ProfileNetwork) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.personas != rhs.personas {
            return false
        }
        if lhs.authorizedDapps != rhs.authorizedDapps {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(accounts)
        hasher.combine(personas)
        hasher.combine(authorizedDapps)
    }
}

public struct FfiConverterTypeProfileNetwork: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileNetwork {
        return
            try ProfileNetwork(
                id: FfiConverterTypeNetworkID.read(from: &buf),
                accounts: FfiConverterSequenceTypeAccount.read(from: &buf),
                personas: FfiConverterSequenceTypePersona.read(from: &buf),
                authorizedDapps: FfiConverterSequenceTypeAuthorizedDapp.read(from: &buf)
            )
    }

    public static func write(_ value: ProfileNetwork, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.id, into: &buf)
        FfiConverterSequenceTypeAccount.write(value.accounts, into: &buf)
        FfiConverterSequenceTypePersona.write(value.personas, into: &buf)
        FfiConverterSequenceTypeAuthorizedDapp.write(value.authorizedDapps, into: &buf)
    }
}

public func FfiConverterTypeProfileNetwork_lift(_ buf: RustBuffer) throws -> ProfileNetwork {
    return try FfiConverterTypeProfileNetwork.lift(buf)
}

public func FfiConverterTypeProfileNetwork_lower(_ value: ProfileNetwork) -> RustBuffer {
    return FfiConverterTypeProfileNetwork.lower(value)
}

public struct RadixConnectMobileDappRequest {
    public var interactionId: WalletInteractionId
    public var sessionId: SessionId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, sessionId: SessionId) {
        self.interactionId = interactionId
        self.sessionId = sessionId
    }
}

extension RadixConnectMobileDappRequest: Sendable {}
extension RadixConnectMobileDappRequest: Equatable, Hashable {
    public static func == (lhs: RadixConnectMobileDappRequest, rhs: RadixConnectMobileDappRequest) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(sessionId)
    }
}

public struct FfiConverterTypeRadixConnectMobileDappRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileDappRequest {
        return
            try RadixConnectMobileDappRequest(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                sessionId: FfiConverterTypeSessionID.read(from: &buf)
            )
    }

    public static func write(_ value: RadixConnectMobileDappRequest, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeSessionID.write(value.sessionId, into: &buf)
    }
}

public func FfiConverterTypeRadixConnectMobileDappRequest_lift(_ buf: RustBuffer) throws -> RadixConnectMobileDappRequest {
    return try FfiConverterTypeRadixConnectMobileDappRequest.lift(buf)
}

public func FfiConverterTypeRadixConnectMobileDappRequest_lower(_ value: RadixConnectMobileDappRequest) -> RustBuffer {
    return FfiConverterTypeRadixConnectMobileDappRequest.lower(value)
}

public struct RadixConnectMobileLinkRequest {
    public var origin: Url
    public var sessionId: SessionId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(origin: Url, sessionId: SessionId) {
        self.origin = origin
        self.sessionId = sessionId
    }
}

extension RadixConnectMobileLinkRequest: Sendable {}
extension RadixConnectMobileLinkRequest: Equatable, Hashable {
    public static func == (lhs: RadixConnectMobileLinkRequest, rhs: RadixConnectMobileLinkRequest) -> Bool {
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(origin)
        hasher.combine(sessionId)
    }
}

public struct FfiConverterTypeRadixConnectMobileLinkRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileLinkRequest {
        return
            try RadixConnectMobileLinkRequest(
                origin: FfiConverterTypeUrl.read(from: &buf),
                sessionId: FfiConverterTypeSessionID.read(from: &buf)
            )
    }

    public static func write(_ value: RadixConnectMobileLinkRequest, into buf: inout [UInt8]) {
        FfiConverterTypeUrl.write(value.origin, into: &buf)
        FfiConverterTypeSessionID.write(value.sessionId, into: &buf)
    }
}

public func FfiConverterTypeRadixConnectMobileLinkRequest_lift(_ buf: RustBuffer) throws -> RadixConnectMobileLinkRequest {
    return try FfiConverterTypeRadixConnectMobileLinkRequest.lift(buf)
}

public func FfiConverterTypeRadixConnectMobileLinkRequest_lower(_ value: RadixConnectMobileLinkRequest) -> RustBuffer {
    return FfiConverterTypeRadixConnectMobileLinkRequest.lower(value)
}

/**
 * The hash of the connection password is used to connect to the Radix Connect Signaling Server,
 * over web sockets. The actual `ConnectionPassword` is used to encrypt all messages sent via
 * the Signaling Server.
 */
public struct RadixConnectPassword {
    public var value: Exactly32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Exactly32Bytes) {
        self.value = value
    }
}

extension RadixConnectPassword: Sendable {}
extension RadixConnectPassword: Equatable, Hashable {
    public static func == (lhs: RadixConnectPassword, rhs: RadixConnectPassword) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeRadixConnectPassword: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectPassword {
        return
            try RadixConnectPassword(
                value: FfiConverterTypeExactly32Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: RadixConnectPassword, into buf: inout [UInt8]) {
        FfiConverterTypeExactly32Bytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeRadixConnectPassword_lift(_ buf: RustBuffer) throws -> RadixConnectPassword {
    return try FfiConverterTypeRadixConnectPassword.lift(buf)
}

public func FfiConverterTypeRadixConnectPassword_lower(_ value: RadixConnectPassword) -> RustBuffer {
    return FfiConverterTypeRadixConnectPassword.lower(value)
}

/**
 * A requested (by Dapp) quantity, e.g. "I want AT LEAST 3 account addresses" or
 * "I want EXACTLY 2 email addresses".
 */
public struct RequestedQuantity {
    public var quantifier: RequestedNumberQuantifier
    public var quantity: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(quantifier: RequestedNumberQuantifier, quantity: UInt16) {
        self.quantifier = quantifier
        self.quantity = quantity
    }
}

extension RequestedQuantity: Sendable {}
extension RequestedQuantity: Equatable, Hashable {
    public static func == (lhs: RequestedQuantity, rhs: RequestedQuantity) -> Bool {
        if lhs.quantifier != rhs.quantifier {
            return false
        }
        if lhs.quantity != rhs.quantity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(quantifier)
        hasher.combine(quantity)
    }
}

public struct FfiConverterTypeRequestedQuantity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedQuantity {
        return
            try RequestedQuantity(
                quantifier: FfiConverterTypeRequestedNumberQuantifier.read(from: &buf),
                quantity: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: RequestedQuantity, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedNumberQuantifier.write(value.quantifier, into: &buf)
        FfiConverterUInt16.write(value.quantity, into: &buf)
    }
}

public func FfiConverterTypeRequestedQuantity_lift(_ buf: RustBuffer) throws -> RequestedQuantity {
    return try FfiConverterTypeRequestedQuantity.lift(buf)
}

public func FfiConverterTypeRequestedQuantity_lower(_ value: RequestedQuantity) -> RustBuffer {
    return FfiConverterTypeRequestedQuantity.lower(value)
}

/**
 * Addresses identifying an asset, either fungible (Token) or non-fungible (NFT), on the Radix network, e.g.
 * `"resource_rdx1tknxxxxxxxxxradxrdxxxxxxxxx009923554798xxxxxxxxxradxrd"`
 * Being the unique identifier of the Radix Token, the Rad, on mainnet.
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of ResourceAddresses:
 * * GlobalFungibleResourceManager
 * * GlobalNonFungibleResourceManager
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalResourceAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L236-L239
 */
public struct ResourceAddress {
    fileprivate let secretMagic: RetResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetResourceAddress) {
        self.secretMagic = secretMagic
    }
}

extension ResourceAddress: Sendable {}
extension ResourceAddress: Equatable, Hashable {
    public static func == (lhs: ResourceAddress, rhs: ResourceAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeResourceAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAddress {
        return
            try ResourceAddress(
                secretMagic: FfiConverterTypeRetResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: ResourceAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetResourceAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeResourceAddress_lift(_ buf: RustBuffer) throws -> ResourceAddress {
    return try FfiConverterTypeResourceAddress.lift(buf)
}

public func FfiConverterTypeResourceAddress_lower(_ value: ResourceAddress) -> RustBuffer {
    return FfiConverterTypeResourceAddress.lower(value)
}

public struct SargonBuildInformation {
    public var sargonVersion: String
    public var dependencies: SargonDependencies

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sargonVersion: String, dependencies: SargonDependencies) {
        self.sargonVersion = sargonVersion
        self.dependencies = dependencies
    }
}

extension SargonBuildInformation: Sendable {}
extension SargonBuildInformation: Equatable, Hashable {
    public static func == (lhs: SargonBuildInformation, rhs: SargonBuildInformation) -> Bool {
        if lhs.sargonVersion != rhs.sargonVersion {
            return false
        }
        if lhs.dependencies != rhs.dependencies {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sargonVersion)
        hasher.combine(dependencies)
    }
}

public struct FfiConverterTypeSargonBuildInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonBuildInformation {
        return
            try SargonBuildInformation(
                sargonVersion: FfiConverterString.read(from: &buf),
                dependencies: FfiConverterTypeSargonDependencies.read(from: &buf)
            )
    }

    public static func write(_ value: SargonBuildInformation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.sargonVersion, into: &buf)
        FfiConverterTypeSargonDependencies.write(value.dependencies, into: &buf)
    }
}

public func FfiConverterTypeSargonBuildInformation_lift(_ buf: RustBuffer) throws -> SargonBuildInformation {
    return try FfiConverterTypeSargonBuildInformation.lift(buf)
}

public func FfiConverterTypeSargonBuildInformation_lower(_ value: SargonBuildInformation) -> RustBuffer {
    return FfiConverterTypeSargonBuildInformation.lower(value)
}

public struct SargonDependencies {
    public var radixEngineToolkit: DependencyInformation
    public var scryptoRadixEngine: DependencyInformation

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(radixEngineToolkit: DependencyInformation, scryptoRadixEngine: DependencyInformation) {
        self.radixEngineToolkit = radixEngineToolkit
        self.scryptoRadixEngine = scryptoRadixEngine
    }
}

extension SargonDependencies: Sendable {}
extension SargonDependencies: Equatable, Hashable {
    public static func == (lhs: SargonDependencies, rhs: SargonDependencies) -> Bool {
        if lhs.radixEngineToolkit != rhs.radixEngineToolkit {
            return false
        }
        if lhs.scryptoRadixEngine != rhs.scryptoRadixEngine {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(radixEngineToolkit)
        hasher.combine(scryptoRadixEngine)
    }
}

public struct FfiConverterTypeSargonDependencies: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonDependencies {
        return
            try SargonDependencies(
                radixEngineToolkit: FfiConverterTypeDependencyInformation.read(from: &buf),
                scryptoRadixEngine: FfiConverterTypeDependencyInformation.read(from: &buf)
            )
    }

    public static func write(_ value: SargonDependencies, into buf: inout [UInt8]) {
        FfiConverterTypeDependencyInformation.write(value.radixEngineToolkit, into: &buf)
        FfiConverterTypeDependencyInformation.write(value.scryptoRadixEngine, into: &buf)
    }
}

public func FfiConverterTypeSargonDependencies_lift(_ buf: RustBuffer) throws -> SargonDependencies {
    return try FfiConverterTypeSargonDependencies.lift(buf)
}

public func FfiConverterTypeSargonDependencies_lower(_ value: SargonDependencies) -> RustBuffer {
    return FfiConverterTypeSargonDependencies.lower(value)
}

/**
 * The currently used Gateway and a collection of other by user added
 * or predefined Gateways the user can switch to.
 */
public struct SavedGateways {
    /**
     * The currently used Gateway, when a user query's asset balances of
     * accounts or submits transactions, this Gateway will be used.
     */
    public var current: Gateway
    /**
     * Other by user added or predefined Gateways the user can switch to.
     * It might be Gateways with different URLs on the SAME network, or
     * other networks, the identifier of a Gateway is the URL.
     */
    public var other: [Gateway]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The currently used Gateway, when a user query's asset balances of
         * accounts or submits transactions, this Gateway will be used.
         */ current: Gateway,
        /**
            * Other by user added or predefined Gateways the user can switch to.
            * It might be Gateways with different URLs on the SAME network, or
            * other networks, the identifier of a Gateway is the URL.
            */ other: [Gateway]
    ) {
        self.current = current
        self.other = other
    }
}

extension SavedGateways: Sendable {}
extension SavedGateways: Equatable, Hashable {
    public static func == (lhs: SavedGateways, rhs: SavedGateways) -> Bool {
        if lhs.current != rhs.current {
            return false
        }
        if lhs.other != rhs.other {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(current)
        hasher.combine(other)
    }
}

public struct FfiConverterTypeSavedGateways: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SavedGateways {
        return
            try SavedGateways(
                current: FfiConverterTypeGateway.read(from: &buf),
                other: FfiConverterSequenceTypeGateway.read(from: &buf)
            )
    }

    public static func write(_ value: SavedGateways, into buf: inout [UInt8]) {
        FfiConverterTypeGateway.write(value.current, into: &buf)
        FfiConverterSequenceTypeGateway.write(value.other, into: &buf)
    }
}

public func FfiConverterTypeSavedGateways_lift(_ buf: RustBuffer) throws -> SavedGateways {
    return try FfiConverterTypeSavedGateways.lift(buf)
}

public func FfiConverterTypeSavedGateways_lower(_ value: SavedGateways) -> RustBuffer {
    return FfiConverterTypeSavedGateways.lower(value)
}

/**
 * A `secp256k1` public key used to verify cryptographic signatures (ECDSA signatures).
 */
public struct Secp256k1PublicKey {
    fileprivate let secretMagic: ScryptoSecp256k1PublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: ScryptoSecp256k1PublicKey) {
        self.secretMagic = secretMagic
    }
}

extension Secp256k1PublicKey: Sendable {}
extension Secp256k1PublicKey: Equatable, Hashable {
    public static func == (lhs: Secp256k1PublicKey, rhs: Secp256k1PublicKey) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeSecp256k1PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1PublicKey {
        return
            try Secp256k1PublicKey(
                secretMagic: FfiConverterTypeScryptoSecp256k1PublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: Secp256k1PublicKey, into buf: inout [UInt8]) {
        FfiConverterTypeScryptoSecp256k1PublicKey.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeSecp256k1PublicKey_lift(_ buf: RustBuffer) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(buf)
}

public func FfiConverterTypeSecp256k1PublicKey_lower(_ value: Secp256k1PublicKey) -> RustBuffer {
    return FfiConverterTypeSecp256k1PublicKey.lower(value)
}

/**
 * Represents an Secp256k1 signature.
 */
public struct Secp256k1Signature {
    public var bytes: Exactly65Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Exactly65Bytes) {
        self.bytes = bytes
    }
}

extension Secp256k1Signature: Sendable {}
extension Secp256k1Signature: Equatable, Hashable {
    public static func == (lhs: Secp256k1Signature, rhs: Secp256k1Signature) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}

public struct FfiConverterTypeSecp256k1Signature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1Signature {
        return
            try Secp256k1Signature(
                bytes: FfiConverterTypeExactly65Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: Secp256k1Signature, into buf: inout [UInt8]) {
        FfiConverterTypeExactly65Bytes.write(value.bytes, into: &buf)
    }
}

public func FfiConverterTypeSecp256k1Signature_lift(_ buf: RustBuffer) throws -> Secp256k1Signature {
    return try FfiConverterTypeSecp256k1Signature.lift(buf)
}

public func FfiConverterTypeSecp256k1Signature_lower(_ value: Secp256k1Signature) -> RustBuffer {
    return FfiConverterTypeSecp256k1Signature.lower(value)
}

/**
 * Controls e.g. if Profile Snapshot gets synced to iCloud or not, and whether
 * developer mode is enabled or not. In future (MFA) we will also save a list of
 * MFA security structure configurations.
 */
public struct Security {
    public var isCloudProfileSyncEnabled: Bool
    public var isDeveloperModeEnabled: Bool
    public var structureConfigurationReferences: [Bool]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isCloudProfileSyncEnabled: Bool, isDeveloperModeEnabled: Bool, structureConfigurationReferences: [Bool]) {
        self.isCloudProfileSyncEnabled = isCloudProfileSyncEnabled
        self.isDeveloperModeEnabled = isDeveloperModeEnabled
        self.structureConfigurationReferences = structureConfigurationReferences
    }
}

extension Security: Sendable {}
extension Security: Equatable, Hashable {
    public static func == (lhs: Security, rhs: Security) -> Bool {
        if lhs.isCloudProfileSyncEnabled != rhs.isCloudProfileSyncEnabled {
            return false
        }
        if lhs.isDeveloperModeEnabled != rhs.isDeveloperModeEnabled {
            return false
        }
        if lhs.structureConfigurationReferences != rhs.structureConfigurationReferences {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCloudProfileSyncEnabled)
        hasher.combine(isDeveloperModeEnabled)
        hasher.combine(structureConfigurationReferences)
    }
}

public struct FfiConverterTypeSecurity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Security {
        return
            try Security(
                isCloudProfileSyncEnabled: FfiConverterBool.read(from: &buf),
                isDeveloperModeEnabled: FfiConverterBool.read(from: &buf),
                structureConfigurationReferences: FfiConverterSequenceBool.read(from: &buf)
            )
    }

    public static func write(_ value: Security, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCloudProfileSyncEnabled, into: &buf)
        FfiConverterBool.write(value.isDeveloperModeEnabled, into: &buf)
        FfiConverterSequenceBool.write(value.structureConfigurationReferences, into: &buf)
    }
}

public func FfiConverterTypeSecurity_lift(_ buf: RustBuffer) throws -> Security {
    return try FfiConverterTypeSecurity.lift(buf)
}

public func FfiConverterTypeSecurity_lower(_ value: Security) -> RustBuffer {
    return FfiConverterTypeSecurity.lower(value)
}

/**
 * Identities for PersonaData entry values a user have shared with a dApp.
 */
public struct SharedPersonaData {
    /**
     * ID of a `PersonaDataEntryName` the user has shared with some dApp on some network,
     * can be `None`.
     */
    public var name: PersonaDataEntryId?
    /**
     * IDs of a `PersonaDataEntryEmailAddress`es the user has shared with some dApp on some network
     * can be `None`, or can be `Some(<EMPTY>)`.
     */
    public var emailAddresses: SharedToDappWithPersonaIDsOfPersonaDataEntries?
    /**
     * IDs of a `PersonaDataEntryPhoneNumber`s the user has shared with some dApp on some network
     * can be `None`, or can be `Some(<EMPTY>)`.
     */
    public var phoneNumbers: SharedToDappWithPersonaIDsOfPersonaDataEntries?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * ID of a `PersonaDataEntryName` the user has shared with some dApp on some network,
         * can be `None`.
         */ name: PersonaDataEntryId?,
        /**
            * IDs of a `PersonaDataEntryEmailAddress`es the user has shared with some dApp on some network
            * can be `None`, or can be `Some(<EMPTY>)`.
            */ emailAddresses: SharedToDappWithPersonaIDsOfPersonaDataEntries?,
        /**
            * IDs of a `PersonaDataEntryPhoneNumber`s the user has shared with some dApp on some network
            * can be `None`, or can be `Some(<EMPTY>)`.
            */ phoneNumbers: SharedToDappWithPersonaIDsOfPersonaDataEntries?
    ) {
        self.name = name
        self.emailAddresses = emailAddresses
        self.phoneNumbers = phoneNumbers
    }
}

extension SharedPersonaData: Sendable {}
extension SharedPersonaData: Equatable, Hashable {
    public static func == (lhs: SharedPersonaData, rhs: SharedPersonaData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(emailAddresses)
        hasher.combine(phoneNumbers)
    }
}

public struct FfiConverterTypeSharedPersonaData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedPersonaData {
        return
            try SharedPersonaData(
                name: FfiConverterOptionTypePersonaDataEntryID.read(from: &buf),
                emailAddresses: FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf),
                phoneNumbers: FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf)
            )
    }

    public static func write(_ value: SharedPersonaData, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataEntryID.write(value.name, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value.emailAddresses, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value.phoneNumbers, into: &buf)
    }
}

public func FfiConverterTypeSharedPersonaData_lift(_ buf: RustBuffer) throws -> SharedPersonaData {
    return try FfiConverterTypeSharedPersonaData.lift(buf)
}

public func FfiConverterTypeSharedPersonaData_lower(_ value: SharedPersonaData) -> RustBuffer {
    return FfiConverterTypeSharedPersonaData.lower(value)
}

/**
 * IDs that have been shared with an Dapp the user has interacted with
 * that fulfill a Dapp request's specified [`RequestedQuantity`].
 */
public struct SharedToDappWithPersonaAccountAddresses {
    /**
     * The requested quantity to be shared by user, sent by a Dapp.
     */
    public var request: RequestedQuantity
    /**
     * The by user shared IDs of data identifiable data shared with the
     * Dapp.
     */
    public var ids: [AccountAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The requested quantity to be shared by user, sent by a Dapp.
         */ request: RequestedQuantity,
        /**
            * The by user shared IDs of data identifiable data shared with the
            * Dapp.
            */ ids: [AccountAddress]
    ) {
        self.request = request
        self.ids = ids
    }
}

extension SharedToDappWithPersonaAccountAddresses: Sendable {}
extension SharedToDappWithPersonaAccountAddresses: Equatable, Hashable {
    public static func == (lhs: SharedToDappWithPersonaAccountAddresses, rhs: SharedToDappWithPersonaAccountAddresses) -> Bool {
        if lhs.request != rhs.request {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(request)
        hasher.combine(ids)
    }
}

public struct FfiConverterTypeSharedToDappWithPersonaAccountAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedToDappWithPersonaAccountAddresses {
        return
            try SharedToDappWithPersonaAccountAddresses(
                request: FfiConverterTypeRequestedQuantity.read(from: &buf),
                ids: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: SharedToDappWithPersonaAccountAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.request, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.ids, into: &buf)
    }
}

public func FfiConverterTypeSharedToDappWithPersonaAccountAddresses_lift(_ buf: RustBuffer) throws -> SharedToDappWithPersonaAccountAddresses {
    return try FfiConverterTypeSharedToDappWithPersonaAccountAddresses.lift(buf)
}

public func FfiConverterTypeSharedToDappWithPersonaAccountAddresses_lower(_ value: SharedToDappWithPersonaAccountAddresses) -> RustBuffer {
    return FfiConverterTypeSharedToDappWithPersonaAccountAddresses.lower(value)
}

/**
 * IDs that have been shared with an Dapp the user has interacted with
 * that fulfill a Dapp request's specified [`RequestedQuantity`].
 */
public struct SharedToDappWithPersonaIDsOfPersonaDataEntries {
    /**
     * The requested quantity to be shared by user, sent by a Dapp.
     */
    public var request: RequestedQuantity
    /**
     * The by user shared IDs of data identifiable data shared with the
     * Dapp.
     */
    public var ids: [PersonaDataEntryId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The requested quantity to be shared by user, sent by a Dapp.
         */ request: RequestedQuantity,
        /**
            * The by user shared IDs of data identifiable data shared with the
            * Dapp.
            */ ids: [PersonaDataEntryId]
    ) {
        self.request = request
        self.ids = ids
    }
}

extension SharedToDappWithPersonaIDsOfPersonaDataEntries: Sendable {}
extension SharedToDappWithPersonaIDsOfPersonaDataEntries: Equatable, Hashable {
    public static func == (lhs: SharedToDappWithPersonaIDsOfPersonaDataEntries, rhs: SharedToDappWithPersonaIDsOfPersonaDataEntries) -> Bool {
        if lhs.request != rhs.request {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(request)
        hasher.combine(ids)
    }
}

public struct FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedToDappWithPersonaIDsOfPersonaDataEntries {
        return
            try SharedToDappWithPersonaIDsOfPersonaDataEntries(
                request: FfiConverterTypeRequestedQuantity.read(from: &buf),
                ids: FfiConverterSequenceTypePersonaDataEntryID.read(from: &buf)
            )
    }

    public static func write(_ value: SharedToDappWithPersonaIDsOfPersonaDataEntries, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.request, into: &buf)
        FfiConverterSequenceTypePersonaDataEntryID.write(value.ids, into: &buf)
    }
}

public func FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries_lift(_ buf: RustBuffer) throws -> SharedToDappWithPersonaIDsOfPersonaDataEntries {
    return try FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.lift(buf)
}

public func FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries_lower(_ value: SharedToDappWithPersonaIDsOfPersonaDataEntries) -> RustBuffer {
    return FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.lower(value)
}

public struct SignedIntent {
    public var intent: TransactionIntent
    public var intentSignatures: IntentSignatures

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(intent: TransactionIntent, intentSignatures: IntentSignatures) {
        self.intent = intent
        self.intentSignatures = intentSignatures
    }
}

extension SignedIntent: Sendable {}
extension SignedIntent: Equatable, Hashable {
    public static func == (lhs: SignedIntent, rhs: SignedIntent) -> Bool {
        if lhs.intent != rhs.intent {
            return false
        }
        if lhs.intentSignatures != rhs.intentSignatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(intent)
        hasher.combine(intentSignatures)
    }
}

public struct FfiConverterTypeSignedIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedIntent {
        return
            try SignedIntent(
                intent: FfiConverterTypeTransactionIntent.read(from: &buf),
                intentSignatures: FfiConverterTypeIntentSignatures.read(from: &buf)
            )
    }

    public static func write(_ value: SignedIntent, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionIntent.write(value.intent, into: &buf)
        FfiConverterTypeIntentSignatures.write(value.intentSignatures, into: &buf)
    }
}

public func FfiConverterTypeSignedIntent_lift(_ buf: RustBuffer) throws -> SignedIntent {
    return try FfiConverterTypeSignedIntent.lift(buf)
}

public func FfiConverterTypeSignedIntent_lower(_ value: SignedIntent) -> RustBuffer {
    return FfiConverterTypeSignedIntent.lower(value)
}

/**
 * A Signed Intent Hash is a bech32 encoded string starting with `"signedintent_"
 */
public struct SignedIntentHash {
    /**
     * Which network this transaction hash is used on
     */
    public var networkId: NetworkId
    /**
     * the hash of the intent
     */
    public var hash: Hash
    /**
     * Bech32 encoded TX id
     */
    public var bech32EncodedTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Which network this transaction hash is used on
         */ networkId: NetworkId,
        /**
            * the hash of the intent
            */ hash: Hash,
        /**
            * Bech32 encoded TX id
            */ bech32EncodedTxId: String
    ) {
        self.networkId = networkId
        self.hash = hash
        self.bech32EncodedTxId = bech32EncodedTxId
    }
}

extension SignedIntentHash: Sendable {}
extension SignedIntentHash: Equatable, Hashable {
    public static func == (lhs: SignedIntentHash, rhs: SignedIntentHash) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(hash)
        hasher.combine(bech32EncodedTxId)
    }
}

public struct FfiConverterTypeSignedIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedIntentHash {
        return
            try SignedIntentHash(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                hash: FfiConverterTypeHash.read(from: &buf),
                bech32EncodedTxId: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: SignedIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeHash.write(value.hash, into: &buf)
        FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
    }
}

public func FfiConverterTypeSignedIntentHash_lift(_ buf: RustBuffer) throws -> SignedIntentHash {
    return try FfiConverterTypeSignedIntentHash.lift(buf)
}

public func FfiConverterTypeSignedIntentHash_lower(_ value: SignedIntentHash) -> RustBuffer {
    return FfiConverterTypeSignedIntentHash.lower(value)
}

public struct StakeClaim {
    public var validatorAddress: ValidatorAddress
    public var resourceAddress: NonFungibleResourceAddress
    public var ids: [NonFungibleLocalId]
    /**
     * The summed claim amount across ids
     */
    public var amount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: ValidatorAddress, resourceAddress: NonFungibleResourceAddress, ids: [NonFungibleLocalId],
                /**
                    * The summed claim amount across ids
                    */ amount: Decimal192)
    {
        self.validatorAddress = validatorAddress
        self.resourceAddress = resourceAddress
        self.ids = ids
        self.amount = amount
    }
}

extension StakeClaim: Sendable {}
extension StakeClaim: Equatable, Hashable {
    public static func == (lhs: StakeClaim, rhs: StakeClaim) -> Bool {
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validatorAddress)
        hasher.combine(resourceAddress)
        hasher.combine(ids)
        hasher.combine(amount)
    }
}

public struct FfiConverterTypeStakeClaim: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StakeClaim {
        return
            try StakeClaim(
                validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf),
                resourceAddress: FfiConverterTypeNonFungibleResourceAddress.read(from: &buf),
                ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                amount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: StakeClaim, into buf: inout [UInt8]) {
        FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeNonFungibleResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.ids, into: &buf)
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
    }
}

public func FfiConverterTypeStakeClaim_lift(_ buf: RustBuffer) throws -> StakeClaim {
    return try FfiConverterTypeStakeClaim.lift(buf)
}

public func FfiConverterTypeStakeClaim_lower(_ value: StakeClaim) -> RustBuffer {
    return FfiConverterTypeStakeClaim.lower(value)
}

/**
 * The response a call to the REST Endpoint:
 * `https://mainnet.radixdlt.com/state/entity/details`
 *
 * Which contains token balances of an account.
 */
public struct StateEntityDetailsResponse {
    public var items: [StateEntityDetailsResponseItem]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [StateEntityDetailsResponseItem]) {
        self.items = items
    }
}

extension StateEntityDetailsResponse: Sendable {}
extension StateEntityDetailsResponse: Equatable, Hashable {
    public static func == (lhs: StateEntityDetailsResponse, rhs: StateEntityDetailsResponse) -> Bool {
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(items)
    }
}

public struct FfiConverterTypeStateEntityDetailsResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateEntityDetailsResponse {
        return
            try StateEntityDetailsResponse(
                items: FfiConverterSequenceTypeStateEntityDetailsResponseItem.read(from: &buf)
            )
    }

    public static func write(_ value: StateEntityDetailsResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeStateEntityDetailsResponseItem.write(value.items, into: &buf)
    }
}

public func FfiConverterTypeStateEntityDetailsResponse_lift(_ buf: RustBuffer) throws -> StateEntityDetailsResponse {
    return try FfiConverterTypeStateEntityDetailsResponse.lift(buf)
}

public func FfiConverterTypeStateEntityDetailsResponse_lower(_ value: StateEntityDetailsResponse) -> RustBuffer {
    return FfiConverterTypeStateEntityDetailsResponse.lower(value)
}

public struct StateEntityDetailsResponseItem {
    public var address: Address
    public var fungibleResources: FungibleResourcesCollection?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: Address, fungibleResources: FungibleResourcesCollection?) {
        self.address = address
        self.fungibleResources = fungibleResources
    }
}

extension StateEntityDetailsResponseItem: Sendable {}
extension StateEntityDetailsResponseItem: Equatable, Hashable {
    public static func == (lhs: StateEntityDetailsResponseItem, rhs: StateEntityDetailsResponseItem) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.fungibleResources != rhs.fungibleResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(fungibleResources)
    }
}

public struct FfiConverterTypeStateEntityDetailsResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateEntityDetailsResponseItem {
        return
            try StateEntityDetailsResponseItem(
                address: FfiConverterTypeAddress.read(from: &buf),
                fungibleResources: FfiConverterOptionTypeFungibleResourcesCollection.read(from: &buf)
            )
    }

    public static func write(_ value: StateEntityDetailsResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.address, into: &buf)
        FfiConverterOptionTypeFungibleResourcesCollection.write(value.fungibleResources, into: &buf)
    }
}

public func FfiConverterTypeStateEntityDetailsResponseItem_lift(_ buf: RustBuffer) throws -> StateEntityDetailsResponseItem {
    return try FfiConverterTypeStateEntityDetailsResponseItem.lift(buf)
}

public func FfiConverterTypeStateEntityDetailsResponseItem_lower(_ value: StateEntityDetailsResponseItem) -> RustBuffer {
    return FfiConverterTypeStateEntityDetailsResponseItem.lower(value)
}

/**
 * Controls the ability of third-parties to deposit into a certain account, this is
 * useful for users who wish to not be able to receive airdrops.
 */
public struct ThirdPartyDeposits {
    /**
     * Controls the ability of third-parties to deposit into this account
     */
    public var depositRule: DepositRule
    /**
     * Denies or allows third-party deposits of specific assets by ignoring the `depositMode`
     * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
     * thus the value is unknown.
     */
    public var assetsExceptionList: [AssetException]?
    /**
     * Allows certain third-party depositors to deposit assets freely.
     * Note: There is no `deny` counterpart for this.
     * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
     * thus the value is unknown.
     */
    public var depositorsAllowList: [ResourceOrNonFungible]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Controls the ability of third-parties to deposit into this account
         */ depositRule: DepositRule,
        /**
            * Denies or allows third-party deposits of specific assets by ignoring the `depositMode`
            * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
            * thus the value is unknown.
            */ assetsExceptionList: [AssetException]?,
        /**
            * Allows certain third-party depositors to deposit assets freely.
            * Note: There is no `deny` counterpart for this.
            * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
            * thus the value is unknown.
            */ depositorsAllowList: [ResourceOrNonFungible]?
    ) {
        self.depositRule = depositRule
        self.assetsExceptionList = assetsExceptionList
        self.depositorsAllowList = depositorsAllowList
    }
}

extension ThirdPartyDeposits: Sendable {}
extension ThirdPartyDeposits: Equatable, Hashable {
    public static func == (lhs: ThirdPartyDeposits, rhs: ThirdPartyDeposits) -> Bool {
        if lhs.depositRule != rhs.depositRule {
            return false
        }
        if lhs.assetsExceptionList != rhs.assetsExceptionList {
            return false
        }
        if lhs.depositorsAllowList != rhs.depositorsAllowList {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(depositRule)
        hasher.combine(assetsExceptionList)
        hasher.combine(depositorsAllowList)
    }
}

public struct FfiConverterTypeThirdPartyDeposits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThirdPartyDeposits {
        return
            try ThirdPartyDeposits(
                depositRule: FfiConverterTypeDepositRule.read(from: &buf),
                assetsExceptionList: FfiConverterOptionSequenceTypeAssetException.read(from: &buf),
                depositorsAllowList: FfiConverterOptionSequenceTypeResourceOrNonFungible.read(from: &buf)
            )
    }

    public static func write(_ value: ThirdPartyDeposits, into buf: inout [UInt8]) {
        FfiConverterTypeDepositRule.write(value.depositRule, into: &buf)
        FfiConverterOptionSequenceTypeAssetException.write(value.assetsExceptionList, into: &buf)
        FfiConverterOptionSequenceTypeResourceOrNonFungible.write(value.depositorsAllowList, into: &buf)
    }
}

public func FfiConverterTypeThirdPartyDeposits_lift(_ buf: RustBuffer) throws -> ThirdPartyDeposits {
    return try FfiConverterTypeThirdPartyDeposits.lift(buf)
}

public func FfiConverterTypeThirdPartyDeposits_lower(_ value: ThirdPartyDeposits) -> RustBuffer {
    return FfiConverterTypeThirdPartyDeposits.lower(value)
}

public struct TokenDefinitionMetadata {
    public var name: String
    public var description: String
    public var symbol: String
    public var iconUrl: String
    public var tags: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, description: String, symbol: String, iconUrl: String, tags: [String]) {
        self.name = name
        self.description = description
        self.symbol = symbol
        self.iconUrl = iconUrl
        self.tags = tags
    }
}

extension TokenDefinitionMetadata: Sendable {}
extension TokenDefinitionMetadata: Equatable, Hashable {
    public static func == (lhs: TokenDefinitionMetadata, rhs: TokenDefinitionMetadata) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.iconUrl != rhs.iconUrl {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(symbol)
        hasher.combine(iconUrl)
        hasher.combine(tags)
    }
}

public struct FfiConverterTypeTokenDefinitionMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenDefinitionMetadata {
        return
            try TokenDefinitionMetadata(
                name: FfiConverterString.read(from: &buf),
                description: FfiConverterString.read(from: &buf),
                symbol: FfiConverterString.read(from: &buf),
                iconUrl: FfiConverterString.read(from: &buf),
                tags: FfiConverterSequenceString.read(from: &buf)
            )
    }

    public static func write(_ value: TokenDefinitionMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.symbol, into: &buf)
        FfiConverterString.write(value.iconUrl, into: &buf)
        FfiConverterSequenceString.write(value.tags, into: &buf)
    }
}

public func FfiConverterTypeTokenDefinitionMetadata_lift(_ buf: RustBuffer) throws -> TokenDefinitionMetadata {
    return try FfiConverterTypeTokenDefinitionMetadata.lift(buf)
}

public func FfiConverterTypeTokenDefinitionMetadata_lower(_ value: TokenDefinitionMetadata) -> RustBuffer {
    return FfiConverterTypeTokenDefinitionMetadata.lower(value)
}

/**
 * A contribution to a pool observed in the transaction
 */
public struct TrackedPoolContribution {
    public var poolAddress: PoolAddress
    public var contributedResources: [ResourceAddress: Decimal192]
    public var poolUnitsResourceAddress: ResourceAddress
    public var poolUnitsAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolAddress: PoolAddress, contributedResources: [ResourceAddress: Decimal192], poolUnitsResourceAddress: ResourceAddress, poolUnitsAmount: Decimal192) {
        self.poolAddress = poolAddress
        self.contributedResources = contributedResources
        self.poolUnitsResourceAddress = poolUnitsResourceAddress
        self.poolUnitsAmount = poolUnitsAmount
    }
}

extension TrackedPoolContribution: Sendable {}
extension TrackedPoolContribution: Equatable, Hashable {
    public static func == (lhs: TrackedPoolContribution, rhs: TrackedPoolContribution) -> Bool {
        if lhs.poolAddress != rhs.poolAddress {
            return false
        }
        if lhs.contributedResources != rhs.contributedResources {
            return false
        }
        if lhs.poolUnitsResourceAddress != rhs.poolUnitsResourceAddress {
            return false
        }
        if lhs.poolUnitsAmount != rhs.poolUnitsAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(poolAddress)
        hasher.combine(contributedResources)
        hasher.combine(poolUnitsResourceAddress)
        hasher.combine(poolUnitsAmount)
    }
}

public struct FfiConverterTypeTrackedPoolContribution: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedPoolContribution {
        return
            try TrackedPoolContribution(
                poolAddress: FfiConverterTypePoolAddress.read(from: &buf),
                contributedResources: FfiConverterDictionaryTypeResourceAddressTypeDecimal192.read(from: &buf),
                poolUnitsResourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                poolUnitsAmount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TrackedPoolContribution, into buf: inout [UInt8]) {
        FfiConverterTypePoolAddress.write(value.poolAddress, into: &buf)
        FfiConverterDictionaryTypeResourceAddressTypeDecimal192.write(value.contributedResources, into: &buf)
        FfiConverterTypeResourceAddress.write(value.poolUnitsResourceAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.poolUnitsAmount, into: &buf)
    }
}

public func FfiConverterTypeTrackedPoolContribution_lift(_ buf: RustBuffer) throws -> TrackedPoolContribution {
    return try FfiConverterTypeTrackedPoolContribution.lift(buf)
}

public func FfiConverterTypeTrackedPoolContribution_lower(_ value: TrackedPoolContribution) -> RustBuffer {
    return FfiConverterTypeTrackedPoolContribution.lower(value)
}

/**
 * A pool redemptions observed in the transaction
 */
public struct TrackedPoolRedemption {
    public var poolAddress: PoolAddress
    public var poolUnitsResourceAddress: ResourceAddress
    public var poolUnitsAmount: Decimal192
    public var redeemedResources: [ResourceAddress: Decimal192]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolAddress: PoolAddress, poolUnitsResourceAddress: ResourceAddress, poolUnitsAmount: Decimal192, redeemedResources: [ResourceAddress: Decimal192]) {
        self.poolAddress = poolAddress
        self.poolUnitsResourceAddress = poolUnitsResourceAddress
        self.poolUnitsAmount = poolUnitsAmount
        self.redeemedResources = redeemedResources
    }
}

extension TrackedPoolRedemption: Sendable {}
extension TrackedPoolRedemption: Equatable, Hashable {
    public static func == (lhs: TrackedPoolRedemption, rhs: TrackedPoolRedemption) -> Bool {
        if lhs.poolAddress != rhs.poolAddress {
            return false
        }
        if lhs.poolUnitsResourceAddress != rhs.poolUnitsResourceAddress {
            return false
        }
        if lhs.poolUnitsAmount != rhs.poolUnitsAmount {
            return false
        }
        if lhs.redeemedResources != rhs.redeemedResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(poolAddress)
        hasher.combine(poolUnitsResourceAddress)
        hasher.combine(poolUnitsAmount)
        hasher.combine(redeemedResources)
    }
}

public struct FfiConverterTypeTrackedPoolRedemption: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedPoolRedemption {
        return
            try TrackedPoolRedemption(
                poolAddress: FfiConverterTypePoolAddress.read(from: &buf),
                poolUnitsResourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                poolUnitsAmount: FfiConverterTypeDecimal192.read(from: &buf),
                redeemedResources: FfiConverterDictionaryTypeResourceAddressTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TrackedPoolRedemption, into buf: inout [UInt8]) {
        FfiConverterTypePoolAddress.write(value.poolAddress, into: &buf)
        FfiConverterTypeResourceAddress.write(value.poolUnitsResourceAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.poolUnitsAmount, into: &buf)
        FfiConverterDictionaryTypeResourceAddressTypeDecimal192.write(value.redeemedResources, into: &buf)
    }
}

public func FfiConverterTypeTrackedPoolRedemption_lift(_ buf: RustBuffer) throws -> TrackedPoolRedemption {
    return try FfiConverterTypeTrackedPoolRedemption.lift(buf)
}

public func FfiConverterTypeTrackedPoolRedemption_lower(_ value: TrackedPoolRedemption) -> RustBuffer {
    return FfiConverterTypeTrackedPoolRedemption.lower(value)
}

/**
 * A validator claim observed in the transaction
 */
public struct TrackedValidatorClaim {
    public var validatorAddress: ValidatorAddress
    public var claimNftAddress: ResourceAddress
    public var claimNftIds: [NonFungibleLocalId]
    public var xrdAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: ValidatorAddress, claimNftAddress: ResourceAddress, claimNftIds: [NonFungibleLocalId], xrdAmount: Decimal192) {
        self.validatorAddress = validatorAddress
        self.claimNftAddress = claimNftAddress
        self.claimNftIds = claimNftIds
        self.xrdAmount = xrdAmount
    }
}

extension TrackedValidatorClaim: Sendable {}
extension TrackedValidatorClaim: Equatable, Hashable {
    public static func == (lhs: TrackedValidatorClaim, rhs: TrackedValidatorClaim) -> Bool {
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.claimNftAddress != rhs.claimNftAddress {
            return false
        }
        if lhs.claimNftIds != rhs.claimNftIds {
            return false
        }
        if lhs.xrdAmount != rhs.xrdAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validatorAddress)
        hasher.combine(claimNftAddress)
        hasher.combine(claimNftIds)
        hasher.combine(xrdAmount)
    }
}

public struct FfiConverterTypeTrackedValidatorClaim: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorClaim {
        return
            try TrackedValidatorClaim(
                validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf),
                claimNftAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                claimNftIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                xrdAmount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TrackedValidatorClaim, into buf: inout [UInt8]) {
        FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeResourceAddress.write(value.claimNftAddress, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.claimNftIds, into: &buf)
        FfiConverterTypeDecimal192.write(value.xrdAmount, into: &buf)
    }
}

public func FfiConverterTypeTrackedValidatorClaim_lift(_ buf: RustBuffer) throws -> TrackedValidatorClaim {
    return try FfiConverterTypeTrackedValidatorClaim.lift(buf)
}

public func FfiConverterTypeTrackedValidatorClaim_lower(_ value: TrackedValidatorClaim) -> RustBuffer {
    return FfiConverterTypeTrackedValidatorClaim.lower(value)
}

/**
 * A validator stake observed in the transaction
 */
public struct TrackedValidatorStake {
    public var validatorAddress: ValidatorAddress
    public var xrdAmount: Decimal192
    public var liquidStakeUnitAddress: ResourceAddress
    public var liquidStakeUnitAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: ValidatorAddress, xrdAmount: Decimal192, liquidStakeUnitAddress: ResourceAddress, liquidStakeUnitAmount: Decimal192) {
        self.validatorAddress = validatorAddress
        self.xrdAmount = xrdAmount
        self.liquidStakeUnitAddress = liquidStakeUnitAddress
        self.liquidStakeUnitAmount = liquidStakeUnitAmount
    }
}

extension TrackedValidatorStake: Sendable {}
extension TrackedValidatorStake: Equatable, Hashable {
    public static func == (lhs: TrackedValidatorStake, rhs: TrackedValidatorStake) -> Bool {
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.xrdAmount != rhs.xrdAmount {
            return false
        }
        if lhs.liquidStakeUnitAddress != rhs.liquidStakeUnitAddress {
            return false
        }
        if lhs.liquidStakeUnitAmount != rhs.liquidStakeUnitAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validatorAddress)
        hasher.combine(xrdAmount)
        hasher.combine(liquidStakeUnitAddress)
        hasher.combine(liquidStakeUnitAmount)
    }
}

public struct FfiConverterTypeTrackedValidatorStake: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorStake {
        return
            try TrackedValidatorStake(
                validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf),
                xrdAmount: FfiConverterTypeDecimal192.read(from: &buf),
                liquidStakeUnitAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                liquidStakeUnitAmount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TrackedValidatorStake, into buf: inout [UInt8]) {
        FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.xrdAmount, into: &buf)
        FfiConverterTypeResourceAddress.write(value.liquidStakeUnitAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.liquidStakeUnitAmount, into: &buf)
    }
}

public func FfiConverterTypeTrackedValidatorStake_lift(_ buf: RustBuffer) throws -> TrackedValidatorStake {
    return try FfiConverterTypeTrackedValidatorStake.lift(buf)
}

public func FfiConverterTypeTrackedValidatorStake_lower(_ value: TrackedValidatorStake) -> RustBuffer {
    return FfiConverterTypeTrackedValidatorStake.lower(value)
}

public struct TransactionConstructionResponse {
    public var ledgerState: LedgerState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ledgerState: LedgerState) {
        self.ledgerState = ledgerState
    }
}

extension TransactionConstructionResponse: Sendable {}
extension TransactionConstructionResponse: Equatable, Hashable {
    public static func == (lhs: TransactionConstructionResponse, rhs: TransactionConstructionResponse) -> Bool {
        if lhs.ledgerState != rhs.ledgerState {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ledgerState)
    }
}

public struct FfiConverterTypeTransactionConstructionResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionConstructionResponse {
        return
            try TransactionConstructionResponse(
                ledgerState: FfiConverterTypeLedgerState.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionConstructionResponse, into buf: inout [UInt8]) {
        FfiConverterTypeLedgerState.write(value.ledgerState, into: &buf)
    }
}

public func FfiConverterTypeTransactionConstructionResponse_lift(_ buf: RustBuffer) throws -> TransactionConstructionResponse {
    return try FfiConverterTypeTransactionConstructionResponse.lift(buf)
}

public func FfiConverterTypeTransactionConstructionResponse_lower(_ value: TransactionConstructionResponse) -> RustBuffer {
    return FfiConverterTypeTransactionConstructionResponse.lower(value)
}

public struct TransactionGuarantee {
    /**
     * The guaranteed amount to be obtained on this transaction. For manifest & display purposes.
     */
    public var amount: Decimal192
    /**
     * The percentage the user has selected, which generated the `amount`. For display purposes only.
     */
    public var percentage: Decimal192
    public var instructionIndex: UInt64
    public var resourceAddress: ResourceAddress
    public var resourceDivisibility: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The guaranteed amount to be obtained on this transaction. For manifest & display purposes.
         */ amount: Decimal192,
        /**
            * The percentage the user has selected, which generated the `amount`. For display purposes only.
            */ percentage: Decimal192, instructionIndex: UInt64, resourceAddress: ResourceAddress, resourceDivisibility: UInt8?
    ) {
        self.amount = amount
        self.percentage = percentage
        self.instructionIndex = instructionIndex
        self.resourceAddress = resourceAddress
        self.resourceDivisibility = resourceDivisibility
    }
}

extension TransactionGuarantee: Sendable {}
extension TransactionGuarantee: Equatable, Hashable {
    public static func == (lhs: TransactionGuarantee, rhs: TransactionGuarantee) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.percentage != rhs.percentage {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.resourceDivisibility != rhs.resourceDivisibility {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(percentage)
        hasher.combine(instructionIndex)
        hasher.combine(resourceAddress)
        hasher.combine(resourceDivisibility)
    }
}

public struct FfiConverterTypeTransactionGuarantee: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionGuarantee {
        return
            try TransactionGuarantee(
                amount: FfiConverterTypeDecimal192.read(from: &buf),
                percentage: FfiConverterTypeDecimal192.read(from: &buf),
                instructionIndex: FfiConverterUInt64.read(from: &buf),
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                resourceDivisibility: FfiConverterOptionUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionGuarantee, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterTypeDecimal192.write(value.percentage, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterOptionUInt8.write(value.resourceDivisibility, into: &buf)
    }
}

public func FfiConverterTypeTransactionGuarantee_lift(_ buf: RustBuffer) throws -> TransactionGuarantee {
    return try FfiConverterTypeTransactionGuarantee.lift(buf)
}

public func FfiConverterTypeTransactionGuarantee_lower(_ value: TransactionGuarantee) -> RustBuffer {
    return FfiConverterTypeTransactionGuarantee.lower(value)
}

public struct TransactionHeader {
    public var networkId: NetworkId
    public var startEpochInclusive: Epoch
    public var endEpochExclusive: Epoch
    public var nonce: Nonce
    public var notaryPublicKey: PublicKey
    public var notaryIsSignatory: Bool
    public var tipPercentage: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, startEpochInclusive: Epoch, endEpochExclusive: Epoch, nonce: Nonce, notaryPublicKey: PublicKey, notaryIsSignatory: Bool, tipPercentage: UInt16) {
        self.networkId = networkId
        self.startEpochInclusive = startEpochInclusive
        self.endEpochExclusive = endEpochExclusive
        self.nonce = nonce
        self.notaryPublicKey = notaryPublicKey
        self.notaryIsSignatory = notaryIsSignatory
        self.tipPercentage = tipPercentage
    }
}

extension TransactionHeader: Sendable {}
extension TransactionHeader: Equatable, Hashable {
    public static func == (lhs: TransactionHeader, rhs: TransactionHeader) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.startEpochInclusive != rhs.startEpochInclusive {
            return false
        }
        if lhs.endEpochExclusive != rhs.endEpochExclusive {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.notaryPublicKey != rhs.notaryPublicKey {
            return false
        }
        if lhs.notaryIsSignatory != rhs.notaryIsSignatory {
            return false
        }
        if lhs.tipPercentage != rhs.tipPercentage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(startEpochInclusive)
        hasher.combine(endEpochExclusive)
        hasher.combine(nonce)
        hasher.combine(notaryPublicKey)
        hasher.combine(notaryIsSignatory)
        hasher.combine(tipPercentage)
    }
}

public struct FfiConverterTypeTransactionHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHeader {
        return
            try TransactionHeader(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                startEpochInclusive: FfiConverterTypeEpoch.read(from: &buf),
                endEpochExclusive: FfiConverterTypeEpoch.read(from: &buf),
                nonce: FfiConverterTypeNonce.read(from: &buf),
                notaryPublicKey: FfiConverterTypePublicKey.read(from: &buf),
                notaryIsSignatory: FfiConverterBool.read(from: &buf),
                tipPercentage: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionHeader, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeEpoch.write(value.startEpochInclusive, into: &buf)
        FfiConverterTypeEpoch.write(value.endEpochExclusive, into: &buf)
        FfiConverterTypeNonce.write(value.nonce, into: &buf)
        FfiConverterTypePublicKey.write(value.notaryPublicKey, into: &buf)
        FfiConverterBool.write(value.notaryIsSignatory, into: &buf)
        FfiConverterUInt16.write(value.tipPercentage, into: &buf)
    }
}

public func FfiConverterTypeTransactionHeader_lift(_ buf: RustBuffer) throws -> TransactionHeader {
    return try FfiConverterTypeTransactionHeader.lift(buf)
}

public func FfiConverterTypeTransactionHeader_lower(_ value: TransactionHeader) -> RustBuffer {
    return FfiConverterTypeTransactionHeader.lower(value)
}

public struct TransactionIntent {
    public var header: TransactionHeader
    public var manifest: TransactionManifest
    public var message: Message

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(header: TransactionHeader, manifest: TransactionManifest, message: Message) {
        self.header = header
        self.manifest = manifest
        self.message = message
    }
}

extension TransactionIntent: Sendable {}
extension TransactionIntent: Equatable, Hashable {
    public static func == (lhs: TransactionIntent, rhs: TransactionIntent) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.manifest != rhs.manifest {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(manifest)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeTransactionIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionIntent {
        return
            try TransactionIntent(
                header: FfiConverterTypeTransactionHeader.read(from: &buf),
                manifest: FfiConverterTypeTransactionManifest.read(from: &buf),
                message: FfiConverterTypeMessage.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionIntent, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionHeader.write(value.header, into: &buf)
        FfiConverterTypeTransactionManifest.write(value.manifest, into: &buf)
        FfiConverterTypeMessage.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeTransactionIntent_lift(_ buf: RustBuffer) throws -> TransactionIntent {
    return try FfiConverterTypeTransactionIntent.lift(buf)
}

public func FfiConverterTypeTransactionIntent_lower(_ value: TransactionIntent) -> RustBuffer {
    return FfiConverterTypeTransactionIntent.lower(value)
}

public struct TransactionManifest {
    fileprivate let secretMagic: TransactionManifestSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: TransactionManifestSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension TransactionManifest: Sendable {}
extension TransactionManifest: Equatable, Hashable {
    public static func == (lhs: TransactionManifest, rhs: TransactionManifest) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeTransactionManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifest {
        return
            try TransactionManifest(
                secretMagic: FfiConverterTypeTransactionManifestSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionManifest, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionManifestSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeTransactionManifest_lift(_ buf: RustBuffer) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(buf)
}

public func FfiConverterTypeTransactionManifest_lower(_ value: TransactionManifest) -> RustBuffer {
    return FfiConverterTypeTransactionManifest.lower(value)
}

/**
 * An internal representation of a TransactionManifest,
 * which intentions is to allow the `struct TransactionManifest`
 * to have no public initializers in Swift/Kotlin land, since it
 * can contain a single field:
 * `private let secretMagic: TransactionManifestSecretMagic`
 */
public struct TransactionManifestSecretMagic {
    public var instructions: Instructions
    public var blobs: Blobs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(instructions: Instructions, blobs: Blobs) {
        self.instructions = instructions
        self.blobs = blobs
    }
}

extension TransactionManifestSecretMagic: Sendable {}
extension TransactionManifestSecretMagic: Equatable, Hashable {
    public static func == (lhs: TransactionManifestSecretMagic, rhs: TransactionManifestSecretMagic) -> Bool {
        if lhs.instructions != rhs.instructions {
            return false
        }
        if lhs.blobs != rhs.blobs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(instructions)
        hasher.combine(blobs)
    }
}

public struct FfiConverterTypeTransactionManifestSecretMagic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifestSecretMagic {
        return
            try TransactionManifestSecretMagic(
                instructions: FfiConverterTypeInstructions.read(from: &buf),
                blobs: FfiConverterTypeBlobs.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionManifestSecretMagic, into buf: inout [UInt8]) {
        FfiConverterTypeInstructions.write(value.instructions, into: &buf)
        FfiConverterTypeBlobs.write(value.blobs, into: &buf)
    }
}

public func FfiConverterTypeTransactionManifestSecretMagic_lift(_ buf: RustBuffer) throws -> TransactionManifestSecretMagic {
    return try FfiConverterTypeTransactionManifestSecretMagic.lift(buf)
}

public func FfiConverterTypeTransactionManifestSecretMagic_lower(_ value: TransactionManifestSecretMagic) -> RustBuffer {
    return FfiConverterTypeTransactionManifestSecretMagic.lower(value)
}

/**
 * User Preferences relating to submission of transactions.
 */
public struct TransactionPreferences {
    /**
     * The deposit guarantee that will automatically be added for
     * all deposits in transactions.
     */
    public var defaultDepositGuarantee: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The deposit guarantee that will automatically be added for
         * all deposits in transactions.
         */ defaultDepositGuarantee: Decimal192
    ) {
        self.defaultDepositGuarantee = defaultDepositGuarantee
    }
}

extension TransactionPreferences: Sendable {}
extension TransactionPreferences: Equatable, Hashable {
    public static func == (lhs: TransactionPreferences, rhs: TransactionPreferences) -> Bool {
        if lhs.defaultDepositGuarantee != rhs.defaultDepositGuarantee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(defaultDepositGuarantee)
    }
}

public struct FfiConverterTypeTransactionPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionPreferences {
        return
            try TransactionPreferences(
                defaultDepositGuarantee: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.defaultDepositGuarantee, into: &buf)
    }
}

public func FfiConverterTypeTransactionPreferences_lift(_ buf: RustBuffer) throws -> TransactionPreferences {
    return try FfiConverterTypeTransactionPreferences.lift(buf)
}

public func FfiConverterTypeTransactionPreferences_lower(_ value: TransactionPreferences) -> RustBuffer {
    return FfiConverterTypeTransactionPreferences.lower(value)
}

public struct TransactionPreviewResponse {
    /**
     * Hex-encoded binary blob.
     */
    public var encodedReceipt: String
    public var logs: [TransactionPreviewResponseLogsInner]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hex-encoded binary blob.
         */ encodedReceipt: String, logs: [TransactionPreviewResponseLogsInner]
    ) {
        self.encodedReceipt = encodedReceipt
        self.logs = logs
    }
}

extension TransactionPreviewResponse: Sendable {}
extension TransactionPreviewResponse: Equatable, Hashable {
    public static func == (lhs: TransactionPreviewResponse, rhs: TransactionPreviewResponse) -> Bool {
        if lhs.encodedReceipt != rhs.encodedReceipt {
            return false
        }
        if lhs.logs != rhs.logs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encodedReceipt)
        hasher.combine(logs)
    }
}

public struct FfiConverterTypeTransactionPreviewResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionPreviewResponse {
        return
            try TransactionPreviewResponse(
                encodedReceipt: FfiConverterString.read(from: &buf),
                logs: FfiConverterSequenceTypeTransactionPreviewResponseLogsInner.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionPreviewResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.encodedReceipt, into: &buf)
        FfiConverterSequenceTypeTransactionPreviewResponseLogsInner.write(value.logs, into: &buf)
    }
}

public func FfiConverterTypeTransactionPreviewResponse_lift(_ buf: RustBuffer) throws -> TransactionPreviewResponse {
    return try FfiConverterTypeTransactionPreviewResponse.lift(buf)
}

public func FfiConverterTypeTransactionPreviewResponse_lower(_ value: TransactionPreviewResponse) -> RustBuffer {
    return FfiConverterTypeTransactionPreviewResponse.lower(value)
}

public struct TransactionPreviewResponseLogsInner {
    public var level: String
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(level: String, message: String) {
        self.level = level
        self.message = message
    }
}

extension TransactionPreviewResponseLogsInner: Sendable {}
extension TransactionPreviewResponseLogsInner: Equatable, Hashable {
    public static func == (lhs: TransactionPreviewResponseLogsInner, rhs: TransactionPreviewResponseLogsInner) -> Bool {
        if lhs.level != rhs.level {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(level)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeTransactionPreviewResponseLogsInner: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionPreviewResponseLogsInner {
        return
            try TransactionPreviewResponseLogsInner(
                level: FfiConverterString.read(from: &buf),
                message: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionPreviewResponseLogsInner, into buf: inout [UInt8]) {
        FfiConverterString.write(value.level, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeTransactionPreviewResponseLogsInner_lift(_ buf: RustBuffer) throws -> TransactionPreviewResponseLogsInner {
    return try FfiConverterTypeTransactionPreviewResponseLogsInner.lift(buf)
}

public func FfiConverterTypeTransactionPreviewResponseLogsInner_lower(_ value: TransactionPreviewResponseLogsInner) -> RustBuffer {
    return FfiConverterTypeTransactionPreviewResponseLogsInner.lower(value)
}

public struct TransactionSubmitResponse {
    /**
     * Is true if the transaction is a duplicate of an existing pending transaction.
     */
    public var duplicate: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Is true if the transaction is a duplicate of an existing pending transaction.
         */ duplicate: Bool
    ) {
        self.duplicate = duplicate
    }
}

extension TransactionSubmitResponse: Sendable {}
extension TransactionSubmitResponse: Equatable, Hashable {
    public static func == (lhs: TransactionSubmitResponse, rhs: TransactionSubmitResponse) -> Bool {
        if lhs.duplicate != rhs.duplicate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(duplicate)
    }
}

public struct FfiConverterTypeTransactionSubmitResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionSubmitResponse {
        return
            try TransactionSubmitResponse(
                duplicate: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionSubmitResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.duplicate, into: &buf)
    }
}

public func FfiConverterTypeTransactionSubmitResponse_lift(_ buf: RustBuffer) throws -> TransactionSubmitResponse {
    return try FfiConverterTypeTransactionSubmitResponse.lift(buf)
}

public func FfiConverterTypeTransactionSubmitResponse_lower(_ value: TransactionSubmitResponse) -> RustBuffer {
    return FfiConverterTypeTransactionSubmitResponse.lower(value)
}

public struct U11 {
    public var inner: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inner: UInt16) {
        self.inner = inner
    }
}

extension U11: Sendable {}
extension U11: Equatable, Hashable {
    public static func == (lhs: U11, rhs: U11) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeU11: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U11 {
        return
            try U11(
                inner: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: U11, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeU11_lift(_ buf: RustBuffer) throws -> U11 {
    return try FfiConverterTypeU11.lift(buf)
}

public func FfiConverterTypeU11_lower(_ value: U11) -> RustBuffer {
    return FfiConverterTypeU11.lower(value)
}

/**
 * Basic security control of an unsecured entity. When said entity
 * is "securified" it will no longer be controlled by this `UnsecuredEntityControl`
 * but rather by an `AccessControl`. It is a name space holding the
 * single factor instance which was used to create
 */
public struct UnsecuredEntityControl {
    public var transactionSigning: HierarchicalDeterministicFactorInstance
    /**
     * The factor instance which can be used for ROLA.
     */
    public var authenticationSigning: HierarchicalDeterministicFactorInstance?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionSigning: HierarchicalDeterministicFactorInstance,
                /**
                    * The factor instance which can be used for ROLA.
                    */ authenticationSigning: HierarchicalDeterministicFactorInstance?)
    {
        self.transactionSigning = transactionSigning
        self.authenticationSigning = authenticationSigning
    }
}

extension UnsecuredEntityControl: Sendable {}
extension UnsecuredEntityControl: Equatable, Hashable {
    public static func == (lhs: UnsecuredEntityControl, rhs: UnsecuredEntityControl) -> Bool {
        if lhs.transactionSigning != rhs.transactionSigning {
            return false
        }
        if lhs.authenticationSigning != rhs.authenticationSigning {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionSigning)
        hasher.combine(authenticationSigning)
    }
}

public struct FfiConverterTypeUnsecuredEntityControl: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsecuredEntityControl {
        return
            try UnsecuredEntityControl(
                transactionSigning: FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf),
                authenticationSigning: FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
            )
    }

    public static func write(_ value: UnsecuredEntityControl, into buf: inout [UInt8]) {
        FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value.transactionSigning, into: &buf)
        FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.write(value.authenticationSigning, into: &buf)
    }
}

public func FfiConverterTypeUnsecuredEntityControl_lift(_ buf: RustBuffer) throws -> UnsecuredEntityControl {
    return try FfiConverterTypeUnsecuredEntityControl.lift(buf)
}

public func FfiConverterTypeUnsecuredEntityControl_lower(_ value: UnsecuredEntityControl) -> RustBuffer {
    return FfiConverterTypeUnsecuredEntityControl.lower(value)
}

/**
 * The data associated with the various validator claim NFTs
 */
public struct UnstakeData {
    public var name: String
    /**
     * An epoch number at (or after) which the pending unstaked XRD may be claimed.
     */
    public var claimEpoch: Epoch
    /**
     * An XRD amount to be claimed.
     */
    public var claimAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String,
                /**
                    * An epoch number at (or after) which the pending unstaked XRD may be claimed.
                    */ claimEpoch: Epoch,
                /**
                    * An XRD amount to be claimed.
                    */ claimAmount: Decimal192)
    {
        self.name = name
        self.claimEpoch = claimEpoch
        self.claimAmount = claimAmount
    }
}

extension UnstakeData: Sendable {}
extension UnstakeData: Equatable, Hashable {
    public static func == (lhs: UnstakeData, rhs: UnstakeData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.claimEpoch != rhs.claimEpoch {
            return false
        }
        if lhs.claimAmount != rhs.claimAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(claimEpoch)
        hasher.combine(claimAmount)
    }
}

public struct FfiConverterTypeUnstakeData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstakeData {
        return
            try UnstakeData(
                name: FfiConverterString.read(from: &buf),
                claimEpoch: FfiConverterTypeEpoch.read(from: &buf),
                claimAmount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: UnstakeData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeEpoch.write(value.claimEpoch, into: &buf)
        FfiConverterTypeDecimal192.write(value.claimAmount, into: &buf)
    }
}

public func FfiConverterTypeUnstakeData_lift(_ buf: RustBuffer) throws -> UnstakeData {
    return try FfiConverterTypeUnstakeData.lift(buf)
}

public func FfiConverterTypeUnstakeData_lower(_ value: UnstakeData) -> RustBuffer {
    return FfiConverterTypeUnstakeData.lower(value)
}

/**
 * Address to a Validator that secures the network by validating transactions, users can stake to these
 * validators (Delegated Proof of Stake) by using the Dashboard and sending a TX to the Radix Wallet to sign;
 * e.g.:
 * `"validator_rdx1sd5368vqdmjk0y2w7ymdts02cz9c52858gpyny56xdvzuheepdeyy0"`
 *
 * A `ValidatorAddress` has the [Scrypto's `EntityType`][entt] `GlobalValidator`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalValidatorAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L249-L250
 */
public struct ValidatorAddress {
    fileprivate let secretMagic: RetValidatorAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetValidatorAddress) {
        self.secretMagic = secretMagic
    }
}

extension ValidatorAddress: Sendable {}
extension ValidatorAddress: Equatable, Hashable {
    public static func == (lhs: ValidatorAddress, rhs: ValidatorAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeValidatorAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorAddress {
        return
            try ValidatorAddress(
                secretMagic: FfiConverterTypeRetValidatorAddress.read(from: &buf)
            )
    }

    public static func write(_ value: ValidatorAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetValidatorAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeValidatorAddress_lift(_ buf: RustBuffer) throws -> ValidatorAddress {
    return try FfiConverterTypeValidatorAddress.lift(buf)
}

public func FfiConverterTypeValidatorAddress_lower(_ value: ValidatorAddress) -> RustBuffer {
    return FfiConverterTypeValidatorAddress.lower(value)
}

/**
 * Addresses to a specific vault, owned by a user, holding asset of one kind, either fungible or non-fungible.
 * Identities cannot own assets so they do not have vaults, but Accounts do, e.g.:
 * `"internal_vault_rdx1tz474x29nxxd4k2p2reete9xyz4apawv63dphxkr00qt23vyju49fq"`
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of VaultAddresses:
 * * InternalFungibleVault
 * * InternalNonFungibleVault
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalVaultAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L251-L255
 */
public struct VaultAddress {
    fileprivate let secretMagic: RetVaultAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetVaultAddress) {
        self.secretMagic = secretMagic
    }
}

extension VaultAddress: Sendable {}
extension VaultAddress: Equatable, Hashable {
    public static func == (lhs: VaultAddress, rhs: VaultAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeVaultAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VaultAddress {
        return
            try VaultAddress(
                secretMagic: FfiConverterTypeRetVaultAddress.read(from: &buf)
            )
    }

    public static func write(_ value: VaultAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetVaultAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeVaultAddress_lift(_ buf: RustBuffer) throws -> VaultAddress {
    return try FfiConverterTypeVaultAddress.lift(buf)
}

public func FfiConverterTypeVaultAddress_lower(_ value: VaultAddress) -> RustBuffer {
    return FfiConverterTypeVaultAddress.lower(value)
}

public struct WalletInteractionWalletAccount {
    public var address: AccountAddress
    public var label: String
    public var appearanceId: AppearanceId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: AccountAddress, label: String, appearanceId: AppearanceId) {
        self.address = address
        self.label = label
        self.appearanceId = appearanceId
    }
}

extension WalletInteractionWalletAccount: Sendable {}
extension WalletInteractionWalletAccount: Equatable, Hashable {
    public static func == (lhs: WalletInteractionWalletAccount, rhs: WalletInteractionWalletAccount) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(label)
        hasher.combine(appearanceId)
    }
}

public struct FfiConverterTypeWalletInteractionWalletAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionWalletAccount {
        return
            try WalletInteractionWalletAccount(
                address: FfiConverterTypeAccountAddress.read(from: &buf),
                label: FfiConverterString.read(from: &buf),
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf)
            )
    }

    public static func write(_ value: WalletInteractionWalletAccount, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
    }
}

public func FfiConverterTypeWalletInteractionWalletAccount_lift(_ buf: RustBuffer) throws -> WalletInteractionWalletAccount {
    return try FfiConverterTypeWalletInteractionWalletAccount.lift(buf)
}

public func FfiConverterTypeWalletInteractionWalletAccount_lower(_ value: WalletInteractionWalletAccount) -> RustBuffer {
    return FfiConverterTypeWalletInteractionWalletAccount.lower(value)
}

public struct WalletToDappInteractionAccountProof {
    public var accountAddress: AccountAddress
    public var proof: WalletToDappInteractionAuthProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accountAddress: AccountAddress, proof: WalletToDappInteractionAuthProof) {
        self.accountAddress = accountAddress
        self.proof = proof
    }
}

extension WalletToDappInteractionAccountProof: Sendable {}
extension WalletToDappInteractionAccountProof: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAccountProof, rhs: WalletToDappInteractionAccountProof) -> Bool {
        if lhs.accountAddress != rhs.accountAddress {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountAddress)
        hasher.combine(proof)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAccountProof {
        return
            try WalletToDappInteractionAccountProof(
                accountAddress: FfiConverterTypeAccountAddress.read(from: &buf),
                proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAccountProof, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.accountAddress, into: &buf)
        FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAccountProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAccountProof {
    return try FfiConverterTypeWalletToDappInteractionAccountProof.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAccountProof_lower(_ value: WalletToDappInteractionAccountProof) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAccountProof.lower(value)
}

public struct WalletToDappInteractionAccountsRequestResponseItem {
    public var accounts: [WalletInteractionWalletAccount]
    public var challenge: Exactly32Bytes?
    public var proofs: [WalletToDappInteractionAccountProof]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accounts: [WalletInteractionWalletAccount], challenge: Exactly32Bytes?, proofs: [WalletToDappInteractionAccountProof]?) {
        self.accounts = accounts
        self.challenge = challenge
        self.proofs = proofs
    }
}

extension WalletToDappInteractionAccountsRequestResponseItem: Sendable {}
extension WalletToDappInteractionAccountsRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAccountsRequestResponseItem, rhs: WalletToDappInteractionAccountsRequestResponseItem) -> Bool {
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.proofs != rhs.proofs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accounts)
        hasher.combine(challenge)
        hasher.combine(proofs)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAccountsRequestResponseItem {
        return
            try WalletToDappInteractionAccountsRequestResponseItem(
                accounts: FfiConverterSequenceTypeWalletInteractionWalletAccount.read(from: &buf),
                challenge: FfiConverterOptionTypeExactly32Bytes.read(from: &buf),
                proofs: FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAccountsRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeWalletInteractionWalletAccount.write(value.accounts, into: &buf)
        FfiConverterOptionTypeExactly32Bytes.write(value.challenge, into: &buf)
        FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof.write(value.proofs, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAccountsRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem_lower(_ value: WalletToDappInteractionAccountsRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
    public var persona: DappWalletInteractionPersona
    public var challenge: Exactly32Bytes
    public var proof: WalletToDappInteractionAuthProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(persona: DappWalletInteractionPersona, challenge: Exactly32Bytes, proof: WalletToDappInteractionAuthProof) {
        self.persona = persona
        self.challenge = challenge
        self.proof = proof
    }
}

extension WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: Sendable {}
extension WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem, rhs: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem) -> Bool {
        if lhs.persona != rhs.persona {
            return false
        }
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(persona)
        hasher.combine(challenge)
        hasher.combine(proof)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
        return
            try WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem(
                persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf),
                challenge: FfiConverterTypeExactly32Bytes.read(from: &buf),
                proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
        FfiConverterTypeExactly32Bytes.write(value.challenge, into: &buf)
        FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem_lower(_ value: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
    public var persona: DappWalletInteractionPersona

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(persona: DappWalletInteractionPersona) {
        self.persona = persona
    }
}

extension WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: Sendable {}
extension WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem, rhs: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem) -> Bool {
        if lhs.persona != rhs.persona {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(persona)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
        return
            try WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem(
                persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem_lower(_ value: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionAuthProof {
    public var publicKey: PublicKey
    public var curve: Slip10Curve
    public var signature: Signature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: PublicKey, curve: Slip10Curve, signature: Signature) {
        self.publicKey = publicKey
        self.curve = curve
        self.signature = signature
    }
}

extension WalletToDappInteractionAuthProof: Sendable {}
extension WalletToDappInteractionAuthProof: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthProof, rhs: WalletToDappInteractionAuthProof) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.curve != rhs.curve {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(curve)
        hasher.combine(signature)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthProof {
        return
            try WalletToDappInteractionAuthProof(
                publicKey: FfiConverterTypePublicKey.read(from: &buf),
                curve: FfiConverterTypeSLIP10Curve.read(from: &buf),
                signature: FfiConverterTypeSignature.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthProof, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterTypeSLIP10Curve.write(value.curve, into: &buf)
        FfiConverterTypeSignature.write(value.signature, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthProof {
    return try FfiConverterTypeWalletToDappInteractionAuthProof.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthProof_lower(_ value: WalletToDappInteractionAuthProof) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthProof.lower(value)
}

public struct WalletToDappInteractionAuthUsePersonaRequestResponseItem {
    public var persona: DappWalletInteractionPersona

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(persona: DappWalletInteractionPersona) {
        self.persona = persona
    }
}

extension WalletToDappInteractionAuthUsePersonaRequestResponseItem: Sendable {}
extension WalletToDappInteractionAuthUsePersonaRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthUsePersonaRequestResponseItem, rhs: WalletToDappInteractionAuthUsePersonaRequestResponseItem) -> Bool {
        if lhs.persona != rhs.persona {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(persona)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthUsePersonaRequestResponseItem {
        return
            try WalletToDappInteractionAuthUsePersonaRequestResponseItem(
                persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthUsePersonaRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthUsePersonaRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem_lower(_ value: WalletToDappInteractionAuthUsePersonaRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionAuthorizedRequestResponseItems {
    public var auth: WalletToDappInteractionAuthRequestResponseItem
    public var ongoingAccounts: WalletToDappInteractionAccountsRequestResponseItem?
    public var ongoingPersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?
    public var oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?
    public var oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(auth: WalletToDappInteractionAuthRequestResponseItem, ongoingAccounts: WalletToDappInteractionAccountsRequestResponseItem?, ongoingPersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?, oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?, oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?) {
        self.auth = auth
        self.ongoingAccounts = ongoingAccounts
        self.ongoingPersonaData = ongoingPersonaData
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
    }
}

extension WalletToDappInteractionAuthorizedRequestResponseItems: Sendable {}
extension WalletToDappInteractionAuthorizedRequestResponseItems: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthorizedRequestResponseItems, rhs: WalletToDappInteractionAuthorizedRequestResponseItems) -> Bool {
        if lhs.auth != rhs.auth {
            return false
        }
        if lhs.ongoingAccounts != rhs.ongoingAccounts {
            return false
        }
        if lhs.ongoingPersonaData != rhs.ongoingPersonaData {
            return false
        }
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(auth)
        hasher.combine(ongoingAccounts)
        hasher.combine(ongoingPersonaData)
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthorizedRequestResponseItems {
        return
            try WalletToDappInteractionAuthorizedRequestResponseItems(
                auth: FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.read(from: &buf),
                ongoingAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf),
                ongoingPersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf),
                oneTimeAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf),
                oneTimePersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthorizedRequestResponseItems, into buf: inout [UInt8]) {
        FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.write(value.auth, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.ongoingAccounts, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.ongoingPersonaData, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.oneTimePersonaData, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthorizedRequestResponseItems {
    return try FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems_lower(_ value: WalletToDappInteractionAuthorizedRequestResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.lower(value)
}

public struct WalletToDappInteractionFailureResponse {
    public var interactionId: WalletInteractionId
    public var error: DappWalletInteractionErrorType
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, error: DappWalletInteractionErrorType, message: String?) {
        self.interactionId = interactionId
        self.error = error
        self.message = message
    }
}

extension WalletToDappInteractionFailureResponse: Sendable {}
extension WalletToDappInteractionFailureResponse: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionFailureResponse, rhs: WalletToDappInteractionFailureResponse) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(error)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeWalletToDappInteractionFailureResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionFailureResponse {
        return
            try WalletToDappInteractionFailureResponse(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                error: FfiConverterTypeDappWalletInteractionErrorType.read(from: &buf),
                message: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionFailureResponse, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeDappWalletInteractionErrorType.write(value.error, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionFailureResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionFailureResponse {
    return try FfiConverterTypeWalletToDappInteractionFailureResponse.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionFailureResponse_lower(_ value: WalletToDappInteractionFailureResponse) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionFailureResponse.lower(value)
}

public struct WalletToDappInteractionPersonaDataRequestResponseItem {
    public var name: PersonaDataEntryName?
    public var emailAddresses: [PersonaDataEntryEmailAddress]?
    public var phoneNumbers: [PersonaDataEntryPhoneNumber]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: PersonaDataEntryName?, emailAddresses: [PersonaDataEntryEmailAddress]?, phoneNumbers: [PersonaDataEntryPhoneNumber]?) {
        self.name = name
        self.emailAddresses = emailAddresses
        self.phoneNumbers = phoneNumbers
    }
}

extension WalletToDappInteractionPersonaDataRequestResponseItem: Sendable {}
extension WalletToDappInteractionPersonaDataRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionPersonaDataRequestResponseItem, rhs: WalletToDappInteractionPersonaDataRequestResponseItem) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(emailAddresses)
        hasher.combine(phoneNumbers)
    }
}

public struct FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionPersonaDataRequestResponseItem {
        return
            try WalletToDappInteractionPersonaDataRequestResponseItem(
                name: FfiConverterOptionTypePersonaDataEntryName.read(from: &buf),
                emailAddresses: FfiConverterOptionSequenceTypePersonaDataEntryEmailAddress.read(from: &buf),
                phoneNumbers: FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionPersonaDataRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataEntryName.write(value.name, into: &buf)
        FfiConverterOptionSequenceTypePersonaDataEntryEmailAddress.write(value.emailAddresses, into: &buf)
        FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber.write(value.phoneNumbers, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionPersonaDataRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem_lower(_ value: WalletToDappInteractionPersonaDataRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionSendTransactionResponseItem {
    public var bech32EncodedTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bech32EncodedTxId: String) {
        self.bech32EncodedTxId = bech32EncodedTxId
    }
}

extension WalletToDappInteractionSendTransactionResponseItem: Sendable {}
extension WalletToDappInteractionSendTransactionResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionSendTransactionResponseItem, rhs: WalletToDappInteractionSendTransactionResponseItem) -> Bool {
        if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bech32EncodedTxId)
    }
}

public struct FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSendTransactionResponseItem {
        return
            try WalletToDappInteractionSendTransactionResponseItem(
                bech32EncodedTxId: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionSendTransactionResponseItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSendTransactionResponseItem {
    return try FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem_lower(_ value: WalletToDappInteractionSendTransactionResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.lower(value)
}

public struct WalletToDappInteractionSuccessResponse {
    public var interactionId: WalletInteractionId
    public var items: WalletToDappInteractionResponseItems

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, items: WalletToDappInteractionResponseItems) {
        self.interactionId = interactionId
        self.items = items
    }
}

extension WalletToDappInteractionSuccessResponse: Sendable {}
extension WalletToDappInteractionSuccessResponse: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionSuccessResponse, rhs: WalletToDappInteractionSuccessResponse) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(items)
    }
}

public struct FfiConverterTypeWalletToDappInteractionSuccessResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSuccessResponse {
        return
            try WalletToDappInteractionSuccessResponse(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                items: FfiConverterTypeWalletToDappInteractionResponseItems.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionSuccessResponse, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeWalletToDappInteractionResponseItems.write(value.items, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionSuccessResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSuccessResponse {
    return try FfiConverterTypeWalletToDappInteractionSuccessResponse.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionSuccessResponse_lower(_ value: WalletToDappInteractionSuccessResponse) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionSuccessResponse.lower(value)
}

public struct WalletToDappInteractionTransactionResponseItems {
    public var send: WalletToDappInteractionSendTransactionResponseItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(send: WalletToDappInteractionSendTransactionResponseItem) {
        self.send = send
    }
}

extension WalletToDappInteractionTransactionResponseItems: Sendable {}
extension WalletToDappInteractionTransactionResponseItems: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionTransactionResponseItems, rhs: WalletToDappInteractionTransactionResponseItems) -> Bool {
        if lhs.send != rhs.send {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(send)
    }
}

public struct FfiConverterTypeWalletToDappInteractionTransactionResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionTransactionResponseItems {
        return
            try WalletToDappInteractionTransactionResponseItems(
                send: FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionTransactionResponseItems, into buf: inout [UInt8]) {
        FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.write(value.send, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionTransactionResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionTransactionResponseItems {
    return try FfiConverterTypeWalletToDappInteractionTransactionResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionTransactionResponseItems_lower(_ value: WalletToDappInteractionTransactionResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionTransactionResponseItems.lower(value)
}

public struct WalletToDappInteractionUnauthorizedRequestResponseItems {
    public var oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?
    public var oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?, oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?) {
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
    }
}

extension WalletToDappInteractionUnauthorizedRequestResponseItems: Sendable {}
extension WalletToDappInteractionUnauthorizedRequestResponseItems: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionUnauthorizedRequestResponseItems, rhs: WalletToDappInteractionUnauthorizedRequestResponseItems) -> Bool {
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
    }
}

public struct FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionUnauthorizedRequestResponseItems {
        return
            try WalletToDappInteractionUnauthorizedRequestResponseItems(
                oneTimeAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf),
                oneTimePersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionUnauthorizedRequestResponseItems, into buf: inout [UInt8]) {
        FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.oneTimePersonaData, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionUnauthorizedRequestResponseItems {
    return try FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems_lower(_ value: WalletToDappInteractionUnauthorizedRequestResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AccountOrAddressOf {
    case profileAccount(value: Account
    )
    case addressOfExternalAccount(value: AccountAddress
    )
}

public struct FfiConverterTypeAccountOrAddressOf: FfiConverterRustBuffer {
    typealias SwiftType = AccountOrAddressOf

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountOrAddressOf {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .profileAccount(value: FfiConverterTypeAccount.read(from: &buf)
            )

        case 2: return try .addressOfExternalAccount(value: FfiConverterTypeAccountAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountOrAddressOf, into buf: inout [UInt8]) {
        switch value {
        case let .profileAccount(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccount.write(value, into: &buf)

        case let .addressOfExternalAccount(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountAddress.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeAccountOrAddressOf_lift(_ buf: RustBuffer) throws -> AccountOrAddressOf {
    return try FfiConverterTypeAccountOrAddressOf.lift(buf)
}

public func FfiConverterTypeAccountOrAddressOf_lower(_ value: AccountOrAddressOf) -> RustBuffer {
    return FfiConverterTypeAccountOrAddressOf.lower(value)
}

extension AccountOrAddressOf: Sendable {}
extension AccountOrAddressOf: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either an `Account` or a `Persona`.
 */

public enum AccountOrPersona {
    /**
     * An `Account`
     *
     * Note:
     * This case/variant can not be named `account`/ `Account` due
     * to Kotlin UniFFI limitation.
     */
    case accountEntity(Account
    )
    /**
     * A `Persona`
     *
     * Note:
     * This is named `personaEntity` / `PersonaEntity` to match
     * `accountEntity` / `AccountEntity` which can not be named
     * `account`/ `Account` due to Kotlin UniFFI limitation.
     */
    case personaEntity(Persona
    )
}

public struct FfiConverterTypeAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = AccountOrPersona

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountOrPersona {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .accountEntity(FfiConverterTypeAccount.read(from: &buf)
            )

        case 2: return try .personaEntity(FfiConverterTypePersona.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountOrPersona, into buf: inout [UInt8]) {
        switch value {
        case let .accountEntity(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccount.write(v1, into: &buf)

        case let .personaEntity(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypePersona.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeAccountOrPersona_lift(_ buf: RustBuffer) throws -> AccountOrPersona {
    return try FfiConverterTypeAccountOrPersona.lift(buf)
}

public func FfiConverterTypeAccountOrPersona_lower(_ value: AccountOrPersona) -> RustBuffer {
    return FfiConverterTypeAccountOrPersona.lower(value)
}

extension AccountOrPersona: Sendable {}
extension AccountOrPersona: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of addresses.
 *
 * Does not include `LegacyOlympiaAccountAddress` nor `NonFungibleResourceAddress`
 */

public enum Address {
    case accessController(AccessControllerAddress
    )
    case account(AccountAddress
    )
    case component(ComponentAddress
    )
    case identity(IdentityAddress
    )
    case package(PackageAddress
    )
    case pool(PoolAddress
    )
    case resource(ResourceAddress
    )
    case validator(ValidatorAddress
    )
    case vault(VaultAddress
    )
}

public struct FfiConverterTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = Address

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .accessController(FfiConverterTypeAccessControllerAddress.read(from: &buf)
            )

        case 2: return try .account(FfiConverterTypeAccountAddress.read(from: &buf)
            )

        case 3: return try .component(FfiConverterTypeComponentAddress.read(from: &buf)
            )

        case 4: return try .identity(FfiConverterTypeIdentityAddress.read(from: &buf)
            )

        case 5: return try .package(FfiConverterTypePackageAddress.read(from: &buf)
            )

        case 6: return try .pool(FfiConverterTypePoolAddress.read(from: &buf)
            )

        case 7: return try .resource(FfiConverterTypeResourceAddress.read(from: &buf)
            )

        case 8: return try .validator(FfiConverterTypeValidatorAddress.read(from: &buf)
            )

        case 9: return try .vault(FfiConverterTypeVaultAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        switch value {
        case let .accessController(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccessControllerAddress.write(v1, into: &buf)

        case let .account(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountAddress.write(v1, into: &buf)

        case let .component(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeComponentAddress.write(v1, into: &buf)

        case let .identity(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeIdentityAddress.write(v1, into: &buf)

        case let .package(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypePackageAddress.write(v1, into: &buf)

        case let .pool(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypePoolAddress.write(v1, into: &buf)

        case let .resource(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeResourceAddress.write(v1, into: &buf)

        case let .validator(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeValidatorAddress.write(v1, into: &buf)

        case let .vault(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeVaultAddress.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeAddress_lift(_ buf: RustBuffer) throws -> Address {
    return try FfiConverterTypeAddress.lift(buf)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> RustBuffer {
    return FfiConverterTypeAddress.lower(value)
}

extension Address: Sendable {}
extension Address: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AddressFormat {
    case full
    case raw
    case `default`
    case middle
}

public struct FfiConverterTypeAddressFormat: FfiConverterRustBuffer {
    typealias SwiftType = AddressFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .full

        case 2: return .raw

        case 3: return .default

        case 4: return .middle

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressFormat, into buf: inout [UInt8]) {
        switch value {
        case .full:
            writeInt(&buf, Int32(1))

        case .raw:
            writeInt(&buf, Int32(2))

        case .default:
            writeInt(&buf, Int32(3))

        case .middle:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeAddressFormat_lift(_ buf: RustBuffer) throws -> AddressFormat {
    return try FfiConverterTypeAddressFormat.lift(buf)
}

public func FfiConverterTypeAddressFormat_lower(_ value: AddressFormat) -> RustBuffer {
    return FfiConverterTypeAddressFormat.lower(value)
}

extension AddressFormat: Sendable {}
extension AddressFormat: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of addresses of either an Account or a Persona (IdentityAddress)
 */

public enum AddressOfAccountOrPersona {
    case account(AccountAddress
    )
    case identity(IdentityAddress
    )
}

public struct FfiConverterTypeAddressOfAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = AddressOfAccountOrPersona

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressOfAccountOrPersona {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .account(FfiConverterTypeAccountAddress.read(from: &buf)
            )

        case 2: return try .identity(FfiConverterTypeIdentityAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressOfAccountOrPersona, into buf: inout [UInt8]) {
        switch value {
        case let .account(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountAddress.write(v1, into: &buf)

        case let .identity(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeIdentityAddress.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeAddressOfAccountOrPersona_lift(_ buf: RustBuffer) throws -> AddressOfAccountOrPersona {
    return try FfiConverterTypeAddressOfAccountOrPersona.lift(buf)
}

public func FfiConverterTypeAddressOfAccountOrPersona_lower(_ value: AddressOfAccountOrPersona) -> RustBuffer {
    return FfiConverterTypeAddressOfAccountOrPersona.lower(value)
}

extension AddressOfAccountOrPersona: Sendable {}
extension AddressOfAccountOrPersona: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * BIP39 entropy, ranging from 16-32 bytes with discrete values being multiples of in between the range.
 */

public enum Bip39Entropy {
    case entropyOf16Bytes(Entropy16Bytes
    )
    case entropyOf20Bytes(Entropy20Bytes
    )
    case entropyOf24Bytes(Entropy24Bytes
    )
    case entropyOf28Bytes(Entropy28Bytes
    )
    case entropyOf32Bytes(Entropy32Bytes
    )
}

public struct FfiConverterTypeBIP39Entropy: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Entropy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Entropy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .entropyOf16Bytes(FfiConverterTypeEntropy16Bytes.read(from: &buf)
            )

        case 2: return try .entropyOf20Bytes(FfiConverterTypeEntropy20Bytes.read(from: &buf)
            )

        case 3: return try .entropyOf24Bytes(FfiConverterTypeEntropy24Bytes.read(from: &buf)
            )

        case 4: return try .entropyOf28Bytes(FfiConverterTypeEntropy28Bytes.read(from: &buf)
            )

        case 5: return try .entropyOf32Bytes(FfiConverterTypeEntropy32Bytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Entropy, into buf: inout [UInt8]) {
        switch value {
        case let .entropyOf16Bytes(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEntropy16Bytes.write(v1, into: &buf)

        case let .entropyOf20Bytes(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEntropy20Bytes.write(v1, into: &buf)

        case let .entropyOf24Bytes(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEntropy24Bytes.write(v1, into: &buf)

        case let .entropyOf28Bytes(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeEntropy28Bytes.write(v1, into: &buf)

        case let .entropyOf32Bytes(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEntropy32Bytes.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeBIP39Entropy_lift(_ buf: RustBuffer) throws -> Bip39Entropy {
    return try FfiConverterTypeBIP39Entropy.lift(buf)
}

public func FfiConverterTypeBIP39Entropy_lower(_ value: Bip39Entropy) -> RustBuffer {
    return FfiConverterTypeBIP39Entropy.lower(value)
}

extension Bip39Entropy: Sendable {}
extension Bip39Entropy: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Language to be used for the mnemonic phrase.
 *
 * The English language is always available, other languages are enabled using
 * the compilation features.
 */

public enum Bip39Language {
    /**
     * The English language.
     */
    case english
    /**
     * The French language.
     */
    case french
}

public struct FfiConverterTypeBIP39Language: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Language

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Language {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .english

        case 2: return .french

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Language, into buf: inout [UInt8]) {
        switch value {
        case .english:
            writeInt(&buf, Int32(1))

        case .french:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeBIP39Language_lift(_ buf: RustBuffer) throws -> Bip39Language {
    return try FfiConverterTypeBIP39Language.lift(buf)
}

public func FfiConverterTypeBIP39Language_lower(_ value: Bip39Language) -> RustBuffer {
    return FfiConverterTypeBIP39Language.lower(value)
}

extension Bip39Language: Sendable {}
extension Bip39Language: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
 * standard, a multiple of 3, from 12 to 24 words. All "Babylon" `DeviceFactorSource`s
 * use 24 words.
 */

public enum Bip39WordCount: UInt8 {
    /**
     * 24 words, used by all "Babylon" `DeviceFactorSource`s
     */
    case twentyFour = 24
    /**
     * 21 words, potentially used by third-party Olympia wallets.
     */
    case twentyOne = 21
    /**
     * 18 words, potentially used by third-party Olympia wallets.
     */
    case eighteen = 18
    /**
     * 15 words, potentially used by third-party Olympia wallets.
     */
    case fifteen = 15
    /**
     * 12 words, used by Radix Olympia legacy wallet.
     */
    case twelve = 12
}

public struct FfiConverterTypeBIP39WordCount: FfiConverterRustBuffer {
    typealias SwiftType = Bip39WordCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39WordCount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .twentyFour

        case 2: return .twentyOne

        case 3: return .eighteen

        case 4: return .fifteen

        case 5: return .twelve

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39WordCount, into buf: inout [UInt8]) {
        switch value {
        case .twentyFour:
            writeInt(&buf, Int32(1))

        case .twentyOne:
            writeInt(&buf, Int32(2))

        case .eighteen:
            writeInt(&buf, Int32(3))

        case .fifteen:
            writeInt(&buf, Int32(4))

        case .twelve:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeBIP39WordCount_lift(_ buf: RustBuffer) throws -> Bip39WordCount {
    return try FfiConverterTypeBIP39WordCount.lift(buf)
}

public func FfiConverterTypeBIP39WordCount_lower(_ value: Bip39WordCount) -> RustBuffer {
    return FfiConverterTypeBIP39WordCount.lower(value)
}

extension Bip39WordCount: Sendable {}
extension Bip39WordCount: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Account or Identity (used by Personas) part of a CAP26 derivation
 * path.
 */

public enum Cap26EntityKind: UInt32 {
    /**
     * An Account entity type
     */
    case account = 525
    /**
     * An Identity entity type (used by Personas)
     */
    case identity = 618
}

public struct FfiConverterTypeCAP26EntityKind: FfiConverterRustBuffer {
    typealias SwiftType = Cap26EntityKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26EntityKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .account

        case 2: return .identity

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26EntityKind, into buf: inout [UInt8]) {
        switch value {
        case .account:
            writeInt(&buf, Int32(1))

        case .identity:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeCAP26EntityKind_lift(_ buf: RustBuffer) throws -> Cap26EntityKind {
    return try FfiConverterTypeCAP26EntityKind.lift(buf)
}

public func FfiConverterTypeCAP26EntityKind_lower(_ value: Cap26EntityKind) -> RustBuffer {
    return FfiConverterTypeCAP26EntityKind.lower(value)
}

extension Cap26EntityKind: Sendable {}
extension Cap26EntityKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Cap26KeyKind: UInt32 {
    /**
     * For a key to be used for signing transactions.
     * The value is the ascii sum of `"TRANSACTION_SIGNING"`
     */
    case transactionSigning = 1460
    /**
     * For a key to be used for signing authentication..
     * The value is the ascii sum of `"AUTHENTICATION_SIGNING"`
     */
    case authenticationSigning = 1678
    /**
     * For a key to be used for encrypting messages.
     * The value is the ascii sum of `"MESSAGE_ENCRYPTION"`
     */
    case messageEncryption = 1391
}

public struct FfiConverterTypeCAP26KeyKind: FfiConverterRustBuffer {
    typealias SwiftType = Cap26KeyKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26KeyKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .transactionSigning

        case 2: return .authenticationSigning

        case 3: return .messageEncryption

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26KeyKind, into buf: inout [UInt8]) {
        switch value {
        case .transactionSigning:
            writeInt(&buf, Int32(1))

        case .authenticationSigning:
            writeInt(&buf, Int32(2))

        case .messageEncryption:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeCAP26KeyKind_lift(_ buf: RustBuffer) throws -> Cap26KeyKind {
    return try FfiConverterTypeCAP26KeyKind.lift(buf)
}

public func FfiConverterTypeCAP26KeyKind_lower(_ value: Cap26KeyKind) -> RustBuffer {
    return FfiConverterTypeCAP26KeyKind.lower(value)
}

extension Cap26KeyKind: Sendable {}
extension Cap26KeyKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A derivation path design specifically for Radix Babylon wallets used by Accounts and Personas
 * to be unique per network with separate key spaces for Accounts/Identities (Personas) and key
 * kind: sign transaction or sign auth.
 */

public enum Cap26Path {
    case getId(value: GetIdPath
    )
    case account(value: AccountPath
    )
    case identity(value: IdentityPath
    )
}

public struct FfiConverterTypeCAP26Path: FfiConverterRustBuffer {
    typealias SwiftType = Cap26Path

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26Path {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .getId(value: FfiConverterTypeGetIDPath.read(from: &buf)
            )

        case 2: return try .account(value: FfiConverterTypeAccountPath.read(from: &buf)
            )

        case 3: return try .identity(value: FfiConverterTypeIdentityPath.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26Path, into buf: inout [UInt8]) {
        switch value {
        case let .getId(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeGetIDPath.write(value, into: &buf)

        case let .account(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountPath.write(value, into: &buf)

        case let .identity(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeIdentityPath.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeCAP26Path_lift(_ buf: RustBuffer) throws -> Cap26Path {
    return try FfiConverterTypeCAP26Path.lift(buf)
}

public func FfiConverterTypeCAP26Path_lower(_ value: Cap26Path) -> RustBuffer {
    return FfiConverterTypeCAP26Path.lower(value)
}

extension Cap26Path: Sendable {}
extension Cap26Path: Equatable, Hashable {}

public enum CommonError {
    case Unknown
    case InvalidEd25519PrivateKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidEd25519PrivateKeyFromString(badValue: String
    )
    case InvalidSecp256k1PrivateKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidSecp256k1PrivateKeyFromString(badValue: String
    )
    case InvalidEd25519PublicKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidEd25519PublicKeyFromString(badValue: String
    )
    case InvalidSecp256k1PublicKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidSecp256k1PublicKeyFromString(badValue: String
    )
    case InvalidSecp256k1PublicKeyPointNotOnCurve
    case InvalidEd25519PublicKeyPointNotOnCurve
    case StringNotHex(badValue: String
    )
    case InvalidByteCount(expected: UInt64, found: UInt64)
    case InvalidBip32Path(badValue: String
    )
    case InvalidDepthOfBip44Path(expected: UInt64, found: UInt64)
    case InvalidBip44LikePathAccountWasNotHardened
    case InvalidBip44LikePathChangeWasUnexpectedlyHardened
    case InvalidDepthOfCap26Path(expected: UInt64, found: UInt64)
    case NotAllComponentsAreHardened
    case Bip44PurposeNotFound(badValue: UInt32
    )
    case CoinTypeNotFound(badValue: UInt32
    )
    case InvalidNetworkIdExceedsLimit(badValue: UInt32
    )
    case InvalidEntityKind(badValue: UInt32
    )
    case WrongEntityKind(expected: Cap26EntityKind, found: Cap26EntityKind)
    case InvalidKeyKind(badValue: UInt32
    )
    case UnsupportedNetworkId(badValue: UInt8
    )
    case InvalidGetIdPath(badValue: UInt32
    )
    case UnknownBip39Word
    case InvalidMnemonicPhrase
    case InvalidBip39WordCount(badValue: UInt64
    )
    case InvalidAppearanceId(badValue: UInt8
    )
    case InvalidAccountAddress(badValue: String
    )
    case UnsupportedEntityType
    case FailedToDecodeAddressFromBech32(badValue: String
    )
    case MismatchingEntityTypeWhileDecodingAddress
    case MismatchingHrpWhileDecodingAddress
    case UnknownNetworkId(badValue: UInt8
    )
    case InvalidNonFungibleGlobalId(badValue: String
    )
    case FactorSourceCryptoParametersSupportedCurvesInvalidSize
    case BadgeIsNotVirtualHierarchicalDeterministic
    case FactorSourceIdNotFromHash
    case ExpectedAccountPathButGotSomethingElse
    case WrongEntityKindOfInFactorInstancesPath
    case WrongKeyKindOfTransactionSigningFactorInstance
    case WrongKeyKindOfAuthenticationSigningFactorInstance
    case ExpectedDeviceFactorSourceGotSomethingElse
    case ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse
    case UnknownNetworkWithName(badValue: String
    )
    case UnknownNetworkForId(badValue: UInt8
    )
    case GatewaysDiscrepancyOtherShouldNotContainCurrent
    case InvalidGatewaysJsonCurrentNotFoundAmongstSaved
    case InvalidUrl(badValue: String
    )
    case AccountOnWrongNetwork(expected: NetworkId, found: NetworkId)
    case FactorSourcesMustNotBeEmpty
    case UpdateFactorSourceMutateFailed
    case CastFactorSourceWrongKind(expected: FactorSourceKind, found: FactorSourceKind)
    case InvalidLength(expected: UInt64, found: UInt64, data: BagOfBytes)
    case InvalidNonFungibleLocalIdString
    case InvalidNonFungibleLocalIdBytes
    case DecimalError
    case InvalidBip39Index(badValue: UInt16
    )
    case InvalidDisplayNameEmpty
    case InvalidDisplayNameTooLong(expected: UInt64, found: UInt64)
    case InvalidIso8601String(badValue: String
    )
    case UnknownAccount
    case SecureStorageReadError
    case UnableToLoadDeviceFactorSourceFromSecureStorage
    case SecureStorageWriteError
    case FailedToSerializeToJson
    case FailedToDeserializeJsonToValue(jsonByteCount: UInt64, typeName: String)
    case InvalidProfileId(badValue: String
    )
    case FailedToLoadProfileHeadersList
    case ProfileDoesNotContainFactorSourceWithId(badValue: FactorSourceId
    )
    case NoActiveProfileIdSet
    case ProfileSnapshotNotFound(badValue: ProfileId
    )
    case AccountAlreadyPresent(badValue: AccountAddress
    )
    case UnableToAcquireWriteLockForProfile
    case UnableToSaveMnemonicToSecureStorage(badValue: FactorSourceIdFromHash
    )
    case UnableToLoadMnemonicFromSecureStorage(badValue: FactorSourceIdFromHash
    )
    case UnableToSaveFactorSourceToProfile(badValue: FactorSourceId
    )
    case ExpectedIdentityPathButGotSomethingElse
    case PersonaDataInvalidPhoneNumberEmpty
    case PersonaDataInvalidEmailAddressEmpty
    case PersonaDataInvalidNameFamilyNameEmpty
    case PersonaDataInvalidNameGivenNamesEmpty
    case InvalidUuiDv4(badValue: String
    )
    case UnrecognizedLocaleIdentifier(badValue: String
    )
    case FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(nodeIdAsHex: String, networkId: NetworkId)
    case InvalidOlympiaAddressString(badValue: String
    )
    case InvalidInstructionsString(underlying: String
    )
    case ExecutionSummaryFail(underlying: String
    )
    case FailedToDecodeEncodedReceipt
    case BytesEmpty
    case TooManyBytes(max: UInt64, found: UInt64)
    case InvalidInstructionsWrongNetwork(foundInInstructions: NetworkId, specifiedToInstructionsCtor: NetworkId)
    case FailedToUniFfiDecodeBytesToManifestInstructions
    case FailedToDecodeTransactionHash(badValue: String
    )
    case FailedToHashIntent
    case EncryptedMessagesAreNotYetSupported
    case FailedToBech32DecodeTransactionHashAfterHavingTestedAllNetworkId(badValue: String
    )
    case FailedToParseSignatureFromString(badValue: String
    )
    case InvalidSignaturesForIntentSomeDidNotValidateIntentHash
    case FailedToDecompileBytesIntoNotarizedTransaction
    case FailedToRecoverSecp256k1PublicKeyFromSignature
    case FungibleResourceAddressNotAcceptedInNonFungibleContext
    case DecimalOverflow(badValue: String
    )
    case InvalidAddressNotOlympiaMainnet(badValue: String
    )
    case FailedToParseSignatureFromBytes(badValue: String
    )
    case InvalidIntentFailedToEncode(underlying: String
    )
    case InvalidInstructionsFailedToDecompile(underlying: String
    )
    case InvalidTransactionMaxSborDepthExceeded(max: UInt16
    )
    case InvalidSignedIntentFailedToEncode(underlying: String
    )
    case InvalidNotarizedIntentFailedToEncode(underlying: String
    )
    case NetworkResponseBadCode
    case NetworkResponseEmptyBody
    case NetworkResponseJsonDeserialize(intoType: String
    )
    case NetworkRequestInvalidUrl(badValue: String
    )
    case NetworkRequestGenericFailure(underlying: String
    )
    case GatewaySubmitDuplicateTx(intentHash: String
    )
    case SupportedCurvesMustNotBeEmpty
    case ProfileNetworksMustNotBeEmpty
    case UnknownSlip10Curve(badValue: String
    )
    case AesDecryptionFailed
    case InvalidAesBytesTooShort(expectedAtLeast: UInt64, found: UInt64)
    case InvalidFactorSourceKind(badValue: String
    )
    case InvalidLedgerHardwareWalletModel(badValue: String
    )
    case RadixConnectMobileInvalidRequestUrl(badValue: String
    )
    case RadixConnectMobileInvalidOrigin(badValue: String
    )
    case RadixConnectMobileInvalidSessionId(badValue: String
    )
    case RadixMobileInvalidInteractionId(badValue: String
    )
    case NetworkDiscrepancy(expected: NetworkId, actual: NetworkId)
    case DiscrepancyAuthorizedDappReferencedPersonaWhichDoesNotExist(address: IdentityAddress
    )
    case DiscrepancyAuthorizedDappReferencedAccountWhichDoesNotExist(address: AccountAddress
    )
    case AuthorizedDappReferencesFieldIdThatDoesNotExist
    case ElementDoesNotExist(id: String
    )
    case ElementAlreadyExist(id: String
    )
    case InvalidRadixConnectPurpose(badValue: String
    )
}

public struct FfiConverterTypeCommonError: FfiConverterRustBuffer {
    typealias SwiftType = CommonError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CommonError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .Unknown
        case 2: return try .InvalidEd25519PrivateKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 3: return try .InvalidEd25519PrivateKeyFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 4: return try .InvalidSecp256k1PrivateKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 5: return try .InvalidSecp256k1PrivateKeyFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 6: return try .InvalidEd25519PublicKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 7: return try .InvalidEd25519PublicKeyFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 8: return try .InvalidSecp256k1PublicKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 9: return try .InvalidSecp256k1PublicKeyFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 10: return .InvalidSecp256k1PublicKeyPointNotOnCurve
        case 11: return .InvalidEd25519PublicKeyPointNotOnCurve
        case 12: return try .StringNotHex(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 13: return try .InvalidByteCount(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 14: return try .InvalidBip32Path(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 15: return try .InvalidDepthOfBip44Path(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 16: return .InvalidBip44LikePathAccountWasNotHardened
        case 17: return .InvalidBip44LikePathChangeWasUnexpectedlyHardened
        case 18: return try .InvalidDepthOfCap26Path(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 19: return .NotAllComponentsAreHardened
        case 20: return try .Bip44PurposeNotFound(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 21: return try .CoinTypeNotFound(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 22: return try .InvalidNetworkIdExceedsLimit(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 23: return try .InvalidEntityKind(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 24: return try .WrongEntityKind(
                expected: FfiConverterTypeCAP26EntityKind.read(from: &buf),
                found: FfiConverterTypeCAP26EntityKind.read(from: &buf)
            )
        case 25: return try .InvalidKeyKind(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 26: return try .UnsupportedNetworkId(
                badValue: FfiConverterUInt8.read(from: &buf)
            )
        case 27: return try .InvalidGetIdPath(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 28: return .UnknownBip39Word
        case 29: return .InvalidMnemonicPhrase
        case 30: return try .InvalidBip39WordCount(
                badValue: FfiConverterUInt64.read(from: &buf)
            )
        case 31: return try .InvalidAppearanceId(
                badValue: FfiConverterUInt8.read(from: &buf)
            )
        case 32: return try .InvalidAccountAddress(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 33: return .UnsupportedEntityType
        case 34: return try .FailedToDecodeAddressFromBech32(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 35: return .MismatchingEntityTypeWhileDecodingAddress
        case 36: return .MismatchingHrpWhileDecodingAddress
        case 37: return try .UnknownNetworkId(
                badValue: FfiConverterUInt8.read(from: &buf)
            )
        case 38: return try .InvalidNonFungibleGlobalId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 39: return .FactorSourceCryptoParametersSupportedCurvesInvalidSize
        case 40: return .BadgeIsNotVirtualHierarchicalDeterministic
        case 41: return .FactorSourceIdNotFromHash
        case 42: return .ExpectedAccountPathButGotSomethingElse
        case 43: return .WrongEntityKindOfInFactorInstancesPath
        case 44: return .WrongKeyKindOfTransactionSigningFactorInstance
        case 45: return .WrongKeyKindOfAuthenticationSigningFactorInstance
        case 46: return .ExpectedDeviceFactorSourceGotSomethingElse
        case 47: return .ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse
        case 48: return try .UnknownNetworkWithName(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 49: return try .UnknownNetworkForId(
                badValue: FfiConverterUInt8.read(from: &buf)
            )
        case 50: return .GatewaysDiscrepancyOtherShouldNotContainCurrent
        case 51: return .InvalidGatewaysJsonCurrentNotFoundAmongstSaved
        case 52: return try .InvalidUrl(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 53: return try .AccountOnWrongNetwork(
                expected: FfiConverterTypeNetworkID.read(from: &buf),
                found: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 54: return .FactorSourcesMustNotBeEmpty
        case 55: return .UpdateFactorSourceMutateFailed
        case 56: return try .CastFactorSourceWrongKind(
                expected: FfiConverterTypeFactorSourceKind.read(from: &buf),
                found: FfiConverterTypeFactorSourceKind.read(from: &buf)
            )
        case 57: return try .InvalidLength(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf),
                data: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 58: return .InvalidNonFungibleLocalIdString
        case 59: return .InvalidNonFungibleLocalIdBytes
        case 60: return .DecimalError
        case 61: return try .InvalidBip39Index(
                badValue: FfiConverterUInt16.read(from: &buf)
            )
        case 62: return .InvalidDisplayNameEmpty
        case 63: return try .InvalidDisplayNameTooLong(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 64: return try .InvalidIso8601String(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 65: return .UnknownAccount
        case 66: return .SecureStorageReadError
        case 67: return .UnableToLoadDeviceFactorSourceFromSecureStorage
        case 68: return .SecureStorageWriteError
        case 69: return .FailedToSerializeToJson
        case 70: return try .FailedToDeserializeJsonToValue(
                jsonByteCount: FfiConverterUInt64.read(from: &buf),
                typeName: FfiConverterString.read(from: &buf)
            )
        case 71: return try .InvalidProfileId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 72: return .FailedToLoadProfileHeadersList
        case 73: return try .ProfileDoesNotContainFactorSourceWithId(
                badValue: FfiConverterTypeFactorSourceID.read(from: &buf)
            )
        case 74: return .NoActiveProfileIdSet
        case 75: return try .ProfileSnapshotNotFound(
                badValue: FfiConverterTypeProfileID.read(from: &buf)
            )
        case 76: return try .AccountAlreadyPresent(
                badValue: FfiConverterTypeAccountAddress.read(from: &buf)
            )
        case 77: return .UnableToAcquireWriteLockForProfile
        case 78: return try .UnableToSaveMnemonicToSecureStorage(
                badValue: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )
        case 79: return try .UnableToLoadMnemonicFromSecureStorage(
                badValue: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )
        case 80: return try .UnableToSaveFactorSourceToProfile(
                badValue: FfiConverterTypeFactorSourceID.read(from: &buf)
            )
        case 81: return .ExpectedIdentityPathButGotSomethingElse
        case 82: return .PersonaDataInvalidPhoneNumberEmpty
        case 83: return .PersonaDataInvalidEmailAddressEmpty
        case 84: return .PersonaDataInvalidNameFamilyNameEmpty
        case 85: return .PersonaDataInvalidNameGivenNamesEmpty
        case 86: return try .InvalidUuiDv4(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 87: return try .UnrecognizedLocaleIdentifier(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 88: return try .FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(
                nodeIdAsHex: FfiConverterString.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 89: return try .InvalidOlympiaAddressString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 90: return try .InvalidInstructionsString(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 91: return try .ExecutionSummaryFail(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 92: return .FailedToDecodeEncodedReceipt
        case 93: return .BytesEmpty
        case 94: return try .TooManyBytes(
                max: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 95: return try .InvalidInstructionsWrongNetwork(
                foundInInstructions: FfiConverterTypeNetworkID.read(from: &buf),
                specifiedToInstructionsCtor: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 96: return .FailedToUniFfiDecodeBytesToManifestInstructions
        case 97: return try .FailedToDecodeTransactionHash(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 98: return .FailedToHashIntent
        case 99: return .EncryptedMessagesAreNotYetSupported
        case 100: return try .FailedToBech32DecodeTransactionHashAfterHavingTestedAllNetworkId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 101: return try .FailedToParseSignatureFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 102: return .InvalidSignaturesForIntentSomeDidNotValidateIntentHash
        case 103: return .FailedToDecompileBytesIntoNotarizedTransaction
        case 104: return .FailedToRecoverSecp256k1PublicKeyFromSignature
        case 105: return .FungibleResourceAddressNotAcceptedInNonFungibleContext
        case 106: return try .DecimalOverflow(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 107: return try .InvalidAddressNotOlympiaMainnet(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 108: return try .FailedToParseSignatureFromBytes(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 109: return try .InvalidIntentFailedToEncode(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 110: return try .InvalidInstructionsFailedToDecompile(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 111: return try .InvalidTransactionMaxSborDepthExceeded(
                max: FfiConverterUInt16.read(from: &buf)
            )
        case 112: return try .InvalidSignedIntentFailedToEncode(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 113: return try .InvalidNotarizedIntentFailedToEncode(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 114: return .NetworkResponseBadCode
        case 115: return .NetworkResponseEmptyBody
        case 116: return try .NetworkResponseJsonDeserialize(
                intoType: FfiConverterString.read(from: &buf)
            )
        case 117: return try .NetworkRequestInvalidUrl(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 118: return try .NetworkRequestGenericFailure(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 119: return try .GatewaySubmitDuplicateTx(
                intentHash: FfiConverterString.read(from: &buf)
            )
        case 120: return .SupportedCurvesMustNotBeEmpty
        case 121: return .ProfileNetworksMustNotBeEmpty
        case 122: return try .UnknownSlip10Curve(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 123: return .AesDecryptionFailed
        case 124: return try .InvalidAesBytesTooShort(
                expectedAtLeast: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 125: return try .InvalidFactorSourceKind(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 126: return try .InvalidLedgerHardwareWalletModel(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 127: return try .RadixConnectMobileInvalidRequestUrl(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 128: return try .RadixConnectMobileInvalidOrigin(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 129: return try .RadixConnectMobileInvalidSessionId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 130: return try .RadixMobileInvalidInteractionId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 131: return try .NetworkDiscrepancy(
                expected: FfiConverterTypeNetworkID.read(from: &buf),
                actual: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 132: return try .DiscrepancyAuthorizedDappReferencedPersonaWhichDoesNotExist(
                address: FfiConverterTypeIdentityAddress.read(from: &buf)
            )
        case 133: return try .DiscrepancyAuthorizedDappReferencedAccountWhichDoesNotExist(
                address: FfiConverterTypeAccountAddress.read(from: &buf)
            )
        case 134: return .AuthorizedDappReferencesFieldIdThatDoesNotExist
        case 135: return try .ElementDoesNotExist(
                id: FfiConverterString.read(from: &buf)
            )
        case 136: return try .ElementAlreadyExist(
                id: FfiConverterString.read(from: &buf)
            )
        case 137: return try .InvalidRadixConnectPurpose(
                badValue: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CommonError, into buf: inout [UInt8]) {
        switch value {
        case .Unknown:
            writeInt(&buf, Int32(1))

        case let .InvalidEd25519PrivateKeyFromBytes(badValue):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidEd25519PrivateKeyFromString(badValue):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidSecp256k1PrivateKeyFromBytes(badValue):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidSecp256k1PrivateKeyFromString(badValue):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidEd25519PublicKeyFromBytes(badValue):
            writeInt(&buf, Int32(6))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidEd25519PublicKeyFromString(badValue):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidSecp256k1PublicKeyFromBytes(badValue):
            writeInt(&buf, Int32(8))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidSecp256k1PublicKeyFromString(badValue):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(badValue, into: &buf)

        case .InvalidSecp256k1PublicKeyPointNotOnCurve:
            writeInt(&buf, Int32(10))

        case .InvalidEd25519PublicKeyPointNotOnCurve:
            writeInt(&buf, Int32(11))

        case let .StringNotHex(badValue):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidByteCount(expected, found):
            writeInt(&buf, Int32(13))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case let .InvalidBip32Path(badValue):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidDepthOfBip44Path(expected, found):
            writeInt(&buf, Int32(15))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case .InvalidBip44LikePathAccountWasNotHardened:
            writeInt(&buf, Int32(16))

        case .InvalidBip44LikePathChangeWasUnexpectedlyHardened:
            writeInt(&buf, Int32(17))

        case let .InvalidDepthOfCap26Path(expected, found):
            writeInt(&buf, Int32(18))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case .NotAllComponentsAreHardened:
            writeInt(&buf, Int32(19))

        case let .Bip44PurposeNotFound(badValue):
            writeInt(&buf, Int32(20))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .CoinTypeNotFound(badValue):
            writeInt(&buf, Int32(21))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .InvalidNetworkIdExceedsLimit(badValue):
            writeInt(&buf, Int32(22))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .InvalidEntityKind(badValue):
            writeInt(&buf, Int32(23))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .WrongEntityKind(expected, found):
            writeInt(&buf, Int32(24))
            FfiConverterTypeCAP26EntityKind.write(expected, into: &buf)
            FfiConverterTypeCAP26EntityKind.write(found, into: &buf)

        case let .InvalidKeyKind(badValue):
            writeInt(&buf, Int32(25))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .UnsupportedNetworkId(badValue):
            writeInt(&buf, Int32(26))
            FfiConverterUInt8.write(badValue, into: &buf)

        case let .InvalidGetIdPath(badValue):
            writeInt(&buf, Int32(27))
            FfiConverterUInt32.write(badValue, into: &buf)

        case .UnknownBip39Word:
            writeInt(&buf, Int32(28))

        case .InvalidMnemonicPhrase:
            writeInt(&buf, Int32(29))

        case let .InvalidBip39WordCount(badValue):
            writeInt(&buf, Int32(30))
            FfiConverterUInt64.write(badValue, into: &buf)

        case let .InvalidAppearanceId(badValue):
            writeInt(&buf, Int32(31))
            FfiConverterUInt8.write(badValue, into: &buf)

        case let .InvalidAccountAddress(badValue):
            writeInt(&buf, Int32(32))
            FfiConverterString.write(badValue, into: &buf)

        case .UnsupportedEntityType:
            writeInt(&buf, Int32(33))

        case let .FailedToDecodeAddressFromBech32(badValue):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(badValue, into: &buf)

        case .MismatchingEntityTypeWhileDecodingAddress:
            writeInt(&buf, Int32(35))

        case .MismatchingHrpWhileDecodingAddress:
            writeInt(&buf, Int32(36))

        case let .UnknownNetworkId(badValue):
            writeInt(&buf, Int32(37))
            FfiConverterUInt8.write(badValue, into: &buf)

        case let .InvalidNonFungibleGlobalId(badValue):
            writeInt(&buf, Int32(38))
            FfiConverterString.write(badValue, into: &buf)

        case .FactorSourceCryptoParametersSupportedCurvesInvalidSize:
            writeInt(&buf, Int32(39))

        case .BadgeIsNotVirtualHierarchicalDeterministic:
            writeInt(&buf, Int32(40))

        case .FactorSourceIdNotFromHash:
            writeInt(&buf, Int32(41))

        case .ExpectedAccountPathButGotSomethingElse:
            writeInt(&buf, Int32(42))

        case .WrongEntityKindOfInFactorInstancesPath:
            writeInt(&buf, Int32(43))

        case .WrongKeyKindOfTransactionSigningFactorInstance:
            writeInt(&buf, Int32(44))

        case .WrongKeyKindOfAuthenticationSigningFactorInstance:
            writeInt(&buf, Int32(45))

        case .ExpectedDeviceFactorSourceGotSomethingElse:
            writeInt(&buf, Int32(46))

        case .ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse:
            writeInt(&buf, Int32(47))

        case let .UnknownNetworkWithName(badValue):
            writeInt(&buf, Int32(48))
            FfiConverterString.write(badValue, into: &buf)

        case let .UnknownNetworkForId(badValue):
            writeInt(&buf, Int32(49))
            FfiConverterUInt8.write(badValue, into: &buf)

        case .GatewaysDiscrepancyOtherShouldNotContainCurrent:
            writeInt(&buf, Int32(50))

        case .InvalidGatewaysJsonCurrentNotFoundAmongstSaved:
            writeInt(&buf, Int32(51))

        case let .InvalidUrl(badValue):
            writeInt(&buf, Int32(52))
            FfiConverterString.write(badValue, into: &buf)

        case let .AccountOnWrongNetwork(expected, found):
            writeInt(&buf, Int32(53))
            FfiConverterTypeNetworkID.write(expected, into: &buf)
            FfiConverterTypeNetworkID.write(found, into: &buf)

        case .FactorSourcesMustNotBeEmpty:
            writeInt(&buf, Int32(54))

        case .UpdateFactorSourceMutateFailed:
            writeInt(&buf, Int32(55))

        case let .CastFactorSourceWrongKind(expected, found):
            writeInt(&buf, Int32(56))
            FfiConverterTypeFactorSourceKind.write(expected, into: &buf)
            FfiConverterTypeFactorSourceKind.write(found, into: &buf)

        case let .InvalidLength(expected, found, data):
            writeInt(&buf, Int32(57))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)
            FfiConverterTypeBagOfBytes.write(data, into: &buf)

        case .InvalidNonFungibleLocalIdString:
            writeInt(&buf, Int32(58))

        case .InvalidNonFungibleLocalIdBytes:
            writeInt(&buf, Int32(59))

        case .DecimalError:
            writeInt(&buf, Int32(60))

        case let .InvalidBip39Index(badValue):
            writeInt(&buf, Int32(61))
            FfiConverterUInt16.write(badValue, into: &buf)

        case .InvalidDisplayNameEmpty:
            writeInt(&buf, Int32(62))

        case let .InvalidDisplayNameTooLong(expected, found):
            writeInt(&buf, Int32(63))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case let .InvalidIso8601String(badValue):
            writeInt(&buf, Int32(64))
            FfiConverterString.write(badValue, into: &buf)

        case .UnknownAccount:
            writeInt(&buf, Int32(65))

        case .SecureStorageReadError:
            writeInt(&buf, Int32(66))

        case .UnableToLoadDeviceFactorSourceFromSecureStorage:
            writeInt(&buf, Int32(67))

        case .SecureStorageWriteError:
            writeInt(&buf, Int32(68))

        case .FailedToSerializeToJson:
            writeInt(&buf, Int32(69))

        case let .FailedToDeserializeJsonToValue(jsonByteCount, typeName):
            writeInt(&buf, Int32(70))
            FfiConverterUInt64.write(jsonByteCount, into: &buf)
            FfiConverterString.write(typeName, into: &buf)

        case let .InvalidProfileId(badValue):
            writeInt(&buf, Int32(71))
            FfiConverterString.write(badValue, into: &buf)

        case .FailedToLoadProfileHeadersList:
            writeInt(&buf, Int32(72))

        case let .ProfileDoesNotContainFactorSourceWithId(badValue):
            writeInt(&buf, Int32(73))
            FfiConverterTypeFactorSourceID.write(badValue, into: &buf)

        case .NoActiveProfileIdSet:
            writeInt(&buf, Int32(74))

        case let .ProfileSnapshotNotFound(badValue):
            writeInt(&buf, Int32(75))
            FfiConverterTypeProfileID.write(badValue, into: &buf)

        case let .AccountAlreadyPresent(badValue):
            writeInt(&buf, Int32(76))
            FfiConverterTypeAccountAddress.write(badValue, into: &buf)

        case .UnableToAcquireWriteLockForProfile:
            writeInt(&buf, Int32(77))

        case let .UnableToSaveMnemonicToSecureStorage(badValue):
            writeInt(&buf, Int32(78))
            FfiConverterTypeFactorSourceIDFromHash.write(badValue, into: &buf)

        case let .UnableToLoadMnemonicFromSecureStorage(badValue):
            writeInt(&buf, Int32(79))
            FfiConverterTypeFactorSourceIDFromHash.write(badValue, into: &buf)

        case let .UnableToSaveFactorSourceToProfile(badValue):
            writeInt(&buf, Int32(80))
            FfiConverterTypeFactorSourceID.write(badValue, into: &buf)

        case .ExpectedIdentityPathButGotSomethingElse:
            writeInt(&buf, Int32(81))

        case .PersonaDataInvalidPhoneNumberEmpty:
            writeInt(&buf, Int32(82))

        case .PersonaDataInvalidEmailAddressEmpty:
            writeInt(&buf, Int32(83))

        case .PersonaDataInvalidNameFamilyNameEmpty:
            writeInt(&buf, Int32(84))

        case .PersonaDataInvalidNameGivenNamesEmpty:
            writeInt(&buf, Int32(85))

        case let .InvalidUuiDv4(badValue):
            writeInt(&buf, Int32(86))
            FfiConverterString.write(badValue, into: &buf)

        case let .UnrecognizedLocaleIdentifier(badValue):
            writeInt(&buf, Int32(87))
            FfiConverterString.write(badValue, into: &buf)

        case let .FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(nodeIdAsHex, networkId):
            writeInt(&buf, Int32(88))
            FfiConverterString.write(nodeIdAsHex, into: &buf)
            FfiConverterTypeNetworkID.write(networkId, into: &buf)

        case let .InvalidOlympiaAddressString(badValue):
            writeInt(&buf, Int32(89))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidInstructionsString(underlying):
            writeInt(&buf, Int32(90))
            FfiConverterString.write(underlying, into: &buf)

        case let .ExecutionSummaryFail(underlying):
            writeInt(&buf, Int32(91))
            FfiConverterString.write(underlying, into: &buf)

        case .FailedToDecodeEncodedReceipt:
            writeInt(&buf, Int32(92))

        case .BytesEmpty:
            writeInt(&buf, Int32(93))

        case let .TooManyBytes(max, found):
            writeInt(&buf, Int32(94))
            FfiConverterUInt64.write(max, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case let .InvalidInstructionsWrongNetwork(foundInInstructions, specifiedToInstructionsCtor):
            writeInt(&buf, Int32(95))
            FfiConverterTypeNetworkID.write(foundInInstructions, into: &buf)
            FfiConverterTypeNetworkID.write(specifiedToInstructionsCtor, into: &buf)

        case .FailedToUniFfiDecodeBytesToManifestInstructions:
            writeInt(&buf, Int32(96))

        case let .FailedToDecodeTransactionHash(badValue):
            writeInt(&buf, Int32(97))
            FfiConverterString.write(badValue, into: &buf)

        case .FailedToHashIntent:
            writeInt(&buf, Int32(98))

        case .EncryptedMessagesAreNotYetSupported:
            writeInt(&buf, Int32(99))

        case let .FailedToBech32DecodeTransactionHashAfterHavingTestedAllNetworkId(badValue):
            writeInt(&buf, Int32(100))
            FfiConverterString.write(badValue, into: &buf)

        case let .FailedToParseSignatureFromString(badValue):
            writeInt(&buf, Int32(101))
            FfiConverterString.write(badValue, into: &buf)

        case .InvalidSignaturesForIntentSomeDidNotValidateIntentHash:
            writeInt(&buf, Int32(102))

        case .FailedToDecompileBytesIntoNotarizedTransaction:
            writeInt(&buf, Int32(103))

        case .FailedToRecoverSecp256k1PublicKeyFromSignature:
            writeInt(&buf, Int32(104))

        case .FungibleResourceAddressNotAcceptedInNonFungibleContext:
            writeInt(&buf, Int32(105))

        case let .DecimalOverflow(badValue):
            writeInt(&buf, Int32(106))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidAddressNotOlympiaMainnet(badValue):
            writeInt(&buf, Int32(107))
            FfiConverterString.write(badValue, into: &buf)

        case let .FailedToParseSignatureFromBytes(badValue):
            writeInt(&buf, Int32(108))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidIntentFailedToEncode(underlying):
            writeInt(&buf, Int32(109))
            FfiConverterString.write(underlying, into: &buf)

        case let .InvalidInstructionsFailedToDecompile(underlying):
            writeInt(&buf, Int32(110))
            FfiConverterString.write(underlying, into: &buf)

        case let .InvalidTransactionMaxSborDepthExceeded(max):
            writeInt(&buf, Int32(111))
            FfiConverterUInt16.write(max, into: &buf)

        case let .InvalidSignedIntentFailedToEncode(underlying):
            writeInt(&buf, Int32(112))
            FfiConverterString.write(underlying, into: &buf)

        case let .InvalidNotarizedIntentFailedToEncode(underlying):
            writeInt(&buf, Int32(113))
            FfiConverterString.write(underlying, into: &buf)

        case .NetworkResponseBadCode:
            writeInt(&buf, Int32(114))

        case .NetworkResponseEmptyBody:
            writeInt(&buf, Int32(115))

        case let .NetworkResponseJsonDeserialize(intoType):
            writeInt(&buf, Int32(116))
            FfiConverterString.write(intoType, into: &buf)

        case let .NetworkRequestInvalidUrl(badValue):
            writeInt(&buf, Int32(117))
            FfiConverterString.write(badValue, into: &buf)

        case let .NetworkRequestGenericFailure(underlying):
            writeInt(&buf, Int32(118))
            FfiConverterString.write(underlying, into: &buf)

        case let .GatewaySubmitDuplicateTx(intentHash):
            writeInt(&buf, Int32(119))
            FfiConverterString.write(intentHash, into: &buf)

        case .SupportedCurvesMustNotBeEmpty:
            writeInt(&buf, Int32(120))

        case .ProfileNetworksMustNotBeEmpty:
            writeInt(&buf, Int32(121))

        case let .UnknownSlip10Curve(badValue):
            writeInt(&buf, Int32(122))
            FfiConverterString.write(badValue, into: &buf)

        case .AesDecryptionFailed:
            writeInt(&buf, Int32(123))

        case let .InvalidAesBytesTooShort(expectedAtLeast, found):
            writeInt(&buf, Int32(124))
            FfiConverterUInt64.write(expectedAtLeast, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case let .InvalidFactorSourceKind(badValue):
            writeInt(&buf, Int32(125))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidLedgerHardwareWalletModel(badValue):
            writeInt(&buf, Int32(126))
            FfiConverterString.write(badValue, into: &buf)

        case let .RadixConnectMobileInvalidRequestUrl(badValue):
            writeInt(&buf, Int32(127))
            FfiConverterString.write(badValue, into: &buf)

        case let .RadixConnectMobileInvalidOrigin(badValue):
            writeInt(&buf, Int32(128))
            FfiConverterString.write(badValue, into: &buf)

        case let .RadixConnectMobileInvalidSessionId(badValue):
            writeInt(&buf, Int32(129))
            FfiConverterString.write(badValue, into: &buf)

        case let .RadixMobileInvalidInteractionId(badValue):
            writeInt(&buf, Int32(130))
            FfiConverterString.write(badValue, into: &buf)

        case let .NetworkDiscrepancy(expected, actual):
            writeInt(&buf, Int32(131))
            FfiConverterTypeNetworkID.write(expected, into: &buf)
            FfiConverterTypeNetworkID.write(actual, into: &buf)

        case let .DiscrepancyAuthorizedDappReferencedPersonaWhichDoesNotExist(address):
            writeInt(&buf, Int32(132))
            FfiConverterTypeIdentityAddress.write(address, into: &buf)

        case let .DiscrepancyAuthorizedDappReferencedAccountWhichDoesNotExist(address):
            writeInt(&buf, Int32(133))
            FfiConverterTypeAccountAddress.write(address, into: &buf)

        case .AuthorizedDappReferencesFieldIdThatDoesNotExist:
            writeInt(&buf, Int32(134))

        case let .ElementDoesNotExist(id):
            writeInt(&buf, Int32(135))
            FfiConverterString.write(id, into: &buf)

        case let .ElementAlreadyExist(id):
            writeInt(&buf, Int32(136))
            FfiConverterString.write(id, into: &buf)

        case let .InvalidRadixConnectPurpose(badValue):
            writeInt(&buf, Int32(137))
            FfiConverterString.write(badValue, into: &buf)
        }
    }
}

extension CommonError: Equatable, Hashable {}

extension CommonError: Swift.Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappToWalletInteractionAuthRequestItem {
    case loginWithChallenge(DappToWalletInteractionAuthLoginWithChallengeRequestItem
    )
    case loginWithoutChallenge
    case usePersona(DappToWalletInteractionAuthUsePersonaRequestItem
    )
}

public struct FfiConverterTypeDappToWalletInteractionAuthRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionAuthRequestItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthRequestItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .loginWithChallenge(FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.read(from: &buf)
            )

        case 2: return .loginWithoutChallenge

        case 3: return try .usePersona(FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappToWalletInteractionAuthRequestItem, into buf: inout [UInt8]) {
        switch value {
        case let .loginWithChallenge(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.write(v1, into: &buf)

        case .loginWithoutChallenge:
            writeInt(&buf, Int32(2))

        case let .usePersona(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAuthRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthRequestItem_lower(_ value: DappToWalletInteractionAuthRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthRequestItem.lower(value)
}

extension DappToWalletInteractionAuthRequestItem: Sendable {}
extension DappToWalletInteractionAuthRequestItem: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappToWalletInteractionItems {
    case unauthorizedRequest(DappToWalletInteractionUnauthorizedRequestItems
    )
    case authorizedRequest(DappToWalletInteractionAuthorizedRequestItems
    )
    case transaction(DappToWalletInteractionTransactionItems
    )
}

public struct FfiConverterTypeDappToWalletInteractionItems: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionItems

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionItems {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .unauthorizedRequest(FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.read(from: &buf)
            )

        case 2: return try .authorizedRequest(FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.read(from: &buf)
            )

        case 3: return try .transaction(FfiConverterTypeDappToWalletInteractionTransactionItems.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappToWalletInteractionItems, into buf: inout [UInt8]) {
        switch value {
        case let .unauthorizedRequest(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.write(v1, into: &buf)

        case let .authorizedRequest(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.write(v1, into: &buf)

        case let .transaction(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDappToWalletInteractionTransactionItems.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeDappToWalletInteractionItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionItems {
    return try FfiConverterTypeDappToWalletInteractionItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionItems_lower(_ value: DappToWalletInteractionItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionItems.lower(value)
}

extension DappToWalletInteractionItems: Sendable {}
extension DappToWalletInteractionItems: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappWalletInteractionErrorType {
    case rejectedByUser
    case wrongNetwork
    case failedToPrepareTransaction
    case failedToCompileTransaction
    case failedToSignTransaction
    case failedToSubmitTransaction
    case failedToPollSubmittedTransaction
    case failedToFindAccountWithEnoughFundsToLockFee
    case submittedTransactionWasDuplicate
    case submittedTransactionHasFailedTransactionStatus
    case submittedTransactionHasRejectedTransactionStatus
    case wrongAccountType
    case unknownWebsite
    case invalidOriginUrl
    case radixJsonNotFound
    case radixJsonUnknownFileFormat
    case unknownDappDefinitionAddress
    case invalidPersona
    case invalidRequest
    case incompatibleVersion
    case failedToSignAuthChallenge
}

public struct FfiConverterTypeDappWalletInteractionErrorType: FfiConverterRustBuffer {
    typealias SwiftType = DappWalletInteractionErrorType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappWalletInteractionErrorType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .rejectedByUser

        case 2: return .wrongNetwork

        case 3: return .failedToPrepareTransaction

        case 4: return .failedToCompileTransaction

        case 5: return .failedToSignTransaction

        case 6: return .failedToSubmitTransaction

        case 7: return .failedToPollSubmittedTransaction

        case 8: return .failedToFindAccountWithEnoughFundsToLockFee

        case 9: return .submittedTransactionWasDuplicate

        case 10: return .submittedTransactionHasFailedTransactionStatus

        case 11: return .submittedTransactionHasRejectedTransactionStatus

        case 12: return .wrongAccountType

        case 13: return .unknownWebsite

        case 14: return .invalidOriginUrl

        case 15: return .radixJsonNotFound

        case 16: return .radixJsonUnknownFileFormat

        case 17: return .unknownDappDefinitionAddress

        case 18: return .invalidPersona

        case 19: return .invalidRequest

        case 20: return .incompatibleVersion

        case 21: return .failedToSignAuthChallenge

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappWalletInteractionErrorType, into buf: inout [UInt8]) {
        switch value {
        case .rejectedByUser:
            writeInt(&buf, Int32(1))

        case .wrongNetwork:
            writeInt(&buf, Int32(2))

        case .failedToPrepareTransaction:
            writeInt(&buf, Int32(3))

        case .failedToCompileTransaction:
            writeInt(&buf, Int32(4))

        case .failedToSignTransaction:
            writeInt(&buf, Int32(5))

        case .failedToSubmitTransaction:
            writeInt(&buf, Int32(6))

        case .failedToPollSubmittedTransaction:
            writeInt(&buf, Int32(7))

        case .failedToFindAccountWithEnoughFundsToLockFee:
            writeInt(&buf, Int32(8))

        case .submittedTransactionWasDuplicate:
            writeInt(&buf, Int32(9))

        case .submittedTransactionHasFailedTransactionStatus:
            writeInt(&buf, Int32(10))

        case .submittedTransactionHasRejectedTransactionStatus:
            writeInt(&buf, Int32(11))

        case .wrongAccountType:
            writeInt(&buf, Int32(12))

        case .unknownWebsite:
            writeInt(&buf, Int32(13))

        case .invalidOriginUrl:
            writeInt(&buf, Int32(14))

        case .radixJsonNotFound:
            writeInt(&buf, Int32(15))

        case .radixJsonUnknownFileFormat:
            writeInt(&buf, Int32(16))

        case .unknownDappDefinitionAddress:
            writeInt(&buf, Int32(17))

        case .invalidPersona:
            writeInt(&buf, Int32(18))

        case .invalidRequest:
            writeInt(&buf, Int32(19))

        case .incompatibleVersion:
            writeInt(&buf, Int32(20))

        case .failedToSignAuthChallenge:
            writeInt(&buf, Int32(21))
        }
    }
}

public func FfiConverterTypeDappWalletInteractionErrorType_lift(_ buf: RustBuffer) throws -> DappWalletInteractionErrorType {
    return try FfiConverterTypeDappWalletInteractionErrorType.lift(buf)
}

public func FfiConverterTypeDappWalletInteractionErrorType_lower(_ value: DappWalletInteractionErrorType) -> RustBuffer {
    return FfiConverterTypeDappWalletInteractionErrorType.lower(value)
}

extension DappWalletInteractionErrorType: Sendable {}
extension DappWalletInteractionErrorType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DependencyInformation {
    case version(String
    )
    case tag(String
    )
    case branch(String
    )
    case rev(String
    )
}

public struct FfiConverterTypeDependencyInformation: FfiConverterRustBuffer {
    typealias SwiftType = DependencyInformation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DependencyInformation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .version(FfiConverterString.read(from: &buf)
            )

        case 2: return try .tag(FfiConverterString.read(from: &buf)
            )

        case 3: return try .branch(FfiConverterString.read(from: &buf)
            )

        case 4: return try .rev(FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DependencyInformation, into buf: inout [UInt8]) {
        switch value {
        case let .version(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .tag(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)

        case let .branch(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)

        case let .rev(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeDependencyInformation_lift(_ buf: RustBuffer) throws -> DependencyInformation {
    return try FfiConverterTypeDependencyInformation.lift(buf)
}

public func FfiConverterTypeDependencyInformation_lower(_ value: DependencyInformation) -> RustBuffer {
    return FfiConverterTypeDependencyInformation.lower(value)
}

extension DependencyInformation: Sendable {}
extension DependencyInformation: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The exception kind for deposit address
 */

public enum DepositAddressExceptionRule {
    /**
     * A resource can always be deposited in to the account by third-parties
     */
    case allow
    /**
     * A resource can never be deposited in to the account by third-parties
     */
    case deny
}

public struct FfiConverterTypeDepositAddressExceptionRule: FfiConverterRustBuffer {
    typealias SwiftType = DepositAddressExceptionRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositAddressExceptionRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .allow

        case 2: return .deny

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositAddressExceptionRule, into buf: inout [UInt8]) {
        switch value {
        case .allow:
            writeInt(&buf, Int32(1))

        case .deny:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeDepositAddressExceptionRule_lift(_ buf: RustBuffer) throws -> DepositAddressExceptionRule {
    return try FfiConverterTypeDepositAddressExceptionRule.lift(buf)
}

public func FfiConverterTypeDepositAddressExceptionRule_lower(_ value: DepositAddressExceptionRule) -> RustBuffer {
    return FfiConverterTypeDepositAddressExceptionRule.lower(value)
}

extension DepositAddressExceptionRule: Sendable {}
extension DepositAddressExceptionRule: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The general deposit rule to apply
 */

public enum DepositRule {
    /**
     * The account accepts **all** assets by default, except for exceptions (if any) which might not deposit/be deposited into this account.
     */
    case acceptKnown
    /**
     * The account accepts **known** assets by default, except for exceptions (if any) which might not deposit/be deposited into this account. By known we mean assets this account has received in the past.
     */
    case acceptAll
    /**
     * The account denies **all** assets by default, except for exceptions (if any) which might in fact deposit/be deposited into this account.
     */
    case denyAll
}

public struct FfiConverterTypeDepositRule: FfiConverterRustBuffer {
    typealias SwiftType = DepositRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .acceptKnown

        case 2: return .acceptAll

        case 3: return .denyAll

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositRule, into buf: inout [UInt8]) {
        switch value {
        case .acceptKnown:
            writeInt(&buf, Int32(1))

        case .acceptAll:
            writeInt(&buf, Int32(2))

        case .denyAll:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeDepositRule_lift(_ buf: RustBuffer) throws -> DepositRule {
    return try FfiConverterTypeDepositRule.lift(buf)
}

public func FfiConverterTypeDepositRule_lower(_ value: DepositRule) -> RustBuffer {
    return FfiConverterTypeDepositRule.lower(value)
}

extension DepositRule: Sendable {}
extension DepositRule: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A derivation path on either supported schemes, either Babylon (CAP26) or Olympia (BIP44Like).
 */

public enum DerivationPath {
    case cap26(value: Cap26Path
    )
    case bip44Like(value: Bip44LikePath
    )
}

public struct FfiConverterTypeDerivationPath: FfiConverterRustBuffer {
    typealias SwiftType = DerivationPath

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPath {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .cap26(value: FfiConverterTypeCAP26Path.read(from: &buf)
            )

        case 2: return try .bip44Like(value: FfiConverterTypeBIP44LikePath.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivationPath, into buf: inout [UInt8]) {
        switch value {
        case let .cap26(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeCAP26Path.write(value, into: &buf)

        case let .bip44Like(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBIP44LikePath.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeDerivationPath_lift(_ buf: RustBuffer) throws -> DerivationPath {
    return try FfiConverterTypeDerivationPath.lift(buf)
}

public func FfiConverterTypeDerivationPath_lower(_ value: DerivationPath) -> RustBuffer {
    return FfiConverterTypeDerivationPath.lower(value)
}

extension DerivationPath: Sendable {}
extension DerivationPath: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Which derivation path to used for some particular HD operations
 * such as signing or public key derivation. Radix Babylon introduces
 * a new scheme call Cap26 but we also need to support BIP44-like used
 * by Olympia.
 */

public enum DerivationPathScheme {
    /**
     * A BIP32 based derivation path scheme, using SLIP10.
     */
    case cap26
    /**
     * A BIP32 based similar to BIP44, but not strict BIP44 since the
     * last path component is hardened (a mistake made during Olympia),
     * used to support legacy accounts imported from Olympia wallet.
     */
    case bip44Olympia
}

public struct FfiConverterTypeDerivationPathScheme: FfiConverterRustBuffer {
    typealias SwiftType = DerivationPathScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPathScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .cap26

        case 2: return .bip44Olympia

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivationPathScheme, into buf: inout [UInt8]) {
        switch value {
        case .cap26:
            writeInt(&buf, Int32(1))

        case .bip44Olympia:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeDerivationPathScheme_lift(_ buf: RustBuffer) throws -> DerivationPathScheme {
    return try FfiConverterTypeDerivationPathScheme.lift(buf)
}

public func FfiConverterTypeDerivationPathScheme_lower(_ value: DerivationPathScheme) -> RustBuffer {
    return FfiConverterTypeDerivationPathScheme.lower(value)
}

extension DerivationPathScheme: Sendable {}
extension DerivationPathScheme: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The execution summary process not only determines the class of the manifest,
 * but also includes additional information about this class that the wallet
 * requires to display to the user.
 */

public enum DetailedManifestClass {
    /**
     * A general manifest that involves any amount of arbitrary components
     * and packages where nothing more concrete can be said about the manifest
     * and its nature.
     *
     * No additional information is required beyond what the execution summary
     * will provide.
     */
    case general
    /**
     * A manifest of a 1-to-1 transfer to a one-to-many transfer of resources.
     */
    case transfer(
        /**
         * When `true`, then this is a one-to-one transfer and the wallet can
         * regard this as a "simple transfer" and communicate this information
         * to the ledger hardware wallet. Otherwise, if `false`, then this is
         * not a one-to-one transfer.
         */ isOneToOne: Bool
    )
    /**
     * A manifest where XRD is claimed from one or more validators.
     */
    case validatorClaim(
        /**
         * The addresses of validators in the transaction
         */ validatorAddresses: [ValidatorAddress],
        /**
            * The claims observed in the transaction
            */ validatorClaims: [TrackedValidatorClaim]
    )
    /**
     * A manifest where XRD is staked to one or more validators.
     */
    case validatorStake(
        /**
         * The addresses of validators in the transaction
         */ validatorAddresses: [ValidatorAddress],
        /**
            * The stake observed in the transaction
            */ validatorStakes: [TrackedValidatorStake]
    )
    /**
     * A manifest where XRD is unstaked from one or more validators.
     */
    case validatorUnstake(
        /**
         * The addresses of validators in the transaction
         */ validatorAddresses: [ValidatorAddress],
        /**
            * The data associated with the various claim NFTs
            */ claimsNonFungibleData: [NonFungibleGlobalId: UnstakeData]
    )
    /**
     * A manifest that updated the deposit settings of the account.
     */
    case accountDepositSettingsUpdate(
        /**
         * Updates to the resource preferences of the account deposit settings.
         * account_address -> (resource_address -> Update<new_preference>)
         */ resourcePreferencesUpdates: [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]],
        /**
            * Changes to the account's deposit mode.
            * account_address -> new_default_deposit_mode
            */ depositModeUpdates: [AccountAddress: DepositRule],
        /**
            * Additions to the authorized depositors
            */ authorizedDepositorsAdded: [AccountAddress: [ResourceOrNonFungible]],
        /**
            * Removals from the authorized depositors
            */ authorizedDepositorsRemoved: [AccountAddress: [ResourceOrNonFungible]]
    )
    /**
     * A manifest that contributed some amount of resources to a liquidity
     * pool that can be a one-resource pool, two-resource pool, or a
     * multi-resource pool.
     */
    case poolContribution(
        /**
         * The addresses of the pools in the transaction
         */ poolAddresses: [PoolAddress],
        /**
            * The contribution observed in the transaction
            */ poolContributions: [TrackedPoolContribution]
    )
    /**
     * A manifest that redeemed resources from a liquidity pool. Similar to
     * contributions, this can be any of the three pool blueprints available
     * in the pool package.
     */
    case poolRedemption(
        /**
         * The addresses of the pools in the transaction
         */ poolAddresses: [PoolAddress],
        /**
            * The redemptions observed in the transaction
            */ poolRedemptions: [TrackedPoolRedemption]
    )
}

public struct FfiConverterTypeDetailedManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = DetailedManifestClass

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DetailedManifestClass {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .general

        case 2: return try .transfer(isOneToOne: FfiConverterBool.read(from: &buf)
            )

        case 3: return try .validatorClaim(validatorAddresses: FfiConverterSequenceTypeValidatorAddress.read(from: &buf), validatorClaims: FfiConverterSequenceTypeTrackedValidatorClaim.read(from: &buf))

        case 4: return try .validatorStake(validatorAddresses: FfiConverterSequenceTypeValidatorAddress.read(from: &buf), validatorStakes: FfiConverterSequenceTypeTrackedValidatorStake.read(from: &buf))

        case 5: return try .validatorUnstake(validatorAddresses: FfiConverterSequenceTypeValidatorAddress.read(from: &buf), claimsNonFungibleData: FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData.read(from: &buf))

        case 6: return try .accountDepositSettingsUpdate(resourcePreferencesUpdates: FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.read(from: &buf), depositModeUpdates: FfiConverterDictionaryTypeAccountAddressTypeDepositRule.read(from: &buf), authorizedDepositorsAdded: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.read(from: &buf), authorizedDepositorsRemoved: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.read(from: &buf))

        case 7: return try .poolContribution(poolAddresses: FfiConverterSequenceTypePoolAddress.read(from: &buf), poolContributions: FfiConverterSequenceTypeTrackedPoolContribution.read(from: &buf))

        case 8: return try .poolRedemption(poolAddresses: FfiConverterSequenceTypePoolAddress.read(from: &buf), poolRedemptions: FfiConverterSequenceTypeTrackedPoolRedemption.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DetailedManifestClass, into buf: inout [UInt8]) {
        switch value {
        case .general:
            writeInt(&buf, Int32(1))

        case let .transfer(isOneToOne):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(isOneToOne, into: &buf)

        case let .validatorClaim(validatorAddresses, validatorClaims):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedValidatorClaim.write(validatorClaims, into: &buf)

        case let .validatorStake(validatorAddresses, validatorStakes):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedValidatorStake.write(validatorStakes, into: &buf)

        case let .validatorUnstake(validatorAddresses, claimsNonFungibleData):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
            FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData.write(claimsNonFungibleData, into: &buf)

        case let .accountDepositSettingsUpdate(resourcePreferencesUpdates, depositModeUpdates, authorizedDepositorsAdded, authorizedDepositorsRemoved):
            writeInt(&buf, Int32(6))
            FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.write(resourcePreferencesUpdates, into: &buf)
            FfiConverterDictionaryTypeAccountAddressTypeDepositRule.write(depositModeUpdates, into: &buf)
            FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.write(authorizedDepositorsAdded, into: &buf)
            FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.write(authorizedDepositorsRemoved, into: &buf)

        case let .poolContribution(poolAddresses, poolContributions):
            writeInt(&buf, Int32(7))
            FfiConverterSequenceTypePoolAddress.write(poolAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedPoolContribution.write(poolContributions, into: &buf)

        case let .poolRedemption(poolAddresses, poolRedemptions):
            writeInt(&buf, Int32(8))
            FfiConverterSequenceTypePoolAddress.write(poolAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedPoolRedemption.write(poolRedemptions, into: &buf)
        }
    }
}

public func FfiConverterTypeDetailedManifestClass_lift(_ buf: RustBuffer) throws -> DetailedManifestClass {
    return try FfiConverterTypeDetailedManifestClass.lift(buf)
}

public func FfiConverterTypeDetailedManifestClass_lower(_ value: DetailedManifestClass) -> RustBuffer {
    return FfiConverterTypeDetailedManifestClass.lower(value)
}

extension DetailedManifestClass: Sendable {}
extension DetailedManifestClass: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Flags used to mark state of an Account or Persona such as whether
 * user has marked it as deleted or not.
 */

public enum EntityFlag {
    /**
     * The entity is marked as deleted by user. Entity should still be kept in Profile
     */
    case deletedByUser
    /**
     * Just a temporary placeholder value used by Sample Values.
     */
    case placeholderSampleValueFlag
}

public struct FfiConverterTypeEntityFlag: FfiConverterRustBuffer {
    typealias SwiftType = EntityFlag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityFlag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .deletedByUser

        case 2: return .placeholderSampleValueFlag

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityFlag, into buf: inout [UInt8]) {
        switch value {
        case .deletedByUser:
            writeInt(&buf, Int32(1))

        case .placeholderSampleValueFlag:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeEntityFlag_lift(_ buf: RustBuffer) throws -> EntityFlag {
    return try FfiConverterTypeEntityFlag.lift(buf)
}

public func FfiConverterTypeEntityFlag_lower(_ value: EntityFlag) -> RustBuffer {
    return FfiConverterTypeEntityFlag.lower(value)
}

extension EntityFlag: Sendable {}
extension EntityFlag: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EntityKind {
    case account
    case persona
}

public struct FfiConverterTypeEntityKind: FfiConverterRustBuffer {
    typealias SwiftType = EntityKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .account

        case 2: return .persona

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityKind, into buf: inout [UInt8]) {
        switch value {
        case .account:
            writeInt(&buf, Int32(1))

        case .persona:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeEntityKind_lift(_ buf: RustBuffer) throws -> EntityKind {
    return try FfiConverterTypeEntityKind.lift(buf)
}

public func FfiConverterTypeEntityKind_lower(_ value: EntityKind) -> RustBuffer {
    return FfiConverterTypeEntityKind.lower(value)
}

extension EntityKind: Sendable {}
extension EntityKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the state an entity - Account or Persona - is in, in regards to how
 * the user controls it, i.e. if it is controlled by a single factor (private key)
 * or an `AccessController` with a potential Multi-Factor setup.
 */

public enum EntitySecurityState {
    /**
     * The account is controlled by a single factor (private key)
     */
    case unsecured(value: UnsecuredEntityControl
    )
}

public struct FfiConverterTypeEntitySecurityState: FfiConverterRustBuffer {
    typealias SwiftType = EntitySecurityState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntitySecurityState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .unsecured(value: FfiConverterTypeUnsecuredEntityControl.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntitySecurityState, into buf: inout [UInt8]) {
        switch value {
        case let .unsecured(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUnsecuredEntityControl.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeEntitySecurityState_lift(_ buf: RustBuffer) throws -> EntitySecurityState {
    return try FfiConverterTypeEntitySecurityState.lift(buf)
}

public func FfiConverterTypeEntitySecurityState_lower(_ value: EntitySecurityState) -> RustBuffer {
    return FfiConverterTypeEntitySecurityState.lower(value)
}

extension EntitySecurityState: Sendable {}
extension EntitySecurityState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either a "physical" badge (NFT) or some source for recreation of a producer
 * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
 * is derived which produces virtual badges (signatures).
 */

public enum FactorInstanceBadge {
    case virtual(value: FactorInstanceBadgeVirtualSource
    )
}

public struct FfiConverterTypeFactorInstanceBadge: FfiConverterRustBuffer {
    typealias SwiftType = FactorInstanceBadge

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceBadge {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .virtual(value: FfiConverterTypeFactorInstanceBadgeVirtualSource.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorInstanceBadge, into buf: inout [UInt8]) {
        switch value {
        case let .virtual(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFactorInstanceBadgeVirtualSource.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorInstanceBadge_lift(_ buf: RustBuffer) throws -> FactorInstanceBadge {
    return try FfiConverterTypeFactorInstanceBadge.lift(buf)
}

public func FfiConverterTypeFactorInstanceBadge_lower(_ value: FactorInstanceBadge) -> RustBuffer {
    return FfiConverterTypeFactorInstanceBadge.lower(value)
}

extension FactorInstanceBadge: Sendable {}
extension FactorInstanceBadge: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FactorInstanceBadgeVirtualSource {
    case hierarchicalDeterministic(value: HierarchicalDeterministicPublicKey
    )
}

public struct FfiConverterTypeFactorInstanceBadgeVirtualSource: FfiConverterRustBuffer {
    typealias SwiftType = FactorInstanceBadgeVirtualSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceBadgeVirtualSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .hierarchicalDeterministic(value: FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorInstanceBadgeVirtualSource, into buf: inout [UInt8]) {
        switch value {
        case let .hierarchicalDeterministic(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeHierarchicalDeterministicPublicKey.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorInstanceBadgeVirtualSource_lift(_ buf: RustBuffer) throws -> FactorInstanceBadgeVirtualSource {
    return try FfiConverterTypeFactorInstanceBadgeVirtualSource.lift(buf)
}

public func FfiConverterTypeFactorInstanceBadgeVirtualSource_lower(_ value: FactorInstanceBadgeVirtualSource) -> RustBuffer {
    return FfiConverterTypeFactorInstanceBadgeVirtualSource.lower(value)
}

extension FactorInstanceBadgeVirtualSource: Sendable {}
extension FactorInstanceBadgeVirtualSource: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FactorSource {
    case device(value: DeviceFactorSource
    )
    case ledger(value: LedgerHardwareWalletFactorSource
    )
}

public struct FfiConverterTypeFactorSource: FfiConverterRustBuffer {
    typealias SwiftType = FactorSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .device(value: FfiConverterTypeDeviceFactorSource.read(from: &buf)
            )

        case 2: return try .ledger(value: FfiConverterTypeLedgerHardwareWalletFactorSource.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSource, into buf: inout [UInt8]) {
        switch value {
        case let .device(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDeviceFactorSource.write(value, into: &buf)

        case let .ledger(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLedgerHardwareWalletFactorSource.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorSource_lift(_ buf: RustBuffer) throws -> FactorSource {
    return try FfiConverterTypeFactorSource.lift(buf)
}

public func FfiConverterTypeFactorSource_lower(_ value: FactorSource) -> RustBuffer {
    return FfiConverterTypeFactorSource.lower(value)
}

extension FactorSource: Sendable {}
extension FactorSource: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Flags which describe a certain state a FactorSource might be in, primarily used
 * by DeviceFactorSource's to mark which "Babylon" FactorSource is the **main** one.
 */

public enum FactorSourceFlag {
    /**
     * Used to mark a "babylon" `.device` FactorSource as "main". All new accounts
     * and Personas are created using the `main` `DeviceFactorSource`.
     *
     * We can only ever have one.
     * We might have zero `main` flags across all  `DeviceFactorSource`s if and only if we have only one  `DeviceFactorSource`s. If we have two or more  `DeviceFactorSource`s one of them MUST
     * be marked with `main`.
     */
    case main
    /**
     * Until we have implemented "proper" deletion, we will "flag" a
     * FactorSource as deleted by the user and hide it, meaning e.g.
     * that in Multi-Factor Setup flows it will not show up.
     */
    case deletedByUser
}

public struct FfiConverterTypeFactorSourceFlag: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceFlag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceFlag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .main

        case 2: return .deletedByUser

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceFlag, into buf: inout [UInt8]) {
        switch value {
        case .main:
            writeInt(&buf, Int32(1))

        case .deletedByUser:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeFactorSourceFlag_lift(_ buf: RustBuffer) throws -> FactorSourceFlag {
    return try FfiConverterTypeFactorSourceFlag.lift(buf)
}

public func FfiConverterTypeFactorSourceFlag_lower(_ value: FactorSourceFlag) -> RustBuffer {
    return FfiConverterTypeFactorSourceFlag.lower(value)
}

extension FactorSourceFlag: Sendable {}
extension FactorSourceFlag: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A unique and stable identifier of a FactorSource, e.g. a
 * DeviceFactorSource being a mnemonic securely stored in a
 * device (phone), where the ID of it is the hash of a special
 * key derived near the root of it.
 */

public enum FactorSourceId {
    /**
     * FactorSourceID from the blake2b hash of the special HD public key derived at `CAP26::GetID`,
     * for a certain `FactorSourceKind`
     */
    case hash(value: FactorSourceIdFromHash
    )
    /**
     * FactorSourceID from an AccountAddress, typically used by `trustedContact` FactorSource.
     */
    case address(value: FactorSourceIdFromAddress
    )
}

public struct FfiConverterTypeFactorSourceID: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .hash(value: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )

        case 2: return try .address(value: FfiConverterTypeFactorSourceIDFromAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceId, into buf: inout [UInt8]) {
        switch value {
        case let .hash(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFactorSourceIDFromHash.write(value, into: &buf)

        case let .address(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFactorSourceIDFromAddress.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorSourceID_lift(_ buf: RustBuffer) throws -> FactorSourceId {
    return try FfiConverterTypeFactorSourceID.lift(buf)
}

public func FfiConverterTypeFactorSourceID_lower(_ value: FactorSourceId) -> RustBuffer {
    return FfiConverterTypeFactorSourceID.lower(value)
}

extension FactorSourceId: Sendable {}
extension FactorSourceId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The **kind** (or "type") of FactorSource describes how it is used.
 */

public enum FactorSourceKind {
    /**
     * A user owned unencrypted mnemonic (and optional BIP39 passphrase) stored on device,
     * thus directly usable. This kind is used as the standard factor source for all new
     * wallet users.
     *
     * Attributes:
     * * Mine
     * * On device
     * * Hierarchical deterministic (Mnemonic)
     * * Entity creating
     */
    case device
    /**
     * A user owned hardware wallet by vendor Ledger HQ, most commonly
     * a Ledger Nano S or Ledger Nano X. Less common models are Ledger Nano S Plus
     * Ledger Stax.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hardware (requires Browser Connector Extension to communicate with wallet)
     * * Hierarchical deterministic
     * * Entity creating (accounts only)
     */
    case ledgerHqHardwareWallet
    /**
     * A user owned mnemonic (and optional BIP39 passphrase) user has to input when used,
     * e.g. during signing.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic  (Mnemonic)
     */
    case offDeviceMnemonic
    /**
     * A contact, friend, company, organization or otherwise third party the user trusts enough
     * to be given a recovery token user has minted and sent the this contact.
     *
     * Attributes:
     * * **Not** mine
     * * Off device
     */
    case trustedContact
    /**
     * An encrypted user owned mnemonic (*never* any BIP39 passphrase) which can
     * be decrypted by answers to **security question**, which are personal questions
     * that should be only known to the user.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic  (**Encrypted** mnemonic)
     */
    case securityQuestions
}

public struct FfiConverterTypeFactorSourceKind: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .device

        case 2: return .ledgerHqHardwareWallet

        case 3: return .offDeviceMnemonic

        case 4: return .trustedContact

        case 5: return .securityQuestions

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceKind, into buf: inout [UInt8]) {
        switch value {
        case .device:
            writeInt(&buf, Int32(1))

        case .ledgerHqHardwareWallet:
            writeInt(&buf, Int32(2))

        case .offDeviceMnemonic:
            writeInt(&buf, Int32(3))

        case .trustedContact:
            writeInt(&buf, Int32(4))

        case .securityQuestions:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeFactorSourceKind_lift(_ buf: RustBuffer) throws -> FactorSourceKind {
    return try FfiConverterTypeFactorSourceKind.lift(buf)
}

public func FfiConverterTypeFactorSourceKind_lower(_ value: FactorSourceKind) -> RustBuffer {
    return FfiConverterTypeFactorSourceKind.lower(value)
}

extension FactorSourceKind: Sendable {}
extension FactorSourceKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Fiat currency to measure and display the value of some XRD or other Radix assets value/worth in.
 */

public enum FiatCurrency {
    /**
     * American dollars.
     */
    case usd
    /**
     * Swedish krona.
     */
    case sek
}

public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = FiatCurrency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .usd

        case 2: return .sek

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        switch value {
        case .usd:
            writeInt(&buf, Int32(1))

        case .sek:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(buf)
}

public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
    return FfiConverterTypeFiatCurrency.lower(value)
}

extension FiatCurrency: Sendable {}
extension FiatCurrency: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FungibleResourceIndicator {
    case guaranteed(decimal: Decimal192
    )
    case predicted(predictedDecimal: PredictedDecimal
    )
}

public struct FfiConverterTypeFungibleResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = FungibleResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .guaranteed(decimal: FfiConverterTypeDecimal192.read(from: &buf)
            )

        case 2: return try .predicted(predictedDecimal: FfiConverterTypePredictedDecimal.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FungibleResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        case let .guaranteed(decimal):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal192.write(decimal, into: &buf)

        case let .predicted(predictedDecimal):
            writeInt(&buf, Int32(2))
            FfiConverterTypePredictedDecimal.write(predictedDecimal, into: &buf)
        }
    }
}

public func FfiConverterTypeFungibleResourceIndicator_lift(_ buf: RustBuffer) throws -> FungibleResourceIndicator {
    return try FfiConverterTypeFungibleResourceIndicator.lift(buf)
}

public func FfiConverterTypeFungibleResourceIndicator_lower(_ value: FungibleResourceIndicator) -> RustBuffer {
    return FfiConverterTypeFungibleResourceIndicator.lower(value)
}

extension FungibleResourceIndicator: Sendable {}
extension FungibleResourceIndicator: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FungibleResourcesCollectionItem {
    case global(FungibleResourcesCollectionItemGloballyAggregated
    )
}

public struct FfiConverterTypeFungibleResourcesCollectionItem: FfiConverterRustBuffer {
    typealias SwiftType = FungibleResourcesCollectionItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourcesCollectionItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .global(FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FungibleResourcesCollectionItem, into buf: inout [UInt8]) {
        switch value {
        case let .global(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeFungibleResourcesCollectionItem_lift(_ buf: RustBuffer) throws -> FungibleResourcesCollectionItem {
    return try FfiConverterTypeFungibleResourcesCollectionItem.lift(buf)
}

public func FfiConverterTypeFungibleResourcesCollectionItem_lower(_ value: FungibleResourcesCollectionItem) -> RustBuffer {
    return FfiConverterTypeFungibleResourcesCollectionItem.lower(value)
}

extension FungibleResourcesCollectionItem: Sendable {}
extension FungibleResourcesCollectionItem: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GwPublicKey {
    case secp256k1(Secp256k1PublicKey
    )
    case ed25519(Ed25519PublicKey
    )
}

public struct FfiConverterTypeGWPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = GwPublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GwPublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
            )

        case 2: return try .ed25519(FfiConverterTypeEd25519PublicKey.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GwPublicKey, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecp256k1PublicKey.write(v1, into: &buf)

        case let .ed25519(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEd25519PublicKey.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeGWPublicKey_lift(_ buf: RustBuffer) throws -> GwPublicKey {
    return try FfiConverterTypeGWPublicKey.lift(buf)
}

public func FfiConverterTypeGWPublicKey_lower(_ value: GwPublicKey) -> RustBuffer {
    return FfiConverterTypeGWPublicKey.lower(value)
}

extension GwPublicKey: Sendable {}
extension GwPublicKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The model of a Ledger HQ hardware wallet NanoS, e.g.
 * *Ledger Nano S+*.
 */

public enum LedgerHardwareWalletModel {
    case nanoS
    case nanoSPlus
    case nanoX
}

public struct FfiConverterTypeLedgerHardwareWalletModel: FfiConverterRustBuffer {
    typealias SwiftType = LedgerHardwareWalletModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletModel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .nanoS

        case 2: return .nanoSPlus

        case 3: return .nanoX

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LedgerHardwareWalletModel, into buf: inout [UInt8]) {
        switch value {
        case .nanoS:
            writeInt(&buf, Int32(1))

        case .nanoSPlus:
            writeInt(&buf, Int32(2))

        case .nanoX:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeLedgerHardwareWalletModel_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletModel {
    return try FfiConverterTypeLedgerHardwareWalletModel.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletModel_lower(_ value: LedgerHardwareWalletModel) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletModel.lower(value)
}

extension LedgerHardwareWalletModel: Sendable {}
extension LedgerHardwareWalletModel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Message {
    case plainText(plaintext: PlaintextMessage
    )
    case none
}

public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .plainText(plaintext: FfiConverterTypePlaintextMessage.read(from: &buf)
            )

        case 2: return .none

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        switch value {
        case let .plainText(plaintext):
            writeInt(&buf, Int32(1))
            FfiConverterTypePlaintextMessage.write(plaintext, into: &buf)

        case .none:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}

extension Message: Sendable {}
extension Message: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * We explicitly mark content as either String or Bytes - this distinguishes (along with the mime type)
 * whether the message is intended to be displayable as text, or not.
 *
 * This data model ensures that messages intended to be displayable as text are valid unicode strings.
 */

public enum MessageContents {
    case stringMessage(string: String
    )
    case binaryMessage(bagOfBytes: BagOfBytes
    )
}

public struct FfiConverterTypeMessageContents: FfiConverterRustBuffer {
    typealias SwiftType = MessageContents

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageContents {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .stringMessage(string: FfiConverterString.read(from: &buf)
            )

        case 2: return try .binaryMessage(bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageContents, into buf: inout [UInt8]) {
        switch value {
        case let .stringMessage(string):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(string, into: &buf)

        case let .binaryMessage(bagOfBytes):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBagOfBytes.write(bagOfBytes, into: &buf)
        }
    }
}

public func FfiConverterTypeMessageContents_lift(_ buf: RustBuffer) throws -> MessageContents {
    return try FfiConverterTypeMessageContents.lift(buf)
}

public func FfiConverterTypeMessageContents_lower(_ value: MessageContents) -> RustBuffer {
    return FfiConverterTypeMessageContents.lower(value)
}

extension MessageContents: Sendable {}
extension MessageContents: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Million, Billion or Trillion, helper for Decimal192 formatting.
 */

public enum Multiplier: UInt8 {
    case million = 6
    case billion = 9
    case trillion = 12
}

public struct FfiConverterTypeMultiplier: FfiConverterRustBuffer {
    typealias SwiftType = Multiplier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Multiplier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .million

        case 2: return .billion

        case 3: return .trillion

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Multiplier, into buf: inout [UInt8]) {
        switch value {
        case .million:
            writeInt(&buf, Int32(1))

        case .billion:
            writeInt(&buf, Int32(2))

        case .trillion:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeMultiplier_lift(_ buf: RustBuffer) throws -> Multiplier {
    return try FfiConverterTypeMultiplier.lift(buf)
}

public func FfiConverterTypeMultiplier_lower(_ value: Multiplier) -> RustBuffer {
    return FfiConverterTypeMultiplier.lower(value)
}

extension Multiplier: Sendable {}
extension Multiplier: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NetworkId: UInt8 {
    /**
     * Mainnet (0x01 / 0d01)
     *
     * The Radix public network.
     *
     * https://github.com/radixdlt/radixdlt-scrypto/blob/v1.0.1/radix-engine-common/src/network/mod.rs#L79
     */
    case mainnet = 1
    /**
     * Stokenet (0x02 / 0d02)
     *
     * The public testnet for Radix.
     *
     * https://github.com/radixdlt/radixdlt-scrypto/blob/v1.0.1/radix-engine-common/src/network/mod.rs#L71
     */
    case stokenet = 2
    /**
     * Adapanet (0x0a / 0d10
     */
    case adapanet = 10
    /**
     * Nebunet (0x0b / 0d11 )
     *
     * The first Betanet of Babylon
     */
    case nebunet = 11
    /**
     * Kisharnet (0x0c / 0d12)
     *
     * The first release candidate of Babylon (RCnet v1)
     */
    case kisharnet = 12
    /**
     * Ansharnet (0x0d / 0d13)
     *
     * The second release candidate of Babylon (RCnet v2)
     */
    case ansharnet = 13
    /**
     * Zabanet (0x0e / 0d14)
     *
     * The third release candidate of Babylon (RCnet v3)
     */
    case zabanet = 14
    /**
     * Enkinet (0x21 / 0d33)
     *
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L94
     */
    case enkinet = 33
    /**
     * Hammunet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L95
     * Decimal value: 34
     */
    case hammunet = 34
    /**
     * Nergalnet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L96
     * Decimal value: 35
     */
    case nergalnet = 35
    /**
     * Mardunet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L97
     * Decimal value: 36
     */
    case mardunet = 36
    /**
     * Simulator (0xf2 / 0d242)
     */
    case simulator = 242
}

public struct FfiConverterTypeNetworkID: FfiConverterRustBuffer {
    typealias SwiftType = NetworkId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .mainnet

        case 2: return .stokenet

        case 3: return .adapanet

        case 4: return .nebunet

        case 5: return .kisharnet

        case 6: return .ansharnet

        case 7: return .zabanet

        case 8: return .enkinet

        case 9: return .hammunet

        case 10: return .nergalnet

        case 11: return .mardunet

        case 12: return .simulator

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NetworkId, into buf: inout [UInt8]) {
        switch value {
        case .mainnet:
            writeInt(&buf, Int32(1))

        case .stokenet:
            writeInt(&buf, Int32(2))

        case .adapanet:
            writeInt(&buf, Int32(3))

        case .nebunet:
            writeInt(&buf, Int32(4))

        case .kisharnet:
            writeInt(&buf, Int32(5))

        case .ansharnet:
            writeInt(&buf, Int32(6))

        case .zabanet:
            writeInt(&buf, Int32(7))

        case .enkinet:
            writeInt(&buf, Int32(8))

        case .hammunet:
            writeInt(&buf, Int32(9))

        case .nergalnet:
            writeInt(&buf, Int32(10))

        case .mardunet:
            writeInt(&buf, Int32(11))

        case .simulator:
            writeInt(&buf, Int32(12))
        }
    }
}

public func FfiConverterTypeNetworkID_lift(_ buf: RustBuffer) throws -> NetworkId {
    return try FfiConverterTypeNetworkID.lift(buf)
}

public func FfiConverterTypeNetworkID_lower(_ value: NetworkId) -> RustBuffer {
    return FfiConverterTypeNetworkID.lower(value)
}

extension NetworkId: Sendable {}
extension NetworkId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NetworkMethod {
    case post
    case get
}

public struct FfiConverterTypeNetworkMethod: FfiConverterRustBuffer {
    typealias SwiftType = NetworkMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .post

        case 2: return .get

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NetworkMethod, into buf: inout [UInt8]) {
        switch value {
        case .post:
            writeInt(&buf, Int32(1))

        case .get:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeNetworkMethod_lift(_ buf: RustBuffer) throws -> NetworkMethod {
    return try FfiConverterTypeNetworkMethod.lift(buf)
}

public func FfiConverterTypeNetworkMethod_lower(_ value: NetworkMethod) -> RustBuffer {
    return FfiConverterTypeNetworkMethod.lower(value)
}

extension NetworkMethod: Sendable {}
extension NetworkMethod: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NonFungibleLocalId {
    /**
     * Unsigned integers, up to u64.
     *
     * Create using `NonFungibleLocalId::integer(...)`.
     */
    case integer(value: UInt64
    )
    /**
     * String matching `[_0-9a-zA-Z]{1,64}`.
     *
     * Create using `NonFungibleLocalId::string(...).unwrap()`.
     */
    case str(value: NonFungibleLocalIdString
    )
    /**
     * Bytes, of length between 1 and 64.
     *
     * Create using `NonFungibleLocalId::bytes(...).unwrap()`.
     */
    case bytes(value: NonEmptyMax64Bytes
    )
    /**
     * RUID, v4, variant 1, big endian. See https://www.rfc-editor.org/rfc/rfc4122
     *
     * Create using `NonFungibleLocalId::ruid(...).unwrap()`.
     */
    case ruid(value: Exactly32Bytes
    )
}

public struct FfiConverterTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleLocalId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .integer(value: FfiConverterUInt64.read(from: &buf)
            )

        case 2: return try .str(value: FfiConverterTypeNonFungibleLocalIdString.read(from: &buf)
            )

        case 3: return try .bytes(value: FfiConverterTypeNonEmptyMax64Bytes.read(from: &buf)
            )

        case 4: return try .ruid(value: FfiConverterTypeExactly32Bytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleLocalId, into buf: inout [UInt8]) {
        switch value {
        case let .integer(value):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(value, into: &buf)

        case let .str(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNonFungibleLocalIdString.write(value, into: &buf)

        case let .bytes(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNonEmptyMax64Bytes.write(value, into: &buf)

        case let .ruid(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeExactly32Bytes.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeNonFungibleLocalId_lift(_ buf: RustBuffer) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalId_lower(_ value: NonFungibleLocalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalId.lower(value)
}

extension NonFungibleLocalId: Sendable {}
extension NonFungibleLocalId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NonFungibleResourceIndicator {
    case byAll(predictedAmount: PredictedDecimal, predictedIds: PredictedNonFungibleLocalIds)
    case byAmount(amount: Decimal192, predictedIds: PredictedNonFungibleLocalIds)
    case byIds(ids: [NonFungibleLocalId]
    )
}

public struct FfiConverterTypeNonFungibleResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .byAll(predictedAmount: FfiConverterTypePredictedDecimal.read(from: &buf), predictedIds: FfiConverterTypePredictedNonFungibleLocalIds.read(from: &buf))

        case 2: return try .byAmount(amount: FfiConverterTypeDecimal192.read(from: &buf), predictedIds: FfiConverterTypePredictedNonFungibleLocalIds.read(from: &buf))

        case 3: return try .byIds(ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        case let .byAll(predictedAmount, predictedIds):
            writeInt(&buf, Int32(1))
            FfiConverterTypePredictedDecimal.write(predictedAmount, into: &buf)
            FfiConverterTypePredictedNonFungibleLocalIds.write(predictedIds, into: &buf)

        case let .byAmount(amount, predictedIds):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDecimal192.write(amount, into: &buf)
            FfiConverterTypePredictedNonFungibleLocalIds.write(predictedIds, into: &buf)

        case let .byIds(ids):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
        }
    }
}

public func FfiConverterTypeNonFungibleResourceIndicator_lift(_ buf: RustBuffer) throws -> NonFungibleResourceIndicator {
    return try FfiConverterTypeNonFungibleResourceIndicator.lift(buf)
}

public func FfiConverterTypeNonFungibleResourceIndicator_lower(_ value: NonFungibleResourceIndicator) -> RustBuffer {
    return FfiConverterTypeNonFungibleResourceIndicator.lower(value)
}

extension NonFungibleResourceIndicator: Sendable {}
extension NonFungibleResourceIndicator: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PersonaDataNameVariant {
    case western
    case eastern
}

public struct FfiConverterTypePersonaDataNameVariant: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataNameVariant

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataNameVariant {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .western

        case 2: return .eastern

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PersonaDataNameVariant, into buf: inout [UInt8]) {
        switch value {
        case .western:
            writeInt(&buf, Int32(1))

        case .eastern:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypePersonaDataNameVariant_lift(_ buf: RustBuffer) throws -> PersonaDataNameVariant {
    return try FfiConverterTypePersonaDataNameVariant.lift(buf)
}

public func FfiConverterTypePersonaDataNameVariant_lower(_ value: PersonaDataNameVariant) -> RustBuffer {
    return FfiConverterTypePersonaDataNameVariant.lower(value)
}

extension PersonaDataNameVariant: Sendable {}
extension PersonaDataNameVariant: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The kind of the Pool, either One, Two or Multi resources.
 */

public enum PoolKind {
    /**
     * A Pool to which user can contribute liquidity of a single
     * resource kind.
     */
    case oneResource
    /**
     * A Pool to which user can contribute liquidity of two different
     * resources
     */
    case twoResources
    /**
     * A Pool to which user can contribute liquidity of many different
     * resources
     */
    case multiResources
}

public struct FfiConverterTypePoolKind: FfiConverterRustBuffer {
    typealias SwiftType = PoolKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PoolKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .oneResource

        case 2: return .twoResources

        case 3: return .multiResources

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PoolKind, into buf: inout [UInt8]) {
        switch value {
        case .oneResource:
            writeInt(&buf, Int32(1))

        case .twoResources:
            writeInt(&buf, Int32(2))

        case .multiResources:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypePoolKind_lift(_ buf: RustBuffer) throws -> PoolKind {
    return try FfiConverterTypePoolKind.lift(buf)
}

public func FfiConverterTypePoolKind_lower(_ value: PoolKind) -> RustBuffer {
    return FfiConverterTypePoolKind.lower(value)
}

extension PoolKind: Sendable {}
extension PoolKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of analyzing a file (bytes), containing either a Profile
 * which we were able to successfully JSON deserialize from the bytes,
 * or EncryptedProfile for which wallets will continue prompting the
 * user for an encryption password and then call JSON deserialize
 * of `EncryptedProfileSnapshot` using [`Profile::new_from_encryption_bytes`](Profile::new_from_encryption_bytes)
 * or if we failed to parse as Profile and `EncryptedProfileSnapshot`
 * then `NotProfile` is used, indicating that the bytes is not at all
 * a Profile.
 */

public enum ProfileFileContents {
    /**
     * The JSON deserialized Profile from some bytes.
     */
    case plaintextProfile(Profile
    )
    /**
     * We successfully JSON deserialized the bytes into
     * `EncryptedProfileSnapshot`, the wallets should proceed
     * with asking the user for the decryption password.
     */
    case encryptedProfile
    /**
     * The bytes is neither a valid `Profile` nor `EncryptedProfile`,
     * it is either a corrupt file or it is not at all a Profile file,
     * contrary to the users beliefs (or the user accidentally selected
     * a random file...)
     */
    case notProfile
}

public struct FfiConverterTypeProfileFileContents: FfiConverterRustBuffer {
    typealias SwiftType = ProfileFileContents

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileFileContents {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .plaintextProfile(FfiConverterTypeProfile.read(from: &buf)
            )

        case 2: return .encryptedProfile

        case 3: return .notProfile

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileFileContents, into buf: inout [UInt8]) {
        switch value {
        case let .plaintextProfile(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeProfile.write(v1, into: &buf)

        case .encryptedProfile:
            writeInt(&buf, Int32(2))

        case .notProfile:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeProfileFileContents_lift(_ buf: RustBuffer) throws -> ProfileFileContents {
    return try FfiConverterTypeProfileFileContents.lift(buf)
}

public func FfiConverterTypeProfileFileContents_lower(_ value: ProfileFileContents) -> RustBuffer {
    return FfiConverterTypeProfileFileContents.lower(value)
}

extension ProfileFileContents: Sendable {}
extension ProfileFileContents: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The version of the Profile Snapshot data format (JSON).
 */

public enum ProfileSnapshotVersion: UInt16 {
    /**
     * The version we went live with on Babylon mainnet 2023-09-28,
     * shipped with iOS 1.0.0 (7) and Android v 1.0.0.
     */
    case v100 = 100
}

public struct FfiConverterTypeProfileSnapshotVersion: FfiConverterRustBuffer {
    typealias SwiftType = ProfileSnapshotVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileSnapshotVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .v100

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileSnapshotVersion, into buf: inout [UInt8]) {
        switch value {
        case .v100:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeProfileSnapshotVersion_lift(_ buf: RustBuffer) throws -> ProfileSnapshotVersion {
    return try FfiConverterTypeProfileSnapshotVersion.lift(buf)
}

public func FfiConverterTypeProfileSnapshotVersion_lower(_ value: ProfileSnapshotVersion) -> RustBuffer {
    return FfiConverterTypeProfileSnapshotVersion.lower(value)
}

extension ProfileSnapshotVersion: Sendable {}
extension ProfileSnapshotVersion: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of supported public keys on different curves, supported
 * curves are `secp256k1` and `Curve25519`
 */

public enum PublicKey {
    /**
     * An Ed25519 public key used to verify cryptographic signatures.
     */
    case ed25519(Ed25519PublicKey
    )
    /**
     * A secp256k1 public key used to verify cryptographic signatures (ECDSA signatures).
     */
    case secp256k1(Secp256k1PublicKey
    )
}

public struct FfiConverterTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .ed25519(FfiConverterTypeEd25519PublicKey.read(from: &buf)
            )

        case 2: return try .secp256k1(FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        switch value {
        case let .ed25519(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEd25519PublicKey.write(v1, into: &buf)

        case let .secp256k1(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecp256k1PublicKey.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypePublicKey_lift(_ buf: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(buf)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}

extension PublicKey: Sendable {}
extension PublicKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Hashes of public keys, either Ed25519PublicKey or Secp256k1PublicKey
 */

public enum PublicKeyHash {
    case ed25519(value: Exactly29Bytes
    )
    case secp256k1(value: Exactly29Bytes
    )
}

public struct FfiConverterTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = PublicKeyHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKeyHash {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .ed25519(value: FfiConverterTypeExactly29Bytes.read(from: &buf)
            )

        case 2: return try .secp256k1(value: FfiConverterTypeExactly29Bytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKeyHash, into buf: inout [UInt8]) {
        switch value {
        case let .ed25519(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeExactly29Bytes.write(value, into: &buf)

        case let .secp256k1(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeExactly29Bytes.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypePublicKeyHash_lift(_ buf: RustBuffer) throws -> PublicKeyHash {
    return try FfiConverterTypePublicKeyHash.lift(buf)
}

public func FfiConverterTypePublicKeyHash_lower(_ value: PublicKeyHash) -> RustBuffer {
    return FfiConverterTypePublicKeyHash.lower(value)
}

extension PublicKeyHash: Sendable {}
extension PublicKeyHash: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RadixConnectMobileConnectRequest {
    case link(RadixConnectMobileLinkRequest
    )
    case dappInteraction(RadixConnectMobileDappRequest
    )
}

public struct FfiConverterTypeRadixConnectMobileConnectRequest: FfiConverterRustBuffer {
    typealias SwiftType = RadixConnectMobileConnectRequest

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileConnectRequest {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .link(FfiConverterTypeRadixConnectMobileLinkRequest.read(from: &buf)
            )

        case 2: return try .dappInteraction(FfiConverterTypeRadixConnectMobileDappRequest.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RadixConnectMobileConnectRequest, into buf: inout [UInt8]) {
        switch value {
        case let .link(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRadixConnectMobileLinkRequest.write(v1, into: &buf)

        case let .dappInteraction(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeRadixConnectMobileDappRequest.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeRadixConnectMobileConnectRequest_lift(_ buf: RustBuffer) throws -> RadixConnectMobileConnectRequest {
    return try FfiConverterTypeRadixConnectMobileConnectRequest.lift(buf)
}

public func FfiConverterTypeRadixConnectMobileConnectRequest_lower(_ value: RadixConnectMobileConnectRequest) -> RustBuffer {
    return FfiConverterTypeRadixConnectMobileConnectRequest.lower(value)
}

extension RadixConnectMobileConnectRequest: Sendable {}
extension RadixConnectMobileConnectRequest: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
 * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
 * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
 */

public enum RadixConnectPurpose {
    case general
    case unknown
}

public struct FfiConverterTypeRadixConnectPurpose: FfiConverterRustBuffer {
    typealias SwiftType = RadixConnectPurpose

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectPurpose {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .general

        case 2: return .unknown

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RadixConnectPurpose, into buf: inout [UInt8]) {
        switch value {
        case .general:
            writeInt(&buf, Int32(1))

        case .unknown:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeRadixConnectPurpose_lift(_ buf: RustBuffer) throws -> RadixConnectPurpose {
    return try FfiConverterTypeRadixConnectPurpose.lift(buf)
}

public func FfiConverterTypeRadixConnectPurpose_lower(_ value: RadixConnectPurpose) -> RustBuffer {
    return FfiConverterTypeRadixConnectPurpose.lower(value)
}

extension RadixConnectPurpose: Sendable {}
extension RadixConnectPurpose: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A quantifier of a quantity, either `atLeast` or `exactly`, as in
 * "I want AT LEAST 3" or "I want EXACTLY 10".
 *
 * This is typically sent by a Dapp when requesting access to accounts
 * or PersonaData.
 */

public enum RequestedNumberQuantifier {
    /**
     * (Request access to) *exactly* N many of something, where quantity `N` is
     * not part of this enum, e.g. "I want EXACTLY 2 accounts"
     */
    case exactly
    /**
     * (Request access to) *at least* N many of something, where quantity `N` is
     * not part of this enum, e.g. "I want AT LEAST 3 accounts"
     */
    case atLeast
}

public struct FfiConverterTypeRequestedNumberQuantifier: FfiConverterRustBuffer {
    typealias SwiftType = RequestedNumberQuantifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedNumberQuantifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .exactly

        case 2: return .atLeast

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestedNumberQuantifier, into buf: inout [UInt8]) {
        switch value {
        case .exactly:
            writeInt(&buf, Int32(1))

        case .atLeast:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeRequestedNumberQuantifier_lift(_ buf: RustBuffer) throws -> RequestedNumberQuantifier {
    return try FfiConverterTypeRequestedNumberQuantifier.lift(buf)
}

public func FfiConverterTypeRequestedNumberQuantifier_lower(_ value: RequestedNumberQuantifier) -> RustBuffer {
    return FfiConverterTypeRequestedNumberQuantifier.lower(value)
}

extension RequestedNumberQuantifier: Sendable {}
extension RequestedNumberQuantifier: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The set of instructions that is only allowed in manifests created by the
 * wallet itself.
 */

public enum ReservedInstruction {
    case accountLockFee
    case accountSecurify
    case identitySecurify
    case accessControllerMethod
    case accountUpdateSettings
}

public struct FfiConverterTypeReservedInstruction: FfiConverterRustBuffer {
    typealias SwiftType = ReservedInstruction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReservedInstruction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .accountLockFee

        case 2: return .accountSecurify

        case 3: return .identitySecurify

        case 4: return .accessControllerMethod

        case 5: return .accountUpdateSettings

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReservedInstruction, into buf: inout [UInt8]) {
        switch value {
        case .accountLockFee:
            writeInt(&buf, Int32(1))

        case .accountSecurify:
            writeInt(&buf, Int32(2))

        case .identitySecurify:
            writeInt(&buf, Int32(3))

        case .accessControllerMethod:
            writeInt(&buf, Int32(4))

        case .accountUpdateSettings:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeReservedInstruction_lift(_ buf: RustBuffer) throws -> ReservedInstruction {
    return try FfiConverterTypeReservedInstruction.lift(buf)
}

public func FfiConverterTypeReservedInstruction_lower(_ value: ReservedInstruction) -> RustBuffer {
    return FfiConverterTypeReservedInstruction.lower(value)
}

extension ReservedInstruction: Sendable {}
extension ReservedInstruction: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourceIndicator {
    case fungible(resourceAddress: ResourceAddress, indicator: FungibleResourceIndicator)
    case nonFungible(resourceAddress: ResourceAddress, indicator: NonFungibleResourceIndicator)
}

public struct FfiConverterTypeResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = ResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .fungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), indicator: FfiConverterTypeFungibleResourceIndicator.read(from: &buf))

        case 2: return try .nonFungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), indicator: FfiConverterTypeNonFungibleResourceIndicator.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        case let .fungible(resourceAddress, indicator):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeFungibleResourceIndicator.write(indicator, into: &buf)

        case let .nonFungible(resourceAddress, indicator):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeNonFungibleResourceIndicator.write(indicator, into: &buf)
        }
    }
}

public func FfiConverterTypeResourceIndicator_lift(_ buf: RustBuffer) throws -> ResourceIndicator {
    return try FfiConverterTypeResourceIndicator.lift(buf)
}

public func FfiConverterTypeResourceIndicator_lower(_ value: ResourceIndicator) -> RustBuffer {
    return FfiConverterTypeResourceIndicator.lower(value)
}

extension ResourceIndicator: Sendable {}
extension ResourceIndicator: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The addresses that can be added as exception to the `DepositRule`
 */

public enum ResourceOrNonFungible {
    case resource(value: ResourceAddress
    )
    case nonFungible(value: NonFungibleGlobalId
    )
}

public struct FfiConverterTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = ResourceOrNonFungible

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceOrNonFungible {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .resource(value: FfiConverterTypeResourceAddress.read(from: &buf)
            )

        case 2: return try .nonFungible(value: FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceOrNonFungible, into buf: inout [UInt8]) {
        switch value {
        case let .resource(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(value, into: &buf)

        case let .nonFungible(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNonFungibleGlobalId.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeResourceOrNonFungible_lift(_ buf: RustBuffer) throws -> ResourceOrNonFungible {
    return try FfiConverterTypeResourceOrNonFungible.lift(buf)
}

public func FfiConverterTypeResourceOrNonFungible_lower(_ value: ResourceOrNonFungible) -> RustBuffer {
    return FfiConverterTypeResourceOrNonFungible.lower(value)
}

extension ResourceOrNonFungible: Sendable {}
extension ResourceOrNonFungible: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourcePreference {
    case allowed
    case disallowed
}

public struct FfiConverterTypeResourcePreference: FfiConverterRustBuffer {
    typealias SwiftType = ResourcePreference

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreference {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .allowed

        case 2: return .disallowed

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourcePreference, into buf: inout [UInt8]) {
        switch value {
        case .allowed:
            writeInt(&buf, Int32(1))

        case .disallowed:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeResourcePreference_lift(_ buf: RustBuffer) throws -> ResourcePreference {
    return try FfiConverterTypeResourcePreference.lift(buf)
}

public func FfiConverterTypeResourcePreference_lower(_ value: ResourcePreference) -> RustBuffer {
    return FfiConverterTypeResourcePreference.lower(value)
}

extension ResourcePreference: Sendable {}
extension ResourcePreference: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourcePreferenceUpdate {
    case set(value: ResourcePreference
    )
    case remove
}

public struct FfiConverterTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    typealias SwiftType = ResourcePreferenceUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreferenceUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .set(value: FfiConverterTypeResourcePreference.read(from: &buf)
            )

        case 2: return .remove

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourcePreferenceUpdate, into buf: inout [UInt8]) {
        switch value {
        case let .set(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourcePreference.write(value, into: &buf)

        case .remove:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeResourcePreferenceUpdate_lift(_ buf: RustBuffer) throws -> ResourcePreferenceUpdate {
    return try FfiConverterTypeResourcePreferenceUpdate.lift(buf)
}

public func FfiConverterTypeResourcePreferenceUpdate_lower(_ value: ResourcePreferenceUpdate) -> RustBuffer {
    return FfiConverterTypeResourcePreferenceUpdate.lower(value)
}

extension ResourcePreferenceUpdate: Sendable {}
extension ResourcePreferenceUpdate: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Defines the rounding strategy used when you round e.g. `Decimal192`.
 *
 * Following the same naming convention as https://docs.rs/rust_decimal/latest/rust_decimal/enum.RoundingStrategy.html.
 */

public enum RoundingMode {
    /**
     * The number is always rounded toward positive infinity, e.g. `3.1 -> 4`, `-3.1 -> -3`.
     */
    case toPositiveInfinity
    /**
     * The number is always rounded toward negative infinity, e.g. `3.1 -> 3`, `-3.1 -> -4`.
     */
    case toNegativeInfinity
    /**
     * The number is always rounded toward zero, e.g. `3.1 -> 3`, `-3.1 -> -3`.
     */
    case toZero
    /**
     * The number is always rounded away from zero, e.g. `3.1 -> 4`, `-3.1 -> -4`.
     */
    case awayFromZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded toward zero, e.g. `3.5 -> 3`, `-3.5 -> -3`.
     */
    case toNearestMidpointTowardZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded away from zero, e.g. `3.5 -> 4`, `-3.5 -> -4`.
     */
    case toNearestMidpointAwayFromZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded toward the nearest even number. Also known as "Bankers Rounding".
     */
    case toNearestMidpointToEven
}

public struct FfiConverterTypeRoundingMode: FfiConverterRustBuffer {
    typealias SwiftType = RoundingMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoundingMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .toPositiveInfinity

        case 2: return .toNegativeInfinity

        case 3: return .toZero

        case 4: return .awayFromZero

        case 5: return .toNearestMidpointTowardZero

        case 6: return .toNearestMidpointAwayFromZero

        case 7: return .toNearestMidpointToEven

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoundingMode, into buf: inout [UInt8]) {
        switch value {
        case .toPositiveInfinity:
            writeInt(&buf, Int32(1))

        case .toNegativeInfinity:
            writeInt(&buf, Int32(2))

        case .toZero:
            writeInt(&buf, Int32(3))

        case .awayFromZero:
            writeInt(&buf, Int32(4))

        case .toNearestMidpointTowardZero:
            writeInt(&buf, Int32(5))

        case .toNearestMidpointAwayFromZero:
            writeInt(&buf, Int32(6))

        case .toNearestMidpointToEven:
            writeInt(&buf, Int32(7))
        }
    }
}

public func FfiConverterTypeRoundingMode_lift(_ buf: RustBuffer) throws -> RoundingMode {
    return try FfiConverterTypeRoundingMode.lift(buf)
}

public func FfiConverterTypeRoundingMode_lower(_ value: RoundingMode) -> RustBuffer {
    return FfiConverterTypeRoundingMode.lower(value)
}

extension RoundingMode: Sendable {}
extension RoundingMode: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Elliptic Curves which the SLIP10 derivation algorithm supports.
 *
 * We use SLIP10 for hierarchical deterministic derivation since we
 * prefer using Curve25519 - which is incompatible with BIP32 (BIP44).
 *
 * For for information see [SLIP10 reference](https://github.com/satoshilabs/slips/blob/master/slip-0010.md)
 */

public enum Slip10Curve {
    /**
     * Curve25519 which we use for Ed25519 for EdDSA signatures.
     */
    case curve25519
    /**
     * The bitcoin curve, used by Radix Olympia and still valid
     * to support legacy accounts.
     */
    case secp256k1
}

public struct FfiConverterTypeSLIP10Curve: FfiConverterRustBuffer {
    typealias SwiftType = Slip10Curve

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Slip10Curve {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .curve25519

        case 2: return .secp256k1

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Slip10Curve, into buf: inout [UInt8]) {
        switch value {
        case .curve25519:
            writeInt(&buf, Int32(1))

        case .secp256k1:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeSLIP10Curve_lift(_ buf: RustBuffer) throws -> Slip10Curve {
    return try FfiConverterTypeSLIP10Curve.lift(buf)
}

public func FfiConverterTypeSLIP10Curve_lower(_ value: Slip10Curve) -> RustBuffer {
    return FfiConverterTypeSLIP10Curve.lower(value)
}

extension Slip10Curve: Sendable {}
extension Slip10Curve: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SecureStorageKey {
    case snapshotHeadersList
    case activeProfileId
    case deviceFactorSourceMnemonic(factorSourceId: FactorSourceIdFromHash
    )
    case profileSnapshot(profileId: ProfileId
    )
}

public struct FfiConverterTypeSecureStorageKey: FfiConverterRustBuffer {
    typealias SwiftType = SecureStorageKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .snapshotHeadersList

        case 2: return .activeProfileId

        case 3: return try .deviceFactorSourceMnemonic(factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )

        case 4: return try .profileSnapshot(profileId: FfiConverterTypeProfileID.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecureStorageKey, into buf: inout [UInt8]) {
        switch value {
        case .snapshotHeadersList:
            writeInt(&buf, Int32(1))

        case .activeProfileId:
            writeInt(&buf, Int32(2))

        case let .deviceFactorSourceMnemonic(factorSourceId):
            writeInt(&buf, Int32(3))
            FfiConverterTypeFactorSourceIDFromHash.write(factorSourceId, into: &buf)

        case let .profileSnapshot(profileId):
            writeInt(&buf, Int32(4))
            FfiConverterTypeProfileID.write(profileId, into: &buf)
        }
    }
}

public func FfiConverterTypeSecureStorageKey_lift(_ buf: RustBuffer) throws -> SecureStorageKey {
    return try FfiConverterTypeSecureStorageKey.lift(buf)
}

public func FfiConverterTypeSecureStorageKey_lower(_ value: SecureStorageKey) -> RustBuffer {
    return FfiConverterTypeSecureStorageKey.lower(value)
}

extension SecureStorageKey: Sendable {}
extension SecureStorageKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either a Signature on `Curve25519` or `Secp256k1`
 */

public enum Signature {
    case secp256k1(value: Secp256k1Signature
    )
    case ed25519(value: Ed25519Signature
    )
}

public struct FfiConverterTypeSignature: FfiConverterRustBuffer {
    typealias SwiftType = Signature

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Signature {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(value: FfiConverterTypeSecp256k1Signature.read(from: &buf)
            )

        case 2: return try .ed25519(value: FfiConverterTypeEd25519Signature.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Signature, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecp256k1Signature.write(value, into: &buf)

        case let .ed25519(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEd25519Signature.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeSignature_lift(_ buf: RustBuffer) throws -> Signature {
    return try FfiConverterTypeSignature.lift(buf)
}

public func FfiConverterTypeSignature_lower(_ value: Signature) -> RustBuffer {
    return FfiConverterTypeSignature.lower(value)
}

extension Signature: Sendable {}
extension Signature: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents any natively supported signature, including public key.
 */

public enum SignatureWithPublicKey {
    case secp256k1(publicKey: Secp256k1PublicKey, signature: Secp256k1Signature)
    case ed25519(publicKey: Ed25519PublicKey, signature: Ed25519Signature)
}

public struct FfiConverterTypeSignatureWithPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = SignatureWithPublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureWithPublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(publicKey: FfiConverterTypeSecp256k1PublicKey.read(from: &buf), signature: FfiConverterTypeSecp256k1Signature.read(from: &buf))

        case 2: return try .ed25519(publicKey: FfiConverterTypeEd25519PublicKey.read(from: &buf), signature: FfiConverterTypeEd25519Signature.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureWithPublicKey, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(publicKey, signature):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecp256k1PublicKey.write(publicKey, into: &buf)
            FfiConverterTypeSecp256k1Signature.write(signature, into: &buf)

        case let .ed25519(publicKey, signature):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEd25519PublicKey.write(publicKey, into: &buf)
            FfiConverterTypeEd25519Signature.write(signature, into: &buf)
        }
    }
}

public func FfiConverterTypeSignatureWithPublicKey_lift(_ buf: RustBuffer) throws -> SignatureWithPublicKey {
    return try FfiConverterTypeSignatureWithPublicKey.lift(buf)
}

public func FfiConverterTypeSignatureWithPublicKey_lower(_ value: SignatureWithPublicKey) -> RustBuffer {
    return FfiConverterTypeSignatureWithPublicKey.lower(value)
}

extension SignatureWithPublicKey: Sendable {}
extension SignatureWithPublicKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletClientModel {
    case iphone
    case android
    case unknown
}

public struct FfiConverterTypeWalletClientModel: FfiConverterRustBuffer {
    typealias SwiftType = WalletClientModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletClientModel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .iphone

        case 2: return .android

        case 3: return .unknown

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletClientModel, into buf: inout [UInt8]) {
        switch value {
        case .iphone:
            writeInt(&buf, Int32(1))

        case .android:
            writeInt(&buf, Int32(2))

        case .unknown:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeWalletClientModel_lift(_ buf: RustBuffer) throws -> WalletClientModel {
    return try FfiConverterTypeWalletClientModel.lift(buf)
}

public func FfiConverterTypeWalletClientModel_lower(_ value: WalletClientModel) -> RustBuffer {
    return FfiConverterTypeWalletClientModel.lower(value)
}

extension WalletClientModel: Sendable {}
extension WalletClientModel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionAuthRequestResponseItem {
    case usePersona(WalletToDappInteractionAuthUsePersonaRequestResponseItem
    )
    case loginWithoutChallenge(WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem
    )
    case loginWithChallenge(WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem
    )
}

public struct FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionAuthRequestResponseItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthRequestResponseItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .usePersona(FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.read(from: &buf)
            )

        case 2: return try .loginWithoutChallenge(FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.read(from: &buf)
            )

        case 3: return try .loginWithChallenge(FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionAuthRequestResponseItem, into buf: inout [UInt8]) {
        switch value {
        case let .usePersona(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.write(v1, into: &buf)

        case let .loginWithoutChallenge(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.write(v1, into: &buf)

        case let .loginWithChallenge(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem_lower(_ value: WalletToDappInteractionAuthRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.lower(value)
}

extension WalletToDappInteractionAuthRequestResponseItem: Sendable {}
extension WalletToDappInteractionAuthRequestResponseItem: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionResponse {
    case success(WalletToDappInteractionSuccessResponse
    )
    case failure(WalletToDappInteractionFailureResponse
    )
}

public struct FfiConverterTypeWalletToDappInteractionResponse: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionResponse

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionResponse {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .success(FfiConverterTypeWalletToDappInteractionSuccessResponse.read(from: &buf)
            )

        case 2: return try .failure(FfiConverterTypeWalletToDappInteractionFailureResponse.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionResponse, into buf: inout [UInt8]) {
        switch value {
        case let .success(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionSuccessResponse.write(v1, into: &buf)

        case let .failure(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionFailureResponse.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletToDappInteractionResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionResponse {
    return try FfiConverterTypeWalletToDappInteractionResponse.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionResponse_lower(_ value: WalletToDappInteractionResponse) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionResponse.lower(value)
}

extension WalletToDappInteractionResponse: Sendable {}
extension WalletToDappInteractionResponse: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionResponseItems {
    case authorizedRequest(WalletToDappInteractionAuthorizedRequestResponseItems
    )
    case unauthorizedRequest(WalletToDappInteractionUnauthorizedRequestResponseItems
    )
    case transaction(WalletToDappInteractionTransactionResponseItems
    )
}

public struct FfiConverterTypeWalletToDappInteractionResponseItems: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionResponseItems

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionResponseItems {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .authorizedRequest(FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.read(from: &buf)
            )

        case 2: return try .unauthorizedRequest(FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.read(from: &buf)
            )

        case 3: return try .transaction(FfiConverterTypeWalletToDappInteractionTransactionResponseItems.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionResponseItems, into buf: inout [UInt8]) {
        switch value {
        case let .authorizedRequest(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.write(v1, into: &buf)

        case let .unauthorizedRequest(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.write(v1, into: &buf)

        case let .transaction(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletToDappInteractionTransactionResponseItems.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletToDappInteractionResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionResponseItems {
    return try FfiConverterTypeWalletToDappInteractionResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionResponseItems_lower(_ value: WalletToDappInteractionResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionResponseItems.lower(value)
}

extension WalletToDappInteractionResponseItems: Sendable {}
extension WalletToDappInteractionResponseItems: Equatable, Hashable {}

private struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionAccountsRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionAccountsRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionPersonaDataRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDappToWalletInteractionResetRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionResetRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionResetRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionResetRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDecimal192: FfiConverterRustBuffer {
    typealias SwiftType = Decimal192?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDecimal192.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDecimal192.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDisplayName: FfiConverterRustBuffer {
    typealias SwiftType = DisplayName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDisplayName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDisplayName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeExactly32Bytes: FfiConverterRustBuffer {
    typealias SwiftType = Exactly32Bytes?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeExactly32Bytes.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeExactly32Bytes.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFungibleResourcesCollection: FfiConverterRustBuffer {
    typealias SwiftType = FungibleResourcesCollection?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFungibleResourcesCollection.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFungibleResourcesCollection.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
    typealias SwiftType = HierarchicalDeterministicFactorInstance?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePersonaDataEntryName: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataEntryName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataEntryName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataEntryName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePersonaDataIdentifiedName: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataIdentifiedName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataIdentifiedName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataIdentifiedName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeRequestedQuantity: FfiConverterRustBuffer {
    typealias SwiftType = RequestedQuantity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRequestedQuantity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRequestedQuantity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses: FfiConverterRustBuffer {
    typealias SwiftType = SharedToDappWithPersonaAccountAddresses?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSharedToDappWithPersonaAccountAddresses.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSharedToDappWithPersonaAccountAddresses.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries: FfiConverterRustBuffer {
    typealias SwiftType = SharedToDappWithPersonaIDsOfPersonaDataEntries?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionAccountsRequestResponseItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionPersonaDataRequestResponseItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeAccountForDisplay: FfiConverterRustBuffer {
    typealias SwiftType = [AccountForDisplay]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAccountForDisplay.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAccountForDisplay.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeAssetException: FfiConverterRustBuffer {
    typealias SwiftType = [AssetException]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAssetException.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAssetException.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypePersonaDataEntryEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryEmailAddress]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePersonaDataEntryEmailAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePersonaDataEntryEmailAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryPhoneNumber]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePersonaDataEntryPhoneNumber.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePersonaDataEntryPhoneNumber.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
    typealias SwiftType = [WalletToDappInteractionAccountProof]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeWalletToDappInteractionAccountProof.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeWalletToDappInteractionAccountProof.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceOrNonFungible]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeResourceOrNonFungible.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePersonaDataEntryID: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataEntryId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataEntryID.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataEntryID.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceInt8: FfiConverterRustBuffer {
    typealias SwiftType = [Int8]

    public static func write(_ value: [Int8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int8] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceBool: FfiConverterRustBuffer {
    typealias SwiftType = [Bool]

    public static func write(_ value: [Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterBool.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bool] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bool]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterBool.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccount: FfiConverterRustBuffer {
    typealias SwiftType = [Account]

    public static func write(_ value: [Account], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Account] {
        let len: Int32 = try readInt(&buf)
        var seq = [Account]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccount.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountAddress: FfiConverterRustBuffer {
    typealias SwiftType = [AccountAddress]

    public static func write(_ value: [AccountAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountForDisplay: FfiConverterRustBuffer {
    typealias SwiftType = [AccountForDisplay]

    public static func write(_ value: [AccountForDisplay], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountForDisplay.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountForDisplay] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountForDisplay]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountForDisplay.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAppearanceID: FfiConverterRustBuffer {
    typealias SwiftType = [AppearanceId]

    public static func write(_ value: [AppearanceId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAppearanceID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AppearanceId] {
        let len: Int32 = try readInt(&buf)
        var seq = [AppearanceId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAppearanceID.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAssetException: FfiConverterRustBuffer {
    typealias SwiftType = [AssetException]

    public static func write(_ value: [AssetException], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAssetException.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetException] {
        let len: Int32 = try readInt(&buf)
        var seq = [AssetException]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAssetException.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAuthorizedDapp: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedDapp]

    public static func write(_ value: [AuthorizedDapp], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedDapp.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedDapp] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedDapp]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAuthorizedDapp.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAuthorizedPersonaDetailed: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedPersonaDetailed]

    public static func write(_ value: [AuthorizedPersonaDetailed], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedPersonaDetailed.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedPersonaDetailed] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedPersonaDetailed]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAuthorizedPersonaDetailed.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAuthorizedPersonaSimple: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedPersonaSimple]

    public static func write(_ value: [AuthorizedPersonaSimple], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedPersonaSimple.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedPersonaSimple] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedPersonaSimple]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAuthorizedPersonaSimple.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeBIP39Word: FfiConverterRustBuffer {
    typealias SwiftType = [Bip39Word]

    public static func write(_ value: [Bip39Word], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBIP39Word.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip39Word] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bip39Word]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeBIP39Word.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeBlob: FfiConverterRustBuffer {
    typealias SwiftType = [Blob]

    public static func write(_ value: [Blob], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBlob.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Blob] {
        let len: Int32 = try readInt(&buf)
        var seq = [Blob]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeBlob.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeComponentAddress: FfiConverterRustBuffer {
    typealias SwiftType = [ComponentAddress]

    public static func write(_ value: [ComponentAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeComponentAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ComponentAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [ComponentAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeComponentAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeGateway: FfiConverterRustBuffer {
    typealias SwiftType = [Gateway]

    public static func write(_ value: [Gateway], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGateway.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Gateway] {
        let len: Int32 = try readInt(&buf)
        var seq = [Gateway]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeGateway.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHDPathComponent: FfiConverterRustBuffer {
    typealias SwiftType = [HdPathComponent]

    public static func write(_ value: [HdPathComponent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHDPathComponent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HdPathComponent] {
        let len: Int32 = try readInt(&buf)
        var seq = [HdPathComponent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeHDPathComponent.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHierarchicalDeterministicPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [HierarchicalDeterministicPublicKey]

    public static func write(_ value: [HierarchicalDeterministicPublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHierarchicalDeterministicPublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HierarchicalDeterministicPublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [HierarchicalDeterministicPublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeIdentityAddress: FfiConverterRustBuffer {
    typealias SwiftType = [IdentityAddress]

    public static func write(_ value: [IdentityAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIdentityAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IdentityAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [IdentityAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeIdentityAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeIntentSignature: FfiConverterRustBuffer {
    typealias SwiftType = [IntentSignature]

    public static func write(_ value: [IntentSignature], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIntentSignature.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IntentSignature] {
        let len: Int32 = try readInt(&buf)
        var seq = [IntentSignature]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeIntentSignature.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNonFungibleGlobalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleGlobalId]

    public static func write(_ value: [NonFungibleGlobalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleGlobalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleGlobalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNonFungibleGlobalId.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeP2PLink: FfiConverterRustBuffer {
    typealias SwiftType = [P2pLink]

    public static func write(_ value: [P2pLink], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeP2PLink.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [P2pLink] {
        let len: Int32 = try readInt(&buf)
        var seq = [P2pLink]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeP2PLink.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerAssetFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetFungibleTransfer]

    public static func write(_ value: [PerAssetFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerAssetFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerAssetNonFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetNonFungibleTransfer]

    public static func write(_ value: [PerAssetNonFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetNonFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetNonFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetNonFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerAssetNonFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerAssetTransfersOfFungibleResource: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetTransfersOfFungibleResource]

    public static func write(_ value: [PerAssetTransfersOfFungibleResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetTransfersOfFungibleResource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetTransfersOfFungibleResource] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetTransfersOfFungibleResource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerAssetTransfersOfFungibleResource.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetTransfersOfNonFungibleResource]

    public static func write(_ value: [PerAssetTransfersOfNonFungibleResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetTransfersOfNonFungibleResource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetTransfersOfNonFungibleResource] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetTransfersOfNonFungibleResource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerAssetTransfersOfNonFungibleResource.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerRecipientAssetTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerRecipientAssetTransfer]

    public static func write(_ value: [PerRecipientAssetTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerRecipientAssetTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientAssetTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerRecipientAssetTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerRecipientAssetTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerRecipientFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerRecipientFungibleTransfer]

    public static func write(_ value: [PerRecipientFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerRecipientFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerRecipientFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerRecipientFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerRecipientNonFungiblesTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerRecipientNonFungiblesTransfer]

    public static func write(_ value: [PerRecipientNonFungiblesTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerRecipientNonFungiblesTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientNonFungiblesTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerRecipientNonFungiblesTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerRecipientNonFungiblesTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersona: FfiConverterRustBuffer {
    typealias SwiftType = [Persona]

    public static func write(_ value: [Persona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Persona] {
        let len: Int32 = try readInt(&buf)
        var seq = [Persona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersona.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataEntryEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryEmailAddress]

    public static func write(_ value: [PersonaDataEntryEmailAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataEntryEmailAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataEntryEmailAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataEntryEmailAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataEntryEmailAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryPhoneNumber]

    public static func write(_ value: [PersonaDataEntryPhoneNumber], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataEntryPhoneNumber.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataEntryPhoneNumber] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataEntryPhoneNumber]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataEntryPhoneNumber.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataIdentifiedEmailAddress]

    public static func write(_ value: [PersonaDataIdentifiedEmailAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataIdentifiedEmailAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataIdentifiedEmailAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataIdentifiedEmailAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataIdentifiedEmailAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataIdentifiedPhoneNumber]

    public static func write(_ value: [PersonaDataIdentifiedPhoneNumber], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataIdentifiedPhoneNumber.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataIdentifiedPhoneNumber] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataIdentifiedPhoneNumber]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataIdentifiedPhoneNumber.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePoolAddress: FfiConverterRustBuffer {
    typealias SwiftType = [PoolAddress]

    public static func write(_ value: [PoolAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePoolAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PoolAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [PoolAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePoolAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeProfileNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [ProfileNetwork]

    public static func write(_ value: [ProfileNetwork], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProfileNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ProfileNetwork] {
        let len: Int32 = try readInt(&buf)
        var seq = [ProfileNetwork]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeProfileNetwork.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceAddress: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceAddress]

    public static func write(_ value: [ResourceAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeStakeClaim: FfiConverterRustBuffer {
    typealias SwiftType = [StakeClaim]

    public static func write(_ value: [StakeClaim], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStakeClaim.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [StakeClaim] {
        let len: Int32 = try readInt(&buf)
        var seq = [StakeClaim]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeStakeClaim.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeStateEntityDetailsResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = [StateEntityDetailsResponseItem]

    public static func write(_ value: [StateEntityDetailsResponseItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStateEntityDetailsResponseItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [StateEntityDetailsResponseItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [StateEntityDetailsResponseItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeStateEntityDetailsResponseItem.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTrackedPoolContribution: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedPoolContribution]

    public static func write(_ value: [TrackedPoolContribution], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedPoolContribution.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedPoolContribution] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedPoolContribution]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTrackedPoolContribution.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTrackedPoolRedemption: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedPoolRedemption]

    public static func write(_ value: [TrackedPoolRedemption], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedPoolRedemption.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedPoolRedemption] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedPoolRedemption]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTrackedPoolRedemption.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTrackedValidatorClaim: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedValidatorClaim]

    public static func write(_ value: [TrackedValidatorClaim], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedValidatorClaim.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorClaim] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedValidatorClaim]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTrackedValidatorClaim.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTrackedValidatorStake: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedValidatorStake]

    public static func write(_ value: [TrackedValidatorStake], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedValidatorStake.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorStake] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedValidatorStake]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTrackedValidatorStake.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTransactionGuarantee: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionGuarantee]

    public static func write(_ value: [TransactionGuarantee], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionGuarantee.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionGuarantee] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionGuarantee]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTransactionGuarantee.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTransactionPreviewResponseLogsInner: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionPreviewResponseLogsInner]

    public static func write(_ value: [TransactionPreviewResponseLogsInner], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionPreviewResponseLogsInner.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionPreviewResponseLogsInner] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionPreviewResponseLogsInner]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTransactionPreviewResponseLogsInner.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeValidatorAddress: FfiConverterRustBuffer {
    typealias SwiftType = [ValidatorAddress]

    public static func write(_ value: [ValidatorAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeValidatorAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ValidatorAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [ValidatorAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeValidatorAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeWalletInteractionWalletAccount: FfiConverterRustBuffer {
    typealias SwiftType = [WalletInteractionWalletAccount]

    public static func write(_ value: [WalletInteractionWalletAccount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletInteractionWalletAccount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletInteractionWalletAccount] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletInteractionWalletAccount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeWalletInteractionWalletAccount.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
    typealias SwiftType = [WalletToDappInteractionAccountProof]

    public static func write(_ value: [WalletToDappInteractionAccountProof], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletToDappInteractionAccountProof.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletToDappInteractionAccountProof] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletToDappInteractionAccountProof]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeWalletToDappInteractionAccountProof.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = [AccountOrPersona]

    public static func write(_ value: [AccountOrPersona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountOrPersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountOrPersona] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountOrPersona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountOrPersona.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = [Address]

    public static func write(_ value: [Address], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Address] {
        let len: Int32 = try readInt(&buf)
        var seq = [Address]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAddressOfAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = [AddressOfAccountOrPersona]

    public static func write(_ value: [AddressOfAccountOrPersona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddressOfAccountOrPersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AddressOfAccountOrPersona] {
        let len: Int32 = try readInt(&buf)
        var seq = [AddressOfAccountOrPersona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAddressOfAccountOrPersona.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeBIP39WordCount: FfiConverterRustBuffer {
    typealias SwiftType = [Bip39WordCount]

    public static func write(_ value: [Bip39WordCount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBIP39WordCount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip39WordCount] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bip39WordCount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeBIP39WordCount.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeDerivationPath: FfiConverterRustBuffer {
    typealias SwiftType = [DerivationPath]

    public static func write(_ value: [DerivationPath], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivationPath.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationPath] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivationPath]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeDerivationPath.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeDerivationPathScheme: FfiConverterRustBuffer {
    typealias SwiftType = [DerivationPathScheme]

    public static func write(_ value: [DerivationPathScheme], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivationPathScheme.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationPathScheme] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivationPathScheme]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeDerivationPathScheme.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeDetailedManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = [DetailedManifestClass]

    public static func write(_ value: [DetailedManifestClass], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDetailedManifestClass.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DetailedManifestClass] {
        let len: Int32 = try readInt(&buf)
        var seq = [DetailedManifestClass]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeDetailedManifestClass.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeEntityFlag: FfiConverterRustBuffer {
    typealias SwiftType = [EntityFlag]

    public static func write(_ value: [EntityFlag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEntityFlag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityFlag] {
        let len: Int32 = try readInt(&buf)
        var seq = [EntityFlag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeEntityFlag.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorSource: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSource]

    public static func write(_ value: [FactorSource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSource] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorSource.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorSourceFlag: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSourceFlag]

    public static func write(_ value: [FactorSourceFlag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSourceFlag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceFlag] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSourceFlag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorSourceFlag.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFungibleResourcesCollectionItem: FfiConverterRustBuffer {
    typealias SwiftType = [FungibleResourcesCollectionItem]

    public static func write(_ value: [FungibleResourcesCollectionItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFungibleResourcesCollectionItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FungibleResourcesCollectionItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [FungibleResourcesCollectionItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFungibleResourcesCollectionItem.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNetworkID: FfiConverterRustBuffer {
    typealias SwiftType = [NetworkId]

    public static func write(_ value: [NetworkId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNetworkID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NetworkId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NetworkId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNetworkID.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleLocalId]

    public static func write(_ value: [NonFungibleLocalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleLocalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleLocalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleLocalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNonFungibleLocalId.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKeyHash]

    public static func write(_ value: [PublicKeyHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKeyHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKeyHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKeyHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePublicKeyHash.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeReservedInstruction: FfiConverterRustBuffer {
    typealias SwiftType = [ReservedInstruction]

    public static func write(_ value: [ReservedInstruction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReservedInstruction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReservedInstruction] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReservedInstruction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeReservedInstruction.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceIndicator]

    public static func write(_ value: [ResourceIndicator], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceIndicator.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceIndicator] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceIndicator]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceIndicator.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceOrNonFungible]

    public static func write(_ value: [ResourceOrNonFungible], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceOrNonFungible.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceOrNonFungible] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceOrNonFungible]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceOrNonFungible.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSLIP10Curve: FfiConverterRustBuffer {
    typealias SwiftType = [Slip10Curve]

    public static func write(_ value: [Slip10Curve], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSLIP10Curve.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Slip10Curve] {
        let len: Int32 = try readInt(&buf)
        var seq = [Slip10Curve]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSLIP10Curve.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataEntryID: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryId]

    public static func write(_ value: [PersonaDataEntryId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataEntryID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataEntryId] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataEntryId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataEntryID.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressTypeDepositRule: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: DepositRule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterTypeDepositRule.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: DepositRule] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: DepositRule]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterTypeDepositRule.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [ResourceIndicator]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterSequenceTypeResourceIndicator.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceIndicator]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [ResourceIndicator]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceIndicator.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [ResourceOrNonFungible]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterSequenceTypeResourceOrNonFungible.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceOrNonFungible]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [ResourceOrNonFungible]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData: FfiConverterRustBuffer {
    public static func write(_ value: [NonFungibleGlobalId: UnstakeData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeNonFungibleGlobalId.write(key, into: &buf)
            FfiConverterTypeUnstakeData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId: UnstakeData] {
        let len: Int32 = try readInt(&buf)
        var dict = [NonFungibleGlobalId: UnstakeData]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
            let value = try FfiConverterTypeUnstakeData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeResourceAddressTypeDecimal192: FfiConverterRustBuffer {
    public static func write(_ value: [ResourceAddress: Decimal192], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeResourceAddress.write(key, into: &buf)
            FfiConverterTypeDecimal192.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: Decimal192] {
        let len: Int32 = try readInt(&buf)
        var dict = [ResourceAddress: Decimal192]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeResourceAddress.read(from: &buf)
            let value = try FfiConverterTypeDecimal192.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource: FfiConverterRustBuffer {
    public static func write(_ value: [ResourceAddress: NewlyCreatedResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeResourceAddress.write(key, into: &buf)
            FfiConverterTypeNewlyCreatedResource.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: NewlyCreatedResource] {
        let len: Int32 = try readInt(&buf)
        var dict = [ResourceAddress: NewlyCreatedResource]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeResourceAddress.read(from: &buf)
            let value = try FfiConverterTypeNewlyCreatedResource.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    public static func write(_ value: [ResourceAddress: ResourcePreferenceUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeResourceAddress.write(key, into: &buf)
            FfiConverterTypeResourcePreferenceUpdate.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: ResourcePreferenceUpdate] {
        let len: Int32 = try readInt(&buf)
        var dict = [ResourceAddress: ResourcePreferenceUpdate]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeResourceAddress.read(from: &buf)
            let value = try FfiConverterTypeResourcePreferenceUpdate.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bip39Passphrase = String
public struct FfiConverterTypeBIP39Passphrase: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Passphrase {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Bip39Passphrase, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bip39Passphrase {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Bip39Passphrase) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeBIP39Passphrase_lift(_ value: RustBuffer) throws -> Bip39Passphrase {
    return try FfiConverterTypeBIP39Passphrase.lift(value)
}

public func FfiConverterTypeBIP39Passphrase_lower(_ value: Bip39Passphrase) -> RustBuffer {
    return FfiConverterTypeBIP39Passphrase.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bip39SeedSecretMagic = BagOfBytes
public struct FfiConverterTypeBIP39SeedSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39SeedSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Bip39SeedSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bip39SeedSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Bip39SeedSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeBIP39SeedSecretMagic_lift(_ value: RustBuffer) throws -> Bip39SeedSecretMagic {
    return try FfiConverterTypeBIP39SeedSecretMagic.lift(value)
}

public func FfiConverterTypeBIP39SeedSecretMagic_lower(_ value: Bip39SeedSecretMagic) -> RustBuffer {
    return FfiConverterTypeBIP39SeedSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BagOfBytes = Data

public struct FfiConverterTypeBagOfBytes: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BagOfBytes {
        let builtinValue = try FfiConverterSequenceInt8.read(from: &buf)
        return Data(builtinValue.map { i8 in UInt8(bitPattern: i8) })
    }

    public static func write(_ value: BagOfBytes, into buf: inout [UInt8]) {
        let builtinValue = value.map { u8 in Int8(bitPattern: u8) }
        return FfiConverterSequenceInt8.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BagOfBytes {
        let builtinValue = try FfiConverterSequenceInt8.lift(value)
        return Data(builtinValue.map { i8 in UInt8(bitPattern: i8) })
    }

    public static func lower(_ value: BagOfBytes) -> RustBuffer {
        let builtinValue = value.map { u8 in Int8(bitPattern: u8) }
        return FfiConverterSequenceInt8.lower(builtinValue)
    }
}

public func FfiConverterTypeBagOfBytes_lift(_ value: RustBuffer) throws -> BagOfBytes {
    return try FfiConverterTypeBagOfBytes.lift(value)
}

public func FfiConverterTypeBagOfBytes_lower(_ value: BagOfBytes) -> RustBuffer {
    return FfiConverterTypeBagOfBytes.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Entropy16BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeEntropy16BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy16BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Entropy16BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Entropy16BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Entropy16BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeEntropy16BytesSecretMagic_lift(_ value: RustBuffer) throws -> Entropy16BytesSecretMagic {
    return try FfiConverterTypeEntropy16BytesSecretMagic.lift(value)
}

public func FfiConverterTypeEntropy16BytesSecretMagic_lower(_ value: Entropy16BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeEntropy16BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Entropy20BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeEntropy20BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy20BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Entropy20BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Entropy20BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Entropy20BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeEntropy20BytesSecretMagic_lift(_ value: RustBuffer) throws -> Entropy20BytesSecretMagic {
    return try FfiConverterTypeEntropy20BytesSecretMagic.lift(value)
}

public func FfiConverterTypeEntropy20BytesSecretMagic_lower(_ value: Entropy20BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeEntropy20BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Entropy24BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeEntropy24BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy24BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Entropy24BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Entropy24BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Entropy24BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeEntropy24BytesSecretMagic_lift(_ value: RustBuffer) throws -> Entropy24BytesSecretMagic {
    return try FfiConverterTypeEntropy24BytesSecretMagic.lift(value)
}

public func FfiConverterTypeEntropy24BytesSecretMagic_lower(_ value: Entropy24BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeEntropy24BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Entropy28BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeEntropy28BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy28BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Entropy28BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Entropy28BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Entropy28BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeEntropy28BytesSecretMagic_lift(_ value: RustBuffer) throws -> Entropy28BytesSecretMagic {
    return try FfiConverterTypeEntropy28BytesSecretMagic.lift(value)
}

public func FfiConverterTypeEntropy28BytesSecretMagic_lower(_ value: Entropy28BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeEntropy28BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Entropy32BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeEntropy32BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy32BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Entropy32BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Entropy32BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Entropy32BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeEntropy32BytesSecretMagic_lift(_ value: RustBuffer) throws -> Entropy32BytesSecretMagic {
    return try FfiConverterTypeEntropy32BytesSecretMagic.lift(value)
}

public func FfiConverterTypeEntropy32BytesSecretMagic_lower(_ value: Entropy32BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeEntropy32BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Epoch = UInt64
public struct FfiConverterTypeEpoch: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Epoch {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: Epoch, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> Epoch {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: Epoch) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}

public func FfiConverterTypeEpoch_lift(_ value: UInt64) throws -> Epoch {
    return try FfiConverterTypeEpoch.lift(value)
}

public func FfiConverterTypeEpoch_lower(_ value: Epoch) -> UInt64 {
    return FfiConverterTypeEpoch.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly12BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly12BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly12BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly12BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly12BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly12BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly12BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly12BytesSecretMagic {
    return try FfiConverterTypeExactly12BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly12BytesSecretMagic_lower(_ value: Exactly12BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly12BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly29BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly29BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly29BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly29BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly29BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly29BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly29BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly29BytesSecretMagic {
    return try FfiConverterTypeExactly29BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly29BytesSecretMagic_lower(_ value: Exactly29BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly29BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly32BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly32BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly32BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly32BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly32BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly32BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly32BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly32BytesSecretMagic {
    return try FfiConverterTypeExactly32BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly32BytesSecretMagic_lower(_ value: Exactly32BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly32BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly33BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly33BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly33BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly33BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly33BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly33BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly33BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly33BytesSecretMagic {
    return try FfiConverterTypeExactly33BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly33BytesSecretMagic_lower(_ value: Exactly33BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly33BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly64BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly64BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly64BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly64BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly64BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly64BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly64BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly64BytesSecretMagic {
    return try FfiConverterTypeExactly64BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly64BytesSecretMagic_lower(_ value: Exactly64BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly64BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly65BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly65BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly65BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly65BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly65BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly65BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly65BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly65BytesSecretMagic {
    return try FfiConverterTypeExactly65BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly65BytesSecretMagic_lower(_ value: Exactly65BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly65BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias HashSecretMagic = BagOfBytes
public struct FfiConverterTypeHashSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HashSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: HashSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> HashSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: HashSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeHashSecretMagic_lift(_ value: RustBuffer) throws -> HashSecretMagic {
    return try FfiConverterTypeHashSecretMagic.lift(value)
}

public func FfiConverterTypeHashSecretMagic_lower(_ value: HashSecretMagic) -> RustBuffer {
    return FfiConverterTypeHashSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias InstructionsSecretMagic = BagOfBytes
public struct FfiConverterTypeInstructionsSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InstructionsSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: InstructionsSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> InstructionsSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: InstructionsSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeInstructionsSecretMagic_lift(_ value: RustBuffer) throws -> InstructionsSecretMagic {
    return try FfiConverterTypeInstructionsSecretMagic.lift(value)
}

public func FfiConverterTypeInstructionsSecretMagic_lower(_ value: InstructionsSecretMagic) -> RustBuffer {
    return FfiConverterTypeInstructionsSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias LegacyOlympiaAccountAddressSecretMagic = Secp256k1PublicKey
public struct FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyOlympiaAccountAddressSecretMagic {
        return try FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
    }

    public static func write(_ value: LegacyOlympiaAccountAddressSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeSecp256k1PublicKey.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> LegacyOlympiaAccountAddressSecretMagic {
        return try FfiConverterTypeSecp256k1PublicKey.lift(value)
    }

    public static func lower(_ value: LegacyOlympiaAccountAddressSecretMagic) -> RustBuffer {
        return FfiConverterTypeSecp256k1PublicKey.lower(value)
    }
}

public func FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic_lift(_ value: RustBuffer) throws -> LegacyOlympiaAccountAddressSecretMagic {
    return try FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic.lift(value)
}

public func FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic_lower(_ value: LegacyOlympiaAccountAddressSecretMagic) -> RustBuffer {
    return FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias NonceSecretMagic = UInt32
public struct FfiConverterTypeNonceSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonceSecretMagic {
        return try FfiConverterUInt32.read(from: &buf)
    }

    public static func write(_ value: NonceSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterUInt32.write(value, into: &buf)
    }

    public static func lift(_ value: UInt32) throws -> NonceSecretMagic {
        return try FfiConverterUInt32.lift(value)
    }

    public static func lower(_ value: NonceSecretMagic) -> UInt32 {
        return FfiConverterUInt32.lower(value)
    }
}

public func FfiConverterTypeNonceSecretMagic_lift(_ value: UInt32) throws -> NonceSecretMagic {
    return try FfiConverterTypeNonceSecretMagic.lift(value)
}

public func FfiConverterTypeNonceSecretMagic_lower(_ value: NonceSecretMagic) -> UInt32 {
    return FfiConverterTypeNonceSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PersonaDataEntryId = Uuid
public struct FfiConverterTypePersonaDataEntryID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: PersonaDataEntryId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PersonaDataEntryId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: PersonaDataEntryId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypePersonaDataEntryID_lift(_ value: RustBuffer) throws -> PersonaDataEntryId {
    return try FfiConverterTypePersonaDataEntryID.lift(value)
}

public func FfiConverterTypePersonaDataEntryID_lower(_ value: PersonaDataEntryId) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ProfileId = Uuid
public struct FfiConverterTypeProfileID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: ProfileId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ProfileId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: ProfileId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypeProfileID_lift(_ value: RustBuffer) throws -> ProfileId {
    return try FfiConverterTypeProfileID.lift(value)
}

public func FfiConverterTypeProfileID_lower(_ value: ProfileId) -> RustBuffer {
    return FfiConverterTypeProfileID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetAccessControllerAddress = String
public struct FfiConverterTypeRetAccessControllerAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetAccessControllerAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetAccessControllerAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetAccessControllerAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetAccessControllerAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetAccessControllerAddress_lift(_ value: RustBuffer) throws -> RetAccessControllerAddress {
    return try FfiConverterTypeRetAccessControllerAddress.lift(value)
}

public func FfiConverterTypeRetAccessControllerAddress_lower(_ value: RetAccessControllerAddress) -> RustBuffer {
    return FfiConverterTypeRetAccessControllerAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetAccountAddress = String
public struct FfiConverterTypeRetAccountAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetAccountAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetAccountAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetAccountAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetAccountAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetAccountAddress_lift(_ value: RustBuffer) throws -> RetAccountAddress {
    return try FfiConverterTypeRetAccountAddress.lift(value)
}

public func FfiConverterTypeRetAccountAddress_lower(_ value: RetAccountAddress) -> RustBuffer {
    return FfiConverterTypeRetAccountAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetComponentAddress = String
public struct FfiConverterTypeRetComponentAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetComponentAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetComponentAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetComponentAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetComponentAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetComponentAddress_lift(_ value: RustBuffer) throws -> RetComponentAddress {
    return try FfiConverterTypeRetComponentAddress.lift(value)
}

public func FfiConverterTypeRetComponentAddress_lower(_ value: RetComponentAddress) -> RustBuffer {
    return FfiConverterTypeRetComponentAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetIdentityAddress = String
public struct FfiConverterTypeRetIdentityAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetIdentityAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetIdentityAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetIdentityAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetIdentityAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetIdentityAddress_lift(_ value: RustBuffer) throws -> RetIdentityAddress {
    return try FfiConverterTypeRetIdentityAddress.lift(value)
}

public func FfiConverterTypeRetIdentityAddress_lower(_ value: RetIdentityAddress) -> RustBuffer {
    return FfiConverterTypeRetIdentityAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetPackageAddress = String
public struct FfiConverterTypeRetPackageAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetPackageAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetPackageAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetPackageAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetPackageAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetPackageAddress_lift(_ value: RustBuffer) throws -> RetPackageAddress {
    return try FfiConverterTypeRetPackageAddress.lift(value)
}

public func FfiConverterTypeRetPackageAddress_lower(_ value: RetPackageAddress) -> RustBuffer {
    return FfiConverterTypeRetPackageAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetPoolAddress = String
public struct FfiConverterTypeRetPoolAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetPoolAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetPoolAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetPoolAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetPoolAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetPoolAddress_lift(_ value: RustBuffer) throws -> RetPoolAddress {
    return try FfiConverterTypeRetPoolAddress.lift(value)
}

public func FfiConverterTypeRetPoolAddress_lower(_ value: RetPoolAddress) -> RustBuffer {
    return FfiConverterTypeRetPoolAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetResourceAddress = String
public struct FfiConverterTypeRetResourceAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetResourceAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetResourceAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetResourceAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetResourceAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetResourceAddress_lift(_ value: RustBuffer) throws -> RetResourceAddress {
    return try FfiConverterTypeRetResourceAddress.lift(value)
}

public func FfiConverterTypeRetResourceAddress_lower(_ value: RetResourceAddress) -> RustBuffer {
    return FfiConverterTypeRetResourceAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetValidatorAddress = String
public struct FfiConverterTypeRetValidatorAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetValidatorAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetValidatorAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetValidatorAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetValidatorAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetValidatorAddress_lift(_ value: RustBuffer) throws -> RetValidatorAddress {
    return try FfiConverterTypeRetValidatorAddress.lift(value)
}

public func FfiConverterTypeRetValidatorAddress_lower(_ value: RetValidatorAddress) -> RustBuffer {
    return FfiConverterTypeRetValidatorAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetVaultAddress = String
public struct FfiConverterTypeRetVaultAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetVaultAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetVaultAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetVaultAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetVaultAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetVaultAddress_lift(_ value: RustBuffer) throws -> RetVaultAddress {
    return try FfiConverterTypeRetVaultAddress.lift(value)
}

public func FfiConverterTypeRetVaultAddress_lower(_ value: RetVaultAddress) -> RustBuffer {
    return FfiConverterTypeRetVaultAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ScryptoDecimal192 = String
public struct FfiConverterTypeScryptoDecimal192: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScryptoDecimal192 {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ScryptoDecimal192, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ScryptoDecimal192 {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ScryptoDecimal192) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeScryptoDecimal192_lift(_ value: RustBuffer) throws -> ScryptoDecimal192 {
    return try FfiConverterTypeScryptoDecimal192.lift(value)
}

public func FfiConverterTypeScryptoDecimal192_lower(_ value: ScryptoDecimal192) -> RustBuffer {
    return FfiConverterTypeScryptoDecimal192.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ScryptoEd25519PublicKey = BagOfBytes
public struct FfiConverterTypeScryptoEd25519PublicKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScryptoEd25519PublicKey {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: ScryptoEd25519PublicKey, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ScryptoEd25519PublicKey {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: ScryptoEd25519PublicKey) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeScryptoEd25519PublicKey_lift(_ value: RustBuffer) throws -> ScryptoEd25519PublicKey {
    return try FfiConverterTypeScryptoEd25519PublicKey.lift(value)
}

public func FfiConverterTypeScryptoEd25519PublicKey_lower(_ value: ScryptoEd25519PublicKey) -> RustBuffer {
    return FfiConverterTypeScryptoEd25519PublicKey.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ScryptoSecp256k1PublicKey = BagOfBytes
public struct FfiConverterTypeScryptoSecp256k1PublicKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScryptoSecp256k1PublicKey {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: ScryptoSecp256k1PublicKey, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ScryptoSecp256k1PublicKey {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: ScryptoSecp256k1PublicKey) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeScryptoSecp256k1PublicKey_lift(_ value: RustBuffer) throws -> ScryptoSecp256k1PublicKey {
    return try FfiConverterTypeScryptoSecp256k1PublicKey.lift(value)
}

public func FfiConverterTypeScryptoSecp256k1PublicKey_lower(_ value: ScryptoSecp256k1PublicKey) -> RustBuffer {
    return FfiConverterTypeScryptoSecp256k1PublicKey.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ScryptoStringNonFungibleLocalId = String
public struct FfiConverterTypeScryptoStringNonFungibleLocalId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScryptoStringNonFungibleLocalId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ScryptoStringNonFungibleLocalId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ScryptoStringNonFungibleLocalId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ScryptoStringNonFungibleLocalId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeScryptoStringNonFungibleLocalId_lift(_ value: RustBuffer) throws -> ScryptoStringNonFungibleLocalId {
    return try FfiConverterTypeScryptoStringNonFungibleLocalId.lift(value)
}

public func FfiConverterTypeScryptoStringNonFungibleLocalId_lower(_ value: ScryptoStringNonFungibleLocalId) -> RustBuffer {
    return FfiConverterTypeScryptoStringNonFungibleLocalId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SessionId = Uuid
public struct FfiConverterTypeSessionID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: SessionId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> SessionId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: SessionId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypeSessionID_lift(_ value: RustBuffer) throws -> SessionId {
    return try FfiConverterTypeSessionID.lift(value)
}

public func FfiConverterTypeSessionID_lower(_ value: SessionId) -> RustBuffer {
    return FfiConverterTypeSessionID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TxVersion = UInt64
public struct FfiConverterTypeTXVersion: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxVersion {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: TxVersion, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> TxVersion {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: TxVersion) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}

public func FfiConverterTypeTXVersion_lift(_ value: UInt64) throws -> TxVersion {
    return try FfiConverterTypeTXVersion.lift(value)
}

public func FfiConverterTypeTXVersion_lower(_ value: TxVersion) -> UInt64 {
    return FfiConverterTypeTXVersion.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Timestamp = Date

public struct FfiConverterTypeTimestamp: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timestamp {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return {
            let stringToDeserialize = builtinValue // this is UniFFIs counterpart to `$0`
            let formatter = ISO8601DateFormatter()
            let formatOptionMS = ISO8601DateFormatter.Options.withFractionalSeconds
            formatter.formatOptions.insert(formatOptionMS)

            func format() -> Date? {
                formatter.date(from: stringToDeserialize)
            }

            if let date = format() {
                return date
            }

            // try without fractional seconds
            formatter.formatOptions.remove(formatOptionMS)
            return format()!
        }()
    }

    public static func write(_ value: Timestamp, into buf: inout [UInt8]) {
        let builtinValue = {
            let dateToSerialize = value // this is UniFFIs counterpart to `$0`
            let formatter = ISO8601DateFormatter()
            formatter.formatOptions.insert(.withFractionalSeconds)
            return formatter.string(from: dateToSerialize)
        }()

        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Timestamp {
        let builtinValue = try FfiConverterString.lift(value)
        return {
            let stringToDeserialize = builtinValue // this is UniFFIs counterpart to `$0`
            let formatter = ISO8601DateFormatter()
            let formatOptionMS = ISO8601DateFormatter.Options.withFractionalSeconds
            formatter.formatOptions.insert(formatOptionMS)

            func format() -> Date? {
                formatter.date(from: stringToDeserialize)
            }

            if let date = format() {
                return date
            }

            // try without fractional seconds
            formatter.formatOptions.remove(formatOptionMS)
            return format()!
        }()
    }

    public static func lower(_ value: Timestamp) -> RustBuffer {
        let builtinValue = {
            let dateToSerialize = value // this is UniFFIs counterpart to `$0`
            let formatter = ISO8601DateFormatter()
            formatter.formatOptions.insert(.withFractionalSeconds)
            return formatter.string(from: dateToSerialize)
        }()

        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeTimestamp_lift(_ value: RustBuffer) throws -> Timestamp {
    return try FfiConverterTypeTimestamp.lift(value)
}

public func FfiConverterTypeTimestamp_lower(_ value: Timestamp) -> RustBuffer {
    return FfiConverterTypeTimestamp.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Url = URL

public struct FfiConverterTypeUrl: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Url {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return URL(string: builtinValue)!
    }

    public static func write(_ value: Url, into buf: inout [UInt8]) {
        let builtinValue = String(describing: value)
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Url {
        let builtinValue = try FfiConverterString.lift(value)
        return URL(string: builtinValue)!
    }

    public static func lower(_ value: Url) -> RustBuffer {
        let builtinValue = String(describing: value)
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeUrl_lift(_ value: RustBuffer) throws -> Url {
    return try FfiConverterTypeUrl.lift(value)
}

public func FfiConverterTypeUrl_lower(_ value: Url) -> RustBuffer {
    return FfiConverterTypeUrl.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Uuid = UUID

public struct FfiConverterTypeUuid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return UUID(uuidString: builtinValue)!
    }

    public static func write(_ value: Uuid, into buf: inout [UInt8]) {
        let builtinValue = value.uuidString
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Uuid {
        let builtinValue = try FfiConverterString.lift(value)
        return UUID(uuidString: builtinValue)!
    }

    public static func lower(_ value: Uuid) -> RustBuffer {
        let builtinValue = value.uuidString
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeUuid_lift(_ value: RustBuffer) throws -> Uuid {
    return try FfiConverterTypeUuid.lift(value)
}

public func FfiConverterTypeUuid_lower(_ value: Uuid) -> RustBuffer {
    return FfiConverterTypeUuid.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletInteractionId = Uuid
public struct FfiConverterTypeWalletInteractionId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: WalletInteractionId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> WalletInteractionId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: WalletInteractionId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypeWalletInteractionId_lift(_ value: RustBuffer) throws -> WalletInteractionId {
    return try FfiConverterTypeWalletInteractionId.lift(value)
}

public func FfiConverterTypeWalletInteractionId_lower(_ value: WalletInteractionId) -> RustBuffer {
    return FfiConverterTypeWalletInteractionId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletInteractionVersion = UInt64
public struct FfiConverterTypeWalletInteractionVersion: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionVersion {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: WalletInteractionVersion, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> WalletInteractionVersion {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: WalletInteractionVersion) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}

public func FfiConverterTypeWalletInteractionVersion_lift(_ value: UInt64) throws -> WalletInteractionVersion {
    return try FfiConverterTypeWalletInteractionVersion.lift(value)
}

public func FfiConverterTypeWalletInteractionVersion_lower(_ value: WalletInteractionVersion) -> UInt64 {
    return FfiConverterTypeWalletInteractionVersion.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

private func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> Void,
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> Void,
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> Void,
    handleError: @escaping (Int8, RustBuffer) -> Void
) -> UniffiForeignFuture {
    let task = Task {
        do {
            try handleSuccess(await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> Void,
    handleError: @escaping (Int8, RustBuffer) -> Void,
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            try handleSuccess(await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
private var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountSargon() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}

public func accessControllerAddressBech32Address(address: AccessControllerAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_access_controller_address_bech32_address(
            FfiConverterTypeAccessControllerAddress.lower(address), $0
        )
    })
}

public func accessControllerAddressFormatted(address: AccessControllerAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_access_controller_address_formatted(
            FfiConverterTypeAccessControllerAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func accessControllerAddressMapToNetwork(address: AccessControllerAddress, networkId: NetworkId) -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_access_controller_address_map_to_network(
            FfiConverterTypeAccessControllerAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func accessControllerAddressNetworkId(address: AccessControllerAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_access_controller_address_network_id(
            FfiConverterTypeAccessControllerAddress.lower(address), $0
        )
    })
}

public func accountAddressBech32Address(address: AccountAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_account_address_bech32_address(
            FfiConverterTypeAccountAddress.lower(address), $0
        )
    })
}

public func accountAddressFormatted(address: AccountAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_account_address_formatted(
            FfiConverterTypeAccountAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns `false` for all addresses created with `Ed25519PublicKey`s, i.e.
 * for all accounts created by the Babylon Radix Wallets.
 * Returns `true` for all addresses created with `Secp256k1PublicKey`s, i.e.
 * imported from the Olympia Wallet.
 */
public func accountAddressIsLegacy(address: AccountAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_account_address_is_legacy(
            FfiConverterTypeAccountAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func accountAddressMapToNetwork(address: AccountAddress, networkId: NetworkId) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_account_address_map_to_network(
            FfiConverterTypeAccountAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func accountAddressNetworkId(address: AccountAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_account_address_network_id(
            FfiConverterTypeAccountAddress.lower(address), $0
        )
    })
}

public func accountOrAddressOfAccountAddress(recipient: AccountOrAddressOf) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_account_or_address_of_account_address(
            FfiConverterTypeAccountOrAddressOf.lower(recipient), $0
        )
    })
}

public func accountOrPersonaGetId(entity: AccountOrPersona) -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_account_or_persona_get_id(
            FfiConverterTypeAccountOrPersona.lower(entity), $0
        )
    })
}

public func addressFormatted(address: Address, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_address_formatted(
            FfiConverterTypeAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func addressMapToNetwork(address: Address, networkId: NetworkId) -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_address_map_to_network(
            FfiConverterTypeAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func addressNetworkId(address: Address) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_address_network_id(
            FfiConverterTypeAddress.lower(address), $0
        )
    })
}

public func addressOfAccountOrPersonaFormatted(address: AddressOfAccountOrPersona, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_address_of_account_or_persona_formatted(
            FfiConverterTypeAddressOfAccountOrPersona.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func addressOfAccountOrPersonaMapToNetwork(address: AddressOfAccountOrPersona, networkId: NetworkId) -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_address_of_account_or_persona_map_to_network(
            FfiConverterTypeAddressOfAccountOrPersona.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func addressOfAccountOrPersonaNetworkId(address: AddressOfAccountOrPersona) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_address_of_account_or_persona_network_id(
            FfiConverterTypeAddressOfAccountOrPersona.lower(address), $0
        )
    })
}

public func addressOfAccountOrPersonaSampleValuesAll() -> [AddressOfAccountOrPersona] {
    return try! FfiConverterSequenceTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_address_of_account_or_persona_sample_values_all($0
        )
    })
}

public func addressOfAccountOrPersonaToString(address: AddressOfAccountOrPersona) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_address_of_account_or_persona_to_string(
            FfiConverterTypeAddressOfAccountOrPersona.lower(address), $0
        )
    })
}

public func addressSampleValuesAll() -> [Address] {
    return try! FfiConverterSequenceTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_address_sample_values_all($0
        )
    })
}

public func addressToString(address: Address) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_address_to_string(
            FfiConverterTypeAddress.lower(address), $0
        )
    })
}

public func androidNotarizeHashWithPrivateKeyBytes(privateKeyBytes: Exactly32Bytes, signedIntentHash: SignedIntentHash) throws -> NotarySignature {
    return try FfiConverterTypeNotarySignature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_android_notarize_hash_with_private_key_bytes(
            FfiConverterTypeExactly32Bytes.lower(privateKeyBytes),
            FfiConverterTypeSignedIntentHash.lower(signedIntentHash), $0
        )
    })
}

public func androidSecretKeyGetPublicKeyFromPrivateKeyBytes(privateKeyBytes: Exactly32Bytes) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_android_secret_key_get_public_key_from_private_key_bytes(
            FfiConverterTypeExactly32Bytes.lower(privateKeyBytes), $0
        )
    })
}

public func androidSignHashWithPrivateKeyBytes(privateKeyBytes: Exactly32Bytes, hash: Hash) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_android_sign_hash_with_private_key_bytes(
            FfiConverterTypeExactly32Bytes.lower(privateKeyBytes),
            FfiConverterTypeHash.lower(hash), $0
        )
    })
}

public func appearanceIdsAll() -> [AppearanceId] {
    return try! FfiConverterSequenceTypeAppearanceID.lift(try! rustCall {
        uniffi_sargon_fn_func_appearance_ids_all($0
        )
    })
}

public func authorizedDappToJsonBytes(authorizedDapp: AuthorizedDapp) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_authorized_dapp_to_json_bytes(
            FfiConverterTypeAuthorizedDapp.lower(authorizedDapp), $0
        )
    })
}

public func bIP39SeedToBytes(bytes: Bip39Seed) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_b_i_p39_seed_to_bytes(
            FfiConverterTypeBIP39Seed.lower(bytes), $0
        )
    })
}

public func bagOfBytesAppendCafe(to: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_bag_of_bytes_append_cafe(
            FfiConverterTypeBagOfBytes.lower(to), $0
        )
    })
}

public func bagOfBytesAppendDeadbeef(to: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_bag_of_bytes_append_deadbeef(
            FfiConverterTypeBagOfBytes.lower(to), $0
        )
    })
}

public func bagOfBytesPrependCafe(inFrontOf: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_bag_of_bytes_prepend_cafe(
            FfiConverterTypeBagOfBytes.lower(inFrontOf), $0
        )
    })
}

public func bagOfBytesPrependDeadbeef(inFrontOf: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_bag_of_bytes_prepend_deadbeef(
            FfiConverterTypeBagOfBytes.lower(inFrontOf), $0
        )
    })
}

public func bip39LanguageWordlist(language: Bip39Language) -> [Bip39Word] {
    return try! FfiConverterSequenceTypeBIP39Word.lift(try! rustCall {
        uniffi_sargon_fn_func_bip39_language_wordlist(
            FfiConverterTypeBIP39Language.lower(language), $0
        )
    })
}

public func bip39WordCountAll() -> [Bip39WordCount] {
    return try! FfiConverterSequenceTypeBIP39WordCount.lift(try! rustCall {
        uniffi_sargon_fn_func_bip39_word_count_all($0
        )
    })
}

public func bip44LikePathGetAddressIndex(path: Bip44LikePath) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_fn_func_bip44_like_path_get_address_index(
            FfiConverterTypeBIP44LikePath.lower(path), $0
        )
    })
}

public func bip44LikePathToString(path: Bip44LikePath) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_bip44_like_path_to_string(
            FfiConverterTypeBIP44LikePath.lower(path), $0
        )
    })
}

public func blobToBytes(blob: Blob) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_blob_to_bytes(
            FfiConverterTypeBlob.lower(blob), $0
        )
    })
}

public func blobToString(blob: Blob) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_blob_to_string(
            FfiConverterTypeBlob.lower(blob), $0
        )
    })
}

public func blobsListOfBlobs(blobs: Blobs) -> [Blob] {
    return try! FfiConverterSequenceTypeBlob.lift(try! rustCall {
        uniffi_sargon_fn_func_blobs_list_of_blobs(
            FfiConverterTypeBlobs.lower(blobs), $0
        )
    })
}

public func buildInformation() -> SargonBuildInformation {
    return try! FfiConverterTypeSargonBuildInformation.lift(try! rustCall {
        uniffi_sargon_fn_func_build_information($0
        )
    })
}

public func cap26PathToString(path: Cap26Path) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_cap26_path_to_string(
            FfiConverterTypeCAP26Path.lower(path), $0
        )
    })
}

public func checkIfEncryptedProfileJsonContainsLegacyP2pLinks(jsonStr: String, password: String) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_check_if_encrypted_profile_json_contains_legacy_p2p_links(
            FfiConverterString.lower(jsonStr),
            FfiConverterString.lower(password), $0
        )
    })
}

public func checkIfProfileJsonContainsLegacyP2pLinks(jsonStr: String) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_check_if_profile_json_contains_legacy_p2p_links(
            FfiConverterString.lower(jsonStr), $0
        )
    })
}

public func compiledNotarizedIntentGetBytes(compiledNotarizedIntent: CompiledNotarizedIntent) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_compiled_notarized_intent_get_bytes(
            FfiConverterTypeCompiledNotarizedIntent.lower(compiledNotarizedIntent), $0
        )
    })
}

public func componentAddressBech32Address(address: ComponentAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_component_address_bech32_address(
            FfiConverterTypeComponentAddress.lower(address), $0
        )
    })
}

public func componentAddressFormatted(address: ComponentAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_component_address_formatted(
            FfiConverterTypeComponentAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns `true` if the ComponentAddress is `global` (i.e. not `internal`)
 */
public func componentAddressIsGlobal(address: ComponentAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_component_address_is_global(
            FfiConverterTypeComponentAddress.lower(address), $0
        )
    })
}

/**
 * Returns `true` if the ComponentAddress is `internal` (i.e. not `global`)
 */
public func componentAddressIsInternal(address: ComponentAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_component_address_is_internal(
            FfiConverterTypeComponentAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func componentAddressMapToNetwork(address: ComponentAddress, networkId: NetworkId) -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_component_address_map_to_network(
            FfiConverterTypeComponentAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func componentAddressNetworkId(address: ComponentAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_component_address_network_id(
            FfiConverterTypeComponentAddress.lower(address), $0
        )
    })
}

public func dappToWalletInteractionUnvalidatedToJsonBytes(dappToWalletInteractionUnvalidated: DappToWalletInteractionUnvalidated) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_dapp_to_wallet_interaction_unvalidated_to_json_bytes(
            FfiConverterTypeDappToWalletInteractionUnvalidated.lower(dappToWalletInteractionUnvalidated), $0
        )
    })
}

public func debugPrintCompiledNotarizedIntent(compiled: CompiledNotarizedIntent) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_debug_print_compiled_notarized_intent(
            FfiConverterTypeCompiledNotarizedIntent.lower(compiled), $0
        )
    })
}

/**
 * Returns `decimal.abs()`, panics if `decimal` is `Decimal192::MIN`
 */
public func decimalAbs(decimal: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_abs(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * `lhs + rhs``
 */
public func decimalAdd(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_add(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * Clamps `decimal` to zero, i.e. `max(decimal, 0)`
 */
public func decimalClampedToZero(decimal: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_clamped_to_zero(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * `lhs / rhs``
 */
public func decimalDiv(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_div(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

public func decimalFormatted(decimal: Decimal192, locale: LocaleConfig, totalPlaces: UInt8, useGroupingSeparator: Bool) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_formatted(
            FfiConverterTypeDecimal192.lower(decimal),
            FfiConverterTypeLocaleConfig.lower(locale),
            FfiConverterUInt8.lower(totalPlaces),
            FfiConverterBool.lower(useGroupingSeparator), $0
        )
    })
}

/**
 * A human readable, locale respecting string. Does not perform any rounding or truncation.
 */
public func decimalFormattedPlain(decimal: Decimal192, locale: LocaleConfig, useGroupingSeparator: Bool) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_formatted_plain(
            FfiConverterTypeDecimal192.lower(decimal),
            FfiConverterTypeLocaleConfig.lower(locale),
            FfiConverterBool.lower(useGroupingSeparator), $0
        )
    })
}

/**
 * `lhs > rhs`
 */
public func decimalGreaterThan(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_greater_than(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * `lhs >= rhs`
 */
public func decimalGreaterThanOrEqual(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_greater_than_or_equal(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * Whether this decimal is negative.
 */
public func decimalIsNegative(decimal: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_is_negative(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * Whether this decimal is positive.
 */
public func decimalIsPositive(decimal: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_is_positive(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * Whether this decimal is zero.
 */
public func decimalIsZero(decimal: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_is_zero(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * `lhs < rhs`
 */
public func decimalLessThan(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_less_than(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * `lhs <= rhs`
 */
public func decimalLessThanOrEqual(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_less_than_or_equal(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * The maximum possible value of `Decimal192`, being:
 * `3138550867693340381917894711603833208051.177722232017256447`
 */
public func decimalMax() -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_max($0
        )
    })
}

/**
 * The minimum possible value of `Decimal192`, being:
 * `-3138550867693340381917894711603833208051.177722232017256448`
 */
public func decimalMin() -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_min($0
        )
    })
}

/**
 * `lhs * rhs``
 */
public func decimalMul(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_mul(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * Negates the `decimal`
 */
public func decimalNeg(decimal: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_neg(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * Rounds this number to the specified decimal places.
 *
 * # Panics
 * - Panic if the number of decimal places is not within [0..SCALE(=18)]
 */
public func decimalRound(decimal: Decimal192, decimalPlaces: UInt8, roundingMode: RoundingMode) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_decimal_round(
            FfiConverterTypeDecimal192.lower(decimal),
            FfiConverterUInt8.lower(decimalPlaces),
            FfiConverterTypeRoundingMode.lower(roundingMode), $0
        )
    })
}

/**
 * `lhs - rhs``
 */
public func decimalSub(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_sub(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * `decimal.to_string()`
 */
public func decimalToString(decimal: Decimal192) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_to_string(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

public func defaultGetIdPath() -> GetIdPath {
    return try! FfiConverterTypeGetIDPath.lift(try! rustCall {
        uniffi_sargon_fn_func_default_get_id_path($0
        )
    })
}

public func dependencyInformationToString(info: DependencyInformation) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_dependency_information_to_string(
            FfiConverterTypeDependencyInformation.lower(info), $0
        )
    })
}

public func depositRuleToJsonString(depositRule: DepositRule) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_deposit_rule_to_json_string(
            FfiConverterTypeDepositRule.lower(depositRule), $0
        )
    })
}

public func derivationPathToHdPath(path: DerivationPath) -> HdPath {
    return try! FfiConverterTypeHDPath.lift(try! rustCall {
        uniffi_sargon_fn_func_derivation_path_to_hd_path(
            FfiConverterTypeDerivationPath.lower(path), $0
        )
    })
}

public func derivationPathToString(path: DerivationPath) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_derivation_path_to_string(
            FfiConverterTypeDerivationPath.lower(path), $0
        )
    })
}

public func deviceFactorSourceIsMainBdfs(deviceFactorSource: DeviceFactorSource) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_device_factor_source_is_main_bdfs(
            FfiConverterTypeDeviceFactorSource.lower(deviceFactorSource), $0
        )
    })
}

public func deviceInfoToJsonBytes(deviceInfo: DeviceInfo) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_device_info_to_json_bytes(
            FfiConverterTypeDeviceInfo.lower(deviceInfo), $0
        )
    })
}

public func displayNameToJsonString(displayName: DisplayName) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_display_name_to_json_string(
            FfiConverterTypeDisplayName.lower(displayName), $0
        )
    })
}

public func ed25519PublicKeyToBytes(publicKey: Ed25519PublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_ed25519_public_key_to_bytes(
            FfiConverterTypeEd25519PublicKey.lower(publicKey), $0
        )
    })
}

/**
 * Encodes the `Ed25519PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"b7a3c12dc0c8c748ab07525b701122b88bd78f600c76342d27f25e5f92444cde"`
 */
public func ed25519PublicKeyToHex(publicKey: Ed25519PublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_ed25519_public_key_to_hex(
            FfiConverterTypeEd25519PublicKey.lower(publicKey), $0
        )
    })
}

public func ed25519PublicKeyToJsonString(ed25519PublicKey: Ed25519PublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_ed25519_public_key_to_json_string(
            FfiConverterTypeEd25519PublicKey.lower(ed25519PublicKey), $0
        )
    })
}

public func ed25519SignatureToJsonString(ed25519Signature: Ed25519Signature) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_ed25519_signature_to_json_string(
            FfiConverterTypeEd25519Signature.lower(ed25519Signature), $0
        )
    })
}

public func ed25519SignatureToString(signature: Ed25519Signature) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_ed25519_signature_to_string(
            FfiConverterTypeEd25519Signature.lower(signature), $0
        )
    })
}

public func enableLoggingFromRust() { try! rustCall {
    uniffi_sargon_fn_func_enable_logging_from_rust($0
    )
}
}

public func entropy16BytesToBytes(bytes: Entropy16Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_entropy16_bytes_to_bytes(
            FfiConverterTypeEntropy16Bytes.lower(bytes), $0
        )
    })
}

public func entropy20BytesToBytes(bytes: Entropy20Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_entropy20_bytes_to_bytes(
            FfiConverterTypeEntropy20Bytes.lower(bytes), $0
        )
    })
}

public func entropy24BytesToBytes(bytes: Entropy24Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_entropy24_bytes_to_bytes(
            FfiConverterTypeEntropy24Bytes.lower(bytes), $0
        )
    })
}

public func entropy28BytesToBytes(bytes: Entropy28Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_entropy28_bytes_to_bytes(
            FfiConverterTypeEntropy28Bytes.lower(bytes), $0
        )
    })
}

public func entropy32BytesToBytes(bytes: Entropy32Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_entropy32_bytes_to_bytes(
            FfiConverterTypeEntropy32Bytes.lower(bytes), $0
        )
    })
}

public func errorCodeFromError(error: CommonError) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_fn_func_error_code_from_error(
            FfiConverterTypeCommonError.lower(error), $0
        )
    })
}

public func errorMessageFromError(error: CommonError) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_error_message_from_error(
            FfiConverterTypeCommonError.lower(error), $0
        )
    })
}

public func exactly12BytesToJsonString(exactly12Bytes: Exactly12Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly12_bytes_to_json_string(
            FfiConverterTypeExactly12Bytes.lower(exactly12Bytes), $0
        )
    })
}

public func exactly29BytesToJsonString(exactly29Bytes: Exactly29Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly29_bytes_to_json_string(
            FfiConverterTypeExactly29Bytes.lower(exactly29Bytes), $0
        )
    })
}

public func exactly32BytesToJsonString(exactly32Bytes: Exactly32Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly32_bytes_to_json_string(
            FfiConverterTypeExactly32Bytes.lower(exactly32Bytes), $0
        )
    })
}

public func exactly33BytesToJsonString(exactly33Bytes: Exactly33Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly33_bytes_to_json_string(
            FfiConverterTypeExactly33Bytes.lower(exactly33Bytes), $0
        )
    })
}

public func exactly64BytesToJsonString(exactly64Bytes: Exactly64Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly64_bytes_to_json_string(
            FfiConverterTypeExactly64Bytes.lower(exactly64Bytes), $0
        )
    })
}

public func exactly65BytesToJsonString(exactly65Bytes: Exactly65Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly65_bytes_to_json_string(
            FfiConverterTypeExactly65Bytes.lower(exactly65Bytes), $0
        )
    })
}

public func exactly12BytesToBytes(bytes: Exactly12Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_12_bytes_to_bytes(
            FfiConverterTypeExactly12Bytes.lower(bytes), $0
        )
    })
}

public func exactly12BytesToHex(bytes: Exactly12Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_12_bytes_to_hex(
            FfiConverterTypeExactly12Bytes.lower(bytes), $0
        )
    })
}

public func exactly29BytesToBytes(bytes: Exactly29Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_29_bytes_to_bytes(
            FfiConverterTypeExactly29Bytes.lower(bytes), $0
        )
    })
}

public func exactly29BytesToHex(bytes: Exactly29Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_29_bytes_to_hex(
            FfiConverterTypeExactly29Bytes.lower(bytes), $0
        )
    })
}

public func exactly32BytesToBytes(bytes: Exactly32Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_32_bytes_to_bytes(
            FfiConverterTypeExactly32Bytes.lower(bytes), $0
        )
    })
}

public func exactly32BytesToHex(bytes: Exactly32Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_32_bytes_to_hex(
            FfiConverterTypeExactly32Bytes.lower(bytes), $0
        )
    })
}

public func exactly33BytesToBytes(bytes: Exactly33Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_33_bytes_to_bytes(
            FfiConverterTypeExactly33Bytes.lower(bytes), $0
        )
    })
}

public func exactly33BytesToHex(bytes: Exactly33Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_33_bytes_to_hex(
            FfiConverterTypeExactly33Bytes.lower(bytes), $0
        )
    })
}

public func exactly64BytesToBytes(bytes: Exactly64Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_64_bytes_to_bytes(
            FfiConverterTypeExactly64Bytes.lower(bytes), $0
        )
    })
}

public func exactly64BytesToHex(bytes: Exactly64Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_64_bytes_to_hex(
            FfiConverterTypeExactly64Bytes.lower(bytes), $0
        )
    })
}

public func exactly65BytesToBytes(bytes: Exactly65Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_65_bytes_to_bytes(
            FfiConverterTypeExactly65Bytes.lower(bytes), $0
        )
    })
}

public func exactly65BytesToHex(bytes: Exactly65Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_65_bytes_to_hex(
            FfiConverterTypeExactly65Bytes.lower(bytes), $0
        )
    })
}

public func factorSourceCryptoParametersSupportsBabylon(parameters: FactorSourceCryptoParameters) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_crypto_parameters_supports_babylon(
            FfiConverterTypeFactorSourceCryptoParameters.lower(parameters), $0
        )
    })
}

public func factorSourceCryptoParametersSupportsOlympia(parameters: FactorSourceCryptoParameters) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_crypto_parameters_supports_olympia(
            FfiConverterTypeFactorSourceCryptoParameters.lower(parameters), $0
        )
    })
}

public func factorSourceIDFromAddressToJsonBytes(factorSourceIDFromAddress: FactorSourceIdFromAddress) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_i_d_from_address_to_json_bytes(
            FfiConverterTypeFactorSourceIDFromAddress.lower(factorSourceIDFromAddress), $0
        )
    })
}

public func factorSourceIDFromHashToJsonBytes(factorSourceIDFromHash: FactorSourceIdFromHash) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_i_d_from_hash_to_json_bytes(
            FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceIDFromHash), $0
        )
    })
}

public func factorSourceIdFromAddressToString(factorSourceId: FactorSourceIdFromAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_id_from_address_to_string(
            FfiConverterTypeFactorSourceIDFromAddress.lower(factorSourceId), $0
        )
    })
}

public func factorSourceIdFromHashToString(factorSourceId: FactorSourceIdFromHash) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_id_from_hash_to_string(
            FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceId), $0
        )
    })
}

public func factorSourceIdToString(factorSourceId: FactorSourceId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_id_to_string(
            FfiConverterTypeFactorSourceID.lower(factorSourceId), $0
        )
    })
}

public func factorSourceKindToString(kind: FactorSourceKind) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_kind_to_string(
            FfiConverterTypeFactorSourceKind.lower(kind), $0
        )
    })
}

public func factorSourceSupportsBabylon(factorSource: FactorSource) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_supports_babylon(
            FfiConverterTypeFactorSource.lower(factorSource), $0
        )
    })
}

public func factorSourceSupportsOlympia(factorSource: FactorSource) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_supports_olympia(
            FfiConverterTypeFactorSource.lower(factorSource), $0
        )
    })
}

public func factorSourceToString(factorSource: FactorSource) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_to_string(
            FfiConverterTypeFactorSource.lower(factorSource), $0
        )
    })
}

public func fiatCurrencyToJsonString(fiatCurrency: FiatCurrency) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_fiat_currency_to_json_string(
            FfiConverterTypeFiatCurrency.lower(fiatCurrency), $0
        )
    })
}

public func fungibleResourceIndicatorGetAmount(indicator: FungibleResourceIndicator) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_fungible_resource_indicator_get_amount(
            FfiConverterTypeFungibleResourceIndicator.lower(indicator), $0
        )
    })
}

public func gatewayId(gateway: Gateway) -> Url {
    return try! FfiConverterTypeUrl.lift(try! rustCall {
        uniffi_sargon_fn_func_gateway_id(
            FfiConverterTypeGateway.lower(gateway), $0
        )
    })
}

public func gatewayIsWellknown(gateway: Gateway) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_gateway_is_wellknown(
            FfiConverterTypeGateway.lower(gateway), $0
        )
    })
}

public func gatewayMainnet() -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_gateway_mainnet($0
        )
    })
}

public func gatewayStokenet() -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_gateway_stokenet($0
        )
    })
}

public func gatewayToString(gateway: Gateway) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_gateway_to_string(
            FfiConverterTypeGateway.lower(gateway), $0
        )
    })
}

public func gatewayWellknownGateways() -> [Gateway] {
    return try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_gateway_wellknown_gateways($0
        )
    })
}

public func hash(data: BagOfBytes) -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_fn_func_hash(
            FfiConverterTypeBagOfBytes.lower(data), $0
        )
    })
}

public func hashGetBytes(hash: Hash) -> Exactly32Bytes {
    return try! FfiConverterTypeExactly32Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_hash_get_bytes(
            FfiConverterTypeHash.lower(hash), $0
        )
    })
}

public func hdPathComponentGetNonHardenedValue(component: HdPathComponent) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_fn_func_hd_path_component_get_non_hardened_value(
            FfiConverterTypeHDPathComponent.lower(component), $0
        )
    })
}

public func headerToJsonBytes(header: Header) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_header_to_json_bytes(
            FfiConverterTypeHeader.lower(header), $0
        )
    })
}

public func hierarchicalDeterministicPublicKeyIsValidSignatureForHash(key: HierarchicalDeterministicPublicKey, signature: Signature, hash: Hash) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_hierarchical_deterministic_public_key_is_valid_signature_for_hash(
            FfiConverterTypeHierarchicalDeterministicPublicKey.lower(key),
            FfiConverterTypeSignature.lower(signature),
            FfiConverterTypeHash.lower(hash), $0
        )
    })
}

public func identityAddressBech32Address(address: IdentityAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_identity_address_bech32_address(
            FfiConverterTypeIdentityAddress.lower(address), $0
        )
    })
}

public func identityAddressFormatted(address: IdentityAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_identity_address_formatted(
            FfiConverterTypeIdentityAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func identityAddressMapToNetwork(address: IdentityAddress, networkId: NetworkId) -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_identity_address_map_to_network(
            FfiConverterTypeIdentityAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func identityAddressNetworkId(address: IdentityAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_identity_address_network_id(
            FfiConverterTypeIdentityAddress.lower(address), $0
        )
    })
}

public func intentHashFormatted(address: IntentHash, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_intent_hash_formatted(
            FfiConverterTypeIntentHash.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func intentSignatureGetSignatureWithPublicKey(intentSignature: IntentSignature) -> SignatureWithPublicKey {
    return try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_intent_signature_get_signature_with_public_key(
            FfiConverterTypeIntentSignature.lower(intentSignature), $0
        )
    })
}

public func ledgerHwWalletModelToString(model: LedgerHardwareWalletModel) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_ledger_hw_wallet_model_to_string(
            FfiConverterTypeLedgerHardwareWalletModel.lower(model), $0
        )
    })
}

public func legacyOlympiaAccountAddressFormatted(address: LegacyOlympiaAccountAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_legacy_olympia_account_address_formatted(
            FfiConverterTypeLegacyOlympiaAccountAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func legacyOlympiaAccountAddressIsLegacyOfBabylon(legacyOlympiaAddress: LegacyOlympiaAccountAddress, babylonAccountAddress: AccountAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_legacy_olympia_account_address_is_legacy_of_babylon(
            FfiConverterTypeLegacyOlympiaAccountAddress.lower(legacyOlympiaAddress),
            FfiConverterTypeAccountAddress.lower(babylonAccountAddress), $0
        )
    })
}

public func legacyOlympiaAccountAddressToBabylonAccountAddress(address: LegacyOlympiaAccountAddress) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_legacy_olympia_account_address_to_babylon_account_address(
            FfiConverterTypeLegacyOlympiaAccountAddress.lower(address), $0
        )
    })
}

public func legacyOlympiaAccountAddressToString(address: LegacyOlympiaAccountAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_legacy_olympia_account_address_to_string(
            FfiConverterTypeLegacyOlympiaAccountAddress.lower(address), $0
        )
    })
}

public func linkConnectionQRDataToJsonBytes(linkConnectionQRData: LinkConnectionQrData) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_link_connection_q_r_data_to_json_bytes(
            FfiConverterTypeLinkConnectionQRData.lower(linkConnectionQRData), $0
        )
    })
}

public func manifestCreateFungibleToken(addressOfOwner: AccountAddress) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_create_fungible_token(
            FfiConverterTypeAccountAddress.lower(addressOfOwner), $0
        )
    })
}

public func manifestCreateFungibleTokenWithMetadata(addressOfOwner: AccountAddress, initialSupply: Decimal192, metadata: TokenDefinitionMetadata) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_create_fungible_token_with_metadata(
            FfiConverterTypeAccountAddress.lower(addressOfOwner),
            FfiConverterTypeDecimal192.lower(initialSupply),
            FfiConverterTypeTokenDefinitionMetadata.lower(metadata), $0
        )
    })
}

/**
 * Creates many fungible tokens, with initial supply, to be owned by `address_of_owner`.
 *
 * # Panics
 * Panics if `address_of_owner` is on `Mainnet`, use a testnet instead.
 * Panics if `count` is zero or is greater than the number of token metadata defined in `sample_resource_definition_metadata` (25)
 */
public func manifestCreateMultipleFungibleTokens(addressOfOwner: AccountAddress, count: UInt8?) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_create_multiple_fungible_tokens(
            FfiConverterTypeAccountAddress.lower(addressOfOwner),
            FfiConverterOptionUInt8.lower(count), $0
        )
    })
}

public func manifestCreateMultipleNonFungibleTokens(addressOfOwner: AccountAddress, collectionCount: UInt8?, nftsPerCollection: UInt8?) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_create_multiple_non_fungible_tokens(
            FfiConverterTypeAccountAddress.lower(addressOfOwner),
            FfiConverterOptionUInt8.lower(collectionCount),
            FfiConverterOptionUInt8.lower(nftsPerCollection), $0
        )
    })
}

public func manifestCreateNonFungibleToken(addressOfOwner: AccountAddress, nftsPerCollection: UInt8?) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_create_non_fungible_token(
            FfiConverterTypeAccountAddress.lower(addressOfOwner),
            FfiConverterOptionUInt8.lower(nftsPerCollection), $0
        )
    })
}

public func manifestForFaucet(includeLockFeeInstruction: Bool, addressOfReceivingAccount: AccountAddress) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_for_faucet(
            FfiConverterBool.lower(includeLockFeeInstruction),
            FfiConverterTypeAccountAddress.lower(addressOfReceivingAccount), $0
        )
    })
}

public func manifestMarkingAccountAsDappDefinitionType(accountAddress: AccountAddress) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_marking_account_as_dapp_definition_type(
            FfiConverterTypeAccountAddress.lower(accountAddress), $0
        )
    })
}

public func manifestPerAssetTransfers(transfers: PerAssetTransfers) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_per_asset_transfers(
            FfiConverterTypePerAssetTransfers.lower(transfers), $0
        )
    })
}

/**
 * Uses `per_asset_transfers` after having transposed the `PerRecipientAssetTransfers`
 * into `PerAssetTransfers`. We always use `PerAssetTransfers` when building the manifest
 * since it is more efficient (allows a single withdraw per resource) => fewer instruction =>
 * cheaper TX fee for user.
 */
public func manifestPerRecipientTransfers(transfers: PerRecipientAssetTransfers) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_per_recipient_transfers(
            FfiConverterTypePerRecipientAssetTransfers.lower(transfers), $0
        )
    })
}

public func manifestSetOwnerKeysHashes(addressOfAccountOrPersona: AddressOfAccountOrPersona, ownerKeyHashes: [PublicKeyHash]) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_set_owner_keys_hashes(
            FfiConverterTypeAddressOfAccountOrPersona.lower(addressOfAccountOrPersona),
            FfiConverterSequenceTypePublicKeyHash.lower(ownerKeyHashes), $0
        )
    })
}

public func manifestStakesClaim(accountAddress: AccountAddress, stakeClaims: [StakeClaim]) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_stakes_claim(
            FfiConverterTypeAccountAddress.lower(accountAddress),
            FfiConverterSequenceTypeStakeClaim.lower(stakeClaims), $0
        )
    })
}

public func manifestThirdPartyDepositUpdate(accountAddress: AccountAddress, from: ThirdPartyDeposits, to: ThirdPartyDeposits) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_third_party_deposit_update(
            FfiConverterTypeAccountAddress.lower(accountAddress),
            FfiConverterTypeThirdPartyDeposits.lower(from),
            FfiConverterTypeThirdPartyDeposits.lower(to), $0
        )
    })
}

public func messageAsPlaintext(message: Message) -> String? {
    return try! FfiConverterOptionString.lift(try! rustCall {
        uniffi_sargon_fn_func_message_as_plaintext(
            FfiConverterTypeMessage.lower(message), $0
        )
    })
}

/**
 * Returns the words of a mnemonic as a String joined by spaces, e.g. "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong"
 */
public func mnemonicPhrase(from: Mnemonic) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_mnemonic_phrase(
            FfiConverterTypeMnemonic.lower(from), $0
        )
    })
}

public func mnemonicWithPassphraseDerivePublicKeys(mnemonicWithPassphrase: MnemonicWithPassphrase, derivationPaths: [DerivationPath]) -> [HierarchicalDeterministicPublicKey] {
    return try! FfiConverterSequenceTypeHierarchicalDeterministicPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_mnemonic_with_passphrase_derive_public_keys(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterSequenceTypeDerivationPath.lower(derivationPaths), $0
        )
    })
}

public func mnemonicWithPassphraseSign(mnemonicWithPassphrase: MnemonicWithPassphrase, derivationPath: DerivationPath, hashToSign: Hash) -> SignatureWithPublicKey {
    return try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_mnemonic_with_passphrase_sign(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeDerivationPath.lower(derivationPath),
            FfiConverterTypeHash.lower(hashToSign), $0
        )
    })
}

public func mnemonicWithPassphraseToJsonBytes(mnemonicWithPassphrase: MnemonicWithPassphrase) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_mnemonic_with_passphrase_to_json_bytes(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase), $0
        )
    })
}

/**
 * Returns `true` if this MnemonicWithPassphrase successfully validates all `hd_keys`, that is to say,
 * that all the HierarchicalDeterministicPublicKey were indeed crated by this MnemonicWithPassphrase.
 */
public func mnemonicWithPassphraseValidatePublicKeys(mnemonicWithPassphrase: MnemonicWithPassphrase, hdKeys: [HierarchicalDeterministicPublicKey]) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_mnemonic_with_passphrase_validate_public_keys(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterSequenceTypeHierarchicalDeterministicPublicKey.lower(hdKeys), $0
        )
    })
}

/**
 * Modifies `manifest` by inserting transaction "guarantees", which is the wallet
 * term for `assert_worktop_contains`.
 *
 * # Panics
 * Panics if any of the TransactionGuarantee's `instruction_index` is out of
 * bounds.
 *
 * Also panics if the number of TransactionGuarantee's is larger than the number
 * of instructions of `manifest` (does not make any sense).
 */
public func modifyManifestAddGuarantees(manifest: TransactionManifest, guarantees: [TransactionGuarantee]) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_modify_manifest_add_guarantees(
            FfiConverterTypeTransactionManifest.lower(manifest),
            FfiConverterSequenceTypeTransactionGuarantee.lower(guarantees), $0
        )
    })
}

public func modifyManifestLockFee(manifest: TransactionManifest, addressOfFeePayer: AccountAddress, fee: Decimal192?) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_modify_manifest_lock_fee(
            FfiConverterTypeTransactionManifest.lower(manifest),
            FfiConverterTypeAccountAddress.lower(addressOfFeePayer),
            FfiConverterOptionTypeDecimal192.lower(fee), $0
        )
    })
}

public func networkIdDiscriminant(id: NetworkId) -> UInt8 {
    return try! FfiConverterUInt8.lift(try! rustCall {
        uniffi_sargon_fn_func_network_id_discriminant(
            FfiConverterTypeNetworkID.lower(id), $0
        )
    })
}

public func networkIdToString(id: NetworkId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_network_id_to_string(
            FfiConverterTypeNetworkID.lower(id), $0
        )
    })
}

public func networkIdsAll() -> [NetworkId] {
    return try! FfiConverterSequenceTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_network_ids_all($0
        )
    })
}

public func newAccessControllerAddress(bech32: String) throws -> AccessControllerAddress {
    return try FfiConverterTypeAccessControllerAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_access_controller_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newAccessControllerAddressRandom(networkId: NetworkId) -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_access_controller_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newAccessControllerAddressSampleMainnet() -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_access_controller_address_sample_mainnet($0
        )
    })
}

public func newAccessControllerAddressSampleMainnetOther() -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_access_controller_address_sample_mainnet_other($0
        )
    })
}

public func newAccessControllerAddressSampleStokenet() -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_access_controller_address_sample_stokenet($0
        )
    })
}

public func newAccessControllerAddressSampleStokenetOther() -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_access_controller_address_sample_stokenet_other($0
        )
    })
}

public func newAccountAddress(bech32: String) throws -> AccountAddress {
    return try FfiConverterTypeAccountAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_account_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

public func newAccountAddressFrom(publicKey: PublicKey, networkId: NetworkId) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_address_from(
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newAccountAddressRandom(networkId: NetworkId) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newAccountAddressSampleMainnet() -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_address_sample_mainnet($0
        )
    })
}

public func newAccountAddressSampleMainnetOther() -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_address_sample_mainnet_other($0
        )
    })
}

public func newAccountAddressSampleStokenet() -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_address_sample_stokenet($0
        )
    })
}

public func newAccountAddressSampleStokenetOther() -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_address_sample_stokenet_other($0
        )
    })
}

public func newAccountForDisplaySample() -> AccountForDisplay {
    return try! FfiConverterTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_for_display_sample($0
        )
    })
}

public func newAccountForDisplaySampleOther() -> AccountForDisplay {
    return try! FfiConverterTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_for_display_sample_other($0
        )
    })
}

public func newAccountOrAddressOfSample() -> AccountOrAddressOf {
    return try! FfiConverterTypeAccountOrAddressOf.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_address_of_sample($0
        )
    })
}

public func newAccountOrAddressOfSampleOther() -> AccountOrAddressOf {
    return try! FfiConverterTypeAccountOrAddressOf.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_address_of_sample_other($0
        )
    })
}

public func newAccountOrPersonaSampleMainnet() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_persona_sample_mainnet($0
        )
    })
}

public func newAccountOrPersonaSampleMainnetOther() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_persona_sample_mainnet_other($0
        )
    })
}

public func newAccountOrPersonaSampleMainnetThird() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_persona_sample_mainnet_third($0
        )
    })
}

public func newAccountOrPersonaSampleStokenet() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_persona_sample_stokenet($0
        )
    })
}

public func newAccountOrPersonaSampleStokenetOther() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_persona_sample_stokenet_other($0
        )
    })
}

public func newAccountOrPersonaSampleStokenetThird() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_persona_sample_stokenet_third($0
        )
    })
}

public func newAccountPath(networkId: NetworkId, keyKind: Cap26KeyKind, index: UInt32) -> AccountPath {
    return try! FfiConverterTypeAccountPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_path(
            FfiConverterTypeNetworkID.lower(networkId),
            FfiConverterTypeCAP26KeyKind.lower(keyKind),
            FfiConverterUInt32.lower(index), $0
        )
    })
}

public func newAccountPathSample() -> AccountPath {
    return try! FfiConverterTypeAccountPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_path_sample($0
        )
    })
}

public func newAccountPathSampleOther() -> AccountPath {
    return try! FfiConverterTypeAccountPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_path_sample_other($0
        )
    })
}

public func newAccountSampleMainnetAlice() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_mainnet_alice($0
        )
    })
}

public func newAccountSampleMainnetBob() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_mainnet_bob($0
        )
    })
}

public func newAccountSampleMainnetCarol() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_mainnet_carol($0
        )
    })
}

public func newAccountSampleMainnetDiana() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_mainnet_diana($0
        )
    })
}

public func newAccountSampleStokenetNadia() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_stokenet_nadia($0
        )
    })
}

public func newAccountSampleStokenetOlivia() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_stokenet_olivia($0
        )
    })
}

public func newAccountSampleStokenetPaige() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_stokenet_paige($0
        )
    })
}

public func newAccountsForDisplaySample() -> [AccountForDisplay] {
    return try! FfiConverterSequenceTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_fn_func_new_accounts_for_display_sample($0
        )
    })
}

public func newAccountsForDisplaySampleOther() -> [AccountForDisplay] {
    return try! FfiConverterSequenceTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_fn_func_new_accounts_for_display_sample_other($0
        )
    })
}

public func newAccountsOrPersonasSample() -> [AccountOrPersona] {
    return try! FfiConverterSequenceTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_accounts_or_personas_sample($0
        )
    })
}

public func newAccountsOrPersonasSampleOther() -> [AccountOrPersona] {
    return try! FfiConverterSequenceTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_accounts_or_personas_sample_other($0
        )
    })
}

public func newAccountsSample() -> [Account] {
    return try! FfiConverterSequenceTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_accounts_sample($0
        )
    })
}

public func newAccountsSampleOther() -> [Account] {
    return try! FfiConverterSequenceTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_accounts_sample_other($0
        )
    })
}

public func newAddressFromBech32(string: String) throws -> Address {
    return try FfiConverterTypeAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_address_from_bech32(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newAddressOfAccountOrPersonaFromBech32(string: String) throws -> AddressOfAccountOrPersona {
    return try FfiConverterTypeAddressOfAccountOrPersona.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_from_bech32(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleAccountMainnet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_account_mainnet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleAccountMainnetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_account_mainnet_other($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleAccountStokenet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_account_stokenet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleAccountStokenetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_account_stokenet_other($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleIdentityMainnet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_identity_mainnet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleIdentityMainnetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_identity_mainnet_other($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleIdentityStokenet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_identity_stokenet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleIdentityStokenetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_identity_stokenet_other($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleMainnet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_mainnet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleMainnetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_mainnet_other($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleStokenet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_stokenet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleStokenetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_stokenet_other($0
        )
    })
}

public func newAddressSampleAccessControllerMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_access_controller_mainnet($0
        )
    })
}

public func newAddressSampleAccessControllerMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_access_controller_mainnet_other($0
        )
    })
}

public func newAddressSampleAccessControllerStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_access_controller_stokenet($0
        )
    })
}

public func newAddressSampleAccessControllerStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_access_controller_stokenet_other($0
        )
    })
}

public func newAddressSampleAccountMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_account_mainnet($0
        )
    })
}

public func newAddressSampleAccountMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_account_mainnet_other($0
        )
    })
}

public func newAddressSampleAccountStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_account_stokenet($0
        )
    })
}

public func newAddressSampleAccountStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_account_stokenet_other($0
        )
    })
}

public func newAddressSampleComponentMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_component_mainnet($0
        )
    })
}

public func newAddressSampleComponentMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_component_mainnet_other($0
        )
    })
}

public func newAddressSampleComponentStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_component_stokenet($0
        )
    })
}

public func newAddressSampleComponentStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_component_stokenet_other($0
        )
    })
}

public func newAddressSampleIdentityMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_identity_mainnet($0
        )
    })
}

public func newAddressSampleIdentityMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_identity_mainnet_other($0
        )
    })
}

public func newAddressSampleIdentityStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_identity_stokenet($0
        )
    })
}

public func newAddressSampleIdentityStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_identity_stokenet_other($0
        )
    })
}

public func newAddressSampleMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_mainnet($0
        )
    })
}

public func newAddressSampleMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_mainnet_other($0
        )
    })
}

public func newAddressSamplePackageMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_package_mainnet($0
        )
    })
}

public func newAddressSamplePackageMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_package_mainnet_other($0
        )
    })
}

public func newAddressSamplePackageStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_package_stokenet($0
        )
    })
}

public func newAddressSamplePackageStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_package_stokenet_other($0
        )
    })
}

public func newAddressSamplePoolMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_pool_mainnet($0
        )
    })
}

public func newAddressSamplePoolMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_pool_mainnet_other($0
        )
    })
}

public func newAddressSamplePoolStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_pool_stokenet($0
        )
    })
}

public func newAddressSamplePoolStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_pool_stokenet_other($0
        )
    })
}

public func newAddressSampleResourceMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_resource_mainnet($0
        )
    })
}

public func newAddressSampleResourceMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_resource_mainnet_other($0
        )
    })
}

public func newAddressSampleResourceStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_resource_stokenet($0
        )
    })
}

public func newAddressSampleResourceStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_resource_stokenet_other($0
        )
    })
}

public func newAddressSampleStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_stokenet($0
        )
    })
}

public func newAddressSampleStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_stokenet_other($0
        )
    })
}

public func newAddressSampleValidatorMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_validator_mainnet($0
        )
    })
}

public func newAddressSampleValidatorMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_validator_mainnet_other($0
        )
    })
}

public func newAddressSampleValidatorStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_validator_stokenet($0
        )
    })
}

public func newAddressSampleValidatorStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_validator_stokenet_other($0
        )
    })
}

public func newAddressSampleVaultMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_vault_mainnet($0
        )
    })
}

public func newAddressSampleVaultMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_vault_mainnet_other($0
        )
    })
}

public func newAddressSampleVaultStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_vault_stokenet($0
        )
    })
}

public func newAddressSampleVaultStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_vault_stokenet_other($0
        )
    })
}

public func newAppPreferencesDefault() -> AppPreferences {
    return try! FfiConverterTypeAppPreferences.lift(try! rustCall {
        uniffi_sargon_fn_func_new_app_preferences_default($0
        )
    })
}

public func newAppPreferencesSample() -> AppPreferences {
    return try! FfiConverterTypeAppPreferences.lift(try! rustCall {
        uniffi_sargon_fn_func_new_app_preferences_sample($0
        )
    })
}

public func newAppPreferencesSampleOther() -> AppPreferences {
    return try! FfiConverterTypeAppPreferences.lift(try! rustCall {
        uniffi_sargon_fn_func_new_app_preferences_sample_other($0
        )
    })
}

public func newAppearanceId(validating: UInt8) throws -> AppearanceId {
    return try FfiConverterTypeAppearanceID.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_appearance_id(
            FfiConverterUInt8.lower(validating), $0
        )
    })
}

public func newAppearanceIdFromNumberOfAccountsOnNetwork(count: UInt64) -> AppearanceId {
    return try! FfiConverterTypeAppearanceID.lift(try! rustCall {
        uniffi_sargon_fn_func_new_appearance_id_from_number_of_accounts_on_network(
            FfiConverterUInt64.lower(count), $0
        )
    })
}

public func newAppearanceIdSample() -> AppearanceId {
    return try! FfiConverterTypeAppearanceID.lift(try! rustCall {
        uniffi_sargon_fn_func_new_appearance_id_sample($0
        )
    })
}

public func newAppearanceIdSampleOther() -> AppearanceId {
    return try! FfiConverterTypeAppearanceID.lift(try! rustCall {
        uniffi_sargon_fn_func_new_appearance_id_sample_other($0
        )
    })
}

public func newAssetExceptionSample() -> AssetException {
    return try! FfiConverterTypeAssetException.lift(try! rustCall {
        uniffi_sargon_fn_func_new_asset_exception_sample($0
        )
    })
}

public func newAssetExceptionSampleOther() -> AssetException {
    return try! FfiConverterTypeAssetException.lift(try! rustCall {
        uniffi_sargon_fn_func_new_asset_exception_sample_other($0
        )
    })
}

public func newAssetsExceptionListSample() -> [AssetException] {
    return try! FfiConverterSequenceTypeAssetException.lift(try! rustCall {
        uniffi_sargon_fn_func_new_assets_exception_list_sample($0
        )
    })
}

public func newAssetsExceptionListSampleOther() -> [AssetException] {
    return try! FfiConverterSequenceTypeAssetException.lift(try! rustCall {
        uniffi_sargon_fn_func_new_assets_exception_list_sample_other($0
        )
    })
}

public func newAuthorizedDappDetailedSample() -> AuthorizedDappDetailed {
    return try! FfiConverterTypeAuthorizedDappDetailed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapp_detailed_sample($0
        )
    })
}

public func newAuthorizedDappDetailedSampleOther() -> AuthorizedDappDetailed {
    return try! FfiConverterTypeAuthorizedDappDetailed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapp_detailed_sample_other($0
        )
    })
}

public func newAuthorizedDappFromJsonBytes(jsonBytes: BagOfBytes) throws -> AuthorizedDapp {
    return try FfiConverterTypeAuthorizedDapp.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_authorized_dapp_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newAuthorizedDappSampleMainnetDashboard() -> AuthorizedDapp {
    return try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapp_sample_mainnet_dashboard($0
        )
    })
}

public func newAuthorizedDappSampleMainnetGumballclub() -> AuthorizedDapp {
    return try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapp_sample_mainnet_gumballclub($0
        )
    })
}

public func newAuthorizedDappSampleStokenetDevconsole() -> AuthorizedDapp {
    return try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapp_sample_stokenet_devconsole($0
        )
    })
}

public func newAuthorizedDappSampleStokenetSandbox() -> AuthorizedDapp {
    return try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapp_sample_stokenet_sandbox($0
        )
    })
}

public func newAuthorizedDappsSample() -> [AuthorizedDapp] {
    return try! FfiConverterSequenceTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapps_sample($0
        )
    })
}

public func newAuthorizedDappsSampleOther() -> [AuthorizedDapp] {
    return try! FfiConverterSequenceTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapps_sample_other($0
        )
    })
}

public func newAuthorizedPersonaDetailedSample() -> AuthorizedPersonaDetailed {
    return try! FfiConverterTypeAuthorizedPersonaDetailed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_persona_detailed_sample($0
        )
    })
}

public func newAuthorizedPersonaDetailedSampleOther() -> AuthorizedPersonaDetailed {
    return try! FfiConverterTypeAuthorizedPersonaDetailed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_persona_detailed_sample_other($0
        )
    })
}

public func newAuthorizedPersonaSimpleSampleMainnet() -> AuthorizedPersonaSimple {
    return try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_persona_simple_sample_mainnet($0
        )
    })
}

public func newAuthorizedPersonaSimpleSampleMainnetOther() -> AuthorizedPersonaSimple {
    return try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_persona_simple_sample_mainnet_other($0
        )
    })
}

public func newAuthorizedPersonaSimpleSampleStokenet() -> AuthorizedPersonaSimple {
    return try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_persona_simple_sample_stokenet($0
        )
    })
}

public func newAuthorizedPersonaSimpleSampleStokenetOther() -> AuthorizedPersonaSimple {
    return try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_persona_simple_sample_stokenet_other($0
        )
    })
}

public func newBIP39SeedFromBytes(bytes: BagOfBytes) throws -> Bip39Seed {
    return try FfiConverterTypeBIP39Seed.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_b_i_p39_seed_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newBIP39SeedSample() -> Bip39Seed {
    return try! FfiConverterTypeBIP39Seed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_b_i_p39_seed_sample($0
        )
    })
}

public func newBIP39SeedSampleOther() -> Bip39Seed {
    return try! FfiConverterTypeBIP39Seed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_b_i_p39_seed_sample_other($0
        )
    })
}

public func newBagOfBytesFrom(bytes: Data) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_from(
            FfiConverterData.lower(bytes), $0
        )
    })
}

public func newBagOfBytesSampleAced() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_sample_aced($0
        )
    })
}

public func newBagOfBytesSampleBabe() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_sample_babe($0
        )
    })
}

public func newBagOfBytesSampleCafe() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_sample_cafe($0
        )
    })
}

public func newBagOfBytesSampleDead() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_sample_dead($0
        )
    })
}

public func newBagOfBytesSampleEcad() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_sample_ecad($0
        )
    })
}

public func newBagOfBytesSampleFade() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_sample_fade($0
        )
    })
}

public func newBip39LanguageSample() -> Bip39Language {
    return try! FfiConverterTypeBIP39Language.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip39_language_sample($0
        )
    })
}

public func newBip39LanguageSampleOther() -> Bip39Language {
    return try! FfiConverterTypeBIP39Language.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip39_language_sample_other($0
        )
    })
}

public func newBip39WordSample() -> Bip39Word {
    return try! FfiConverterTypeBIP39Word.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip39_word_sample($0
        )
    })
}

public func newBip39WordSampleOther() -> Bip39Word {
    return try! FfiConverterTypeBIP39Word.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip39_word_sample_other($0
        )
    })
}

public func newBip44LikePathFromIndex(index: UInt32) -> Bip44LikePath {
    return try! FfiConverterTypeBIP44LikePath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip44_like_path_from_index(
            FfiConverterUInt32.lower(index), $0
        )
    })
}

public func newBip44LikePathFromString(string: String) throws -> Bip44LikePath {
    return try FfiConverterTypeBIP44LikePath.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_bip44_like_path_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newBip44LikePathSample() -> Bip44LikePath {
    return try! FfiConverterTypeBIP44LikePath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip44_like_path_sample($0
        )
    })
}

public func newBip44LikePathSampleOther() -> Bip44LikePath {
    return try! FfiConverterTypeBIP44LikePath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip44_like_path_sample_other($0
        )
    })
}

public func newBlobFromBytes(bytes: BagOfBytes) -> Blob {
    return try! FfiConverterTypeBlob.lift(try! rustCall {
        uniffi_sargon_fn_func_new_blob_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newBlobsFromBlobList(blobs: [Blob]) -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_fn_func_new_blobs_from_blob_list(
            FfiConverterSequenceTypeBlob.lower(blobs), $0
        )
    })
}

public func newBlobsSample() -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_fn_func_new_blobs_sample($0
        )
    })
}

public func newBlobsSampleOther() -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_fn_func_new_blobs_sample_other($0
        )
    })
}

public func newCap26PathFromString(string: String) throws -> Cap26Path {
    return try FfiConverterTypeCAP26Path.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_cap26_path_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newCompiledNotarizedIntentSample() -> CompiledNotarizedIntent {
    return try! FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_new_compiled_notarized_intent_sample($0
        )
    })
}

public func newCompiledNotarizedIntentSampleOther() -> CompiledNotarizedIntent {
    return try! FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_new_compiled_notarized_intent_sample_other($0
        )
    })
}

public func newComponentAddress(bech32: String) throws -> ComponentAddress {
    return try FfiConverterTypeComponentAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_component_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newComponentAddressRandom(networkId: NetworkId) -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_component_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Sample to a mainnet ComponentAddress (global)
 */
public func newComponentAddressSampleMainnetGlobal() -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_component_address_sample_mainnet_global($0
        )
    })
}

/**
 * Sample to a mainnet ComponentAddress (internal)
 */
public func newComponentAddressSampleMainnetInternal() -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_component_address_sample_mainnet_internal($0
        )
    })
}

/**
 * Sample to a stokenet ComponentAddress (global)
 */
public func newComponentAddressSampleStokenetGlobal() -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_component_address_sample_stokenet_global($0
        )
    })
}

/**
 * Sample to a stokenet ComponentAddress (internal)
 */
public func newComponentAddressSampleStokenetInternal() -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_component_address_sample_stokenet_internal($0
        )
    })
}

public func newDappToWalletInteractionUnvalidatedFromJsonBytes(jsonBytes: BagOfBytes) throws -> DappToWalletInteractionUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionUnvalidated.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_dapp_to_wallet_interaction_unvalidated_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newDappToWalletInteractionUnvalidatedSample() -> DappToWalletInteractionUnvalidated {
    return try! FfiConverterTypeDappToWalletInteractionUnvalidated.lift(try! rustCall {
        uniffi_sargon_fn_func_new_dapp_to_wallet_interaction_unvalidated_sample($0
        )
    })
}

public func newDappToWalletInteractionUnvalidatedSampleOther() -> DappToWalletInteractionUnvalidated {
    return try! FfiConverterTypeDappToWalletInteractionUnvalidated.lift(try! rustCall {
        uniffi_sargon_fn_func_new_dapp_to_wallet_interaction_unvalidated_sample_other($0
        )
    })
}

/**
 * Creates the Decimal192 `10^exponent`
 */
public func newDecimalExponent(exponent: UInt8) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_new_decimal_exponent(
            FfiConverterUInt8.lower(exponent), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a f32 float. Will
 * fail if the f32 cannot be losslessly represented
 * by the underlying Decimal from Scrypto.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert!(new_decimal_from_f32(208050.17).to_string() == "208050.17");
 *
 * assert!(new_decimal_from_f32(f32::MIN_POSITIVE).to_string() == "0");
 * ```
 */
public func newDecimalFromF32(value: Float) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_new_decimal_from_f32(
            FfiConverterFloat.lower(value), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a f64 float. Will
 * fail if the f64 cannot be losslessly represented
 * by the underlying Decimal from Scrypto.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert!(new_decimal_from_f64(208050.17).is_ok());
 *
 * assert!(new_decimal_from_f64(f64::MIN_POSITIVE).is_ok());
 * ```
 */
public func newDecimalFromF64(value: Double) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_decimal_from_f64(
            FfiConverterDouble.lower(value), $0
        )
    })
}

/**
 * Tries to creates a new `Decimal192` from a formatted String for
 * a specific locale.
 */
public func newDecimalFromFormattedString(formattedString: String, locale: LocaleConfig) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_decimal_from_formatted_string(
            FfiConverterString.lower(formattedString),
            FfiConverterTypeLocaleConfig.lower(locale), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a i32 integer.
 */
public func newDecimalFromI32(value: Int32) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_new_decimal_from_i32(
            FfiConverterInt32.lower(value), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a i64 integer.
 */
public func newDecimalFromI64(value: Int64) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_new_decimal_from_i64(
            FfiConverterInt64.lower(value), $0
        )
    })
}

/**
 * Tries to creates a new `Decimal192` from a String, throws a `CommonError`
 * if the `string` was not a valid Decimal192.
 */
public func newDecimalFromString(string: String) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_decimal_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a u32 integer.
 */
public func newDecimalFromU32(value: UInt32) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_new_decimal_from_u32(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a u64 integer.
 */
public func newDecimalFromU64(value: UInt64) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_new_decimal_from_u64(
            FfiConverterUInt64.lower(value), $0
        )
    })
}

public func newDependencyInformationSample() -> DependencyInformation {
    return try! FfiConverterTypeDependencyInformation.lift(try! rustCall {
        uniffi_sargon_fn_func_new_dependency_information_sample($0
        )
    })
}

public func newDependencyInformationSampleOther() -> DependencyInformation {
    return try! FfiConverterTypeDependencyInformation.lift(try! rustCall {
        uniffi_sargon_fn_func_new_dependency_information_sample_other($0
        )
    })
}

public func newDepositRuleFromJsonString(jsonString: String) throws -> DepositRule {
    return try FfiConverterTypeDepositRule.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_deposit_rule_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newDepositRuleSample() -> DepositRule {
    return try! FfiConverterTypeDepositRule.lift(try! rustCall {
        uniffi_sargon_fn_func_new_deposit_rule_sample($0
        )
    })
}

public func newDepositRuleSampleOther() -> DepositRule {
    return try! FfiConverterTypeDepositRule.lift(try! rustCall {
        uniffi_sargon_fn_func_new_deposit_rule_sample_other($0
        )
    })
}

public func newDepositorsAllowListSample() -> [ResourceOrNonFungible] {
    return try! FfiConverterSequenceTypeResourceOrNonFungible.lift(try! rustCall {
        uniffi_sargon_fn_func_new_depositors_allow_list_sample($0
        )
    })
}

public func newDepositorsAllowListSampleOther() -> [ResourceOrNonFungible] {
    return try! FfiConverterSequenceTypeResourceOrNonFungible.lift(try! rustCall {
        uniffi_sargon_fn_func_new_depositors_allow_list_sample_other($0
        )
    })
}

public func newDerivationPathFromString(string: String) throws -> DerivationPath {
    return try FfiConverterTypeDerivationPath.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_derivation_path_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newDerivationPathSample() -> DerivationPath {
    return try! FfiConverterTypeDerivationPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_derivation_path_sample($0
        )
    })
}

public func newDerivationPathSampleOther() -> DerivationPath {
    return try! FfiConverterTypeDerivationPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_derivation_path_sample_other($0
        )
    })
}

public func newDetailedAuthorizedPersonasSample() -> [AuthorizedPersonaDetailed] {
    return try! FfiConverterSequenceTypeAuthorizedPersonaDetailed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_detailed_authorized_personas_sample($0
        )
    })
}

public func newDetailedAuthorizedPersonasSampleOther() -> [AuthorizedPersonaDetailed] {
    return try! FfiConverterSequenceTypeAuthorizedPersonaDetailed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_detailed_authorized_personas_sample_other($0
        )
    })
}

public func newDeviceFactorSourceBabylon(isMain: Bool, mnemonicWithPassphrase: MnemonicWithPassphrase, walletClientModel: WalletClientModel) -> DeviceFactorSource {
    return try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_factor_source_babylon(
            FfiConverterBool.lower(isMain),
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeWalletClientModel.lower(walletClientModel), $0
        )
    })
}

public func newDeviceFactorSourceOlympia(mnemonicWithPassphrase: MnemonicWithPassphrase, walletClientModel: WalletClientModel) -> DeviceFactorSource {
    return try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_factor_source_olympia(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeWalletClientModel.lower(walletClientModel), $0
        )
    })
}

public func newDeviceFactorSourceSample() -> DeviceFactorSource {
    return try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_factor_source_sample($0
        )
    })
}

public func newDeviceFactorSourceSampleOther() -> DeviceFactorSource {
    return try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_factor_source_sample_other($0
        )
    })
}

public func newDeviceInfoFromJsonBytes(jsonBytes: BagOfBytes) throws -> DeviceInfo {
    return try FfiConverterTypeDeviceInfo.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_device_info_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

/**
 * Instantiates a new `DeviceInfo` with "iPhone" as description, and
 * generates a new `id` and will use the current `date` for creation date.
 */
public func newDeviceInfoIphone() -> DeviceInfo {
    return try! FfiConverterTypeDeviceInfo.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_info_iphone($0
        )
    })
}

public func newDeviceInfoSample() -> DeviceInfo {
    return try! FfiConverterTypeDeviceInfo.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_info_sample($0
        )
    })
}

public func newDeviceInfoSampleOther() -> DeviceInfo {
    return try! FfiConverterTypeDeviceInfo.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_info_sample_other($0
        )
    })
}

public func newDisplayName(name: String) throws -> DisplayName {
    return try FfiConverterTypeDisplayName.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_display_name(
            FfiConverterString.lower(name), $0
        )
    })
}

public func newDisplayNameFromJsonString(jsonString: String) throws -> DisplayName {
    return try FfiConverterTypeDisplayName.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_display_name_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newDisplayNameSample() -> DisplayName {
    return try! FfiConverterTypeDisplayName.lift(try! rustCall {
        uniffi_sargon_fn_func_new_display_name_sample($0
        )
    })
}

public func newDisplayNameSampleOther() -> DisplayName {
    return try! FfiConverterTypeDisplayName.lift(try! rustCall {
        uniffi_sargon_fn_func_new_display_name_sample_other($0
        )
    })
}

public func newEd25519PublicKeyFromBytes(bytes: BagOfBytes) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_ed25519_public_key_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEd25519PublicKeyFromHex(hex: String) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_ed25519_public_key_from_hex(
            FfiConverterString.lower(hex), $0
        )
    })
}

public func newEd25519PublicKeyFromJsonString(jsonString: String) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_ed25519_public_key_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newEd25519PublicKeySample() -> Ed25519PublicKey {
    return try! FfiConverterTypeEd25519PublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ed25519_public_key_sample($0
        )
    })
}

public func newEd25519PublicKeySampleOther() -> Ed25519PublicKey {
    return try! FfiConverterTypeEd25519PublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ed25519_public_key_sample_other($0
        )
    })
}

public func newEd25519SignatureFromBytes(bytes: BagOfBytes) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_ed25519_signature_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEd25519SignatureFromExactly64Bytes(bytes: Exactly64Bytes) -> Ed25519Signature {
    return try! FfiConverterTypeEd25519Signature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ed25519_signature_from_exactly_64_bytes(
            FfiConverterTypeExactly64Bytes.lower(bytes), $0
        )
    })
}

public func newEd25519SignatureFromJsonString(jsonString: String) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_ed25519_signature_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newEd25519SignatureSample() -> Ed25519Signature {
    return try! FfiConverterTypeEd25519Signature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ed25519_signature_sample($0
        )
    })
}

public func newEd25519SignatureSampleOther() -> Ed25519Signature {
    return try! FfiConverterTypeEd25519Signature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ed25519_signature_sample_other($0
        )
    })
}

public func newEntityFlagSample() -> EntityFlag {
    return try! FfiConverterTypeEntityFlag.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entity_flag_sample($0
        )
    })
}

public func newEntityFlagSampleOther() -> EntityFlag {
    return try! FfiConverterTypeEntityFlag.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entity_flag_sample_other($0
        )
    })
}

public func newEntityFlagsSample() -> [EntityFlag] {
    return try! FfiConverterSequenceTypeEntityFlag.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entity_flags_sample($0
        )
    })
}

public func newEntityFlagsSampleOther() -> [EntityFlag] {
    return try! FfiConverterSequenceTypeEntityFlag.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entity_flags_sample_other($0
        )
    })
}

public func newEntitySecurityStateSample() -> EntitySecurityState {
    return try! FfiConverterTypeEntitySecurityState.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entity_security_state_sample($0
        )
    })
}

public func newEntitySecurityStateSampleOther() -> EntitySecurityState {
    return try! FfiConverterTypeEntitySecurityState.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entity_security_state_sample_other($0
        )
    })
}

public func newEntropy16BytesFromBytes(bytes: BagOfBytes) throws -> Entropy16Bytes {
    return try FfiConverterTypeEntropy16Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_entropy16_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy16BytesSample() -> Entropy16Bytes {
    return try! FfiConverterTypeEntropy16Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy16_bytes_sample($0
        )
    })
}

public func newEntropy16BytesSampleOther() -> Entropy16Bytes {
    return try! FfiConverterTypeEntropy16Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy16_bytes_sample_other($0
        )
    })
}

public func newEntropy20BytesFromBytes(bytes: BagOfBytes) throws -> Entropy20Bytes {
    return try FfiConverterTypeEntropy20Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_entropy20_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy20BytesSample() -> Entropy20Bytes {
    return try! FfiConverterTypeEntropy20Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy20_bytes_sample($0
        )
    })
}

public func newEntropy20BytesSampleOther() -> Entropy20Bytes {
    return try! FfiConverterTypeEntropy20Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy20_bytes_sample_other($0
        )
    })
}

public func newEntropy24BytesFromBytes(bytes: BagOfBytes) throws -> Entropy24Bytes {
    return try FfiConverterTypeEntropy24Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_entropy24_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy24BytesSample() -> Entropy24Bytes {
    return try! FfiConverterTypeEntropy24Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy24_bytes_sample($0
        )
    })
}

public func newEntropy24BytesSampleOther() -> Entropy24Bytes {
    return try! FfiConverterTypeEntropy24Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy24_bytes_sample_other($0
        )
    })
}

public func newEntropy28BytesFromBytes(bytes: BagOfBytes) throws -> Entropy28Bytes {
    return try FfiConverterTypeEntropy28Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_entropy28_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy28BytesSample() -> Entropy28Bytes {
    return try! FfiConverterTypeEntropy28Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy28_bytes_sample($0
        )
    })
}

public func newEntropy28BytesSampleOther() -> Entropy28Bytes {
    return try! FfiConverterTypeEntropy28Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy28_bytes_sample_other($0
        )
    })
}

public func newEntropy32BytesFromBytes(bytes: BagOfBytes) throws -> Entropy32Bytes {
    return try FfiConverterTypeEntropy32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_entropy32_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy32BytesSample() -> Entropy32Bytes {
    return try! FfiConverterTypeEntropy32Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy32_bytes_sample($0
        )
    })
}

public func newEntropy32BytesSampleOther() -> Entropy32Bytes {
    return try! FfiConverterTypeEntropy32Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy32_bytes_sample_other($0
        )
    })
}

public func newExactly12BytesFromJsonString(jsonString: String) throws -> Exactly12Bytes {
    return try FfiConverterTypeExactly12Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly12_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly29BytesFromJsonString(jsonString: String) throws -> Exactly29Bytes {
    return try FfiConverterTypeExactly29Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly29_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly32BytesFromJsonString(jsonString: String) throws -> Exactly32Bytes {
    return try FfiConverterTypeExactly32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly32_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly33BytesFromJsonString(jsonString: String) throws -> Exactly33Bytes {
    return try FfiConverterTypeExactly33Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly33_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly64BytesFromJsonString(jsonString: String) throws -> Exactly64Bytes {
    return try FfiConverterTypeExactly64Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly64_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly65BytesFromJsonString(jsonString: String) throws -> Exactly65Bytes {
    return try FfiConverterTypeExactly65Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly65_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly12Bytes(bytes: BagOfBytes) throws -> Exactly12Bytes {
    return try FfiConverterTypeExactly12Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_12_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly12BytesSample() -> Exactly12Bytes {
    return try! FfiConverterTypeExactly12Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_12_bytes_sample($0
        )
    })
}

public func newExactly12BytesSampleOther() -> Exactly12Bytes {
    return try! FfiConverterTypeExactly12Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_12_bytes_sample_other($0
        )
    })
}

public func newExactly29Bytes(bytes: BagOfBytes) throws -> Exactly29Bytes {
    return try FfiConverterTypeExactly29Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_29_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly29BytesSample() -> Exactly29Bytes {
    return try! FfiConverterTypeExactly29Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_29_bytes_sample($0
        )
    })
}

public func newExactly29BytesSampleOther() -> Exactly29Bytes {
    return try! FfiConverterTypeExactly29Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_29_bytes_sample_other($0
        )
    })
}

public func newExactly32Bytes(bytes: BagOfBytes) throws -> Exactly32Bytes {
    return try FfiConverterTypeExactly32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_32_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly32BytesSample() -> Exactly32Bytes {
    return try! FfiConverterTypeExactly32Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_32_bytes_sample($0
        )
    })
}

public func newExactly32BytesSampleOther() -> Exactly32Bytes {
    return try! FfiConverterTypeExactly32Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_32_bytes_sample_other($0
        )
    })
}

public func newExactly33Bytes(bytes: BagOfBytes) throws -> Exactly33Bytes {
    return try FfiConverterTypeExactly33Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_33_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly33BytesSample() -> Exactly33Bytes {
    return try! FfiConverterTypeExactly33Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_33_bytes_sample($0
        )
    })
}

public func newExactly33BytesSampleOther() -> Exactly33Bytes {
    return try! FfiConverterTypeExactly33Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_33_bytes_sample_other($0
        )
    })
}

public func newExactly64Bytes(bytes: BagOfBytes) throws -> Exactly64Bytes {
    return try FfiConverterTypeExactly64Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_64_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly64BytesSample() -> Exactly64Bytes {
    return try! FfiConverterTypeExactly64Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_64_bytes_sample($0
        )
    })
}

public func newExactly64BytesSampleOther() -> Exactly64Bytes {
    return try! FfiConverterTypeExactly64Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_64_bytes_sample_other($0
        )
    })
}

public func newExactly65Bytes(bytes: BagOfBytes) throws -> Exactly65Bytes {
    return try FfiConverterTypeExactly65Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_65_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly65BytesSample() -> Exactly65Bytes {
    return try! FfiConverterTypeExactly65Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_65_bytes_sample($0
        )
    })
}

public func newExactly65BytesSampleOther() -> Exactly65Bytes {
    return try! FfiConverterTypeExactly65Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_65_bytes_sample_other($0
        )
    })
}

public func newFactorSourceCryptoParametersPresetBabylonOlympiaCompatible() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_crypto_parameters_preset_babylon_olympia_compatible($0
        )
    })
}

public func newFactorSourceCryptoParametersPresetBabylonOnly() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_crypto_parameters_preset_babylon_only($0
        )
    })
}

public func newFactorSourceCryptoParametersPresetOlympiaOnly() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_crypto_parameters_preset_olympia_only($0
        )
    })
}

public func newFactorSourceCryptoParametersSample() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_crypto_parameters_sample($0
        )
    })
}

public func newFactorSourceCryptoParametersSampleOther() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_crypto_parameters_sample_other($0
        )
    })
}

public func newFactorSourceIDFromAddressFromJsonBytes(jsonBytes: BagOfBytes) throws -> FactorSourceIdFromAddress {
    return try FfiConverterTypeFactorSourceIDFromAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_factor_source_i_d_from_address_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newFactorSourceIDFromHashFromJsonBytes(jsonBytes: BagOfBytes) throws -> FactorSourceIdFromHash {
    return try FfiConverterTypeFactorSourceIDFromHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_factor_source_i_d_from_hash_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newFactorSourceIdFromAddressSample() -> FactorSourceIdFromAddress {
    return try! FfiConverterTypeFactorSourceIDFromAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_from_address_sample($0
        )
    })
}

public func newFactorSourceIdFromAddressSampleOther() -> FactorSourceIdFromAddress {
    return try! FfiConverterTypeFactorSourceIDFromAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_from_address_sample_other($0
        )
    })
}

public func newFactorSourceIdFromHashFromMnemonicWithPassphrase(factorSourceKind: FactorSourceKind, mnemonicWithPassphrase: MnemonicWithPassphrase) -> FactorSourceIdFromHash {
    return try! FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_from_hash_from_mnemonic_with_passphrase(
            FfiConverterTypeFactorSourceKind.lower(factorSourceKind),
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase), $0
        )
    })
}

public func newFactorSourceIdFromHashSample() -> FactorSourceIdFromHash {
    return try! FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_from_hash_sample($0
        )
    })
}

public func newFactorSourceIdFromHashSampleOther() -> FactorSourceIdFromHash {
    return try! FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_from_hash_sample_other($0
        )
    })
}

public func newFactorSourceIdSample() -> FactorSourceId {
    return try! FfiConverterTypeFactorSourceID.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_sample($0
        )
    })
}

public func newFactorSourceIdSampleOther() -> FactorSourceId {
    return try! FfiConverterTypeFactorSourceID.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_sample_other($0
        )
    })
}

public func newFactorSourceKindFromString(string: String) throws -> FactorSourceKind {
    return try FfiConverterTypeFactorSourceKind.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_factor_source_kind_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newFactorSourceKindSample() -> FactorSourceKind {
    return try! FfiConverterTypeFactorSourceKind.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_kind_sample($0
        )
    })
}

public func newFactorSourceKindSampleOther() -> FactorSourceKind {
    return try! FfiConverterTypeFactorSourceKind.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_kind_sample_other($0
        )
    })
}

public func newFactorSourceSample() -> FactorSource {
    return try! FfiConverterTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_sample($0
        )
    })
}

public func newFactorSourceSampleOther() -> FactorSource {
    return try! FfiConverterTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_sample_other($0
        )
    })
}

public func newFactorSourcesSample() -> [FactorSource] {
    return try! FfiConverterSequenceTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_sources_sample($0
        )
    })
}

public func newFactorSourcesSampleOther() -> [FactorSource] {
    return try! FfiConverterSequenceTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_sources_sample_other($0
        )
    })
}

public func newFiatCurrencyFromJsonString(jsonString: String) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_fiat_currency_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newFiatCurrencySample() -> FiatCurrency {
    return try! FfiConverterTypeFiatCurrency.lift(try! rustCall {
        uniffi_sargon_fn_func_new_fiat_currency_sample($0
        )
    })
}

public func newFiatCurrencySampleOther() -> FiatCurrency {
    return try! FfiConverterTypeFiatCurrency.lift(try! rustCall {
        uniffi_sargon_fn_func_new_fiat_currency_sample_other($0
        )
    })
}

public func newFungibleResourceIndicatorSample() -> FungibleResourceIndicator {
    return try! FfiConverterTypeFungibleResourceIndicator.lift(try! rustCall {
        uniffi_sargon_fn_func_new_fungible_resource_indicator_sample($0
        )
    })
}

public func newFungibleResourceIndicatorSampleOther() -> FungibleResourceIndicator {
    return try! FfiConverterTypeFungibleResourceIndicator.lift(try! rustCall {
        uniffi_sargon_fn_func_new_fungible_resource_indicator_sample_other($0
        )
    })
}

public func newGatewayForNetworkId(networkId: NetworkId) -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_new_gateway_for_network_id(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newGatewaySample() -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_new_gateway_sample($0
        )
    })
}

public func newGatewaySampleOther() -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_new_gateway_sample_other($0
        )
    })
}

public func newGatewayWithUrlOnNetwork(url: String, networkId: NetworkId) throws -> Gateway {
    return try FfiConverterTypeGateway.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_gateway_with_url_on_network(
            FfiConverterString.lower(url),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newGatewaysSample() -> [Gateway] {
    return try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_new_gateways_sample($0
        )
    })
}

public func newGatewaysSampleOther() -> [Gateway] {
    return try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_new_gateways_sample_other($0
        )
    })
}

public func newHashFromBytes(bytes: Exactly32Bytes) -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hash_from_bytes(
            FfiConverterTypeExactly32Bytes.lower(bytes), $0
        )
    })
}

public func newHashFromString(string: String) throws -> Hash {
    return try FfiConverterTypeHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_hash_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newHashSample() -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hash_sample($0
        )
    })
}

public func newHashSampleOther() -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hash_sample_other($0
        )
    })
}

public func newHeaderFromJsonBytes(jsonBytes: BagOfBytes) throws -> Header {
    return try FfiConverterTypeHeader.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_header_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newHeaderSample() -> Header {
    return try! FfiConverterTypeHeader.lift(try! rustCall {
        uniffi_sargon_fn_func_new_header_sample($0
        )
    })
}

public func newHeaderSampleOther() -> Header {
    return try! FfiConverterTypeHeader.lift(try! rustCall {
        uniffi_sargon_fn_func_new_header_sample_other($0
        )
    })
}

/**
 * Instantiates a new `Header` with creating and last used on `DeviceInfo` with
 * "Unknown device" as description, and empty content hint
 */
public func newHeaderWithCreatingDevice(creatingDevice: DeviceInfo) -> Header {
    return try! FfiConverterTypeHeader.lift(try! rustCall {
        uniffi_sargon_fn_func_new_header_with_creating_device(
            FfiConverterTypeDeviceInfo.lower(creatingDevice), $0
        )
    })
}

public func newHierarchicalDeterministicFactorInstanceSample() -> HierarchicalDeterministicFactorInstance {
    return try! FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hierarchical_deterministic_factor_instance_sample($0
        )
    })
}

public func newHierarchicalDeterministicFactorInstanceSampleOther() -> HierarchicalDeterministicFactorInstance {
    return try! FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hierarchical_deterministic_factor_instance_sample_other($0
        )
    })
}

public func newHierarchicalDeterministicPublicKeySample() -> HierarchicalDeterministicPublicKey {
    return try! FfiConverterTypeHierarchicalDeterministicPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hierarchical_deterministic_public_key_sample($0
        )
    })
}

public func newHierarchicalDeterministicPublicKeySampleOther() -> HierarchicalDeterministicPublicKey {
    return try! FfiConverterTypeHierarchicalDeterministicPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hierarchical_deterministic_public_key_sample_other($0
        )
    })
}

public func newIdentityAddress(bech32: String) throws -> IdentityAddress {
    return try FfiConverterTypeIdentityAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_identity_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

public func newIdentityAddressFrom(publicKey: PublicKey, networkId: NetworkId) -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_address_from(
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newIdentityAddressRandom(networkId: NetworkId) -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newIdentityAddressSampleMainnet() -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_address_sample_mainnet($0
        )
    })
}

public func newIdentityAddressSampleMainnetOther() -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_address_sample_mainnet_other($0
        )
    })
}

public func newIdentityAddressSampleStokenet() -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_address_sample_stokenet($0
        )
    })
}

public func newIdentityAddressSampleStokenetOther() -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_address_sample_stokenet_other($0
        )
    })
}

public func newIdentityPath(networkId: NetworkId, keyKind: Cap26KeyKind, index: UInt32) -> IdentityPath {
    return try! FfiConverterTypeIdentityPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_path(
            FfiConverterTypeNetworkID.lower(networkId),
            FfiConverterTypeCAP26KeyKind.lower(keyKind),
            FfiConverterUInt32.lower(index), $0
        )
    })
}

public func newIdentityPathSample() -> IdentityPath {
    return try! FfiConverterTypeIdentityPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_path_sample($0
        )
    })
}

public func newIdentityPathSampleOther() -> IdentityPath {
    return try! FfiConverterTypeIdentityPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_path_sample_other($0
        )
    })
}

public func newIntentHashFromString(string: String) throws -> IntentHash {
    return try FfiConverterTypeIntentHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_intent_hash_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newIntentHashSample() -> IntentHash {
    return try! FfiConverterTypeIntentHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_intent_hash_sample($0
        )
    })
}

public func newIntentHashSampleOther() -> IntentHash {
    return try! FfiConverterTypeIntentHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_intent_hash_sample_other($0
        )
    })
}

public func newIntentSignatureFromSignatureWithPublicKey(signatureWithPublicKey: SignatureWithPublicKey) -> IntentSignature {
    return try! FfiConverterTypeIntentSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_intent_signature_from_signature_with_public_key(
            FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey), $0
        )
    })
}

public func newIntentSignatureSample() -> IntentSignature {
    return try! FfiConverterTypeIntentSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_intent_signature_sample($0
        )
    })
}

public func newIntentSignatureSampleOther() -> IntentSignature {
    return try! FfiConverterTypeIntentSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_intent_signature_sample_other($0
        )
    })
}

public func newLedgerHardwareWalletFactorSourceSample() -> LedgerHardwareWalletFactorSource {
    return try! FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ledger_hardware_wallet_factor_source_sample($0
        )
    })
}

public func newLedgerHardwareWalletFactorSourceSampleOther() -> LedgerHardwareWalletFactorSource {
    return try! FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ledger_hardware_wallet_factor_source_sample_other($0
        )
    })
}

public func newLedgerHwWalletModelFromString(string: String) throws -> LedgerHardwareWalletModel {
    return try FfiConverterTypeLedgerHardwareWalletModel.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_ledger_hw_wallet_model_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newLedgerHwWalletModelSample() -> LedgerHardwareWalletModel {
    return try! FfiConverterTypeLedgerHardwareWalletModel.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ledger_hw_wallet_model_sample($0
        )
    })
}

public func newLedgerHwWalletModelSampleOther() -> LedgerHardwareWalletModel {
    return try! FfiConverterTypeLedgerHardwareWalletModel.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ledger_hw_wallet_model_sample_other($0
        )
    })
}

public func newLegacyOlympiaAccountAddressFromPublicKey(publicKey: Secp256k1PublicKey) -> LegacyOlympiaAccountAddress {
    return try! FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_legacy_olympia_account_address_from_public_key(
            FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
        )
    })
}

public func newLegacyOlympiaAccountAddressFromString(string: String) throws -> LegacyOlympiaAccountAddress {
    return try FfiConverterTypeLegacyOlympiaAccountAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_legacy_olympia_account_address_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newLegacyOlympiaAccountAddressSample() -> LegacyOlympiaAccountAddress {
    return try! FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_legacy_olympia_account_address_sample($0
        )
    })
}

public func newLegacyOlympiaAccountAddressSampleOther() -> LegacyOlympiaAccountAddress {
    return try! FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_legacy_olympia_account_address_sample_other($0
        )
    })
}

public func newLinkConnectionQRDataFromJsonBytes(jsonBytes: BagOfBytes) throws -> LinkConnectionQrData {
    return try FfiConverterTypeLinkConnectionQRData.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_link_connection_q_r_data_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newLinkConnectionQrDataSample() -> LinkConnectionQrData {
    return try! FfiConverterTypeLinkConnectionQRData.lift(try! rustCall {
        uniffi_sargon_fn_func_new_link_connection_qr_data_sample($0
        )
    })
}

public func newLinkConnectionQrDataSampleOther() -> LinkConnectionQrData {
    return try! FfiConverterTypeLinkConnectionQRData.lift(try! rustCall {
        uniffi_sargon_fn_func_new_link_connection_qr_data_sample_other($0
        )
    })
}

public func newMessagePlaintextSample() -> Message {
    return try! FfiConverterTypeMessage.lift(try! rustCall {
        uniffi_sargon_fn_func_new_message_plaintext_sample($0
        )
    })
}

public func newMessagePlaintextSampleOther() -> Message {
    return try! FfiConverterTypeMessage.lift(try! rustCall {
        uniffi_sargon_fn_func_new_message_plaintext_sample_other($0
        )
    })
}

public func newMessagePlaintextString(string: String) -> Message {
    return try! FfiConverterTypeMessage.lift(try! rustCall {
        uniffi_sargon_fn_func_new_message_plaintext_string(
            FfiConverterString.lower(string), $0
        )
    })
}

/**
 * Returns new mnemonic from a string of words
 */
public func newMnemonicFromPhrase(phrase: String) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_mnemonic_from_phrase(
            FfiConverterString.lower(phrase), $0
        )
    })
}

public func newMnemonicFromPhraseLanguage(phrase: String, language: Bip39Language) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_mnemonic_from_phrase_language(
            FfiConverterString.lower(phrase),
            FfiConverterTypeBIP39Language.lower(language), $0
        )
    })
}

public func newMnemonicFromWords(words: [Bip39Word]) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_mnemonic_from_words(
            FfiConverterSequenceTypeBIP39Word.lower(words), $0
        )
    })
}

public func newMnemonicGenerateWithEntropy(entropy: Bip39Entropy, language: Bip39Language) -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_generate_with_entropy(
            FfiConverterTypeBIP39Entropy.lower(entropy),
            FfiConverterTypeBIP39Language.lower(language), $0
        )
    })
}

public func newMnemonicSample() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample($0
        )
    })
}

public func newMnemonicSampleOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_other($0
        )
    })
}

public func newMnemonicWithPassphraseFromJsonBytes(jsonBytes: BagOfBytes) throws -> MnemonicWithPassphrase {
    return try FfiConverterTypeMnemonicWithPassphrase.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_mnemonic_with_passphrase_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newMnemonicWithPassphraseSample() -> MnemonicWithPassphrase {
    return try! FfiConverterTypeMnemonicWithPassphrase.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_with_passphrase_sample($0
        )
    })
}

public func newMnemonicWithPassphraseSampleOther() -> MnemonicWithPassphrase {
    return try! FfiConverterTypeMnemonicWithPassphrase.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_with_passphrase_sample_other($0
        )
    })
}

/**
 * The Radix Connect Mobile client.
 * This is the object that will be used by the mobile app to handle interactions sent over Radix Connect Relay.
 */
public func newMobileConnectRequest(url: String) throws -> RadixConnectMobileConnectRequest {
    return try FfiConverterTypeRadixConnectMobileConnectRequest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_mobile_connect_request(
            FfiConverterString.lower(url), $0
        )
    })
}

public func newNetworkDefinitionLookupByName(logicalName: String) throws -> NetworkDefinition {
    return try FfiConverterTypeNetworkDefinition.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_network_definition_lookup_by_name(
            FfiConverterString.lower(logicalName), $0
        )
    })
}

public func newNetworkDefinitionSample() -> NetworkDefinition {
    return try! FfiConverterTypeNetworkDefinition.lift(try! rustCall {
        uniffi_sargon_fn_func_new_network_definition_sample($0
        )
    })
}

public func newNetworkDefinitionSampleOther() -> NetworkDefinition {
    return try! FfiConverterTypeNetworkDefinition.lift(try! rustCall {
        uniffi_sargon_fn_func_new_network_definition_sample_other($0
        )
    })
}

public func newNetworkIdFromDiscriminant(discriminant: UInt8) throws -> NetworkId {
    return try FfiConverterTypeNetworkID.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_network_id_from_discriminant(
            FfiConverterUInt8.lower(discriminant), $0
        )
    })
}

public func newNonEmptyMax32Bytes(bagOfBytes: BagOfBytes) throws -> NonEmptyMax32Bytes {
    return try FfiConverterTypeNonEmptyMax32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_empty_max_32_bytes(
            FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
        )
    })
}

public func newNonEmptyMax64Bytes(bagOfBytes: BagOfBytes) throws -> NonEmptyMax64Bytes {
    return try FfiConverterTypeNonEmptyMax64Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_empty_max_64_bytes(
            FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
        )
    })
}

public func newNonFungibleGlobalIdFromString(string: String) throws -> NonFungibleGlobalId {
    return try FfiConverterTypeNonFungibleGlobalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_global_id_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newNonFungibleGlobalIdSample() -> NonFungibleGlobalId {
    return try! FfiConverterTypeNonFungibleGlobalId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_global_id_sample($0
        )
    })
}

public func newNonFungibleGlobalIdSampleOther() -> NonFungibleGlobalId {
    return try! FfiConverterTypeNonFungibleGlobalId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_global_id_sample_other($0
        )
    })
}

public func newNonFungibleLocalIdBytes(bytes: BagOfBytes) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_local_id_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newNonFungibleLocalIdFromString(localId: String) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_local_id_from_string(
            FfiConverterString.lower(localId), $0
        )
    })
}

public func newNonFungibleLocalIdInt(value: UInt64) -> NonFungibleLocalId {
    return try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_local_id_int(
            FfiConverterUInt64.lower(value), $0
        )
    })
}

public func newNonFungibleLocalIdRandom() -> NonFungibleLocalId {
    return try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_local_id_random($0
        )
    })
}

public func newNonFungibleLocalIdRuid(bytes: BagOfBytes) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_local_id_ruid(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newNonFungibleLocalIdSample() -> NonFungibleLocalId {
    return try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_local_id_sample($0
        )
    })
}

public func newNonFungibleLocalIdSampleOther() -> NonFungibleLocalId {
    return try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_local_id_sample_other($0
        )
    })
}

public func newNonFungibleLocalIdString(string: String) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_local_id_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newNonFungibleLocalIdStringFromStr(string: String) throws -> NonFungibleLocalIdString {
    return try FfiConverterTypeNonFungibleLocalIdString.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_local_id_string_from_str(
            FfiConverterString.lower(string), $0
        )
    })
}

/**
 * Tries to bech32 decode the string into a specialized address.
 */
public func newNonFungibleResourceAddress(bech32: String) throws -> NonFungibleResourceAddress {
    return try FfiConverterTypeNonFungibleResourceAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_resource_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newNonFungibleResourceAddressRandom(networkId: NetworkId) -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newNonFungibleResourceAddressSampleMainnet() -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_address_sample_mainnet($0
        )
    })
}

public func newNonFungibleResourceAddressSampleMainnetOther() -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_address_sample_mainnet_other($0
        )
    })
}

public func newNonFungibleResourceAddressSampleStokenet() -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_address_sample_stokenet($0
        )
    })
}

public func newNonFungibleResourceAddressSampleStokenetOther() -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_address_sample_stokenet_other($0
        )
    })
}

public func newNonFungibleResourceIndicatorSample() -> NonFungibleResourceIndicator {
    return try! FfiConverterTypeNonFungibleResourceIndicator.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_indicator_sample($0
        )
    })
}

public func newNonFungibleResourceIndicatorSampleOther() -> NonFungibleResourceIndicator {
    return try! FfiConverterTypeNonFungibleResourceIndicator.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_indicator_sample_other($0
        )
    })
}

public func newNonceFromU32(value: UInt32) -> Nonce {
    return try! FfiConverterTypeNonce.lift(try! rustCall {
        uniffi_sargon_fn_func_new_nonce_from_u32(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

public func newNonceRandom() -> Nonce {
    return try! FfiConverterTypeNonce.lift(try! rustCall {
        uniffi_sargon_fn_func_new_nonce_random($0
        )
    })
}

public func newNonceSample() -> Nonce {
    return try! FfiConverterTypeNonce.lift(try! rustCall {
        uniffi_sargon_fn_func_new_nonce_sample($0
        )
    })
}

public func newNonceSampleOther() -> Nonce {
    return try! FfiConverterTypeNonce.lift(try! rustCall {
        uniffi_sargon_fn_func_new_nonce_sample_other($0
        )
    })
}

public func newNotarizedTransactionSample() -> NotarizedTransaction {
    return try! FfiConverterTypeNotarizedTransaction.lift(try! rustCall {
        uniffi_sargon_fn_func_new_notarized_transaction_sample($0
        )
    })
}

public func newNotarizedTransactionSampleOther() -> NotarizedTransaction {
    return try! FfiConverterTypeNotarizedTransaction.lift(try! rustCall {
        uniffi_sargon_fn_func_new_notarized_transaction_sample_other($0
        )
    })
}

public func newNotarySignature(signature: Signature) -> NotarySignature {
    return try! FfiConverterTypeNotarySignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_notary_signature(
            FfiConverterTypeSignature.lower(signature), $0
        )
    })
}

public func newNotarySignatureSample() -> NotarySignature {
    return try! FfiConverterTypeNotarySignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_notary_signature_sample($0
        )
    })
}

public func newNotarySignatureSampleOther() -> NotarySignature {
    return try! FfiConverterTypeNotarySignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_notary_signature_sample_other($0
        )
    })
}

public func newOnLedgerSettingsDefault() -> OnLedgerSettings {
    return try! FfiConverterTypeOnLedgerSettings.lift(try! rustCall {
        uniffi_sargon_fn_func_new_on_ledger_settings_default($0
        )
    })
}

public func newOnLedgerSettingsSample() -> OnLedgerSettings {
    return try! FfiConverterTypeOnLedgerSettings.lift(try! rustCall {
        uniffi_sargon_fn_func_new_on_ledger_settings_sample($0
        )
    })
}

public func newOnLedgerSettingsSampleOther() -> OnLedgerSettings {
    return try! FfiConverterTypeOnLedgerSettings.lift(try! rustCall {
        uniffi_sargon_fn_func_new_on_ledger_settings_sample_other($0
        )
    })
}

public func newP2PLinkFromJsonBytes(jsonBytes: BagOfBytes) throws -> P2pLink {
    return try FfiConverterTypeP2PLink.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_p2_p_link_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newP2PLinksSample() -> [P2pLink] {
    return try! FfiConverterSequenceTypeP2PLink.lift(try! rustCall {
        uniffi_sargon_fn_func_new_p2_p_links_sample($0
        )
    })
}

public func newP2PLinksSampleOther() -> [P2pLink] {
    return try! FfiConverterSequenceTypeP2PLink.lift(try! rustCall {
        uniffi_sargon_fn_func_new_p2_p_links_sample_other($0
        )
    })
}

public func newP2pLinkSample() -> P2pLink {
    return try! FfiConverterTypeP2PLink.lift(try! rustCall {
        uniffi_sargon_fn_func_new_p2p_link_sample($0
        )
    })
}

public func newP2pLinkSampleOther() -> P2pLink {
    return try! FfiConverterTypeP2PLink.lift(try! rustCall {
        uniffi_sargon_fn_func_new_p2p_link_sample_other($0
        )
    })
}

public func newP2pLinksFromJsonBytes(jsonBytes: BagOfBytes) throws -> [P2pLink] {
    return try FfiConverterSequenceTypeP2PLink.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_p2p_links_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newPackageAddress(bech32: String) throws -> PackageAddress {
    return try FfiConverterTypePackageAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_package_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newPackageAddressRandom(networkId: NetworkId) -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_package_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newPackageAddressSampleMainnet() -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_package_address_sample_mainnet($0
        )
    })
}

public func newPackageAddressSampleMainnetOther() -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_package_address_sample_mainnet_other($0
        )
    })
}

public func newPackageAddressSampleStokenet() -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_package_address_sample_stokenet($0
        )
    })
}

public func newPackageAddressSampleStokenetOther() -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_package_address_sample_stokenet_other($0
        )
    })
}

public func newPerAssetTransfersSample() -> PerAssetTransfers {
    return try! FfiConverterTypePerAssetTransfers.lift(try! rustCall {
        uniffi_sargon_fn_func_new_per_asset_transfers_sample($0
        )
    })
}

public func newPerAssetTransfersSampleOther() -> PerAssetTransfers {
    return try! FfiConverterTypePerAssetTransfers.lift(try! rustCall {
        uniffi_sargon_fn_func_new_per_asset_transfers_sample_other($0
        )
    })
}

public func newPersonaDataEntryEmailAddressFromJsonString(jsonString: String) throws -> PersonaDataEntryEmailAddress {
    return try FfiConverterTypePersonaDataEntryEmailAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_persona_data_entry_email_address_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newPersonaDataEntryEmailAddressSample() -> PersonaDataEntryEmailAddress {
    return try! FfiConverterTypePersonaDataEntryEmailAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_entry_email_address_sample($0
        )
    })
}

public func newPersonaDataEntryEmailAddressSampleOther() -> PersonaDataEntryEmailAddress {
    return try! FfiConverterTypePersonaDataEntryEmailAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_entry_email_address_sample_other($0
        )
    })
}

public func newPersonaDataEntryNameFromJsonBytes(jsonBytes: BagOfBytes) throws -> PersonaDataEntryName {
    return try FfiConverterTypePersonaDataEntryName.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_persona_data_entry_name_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newPersonaDataEntryNameSample() -> PersonaDataEntryName {
    return try! FfiConverterTypePersonaDataEntryName.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_entry_name_sample($0
        )
    })
}

public func newPersonaDataEntryNameSampleOther() -> PersonaDataEntryName {
    return try! FfiConverterTypePersonaDataEntryName.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_entry_name_sample_other($0
        )
    })
}

public func newPersonaDataEntryPhoneNumberFromJsonString(jsonString: String) throws -> PersonaDataEntryPhoneNumber {
    return try FfiConverterTypePersonaDataEntryPhoneNumber.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_persona_data_entry_phone_number_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newPersonaDataEntryPhoneNumberSample() -> PersonaDataEntryPhoneNumber {
    return try! FfiConverterTypePersonaDataEntryPhoneNumber.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_entry_phone_number_sample($0
        )
    })
}

public func newPersonaDataEntryPhoneNumberSampleOther() -> PersonaDataEntryPhoneNumber {
    return try! FfiConverterTypePersonaDataEntryPhoneNumber.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_entry_phone_number_sample_other($0
        )
    })
}

public func newPersonaDataSample() -> PersonaData {
    return try! FfiConverterTypePersonaData.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_sample($0
        )
    })
}

public func newPersonaDataSampleOther() -> PersonaData {
    return try! FfiConverterTypePersonaData.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_sample_other($0
        )
    })
}

public func newPersonaSample() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample($0
        )
    })
}

public func newPersonaSampleMainnetBatman() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_mainnet_batman($0
        )
    })
}

public func newPersonaSampleMainnetRipley() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_mainnet_ripley($0
        )
    })
}

public func newPersonaSampleMainnetSatoshi() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_mainnet_satoshi($0
        )
    })
}

public func newPersonaSampleMainnetTuring() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_mainnet_turing($0
        )
    })
}

public func newPersonaSampleOther() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_other($0
        )
    })
}

public func newPersonaSampleStokenetConnor() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_stokenet_connor($0
        )
    })
}

public func newPersonaSampleStokenetHermione() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_stokenet_hermione($0
        )
    })
}

public func newPersonaSampleStokenetLeiaSkywalker() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_stokenet_leia_skywalker($0
        )
    })
}

public func newPersonasSample() -> [Persona] {
    return try! FfiConverterSequenceTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_personas_sample($0
        )
    })
}

public func newPersonasSampleOther() -> [Persona] {
    return try! FfiConverterSequenceTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_personas_sample_other($0
        )
    })
}

public func newPoolAddress(bech32: String) throws -> PoolAddress {
    return try FfiConverterTypePoolAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_pool_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newPoolAddressRandom(networkId: NetworkId) -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Sample to a mainnet PoolAddress with three resources.
 */
public func newPoolAddressSampleMainnetMulti() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_sample_mainnet_multi($0
        )
    })
}

/**
 * Sample to a mainnet PoolAddress with single resource.
 */
public func newPoolAddressSampleMainnetSingle() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_sample_mainnet_single($0
        )
    })
}

/**
 * Sample to a mainnet PoolAddress with two resources.
 */
public func newPoolAddressSampleMainnetTwo() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_sample_mainnet_two($0
        )
    })
}

/**
 * Sample to a stokenet PoolAddress with three resources.
 */
public func newPoolAddressSampleStokenetMulti() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_sample_stokenet_multi($0
        )
    })
}

/**
 * Sample to a stokenet PoolAddress with single resource.
 */
public func newPoolAddressSampleStokenetSingle() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_sample_stokenet_single($0
        )
    })
}

/**
 * Sample to a stokenet PoolAddress with two resources.
 */
public func newPoolAddressSampleStokenetTwo() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_sample_stokenet_two($0
        )
    })
}

public func newPrivateHdFactorSourceBabylon(isMain: Bool, entropy: NonEmptyMax32Bytes, walletClientModel: WalletClientModel) throws -> PrivateHierarchicalDeterministicFactorSource {
    return try FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_private_hd_factor_source_babylon(
            FfiConverterBool.lower(isMain),
            FfiConverterTypeNonEmptyMax32Bytes.lower(entropy),
            FfiConverterTypeWalletClientModel.lower(walletClientModel), $0
        )
    })
}

public func newPrivateHdFactorSourceBabylonFromMnemonicWithPassphrase(isMain: Bool, mnemonicWithPassphrase: MnemonicWithPassphrase, walletClientModel: WalletClientModel) -> PrivateHierarchicalDeterministicFactorSource {
    return try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_private_hd_factor_source_babylon_from_mnemonic_with_passphrase(
            FfiConverterBool.lower(isMain),
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeWalletClientModel.lower(walletClientModel), $0
        )
    })
}

public func newPrivateHdFactorSourceOlympiaFromMnemonicWithPassphrase(mnemonicWithPassphrase: MnemonicWithPassphrase, walletClientModel: WalletClientModel) -> PrivateHierarchicalDeterministicFactorSource {
    return try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_private_hd_factor_source_olympia_from_mnemonic_with_passphrase(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeWalletClientModel.lower(walletClientModel), $0
        )
    })
}

public func newPrivateHdFactorSourceSample() -> PrivateHierarchicalDeterministicFactorSource {
    return try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_private_hd_factor_source_sample($0
        )
    })
}

public func newPrivateHdFactorSourceSampleOther() -> PrivateHierarchicalDeterministicFactorSource {
    return try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_private_hd_factor_source_sample_other($0
        )
    })
}

public func newProfile(deviceFactorSource: DeviceFactorSource, creatingDeviceName: String) -> Profile {
    return try! FfiConverterTypeProfile.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile(
            FfiConverterTypeDeviceFactorSource.lower(deviceFactorSource),
            FfiConverterString.lower(creatingDeviceName), $0
        )
    })
}

public func newProfileFileContentsSample() -> ProfileFileContents {
    return try! FfiConverterTypeProfileFileContents.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_file_contents_sample($0
        )
    })
}

public func newProfileFileContentsSampleOther() -> ProfileFileContents {
    return try! FfiConverterTypeProfileFileContents.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_file_contents_sample_other($0
        )
    })
}

public func newProfileFromEncryptionBytes(jsonString: String, decryptionPassword: String) throws -> Profile {
    return try FfiConverterTypeProfile.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_profile_from_encryption_bytes(
            FfiConverterString.lower(jsonString),
            FfiConverterString.lower(decryptionPassword), $0
        )
    })
}

public func newProfileFromJsonString(jsonStr: String) throws -> Profile {
    return try FfiConverterTypeProfile.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_profile_from_json_string(
            FfiConverterString.lower(jsonStr), $0
        )
    })
}

public func newProfileNetworkSample() -> ProfileNetwork {
    return try! FfiConverterTypeProfileNetwork.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_network_sample($0
        )
    })
}

public func newProfileNetworkSampleOther() -> ProfileNetwork {
    return try! FfiConverterTypeProfileNetwork.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_network_sample_other($0
        )
    })
}

public func newProfileNetworksSample() -> [ProfileNetwork] {
    return try! FfiConverterSequenceTypeProfileNetwork.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_networks_sample($0
        )
    })
}

public func newProfileNetworksSampleOther() -> [ProfileNetwork] {
    return try! FfiConverterSequenceTypeProfileNetwork.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_networks_sample_other($0
        )
    })
}

public func newProfileSample() -> Profile {
    return try! FfiConverterTypeProfile.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_sample($0
        )
    })
}

public func newProfileSampleOther() -> Profile {
    return try! FfiConverterTypeProfile.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_sample_other($0
        )
    })
}

/**
 * Tries to create a PublicKey from the bytes
 */
public func newPublicKeyFromBytes(bagOfBytes: BagOfBytes) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_public_key_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
        )
    })
}

/**
 * Tries to create a PublicKey from the hex string
 */
public func newPublicKeyFromHex(hex: String) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_public_key_from_hex(
            FfiConverterString.lower(hex), $0
        )
    })
}

public func newPublicKeyHashOfKey(publicKey: PublicKey) -> PublicKeyHash {
    return try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_public_key_hash_of_key(
            FfiConverterTypePublicKey.lower(publicKey), $0
        )
    })
}

public func newPublicKeyHashSample() -> PublicKeyHash {
    return try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_public_key_hash_sample($0
        )
    })
}

public func newPublicKeyHashSampleOther() -> PublicKeyHash {
    return try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_public_key_hash_sample_other($0
        )
    })
}

public func newPublicKeySample() -> PublicKey {
    return try! FfiConverterTypePublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_public_key_sample($0
        )
    })
}

public func newPublicKeySampleOther() -> PublicKey {
    return try! FfiConverterTypePublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_public_key_sample_other($0
        )
    })
}

public func newRadixConnectPassword(bytes: Exactly32Bytes) -> RadixConnectPassword {
    return try! FfiConverterTypeRadixConnectPassword.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_password(
            FfiConverterTypeExactly32Bytes.lower(bytes), $0
        )
    })
}

public func newRadixConnectPasswordFromJsonString(jsonString: String) throws -> RadixConnectPassword {
    return try FfiConverterTypeRadixConnectPassword.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_radix_connect_password_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newRadixConnectPasswordSample() -> RadixConnectPassword {
    return try! FfiConverterTypeRadixConnectPassword.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_password_sample($0
        )
    })
}

public func newRadixConnectPasswordSampleOther() -> RadixConnectPassword {
    return try! FfiConverterTypeRadixConnectPassword.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_password_sample_other($0
        )
    })
}

public func newRadixConnectPurposeFromJsonString(jsonString: String) throws -> RadixConnectPurpose {
    return try FfiConverterTypeRadixConnectPurpose.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_radix_connect_purpose_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newRadixConnectPurposeFromString(string: String) -> RadixConnectPurpose {
    return try! FfiConverterTypeRadixConnectPurpose.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_purpose_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newRadixConnectPurposeSample() -> RadixConnectPurpose {
    return try! FfiConverterTypeRadixConnectPurpose.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_purpose_sample($0
        )
    })
}

public func newRadixConnectPurposeSampleOther() -> RadixConnectPurpose {
    return try! FfiConverterTypeRadixConnectPurpose.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_purpose_sample_other($0
        )
    })
}

public func newReferencesToAuthorizedPersonasSample() -> [AuthorizedPersonaSimple] {
    return try! FfiConverterSequenceTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_fn_func_new_references_to_authorized_personas_sample($0
        )
    })
}

public func newReferencesToAuthorizedPersonasSampleOther() -> [AuthorizedPersonaSimple] {
    return try! FfiConverterSequenceTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_fn_func_new_references_to_authorized_personas_sample_other($0
        )
    })
}

public func newRequestedQuantityFromJsonBytes(jsonBytes: BagOfBytes) throws -> RequestedQuantity {
    return try FfiConverterTypeRequestedQuantity.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_requested_quantity_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newRequestedQuantitySample() -> RequestedQuantity {
    return try! FfiConverterTypeRequestedQuantity.lift(try! rustCall {
        uniffi_sargon_fn_func_new_requested_quantity_sample($0
        )
    })
}

public func newRequestedQuantitySampleOther() -> RequestedQuantity {
    return try! FfiConverterTypeRequestedQuantity.lift(try! rustCall {
        uniffi_sargon_fn_func_new_requested_quantity_sample_other($0
        )
    })
}

public func newResourceAddress(bech32: String) throws -> ResourceAddress {
    return try FfiConverterTypeResourceAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_resource_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newResourceAddressRandom(networkId: NetworkId) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newResourceAddressSampleMainnetCandy() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_mainnet_candy($0
        )
    })
}

public func newResourceAddressSampleMainnetNftGcMembership() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_mainnet_nft_gc_membership($0
        )
    })
}

public func newResourceAddressSampleMainnetXrd() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_mainnet_xrd($0
        )
    })
}

public func newResourceAddressSampleStokenetCandy() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_stokenet_candy($0
        )
    })
}

public func newResourceAddressSampleStokenetGcTokens() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_stokenet_gc_tokens($0
        )
    })
}

public func newResourceAddressSampleStokenetGum() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_stokenet_gum($0
        )
    })
}

public func newResourceAddressSampleStokenetXrd() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_stokenet_xrd($0
        )
    })
}

public func newResourceIndicatorSample() -> ResourceIndicator {
    return try! FfiConverterTypeResourceIndicator.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_indicator_sample($0
        )
    })
}

public func newResourceIndicatorSampleOther() -> ResourceIndicator {
    return try! FfiConverterTypeResourceIndicator.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_indicator_sample_other($0
        )
    })
}

public func newResourceOrNonFungibleSample() -> ResourceOrNonFungible {
    return try! FfiConverterTypeResourceOrNonFungible.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_or_non_fungible_sample($0
        )
    })
}

public func newResourceOrNonFungibleSampleOther() -> ResourceOrNonFungible {
    return try! FfiConverterTypeResourceOrNonFungible.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_or_non_fungible_sample_other($0
        )
    })
}

public func newSLIP10CurveFromJsonString(jsonString: String) throws -> Slip10Curve {
    return try FfiConverterTypeSLIP10Curve.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_s_l_i_p10_curve_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newSargonBuildInformationSample() -> SargonBuildInformation {
    return try! FfiConverterTypeSargonBuildInformation.lift(try! rustCall {
        uniffi_sargon_fn_func_new_sargon_build_information_sample($0
        )
    })
}

public func newSargonBuildInformationSampleOther() -> SargonBuildInformation {
    return try! FfiConverterTypeSargonBuildInformation.lift(try! rustCall {
        uniffi_sargon_fn_func_new_sargon_build_information_sample_other($0
        )
    })
}

/**
 * Constructs `Gateways` with `current` set as active Gateway.
 */
public func newSavedGateways(current: Gateway) -> SavedGateways {
    return try! FfiConverterTypeSavedGateways.lift(try! rustCall {
        uniffi_sargon_fn_func_new_saved_gateways(
            FfiConverterTypeGateway.lower(current), $0
        )
    })
}

public func newSavedGatewaysChangingCurrent(to: Gateway, gateways: SavedGateways) throws -> SavedGateways {
    return try FfiConverterTypeSavedGateways.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_saved_gateways_changing_current(
            FfiConverterTypeGateway.lower(to),
            FfiConverterTypeSavedGateways.lower(gateways), $0
        )
    })
}

/**
 * Constructs `Gateways` with default preset values.
 */
public func newSavedGatewaysDefault() -> SavedGateways {
    return try! FfiConverterTypeSavedGateways.lift(try! rustCall {
        uniffi_sargon_fn_func_new_saved_gateways_default($0
        )
    })
}

/**
 * A sample value useful for tests and previews.
 */
public func newSavedGatewaysSample() -> SavedGateways {
    return try! FfiConverterTypeSavedGateways.lift(try! rustCall {
        uniffi_sargon_fn_func_new_saved_gateways_sample($0
        )
    })
}

/**
 * A sample value useful for tests and previews.
 */
public func newSavedGatewaysSampleOther() -> SavedGateways {
    return try! FfiConverterTypeSavedGateways.lift(try! rustCall {
        uniffi_sargon_fn_func_new_saved_gateways_sample_other($0
        )
    })
}

/**
 * Creates a Secp256k1PublicKey from either compressed form (33 bytes) or
 * from uncompressed form (65 bytes).
 */
public func newSecp256k1PublicKeyFromBytes(bytes: BagOfBytes) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_secp256k1_public_key_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newSecp256k1PublicKeyFromHex(hex: String) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_secp256k1_public_key_from_hex(
            FfiConverterString.lower(hex), $0
        )
    })
}

public func newSecp256k1PublicKeySample() -> Secp256k1PublicKey {
    return try! FfiConverterTypeSecp256k1PublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_secp256k1_public_key_sample($0
        )
    })
}

public func newSecp256k1PublicKeySampleOther() -> Secp256k1PublicKey {
    return try! FfiConverterTypeSecp256k1PublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_secp256k1_public_key_sample_other($0
        )
    })
}

public func newSecp256k1SignatureFromBytes(bytes: BagOfBytes) throws -> Secp256k1Signature {
    return try FfiConverterTypeSecp256k1Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_secp256k1_signature_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newSecp256k1SignatureFromExactly65Bytes(bytes: Exactly65Bytes) -> Secp256k1Signature {
    return try! FfiConverterTypeSecp256k1Signature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_secp256k1_signature_from_exactly_65_bytes(
            FfiConverterTypeExactly65Bytes.lower(bytes), $0
        )
    })
}

public func newSecp256k1SignatureSample() -> Secp256k1Signature {
    return try! FfiConverterTypeSecp256k1Signature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_secp256k1_signature_sample($0
        )
    })
}

public func newSecp256k1SignatureSampleOther() -> Secp256k1Signature {
    return try! FfiConverterTypeSecp256k1Signature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_secp256k1_signature_sample_other($0
        )
    })
}

public func newSharedPersonaDataSample() -> SharedPersonaData {
    return try! FfiConverterTypeSharedPersonaData.lift(try! rustCall {
        uniffi_sargon_fn_func_new_shared_persona_data_sample($0
        )
    })
}

public func newSharedPersonaDataSampleOther() -> SharedPersonaData {
    return try! FfiConverterTypeSharedPersonaData.lift(try! rustCall {
        uniffi_sargon_fn_func_new_shared_persona_data_sample_other($0
        )
    })
}

public func newSignatureFromBytes(bytes: BagOfBytes) throws -> Signature {
    return try FfiConverterTypeSignature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_signature_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newSignatureSample() -> Signature {
    return try! FfiConverterTypeSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signature_sample($0
        )
    })
}

public func newSignatureSampleOther() -> Signature {
    return try! FfiConverterTypeSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signature_sample_other($0
        )
    })
}

public func newSignatureWithPublicKeySample() -> SignatureWithPublicKey {
    return try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signature_with_public_key_sample($0
        )
    })
}

public func newSignatureWithPublicKeySampleOther() -> SignatureWithPublicKey {
    return try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signature_with_public_key_sample_other($0
        )
    })
}

public func newSignedIntentHashFromString(string: String) throws -> SignedIntentHash {
    return try FfiConverterTypeSignedIntentHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_signed_intent_hash_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newSignedIntentHashSample() -> SignedIntentHash {
    return try! FfiConverterTypeSignedIntentHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signed_intent_hash_sample($0
        )
    })
}

public func newSignedIntentHashSampleOther() -> SignedIntentHash {
    return try! FfiConverterTypeSignedIntentHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signed_intent_hash_sample_other($0
        )
    })
}

public func newSignedIntentSample() -> SignedIntent {
    return try! FfiConverterTypeSignedIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signed_intent_sample($0
        )
    })
}

public func newSignedIntentSampleOther() -> SignedIntent {
    return try! FfiConverterTypeSignedIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signed_intent_sample_other($0
        )
    })
}

public func newSlip10CurveFromString(curve: String) throws -> Slip10Curve {
    return try FfiConverterTypeSLIP10Curve.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_slip10_curve_from_string(
            FfiConverterString.lower(curve), $0
        )
    })
}

public func newStakeClaimSample() -> StakeClaim {
    return try! FfiConverterTypeStakeClaim.lift(try! rustCall {
        uniffi_sargon_fn_func_new_stake_claim_sample($0
        )
    })
}

public func newStakeClaimSampleOther() -> StakeClaim {
    return try! FfiConverterTypeStakeClaim.lift(try! rustCall {
        uniffi_sargon_fn_func_new_stake_claim_sample_other($0
        )
    })
}

public func newSupportedCurvesSample() -> [Slip10Curve] {
    return try! FfiConverterSequenceTypeSLIP10Curve.lift(try! rustCall {
        uniffi_sargon_fn_func_new_supported_curves_sample($0
        )
    })
}

public func newSupportedCurvesSampleOther() -> [Slip10Curve] {
    return try! FfiConverterSequenceTypeSLIP10Curve.lift(try! rustCall {
        uniffi_sargon_fn_func_new_supported_curves_sample_other($0
        )
    })
}

public func newThirdPartyDepositsDefault() -> ThirdPartyDeposits {
    return try! FfiConverterTypeThirdPartyDeposits.lift(try! rustCall {
        uniffi_sargon_fn_func_new_third_party_deposits_default($0
        )
    })
}

public func newThirdPartyDepositsSample() -> ThirdPartyDeposits {
    return try! FfiConverterTypeThirdPartyDeposits.lift(try! rustCall {
        uniffi_sargon_fn_func_new_third_party_deposits_sample($0
        )
    })
}

public func newThirdPartyDepositsSampleOther() -> ThirdPartyDeposits {
    return try! FfiConverterTypeThirdPartyDeposits.lift(try! rustCall {
        uniffi_sargon_fn_func_new_third_party_deposits_sample_other($0
        )
    })
}

public func newTransactionHeaderSample() -> TransactionHeader {
    return try! FfiConverterTypeTransactionHeader.lift(try! rustCall {
        uniffi_sargon_fn_func_new_transaction_header_sample($0
        )
    })
}

public func newTransactionHeaderSampleOther() -> TransactionHeader {
    return try! FfiConverterTypeTransactionHeader.lift(try! rustCall {
        uniffi_sargon_fn_func_new_transaction_header_sample_other($0
        )
    })
}

public func newTransactionIntentSample() -> TransactionIntent {
    return try! FfiConverterTypeTransactionIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_new_transaction_intent_sample($0
        )
    })
}

public func newTransactionIntentSampleOther() -> TransactionIntent {
    return try! FfiConverterTypeTransactionIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_new_transaction_intent_sample_other($0
        )
    })
}

public func newTransactionManifestFromInstructionsStringAndBlobs(instructionsString: String, networkId: NetworkId, blobs: Blobs) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_transaction_manifest_from_instructions_string_and_blobs(
            FfiConverterString.lower(instructionsString),
            FfiConverterTypeNetworkID.lower(networkId),
            FfiConverterTypeBlobs.lower(blobs), $0
        )
    })
}

public func newTransactionManifestSample() -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_new_transaction_manifest_sample($0
        )
    })
}

public func newTransactionManifestSampleOther() -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_new_transaction_manifest_sample_other($0
        )
    })
}

public func newUnsecuredEntityControlSample() -> UnsecuredEntityControl {
    return try! FfiConverterTypeUnsecuredEntityControl.lift(try! rustCall {
        uniffi_sargon_fn_func_new_unsecured_entity_control_sample($0
        )
    })
}

public func newUnsecuredEntityControlSampleOther() -> UnsecuredEntityControl {
    return try! FfiConverterTypeUnsecuredEntityControl.lift(try! rustCall {
        uniffi_sargon_fn_func_new_unsecured_entity_control_sample_other($0
        )
    })
}

public func newValidatorAddress(bech32: String) throws -> ValidatorAddress {
    return try FfiConverterTypeValidatorAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_validator_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newValidatorAddressRandom(networkId: NetworkId) -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_validator_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newValidatorAddressSampleMainnet() -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_validator_address_sample_mainnet($0
        )
    })
}

public func newValidatorAddressSampleMainnetOther() -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_validator_address_sample_mainnet_other($0
        )
    })
}

public func newValidatorAddressSampleStokenet() -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_validator_address_sample_stokenet($0
        )
    })
}

public func newValidatorAddressSampleStokenetOther() -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_validator_address_sample_stokenet_other($0
        )
    })
}

public func newVaultAddress(bech32: String) throws -> VaultAddress {
    return try FfiConverterTypeVaultAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_vault_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newVaultAddressRandom(networkId: NetworkId) -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_vault_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newVaultAddressSampleMainnetFungible() -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_vault_address_sample_mainnet_fungible($0
        )
    })
}

public func newVaultAddressSampleMainnetNonFungible() -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_vault_address_sample_mainnet_non_fungible($0
        )
    })
}

public func newVaultAddressSampleStokenetFungible() -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_vault_address_sample_stokenet_fungible($0
        )
    })
}

public func newVaultAddressSampleStokenetNonFungible() -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_vault_address_sample_stokenet_non_fungible($0
        )
    })
}

public func newWalletToDappInteractionResponseFromJsonBytes(jsonBytes: BagOfBytes) throws -> WalletToDappInteractionResponse {
    return try FfiConverterTypeWalletToDappInteractionResponse.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_wallet_to_dapp_interaction_response_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newWalletToDappInteractionResponseSample() -> WalletToDappInteractionResponse {
    return try! FfiConverterTypeWalletToDappInteractionResponse.lift(try! rustCall {
        uniffi_sargon_fn_func_new_wallet_to_dapp_interaction_response_sample($0
        )
    })
}

public func newWalletToDappInteractionResponseSampleOther() -> WalletToDappInteractionResponse {
    return try! FfiConverterTypeWalletToDappInteractionResponse.lift(try! rustCall {
        uniffi_sargon_fn_func_new_wallet_to_dapp_interaction_response_sample_other($0
        )
    })
}

public func nonFungibleGlobalIdFormatted(globalId: NonFungibleGlobalId, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_global_id_formatted(
            FfiConverterTypeNonFungibleGlobalId.lower(globalId),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func nonFungibleGlobalIdToString(globalId: NonFungibleGlobalId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_global_id_to_string(
            FfiConverterTypeNonFungibleGlobalId.lower(globalId), $0
        )
    })
}

public func nonFungibleLocalIdAsStr(id: NonFungibleLocalId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_local_id_as_str(
            FfiConverterTypeNonFungibleLocalId.lower(id), $0
        )
    })
}

public func nonFungibleLocalIdFormatted(id: NonFungibleLocalId, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_local_id_formatted(
            FfiConverterTypeNonFungibleLocalId.lower(id),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func nonFungibleLocalIdToUserFacingString(id: NonFungibleLocalId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_local_id_to_user_facing_string(
            FfiConverterTypeNonFungibleLocalId.lower(id), $0
        )
    })
}

/**
 * Returns the base address of this specialized address.
 */
public func nonFungibleResourceAddressAsResourceAddress(address: NonFungibleResourceAddress) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_resource_address_as_resource_address(
            FfiConverterTypeNonFungibleResourceAddress.lower(address), $0
        )
    })
}

/**
 * Returns the bech32 encoding of this address
 */
public func nonFungibleResourceAddressBech32Address(address: NonFungibleResourceAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_resource_address_bech32_address(
            FfiConverterTypeNonFungibleResourceAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func nonFungibleResourceAddressMapToNetwork(address: NonFungibleResourceAddress, networkId: NetworkId) -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_resource_address_map_to_network(
            FfiConverterTypeNonFungibleResourceAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Returns the network id this address
 */
public func nonFungibleResourceAddressNetworkId(address: NonFungibleResourceAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_resource_address_network_id(
            FfiConverterTypeNonFungibleResourceAddress.lower(address), $0
        )
    })
}

public func nonFungibleResourceIndicatorGetIds(indicator: NonFungibleResourceIndicator) -> [NonFungibleLocalId] {
    return try! FfiConverterSequenceTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_resource_indicator_get_ids(
            FfiConverterTypeNonFungibleResourceIndicator.lower(indicator), $0
        )
    })
}

public func nonceGetValue(nonce: Nonce) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_fn_func_nonce_get_value(
            FfiConverterTypeNonce.lower(nonce), $0
        )
    })
}

public func notarizedTransactionCompile(notarizedTransaction: NotarizedTransaction) -> CompiledNotarizedIntent {
    return try! FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_notarized_transaction_compile(
            FfiConverterTypeNotarizedTransaction.lower(notarizedTransaction), $0
        )
    })
}

public func notarySignatureGetSignature(notarySignature: NotarySignature) -> Signature {
    return try! FfiConverterTypeSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_notary_signature_get_signature(
            FfiConverterTypeNotarySignature.lower(notarySignature), $0
        )
    })
}

public func p2PLinkToJsonBytes(p2PLink: P2pLink) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_p2_p_link_to_json_bytes(
            FfiConverterTypeP2PLink.lower(p2PLink), $0
        )
    })
}

public func p2pLinkId(link: P2pLink) -> PublicKeyHash {
    return try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
        uniffi_sargon_fn_func_p2p_link_id(
            FfiConverterTypeP2PLink.lower(link), $0
        )
    })
}

public func p2pLinksToJsonBytes(links: [P2pLink]) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_p2p_links_to_json_bytes(
            FfiConverterSequenceTypeP2PLink.lower(links), $0
        )
    })
}

public func packageAddressBech32Address(address: PackageAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_package_address_bech32_address(
            FfiConverterTypePackageAddress.lower(address), $0
        )
    })
}

public func packageAddressFormatted(address: PackageAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_package_address_formatted(
            FfiConverterTypePackageAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func packageAddressMapToNetwork(address: PackageAddress, networkId: NetworkId) -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_package_address_map_to_network(
            FfiConverterTypePackageAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func packageAddressNetworkId(address: PackageAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_package_address_network_id(
            FfiConverterTypePackageAddress.lower(address), $0
        )
    })
}

public func personaDataEntryEmailAddressToJsonString(personaDataEntryEmailAddress: PersonaDataEntryEmailAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_entry_email_address_to_json_string(
            FfiConverterTypePersonaDataEntryEmailAddress.lower(personaDataEntryEmailAddress), $0
        )
    })
}

public func personaDataEntryNameToJsonBytes(personaDataEntryName: PersonaDataEntryName) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_entry_name_to_json_bytes(
            FfiConverterTypePersonaDataEntryName.lower(personaDataEntryName), $0
        )
    })
}

public func personaDataEntryPhoneNumberToJsonString(personaDataEntryPhoneNumber: PersonaDataEntryPhoneNumber) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_entry_phone_number_to_json_string(
            FfiConverterTypePersonaDataEntryPhoneNumber.lower(personaDataEntryPhoneNumber), $0
        )
    })
}

public func personaDataIdentifiedEmailAddressSample() -> PersonaDataIdentifiedEmailAddress {
    return try! FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_identified_email_address_sample($0
        )
    })
}

public func personaDataIdentifiedEmailAddressSampleOther() -> PersonaDataIdentifiedEmailAddress {
    return try! FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_identified_email_address_sample_other($0
        )
    })
}

public func personaDataIdentifiedNameSample() -> PersonaDataIdentifiedName {
    return try! FfiConverterTypePersonaDataIdentifiedName.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_identified_name_sample($0
        )
    })
}

public func personaDataIdentifiedNameSampleOther() -> PersonaDataIdentifiedName {
    return try! FfiConverterTypePersonaDataIdentifiedName.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_identified_name_sample_other($0
        )
    })
}

public func personaDataIdentifiedPhoneNumberSample() -> PersonaDataIdentifiedPhoneNumber {
    return try! FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_identified_phone_number_sample($0
        )
    })
}

public func personaDataIdentifiedPhoneNumberSampleOther() -> PersonaDataIdentifiedPhoneNumber {
    return try! FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_identified_phone_number_sample_other($0
        )
    })
}

public func poolAddressBech32Address(address: PoolAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_pool_address_bech32_address(
            FfiConverterTypePoolAddress.lower(address), $0
        )
    })
}

public func poolAddressFormatted(address: PoolAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_pool_address_formatted(
            FfiConverterTypePoolAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns the kind of pool, either 1, 2 or Multi resources.
 */
public func poolAddressKind(address: PoolAddress) -> PoolKind {
    return try! FfiConverterTypePoolKind.lift(try! rustCall {
        uniffi_sargon_fn_func_pool_address_kind(
            FfiConverterTypePoolAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func poolAddressMapToNetwork(address: PoolAddress, networkId: NetworkId) -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_pool_address_map_to_network(
            FfiConverterTypePoolAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func poolAddressNetworkId(address: PoolAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_pool_address_network_id(
            FfiConverterTypePoolAddress.lower(address), $0
        )
    })
}

public func profileAnalyzeContentsOfFile(contents: String) -> ProfileFileContents {
    return try! FfiConverterTypeProfileFileContents.lift(try! rustCall {
        uniffi_sargon_fn_func_profile_analyze_contents_of_file(
            FfiConverterString.lower(contents), $0
        )
    })
}

public func profileEncryptWithPassword(profile: Profile, encryptionPassword: String) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_profile_encrypt_with_password(
            FfiConverterTypeProfile.lower(profile),
            FfiConverterString.lower(encryptionPassword), $0
        )
    })
}

public func profileNetworkDetailsForAuthorizedDapp(profileNetwork: ProfileNetwork, dapp: AuthorizedDapp) throws -> AuthorizedDappDetailed {
    return try FfiConverterTypeAuthorizedDappDetailed.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_profile_network_details_for_authorized_dapp(
            FfiConverterTypeProfileNetwork.lower(profileNetwork),
            FfiConverterTypeAuthorizedDapp.lower(dapp), $0
        )
    })
}

public func profileToDebugString(profile: Profile) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_profile_to_debug_string(
            FfiConverterTypeProfile.lower(profile), $0
        )
    })
}

public func profileToJsonString(profile: Profile, prettyPrinted: Bool) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_profile_to_json_string(
            FfiConverterTypeProfile.lower(profile),
            FfiConverterBool.lower(prettyPrinted), $0
        )
    })
}

public func profileToString(profile: Profile) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_profile_to_string(
            FfiConverterTypeProfile.lower(profile), $0
        )
    })
}

/**
 * Verifies an Elliptic Curve signature over either Curve25519 or Secp256k1
 */
public func publicKeyIsValidSignatureForHash(publicKey: PublicKey, signature: Signature, hash: Hash) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_public_key_is_valid_signature_for_hash(
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterTypeSignature.lower(signature),
            FfiConverterTypeHash.lower(hash), $0
        )
    })
}

public func publicKeyToBytes(publicKey: PublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_public_key_to_bytes(
            FfiConverterTypePublicKey.lower(publicKey), $0
        )
    })
}

public func publicKeyToHex(publicKey: PublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_public_key_to_hex(
            FfiConverterTypePublicKey.lower(publicKey), $0
        )
    })
}

public func radixConnectPasswordMessageHash(password: RadixConnectPassword) -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_fn_func_radix_connect_password_message_hash(
            FfiConverterTypeRadixConnectPassword.lower(password), $0
        )
    })
}

public func radixConnectPasswordToJsonString(radixConnectPassword: RadixConnectPassword) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_radix_connect_password_to_json_string(
            FfiConverterTypeRadixConnectPassword.lower(radixConnectPassword), $0
        )
    })
}

public func radixConnectPurposeToJsonString(radixConnectPurpose: RadixConnectPurpose) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_radix_connect_purpose_to_json_string(
            FfiConverterTypeRadixConnectPurpose.lower(radixConnectPurpose), $0
        )
    })
}

/**
 * Checks `number_of_ids` can fulfill the [`RequestedQuantity`] (self), `number_of_ids` is
 * considered to be fulfilling the requested quantity:
 * * if: quantifier == ::Exactly && number_of_ids == quantity // ✅ fulfills
 * * else if: quantifier == ::AtLeast && number_of_ids >= quantity // ✅ fulfills
 * * else false // ❌ does NOT fulfill
 */
public func requestedQuantityIsFulfilledByIds(requestedQuantity: RequestedQuantity, numberOfIds: UInt64) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_requested_quantity_is_fulfilled_by_ids(
            FfiConverterTypeRequestedQuantity.lower(requestedQuantity),
            FfiConverterUInt64.lower(numberOfIds), $0
        )
    })
}

public func requestedQuantityIsValid(requestedQuantity: RequestedQuantity) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_requested_quantity_is_valid(
            FfiConverterTypeRequestedQuantity.lower(requestedQuantity), $0
        )
    })
}

public func requestedQuantityToJsonBytes(requestedQuantity: RequestedQuantity) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_requested_quantity_to_json_bytes(
            FfiConverterTypeRequestedQuantity.lower(requestedQuantity), $0
        )
    })
}

public func resourceAddressBech32Address(address: ResourceAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_address_bech32_address(
            FfiConverterTypeResourceAddress.lower(address), $0
        )
    })
}

public func resourceAddressFormatted(address: ResourceAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_address_formatted(
            FfiConverterTypeResourceAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func resourceAddressIsFungible(address: ResourceAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_address_is_fungible(
            FfiConverterTypeResourceAddress.lower(address), $0
        )
    })
}

public func resourceAddressIsNonFungible(address: ResourceAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_address_is_non_fungible(
            FfiConverterTypeResourceAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func resourceAddressMapToNetwork(address: ResourceAddress, networkId: NetworkId) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_address_map_to_network(
            FfiConverterTypeResourceAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func resourceAddressNetworkId(address: ResourceAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_address_network_id(
            FfiConverterTypeResourceAddress.lower(address), $0
        )
    })
}

public func resourceIndicatorGetAddress(indicator: ResourceIndicator) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_indicator_get_address(
            FfiConverterTypeResourceIndicator.lower(indicator), $0
        )
    })
}

public func sLIP10CurveToJsonString(sLIP10Curve: Slip10Curve) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_s_l_i_p10_curve_to_json_string(
            FfiConverterTypeSLIP10Curve.lower(sLIP10Curve), $0
        )
    })
}

/**
 * Returns the current and the other gateways of `gateways`.
 */
public func savedGatewaysGetAllElements(gateways: SavedGateways) -> [Gateway] {
    return try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_saved_gateways_get_all_elements(
            FfiConverterTypeSavedGateways.lower(gateways), $0
        )
    })
}

/**
 * Returns the public key on **compressed** form (33 bytes)
 */
public func secp256k1PublicKeyToBytes(publicKey: Secp256k1PublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_secp256k1_public_key_to_bytes(
            FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
        )
    })
}

/**
 * Returns the public key on **uncompressed** form (65 bytes)
 */
public func secp256k1PublicKeyToBytesUncompressed(publicKey: Secp256k1PublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_secp256k1_public_key_to_bytes_uncompressed(
            FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
        )
    })
}

/**
 * Encodes the compressed form (33 bytes) of a `Secp256k1PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"033083620d1596d3f8988ff3270e42970dd2a031e2b9b6488052a4170ff999f3e8"`
 */
public func secp256k1PublicKeyToHex(publicKey: Secp256k1PublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_secp256k1_public_key_to_hex(
            FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
        )
    })
}

public func secp256k1SignatureToString(signature: Secp256k1Signature) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_secp256k1_signature_to_string(
            FfiConverterTypeSecp256k1Signature.lower(signature), $0
        )
    })
}

public func secureStorageKeyIdentifier(key: SecureStorageKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_secure_storage_key_identifier(
            FfiConverterTypeSecureStorageKey.lower(key), $0
        )
    })
}

public func signatureToBytes(signature: Signature) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_signature_to_bytes(
            FfiConverterTypeSignature.lower(signature), $0
        )
    })
}

public func signatureToString(signature: Signature) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_signature_to_string(
            FfiConverterTypeSignature.lower(signature), $0
        )
    })
}

public func signatureWithPublicKeyGetPublicKey(signatureWithPublicKey: SignatureWithPublicKey) -> PublicKey {
    return try! FfiConverterTypePublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_signature_with_public_key_get_public_key(
            FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey), $0
        )
    })
}

public func signatureWithPublicKeyGetSignature(signatureWithPublicKey: SignatureWithPublicKey) -> Signature {
    return try! FfiConverterTypeSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_signature_with_public_key_get_signature(
            FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey), $0
        )
    })
}

public func signatureWithPublicKeyIsValid(signatureWithPublicKey: SignatureWithPublicKey, forHash: Hash) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_signature_with_public_key_is_valid(
            FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey),
            FfiConverterTypeHash.lower(forHash), $0
        )
    })
}

public func signedIntentHash(signedIntent: SignedIntent) -> SignedIntentHash {
    return try! FfiConverterTypeSignedIntentHash.lift(try! rustCall {
        uniffi_sargon_fn_func_signed_intent_hash(
            FfiConverterTypeSignedIntent.lower(signedIntent), $0
        )
    })
}

public func signedIntentHashFormatted(address: SignedIntentHash, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_signed_intent_hash_formatted(
            FfiConverterTypeSignedIntentHash.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func slip10CurveToString(curve: Slip10Curve) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_slip10_curve_to_string(
            FfiConverterTypeSLIP10Curve.lower(curve), $0
        )
    })
}

/**
 * The standard transaction fee
 */
public func transactionFeePreset() -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_fee_preset($0
        )
    })
}

public func transactionIntentCompile(intent: TransactionIntent) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_intent_compile(
            FfiConverterTypeTransactionIntent.lower(intent), $0
        )
    })
}

public func transactionIntentHash(intent: TransactionIntent) -> IntentHash {
    return try! FfiConverterTypeIntentHash.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_intent_hash(
            FfiConverterTypeTransactionIntent.lower(intent), $0
        )
    })
}

public func transactionManifestBlobs(manifest: TransactionManifest) -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_manifest_blobs(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestExecutionSummary(manifest: TransactionManifest, encodedReceipt: BagOfBytes) throws -> ExecutionSummary {
    return try FfiConverterTypeExecutionSummary.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_transaction_manifest_execution_summary(
            FfiConverterTypeTransactionManifest.lower(manifest),
            FfiConverterTypeBagOfBytes.lower(encodedReceipt), $0
        )
    })
}

public func transactionManifestInstructionsString(manifest: TransactionManifest) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_manifest_instructions_string(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestInvolvedPoolAddresses(manifest: TransactionManifest) -> [PoolAddress] {
    return try! FfiConverterSequenceTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_manifest_involved_pool_addresses(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestInvolvedResourceAddresses(manifest: TransactionManifest) -> [ResourceAddress] {
    return try! FfiConverterSequenceTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_manifest_involved_resource_addresses(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestNetworkId(manifest: TransactionManifest) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_manifest_network_id(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestSummary(manifest: TransactionManifest) -> ManifestSummary {
    return try! FfiConverterTypeManifestSummary.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_manifest_summary(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func validatorAddressBech32Address(address: ValidatorAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_validator_address_bech32_address(
            FfiConverterTypeValidatorAddress.lower(address), $0
        )
    })
}

public func validatorAddressFormatted(address: ValidatorAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_validator_address_formatted(
            FfiConverterTypeValidatorAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func validatorAddressMapToNetwork(address: ValidatorAddress, networkId: NetworkId) -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_validator_address_map_to_network(
            FfiConverterTypeValidatorAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func validatorAddressNetworkId(address: ValidatorAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_validator_address_network_id(
            FfiConverterTypeValidatorAddress.lower(address), $0
        )
    })
}

public func vaultAddressBech32Address(address: VaultAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_vault_address_bech32_address(
            FfiConverterTypeVaultAddress.lower(address), $0
        )
    })
}

public func vaultAddressFormatted(address: VaultAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_vault_address_formatted(
            FfiConverterTypeVaultAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func vaultAddressIsFungible(address: VaultAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_vault_address_is_fungible(
            FfiConverterTypeVaultAddress.lower(address), $0
        )
    })
}

public func vaultAddressIsNonFungible(address: VaultAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_vault_address_is_non_fungible(
            FfiConverterTypeVaultAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func vaultAddressMapToNetwork(address: VaultAddress, networkId: NetworkId) -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_vault_address_map_to_network(
            FfiConverterTypeVaultAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func vaultAddressNetworkId(address: VaultAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_vault_address_network_id(
            FfiConverterTypeVaultAddress.lower(address), $0
        )
    })
}

public func walletToDappInteractionResponseToJsonBytes(walletToDappInteractionResponse: WalletToDappInteractionResponse) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_wallet_to_dapp_interaction_response_to_json_bytes(
            FfiConverterTypeWalletToDappInteractionResponse.lower(walletToDappInteractionResponse), $0
        )
    })
}

public func xrdAddressOfNetwork(networkId: NetworkId) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_xrd_address_of_network(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_sargon_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_sargon_checksum_func_access_controller_address_bech32_address() != 25760 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_access_controller_address_formatted() != 38684 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_access_controller_address_map_to_network() != 7653 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_access_controller_address_network_id() != 33560 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_bech32_address() != 17948 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_formatted() != 20450 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_is_legacy() != 10971 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_map_to_network() != 36457 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_network_id() != 30596 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_or_address_of_account_address() != 7165 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_or_persona_get_id() != 16313 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_formatted() != 39678 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_map_to_network() != 53347 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_network_id() != 35977 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_of_account_or_persona_formatted() != 33377 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_of_account_or_persona_map_to_network() != 26788 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_of_account_or_persona_network_id() != 61255 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_of_account_or_persona_sample_values_all() != 37634 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_of_account_or_persona_to_string() != 61010 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_sample_values_all() != 44889 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_to_string() != 4384 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_android_notarize_hash_with_private_key_bytes() != 27531 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_android_secret_key_get_public_key_from_private_key_bytes() != 17350 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_android_sign_hash_with_private_key_bytes() != 26678 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_appearance_ids_all() != 44342 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_authorized_dapp_to_json_bytes() != 57472 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_b_i_p39_seed_to_bytes() != 29747 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bag_of_bytes_append_cafe() != 36568 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bag_of_bytes_append_deadbeef() != 37334 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bag_of_bytes_prepend_cafe() != 13192 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bag_of_bytes_prepend_deadbeef() != 48562 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bip39_language_wordlist() != 26097 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bip39_word_count_all() != 27954 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bip44_like_path_get_address_index() != 20616 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bip44_like_path_to_string() != 15736 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_blob_to_bytes() != 37344 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_blob_to_string() != 26081 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_blobs_list_of_blobs() != 64282 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_build_information() != 42216 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_cap26_path_to_string() != 27173 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_check_if_encrypted_profile_json_contains_legacy_p2p_links() != 26929 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_check_if_profile_json_contains_legacy_p2p_links() != 57987 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_compiled_notarized_intent_get_bytes() != 46331 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_bech32_address() != 43553 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_formatted() != 21837 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_is_global() != 52839 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_is_internal() != 64064 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_map_to_network() != 39090 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_network_id() != 20181 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_dapp_to_wallet_interaction_unvalidated_to_json_bytes() != 19171 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_debug_print_compiled_notarized_intent() != 41819 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_abs() != 51780 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_add() != 5696 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_clamped_to_zero() != 43405 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_div() != 54870 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_formatted() != 33239 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_formatted_plain() != 4879 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_greater_than() != 2639 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_greater_than_or_equal() != 22351 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_is_negative() != 21361 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_is_positive() != 57369 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_is_zero() != 56403 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_less_than() != 59937 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_less_than_or_equal() != 28175 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_max() != 7974 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_min() != 12755 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_mul() != 55479 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_neg() != 45257 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_round() != 18483 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_sub() != 7791 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_to_string() != 32945 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_default_get_id_path() != 16971 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_dependency_information_to_string() != 33585 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_deposit_rule_to_json_string() != 36586 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_derivation_path_to_hd_path() != 9453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_derivation_path_to_string() != 35541 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_device_factor_source_is_main_bdfs() != 6200 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_device_info_to_json_bytes() != 47501 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_display_name_to_json_string() != 63874 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ed25519_public_key_to_bytes() != 28864 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ed25519_public_key_to_hex() != 54633 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ed25519_public_key_to_json_string() != 11961 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ed25519_signature_to_json_string() != 63609 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ed25519_signature_to_string() != 54939 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_enable_logging_from_rust() != 36606 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_entropy16_bytes_to_bytes() != 54982 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_entropy20_bytes_to_bytes() != 22819 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_entropy24_bytes_to_bytes() != 42186 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_entropy28_bytes_to_bytes() != 39686 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_entropy32_bytes_to_bytes() != 21935 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_error_code_from_error() != 36211 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_error_message_from_error() != 51552 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly12_bytes_to_json_string() != 39975 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly29_bytes_to_json_string() != 18109 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly32_bytes_to_json_string() != 10726 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly33_bytes_to_json_string() != 37117 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly64_bytes_to_json_string() != 64434 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly65_bytes_to_json_string() != 13120 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_12_bytes_to_bytes() != 14031 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_12_bytes_to_hex() != 28250 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_29_bytes_to_bytes() != 4894 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_29_bytes_to_hex() != 54665 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_32_bytes_to_bytes() != 31576 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_32_bytes_to_hex() != 22925 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_33_bytes_to_bytes() != 1951 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_33_bytes_to_hex() != 20116 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_64_bytes_to_bytes() != 40334 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_64_bytes_to_hex() != 4287 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_65_bytes_to_bytes() != 27895 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_65_bytes_to_hex() != 45594 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_crypto_parameters_supports_babylon() != 52938 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_crypto_parameters_supports_olympia() != 10349 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_i_d_from_address_to_json_bytes() != 20208 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_i_d_from_hash_to_json_bytes() != 19779 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_id_from_address_to_string() != 28754 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_id_from_hash_to_string() != 10880 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_id_to_string() != 14810 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_kind_to_string() != 21223 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_supports_babylon() != 51556 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_supports_olympia() != 42687 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_to_string() != 17785 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_fiat_currency_to_json_string() != 24935 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_fungible_resource_indicator_get_amount() != 6672 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_id() != 62487 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_is_wellknown() != 27630 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_mainnet() != 6356 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_stokenet() != 5043 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_to_string() != 8255 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_wellknown_gateways() != 49249 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_hash() != 34377 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_hash_get_bytes() != 19768 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_hd_path_component_get_non_hardened_value() != 14531 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_header_to_json_bytes() != 5217 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_hierarchical_deterministic_public_key_is_valid_signature_for_hash() != 52778 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_identity_address_bech32_address() != 46543 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_identity_address_formatted() != 21987 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_identity_address_map_to_network() != 10517 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_identity_address_network_id() != 47961 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_intent_hash_formatted() != 9910 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_intent_signature_get_signature_with_public_key() != 59082 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ledger_hw_wallet_model_to_string() != 31313 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_legacy_olympia_account_address_formatted() != 61803 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_legacy_olympia_account_address_is_legacy_of_babylon() != 42848 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_legacy_olympia_account_address_to_babylon_account_address() != 27801 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_legacy_olympia_account_address_to_string() != 31113 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_link_connection_q_r_data_to_json_bytes() != 8014 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_create_fungible_token() != 24371 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_create_fungible_token_with_metadata() != 13453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_create_multiple_fungible_tokens() != 9423 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_create_multiple_non_fungible_tokens() != 18157 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_create_non_fungible_token() != 369 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_for_faucet() != 17078 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_marking_account_as_dapp_definition_type() != 20272 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_per_asset_transfers() != 26522 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_per_recipient_transfers() != 24398 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_set_owner_keys_hashes() != 35668 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_stakes_claim() != 47426 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_third_party_deposit_update() != 63597 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_message_as_plaintext() != 59034 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_mnemonic_phrase() != 29100 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_mnemonic_with_passphrase_derive_public_keys() != 33297 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_mnemonic_with_passphrase_sign() != 12503 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_mnemonic_with_passphrase_to_json_bytes() != 44720 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_mnemonic_with_passphrase_validate_public_keys() != 37731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_modify_manifest_add_guarantees() != 15542 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_modify_manifest_lock_fee() != 62376 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_network_id_discriminant() != 18637 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_network_id_to_string() != 9410 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_network_ids_all() != 37779 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_access_controller_address() != 33601 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_access_controller_address_random() != 41855 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_access_controller_address_sample_mainnet() != 37312 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_access_controller_address_sample_mainnet_other() != 8789 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_access_controller_address_sample_stokenet() != 8365 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_access_controller_address_sample_stokenet_other() != 63709 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address() != 2569 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_from() != 41026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_random() != 51693 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_sample_mainnet() != 54570 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_sample_mainnet_other() != 32731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_sample_stokenet() != 65160 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_sample_stokenet_other() != 9463 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_for_display_sample() != 30591 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_for_display_sample_other() != 46613 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_address_of_sample() != 2477 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_address_of_sample_other() != 690 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_persona_sample_mainnet() != 47397 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_persona_sample_mainnet_other() != 50672 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_persona_sample_mainnet_third() != 54497 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_persona_sample_stokenet() != 42304 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_persona_sample_stokenet_other() != 25620 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_persona_sample_stokenet_third() != 52742 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_path() != 58971 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_path_sample() != 38953 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_path_sample_other() != 29077 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_mainnet_alice() != 2121 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_mainnet_bob() != 12275 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_mainnet_carol() != 43098 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_mainnet_diana() != 62921 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_stokenet_nadia() != 59452 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_stokenet_olivia() != 26665 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_stokenet_paige() != 15474 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accounts_for_display_sample() != 56319 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accounts_for_display_sample_other() != 18568 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accounts_or_personas_sample() != 57382 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accounts_or_personas_sample_other() != 37298 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accounts_sample() != 52304 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accounts_sample_other() != 55827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_from_bech32() != 37020 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_from_bech32() != 42616 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_account_mainnet() != 50600 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_account_mainnet_other() != 57767 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_account_stokenet() != 5321 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_account_stokenet_other() != 11425 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_identity_mainnet() != 32276 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_identity_mainnet_other() != 62845 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_identity_stokenet() != 58184 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_identity_stokenet_other() != 19614 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_mainnet() != 16347 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_mainnet_other() != 43108 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_stokenet() != 13408 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_stokenet_other() != 61142 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_access_controller_mainnet() != 28069 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_access_controller_mainnet_other() != 30642 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_access_controller_stokenet() != 62734 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_access_controller_stokenet_other() != 26659 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_account_mainnet() != 56609 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_account_mainnet_other() != 6596 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_account_stokenet() != 18414 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_account_stokenet_other() != 55369 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_component_mainnet() != 27352 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_component_mainnet_other() != 51433 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_component_stokenet() != 60532 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_component_stokenet_other() != 18123 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_identity_mainnet() != 61162 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_identity_mainnet_other() != 49232 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_identity_stokenet() != 39938 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_identity_stokenet_other() != 35441 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_mainnet() != 8425 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_mainnet_other() != 47495 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_package_mainnet() != 22566 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_package_mainnet_other() != 32671 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_package_stokenet() != 31480 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_package_stokenet_other() != 21526 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_pool_mainnet() != 16663 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_pool_mainnet_other() != 19344 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_pool_stokenet() != 45966 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_pool_stokenet_other() != 53469 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_resource_mainnet() != 65163 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_resource_mainnet_other() != 17673 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_resource_stokenet() != 42435 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_resource_stokenet_other() != 24663 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_stokenet() != 44722 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_stokenet_other() != 48831 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_validator_mainnet() != 26468 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_validator_mainnet_other() != 819 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_validator_stokenet() != 27575 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_validator_stokenet_other() != 59068 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_vault_mainnet() != 56941 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_vault_mainnet_other() != 20624 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_vault_stokenet() != 47675 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_vault_stokenet_other() != 23277 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_app_preferences_default() != 21875 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_app_preferences_sample() != 26430 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_app_preferences_sample_other() != 22597 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_appearance_id() != 28026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_appearance_id_from_number_of_accounts_on_network() != 48123 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_appearance_id_sample() != 60944 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_appearance_id_sample_other() != 1141 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_asset_exception_sample() != 51557 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_asset_exception_sample_other() != 54109 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_assets_exception_list_sample() != 744 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_assets_exception_list_sample_other() != 64252 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_detailed_sample() != 17085 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_detailed_sample_other() != 45014 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_from_json_bytes() != 25043 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_sample_mainnet_dashboard() != 11297 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_sample_mainnet_gumballclub() != 13607 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_sample_stokenet_devconsole() != 25090 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_sample_stokenet_sandbox() != 34108 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapps_sample() != 15614 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapps_sample_other() != 41193 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_persona_detailed_sample() != 48419 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_persona_detailed_sample_other() != 45187 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_persona_simple_sample_mainnet() != 9711 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_persona_simple_sample_mainnet_other() != 37878 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_persona_simple_sample_stokenet() != 60086 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_persona_simple_sample_stokenet_other() != 40314 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_b_i_p39_seed_from_bytes() != 6677 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_b_i_p39_seed_sample() != 20641 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_b_i_p39_seed_sample_other() != 60764 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_from() != 22344 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_sample_aced() != 64842 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_sample_babe() != 62899 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_sample_cafe() != 37207 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_sample_dead() != 5095 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_sample_ecad() != 34034 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_sample_fade() != 12927 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip39_language_sample() != 7193 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip39_language_sample_other() != 51248 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip39_word_sample() != 31657 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip39_word_sample_other() != 63848 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip44_like_path_from_index() != 28361 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip44_like_path_from_string() != 58508 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip44_like_path_sample() != 2907 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip44_like_path_sample_other() != 35179 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_blob_from_bytes() != 40775 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_blobs_from_blob_list() != 54212 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_blobs_sample() != 23083 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_blobs_sample_other() != 32184 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_cap26_path_from_string() != 34117 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_compiled_notarized_intent_sample() != 6366 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_compiled_notarized_intent_sample_other() != 36824 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address() != 30761 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address_random() != 27144 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address_sample_mainnet_global() != 46435 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address_sample_mainnet_internal() != 15814 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address_sample_stokenet_global() != 43113 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address_sample_stokenet_internal() != 30221 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_dapp_to_wallet_interaction_unvalidated_from_json_bytes() != 15557 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_dapp_to_wallet_interaction_unvalidated_sample() != 59961 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_dapp_to_wallet_interaction_unvalidated_sample_other() != 56169 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_exponent() != 14708 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_f32() != 56764 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_f64() != 20942 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_formatted_string() != 61026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_i32() != 58273 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_i64() != 54406 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_string() != 43065 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_u32() != 44217 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_u64() != 34678 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_dependency_information_sample() != 33653 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_dependency_information_sample_other() != 4043 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_deposit_rule_from_json_string() != 38629 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_deposit_rule_sample() != 660 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_deposit_rule_sample_other() != 47005 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_depositors_allow_list_sample() != 33963 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_depositors_allow_list_sample_other() != 42234 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_derivation_path_from_string() != 7796 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_derivation_path_sample() != 63533 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_derivation_path_sample_other() != 564 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_detailed_authorized_personas_sample() != 19857 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_detailed_authorized_personas_sample_other() != 23779 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_factor_source_babylon() != 32662 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_factor_source_olympia() != 49325 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_factor_source_sample() != 12227 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_factor_source_sample_other() != 46676 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_info_from_json_bytes() != 9588 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_info_iphone() != 61302 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_info_sample() != 33011 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_info_sample_other() != 53887 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_display_name() != 49394 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_display_name_from_json_string() != 16707 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_display_name_sample() != 2735 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_display_name_sample_other() != 31614 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_from_bytes() != 44499 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_from_hex() != 12721 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_from_json_string() != 35081 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_sample() != 16099 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_sample_other() != 16541 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_signature_from_bytes() != 64374 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_signature_from_exactly_64_bytes() != 25736 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_signature_from_json_string() != 63670 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_signature_sample() != 47710 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_signature_sample_other() != 12189 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entity_flag_sample() != 32449 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entity_flag_sample_other() != 47403 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entity_flags_sample() != 36473 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entity_flags_sample_other() != 19054 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entity_security_state_sample() != 54665 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entity_security_state_sample_other() != 60901 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy16_bytes_from_bytes() != 24861 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy16_bytes_sample() != 4672 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy16_bytes_sample_other() != 4616 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy20_bytes_from_bytes() != 64190 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy20_bytes_sample() != 52002 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy20_bytes_sample_other() != 31754 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy24_bytes_from_bytes() != 44872 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy24_bytes_sample() != 2550 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy24_bytes_sample_other() != 17735 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy28_bytes_from_bytes() != 43695 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy28_bytes_sample() != 34080 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy28_bytes_sample_other() != 64297 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy32_bytes_from_bytes() != 32787 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy32_bytes_sample() != 32839 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy32_bytes_sample_other() != 25511 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly12_bytes_from_json_string() != 14387 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly29_bytes_from_json_string() != 3419 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly32_bytes_from_json_string() != 18496 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly33_bytes_from_json_string() != 356 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly64_bytes_from_json_string() != 51604 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly65_bytes_from_json_string() != 53948 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_12_bytes() != 27335 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_12_bytes_sample() != 26574 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_12_bytes_sample_other() != 24711 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_29_bytes() != 10056 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_29_bytes_sample() != 6180 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_29_bytes_sample_other() != 29088 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_32_bytes() != 15118 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_32_bytes_sample() != 62764 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_32_bytes_sample_other() != 27949 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_33_bytes() != 50447 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_33_bytes_sample() != 43005 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_33_bytes_sample_other() != 59502 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_64_bytes() != 29843 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_64_bytes_sample() != 48926 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_64_bytes_sample_other() != 25972 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_65_bytes() != 53842 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_65_bytes_sample() != 41067 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_65_bytes_sample_other() != 14279 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_crypto_parameters_preset_babylon_olympia_compatible() != 48552 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_crypto_parameters_preset_babylon_only() != 44467 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_crypto_parameters_preset_olympia_only() != 16590 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_crypto_parameters_sample() != 41685 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_crypto_parameters_sample_other() != 8264 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_i_d_from_address_from_json_bytes() != 16029 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_i_d_from_hash_from_json_bytes() != 31521 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_from_address_sample() != 30773 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_from_address_sample_other() != 37306 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_from_hash_from_mnemonic_with_passphrase() != 2864 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_from_hash_sample() != 30682 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_from_hash_sample_other() != 9217 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_sample() != 7044 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_sample_other() != 32146 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_kind_from_string() != 15813 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_kind_sample() != 7003 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_kind_sample_other() != 58539 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_sample() != 23677 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_sample_other() != 57438 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_sources_sample() != 30863 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_sources_sample_other() != 38923 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_fiat_currency_from_json_string() != 17012 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_fiat_currency_sample() != 21848 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_fiat_currency_sample_other() != 17430 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_fungible_resource_indicator_sample() != 3324 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_fungible_resource_indicator_sample_other() != 51322 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateway_for_network_id() != 50026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateway_sample() != 11459 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateway_sample_other() != 27151 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateway_with_url_on_network() != 58891 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateways_sample() != 42979 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateways_sample_other() != 56017 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hash_from_bytes() != 43039 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hash_from_string() != 61249 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hash_sample() != 5937 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hash_sample_other() != 44813 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_header_from_json_bytes() != 20504 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_header_sample() != 6569 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_header_sample_other() != 55288 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_header_with_creating_device() != 38434 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hierarchical_deterministic_factor_instance_sample() != 7709 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hierarchical_deterministic_factor_instance_sample_other() != 33009 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hierarchical_deterministic_public_key_sample() != 19868 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hierarchical_deterministic_public_key_sample_other() != 13967 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address() != 43870 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_from() != 50540 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_random() != 38925 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_sample_mainnet() != 1456 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_sample_mainnet_other() != 10234 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_sample_stokenet() != 36518 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_sample_stokenet_other() != 60923 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_path() != 50878 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_path_sample() != 6128 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_path_sample_other() != 52443 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_intent_hash_from_string() != 19100 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_intent_hash_sample() != 36275 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_intent_hash_sample_other() != 5461 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_intent_signature_from_signature_with_public_key() != 49901 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_intent_signature_sample() != 31835 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_intent_signature_sample_other() != 12904 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ledger_hardware_wallet_factor_source_sample() != 29405 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ledger_hardware_wallet_factor_source_sample_other() != 30760 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ledger_hw_wallet_model_from_string() != 33130 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ledger_hw_wallet_model_sample() != 7084 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ledger_hw_wallet_model_sample_other() != 19248 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_legacy_olympia_account_address_from_public_key() != 48548 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_legacy_olympia_account_address_from_string() != 47049 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_legacy_olympia_account_address_sample() != 7469 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_legacy_olympia_account_address_sample_other() != 34844 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_link_connection_q_r_data_from_json_bytes() != 4678 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_link_connection_qr_data_sample() != 51383 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_link_connection_qr_data_sample_other() != 9392 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_message_plaintext_sample() != 43854 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_message_plaintext_sample_other() != 25629 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_message_plaintext_string() != 45759 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_from_phrase() != 56379 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_from_phrase_language() != 38433 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_from_words() != 54068 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_generate_with_entropy() != 14363 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample() != 19146 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_other() != 15519 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_with_passphrase_from_json_bytes() != 17411 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_with_passphrase_sample() != 21291 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_with_passphrase_sample_other() != 47176 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mobile_connect_request() != 34930 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_network_definition_lookup_by_name() != 16885 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_network_definition_sample() != 65271 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_network_definition_sample_other() != 42724 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_network_id_from_discriminant() != 37300 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_empty_max_32_bytes() != 41452 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_empty_max_64_bytes() != 47176 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_global_id_from_string() != 59679 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_global_id_sample() != 55156 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_global_id_sample_other() != 41952 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_bytes() != 49201 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_from_string() != 30684 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_int() != 31453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_random() != 23592 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_ruid() != 14178 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_sample() != 9803 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_sample_other() != 861 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_string() != 52482 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_string_from_str() != 61386 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_address() != 54503 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_address_random() != 46740 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_address_sample_mainnet() != 21380 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_address_sample_mainnet_other() != 55440 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_address_sample_stokenet() != 40241 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_address_sample_stokenet_other() != 62264 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_indicator_sample() != 11037 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_indicator_sample_other() != 35376 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_nonce_from_u32() != 11136 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_nonce_random() != 43651 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_nonce_sample() != 11088 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_nonce_sample_other() != 41267 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_notarized_transaction_sample() != 21364 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_notarized_transaction_sample_other() != 59703 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_notary_signature() != 36292 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_notary_signature_sample() != 45924 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_notary_signature_sample_other() != 61991 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_on_ledger_settings_default() != 29280 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_on_ledger_settings_sample() != 12028 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_on_ledger_settings_sample_other() != 35880 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_p2_p_link_from_json_bytes() != 38518 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_p2_p_links_sample() != 15609 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_p2_p_links_sample_other() != 58469 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_p2p_link_sample() != 10175 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_p2p_link_sample_other() != 21151 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_p2p_links_from_json_bytes() != 207 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address() != 37949 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address_random() != 41695 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address_sample_mainnet() != 26382 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address_sample_mainnet_other() != 1195 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address_sample_stokenet() != 18632 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address_sample_stokenet_other() != 52864 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_per_asset_transfers_sample() != 517 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_per_asset_transfers_sample_other() != 38110 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_email_address_from_json_string() != 24623 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_email_address_sample() != 42811 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_email_address_sample_other() != 43855 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_name_from_json_bytes() != 59599 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_name_sample() != 13808 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_name_sample_other() != 25465 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_phone_number_from_json_string() != 123 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_phone_number_sample() != 6672 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_phone_number_sample_other() != 8545 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_sample() != 18517 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_sample_other() != 29352 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample() != 29567 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_mainnet_batman() != 23030 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_mainnet_ripley() != 16938 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_mainnet_satoshi() != 8417 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_mainnet_turing() != 17821 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_other() != 5281 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_stokenet_connor() != 57340 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_stokenet_hermione() != 32750 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_stokenet_leia_skywalker() != 60650 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_personas_sample() != 5762 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_personas_sample_other() != 22085 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address() != 28108 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_random() != 33642 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_sample_mainnet_multi() != 24097 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_sample_mainnet_single() != 21300 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_sample_mainnet_two() != 16203 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_sample_stokenet_multi() != 44248 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_sample_stokenet_single() != 47667 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_sample_stokenet_two() != 47935 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_private_hd_factor_source_babylon() != 19523 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_private_hd_factor_source_babylon_from_mnemonic_with_passphrase() != 48329 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_private_hd_factor_source_olympia_from_mnemonic_with_passphrase() != 61013 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_private_hd_factor_source_sample() != 12746 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_private_hd_factor_source_sample_other() != 13964 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile() != 59141 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_file_contents_sample() != 39969 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_file_contents_sample_other() != 56084 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_from_encryption_bytes() != 51120 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_from_json_string() != 1521 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_network_sample() != 17110 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_network_sample_other() != 28204 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_networks_sample() != 60392 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_networks_sample_other() != 64081 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_sample() != 22947 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_sample_other() != 849 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_from_bytes() != 26414 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_from_hex() != 62045 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_hash_of_key() != 60132 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_hash_sample() != 51315 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_hash_sample_other() != 8307 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_sample() != 48753 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_sample_other() != 44351 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_password() != 19430 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_password_from_json_string() != 43786 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_password_sample() != 56632 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_password_sample_other() != 54337 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_purpose_from_json_string() != 30750 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_purpose_from_string() != 8155 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_purpose_sample() != 58545 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_purpose_sample_other() != 24082 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_references_to_authorized_personas_sample() != 47667 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_references_to_authorized_personas_sample_other() != 2789 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_requested_quantity_from_json_bytes() != 35249 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_requested_quantity_sample() != 55234 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_requested_quantity_sample_other() != 19700 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address() != 6366 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_random() != 45912 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_mainnet_candy() != 29968 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_mainnet_nft_gc_membership() != 62029 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_mainnet_xrd() != 6138 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_stokenet_candy() != 44981 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_stokenet_gc_tokens() != 11387 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_stokenet_gum() != 45465 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_stokenet_xrd() != 27754 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_indicator_sample() != 63296 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_indicator_sample_other() != 24416 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_or_non_fungible_sample() != 17434 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_or_non_fungible_sample_other() != 29487 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_s_l_i_p10_curve_from_json_string() != 51394 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_sargon_build_information_sample() != 35264 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_sargon_build_information_sample_other() != 42234 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_saved_gateways() != 7808 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_saved_gateways_changing_current() != 46302 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_saved_gateways_default() != 12465 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_saved_gateways_sample() != 8684 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_saved_gateways_sample_other() != 25471 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_public_key_from_bytes() != 19094 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_public_key_from_hex() != 4874 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_public_key_sample() != 25738 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_public_key_sample_other() != 19432 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_signature_from_bytes() != 59032 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_signature_from_exactly_65_bytes() != 35236 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_signature_sample() != 53404 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_signature_sample_other() != 45166 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_shared_persona_data_sample() != 41760 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_shared_persona_data_sample_other() != 21162 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signature_from_bytes() != 16399 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signature_sample() != 40187 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signature_sample_other() != 15062 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signature_with_public_key_sample() != 3544 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signature_with_public_key_sample_other() != 2691 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signed_intent_hash_from_string() != 9298 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signed_intent_hash_sample() != 20533 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signed_intent_hash_sample_other() != 47194 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signed_intent_sample() != 43628 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signed_intent_sample_other() != 1979 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_slip10_curve_from_string() != 5484 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_stake_claim_sample() != 34303 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_stake_claim_sample_other() != 9047 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_supported_curves_sample() != 38686 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_supported_curves_sample_other() != 47661 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_third_party_deposits_default() != 30385 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_third_party_deposits_sample() != 55284 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_third_party_deposits_sample_other() != 56077 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_header_sample() != 61986 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_header_sample_other() != 43736 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_intent_sample() != 11735 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_intent_sample_other() != 54416 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_manifest_from_instructions_string_and_blobs() != 477 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_manifest_sample() != 63778 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_manifest_sample_other() != 38915 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_unsecured_entity_control_sample() != 19695 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_unsecured_entity_control_sample_other() != 10502 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address() != 26715 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address_random() != 37504 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address_sample_mainnet() != 57279 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address_sample_mainnet_other() != 1884 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address_sample_stokenet() != 5339 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address_sample_stokenet_other() != 25591 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address() != 11091 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address_random() != 27536 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address_sample_mainnet_fungible() != 23460 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address_sample_mainnet_non_fungible() != 58209 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address_sample_stokenet_fungible() != 30491 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address_sample_stokenet_non_fungible() != 60444 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_wallet_to_dapp_interaction_response_from_json_bytes() != 7825 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_wallet_to_dapp_interaction_response_sample() != 36669 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_wallet_to_dapp_interaction_response_sample_other() != 2432 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_global_id_formatted() != 43733 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_global_id_to_string() != 39748 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_local_id_as_str() != 56180 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_local_id_formatted() != 15563 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_local_id_to_user_facing_string() != 55152 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_resource_address_as_resource_address() != 59145 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_resource_address_bech32_address() != 3970 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_resource_address_map_to_network() != 12314 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_resource_address_network_id() != 31736 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_resource_indicator_get_ids() != 44094 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_nonce_get_value() != 8562 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_notarized_transaction_compile() != 62096 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_notary_signature_get_signature() != 52377 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_p2_p_link_to_json_bytes() != 16315 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_p2p_link_id() != 10640 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_p2p_links_to_json_bytes() != 12947 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_package_address_bech32_address() != 54775 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_package_address_formatted() != 8252 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_package_address_map_to_network() != 52718 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_package_address_network_id() != 5555 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_entry_email_address_to_json_string() != 50372 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_entry_name_to_json_bytes() != 54193 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_entry_phone_number_to_json_string() != 16974 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_identified_email_address_sample() != 52470 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_identified_email_address_sample_other() != 178 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_identified_name_sample() != 62267 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_identified_name_sample_other() != 16367 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_identified_phone_number_sample() != 32965 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_identified_phone_number_sample_other() != 19226 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_pool_address_bech32_address() != 47256 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_pool_address_formatted() != 4906 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_pool_address_kind() != 54453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_pool_address_map_to_network() != 41332 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_pool_address_network_id() != 42097 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_profile_analyze_contents_of_file() != 10056 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_profile_encrypt_with_password() != 22486 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_profile_network_details_for_authorized_dapp() != 39168 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_profile_to_debug_string() != 1782 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_profile_to_json_string() != 61644 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_profile_to_string() != 25731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_public_key_is_valid_signature_for_hash() != 86 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_public_key_to_bytes() != 27512 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_public_key_to_hex() != 22162 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_radix_connect_password_message_hash() != 2615 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_radix_connect_password_to_json_string() != 23214 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_radix_connect_purpose_to_json_string() != 51972 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_requested_quantity_is_fulfilled_by_ids() != 47126 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_requested_quantity_is_valid() != 61093 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_requested_quantity_to_json_bytes() != 57734 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_bech32_address() != 61503 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_formatted() != 44562 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_is_fungible() != 53819 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_is_non_fungible() != 50396 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_map_to_network() != 16830 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_network_id() != 26803 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_indicator_get_address() != 122 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_s_l_i_p10_curve_to_json_string() != 41585 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_saved_gateways_get_all_elements() != 44642 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secp256k1_public_key_to_bytes() != 48737 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secp256k1_public_key_to_bytes_uncompressed() != 49512 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secp256k1_public_key_to_hex() != 62658 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secp256k1_signature_to_string() != 50053 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secure_storage_key_identifier() != 30568 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signature_to_bytes() != 39380 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signature_to_string() != 61098 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signature_with_public_key_get_public_key() != 32591 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signature_with_public_key_get_signature() != 62703 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signature_with_public_key_is_valid() != 50388 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signed_intent_hash() != 12469 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signed_intent_hash_formatted() != 44800 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_slip10_curve_to_string() != 45343 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_fee_preset() != 14032 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_intent_compile() != 48674 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_intent_hash() != 25944 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_blobs() != 45400 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_execution_summary() != 54879 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_instructions_string() != 28699 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_involved_pool_addresses() != 58037 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_involved_resource_addresses() != 11845 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_network_id() != 61620 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_summary() != 27199 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_validator_address_bech32_address() != 16268 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_validator_address_formatted() != 12167 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_validator_address_map_to_network() != 57873 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_validator_address_network_id() != 45312 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_bech32_address() != 4501 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_formatted() != 63212 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_is_fungible() != 47259 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_is_non_fungible() != 44675 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_map_to_network() != 42813 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_network_id() != 28367 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_wallet_to_dapp_interaction_response_to_json_bytes() != 17356 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_xrd_address_of_network() != 8656 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_gatewayclient_current_epoch() != 23731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_gatewayclient_dry_run_transaction() != 148 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_gatewayclient_submit_notarized_transaction() != 36728 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_gatewayclient_xrd_balance_of_account() != 10716 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_gatewayclient_xrd_balance_of_account_or_zero() != 30651 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_networkantenna_execute_network_request() != 288 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_securestorage_load_data() != 34282 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_securestorage_save_data() != 18790 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_securestorage_delete_data_for_key() != 16947 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_add_account() != 19712 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_change_name_of_account() != 18774 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_create_and_save_new_account() != 34309 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_create_new_account() != 53472 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_json_snapshot() != 24850 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_main_bdfs_mnemonic_with_passphrase() != 59906 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_mnemonic_with_passphrase_of_device_factor_source_by_factor_source_id() != 21729 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_profile() != 5221 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_wallet_update_account() != 54189 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_gatewayclient_new() != 52862 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_gatewayclient_with_gateway() != 39895 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_wallet_by_creating_new_profile_and_secrets_with_entropy() != 61210 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_wallet_by_importing_profile() != 42833 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_wallet_by_loading_profile() != 49873 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_wallet_by_loading_profile_with_id() != 54659 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitNetworkAntenna()
    uniffiCallbackInitSecureStorage()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
