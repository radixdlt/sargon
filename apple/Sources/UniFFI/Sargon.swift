// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(SargonFFI)
import SargonFFI
#endif

private extension RustBuffer {
	// Allocate a new buffer, copying the contents of a `UInt8` array.
	init(bytes: [UInt8]) {
		let rbuf = bytes.withUnsafeBufferPointer { ptr in
			RustBuffer.from(ptr)
		}
		self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
	}

	static func empty() -> RustBuffer {
		RustBuffer(capacity: 0, len: 0, data: nil)
	}

	static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
		try! rustCall { ffi_sargon_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
	}

	// Frees the buffer in place.
	// The buffer must not be used after this is called.
	func deallocate() {
		try! rustCall { ffi_sargon_uniffi_rustbuffer_free(self, $0) }
	}
}

private extension ForeignBytes {
	init(bufferPointer: UnsafeBufferPointer<UInt8>) {
		self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
	}
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
	init(rustBuffer: RustBuffer) {
		// TODO: This copies the buffer. Can we read directly from a
		// Rust buffer?
		self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
	}
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
	(data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
	let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
	guard reader.data.count >= range.upperBound else {
		throw UniffiInternalError.bufferOverflow
	}
	if T.self == UInt8.self {
		let value = reader.data[reader.offset]
		reader.offset += 1
		return value as! T
	}
	var value: T = 0
	let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
	reader.offset = range.upperBound
	return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
	let range = reader.offset ..< (reader.offset + count)
	guard reader.data.count >= range.upperBound else {
		throw UniffiInternalError.bufferOverflow
	}
	var value = [UInt8](repeating: 0, count: count)
	value.withUnsafeMutableBufferPointer { buffer in
		reader.data.copyBytes(to: buffer, from: range)
	}
	reader.offset = range.upperBound
	return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
	try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
	try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
	reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
	[]
}

private func writeBytes(_ writer: inout [UInt8], _ byteArr: some Sequence<UInt8>) {
	writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt(_ writer: inout [UInt8], _ value: some FixedWidthInteger) {
	var value = value.bigEndian
	withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
	writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
	writeInt(&writer, value.bitPattern)
}

// MARK: - FfiConverter
// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
	associatedtype FfiType
	associatedtype SwiftType

	static func lift(_ value: FfiType) throws -> SwiftType
	static func lower(_ value: SwiftType) -> FfiType
	static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
	static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// MARK: - FfiConverterPrimitive
// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
	public static func lift(_ value: FfiType) throws -> SwiftType {
		value
	}

	public static func lower(_ value: SwiftType) -> FfiType {
		value
	}
}

// MARK: - FfiConverterRustBuffer
// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
	public static func lift(_ buf: RustBuffer) throws -> SwiftType {
		var reader = createReader(data: Data(rustBuffer: buf))
		let value = try read(from: &reader)
		if hasRemaining(reader) {
			throw UniffiInternalError.incompleteData
		}
		buf.deallocate()
		return value
	}

	public static func lower(_ value: SwiftType) -> RustBuffer {
		var writer = createWriter()
		write(value, into: &writer)
		return RustBuffer(bytes: writer)
	}
}

// MARK: - UniffiInternalError
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
	case bufferOverflow
	case incompleteData
	case unexpectedOptionalTag
	case unexpectedEnumCase
	case unexpectedNullPointer
	case unexpectedRustCallStatusCode
	case unexpectedRustCallError
	case unexpectedStaleHandle
	case rustPanic(_ message: String)

	public var errorDescription: String? {
		switch self {
		case .bufferOverflow: "Reading the requested value would read past the end of the buffer"
		case .incompleteData: "The buffer still has data after lifting its containing value"
		case .unexpectedOptionalTag: "Unexpected optional tag; should be 0 or 1"
		case .unexpectedEnumCase: "Raw enum value doesn't match any cases"
		case .unexpectedNullPointer: "Raw pointer value was null"
		case .unexpectedRustCallStatusCode: "Unexpected RustCallStatus code"
		case .unexpectedRustCallError: "CALL_ERROR but no errorClass specified"
		case .unexpectedStaleHandle: "The object in the handle map has been dropped already"
		case let .rustPanic(message): message
		}
	}
}

private extension NSLock {
	func withLock<T>(f: () throws -> T) rethrows -> T {
		self.lock()
		defer { self.unlock() }
		return try f()
	}
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
	init() {
		self.init(
			code: CALL_SUCCESS,
			errorBuf: RustBuffer(
				capacity: 0,
				len: 0,
				data: nil
			)
		)
	}
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
	let neverThrow: ((RustBuffer) throws -> Never)? = nil
	return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T>(
	_ errorHandler: @escaping (RustBuffer) throws -> some Swift.Error,
	_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
	try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
	_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
	errorHandler: ((RustBuffer) throws -> some Swift.Error)?
) throws -> T {
	uniffiEnsureInitialized()
	var callStatus = RustCallStatus()
	let returnedVal = callback(&callStatus)
	try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
	return returnedVal
}

private func uniffiCheckCallStatus(
	callStatus: RustCallStatus,
	errorHandler: ((RustBuffer) throws -> some Swift.Error)?
) throws {
	switch callStatus.code {
	case CALL_SUCCESS:
		return

	case CALL_ERROR:
		if let errorHandler {
			throw try errorHandler(callStatus.errorBuf)
		} else {
			callStatus.errorBuf.deallocate()
			throw UniffiInternalError.unexpectedRustCallError
		}

	case CALL_UNEXPECTED_ERROR:
		// When the rust code sees a panic, it tries to construct a RustBuffer
		// with the message.  But if that code panics, then it just sends back
		// an empty buffer.
		if callStatus.errorBuf.len > 0 {
			throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
		} else {
			callStatus.errorBuf.deallocate()
			throw UniffiInternalError.rustPanic("Rust panic")
		}

	case CALL_CANCELLED:
		fatalError("Cancellation not supported yet")

	default:
		throw UniffiInternalError.unexpectedRustCallStatusCode
	}
}

private func uniffiTraitInterfaceCall<T>(
	callStatus: UnsafeMutablePointer<RustCallStatus>,
	makeCall: () throws -> T,
	writeReturn: (T) -> Void
) {
	do {
		try writeReturn(makeCall())
	} catch {
		callStatus.pointee.code = CALL_UNEXPECTED_ERROR
		callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
	}
}

private func uniffiTraitInterfaceCallWithError<T, E>(
	callStatus: UnsafeMutablePointer<RustCallStatus>,
	makeCall: () throws -> T,
	writeReturn: (T) -> Void,
	lowerError: (E) -> RustBuffer
) {
	do {
		try writeReturn(makeCall())
	} catch let error as E {
		callStatus.pointee.code = CALL_ERROR
		callStatus.pointee.errorBuf = lowerError(error)
	} catch {
		callStatus.pointee.code = CALL_UNEXPECTED_ERROR
		callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
	}
}

// MARK: - UniffiHandleMap
private class UniffiHandleMap<T> {
	private var map: [UInt64: T] = [:]
	private let lock = NSLock()
	private var currentHandle: UInt64 = 1

	func insert(obj: T) -> UInt64 {
		lock.withLock {
			let handle = currentHandle
			currentHandle += 1
			map[handle] = obj
			return handle
		}
	}

	func get(handle: UInt64) throws -> T {
		try lock.withLock {
			guard let obj = map[handle] else {
				throw UniffiInternalError.unexpectedStaleHandle
			}
			return obj
		}
	}

	@discardableResult
	func remove(handle: UInt64) throws -> T {
		try lock.withLock {
			guard let obj = map.removeValue(forKey: handle) else {
				throw UniffiInternalError.unexpectedStaleHandle
			}
			return obj
		}
	}

	var count: Int {
		map.count
	}
}

// MARK: - FfiConverterUInt8
// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
	typealias FfiType = UInt8
	typealias SwiftType = UInt8

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
		try lift(readInt(&buf))
	}

	public static func write(_ value: UInt8, into buf: inout [UInt8]) {
		writeInt(&buf, lower(value))
	}
}

// MARK: - FfiConverterInt8
private struct FfiConverterInt8: FfiConverterPrimitive {
	typealias FfiType = Int8
	typealias SwiftType = Int8

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
		try lift(readInt(&buf))
	}

	public static func write(_ value: Int8, into buf: inout [UInt8]) {
		writeInt(&buf, lower(value))
	}
}

// MARK: - FfiConverterUInt16
private struct FfiConverterUInt16: FfiConverterPrimitive {
	typealias FfiType = UInt16
	typealias SwiftType = UInt16

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
		try lift(readInt(&buf))
	}

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		writeInt(&buf, lower(value))
	}
}

// MARK: - FfiConverterUInt32
private struct FfiConverterUInt32: FfiConverterPrimitive {
	typealias FfiType = UInt32
	typealias SwiftType = UInt32

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
		try lift(readInt(&buf))
	}

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		writeInt(&buf, lower(value))
	}
}

// MARK: - FfiConverterInt32
private struct FfiConverterInt32: FfiConverterPrimitive {
	typealias FfiType = Int32
	typealias SwiftType = Int32

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
		try lift(readInt(&buf))
	}

	public static func write(_ value: Int32, into buf: inout [UInt8]) {
		writeInt(&buf, lower(value))
	}
}

// MARK: - FfiConverterUInt64
private struct FfiConverterUInt64: FfiConverterPrimitive {
	typealias FfiType = UInt64
	typealias SwiftType = UInt64

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
		try lift(readInt(&buf))
	}

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		writeInt(&buf, lower(value))
	}
}

// MARK: - FfiConverterInt64
private struct FfiConverterInt64: FfiConverterPrimitive {
	typealias FfiType = Int64
	typealias SwiftType = Int64

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
		try lift(readInt(&buf))
	}

	public static func write(_ value: Int64, into buf: inout [UInt8]) {
		writeInt(&buf, lower(value))
	}
}

// MARK: - FfiConverterFloat
private struct FfiConverterFloat: FfiConverterPrimitive {
	typealias FfiType = Float
	typealias SwiftType = Float

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
		try lift(readFloat(&buf))
	}

	public static func write(_ value: Float, into buf: inout [UInt8]) {
		writeFloat(&buf, lower(value))
	}
}

// MARK: - FfiConverterDouble
private struct FfiConverterDouble: FfiConverterPrimitive {
	typealias FfiType = Double
	typealias SwiftType = Double

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
		try lift(readDouble(&buf))
	}

	public static func write(_ value: Double, into buf: inout [UInt8]) {
		writeDouble(&buf, lower(value))
	}
}

// MARK: - FfiConverterBool
private struct FfiConverterBool: FfiConverter {
	typealias FfiType = Int8
	typealias SwiftType = Bool

	public static func lift(_ value: Int8) throws -> Bool {
		value != 0
	}

	public static func lower(_ value: Bool) -> Int8 {
		value ? 1 : 0
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
		try lift(readInt(&buf))
	}

	public static func write(_ value: Bool, into buf: inout [UInt8]) {
		writeInt(&buf, lower(value))
	}
}

// MARK: - FfiConverterString
private struct FfiConverterString: FfiConverter {
	typealias SwiftType = String
	typealias FfiType = RustBuffer

	public static func lift(_ value: RustBuffer) throws -> String {
		defer {
			value.deallocate()
		}
		if value.data == nil {
			return String()
		}
		let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
		return String(bytes: bytes, encoding: String.Encoding.utf8)!
	}

	public static func lower(_ value: String) -> RustBuffer {
		value.utf8CString.withUnsafeBufferPointer { ptr in
			// The swift string gives us int8_t, we want uint8_t.
			ptr.withMemoryRebound(to: UInt8.self) { ptr in
				// The swift string gives us a trailing null byte, we don't want it.
				let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
				return RustBuffer.from(buf)
			}
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
		let len: Int32 = try readInt(&buf)
		return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
	}

	public static func write(_ value: String, into buf: inout [UInt8]) {
		let len = Int32(value.utf8.count)
		writeInt(&buf, len)
		writeBytes(&buf, value.utf8)
	}
}

// MARK: - FfiConverterData
private struct FfiConverterData: FfiConverterRustBuffer {
	typealias SwiftType = Data

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
		let len: Int32 = try readInt(&buf)
		return try Data(readBytes(&buf, count: Int(len)))
	}

	public static func write(_ value: Data, into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		writeBytes(&buf, value)
	}
}

// MARK: - BiosProtocol
public protocol BiosProtocol: AnyObject {}

// MARK: - Bios
open class Bios:
	BiosProtocol
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_bios(self.pointer, $0) }
	}

	public convenience init(drivers: Drivers) {
		let pointer =
			try! rustCall {
				uniffi_sargon_uniffi_fn_constructor_bios_new(
					FfiConverterTypeDrivers.lower(drivers), $0
				)
			}
		self.init(unsafeFromRawPointer: pointer)
	}

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_bios(pointer, $0) }
	}
}

// MARK: - FfiConverterTypeBios
public struct FfiConverterTypeBios: FfiConverter {
	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = Bios

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bios {
		Bios(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: Bios) -> UnsafeMutableRawPointer {
		value.uniffiClonePointer()
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bios {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: Bios, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeBios_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bios {
	try FfiConverterTypeBios.lift(pointer)
}

public func FfiConverterTypeBios_lower(_ value: Bios) -> UnsafeMutableRawPointer {
	FfiConverterTypeBios.lower(value)
}

// MARK: - DriversProtocol
public protocol DriversProtocol: AnyObject {}

// MARK: - Drivers
open class Drivers:
	DriversProtocol
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_drivers(self.pointer, $0) }
	}

	public convenience init(networking: NetworkingDriver, secureStorage: SecureStorageDriver, entropyProvider: EntropyProviderDriver, hostInfo: HostInfoDriver, logging: LoggingDriver, eventBus: EventBusDriver, fileSystem: FileSystemDriver, unsafeStorage: UnsafeStorageDriver, profileStateChangeDriver: ProfileStateChangeDriver) {
		let pointer =
			try! rustCall {
				uniffi_sargon_uniffi_fn_constructor_drivers_new(
					FfiConverterTypeNetworkingDriver.lower(networking),
					FfiConverterTypeSecureStorageDriver.lower(secureStorage),
					FfiConverterTypeEntropyProviderDriver.lower(entropyProvider),
					FfiConverterTypeHostInfoDriver.lower(hostInfo),
					FfiConverterTypeLoggingDriver.lower(logging),
					FfiConverterTypeEventBusDriver.lower(eventBus),
					FfiConverterTypeFileSystemDriver.lower(fileSystem),
					FfiConverterTypeUnsafeStorageDriver.lower(unsafeStorage),
					FfiConverterTypeProfileStateChangeDriver.lower(profileStateChangeDriver), $0
				)
			}
		self.init(unsafeFromRawPointer: pointer)
	}

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_drivers(pointer, $0) }
	}
}

// MARK: - FfiConverterTypeDrivers
public struct FfiConverterTypeDrivers: FfiConverter {
	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = Drivers

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Drivers {
		Drivers(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: Drivers) -> UnsafeMutableRawPointer {
		value.uniffiClonePointer()
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Drivers {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: Drivers, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeDrivers_lift(_ pointer: UnsafeMutableRawPointer) throws -> Drivers {
	try FfiConverterTypeDrivers.lift(pointer)
}

public func FfiConverterTypeDrivers_lower(_ value: Drivers) -> UnsafeMutableRawPointer {
	FfiConverterTypeDrivers.lower(value)
}

// MARK: - EntropyProviderDriver
public protocol EntropyProviderDriver: AnyObject {
	func generateSecureRandomBytes() -> Entropy32Bytes
}

// MARK: - EntropyProviderDriverImpl
open class EntropyProviderDriverImpl:
	EntropyProviderDriver
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_entropyproviderdriver(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_entropyproviderdriver(pointer, $0) }
	}

	open func generateSecureRandomBytes() -> Entropy32Bytes {
		try! FfiConverterTypeEntropy32Bytes.lift(try! rustCall {
			uniffi_sargon_uniffi_fn_method_entropyproviderdriver_generate_secure_random_bytes(self.uniffiClonePointer(), $0)
		})
	}
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// MARK: - UniffiCallbackInterfaceEntropyProviderDriver
// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceEntropyProviderDriver {
	// Create the VTable using a series of closures.
	// Swift automatically converts these into C callback functions.
	static var vtable: UniffiVTableCallbackInterfaceEntropyProviderDriver = .init(
		generateSecureRandomBytes: { (
			uniffiHandle: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
			uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
		) in
			let makeCall = {
				() throws -> Entropy32Bytes in
				guard let uniffiObj = try? FfiConverterTypeEntropyProviderDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return uniffiObj.generateSecureRandomBytes(
				)
			}

			let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeEntropy32Bytes.lower($0) }
			uniffiTraitInterfaceCall(
				callStatus: uniffiCallStatus,
				makeCall: makeCall,
				writeReturn: writeReturn
			)
		},
		uniffiFree: { (uniffiHandle: UInt64) in
			let result = try? FfiConverterTypeEntropyProviderDriver.handleMap.remove(handle: uniffiHandle)
			if result == nil {
				print("Uniffi callback interface EntropyProviderDriver: handle missing in uniffiFree")
			}
		}
	)
}

private func uniffiCallbackInitEntropyProviderDriver() {
	uniffi_sargon_uniffi_fn_init_callback_vtable_entropyproviderdriver(&UniffiCallbackInterfaceEntropyProviderDriver.vtable)
}

// MARK: - FfiConverterTypeEntropyProviderDriver
public struct FfiConverterTypeEntropyProviderDriver: FfiConverter {
	fileprivate static var handleMap = UniffiHandleMap<EntropyProviderDriver>()

	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = EntropyProviderDriver

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EntropyProviderDriver {
		EntropyProviderDriverImpl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: EntropyProviderDriver) -> UnsafeMutableRawPointer {
		guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
			fatalError("Cast to UnsafeMutableRawPointer failed")
		}
		return ptr
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntropyProviderDriver {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: EntropyProviderDriver, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeEntropyProviderDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> EntropyProviderDriver {
	try FfiConverterTypeEntropyProviderDriver.lift(pointer)
}

public func FfiConverterTypeEntropyProviderDriver_lower(_ value: EntropyProviderDriver) -> UnsafeMutableRawPointer {
	FfiConverterTypeEntropyProviderDriver.lower(value)
}

// MARK: - EventBusDriver
/**
 * A driver which received and asynchronously *handles* event notifications
 * emitted by the `SargonOS`. Letting the method be async allows for Rust side
 * to wait for host clients to complete something which might require user
 * attention. E.g. presentation of an alert and await user input.
 *
 * Due to limitations in UniFFI and lack of first class citizen support of
 * async sequences (like we have in Swift) we cannot export an accessor of the
 * received events here. Instead implementing types on the FFI side SHOULD
 * create the driver as a singleton object they can reference later and build
 * async streams in that implementing type.
 *
 * See Swifts EventBus implementation for more details.
 */
public protocol EventBusDriver: AnyObject {
	/**
	 * Asynchronously *handles* event notifications
	 * emitted by the `SargonOS`. Letting the method be async allows for Rust side
	 * to wait for host clients to complete something which might require user
	 * attention. E.g. presentation of an alert and await user input.
	 */
	func handleEventNotification(eventNotification: EventNotification) async
}

// MARK: - EventBusDriverImpl
/**
 * A driver which received and asynchronously *handles* event notifications
 * emitted by the `SargonOS`. Letting the method be async allows for Rust side
 * to wait for host clients to complete something which might require user
 * attention. E.g. presentation of an alert and await user input.
 *
 * Due to limitations in UniFFI and lack of first class citizen support of
 * async sequences (like we have in Swift) we cannot export an accessor of the
 * received events here. Instead implementing types on the FFI side SHOULD
 * create the driver as a singleton object they can reference later and build
 * async streams in that implementing type.
 *
 * See Swifts EventBus implementation for more details.
 */
open class EventBusDriverImpl:
	EventBusDriver
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_eventbusdriver(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_eventbusdriver(pointer, $0) }
	}

	/**
	 * Asynchronously *handles* event notifications
	 * emitted by the `SargonOS`. Letting the method be async allows for Rust side
	 * to wait for host clients to complete something which might require user
	 * attention. E.g. presentation of an alert and await user input.
	 */
	open func handleEventNotification(eventNotification: EventNotification) async {
		try! await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_eventbusdriver_handle_event_notification(
					self.uniffiClonePointer(),
					FfiConverterTypeEventNotification.lower(eventNotification)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: nil
		)
	}
}

// MARK: - UniffiCallbackInterfaceEventBusDriver
// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceEventBusDriver {
	// Create the VTable using a series of closures.
	// Swift automatically converts these into C callback functions.
	static var vtable: UniffiVTableCallbackInterfaceEventBusDriver = .init(
		handleEventNotification: { (
			uniffiHandle: UInt64,
			eventNotification: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws in
				guard let uniffiObj = try? FfiConverterTypeEventBusDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.handleEventNotification(
					eventNotification: FfiConverterTypeEventNotification.lift(eventNotification)
				)
			}

			let uniffiHandleSuccess = { (_: ()) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		uniffiFree: { (uniffiHandle: UInt64) in
			let result = try? FfiConverterTypeEventBusDriver.handleMap.remove(handle: uniffiHandle)
			if result == nil {
				print("Uniffi callback interface EventBusDriver: handle missing in uniffiFree")
			}
		}
	)
}

private func uniffiCallbackInitEventBusDriver() {
	uniffi_sargon_uniffi_fn_init_callback_vtable_eventbusdriver(&UniffiCallbackInterfaceEventBusDriver.vtable)
}

// MARK: - FfiConverterTypeEventBusDriver
public struct FfiConverterTypeEventBusDriver: FfiConverter {
	fileprivate static var handleMap = UniffiHandleMap<EventBusDriver>()

	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = EventBusDriver

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBusDriver {
		EventBusDriverImpl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: EventBusDriver) -> UnsafeMutableRawPointer {
		guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
			fatalError("Cast to UnsafeMutableRawPointer failed")
		}
		return ptr
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventBusDriver {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: EventBusDriver, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeEventBusDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBusDriver {
	try FfiConverterTypeEventBusDriver.lift(pointer)
}

public func FfiConverterTypeEventBusDriver_lower(_ value: EventBusDriver) -> UnsafeMutableRawPointer {
	FfiConverterTypeEventBusDriver.lower(value)
}

// MARK: - FfiUrlProtocol
/**
 * A wrapper around `Url` that allows us to safely deal with Urls generated on hosts.
 *
 * Context: We have defined a custom type conversion between Rust's `Url` and the hosts analogues.
 * However, a Url could be considered valid on host but not on Rust. For example, Swift allows to build a Url
 * from string `"invalid input"`, while Rust doesn't.
 *
 * Therefore, if a given Rust function expects a `Url` as param and is sent one from host side which is invalid,
 * the code will panic. However, if we send the wrapper instead, we make sure the conversion is safely done on the
 * host side, dealing with the failing conversion properly rather than panicking.
 */
public protocol FfiUrlProtocol: AnyObject {}

// MARK: - FfiUrl
/**
 * A wrapper around `Url` that allows us to safely deal with Urls generated on hosts.
 *
 * Context: We have defined a custom type conversion between Rust's `Url` and the hosts analogues.
 * However, a Url could be considered valid on host but not on Rust. For example, Swift allows to build a Url
 * from string `"invalid input"`, while Rust doesn't.
 *
 * Therefore, if a given Rust function expects a `Url` as param and is sent one from host side which is invalid,
 * the code will panic. However, if we send the wrapper instead, we make sure the conversion is safely done on the
 * host side, dealing with the failing conversion properly rather than panicking.
 */
open class FfiUrl:
	CustomDebugStringConvertible,
	CustomStringConvertible,
	Equatable,
	Hashable,
	FfiUrlProtocol
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_ffiurl(self.pointer, $0) }
	}

	public convenience init(urlPath: String) throws {
		let pointer =
			try rustCallWithError(FfiConverterTypeCommonError.lift) {
				uniffi_sargon_uniffi_fn_constructor_ffiurl_new(
					FfiConverterString.lower(urlPath), $0
				)
			}
		self.init(unsafeFromRawPointer: pointer)
	}

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_ffiurl(pointer, $0) }
	}

	open var debugDescription: String {
		try! FfiConverterString.lift(
			try! rustCall {
				uniffi_sargon_uniffi_fn_method_ffiurl_uniffi_trait_debug(self.uniffiClonePointer(), $0)
			}
		)
	}

	open var description: String {
		try! FfiConverterString.lift(
			try! rustCall {
				uniffi_sargon_uniffi_fn_method_ffiurl_uniffi_trait_display(self.uniffiClonePointer(), $0)
			}
		)
	}

	public static func == (self: FfiUrl, other: FfiUrl) -> Bool {
		try! FfiConverterBool.lift(
			try! rustCall {
				uniffi_sargon_uniffi_fn_method_ffiurl_uniffi_trait_eq_eq(self.uniffiClonePointer(),
				                                                         FfiConverterTypeFfiUrl.lower(other), $0)
			}
		)
	}

	open func hash(into hasher: inout Hasher) {
		let val = try! FfiConverterUInt64.lift(
			try! rustCall {
				uniffi_sargon_uniffi_fn_method_ffiurl_uniffi_trait_hash(self.uniffiClonePointer(), $0)
			}
		)
		hasher.combine(val)
	}
}

// MARK: - FfiConverterTypeFfiUrl
public struct FfiConverterTypeFfiUrl: FfiConverter {
	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = FfiUrl

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUrl {
		FfiUrl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: FfiUrl) -> UnsafeMutableRawPointer {
		value.uniffiClonePointer()
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUrl {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: FfiUrl, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeFfiUrl_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUrl {
	try FfiConverterTypeFfiUrl.lift(pointer)
}

public func FfiConverterTypeFfiUrl_lower(_ value: FfiUrl) -> UnsafeMutableRawPointer {
	FfiConverterTypeFfiUrl.lower(value)
}

// MARK: - FileSystemDriver
public protocol FileSystemDriver: AnyObject {
	func writableAppDirPath() async throws -> String

	func loadFromFile(path: String) async throws -> BagOfBytes?

	func saveToFile(path: String, data: BagOfBytes, isAllowedToOverwrite: Bool) async throws

	func deleteFile(path: String) async throws
}

// MARK: - FileSystemDriverImpl
open class FileSystemDriverImpl:
	FileSystemDriver
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_filesystemdriver(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_filesystemdriver(pointer, $0) }
	}

	open func writableAppDirPath() async throws -> String {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_filesystemdriver_writable_app_dir_path(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterString.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func loadFromFile(path: String) async throws -> BagOfBytes? {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_filesystemdriver_load_from_file(
					self.uniffiClonePointer(),
					FfiConverterString.lower(path)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func saveToFile(path: String, data: BagOfBytes, isAllowedToOverwrite: Bool) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_filesystemdriver_save_to_file(
					self.uniffiClonePointer(),
					FfiConverterString.lower(path), FfiConverterTypeBagOfBytes.lower(data), FfiConverterBool.lower(isAllowedToOverwrite)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func deleteFile(path: String) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_filesystemdriver_delete_file(
					self.uniffiClonePointer(),
					FfiConverterString.lower(path)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}
}

// MARK: - UniffiCallbackInterfaceFileSystemDriver
// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceFileSystemDriver {
	// Create the VTable using a series of closures.
	// Swift automatically converts these into C callback functions.
	static var vtable: UniffiVTableCallbackInterfaceFileSystemDriver = .init(
		writableAppDirPath: { (
			uniffiHandle: UInt64,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws -> String in
				guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.writableAppDirPath(
				)
			}

			let uniffiHandleSuccess = { (returnValue: String) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: FfiConverterString.lower(returnValue),
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: RustBuffer.empty(),
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		loadFromFile: { (
			uniffiHandle: UInt64,
			path: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws -> BagOfBytes? in
				guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.loadFromFile(
					path: FfiConverterString.lift(path)
				)
			}

			let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: RustBuffer.empty(),
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		saveToFile: { (
			uniffiHandle: UInt64,
			path: RustBuffer,
			data: RustBuffer,
			isAllowedToOverwrite: Int8,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws in
				guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.saveToFile(
					path: FfiConverterString.lift(path),
					data: FfiConverterTypeBagOfBytes.lift(data),
					isAllowedToOverwrite: FfiConverterBool.lift(isAllowedToOverwrite)
				)
			}

			let uniffiHandleSuccess = { (_: ()) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		deleteFile: { (
			uniffiHandle: UInt64,
			path: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws in
				guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.deleteFile(
					path: FfiConverterString.lift(path)
				)
			}

			let uniffiHandleSuccess = { (_: ()) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		uniffiFree: { (uniffiHandle: UInt64) in
			let result = try? FfiConverterTypeFileSystemDriver.handleMap.remove(handle: uniffiHandle)
			if result == nil {
				print("Uniffi callback interface FileSystemDriver: handle missing in uniffiFree")
			}
		}
	)
}

private func uniffiCallbackInitFileSystemDriver() {
	uniffi_sargon_uniffi_fn_init_callback_vtable_filesystemdriver(&UniffiCallbackInterfaceFileSystemDriver.vtable)
}

// MARK: - FfiConverterTypeFileSystemDriver
public struct FfiConverterTypeFileSystemDriver: FfiConverter {
	fileprivate static var handleMap = UniffiHandleMap<FileSystemDriver>()

	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = FileSystemDriver

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FileSystemDriver {
		FileSystemDriverImpl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: FileSystemDriver) -> UnsafeMutableRawPointer {
		guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
			fatalError("Cast to UnsafeMutableRawPointer failed")
		}
		return ptr
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileSystemDriver {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: FileSystemDriver, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeFileSystemDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> FileSystemDriver {
	try FfiConverterTypeFileSystemDriver.lift(pointer)
}

public func FfiConverterTypeFileSystemDriver_lower(_ value: FileSystemDriver) -> UnsafeMutableRawPointer {
	FfiConverterTypeFileSystemDriver.lower(value)
}

// MARK: - HomeCardsManagerProtocol
/**
 * Manages the home cards by handling storage, parsing, and updating operations.
 * Call `bootstrap` before invoking any other public functions.
 */
public protocol HomeCardsManagerProtocol: AnyObject {
	/**
	 * Initializes `HomeCards` by loading from storage.
	 * This function should be called before invoking any other public functions.
	 * Notifies `HomeCardsObserver`.
	 */
	func bootstrap() async throws

	/**
	 * Dismisses a specified `HomeCard` by removing it from `HomeCardsStorage`.
	 * Notifies `HomeCardsObserver`.
	 */
	func cardDismissed(card: HomeCard) async throws

	/**
	 * Handles a deferred deep link by parsing it and saving the generated `HomeCards` to `HomeCardsStorage`.
	 * `HomeCard::ContinueRadQuest` if found in the link parsing result, replaces `HomeCard::StartRadQuest`.
	 * Notifies `HomeCardsObserver`.
	 */
	func deferredDeepLinkReceived(encodedValue: String) async throws

	/**
	 * Initializes and saves to storage default `HomeCards`.
	 * Marks the wallet creation and populates the set of cards required for a new wallet.
	 * Notifies `HomeCardsObserver`.
	 */
	func walletCreated() async throws

	/**
	 * Clears the home cards from the `HomeCardsStorage`.
	 * Notifies `HomeCardsObserver`.
	 */
	func walletReset() async throws

	/**
	 * Marks the wallet restoration.
	 * Ensures only the expected `HomeCards` remain in `HomeCardsStorage` - currently none.
	 * Notifies `HomeCardsObserver`.
	 */
	func walletRestored() async throws
}

// MARK: - HomeCardsManager
/**
 * Manages the home cards by handling storage, parsing, and updating operations.
 * Call `bootstrap` before invoking any other public functions.
 */
open class HomeCardsManager:
	HomeCardsManagerProtocol
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_homecardsmanager(self.pointer, $0) }
	}

	public convenience init(networkingDriver: NetworkingDriver, networkId: NetworkId, cardsStorage: HomeCardsStorage, observer: HomeCardsObserver) {
		let pointer =
			try! rustCall {
				uniffi_sargon_uniffi_fn_constructor_homecardsmanager_new(
					FfiConverterTypeNetworkingDriver.lower(networkingDriver),
					FfiConverterTypeNetworkID.lower(networkId),
					FfiConverterTypeHomeCardsStorage.lower(cardsStorage),
					FfiConverterTypeHomeCardsObserver.lower(observer), $0
				)
			}
		self.init(unsafeFromRawPointer: pointer)
	}

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_homecardsmanager(pointer, $0) }
	}

	/**
	 * Initializes `HomeCards` by loading from storage.
	 * This function should be called before invoking any other public functions.
	 * Notifies `HomeCardsObserver`.
	 */
	open func bootstrap() async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_homecardsmanager_bootstrap(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Dismisses a specified `HomeCard` by removing it from `HomeCardsStorage`.
	 * Notifies `HomeCardsObserver`.
	 */
	open func cardDismissed(card: HomeCard) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_homecardsmanager_card_dismissed(
					self.uniffiClonePointer(),
					FfiConverterTypeHomeCard.lower(card)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Handles a deferred deep link by parsing it and saving the generated `HomeCards` to `HomeCardsStorage`.
	 * `HomeCard::ContinueRadQuest` if found in the link parsing result, replaces `HomeCard::StartRadQuest`.
	 * Notifies `HomeCardsObserver`.
	 */
	open func deferredDeepLinkReceived(encodedValue: String) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_homecardsmanager_deferred_deep_link_received(
					self.uniffiClonePointer(),
					FfiConverterString.lower(encodedValue)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Initializes and saves to storage default `HomeCards`.
	 * Marks the wallet creation and populates the set of cards required for a new wallet.
	 * Notifies `HomeCardsObserver`.
	 */
	open func walletCreated() async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_homecardsmanager_wallet_created(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Clears the home cards from the `HomeCardsStorage`.
	 * Notifies `HomeCardsObserver`.
	 */
	open func walletReset() async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_homecardsmanager_wallet_reset(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Marks the wallet restoration.
	 * Ensures only the expected `HomeCards` remain in `HomeCardsStorage` - currently none.
	 * Notifies `HomeCardsObserver`.
	 */
	open func walletRestored() async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_homecardsmanager_wallet_restored(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}
}

// MARK: - FfiConverterTypeHomeCardsManager
public struct FfiConverterTypeHomeCardsManager: FfiConverter {
	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = HomeCardsManager

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsManager {
		HomeCardsManager(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: HomeCardsManager) -> UnsafeMutableRawPointer {
		value.uniffiClonePointer()
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCardsManager {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: HomeCardsManager, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeHomeCardsManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsManager {
	try FfiConverterTypeHomeCardsManager.lift(pointer)
}

public func FfiConverterTypeHomeCardsManager_lower(_ value: HomeCardsManager) -> UnsafeMutableRawPointer {
	FfiConverterTypeHomeCardsManager.lower(value)
}

// MARK: - HomeCardsObserver
/**
 * Trait for observing home cards updates.
 * Defines a method for handling updates to home cards.
 */
public protocol HomeCardsObserver: AnyObject {
	/**
	 * Handles updates to the home cards.
	 */
	func handleCardsUpdate(cards: [HomeCard])
}

// MARK: - HomeCardsObserverImpl
/**
 * Trait for observing home cards updates.
 * Defines a method for handling updates to home cards.
 */
open class HomeCardsObserverImpl:
	HomeCardsObserver
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_homecardsobserver(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_homecardsobserver(pointer, $0) }
	}

	/**
	 * Handles updates to the home cards.
	 */
	open func handleCardsUpdate(cards: [HomeCard]) { try! rustCall {
		uniffi_sargon_uniffi_fn_method_homecardsobserver_handle_cards_update(self.uniffiClonePointer(),
		                                                                     FfiConverterSequenceTypeHomeCard.lower(cards), $0)
	}
	}
}

// MARK: - UniffiCallbackInterfaceHomeCardsObserver
// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceHomeCardsObserver {
	// Create the VTable using a series of closures.
	// Swift automatically converts these into C callback functions.
	static var vtable: UniffiVTableCallbackInterfaceHomeCardsObserver = .init(
		handleCardsUpdate: { (
			uniffiHandle: UInt64,
			cards: RustBuffer,
			_: UnsafeMutableRawPointer,
			uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
		) in
			let makeCall = {
				() throws in
				guard let uniffiObj = try? FfiConverterTypeHomeCardsObserver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try uniffiObj.handleCardsUpdate(
					cards: FfiConverterSequenceTypeHomeCard.lift(cards)
				)
			}

			let writeReturn = { () }
			uniffiTraitInterfaceCall(
				callStatus: uniffiCallStatus,
				makeCall: makeCall,
				writeReturn: writeReturn
			)
		},
		uniffiFree: { (uniffiHandle: UInt64) in
			let result = try? FfiConverterTypeHomeCardsObserver.handleMap.remove(handle: uniffiHandle)
			if result == nil {
				print("Uniffi callback interface HomeCardsObserver: handle missing in uniffiFree")
			}
		}
	)
}

private func uniffiCallbackInitHomeCardsObserver() {
	uniffi_sargon_uniffi_fn_init_callback_vtable_homecardsobserver(&UniffiCallbackInterfaceHomeCardsObserver.vtable)
}

// MARK: - FfiConverterTypeHomeCardsObserver
public struct FfiConverterTypeHomeCardsObserver: FfiConverter {
	fileprivate static var handleMap = UniffiHandleMap<HomeCardsObserver>()

	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = HomeCardsObserver

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsObserver {
		HomeCardsObserverImpl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: HomeCardsObserver) -> UnsafeMutableRawPointer {
		guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
			fatalError("Cast to UnsafeMutableRawPointer failed")
		}
		return ptr
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCardsObserver {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: HomeCardsObserver, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeHomeCardsObserver_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsObserver {
	try FfiConverterTypeHomeCardsObserver.lift(pointer)
}

public func FfiConverterTypeHomeCardsObserver_lower(_ value: HomeCardsObserver) -> UnsafeMutableRawPointer {
	FfiConverterTypeHomeCardsObserver.lower(value)
}

// MARK: - HomeCardsStorage
/**
 * A trait for storing and loading home cards.
 * Defines asynchronous methods for saving and loading encoded home cards.
 */
public protocol HomeCardsStorage: AnyObject {
	/**
	 * Saves the encoded home cards to the storage.
	 */
	func saveCards(encodedCards: BagOfBytes) async throws

	/**
	 * Loads the encoded home cards from the storage.
	 */
	func loadCards() async throws -> BagOfBytes?
}

// MARK: - HomeCardsStorageImpl
/**
 * A trait for storing and loading home cards.
 * Defines asynchronous methods for saving and loading encoded home cards.
 */
open class HomeCardsStorageImpl:
	HomeCardsStorage
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_homecardsstorage(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_homecardsstorage(pointer, $0) }
	}

	/**
	 * Saves the encoded home cards to the storage.
	 */
	open func saveCards(encodedCards: BagOfBytes) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_homecardsstorage_save_cards(
					self.uniffiClonePointer(),
					FfiConverterTypeBagOfBytes.lower(encodedCards)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Loads the encoded home cards from the storage.
	 */
	open func loadCards() async throws -> BagOfBytes? {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_homecardsstorage_load_cards(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}
}

// MARK: - UniffiCallbackInterfaceHomeCardsStorage
// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceHomeCardsStorage {
	// Create the VTable using a series of closures.
	// Swift automatically converts these into C callback functions.
	static var vtable: UniffiVTableCallbackInterfaceHomeCardsStorage = .init(
		saveCards: { (
			uniffiHandle: UInt64,
			encodedCards: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws in
				guard let uniffiObj = try? FfiConverterTypeHomeCardsStorage.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.saveCards(
					encodedCards: FfiConverterTypeBagOfBytes.lift(encodedCards)
				)
			}

			let uniffiHandleSuccess = { (_: ()) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		loadCards: { (
			uniffiHandle: UInt64,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws -> BagOfBytes? in
				guard let uniffiObj = try? FfiConverterTypeHomeCardsStorage.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.loadCards(
				)
			}

			let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: RustBuffer.empty(),
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		uniffiFree: { (uniffiHandle: UInt64) in
			let result = try? FfiConverterTypeHomeCardsStorage.handleMap.remove(handle: uniffiHandle)
			if result == nil {
				print("Uniffi callback interface HomeCardsStorage: handle missing in uniffiFree")
			}
		}
	)
}

private func uniffiCallbackInitHomeCardsStorage() {
	uniffi_sargon_uniffi_fn_init_callback_vtable_homecardsstorage(&UniffiCallbackInterfaceHomeCardsStorage.vtable)
}

// MARK: - FfiConverterTypeHomeCardsStorage
public struct FfiConverterTypeHomeCardsStorage: FfiConverter {
	fileprivate static var handleMap = UniffiHandleMap<HomeCardsStorage>()

	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = HomeCardsStorage

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsStorage {
		HomeCardsStorageImpl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: HomeCardsStorage) -> UnsafeMutableRawPointer {
		guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
			fatalError("Cast to UnsafeMutableRawPointer failed")
		}
		return ptr
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCardsStorage {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: HomeCardsStorage, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeHomeCardsStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsStorage {
	try FfiConverterTypeHomeCardsStorage.lift(pointer)
}

public func FfiConverterTypeHomeCardsStorage_lower(_ value: HomeCardsStorage) -> UnsafeMutableRawPointer {
	FfiConverterTypeHomeCardsStorage.lower(value)
}

// MARK: - HostInfoDriver
public protocol HostInfoDriver: AnyObject {
	/**
	 * The **current** device's operating system, e.g. "iOS 17.4.1"
	 */
	func hostOs() async -> HostOs

	/**
	 * The name of the host device (iPhone/Android), e.g. "My Red iPhone"
	 */
	func hostDeviceName() async -> String

	/**
	 * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1".
	 */
	func hostAppVersion() async -> String

	/**
	 * The model of the host device (iPhone/Android), .e.g. "iPhone SE 2nd Gen"
	 */
	func hostDeviceModel() async -> String
}

// MARK: - HostInfoDriverImpl
open class HostInfoDriverImpl:
	HostInfoDriver
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_hostinfodriver(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_hostinfodriver(pointer, $0) }
	}

	/**
	 * The **current** device's operating system, e.g. "iOS 17.4.1"
	 */
	open func hostOs() async -> HostOs {
		try! await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_hostinfodriver_host_os(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeHostOS.lift,
			errorHandler: nil
		)
	}

	/**
	 * The name of the host device (iPhone/Android), e.g. "My Red iPhone"
	 */
	open func hostDeviceName() async -> String {
		try! await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_hostinfodriver_host_device_name(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterString.lift,
			errorHandler: nil
		)
	}

	/**
	 * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1".
	 */
	open func hostAppVersion() async -> String {
		try! await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_hostinfodriver_host_app_version(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterString.lift,
			errorHandler: nil
		)
	}

	/**
	 * The model of the host device (iPhone/Android), .e.g. "iPhone SE 2nd Gen"
	 */
	open func hostDeviceModel() async -> String {
		try! await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_hostinfodriver_host_device_model(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterString.lift,
			errorHandler: nil
		)
	}
}

// MARK: - UniffiCallbackInterfaceHostInfoDriver
// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceHostInfoDriver {
	// Create the VTable using a series of closures.
	// Swift automatically converts these into C callback functions.
	static var vtable: UniffiVTableCallbackInterfaceHostInfoDriver = .init(
		hostOs: { (
			uniffiHandle: UInt64,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws -> HostOs in
				guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return await uniffiObj.hostOs(
				)
			}

			let uniffiHandleSuccess = { (returnValue: HostOs) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: FfiConverterTypeHostOS.lower(returnValue),
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: RustBuffer.empty(),
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		hostDeviceName: { (
			uniffiHandle: UInt64,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws -> String in
				guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return await uniffiObj.hostDeviceName(
				)
			}

			let uniffiHandleSuccess = { (returnValue: String) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: FfiConverterString.lower(returnValue),
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: RustBuffer.empty(),
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		hostAppVersion: { (
			uniffiHandle: UInt64,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws -> String in
				guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return await uniffiObj.hostAppVersion(
				)
			}

			let uniffiHandleSuccess = { (returnValue: String) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: FfiConverterString.lower(returnValue),
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: RustBuffer.empty(),
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		hostDeviceModel: { (
			uniffiHandle: UInt64,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws -> String in
				guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return await uniffiObj.hostDeviceModel(
				)
			}

			let uniffiHandleSuccess = { (returnValue: String) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: FfiConverterString.lower(returnValue),
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: RustBuffer.empty(),
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		uniffiFree: { (uniffiHandle: UInt64) in
			let result = try? FfiConverterTypeHostInfoDriver.handleMap.remove(handle: uniffiHandle)
			if result == nil {
				print("Uniffi callback interface HostInfoDriver: handle missing in uniffiFree")
			}
		}
	)
}

private func uniffiCallbackInitHostInfoDriver() {
	uniffi_sargon_uniffi_fn_init_callback_vtable_hostinfodriver(&UniffiCallbackInterfaceHostInfoDriver.vtable)
}

// MARK: - FfiConverterTypeHostInfoDriver
public struct FfiConverterTypeHostInfoDriver: FfiConverter {
	fileprivate static var handleMap = UniffiHandleMap<HostInfoDriver>()

	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = HostInfoDriver

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HostInfoDriver {
		HostInfoDriverImpl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: HostInfoDriver) -> UnsafeMutableRawPointer {
		guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
			fatalError("Cast to UnsafeMutableRawPointer failed")
		}
		return ptr
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostInfoDriver {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: HostInfoDriver, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeHostInfoDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> HostInfoDriver {
	try FfiConverterTypeHostInfoDriver.lift(pointer)
}

public func FfiConverterTypeHostInfoDriver_lower(_ value: HostInfoDriver) -> UnsafeMutableRawPointer {
	FfiConverterTypeHostInfoDriver.lower(value)
}

// MARK: - LoggingDriver
/**
 * * Trace
 * * Debug
 * * Info
 * * Warning
 * * Error
 */
public protocol LoggingDriver: AnyObject {
	func log(level: LogLevel, msg: String)
}

// MARK: - LoggingDriverImpl
/**
 * * Trace
 * * Debug
 * * Info
 * * Warning
 * * Error
 */
open class LoggingDriverImpl:
	LoggingDriver
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_loggingdriver(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_loggingdriver(pointer, $0) }
	}

	open func log(level: LogLevel, msg: String) { try! rustCall {
		uniffi_sargon_uniffi_fn_method_loggingdriver_log(self.uniffiClonePointer(),
		                                                 FfiConverterTypeLogLevel.lower(level),
		                                                 FfiConverterString.lower(msg), $0)
	}
	}
}

// MARK: - UniffiCallbackInterfaceLoggingDriver
// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceLoggingDriver {
	// Create the VTable using a series of closures.
	// Swift automatically converts these into C callback functions.
	static var vtable: UniffiVTableCallbackInterfaceLoggingDriver = .init(
		log: { (
			uniffiHandle: UInt64,
			level: RustBuffer,
			msg: RustBuffer,
			_: UnsafeMutableRawPointer,
			uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
		) in
			let makeCall = {
				() throws in
				guard let uniffiObj = try? FfiConverterTypeLoggingDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try uniffiObj.log(
					level: FfiConverterTypeLogLevel.lift(level),
					msg: FfiConverterString.lift(msg)
				)
			}

			let writeReturn = { () }
			uniffiTraitInterfaceCall(
				callStatus: uniffiCallStatus,
				makeCall: makeCall,
				writeReturn: writeReturn
			)
		},
		uniffiFree: { (uniffiHandle: UInt64) in
			let result = try? FfiConverterTypeLoggingDriver.handleMap.remove(handle: uniffiHandle)
			if result == nil {
				print("Uniffi callback interface LoggingDriver: handle missing in uniffiFree")
			}
		}
	)
}

private func uniffiCallbackInitLoggingDriver() {
	uniffi_sargon_uniffi_fn_init_callback_vtable_loggingdriver(&UniffiCallbackInterfaceLoggingDriver.vtable)
}

// MARK: - FfiConverterTypeLoggingDriver
public struct FfiConverterTypeLoggingDriver: FfiConverter {
	fileprivate static var handleMap = UniffiHandleMap<LoggingDriver>()

	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = LoggingDriver

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LoggingDriver {
		LoggingDriverImpl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: LoggingDriver) -> UnsafeMutableRawPointer {
		guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
			fatalError("Cast to UnsafeMutableRawPointer failed")
		}
		return ptr
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoggingDriver {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: LoggingDriver, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeLoggingDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> LoggingDriver {
	try FfiConverterTypeLoggingDriver.lift(pointer)
}

public func FfiConverterTypeLoggingDriver_lower(_ value: LoggingDriver) -> UnsafeMutableRawPointer {
	FfiConverterTypeLoggingDriver.lower(value)
}

// MARK: - NetworkingDriver
/**
 * Trait for executing network requests, to be implemented by hosts, so that
 * Sargon can make network requests with some HTTP client.
 */
public protocol NetworkingDriver: AnyObject {
	/**
	 * Method invoked by Sargon Rust side, telling an implementing type to
	 * execute a `NetworkRequest` and pass the Result back to Sargon Rust side.
	 *
	 * Either: `Err` or `Ok(NetworkResponse)`.
	 */
	func executeNetworkRequest(request: NetworkRequest) async throws -> NetworkResponse
}

// MARK: - NetworkingDriverImpl
/**
 * Trait for executing network requests, to be implemented by hosts, so that
 * Sargon can make network requests with some HTTP client.
 */
open class NetworkingDriverImpl:
	NetworkingDriver
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_networkingdriver(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_networkingdriver(pointer, $0) }
	}

	/**
	 * Method invoked by Sargon Rust side, telling an implementing type to
	 * execute a `NetworkRequest` and pass the Result back to Sargon Rust side.
	 *
	 * Either: `Err` or `Ok(NetworkResponse)`.
	 */
	open func executeNetworkRequest(request: NetworkRequest) async throws -> NetworkResponse {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_networkingdriver_execute_network_request(
					self.uniffiClonePointer(),
					FfiConverterTypeNetworkRequest.lower(request)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeNetworkResponse.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}
}

// MARK: - UniffiCallbackInterfaceNetworkingDriver
// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceNetworkingDriver {
	// Create the VTable using a series of closures.
	// Swift automatically converts these into C callback functions.
	static var vtable: UniffiVTableCallbackInterfaceNetworkingDriver = .init(
		executeNetworkRequest: { (
			uniffiHandle: UInt64,
			request: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws -> NetworkResponse in
				guard let uniffiObj = try? FfiConverterTypeNetworkingDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.executeNetworkRequest(
					request: FfiConverterTypeNetworkRequest.lift(request)
				)
			}

			let uniffiHandleSuccess = { (returnValue: NetworkResponse) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: FfiConverterTypeNetworkResponse.lower(returnValue),
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: RustBuffer.empty(),
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		uniffiFree: { (uniffiHandle: UInt64) in
			let result = try? FfiConverterTypeNetworkingDriver.handleMap.remove(handle: uniffiHandle)
			if result == nil {
				print("Uniffi callback interface NetworkingDriver: handle missing in uniffiFree")
			}
		}
	)
}

private func uniffiCallbackInitNetworkingDriver() {
	uniffi_sargon_uniffi_fn_init_callback_vtable_networkingdriver(&UniffiCallbackInterfaceNetworkingDriver.vtable)
}

// MARK: - FfiConverterTypeNetworkingDriver
public struct FfiConverterTypeNetworkingDriver: FfiConverter {
	fileprivate static var handleMap = UniffiHandleMap<NetworkingDriver>()

	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = NetworkingDriver

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkingDriver {
		NetworkingDriverImpl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: NetworkingDriver) -> UnsafeMutableRawPointer {
		guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
			fatalError("Cast to UnsafeMutableRawPointer failed")
		}
		return ptr
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkingDriver {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: NetworkingDriver, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeNetworkingDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkingDriver {
	try FfiConverterTypeNetworkingDriver.lift(pointer)
}

public func FfiConverterTypeNetworkingDriver_lower(_ value: NetworkingDriver) -> UnsafeMutableRawPointer {
	FfiConverterTypeNetworkingDriver.lower(value)
}

// MARK: - ProfileStateChangeDriver
public protocol ProfileStateChangeDriver: AnyObject {
	func handleProfileStateChange(changedProfileState: ProfileState) async
}

// MARK: - ProfileStateChangeDriverImpl
open class ProfileStateChangeDriverImpl:
	ProfileStateChangeDriver
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_profilestatechangedriver(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_profilestatechangedriver(pointer, $0) }
	}

	open func handleProfileStateChange(changedProfileState: ProfileState) async {
		try! await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_profilestatechangedriver_handle_profile_state_change(
					self.uniffiClonePointer(),
					FfiConverterTypeProfileState.lower(changedProfileState)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: nil
		)
	}
}

// MARK: - UniffiCallbackInterfaceProfileStateChangeDriver
// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceProfileStateChangeDriver {
	// Create the VTable using a series of closures.
	// Swift automatically converts these into C callback functions.
	static var vtable: UniffiVTableCallbackInterfaceProfileStateChangeDriver = .init(
		handleProfileStateChange: { (
			uniffiHandle: UInt64,
			changedProfileState: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws in
				guard let uniffiObj = try? FfiConverterTypeProfileStateChangeDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.handleProfileStateChange(
					changedProfileState: FfiConverterTypeProfileState.lift(changedProfileState)
				)
			}

			let uniffiHandleSuccess = { (_: ()) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		uniffiFree: { (uniffiHandle: UInt64) in
			let result = try? FfiConverterTypeProfileStateChangeDriver.handleMap.remove(handle: uniffiHandle)
			if result == nil {
				print("Uniffi callback interface ProfileStateChangeDriver: handle missing in uniffiFree")
			}
		}
	)
}

private func uniffiCallbackInitProfileStateChangeDriver() {
	uniffi_sargon_uniffi_fn_init_callback_vtable_profilestatechangedriver(&UniffiCallbackInterfaceProfileStateChangeDriver.vtable)
}

// MARK: - FfiConverterTypeProfileStateChangeDriver
public struct FfiConverterTypeProfileStateChangeDriver: FfiConverter {
	fileprivate static var handleMap = UniffiHandleMap<ProfileStateChangeDriver>()

	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = ProfileStateChangeDriver

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ProfileStateChangeDriver {
		ProfileStateChangeDriverImpl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: ProfileStateChangeDriver) -> UnsafeMutableRawPointer {
		guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
			fatalError("Cast to UnsafeMutableRawPointer failed")
		}
		return ptr
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileStateChangeDriver {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: ProfileStateChangeDriver, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeProfileStateChangeDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> ProfileStateChangeDriver {
	try FfiConverterTypeProfileStateChangeDriver.lift(pointer)
}

public func FfiConverterTypeProfileStateChangeDriver_lower(_ value: ProfileStateChangeDriver) -> UnsafeMutableRawPointer {
	FfiConverterTypeProfileStateChangeDriver.lower(value)
}

// MARK: - RadixConnectMobileProtocol
/**
 * The Radix Connect Mobile client that handles the interaction with dApps on mobile through deepLinks.
 */
public protocol RadixConnectMobileProtocol: AnyObject {
	/**
	 * Try to parse the deep link and create a RadixConnectMobileDappRequest.
	 * This is a stateful operation as it will create an in flight session, that needs to be validated by the user.
	 */
	func handleDeepLink(url: String) async throws -> RadixConnectMobileSessionRequest

	/**
	 * Send the Host's response to the dApp.
	 * This is a stateful operation as it will save the session in the secure storage if the user validated the session.
	 */
	func sendDappInteractionResponse(walletResponse: RadixConnectMobileWalletResponse) async throws
}

// MARK: - RadixConnectMobile
/**
 * The Radix Connect Mobile client that handles the interaction with dApps on mobile through deepLinks.
 */
open class RadixConnectMobile:
	RadixConnectMobileProtocol
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_radixconnectmobile(self.pointer, $0) }
	}

	public convenience init(networkingDriver: NetworkingDriver, sessionStorage: RadixConnectMobileSessionStorage) {
		let pointer =
			try! rustCall {
				uniffi_sargon_uniffi_fn_constructor_radixconnectmobile_new(
					FfiConverterTypeNetworkingDriver.lower(networkingDriver),
					FfiConverterTypeRadixConnectMobileSessionStorage.lower(sessionStorage), $0
				)
			}
		self.init(unsafeFromRawPointer: pointer)
	}

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_radixconnectmobile(pointer, $0) }
	}

	/**
	 * Try to parse the deep link and create a RadixConnectMobileDappRequest.
	 * This is a stateful operation as it will create an in flight session, that needs to be validated by the user.
	 */
	open func handleDeepLink(url: String) async throws -> RadixConnectMobileSessionRequest {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_radixconnectmobile_handle_deep_link(
					self.uniffiClonePointer(),
					FfiConverterString.lower(url)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeRadixConnectMobileSessionRequest.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Send the Host's response to the dApp.
	 * This is a stateful operation as it will save the session in the secure storage if the user validated the session.
	 */
	open func sendDappInteractionResponse(walletResponse: RadixConnectMobileWalletResponse) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_radixconnectmobile_send_dapp_interaction_response(
					self.uniffiClonePointer(),
					FfiConverterTypeRadixConnectMobileWalletResponse.lower(walletResponse)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}
}

// MARK: - FfiConverterTypeRadixConnectMobile
public struct FfiConverterTypeRadixConnectMobile: FfiConverter {
	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = RadixConnectMobile

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobile {
		RadixConnectMobile(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: RadixConnectMobile) -> UnsafeMutableRawPointer {
		value.uniffiClonePointer()
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobile {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: RadixConnectMobile, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeRadixConnectMobile_lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobile {
	try FfiConverterTypeRadixConnectMobile.lift(pointer)
}

public func FfiConverterTypeRadixConnectMobile_lower(_ value: RadixConnectMobile) -> UnsafeMutableRawPointer {
	FfiConverterTypeRadixConnectMobile.lower(value)
}

// MARK: - RadixConnectMobileSessionStorage
/**
 * A trait for storing and loading Radix Connect Mobile sessions.
 */
public protocol RadixConnectMobileSessionStorage: AnyObject {
	/**
	 * Saves the session to the storage identified by the session id.
	 */
	func saveSession(sessionId: SessionId, encodedSession: BagOfBytes) async throws

	/**
	 * Loads the session from the storage identified by the session id.
	 */
	func loadSession(sessionId: SessionId) async throws -> BagOfBytes?
}

// MARK: - RadixConnectMobileSessionStorageImpl
/**
 * A trait for storing and loading Radix Connect Mobile sessions.
 */
open class RadixConnectMobileSessionStorageImpl:
	RadixConnectMobileSessionStorage
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_radixconnectmobilesessionstorage(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_radixconnectmobilesessionstorage(pointer, $0) }
	}

	/**
	 * Saves the session to the storage identified by the session id.
	 */
	open func saveSession(sessionId: SessionId, encodedSession: BagOfBytes) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_radixconnectmobilesessionstorage_save_session(
					self.uniffiClonePointer(),
					FfiConverterTypeSessionID.lower(sessionId), FfiConverterTypeBagOfBytes.lower(encodedSession)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Loads the session from the storage identified by the session id.
	 */
	open func loadSession(sessionId: SessionId) async throws -> BagOfBytes? {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_radixconnectmobilesessionstorage_load_session(
					self.uniffiClonePointer(),
					FfiConverterTypeSessionID.lower(sessionId)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}
}

// MARK: - UniffiCallbackInterfaceRadixConnectMobileSessionStorage
// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceRadixConnectMobileSessionStorage {
	// Create the VTable using a series of closures.
	// Swift automatically converts these into C callback functions.
	static var vtable: UniffiVTableCallbackInterfaceRadixConnectMobileSessionStorage = .init(
		saveSession: { (
			uniffiHandle: UInt64,
			sessionId: RustBuffer,
			encodedSession: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws in
				guard let uniffiObj = try? FfiConverterTypeRadixConnectMobileSessionStorage.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.saveSession(
					sessionId: FfiConverterTypeSessionID.lift(sessionId),
					encodedSession: FfiConverterTypeBagOfBytes.lift(encodedSession)
				)
			}

			let uniffiHandleSuccess = { (_: ()) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		loadSession: { (
			uniffiHandle: UInt64,
			sessionId: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws -> BagOfBytes? in
				guard let uniffiObj = try? FfiConverterTypeRadixConnectMobileSessionStorage.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.loadSession(
					sessionId: FfiConverterTypeSessionID.lift(sessionId)
				)
			}

			let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: RustBuffer.empty(),
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		uniffiFree: { (uniffiHandle: UInt64) in
			let result = try? FfiConverterTypeRadixConnectMobileSessionStorage.handleMap.remove(handle: uniffiHandle)
			if result == nil {
				print("Uniffi callback interface RadixConnectMobileSessionStorage: handle missing in uniffiFree")
			}
		}
	)
}

private func uniffiCallbackInitRadixConnectMobileSessionStorage() {
	uniffi_sargon_uniffi_fn_init_callback_vtable_radixconnectmobilesessionstorage(&UniffiCallbackInterfaceRadixConnectMobileSessionStorage.vtable)
}

// MARK: - FfiConverterTypeRadixConnectMobileSessionStorage
public struct FfiConverterTypeRadixConnectMobileSessionStorage: FfiConverter {
	fileprivate static var handleMap = UniffiHandleMap<RadixConnectMobileSessionStorage>()

	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = RadixConnectMobileSessionStorage

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobileSessionStorage {
		RadixConnectMobileSessionStorageImpl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: RadixConnectMobileSessionStorage) -> UnsafeMutableRawPointer {
		guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
			fatalError("Cast to UnsafeMutableRawPointer failed")
		}
		return ptr
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileSessionStorage {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: RadixConnectMobileSessionStorage, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeRadixConnectMobileSessionStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobileSessionStorage {
	try FfiConverterTypeRadixConnectMobileSessionStorage.lift(pointer)
}

public func FfiConverterTypeRadixConnectMobileSessionStorage_lower(_ value: RadixConnectMobileSessionStorage) -> UnsafeMutableRawPointer {
	FfiConverterTypeRadixConnectMobileSessionStorage.lower(value)
}

// MARK: - SargonOsProtocol
/**
 * The Sargon "Operating System" is the root "manager" of the Sargon library
 * which holds an in-memory Profile and a collection of "clients" which are
 * created from "drivers" which the hosts (iOS/Android wallets) "installs"
 * during app launch, enabling the  Sargon "Operating System" to e.g read/write
 * to secure storage and make use of the network connection of the iPhone/Android
 * phone.
 */
public protocol SargonOsProtocol: AnyObject {
	func debugFactorInstancesInCache() async -> [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]]

	/**
	 * Looks up the account by account address, returns Err if the account is
	 * unknown, will return a hidden account if queried for.
	 */
	func accountByAddress(address: AccountAddress) throws -> Account

	/**
	 * Returns the non-hidden accounts on the current network as `AccountForDisplay`
	 */
	func accountsForDisplayOnCurrentNetwork() throws -> [AccountForDisplay]

	/**
	 * Returns the non-hidden accounts on the current network, empty if no accounts
	 * on the network
	 */
	func accountsOnCurrentNetwork() throws -> [Account]

	/**
	 * Add the `account` to active profile and **saves** the updated profile to
	 * secure storage.
	 *
	 * Returns `Ok(())` if the `account` was new and successfully added. If
	 * saving failed or if the account was already present in Profile, an
	 * error is returned.
	 *
	 * # Emits Events
	 * Emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage.
	 *
	 * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
	 */
	func addAccount(account: Account) async throws

	/**
	 * Adds the `accounts` to active profile and **saves** the updated profile to
	 * secure storage.
	 *
	 * Returns `Ok(())` if the `accounts` were new and successfully added. If
	 * saving failed or if the accounts were already present in Profile, an
	 * error is returned.
	 *
	 * # Emits Events
	 * Emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage.
	 *
	 * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
	 */
	func addAccounts(accounts: [Account]) async throws

	/**
	 * Returns `Ok(false)` if the Profile already contained a factor source with the
	 * same id (Profile unchanged occurred).
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceAdded }`
	 *
	 * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
	 * if the newly added FactorSource is a new **main** flag, then we remove the
	 * main flag from the old BDFS.
	 *
	 * And also emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage.
	 */
	func addFactorSource(factorSource: FactorSource) async throws -> Bool

	/**
	 * Adds all of the provided `factor_sources` to Profile in one single go.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourcesAdded }`
	 *
	 * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
	 * if the newly added FactorSource is a new **main** flag, then we remove the
	 * main flag from the old BDFS.
	 *
	 * And also emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage.
	 */
	func addFactorSources(factorSources: [FactorSource]) async throws -> [FactorSourceId]

	/**
	 * Adds the security structureof factor sources to Profile if none with the
	 * same ID already exists, and if all factors it references are found in Profile.
	 *
	 * If `structure` references a FactorSource by ID which is unknown to Profile,
	 * `Err(CommonError::StructureReferencesUnknownFactorSource)` is returned.
	 *
	 * If Profile already contains a structure with the same ID, `Ok(false)` is
	 * returned **without** modifying the existing one.
	 *
	 * # Emits Events
	 * Emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage.
	 *
	 * And also emits `Event::ProfileModified { change: EventProfileModified::SecurityStructureAdded { id } }`
	 */
	func addSecurityStructureOfFactorSources(structure: SecurityStructureOfFactorSources) async throws -> Bool

	/**
	 * Performs initial transaction analysis for a given raw manifest, including:
	 * 1. Creating the SubintentManifest.
	 * 2. Validating if the manifest is open or enclosed.
	 * 3. If open, the manifest with its summary is returned.
	 * 4. If enclosed, it extracts the transaction signers and then transaction preview GW request is executed.
	 * 3. The execution summary is created with the manifest and receipt.
	 *
	 * Maps relevant errors to ensure proper handling by the hosts.
	 */
	func analysePreAuthPreview(instructions: String, blobs: Blobs, nonce: Nonce, notaryPublicKey: PublicKey) async throws -> PreAuthToReview

	/**
	 * Performs initial transaction analysis for a given raw manifest, including:
	 * 1. Extracting the transaction signers.
	 * 2. Executing the transaction preview GW request.
	 * 3. Running the execution summary with the manifest and receipt.
	 *
	 * Maps relevant errors to ensure proper handling by the hosts.
	 */
	func analyseTransactionPreview(instructions: String, blobs: Blobs, areInstructionsOriginatingFromHost: Bool, nonce: Nonce, notaryPublicKey: PublicKey) async throws -> TransactionToReview

	/**
	 * The account names will be `<name_prefix> <index>`
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
	 *
	 * And also emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage.
	 */
	func batchCreateManyAccountsThenSaveOnce(count: UInt16, networkId: NetworkId, namePrefix: String) async throws

	/**
	 * Creates many new non securified accounts **WITHOUT** add them to Profile, using the *main* "Babylon"
	 * `DeviceFactorSource` and the "next" indices for this FactorSource as derivation paths.
	 *
	 * If you want to add them to Profile, call `add_accounts(accounts)`
	 *
	 * # Emits Event
	 * Emits `Event::FactorSourceUpdated { id: FactorSourceID }` since the date in
	 * `factor_source.common.last_used` is updated.
	 */
	func batchCreateUnsavedAccounts(networkId: NetworkId, count: UInt16, namePrefix: String) async throws -> [Account]

	/**
	 * Returns the "main Babylon" `DeviceFactorSource` of the current account as
	 * a `DeviceFactorSource`.
	 */
	func bdfs() throws -> DeviceFactorSource

	/**
	 * Changes the current Gateway to `to`, if it is not already the current.
	 * Returns the outcome of the change, if we did in fact switch (current != to),
	 * and if we switched then if `to` is new.
	 *
	 * If we did in fact change current, an `EventNotification` is emitted.
	 *
	 * # Emits Event
	 * Emits `Event::GatewayChangedCurrent` if we changed the gateway.
	 */
	func changeCurrentGateway(to: Gateway) async throws -> ChangeGatewayOutcome

	/**
	 * Queries all `account_addresses` on ledger and checks reports which one is deleted.
	 *
	 * Returns an array of the account addresses along with a `bool` being true if that account
	 * is deleted
	 */
	func checkAccountsDeletedOnLedger(networkId: NetworkId, accountAddresses: [AccountAddress]) async throws -> [AccountAddress: Bool]

	/**
	 * Create a new Account and adds it to the active Profile.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
	 */
	func createAndSaveNewAccount(networkId: NetworkId, name: DisplayName) async throws -> Account

	/**
	 * Create a new mainnet Account and adds it to the active Profile.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
	 */
	func createAndSaveNewMainnetAccount(name: DisplayName) async throws -> Account

	/**
	 * Create a new mainnet Account named "Unnamed" and adds it to the active Profile.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
	 */
	func createAndSaveNewUnnamedMainnetAccount() async throws -> Account

	/**
	 * Creates the `TransactionManifest` for deleting the given `account_address`. If a
	 * `recipient_account_address` is provided, the manifest will also send all the resources from
	 * the deleted account to the recipient one.
	 */
	func createDeleteAccountManifest(accountAddress: AccountAddress, recipientAccountAddress: AccountAddress?) async throws -> CreateDeleteAccountManifestOutcome

	/**
	 * Creates a new unsaved DeviceFactorSource from the provided `mnemonic_with_passphrase`,
	 * either a "BDFS" or an "Olympia" one.
	 */
	func createDeviceFactorSource(mnemonicWithPassphrase: MnemonicWithPassphrase, factorType: DeviceFactorSourceType) async throws -> DeviceFactorSource

	/**
	 * Creates a Subintent given its discriminator, manifest and expiration.
	 */
	func createSubintent(intentDiscriminator: IntentDiscriminator, subintentManifest: SubintentManifest, expiration: DappToWalletInteractionSubintentExpiration, message: String?) async throws -> Subintent

	/**
	 * Creates a new non securified account **WITHOUT** adding it to Profile,
	 * using the *main* "Babylon" `DeviceFactorSource` and the "next" index for
	 * this FactorSource as derivation path.
	 *
	 * If you want to add it to Profile, call `os.add_account(account)`.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage, since the `last_used_on` date
	 * of the factor source has been updated.
	 *
	 * Also emits `EventNotification::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
	 */
	func createUnsavedAccount(networkId: NetworkId, name: DisplayName) async throws -> Account

	/**
	 * Uses `create_unsaved_account` specifying `NetworkID::Mainnet`.
	 */
	func createUnsavedMainnetAccount(name: DisplayName) async throws -> Account

	/**
	 * Creates a new unsaved mainnet account named "Unnamed {N}", where `N` is the
	 * index of the next account for the BDFS.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`
	 */
	func createUnsavedUnnamedMainnetAccount() async throws -> Account

	/**
	 * The current gateway host client is using, which affects `current_network_id`.
	 * All Network Requests reading from Radix ledger and submission of new
	 * transactions will go the the Radix Network of the current Gateway.
	 */
	func currentGateway() throws -> Gateway

	/**
	 * Returns the `ProfileNetwork` corresponding to the network ID set by the
	 * current gateway.
	 */
	func currentNetwork() throws -> ProfileNetwork

	/**
	 * Returns the id of the Network of the current Gateway set in AppPreferences
	 * of the active Profile. This is the canonical value of "current network",
	 * which affects which accounts host clients display to end user and to
	 * which network transactions are submitted, amongst other behaviors.
	 */
	func currentNetworkId() throws -> NetworkId

	func debugAddAllSampleFactors() async throws -> [FactorSourceId]

	func deleteWallet() async throws

	/**
	 * Returns all the factor sources
	 */
	func factorSources() throws -> [FactorSource]

	/**
	 * Returns the `gateways` values of the current Profile.
	 */
	func gateways() throws -> SavedGateways

	/**
	 * Has **any** account, at all, including hidden, on any network.
	 */
	func hasAnyAccountOnAnyNetwork() throws -> Bool

	/**
	 * Checks if current Profile contains any `ProfileNetwork`s.
	 */
	func hasAnyNetwork() throws -> Bool

	/**
	 * Imports the `profile`, claims it, set it as active (current) one and
	 * saves it into secure storage (with the claim modification).
	 *
	 * # Emits Event
	 * Emits `EventNotification::new(Event::ProfileImported))` event if successful.
	 */
	func importProfile(profile: Profile) async throws

	func importWallet(profile: Profile, bdfsSkipped: Bool) async throws

	/**
	 * Loads a `MnemonicWithPassphrase` with the `id` of `device_factor_source`,
	 * from SecureStorage, and returns a `PrivateHierarchicalDeterministicFactorSource`
	 * built from both.
	 *
	 * Useful for when you will want to sign transactions or derive public keys for
	 * creation of new entities.
	 *
	 * Returns `Err` if loading or decoding of `MnemonicWithPassphrase` from
	 * SecureStorage fails.
	 */
	func loadPrivateDeviceFactorSourceById(id: FactorSourceIdFromHash) async throws -> PrivateHierarchicalDeterministicFactorSource

	/**
	 * Updates the profile by marking the account with `account_address` as hidden.
	 */
	func markAccountAsHidden(accountAddress: AccountAddress) async throws

	/**
	 * Updates the profile by marking the account with `account_address` as tombstoned.
	 */
	func markAccountAsTombstoned(accountAddress: AccountAddress) async throws

	func newWallet(shouldPreDeriveInstances: Bool) async throws

	func newWalletWithDerivedBdfs(hdFactorSource: PrivateHierarchicalDeterministicFactorSource, accounts: [Account]) async throws

	/**
	 * Polls the status of a `SubintentHash` until it is either `Success` or `Expired`.
	 */
	func pollPreAuthorizationStatus(intentHash: SubintentHash, expirationTimestamp: Instant) async throws -> PreAuthorizationStatus

	/**
	 * Polls the state of a Transaction until we can determine its `TransactionStatus`.
	 */
	func pollTransactionStatus(intentHash: TransactionIntentHash) async throws -> TransactionStatus

	func profile() throws -> Profile

	func resolveHostId() async throws -> HostId

	func resolveHostInfo() async -> HostInfo

	/**
	 * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
	 * in profile.
	 */
	func securityStructureOfFactorSourcesFromSecurityStructureOfFactorSourceIds(structureOfIds: SecurityStructureOfFactorSourceIDs) throws -> SecurityStructureOfFactorSources

	/**
	 * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
	 * in profile.
	 */
	func securityStructuresOfFactorSourceIds() throws -> [SecurityStructureOfFactorSourceIDs]

	/**
	 * Returns all the SecurityStructuresOfFactorSources,
	 * by trying to map FactorSourceID level -> FactorSource Level
	 */
	func securityStructuresOfFactorSources() throws -> [SecurityStructureOfFactorSources]

	func setProfile(profile: Profile) async throws

	/**
	 * Submits a notarized transaction payload to the network.
	 */
	func submitTransaction(notarizedTransaction: NotarizedTransaction) async throws -> TransactionIntentHash

	/**
	 * Checks all active accounts in current network on ledger, if any of them are deleted.
	 * Any deleted account is marked as tombstoned in profile.
	 *
	 * Returns true if any account became tombstoned.
	 */
	func syncAccountsDeletedOnLedger() async throws -> Bool

	/**
	 * Updates the account `updated` by mutating current profile and persisting
	 * the change to secure storage. Throws `UnknownAccount` error if the account
	 * is not found.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::AccountUpdated { address } }`
	 */
	func updateAccount(updated: Account) async throws

	/**
	 * Updates the factor source `updated` by mutating current profile and persisting
	 * the change to secure storage. Throws `UpdateFactorSourceMutateFailed` error if the
	 * factor source is not found.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
	 */
	func updateFactorSource(updated: FactorSource) async throws
}

// MARK: - SargonOs
/**
 * The Sargon "Operating System" is the root "manager" of the Sargon library
 * which holds an in-memory Profile and a collection of "clients" which are
 * created from "drivers" which the hosts (iOS/Android wallets) "installs"
 * during app launch, enabling the  Sargon "Operating System" to e.g read/write
 * to secure storage and make use of the network connection of the iPhone/Android
 * phone.
 */
open class SargonOs:
	SargonOsProtocol
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_sargonos(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_sargonos(pointer, $0) }
	}

	public static func boot(bios: Bios) async -> SargonOs {
		try! await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_constructor_sargonos_boot(FfiConverterTypeBios.lower(bios)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_pointer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_pointer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_pointer,
			liftFunc: FfiConverterTypeSargonOS.lift,
			errorHandler: nil
		)
	}

	open func debugFactorInstancesInCache() async -> [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]] {
		try! await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos___debug_factor_instances_in_cache(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterDictionaryTypeFactorSourceIDFromHashSequenceSequenceTypeFactorInstanceForDebugPurposes.lift,
			errorHandler: nil
		)
	}

	/**
	 * Looks up the account by account address, returns Err if the account is
	 * unknown, will return a hidden account if queried for.
	 */
	open func accountByAddress(address: AccountAddress) throws -> Account {
		try FfiConverterTypeAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_account_by_address(self.uniffiClonePointer(),
			                                                           FfiConverterTypeAccountAddress.lower(address), $0)
		})
	}

	/**
	 * Returns the non-hidden accounts on the current network as `AccountForDisplay`
	 */
	open func accountsForDisplayOnCurrentNetwork() throws -> [AccountForDisplay] {
		try FfiConverterSequenceTypeAccountForDisplay.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_accounts_for_display_on_current_network(self.uniffiClonePointer(), $0)
		})
	}

	/**
	 * Returns the non-hidden accounts on the current network, empty if no accounts
	 * on the network
	 */
	open func accountsOnCurrentNetwork() throws -> [Account] {
		try FfiConverterSequenceTypeAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_accounts_on_current_network(self.uniffiClonePointer(), $0)
		})
	}

	/**
	 * Add the `account` to active profile and **saves** the updated profile to
	 * secure storage.
	 *
	 * Returns `Ok(())` if the `account` was new and successfully added. If
	 * saving failed or if the account was already present in Profile, an
	 * error is returned.
	 *
	 * # Emits Events
	 * Emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage.
	 *
	 * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
	 */
	open func addAccount(account: Account) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_add_account(
					self.uniffiClonePointer(),
					FfiConverterTypeAccount.lower(account)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Adds the `accounts` to active profile and **saves** the updated profile to
	 * secure storage.
	 *
	 * Returns `Ok(())` if the `accounts` were new and successfully added. If
	 * saving failed or if the accounts were already present in Profile, an
	 * error is returned.
	 *
	 * # Emits Events
	 * Emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage.
	 *
	 * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
	 */
	open func addAccounts(accounts: [Account]) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_add_accounts(
					self.uniffiClonePointer(),
					FfiConverterSequenceTypeAccount.lower(accounts)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Returns `Ok(false)` if the Profile already contained a factor source with the
	 * same id (Profile unchanged occurred).
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceAdded }`
	 *
	 * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
	 * if the newly added FactorSource is a new **main** flag, then we remove the
	 * main flag from the old BDFS.
	 *
	 * And also emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage.
	 */
	open func addFactorSource(factorSource: FactorSource) async throws -> Bool {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_add_factor_source(
					self.uniffiClonePointer(),
					FfiConverterTypeFactorSource.lower(factorSource)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_i8,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_i8,
			freeFunc: ffi_sargon_uniffi_rust_future_free_i8,
			liftFunc: FfiConverterBool.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Adds all of the provided `factor_sources` to Profile in one single go.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourcesAdded }`
	 *
	 * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
	 * if the newly added FactorSource is a new **main** flag, then we remove the
	 * main flag from the old BDFS.
	 *
	 * And also emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage.
	 */
	open func addFactorSources(factorSources: [FactorSource]) async throws -> [FactorSourceId] {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_add_factor_sources(
					self.uniffiClonePointer(),
					FfiConverterSequenceTypeFactorSource.lower(factorSources)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterSequenceTypeFactorSourceID.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Adds the security structureof factor sources to Profile if none with the
	 * same ID already exists, and if all factors it references are found in Profile.
	 *
	 * If `structure` references a FactorSource by ID which is unknown to Profile,
	 * `Err(CommonError::StructureReferencesUnknownFactorSource)` is returned.
	 *
	 * If Profile already contains a structure with the same ID, `Ok(false)` is
	 * returned **without** modifying the existing one.
	 *
	 * # Emits Events
	 * Emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage.
	 *
	 * And also emits `Event::ProfileModified { change: EventProfileModified::SecurityStructureAdded { id } }`
	 */
	open func addSecurityStructureOfFactorSources(structure: SecurityStructureOfFactorSources) async throws -> Bool {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_add_security_structure_of_factor_sources(
					self.uniffiClonePointer(),
					FfiConverterTypeSecurityStructureOfFactorSources.lower(structure)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_i8,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_i8,
			freeFunc: ffi_sargon_uniffi_rust_future_free_i8,
			liftFunc: FfiConverterBool.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Performs initial transaction analysis for a given raw manifest, including:
	 * 1. Creating the SubintentManifest.
	 * 2. Validating if the manifest is open or enclosed.
	 * 3. If open, the manifest with its summary is returned.
	 * 4. If enclosed, it extracts the transaction signers and then transaction preview GW request is executed.
	 * 3. The execution summary is created with the manifest and receipt.
	 *
	 * Maps relevant errors to ensure proper handling by the hosts.
	 */
	open func analysePreAuthPreview(instructions: String, blobs: Blobs, nonce: Nonce, notaryPublicKey: PublicKey) async throws -> PreAuthToReview {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_analyse_pre_auth_preview(
					self.uniffiClonePointer(),
					FfiConverterString.lower(instructions), FfiConverterTypeBlobs.lower(blobs), FfiConverterTypeNonce.lower(nonce), FfiConverterTypePublicKey.lower(notaryPublicKey)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypePreAuthToReview.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Performs initial transaction analysis for a given raw manifest, including:
	 * 1. Extracting the transaction signers.
	 * 2. Executing the transaction preview GW request.
	 * 3. Running the execution summary with the manifest and receipt.
	 *
	 * Maps relevant errors to ensure proper handling by the hosts.
	 */
	open func analyseTransactionPreview(instructions: String, blobs: Blobs, areInstructionsOriginatingFromHost: Bool, nonce: Nonce, notaryPublicKey: PublicKey) async throws -> TransactionToReview {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_analyse_transaction_preview(
					self.uniffiClonePointer(),
					FfiConverterString.lower(instructions), FfiConverterTypeBlobs.lower(blobs), FfiConverterBool.lower(areInstructionsOriginatingFromHost), FfiConverterTypeNonce.lower(nonce), FfiConverterTypePublicKey.lower(notaryPublicKey)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeTransactionToReview.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * The account names will be `<name_prefix> <index>`
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
	 *
	 * And also emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage.
	 */
	open func batchCreateManyAccountsThenSaveOnce(count: UInt16, networkId: NetworkId, namePrefix: String) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_batch_create_many_accounts_then_save_once(
					self.uniffiClonePointer(),
					FfiConverterUInt16.lower(count), FfiConverterTypeNetworkID.lower(networkId), FfiConverterString.lower(namePrefix)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Creates many new non securified accounts **WITHOUT** add them to Profile, using the *main* "Babylon"
	 * `DeviceFactorSource` and the "next" indices for this FactorSource as derivation paths.
	 *
	 * If you want to add them to Profile, call `add_accounts(accounts)`
	 *
	 * # Emits Event
	 * Emits `Event::FactorSourceUpdated { id: FactorSourceID }` since the date in
	 * `factor_source.common.last_used` is updated.
	 */
	open func batchCreateUnsavedAccounts(networkId: NetworkId, count: UInt16, namePrefix: String) async throws -> [Account] {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_batch_create_unsaved_accounts(
					self.uniffiClonePointer(),
					FfiConverterTypeNetworkID.lower(networkId), FfiConverterUInt16.lower(count), FfiConverterString.lower(namePrefix)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterSequenceTypeAccount.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Returns the "main Babylon" `DeviceFactorSource` of the current account as
	 * a `DeviceFactorSource`.
	 */
	open func bdfs() throws -> DeviceFactorSource {
		try FfiConverterTypeDeviceFactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_bdfs(self.uniffiClonePointer(), $0)
		})
	}

	/**
	 * Changes the current Gateway to `to`, if it is not already the current.
	 * Returns the outcome of the change, if we did in fact switch (current != to),
	 * and if we switched then if `to` is new.
	 *
	 * If we did in fact change current, an `EventNotification` is emitted.
	 *
	 * # Emits Event
	 * Emits `Event::GatewayChangedCurrent` if we changed the gateway.
	 */
	open func changeCurrentGateway(to: Gateway) async throws -> ChangeGatewayOutcome {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_change_current_gateway(
					self.uniffiClonePointer(),
					FfiConverterTypeGateway.lower(to)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeChangeGatewayOutcome.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Queries all `account_addresses` on ledger and checks reports which one is deleted.
	 *
	 * Returns an array of the account addresses along with a `bool` being true if that account
	 * is deleted
	 */
	open func checkAccountsDeletedOnLedger(networkId: NetworkId, accountAddresses: [AccountAddress]) async throws -> [AccountAddress: Bool] {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_check_accounts_deleted_on_ledger(
					self.uniffiClonePointer(),
					FfiConverterTypeNetworkID.lower(networkId), FfiConverterSequenceTypeAccountAddress.lower(accountAddresses)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterDictionaryTypeAccountAddressBool.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Create a new Account and adds it to the active Profile.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
	 */
	open func createAndSaveNewAccount(networkId: NetworkId, name: DisplayName) async throws -> Account {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_create_and_save_new_account(
					self.uniffiClonePointer(),
					FfiConverterTypeNetworkID.lower(networkId), FfiConverterTypeDisplayName.lower(name)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeAccount.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Create a new mainnet Account and adds it to the active Profile.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
	 */
	open func createAndSaveNewMainnetAccount(name: DisplayName) async throws -> Account {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_create_and_save_new_mainnet_account(
					self.uniffiClonePointer(),
					FfiConverterTypeDisplayName.lower(name)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeAccount.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Create a new mainnet Account named "Unnamed" and adds it to the active Profile.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
	 */
	open func createAndSaveNewUnnamedMainnetAccount() async throws -> Account {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_create_and_save_new_unnamed_mainnet_account(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeAccount.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Creates the `TransactionManifest` for deleting the given `account_address`. If a
	 * `recipient_account_address` is provided, the manifest will also send all the resources from
	 * the deleted account to the recipient one.
	 */
	open func createDeleteAccountManifest(accountAddress: AccountAddress, recipientAccountAddress: AccountAddress?) async throws -> CreateDeleteAccountManifestOutcome {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_create_delete_account_manifest(
					self.uniffiClonePointer(),
					FfiConverterTypeAccountAddress.lower(accountAddress), FfiConverterOptionTypeAccountAddress.lower(recipientAccountAddress)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeCreateDeleteAccountManifestOutcome.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Creates a new unsaved DeviceFactorSource from the provided `mnemonic_with_passphrase`,
	 * either a "BDFS" or an "Olympia" one.
	 */
	open func createDeviceFactorSource(mnemonicWithPassphrase: MnemonicWithPassphrase, factorType: DeviceFactorSourceType) async throws -> DeviceFactorSource {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_create_device_factor_source(
					self.uniffiClonePointer(),
					FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase), FfiConverterTypeDeviceFactorSourceType.lower(factorType)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeDeviceFactorSource.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Creates a Subintent given its discriminator, manifest and expiration.
	 */
	open func createSubintent(intentDiscriminator: IntentDiscriminator, subintentManifest: SubintentManifest, expiration: DappToWalletInteractionSubintentExpiration, message: String?) async throws -> Subintent {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_create_subintent(
					self.uniffiClonePointer(),
					FfiConverterTypeIntentDiscriminator.lower(intentDiscriminator), FfiConverterTypeSubintentManifest.lower(subintentManifest), FfiConverterTypeDappToWalletInteractionSubintentExpiration.lower(expiration), FfiConverterOptionString.lower(message)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeSubintent.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Creates a new non securified account **WITHOUT** adding it to Profile,
	 * using the *main* "Babylon" `DeviceFactorSource` and the "next" index for
	 * this FactorSource as derivation path.
	 *
	 * If you want to add it to Profile, call `os.add_account(account)`.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileSaved` after having successfully written the JSON
	 * of the active profile to secure storage, since the `last_used_on` date
	 * of the factor source has been updated.
	 *
	 * Also emits `EventNotification::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
	 */
	open func createUnsavedAccount(networkId: NetworkId, name: DisplayName) async throws -> Account {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_create_unsaved_account(
					self.uniffiClonePointer(),
					FfiConverterTypeNetworkID.lower(networkId), FfiConverterTypeDisplayName.lower(name)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeAccount.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Uses `create_unsaved_account` specifying `NetworkID::Mainnet`.
	 */
	open func createUnsavedMainnetAccount(name: DisplayName) async throws -> Account {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_create_unsaved_mainnet_account(
					self.uniffiClonePointer(),
					FfiConverterTypeDisplayName.lower(name)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeAccount.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Creates a new unsaved mainnet account named "Unnamed {N}", where `N` is the
	 * index of the next account for the BDFS.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`
	 */
	open func createUnsavedUnnamedMainnetAccount() async throws -> Account {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_create_unsaved_unnamed_mainnet_account(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeAccount.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * The current gateway host client is using, which affects `current_network_id`.
	 * All Network Requests reading from Radix ledger and submission of new
	 * transactions will go the the Radix Network of the current Gateway.
	 */
	open func currentGateway() throws -> Gateway {
		try FfiConverterTypeGateway.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_current_gateway(self.uniffiClonePointer(), $0)
		})
	}

	/**
	 * Returns the `ProfileNetwork` corresponding to the network ID set by the
	 * current gateway.
	 */
	open func currentNetwork() throws -> ProfileNetwork {
		try FfiConverterTypeProfileNetwork.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_current_network(self.uniffiClonePointer(), $0)
		})
	}

	/**
	 * Returns the id of the Network of the current Gateway set in AppPreferences
	 * of the active Profile. This is the canonical value of "current network",
	 * which affects which accounts host clients display to end user and to
	 * which network transactions are submitted, amongst other behaviors.
	 */
	open func currentNetworkId() throws -> NetworkId {
		try FfiConverterTypeNetworkID.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_current_network_id(self.uniffiClonePointer(), $0)
		})
	}

	open func debugAddAllSampleFactors() async throws -> [FactorSourceId] {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_debug_add_all_sample_factors(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterSequenceTypeFactorSourceID.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func deleteWallet() async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_delete_wallet(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Returns all the factor sources
	 */
	open func factorSources() throws -> [FactorSource] {
		try FfiConverterSequenceTypeFactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_factor_sources(self.uniffiClonePointer(), $0)
		})
	}

	/**
	 * Returns the `gateways` values of the current Profile.
	 */
	open func gateways() throws -> SavedGateways {
		try FfiConverterTypeSavedGateways.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_gateways(self.uniffiClonePointer(), $0)
		})
	}

	/**
	 * Has **any** account, at all, including hidden, on any network.
	 */
	open func hasAnyAccountOnAnyNetwork() throws -> Bool {
		try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_has_any_account_on_any_network(self.uniffiClonePointer(), $0)
		})
	}

	/**
	 * Checks if current Profile contains any `ProfileNetwork`s.
	 */
	open func hasAnyNetwork() throws -> Bool {
		try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_has_any_network(self.uniffiClonePointer(), $0)
		})
	}

	/**
	 * Imports the `profile`, claims it, set it as active (current) one and
	 * saves it into secure storage (with the claim modification).
	 *
	 * # Emits Event
	 * Emits `EventNotification::new(Event::ProfileImported))` event if successful.
	 */
	open func importProfile(profile: Profile) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_import_profile(
					self.uniffiClonePointer(),
					FfiConverterTypeProfile.lower(profile)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func importWallet(profile: Profile, bdfsSkipped: Bool) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_import_wallet(
					self.uniffiClonePointer(),
					FfiConverterTypeProfile.lower(profile), FfiConverterBool.lower(bdfsSkipped)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Loads a `MnemonicWithPassphrase` with the `id` of `device_factor_source`,
	 * from SecureStorage, and returns a `PrivateHierarchicalDeterministicFactorSource`
	 * built from both.
	 *
	 * Useful for when you will want to sign transactions or derive public keys for
	 * creation of new entities.
	 *
	 * Returns `Err` if loading or decoding of `MnemonicWithPassphrase` from
	 * SecureStorage fails.
	 */
	open func loadPrivateDeviceFactorSourceById(id: FactorSourceIdFromHash) async throws -> PrivateHierarchicalDeterministicFactorSource {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_load_private_device_factor_source_by_id(
					self.uniffiClonePointer(),
					FfiConverterTypeFactorSourceIDFromHash.lower(id)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Updates the profile by marking the account with `account_address` as hidden.
	 */
	open func markAccountAsHidden(accountAddress: AccountAddress) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_mark_account_as_hidden(
					self.uniffiClonePointer(),
					FfiConverterTypeAccountAddress.lower(accountAddress)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Updates the profile by marking the account with `account_address` as tombstoned.
	 */
	open func markAccountAsTombstoned(accountAddress: AccountAddress) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_mark_account_as_tombstoned(
					self.uniffiClonePointer(),
					FfiConverterTypeAccountAddress.lower(accountAddress)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func newWallet(shouldPreDeriveInstances: Bool) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_new_wallet(
					self.uniffiClonePointer(),
					FfiConverterBool.lower(shouldPreDeriveInstances)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func newWalletWithDerivedBdfs(hdFactorSource: PrivateHierarchicalDeterministicFactorSource, accounts: [Account]) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_new_wallet_with_derived_bdfs(
					self.uniffiClonePointer(),
					FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lower(hdFactorSource), FfiConverterSequenceTypeAccount.lower(accounts)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Polls the status of a `SubintentHash` until it is either `Success` or `Expired`.
	 */
	open func pollPreAuthorizationStatus(intentHash: SubintentHash, expirationTimestamp: Instant) async throws -> PreAuthorizationStatus {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_poll_pre_authorization_status(
					self.uniffiClonePointer(),
					FfiConverterTypeSubintentHash.lower(intentHash), FfiConverterTypeInstant.lower(expirationTimestamp)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypePreAuthorizationStatus.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Polls the state of a Transaction until we can determine its `TransactionStatus`.
	 */
	open func pollTransactionStatus(intentHash: TransactionIntentHash) async throws -> TransactionStatus {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_poll_transaction_status(
					self.uniffiClonePointer(),
					FfiConverterTypeTransactionIntentHash.lower(intentHash)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeTransactionStatus.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func profile() throws -> Profile {
		try FfiConverterTypeProfile.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_profile(self.uniffiClonePointer(), $0)
		})
	}

	open func resolveHostId() async throws -> HostId {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_resolve_host_id(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeHostId.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func resolveHostInfo() async -> HostInfo {
		try! await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_resolve_host_info(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeHostInfo.lift,
			errorHandler: nil
		)
	}

	/**
	 * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
	 * in profile.
	 */
	open func securityStructureOfFactorSourcesFromSecurityStructureOfFactorSourceIds(structureOfIds: SecurityStructureOfFactorSourceIDs) throws -> SecurityStructureOfFactorSources {
		try FfiConverterTypeSecurityStructureOfFactorSources.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_security_structure_of_factor_sources_from_security_structure_of_factor_source_ids(self.uniffiClonePointer(),
			                                                                                                                          FfiConverterTypeSecurityStructureOfFactorSourceIDs.lower(structureOfIds), $0)
		})
	}

	/**
	 * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
	 * in profile.
	 */
	open func securityStructuresOfFactorSourceIds() throws -> [SecurityStructureOfFactorSourceIDs] {
		try FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_security_structures_of_factor_source_ids(self.uniffiClonePointer(), $0)
		})
	}

	/**
	 * Returns all the SecurityStructuresOfFactorSources,
	 * by trying to map FactorSourceID level -> FactorSource Level
	 */
	open func securityStructuresOfFactorSources() throws -> [SecurityStructureOfFactorSources] {
		try FfiConverterSequenceTypeSecurityStructureOfFactorSources.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
			uniffi_sargon_uniffi_fn_method_sargonos_security_structures_of_factor_sources(self.uniffiClonePointer(), $0)
		})
	}

	open func setProfile(profile: Profile) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_set_profile(
					self.uniffiClonePointer(),
					FfiConverterTypeProfile.lower(profile)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Submits a notarized transaction payload to the network.
	 */
	open func submitTransaction(notarizedTransaction: NotarizedTransaction) async throws -> TransactionIntentHash {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_submit_transaction(
					self.uniffiClonePointer(),
					FfiConverterTypeNotarizedTransaction.lower(notarizedTransaction)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterTypeTransactionIntentHash.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Checks all active accounts in current network on ledger, if any of them are deleted.
	 * Any deleted account is marked as tombstoned in profile.
	 *
	 * Returns true if any account became tombstoned.
	 */
	open func syncAccountsDeletedOnLedger() async throws -> Bool {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_sync_accounts_deleted_on_ledger(
					self.uniffiClonePointer()
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_i8,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_i8,
			freeFunc: ffi_sargon_uniffi_rust_future_free_i8,
			liftFunc: FfiConverterBool.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Updates the account `updated` by mutating current profile and persisting
	 * the change to secure storage. Throws `UnknownAccount` error if the account
	 * is not found.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::AccountUpdated { address } }`
	 */
	open func updateAccount(updated: Account) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_update_account(
					self.uniffiClonePointer(),
					FfiConverterTypeAccount.lower(updated)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	/**
	 * Updates the factor source `updated` by mutating current profile and persisting
	 * the change to secure storage. Throws `UpdateFactorSourceMutateFailed` error if the
	 * factor source is not found.
	 *
	 * # Emits Event
	 * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
	 */
	open func updateFactorSource(updated: FactorSource) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_sargonos_update_factor_source(
					self.uniffiClonePointer(),
					FfiConverterTypeFactorSource.lower(updated)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}
}

// MARK: - FfiConverterTypeSargonOS
public struct FfiConverterTypeSargonOS: FfiConverter {
	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = SargonOs

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SargonOs {
		SargonOs(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: SargonOs) -> UnsafeMutableRawPointer {
		value.uniffiClonePointer()
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonOs {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: SargonOs, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeSargonOS_lift(_ pointer: UnsafeMutableRawPointer) throws -> SargonOs {
	try FfiConverterTypeSargonOS.lift(pointer)
}

public func FfiConverterTypeSargonOS_lower(_ value: SargonOs) -> UnsafeMutableRawPointer {
	FfiConverterTypeSargonOS.lower(value)
}

// MARK: - SecureStorageDriver
public protocol SecureStorageDriver: AnyObject {
	func loadData(key: SecureStorageKey) async throws -> BagOfBytes?

	func saveData(key: SecureStorageKey, data: BagOfBytes) async throws

	func deleteDataForKey(key: SecureStorageKey) async throws
}

// MARK: - SecureStorageDriverImpl
open class SecureStorageDriverImpl:
	SecureStorageDriver
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_securestoragedriver(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_securestoragedriver(pointer, $0) }
	}

	open func loadData(key: SecureStorageKey) async throws -> BagOfBytes? {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_securestoragedriver_load_data(
					self.uniffiClonePointer(),
					FfiConverterTypeSecureStorageKey.lower(key)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func saveData(key: SecureStorageKey, data: BagOfBytes) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_securestoragedriver_save_data(
					self.uniffiClonePointer(),
					FfiConverterTypeSecureStorageKey.lower(key), FfiConverterTypeBagOfBytes.lower(data)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func deleteDataForKey(key: SecureStorageKey) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_securestoragedriver_delete_data_for_key(
					self.uniffiClonePointer(),
					FfiConverterTypeSecureStorageKey.lower(key)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}
}

// MARK: - UniffiCallbackInterfaceSecureStorageDriver
// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceSecureStorageDriver {
	// Create the VTable using a series of closures.
	// Swift automatically converts these into C callback functions.
	static var vtable: UniffiVTableCallbackInterfaceSecureStorageDriver = .init(
		loadData: { (
			uniffiHandle: UInt64,
			key: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws -> BagOfBytes? in
				guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.loadData(
					key: FfiConverterTypeSecureStorageKey.lift(key)
				)
			}

			let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: RustBuffer.empty(),
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		saveData: { (
			uniffiHandle: UInt64,
			key: RustBuffer,
			data: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws in
				guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.saveData(
					key: FfiConverterTypeSecureStorageKey.lift(key),
					data: FfiConverterTypeBagOfBytes.lift(data)
				)
			}

			let uniffiHandleSuccess = { (_: ()) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		deleteDataForKey: { (
			uniffiHandle: UInt64,
			key: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws in
				guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.deleteDataForKey(
					key: FfiConverterTypeSecureStorageKey.lift(key)
				)
			}

			let uniffiHandleSuccess = { (_: ()) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		uniffiFree: { (uniffiHandle: UInt64) in
			let result = try? FfiConverterTypeSecureStorageDriver.handleMap.remove(handle: uniffiHandle)
			if result == nil {
				print("Uniffi callback interface SecureStorageDriver: handle missing in uniffiFree")
			}
		}
	)
}

private func uniffiCallbackInitSecureStorageDriver() {
	uniffi_sargon_uniffi_fn_init_callback_vtable_securestoragedriver(&UniffiCallbackInterfaceSecureStorageDriver.vtable)
}

// MARK: - FfiConverterTypeSecureStorageDriver
public struct FfiConverterTypeSecureStorageDriver: FfiConverter {
	fileprivate static var handleMap = UniffiHandleMap<SecureStorageDriver>()

	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = SecureStorageDriver

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecureStorageDriver {
		SecureStorageDriverImpl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: SecureStorageDriver) -> UnsafeMutableRawPointer {
		guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
			fatalError("Cast to UnsafeMutableRawPointer failed")
		}
		return ptr
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageDriver {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: SecureStorageDriver, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeSecureStorageDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecureStorageDriver {
	try FfiConverterTypeSecureStorageDriver.lift(pointer)
}

public func FfiConverterTypeSecureStorageDriver_lower(_ value: SecureStorageDriver) -> UnsafeMutableRawPointer {
	FfiConverterTypeSecureStorageDriver.lower(value)
}

// MARK: - UnsafeStorageDriver
public protocol UnsafeStorageDriver: AnyObject {
	func loadData(key: UnsafeStorageKey) async throws -> BagOfBytes?

	func saveData(key: UnsafeStorageKey, data: BagOfBytes) async throws

	func deleteDataForKey(key: UnsafeStorageKey) async throws
}

// MARK: - UnsafeStorageDriverImpl
open class UnsafeStorageDriverImpl:
	UnsafeStorageDriver
{
	fileprivate let pointer: UnsafeMutableRawPointer!

	/// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
	public struct NoPointer {
		public init() {}
	}

	// TODO: We'd like this to be `private` but for Swifty reasons,
	// we can't implement `FfiConverter` without making this `required` and we can't
	// make it `required` without making it `public`.
	public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
		self.pointer = pointer
	}

	/// This constructor can be used to instantiate a fake object.
	/// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
	///
	/// - Warning:
	///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
	public init(noPointer: NoPointer) {
		self.pointer = nil
	}

	public func uniffiClonePointer() -> UnsafeMutableRawPointer {
		try! rustCall { uniffi_sargon_uniffi_fn_clone_unsafestoragedriver(self.pointer, $0) }
	}

	// No primary constructor declared for this class.

	deinit {
		guard let pointer else {
			return
		}

		try! rustCall { uniffi_sargon_uniffi_fn_free_unsafestoragedriver(pointer, $0) }
	}

	open func loadData(key: UnsafeStorageKey) async throws -> BagOfBytes? {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_unsafestoragedriver_load_data(
					self.uniffiClonePointer(),
					FfiConverterTypeUnsafeStorageKey.lower(key)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
			freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
			liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func saveData(key: UnsafeStorageKey, data: BagOfBytes) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_unsafestoragedriver_save_data(
					self.uniffiClonePointer(),
					FfiConverterTypeUnsafeStorageKey.lower(key), FfiConverterTypeBagOfBytes.lower(data)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}

	open func deleteDataForKey(key: UnsafeStorageKey) async throws {
		try await uniffiRustCallAsync(
			rustFutureFunc: {
				uniffi_sargon_uniffi_fn_method_unsafestoragedriver_delete_data_for_key(
					self.uniffiClonePointer(),
					FfiConverterTypeUnsafeStorageKey.lower(key)
				)
			},
			pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
			completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
			freeFunc: ffi_sargon_uniffi_rust_future_free_void,
			liftFunc: { $0 },
			errorHandler: FfiConverterTypeCommonError.lift
		)
	}
}

// MARK: - UniffiCallbackInterfaceUnsafeStorageDriver
// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceUnsafeStorageDriver {
	// Create the VTable using a series of closures.
	// Swift automatically converts these into C callback functions.
	static var vtable: UniffiVTableCallbackInterfaceUnsafeStorageDriver = .init(
		loadData: { (
			uniffiHandle: UInt64,
			key: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws -> BagOfBytes? in
				guard let uniffiObj = try? FfiConverterTypeUnsafeStorageDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.loadData(
					key: FfiConverterTypeUnsafeStorageKey.lift(key)
				)
			}

			let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructRustBuffer(
						returnValue: RustBuffer.empty(),
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		saveData: { (
			uniffiHandle: UInt64,
			key: RustBuffer,
			data: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws in
				guard let uniffiObj = try? FfiConverterTypeUnsafeStorageDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.saveData(
					key: FfiConverterTypeUnsafeStorageKey.lift(key),
					data: FfiConverterTypeBagOfBytes.lift(data)
				)
			}

			let uniffiHandleSuccess = { (_: ()) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		deleteDataForKey: { (
			uniffiHandle: UInt64,
			key: RustBuffer,
			uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
			uniffiCallbackData: UInt64,
			uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
		) in
			let makeCall = {
				() async throws in
				guard let uniffiObj = try? FfiConverterTypeUnsafeStorageDriver.handleMap.get(handle: uniffiHandle) else {
					throw UniffiInternalError.unexpectedStaleHandle
				}
				return try await uniffiObj.deleteDataForKey(
					key: FfiConverterTypeUnsafeStorageKey.lift(key)
				)
			}

			let uniffiHandleSuccess = { (_: ()) in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus()
					)
				)
			}
			let uniffiHandleError = { statusCode, errorBuf in
				uniffiFutureCallback(
					uniffiCallbackData,
					UniffiForeignFutureStructVoid(
						callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
					)
				)
			}
			let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
				makeCall: makeCall,
				handleSuccess: uniffiHandleSuccess,
				handleError: uniffiHandleError,
				lowerError: FfiConverterTypeCommonError.lower
			)
			uniffiOutReturn.pointee = uniffiForeignFuture
		},
		uniffiFree: { (uniffiHandle: UInt64) in
			let result = try? FfiConverterTypeUnsafeStorageDriver.handleMap.remove(handle: uniffiHandle)
			if result == nil {
				print("Uniffi callback interface UnsafeStorageDriver: handle missing in uniffiFree")
			}
		}
	)
}

private func uniffiCallbackInitUnsafeStorageDriver() {
	uniffi_sargon_uniffi_fn_init_callback_vtable_unsafestoragedriver(&UniffiCallbackInterfaceUnsafeStorageDriver.vtable)
}

// MARK: - FfiConverterTypeUnsafeStorageDriver
public struct FfiConverterTypeUnsafeStorageDriver: FfiConverter {
	fileprivate static var handleMap = UniffiHandleMap<UnsafeStorageDriver>()

	typealias FfiType = UnsafeMutableRawPointer
	typealias SwiftType = UnsafeStorageDriver

	public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsafeStorageDriver {
		UnsafeStorageDriverImpl(unsafeFromRawPointer: pointer)
	}

	public static func lower(_ value: UnsafeStorageDriver) -> UnsafeMutableRawPointer {
		guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
			fatalError("Cast to UnsafeMutableRawPointer failed")
		}
		return ptr
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsafeStorageDriver {
		let v: UInt64 = try readInt(&buf)
		// The Rust code won't compile if a pointer won't fit in a UInt64.
		// We have to go via `UInt` because that's the thing that's the size of a pointer.
		let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
		if ptr == nil {
			throw UniffiInternalError.unexpectedNullPointer
		}
		return try lift(ptr!)
	}

	public static func write(_ value: UnsafeStorageDriver, into buf: inout [UInt8]) {
		// This fiddling is because `Int` is the thing that's the same size as a pointer.
		// The Rust code won't compile if a pointer won't fit in a `UInt64`.
		writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
	}
}

public func FfiConverterTypeUnsafeStorageDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsafeStorageDriver {
	try FfiConverterTypeUnsafeStorageDriver.lift(pointer)
}

public func FfiConverterTypeUnsafeStorageDriver_lower(_ value: UnsafeStorageDriver) -> UnsafeMutableRawPointer {
	FfiConverterTypeUnsafeStorageDriver.lower(value)
}

// MARK: - AccessControllerAddress
/**
 * Address to an AccessController that controls an Account or Identity (Persona),
 * it said entity has been "securified", e.g.:
 * `"accesscontroller_rdx1c0duj4lq0dc3cpl8qd420fpn5eckh8ljeysvjm894lyl5ja5yq6y5a"`
 *
 * When a user applies a SecurityStructureConfiguration for the first time on a
 * non-securified entity (and signs and submit the resulting TX) said entity is
 * "assigned" an AccessControllerAddress by the network.
 *
 * An `AccessControllerAddress` has the [Scrypto's `EntityType`][entt] `GlobalAccessController`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalAccessControllerAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L247-L248
 */
public struct AccessControllerAddress {
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension AccessControllerAddress: Sendable {}

// MARK: Equatable, Hashable
extension AccessControllerAddress: Equatable, Hashable {
	public static func == (lhs: AccessControllerAddress, rhs: AccessControllerAddress) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeAccessControllerAddress
public struct FfiConverterTypeAccessControllerAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccessControllerAddress {
		try AccessControllerAddress(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: AccessControllerAddress, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeAccessControllerAddress_lift(_ buf: RustBuffer) throws -> AccessControllerAddress {
	try FfiConverterTypeAccessControllerAddress.lift(buf)
}

public func FfiConverterTypeAccessControllerAddress_lower(_ value: AccessControllerAddress) -> RustBuffer {
	FfiConverterTypeAccessControllerAddress.lower(value)
}

// MARK: - Account
/**
 * A network unique account with a unique public address and a set of cryptographic
 * factors used to control it.
 *
 * Used to own and control assets on the radix network. Uniquely identified by an
 * account address, e.g.
 *
 * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
 *
 * But most commonly users see the address on its abbreviated form:
 *
 * `acco...nvjdwr`
 *
 * Accounts have a display name and an appearance id.
 *
 * An account can be either controlled by a "Babylon" DeviceFactorSource or a
 * Legacy one imported from Olympia, or a Ledger hardware wallet, which too might
 * have been imported from Olympia.
 */
public struct Account {
	/**
	 * The ID of the network this account can be used with.
	 */
	public var networkId: NetworkId
	/**
	 * A globally unique identifier of this account, being a human readable
	 * address of an account. Always starts with `"account_"``, for example:
	 *
	 * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
	 *
	 * Most commonly the user will see this address in its abbreviated
	 * form which is:
	 *
	 * `acco...nvjdwr`
	 *
	 * No two addresses will ever be the same even for the same factor source
	 * but on different networks, since the public keys controlling the
	 * accounts depend on the network id.
	 */
	public var address: AccountAddress
	/**
	 * An off-ledger display name or description chosen by the user when she
	 * created this account.
	 */
	public var displayName: DisplayName
	/**
	 * Security state of this account, either "securified" or not.
	 */
	public var securityState: EntitySecurityState
	/**
	 * The visual cue user learns to associated this account with, typically
	 * a beautiful colorful gradient.
	 */
	public var appearanceId: AppearanceId
	/**
	 * An order set of `EntityFlag`s used to describe certain Off-ledger
	 * user state about Accounts or Personas, such as if an entity is
	 * marked as hidden or not.
	 */
	public var flags: [EntityFlag]
	/**
	 * The on ledger synced settings for this account, contains e.g.
	 * ThirdPartyDeposit settings, with deposit rules for assets.
	 */
	public var onLedgerSettings: OnLedgerSettings

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The ID of the network this account can be used with.
		 */ networkId: NetworkId,
		/**
			* A globally unique identifier of this account, being a human readable
			* address of an account. Always starts with `"account_"``, for example:
			*
			* `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
			*
			* Most commonly the user will see this address in its abbreviated
			* form which is:
			*
			* `acco...nvjdwr`
			*
			* No two addresses will ever be the same even for the same factor source
			* but on different networks, since the public keys controlling the
			* accounts depend on the network id.
			*/ address: AccountAddress,
		/**
			* An off-ledger display name or description chosen by the user when she
			* created this account.
			*/ displayName: DisplayName,
		/**
			* Security state of this account, either "securified" or not.
			*/ securityState: EntitySecurityState,
		/**
			* The visual cue user learns to associated this account with, typically
			* a beautiful colorful gradient.
			*/ appearanceId: AppearanceId,
		/**
			* An order set of `EntityFlag`s used to describe certain Off-ledger
			* user state about Accounts or Personas, such as if an entity is
			* marked as hidden or not.
			*/ flags: [EntityFlag],
		/**
			* The on ledger synced settings for this account, contains e.g.
			* ThirdPartyDeposit settings, with deposit rules for assets.
			*/ onLedgerSettings: OnLedgerSettings
	) {
		self.networkId = networkId
		self.address = address
		self.displayName = displayName
		self.securityState = securityState
		self.appearanceId = appearanceId
		self.flags = flags
		self.onLedgerSettings = onLedgerSettings
	}
}

// MARK: Sendable
extension Account: Sendable {}

// MARK: Equatable, Hashable
extension Account: Equatable, Hashable {
	public static func == (lhs: Account, rhs: Account) -> Bool {
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.address != rhs.address {
			return false
		}
		if lhs.displayName != rhs.displayName {
			return false
		}
		if lhs.securityState != rhs.securityState {
			return false
		}
		if lhs.appearanceId != rhs.appearanceId {
			return false
		}
		if lhs.flags != rhs.flags {
			return false
		}
		if lhs.onLedgerSettings != rhs.onLedgerSettings {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(networkId)
		hasher.combine(address)
		hasher.combine(displayName)
		hasher.combine(securityState)
		hasher.combine(appearanceId)
		hasher.combine(flags)
		hasher.combine(onLedgerSettings)
	}
}

// MARK: - FfiConverterTypeAccount
public struct FfiConverterTypeAccount: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Account {
		try Account(
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			address: FfiConverterTypeAccountAddress.read(from: &buf),
			displayName: FfiConverterTypeDisplayName.read(from: &buf),
			securityState: FfiConverterTypeEntitySecurityState.read(from: &buf),
			appearanceId: FfiConverterTypeAppearanceID.read(from: &buf),
			flags: FfiConverterSequenceTypeEntityFlag.read(from: &buf),
			onLedgerSettings: FfiConverterTypeOnLedgerSettings.read(from: &buf)
		)
	}

	public static func write(_ value: Account, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeAccountAddress.write(value.address, into: &buf)
		FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
		FfiConverterTypeEntitySecurityState.write(value.securityState, into: &buf)
		FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
		FfiConverterSequenceTypeEntityFlag.write(value.flags, into: &buf)
		FfiConverterTypeOnLedgerSettings.write(value.onLedgerSettings, into: &buf)
	}
}

public func FfiConverterTypeAccount_lift(_ buf: RustBuffer) throws -> Account {
	try FfiConverterTypeAccount.lift(buf)
}

public func FfiConverterTypeAccount_lower(_ value: Account) -> RustBuffer {
	FfiConverterTypeAccount.lower(value)
}

// MARK: - AccountAddress
/**
 * Human readable address of an account. Always starts with `"account_"``, for example:
 *
 * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
 *
 * Most commonly the user will see this address in its abbreviated
 * form which is:
 *
 * `acco...nvjdwr`
 *
 * Addresses are checksummed, as per Bech32. **Only** *Account* addresses starts with
 * the prefix `account_`.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of AccountAddresses:
 * * GlobalAccount
 * * GlobalVirtualSecp256k1Account
 * * GlobalVirtualEd25519Account
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalAccountAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L224-L228
 */
public struct AccountAddress {
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension AccountAddress: Sendable {}

// MARK: Equatable, Hashable
extension AccountAddress: Equatable, Hashable {
	public static func == (lhs: AccountAddress, rhs: AccountAddress) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeAccountAddress
public struct FfiConverterTypeAccountAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountAddress {
		try AccountAddress(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: AccountAddress, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeAccountAddress_lift(_ buf: RustBuffer) throws -> AccountAddress {
	try FfiConverterTypeAccountAddress.lift(buf)
}

public func FfiConverterTypeAccountAddress_lower(_ value: AccountAddress) -> RustBuffer {
	FfiConverterTypeAccountAddress.lower(value)
}

// MARK: - AccountDeposits
/**
 * Represents an account deposit, which includes specified and unspecified resources.
 */
public struct AccountDeposits {
	public var specifiedResources: [SimpleResourceBounds]
	public var unspecifiedResources: UnspecifiedResources

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(specifiedResources: [SimpleResourceBounds], unspecifiedResources: UnspecifiedResources) {
		self.specifiedResources = specifiedResources
		self.unspecifiedResources = unspecifiedResources
	}
}

// MARK: Sendable
extension AccountDeposits: Sendable {}

// MARK: Equatable, Hashable
extension AccountDeposits: Equatable, Hashable {
	public static func == (lhs: AccountDeposits, rhs: AccountDeposits) -> Bool {
		if lhs.specifiedResources != rhs.specifiedResources {
			return false
		}
		if lhs.unspecifiedResources != rhs.unspecifiedResources {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(specifiedResources)
		hasher.combine(unspecifiedResources)
	}
}

// MARK: - FfiConverterTypeAccountDeposits
public struct FfiConverterTypeAccountDeposits: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountDeposits {
		try AccountDeposits(
			specifiedResources: FfiConverterSequenceTypeSimpleResourceBounds.read(from: &buf),
			unspecifiedResources: FfiConverterTypeUnspecifiedResources.read(from: &buf)
		)
	}

	public static func write(_ value: AccountDeposits, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeSimpleResourceBounds.write(value.specifiedResources, into: &buf)
		FfiConverterTypeUnspecifiedResources.write(value.unspecifiedResources, into: &buf)
	}
}

public func FfiConverterTypeAccountDeposits_lift(_ buf: RustBuffer) throws -> AccountDeposits {
	try FfiConverterTypeAccountDeposits.lift(buf)
}

public func FfiConverterTypeAccountDeposits_lower(_ value: AccountDeposits) -> RustBuffer {
	FfiConverterTypeAccountDeposits.lower(value)
}

// MARK: - AccountForDisplay
/**
 * A minimal version of an [`Account`] meant for
 * display purposes within wallet
 */
public struct AccountForDisplay {
	public var address: AccountAddress
	public var displayName: DisplayName
	public var appearanceId: AppearanceId

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(address: AccountAddress, displayName: DisplayName, appearanceId: AppearanceId) {
		self.address = address
		self.displayName = displayName
		self.appearanceId = appearanceId
	}
}

// MARK: Sendable
extension AccountForDisplay: Sendable {}

// MARK: Equatable, Hashable
extension AccountForDisplay: Equatable, Hashable {
	public static func == (lhs: AccountForDisplay, rhs: AccountForDisplay) -> Bool {
		if lhs.address != rhs.address {
			return false
		}
		if lhs.displayName != rhs.displayName {
			return false
		}
		if lhs.appearanceId != rhs.appearanceId {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(address)
		hasher.combine(displayName)
		hasher.combine(appearanceId)
	}
}

// MARK: - FfiConverterTypeAccountForDisplay
public struct FfiConverterTypeAccountForDisplay: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountForDisplay {
		try AccountForDisplay(
			address: FfiConverterTypeAccountAddress.read(from: &buf),
			displayName: FfiConverterTypeDisplayName.read(from: &buf),
			appearanceId: FfiConverterTypeAppearanceID.read(from: &buf)
		)
	}

	public static func write(_ value: AccountForDisplay, into buf: inout [UInt8]) {
		FfiConverterTypeAccountAddress.write(value.address, into: &buf)
		FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
		FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
	}
}

public func FfiConverterTypeAccountForDisplay_lift(_ buf: RustBuffer) throws -> AccountForDisplay {
	try FfiConverterTypeAccountForDisplay.lift(buf)
}

public func FfiConverterTypeAccountForDisplay_lower(_ value: AccountForDisplay) -> RustBuffer {
	FfiConverterTypeAccountForDisplay.lower(value)
}

// MARK: - AccountPath
public struct AccountPath {
	public var networkId: NetworkId
	public var keyKind: Cap26KeyKind
	public var index: Hardened

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(networkId: NetworkId, keyKind: Cap26KeyKind, index: Hardened) {
		self.networkId = networkId
		self.keyKind = keyKind
		self.index = index
	}
}

// MARK: Sendable
extension AccountPath: Sendable {}

// MARK: Equatable, Hashable
extension AccountPath: Equatable, Hashable {
	public static func == (lhs: AccountPath, rhs: AccountPath) -> Bool {
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.keyKind != rhs.keyKind {
			return false
		}
		if lhs.index != rhs.index {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(networkId)
		hasher.combine(keyKind)
		hasher.combine(index)
	}
}

// MARK: - FfiConverterTypeAccountPath
public struct FfiConverterTypeAccountPath: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountPath {
		try AccountPath(
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			keyKind: FfiConverterTypeCAP26KeyKind.read(from: &buf),
			index: FfiConverterTypeHardened.read(from: &buf)
		)
	}

	public static func write(_ value: AccountPath, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeCAP26KeyKind.write(value.keyKind, into: &buf)
		FfiConverterTypeHardened.write(value.index, into: &buf)
	}
}

public func FfiConverterTypeAccountPath_lift(_ buf: RustBuffer) throws -> AccountPath {
	try FfiConverterTypeAccountPath.lift(buf)
}

public func FfiConverterTypeAccountPath_lower(_ value: AccountPath) -> RustBuffer {
	FfiConverterTypeAccountPath.lower(value)
}

// MARK: - AesGcm256
/**
 * AES GCM 256 encryption
 */
public struct AesGcm256 {
	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init() {}
}

// MARK: Sendable
extension AesGcm256: Sendable {}

// MARK: Equatable, Hashable
extension AesGcm256: Equatable, Hashable {
	public static func == (lhs: AesGcm256, rhs: AesGcm256) -> Bool {
		true
	}

	public func hash(into hasher: inout Hasher) {}
}

// MARK: - FfiConverterTypeAesGcm256
public struct FfiConverterTypeAesGcm256: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesGcm256 {
		AesGcm256()
	}

	public static func write(_ value: AesGcm256, into buf: inout [UInt8]) {}
}

public func FfiConverterTypeAesGcm256_lift(_ buf: RustBuffer) throws -> AesGcm256 {
	try FfiConverterTypeAesGcm256.lift(buf)
}

public func FfiConverterTypeAesGcm256_lower(_ value: AesGcm256) -> RustBuffer {
	FfiConverterTypeAesGcm256.lower(value)
}

// MARK: - AppDisplay
/**
 * Settings related to displaying of information to the user inside the app.
 *
 * **N.B. neither of these settings are in fact not yet used by clients.**
 */
public struct AppDisplay {
	/**
	 * If we should show the aggregate value of users portfolio in fiat currency
	 * of hide it.
	 */
	public var isCurrencyAmountVisible: Bool
	/**
	 * Which fiat currency the prices are measured in.
	 */
	public var fiatCurrencyPriceTarget: FiatCurrency

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * If we should show the aggregate value of users portfolio in fiat currency
		 * of hide it.
		 */ isCurrencyAmountVisible: Bool,
		/**
			* Which fiat currency the prices are measured in.
			*/ fiatCurrencyPriceTarget: FiatCurrency
	) {
		self.isCurrencyAmountVisible = isCurrencyAmountVisible
		self.fiatCurrencyPriceTarget = fiatCurrencyPriceTarget
	}
}

// MARK: Sendable
extension AppDisplay: Sendable {}

// MARK: Equatable, Hashable
extension AppDisplay: Equatable, Hashable {
	public static func == (lhs: AppDisplay, rhs: AppDisplay) -> Bool {
		if lhs.isCurrencyAmountVisible != rhs.isCurrencyAmountVisible {
			return false
		}
		if lhs.fiatCurrencyPriceTarget != rhs.fiatCurrencyPriceTarget {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(isCurrencyAmountVisible)
		hasher.combine(fiatCurrencyPriceTarget)
	}
}

// MARK: - FfiConverterTypeAppDisplay
public struct FfiConverterTypeAppDisplay: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppDisplay {
		try AppDisplay(
			isCurrencyAmountVisible: FfiConverterBool.read(from: &buf),
			fiatCurrencyPriceTarget: FfiConverterTypeFiatCurrency.read(from: &buf)
		)
	}

	public static func write(_ value: AppDisplay, into buf: inout [UInt8]) {
		FfiConverterBool.write(value.isCurrencyAmountVisible, into: &buf)
		FfiConverterTypeFiatCurrency.write(value.fiatCurrencyPriceTarget, into: &buf)
	}
}

public func FfiConverterTypeAppDisplay_lift(_ buf: RustBuffer) throws -> AppDisplay {
	try FfiConverterTypeAppDisplay.lift(buf)
}

public func FfiConverterTypeAppDisplay_lower(_ value: AppDisplay) -> RustBuffer {
	FfiConverterTypeAppDisplay.lower(value)
}

// MARK: - AppPreferences
/**
 * Collection of all settings, preferences and configuration related to how the wallet
 * behaves and looks.
 *
 * Current and other saved Gateways, security settings,
 * App Display settings and preferences for transaction.
 */
public struct AppPreferences {
	/**
	 * Display settings in the wallet app, such as appearances, currency etc.
	 */
	public var display: AppDisplay
	/**
	 * The gateway of the active network and collection of other saved gateways.
	 */
	public var gateways: SavedGateways
	/**
	 * Controls e.g. if Profile Snapshot gets synced to iCloud/Google backup or not.
	 */
	public var security: Security
	/**
	 * Default config related to making of transactions
	 */
	public var transaction: TransactionPreferences

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Display settings in the wallet app, such as appearances, currency etc.
		 */ display: AppDisplay,
		/**
			* The gateway of the active network and collection of other saved gateways.
			*/ gateways: SavedGateways,
		/**
			* Controls e.g. if Profile Snapshot gets synced to iCloud/Google backup or not.
			*/ security: Security,
		/**
			* Default config related to making of transactions
			*/ transaction: TransactionPreferences
	) {
		self.display = display
		self.gateways = gateways
		self.security = security
		self.transaction = transaction
	}
}

// MARK: Sendable
extension AppPreferences: Sendable {}

// MARK: Equatable, Hashable
extension AppPreferences: Equatable, Hashable {
	public static func == (lhs: AppPreferences, rhs: AppPreferences) -> Bool {
		if lhs.display != rhs.display {
			return false
		}
		if lhs.gateways != rhs.gateways {
			return false
		}
		if lhs.security != rhs.security {
			return false
		}
		if lhs.transaction != rhs.transaction {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(display)
		hasher.combine(gateways)
		hasher.combine(security)
		hasher.combine(transaction)
	}
}

// MARK: - FfiConverterTypeAppPreferences
public struct FfiConverterTypeAppPreferences: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppPreferences {
		try AppPreferences(
			display: FfiConverterTypeAppDisplay.read(from: &buf),
			gateways: FfiConverterTypeSavedGateways.read(from: &buf),
			security: FfiConverterTypeSecurity.read(from: &buf),
			transaction: FfiConverterTypeTransactionPreferences.read(from: &buf)
		)
	}

	public static func write(_ value: AppPreferences, into buf: inout [UInt8]) {
		FfiConverterTypeAppDisplay.write(value.display, into: &buf)
		FfiConverterTypeSavedGateways.write(value.gateways, into: &buf)
		FfiConverterTypeSecurity.write(value.security, into: &buf)
		FfiConverterTypeTransactionPreferences.write(value.transaction, into: &buf)
	}
}

public func FfiConverterTypeAppPreferences_lift(_ buf: RustBuffer) throws -> AppPreferences {
	try FfiConverterTypeAppPreferences.lift(buf)
}

public func FfiConverterTypeAppPreferences_lower(_ value: AppPreferences) -> RustBuffer {
	FfiConverterTypeAppPreferences.lower(value)
}

// MARK: - AppearanceId
public struct AppearanceId {
	public var value: UInt8

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: UInt8) {
		self.value = value
	}
}

// MARK: Sendable
extension AppearanceId: Sendable {}

// MARK: Equatable, Hashable
extension AppearanceId: Equatable, Hashable {
	public static func == (lhs: AppearanceId, rhs: AppearanceId) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeAppearanceID
public struct FfiConverterTypeAppearanceID: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppearanceId {
		try AppearanceId(
			value: FfiConverterUInt8.read(from: &buf)
		)
	}

	public static func write(_ value: AppearanceId, into buf: inout [UInt8]) {
		FfiConverterUInt8.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeAppearanceID_lift(_ buf: RustBuffer) throws -> AppearanceId {
	try FfiConverterTypeAppearanceID.lift(buf)
}

public func FfiConverterTypeAppearanceID_lower(_ value: AppearanceId) -> RustBuffer {
	FfiConverterTypeAppearanceID.lower(value)
}

// MARK: - ArculusCardFactorSource
/**
 * An Arculus card, a hierarchal deterministic wallet capable of CAP26 derivation
 * which users interact with by placing it near their host device, which
 * communicates with the card over NFC.
 */
public struct ArculusCardFactorSource {
	/**
	 * Unique and stable identifier of this factor source, stemming from the
	 * hash of a special child key of the HD root of the mnemonic,
	 * that is secured by the Arculus Card.
	 */
	public var id: FactorSourceIdFromHash
	/**
	 * Common properties shared between FactorSources of different kinds,
	 * describing its state, when added, and supported cryptographic parameters.
	 */
	public var common: FactorSourceCommon
	/**
	 * Properties describing a ArculusCardFactorSource to help user disambiguate
	 * between it and another one.
	 */
	public var hint: ArculusCardHint

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Unique and stable identifier of this factor source, stemming from the
		 * hash of a special child key of the HD root of the mnemonic,
		 * that is secured by the Arculus Card.
		 */ id: FactorSourceIdFromHash,
		/**
			* Common properties shared between FactorSources of different kinds,
			* describing its state, when added, and supported cryptographic parameters.
			*/ common: FactorSourceCommon,
		/**
			* Properties describing a ArculusCardFactorSource to help user disambiguate
			* between it and another one.
			*/ hint: ArculusCardHint
	) {
		self.id = id
		self.common = common
		self.hint = hint
	}
}

// MARK: Sendable
extension ArculusCardFactorSource: Sendable {}

// MARK: Equatable, Hashable
extension ArculusCardFactorSource: Equatable, Hashable {
	public static func == (lhs: ArculusCardFactorSource, rhs: ArculusCardFactorSource) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.common != rhs.common {
			return false
		}
		if lhs.hint != rhs.hint {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(common)
		hasher.combine(hint)
	}
}

// MARK: - FfiConverterTypeArculusCardFactorSource
public struct FfiConverterTypeArculusCardFactorSource: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCardFactorSource {
		try ArculusCardFactorSource(
			id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
			common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
			hint: FfiConverterTypeArculusCardHint.read(from: &buf)
		)
	}

	public static func write(_ value: ArculusCardFactorSource, into buf: inout [UInt8]) {
		FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
		FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
		FfiConverterTypeArculusCardHint.write(value.hint, into: &buf)
	}
}

public func FfiConverterTypeArculusCardFactorSource_lift(_ buf: RustBuffer) throws -> ArculusCardFactorSource {
	try FfiConverterTypeArculusCardFactorSource.lift(buf)
}

public func FfiConverterTypeArculusCardFactorSource_lower(_ value: ArculusCardFactorSource) -> RustBuffer {
	FfiConverterTypeArculusCardFactorSource.lower(value)
}

// MARK: - ArculusCardHint
public struct ArculusCardHint {
	/**
	 * E.g. "Black" or "Silver"
	 */
	public var name: String
	public var model: ArculusCardModel

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * E.g. "Black" or "Silver"
		 */ name: String, model: ArculusCardModel
	) {
		self.name = name
		self.model = model
	}
}

// MARK: Sendable
extension ArculusCardHint: Sendable {}

// MARK: Equatable, Hashable
extension ArculusCardHint: Equatable, Hashable {
	public static func == (lhs: ArculusCardHint, rhs: ArculusCardHint) -> Bool {
		if lhs.name != rhs.name {
			return false
		}
		if lhs.model != rhs.model {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(name)
		hasher.combine(model)
	}
}

// MARK: - FfiConverterTypeArculusCardHint
public struct FfiConverterTypeArculusCardHint: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCardHint {
		try ArculusCardHint(
			name: FfiConverterString.read(from: &buf),
			model: FfiConverterTypeArculusCardModel.read(from: &buf)
		)
	}

	public static func write(_ value: ArculusCardHint, into buf: inout [UInt8]) {
		FfiConverterString.write(value.name, into: &buf)
		FfiConverterTypeArculusCardModel.write(value.model, into: &buf)
	}
}

public func FfiConverterTypeArculusCardHint_lift(_ buf: RustBuffer) throws -> ArculusCardHint {
	try FfiConverterTypeArculusCardHint.lift(buf)
}

public func FfiConverterTypeArculusCardHint_lower(_ value: ArculusCardHint) -> RustBuffer {
	FfiConverterTypeArculusCardHint.lower(value)
}

// MARK: - AssetException
/**
 * The specific Asset exception rule, which overrides the general
 * `deposit_rule` of a `ThirdPartyDeposits` settings.
 */
public struct AssetException {
	/**
	 * Address of an asset to either deny or allow, as an exception overriding the `ThirdPartyDeposits`'s general `deposit_rule`.
	 */
	public var address: ResourceAddress
	/**
	 * Either deny or allow the `address`.
	 */
	public var exceptionRule: DepositAddressExceptionRule

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Address of an asset to either deny or allow, as an exception overriding the `ThirdPartyDeposits`'s general `deposit_rule`.
		 */ address: ResourceAddress,
		/**
			* Either deny or allow the `address`.
			*/ exceptionRule: DepositAddressExceptionRule
	) {
		self.address = address
		self.exceptionRule = exceptionRule
	}
}

// MARK: Sendable
extension AssetException: Sendable {}

// MARK: Equatable, Hashable
extension AssetException: Equatable, Hashable {
	public static func == (lhs: AssetException, rhs: AssetException) -> Bool {
		if lhs.address != rhs.address {
			return false
		}
		if lhs.exceptionRule != rhs.exceptionRule {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(address)
		hasher.combine(exceptionRule)
	}
}

// MARK: - FfiConverterTypeAssetException
public struct FfiConverterTypeAssetException: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetException {
		try AssetException(
			address: FfiConverterTypeResourceAddress.read(from: &buf),
			exceptionRule: FfiConverterTypeDepositAddressExceptionRule.read(from: &buf)
		)
	}

	public static func write(_ value: AssetException, into buf: inout [UInt8]) {
		FfiConverterTypeResourceAddress.write(value.address, into: &buf)
		FfiConverterTypeDepositAddressExceptionRule.write(value.exceptionRule, into: &buf)
	}
}

public func FfiConverterTypeAssetException_lift(_ buf: RustBuffer) throws -> AssetException {
	try FfiConverterTypeAssetException.lift(buf)
}

public func FfiConverterTypeAssetException_lower(_ value: AssetException) -> RustBuffer {
	FfiConverterTypeAssetException.lower(value)
}

// MARK: - AuthorizedDapp
/**
 * A connection made between a Radix Dapp and the user.
 */
public struct AuthorizedDapp {
	/**
	 * The ID of the network the authorized Dapp is on.
	 */
	public var networkId: NetworkId
	/**
	 * A `DappDefinitionAddress` is in fact just an alias for
	 * [`AccountAddress`], it is the address of the account
	 * which owns controls the Dapp.
	 */
	public var dappDefinitionAddress: AccountAddress
	/**
	 * The Display name as sent by the Dapp in any interaction
	 * request (CAP21), e.g. "Radix Dashboard".
	 */
	public var displayName: String?
	/**
	 * An order set of `AuthorizedPersonaSimple`s, which is a collection of all
	 * the Personas the user has used to interact with this Dapp, it is called
	 * "references to", since the Personas are not stored in full, that would be
	 * bad duplication of data (which might go stale), instead we refer to the
	 * necessary data by IDs.
	 */
	public var referencesToAuthorizedPersonas: [AuthorizedPersonaSimple]
	/**
	 * The preferences the user has configured for this Dapp.
	 */
	public var preferences: AuthorizedDappPreferences

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The ID of the network the authorized Dapp is on.
		 */ networkId: NetworkId,
		/**
			* A `DappDefinitionAddress` is in fact just an alias for
			* [`AccountAddress`], it is the address of the account
			* which owns controls the Dapp.
			*/ dappDefinitionAddress: AccountAddress,
		/**
			* The Display name as sent by the Dapp in any interaction
			* request (CAP21), e.g. "Radix Dashboard".
			*/ displayName: String?,
		/**
			* An order set of `AuthorizedPersonaSimple`s, which is a collection of all
			* the Personas the user has used to interact with this Dapp, it is called
			* "references to", since the Personas are not stored in full, that would be
			* bad duplication of data (which might go stale), instead we refer to the
			* necessary data by IDs.
			*/ referencesToAuthorizedPersonas: [AuthorizedPersonaSimple],
		/**
			* The preferences the user has configured for this Dapp.
			*/ preferences: AuthorizedDappPreferences
	) {
		self.networkId = networkId
		self.dappDefinitionAddress = dappDefinitionAddress
		self.displayName = displayName
		self.referencesToAuthorizedPersonas = referencesToAuthorizedPersonas
		self.preferences = preferences
	}
}

// MARK: Sendable
extension AuthorizedDapp: Sendable {}

// MARK: Equatable, Hashable
extension AuthorizedDapp: Equatable, Hashable {
	public static func == (lhs: AuthorizedDapp, rhs: AuthorizedDapp) -> Bool {
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
			return false
		}
		if lhs.displayName != rhs.displayName {
			return false
		}
		if lhs.referencesToAuthorizedPersonas != rhs.referencesToAuthorizedPersonas {
			return false
		}
		if lhs.preferences != rhs.preferences {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(networkId)
		hasher.combine(dappDefinitionAddress)
		hasher.combine(displayName)
		hasher.combine(referencesToAuthorizedPersonas)
		hasher.combine(preferences)
	}
}

// MARK: - FfiConverterTypeAuthorizedDapp
public struct FfiConverterTypeAuthorizedDapp: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDapp {
		try AuthorizedDapp(
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf),
			displayName: FfiConverterOptionString.read(from: &buf),
			referencesToAuthorizedPersonas: FfiConverterSequenceTypeAuthorizedPersonaSimple.read(from: &buf),
			preferences: FfiConverterTypeAuthorizedDappPreferences.read(from: &buf)
		)
	}

	public static func write(_ value: AuthorizedDapp, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
		FfiConverterOptionString.write(value.displayName, into: &buf)
		FfiConverterSequenceTypeAuthorizedPersonaSimple.write(value.referencesToAuthorizedPersonas, into: &buf)
		FfiConverterTypeAuthorizedDappPreferences.write(value.preferences, into: &buf)
	}
}

public func FfiConverterTypeAuthorizedDapp_lift(_ buf: RustBuffer) throws -> AuthorizedDapp {
	try FfiConverterTypeAuthorizedDapp.lift(buf)
}

public func FfiConverterTypeAuthorizedDapp_lower(_ value: AuthorizedDapp) -> RustBuffer {
	FfiConverterTypeAuthorizedDapp.lower(value)
}

// MARK: - AuthorizedDappDetailed
public struct AuthorizedDappDetailed {
	public var networkId: NetworkId
	public var dappDefinitionAddress: AccountAddress
	public var displayName: DisplayName?
	public var detailedAuthorizedPersonas: [AuthorizedPersonaDetailed]
	public var preferences: AuthorizedDappPreferences

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(networkId: NetworkId, dappDefinitionAddress: AccountAddress, displayName: DisplayName?, detailedAuthorizedPersonas: [AuthorizedPersonaDetailed], preferences: AuthorizedDappPreferences) {
		self.networkId = networkId
		self.dappDefinitionAddress = dappDefinitionAddress
		self.displayName = displayName
		self.detailedAuthorizedPersonas = detailedAuthorizedPersonas
		self.preferences = preferences
	}
}

// MARK: Sendable
extension AuthorizedDappDetailed: Sendable {}

// MARK: Equatable, Hashable
extension AuthorizedDappDetailed: Equatable, Hashable {
	public static func == (lhs: AuthorizedDappDetailed, rhs: AuthorizedDappDetailed) -> Bool {
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
			return false
		}
		if lhs.displayName != rhs.displayName {
			return false
		}
		if lhs.detailedAuthorizedPersonas != rhs.detailedAuthorizedPersonas {
			return false
		}
		if lhs.preferences != rhs.preferences {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(networkId)
		hasher.combine(dappDefinitionAddress)
		hasher.combine(displayName)
		hasher.combine(detailedAuthorizedPersonas)
		hasher.combine(preferences)
	}
}

// MARK: - FfiConverterTypeAuthorizedDappDetailed
public struct FfiConverterTypeAuthorizedDappDetailed: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappDetailed {
		try AuthorizedDappDetailed(
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf),
			displayName: FfiConverterOptionTypeDisplayName.read(from: &buf),
			detailedAuthorizedPersonas: FfiConverterSequenceTypeAuthorizedPersonaDetailed.read(from: &buf),
			preferences: FfiConverterTypeAuthorizedDappPreferences.read(from: &buf)
		)
	}

	public static func write(_ value: AuthorizedDappDetailed, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
		FfiConverterOptionTypeDisplayName.write(value.displayName, into: &buf)
		FfiConverterSequenceTypeAuthorizedPersonaDetailed.write(value.detailedAuthorizedPersonas, into: &buf)
		FfiConverterTypeAuthorizedDappPreferences.write(value.preferences, into: &buf)
	}
}

public func FfiConverterTypeAuthorizedDappDetailed_lift(_ buf: RustBuffer) throws -> AuthorizedDappDetailed {
	try FfiConverterTypeAuthorizedDappDetailed.lift(buf)
}

public func FfiConverterTypeAuthorizedDappDetailed_lower(_ value: AuthorizedDappDetailed) -> RustBuffer {
	FfiConverterTypeAuthorizedDappDetailed.lower(value)
}

// MARK: - AuthorizedDappPreferences
/**
 * The preferences the user has configured off-ledger for a given `AuthorizedDapp`.
 * Allows users, for example, to hide direct deposit claims for a given Dapp.
 */
public struct AuthorizedDappPreferences {
	public var deposits: AuthorizedDappPreferenceDeposits

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(deposits: AuthorizedDappPreferenceDeposits) {
		self.deposits = deposits
	}
}

// MARK: Sendable
extension AuthorizedDappPreferences: Sendable {}

// MARK: Equatable, Hashable
extension AuthorizedDappPreferences: Equatable, Hashable {
	public static func == (lhs: AuthorizedDappPreferences, rhs: AuthorizedDappPreferences) -> Bool {
		if lhs.deposits != rhs.deposits {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(deposits)
	}
}

// MARK: - FfiConverterTypeAuthorizedDappPreferences
public struct FfiConverterTypeAuthorizedDappPreferences: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappPreferences {
		try AuthorizedDappPreferences(
			deposits: FfiConverterTypeAuthorizedDappPreferenceDeposits.read(from: &buf)
		)
	}

	public static func write(_ value: AuthorizedDappPreferences, into buf: inout [UInt8]) {
		FfiConverterTypeAuthorizedDappPreferenceDeposits.write(value.deposits, into: &buf)
	}
}

public func FfiConverterTypeAuthorizedDappPreferences_lift(_ buf: RustBuffer) throws -> AuthorizedDappPreferences {
	try FfiConverterTypeAuthorizedDappPreferences.lift(buf)
}

public func FfiConverterTypeAuthorizedDappPreferences_lower(_ value: AuthorizedDappPreferences) -> RustBuffer {
	FfiConverterTypeAuthorizedDappPreferences.lower(value)
}

// MARK: - AuthorizedPersonaDetailed
public struct AuthorizedPersonaDetailed {
	/**
	 * Address that globally and uniquely identifies this Persona.
	 */
	public var identityAddress: IdentityAddress
	/**
	 * The display name of the Persona, as stored in `Persona`
	 */
	public var displayName: DisplayName
	/**
	 * Information of accounts the user has given the Dapp access to,
	 * being the triple `(accountAddress, displayName, appearanceID)`
	 */
	public var simpleAccounts: [AccountForDisplay]?
	/**
	 * The persona data that the user has given the Dapp access to
	 */
	public var sharedPersonaData: PersonaData
	/**
	 * If this persona has an auth sign key created
	 */
	public var hasAuthenticationSigningKey: Bool

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Address that globally and uniquely identifies this Persona.
		 */ identityAddress: IdentityAddress,
		/**
			* The display name of the Persona, as stored in `Persona`
			*/ displayName: DisplayName,
		/**
			* Information of accounts the user has given the Dapp access to,
			* being the triple `(accountAddress, displayName, appearanceID)`
			*/ simpleAccounts: [AccountForDisplay]?,
		/**
			* The persona data that the user has given the Dapp access to
			*/ sharedPersonaData: PersonaData,
		/**
			* If this persona has an auth sign key created
			*/ hasAuthenticationSigningKey: Bool
	) {
		self.identityAddress = identityAddress
		self.displayName = displayName
		self.simpleAccounts = simpleAccounts
		self.sharedPersonaData = sharedPersonaData
		self.hasAuthenticationSigningKey = hasAuthenticationSigningKey
	}
}

// MARK: Sendable
extension AuthorizedPersonaDetailed: Sendable {}

// MARK: Equatable, Hashable
extension AuthorizedPersonaDetailed: Equatable, Hashable {
	public static func == (lhs: AuthorizedPersonaDetailed, rhs: AuthorizedPersonaDetailed) -> Bool {
		if lhs.identityAddress != rhs.identityAddress {
			return false
		}
		if lhs.displayName != rhs.displayName {
			return false
		}
		if lhs.simpleAccounts != rhs.simpleAccounts {
			return false
		}
		if lhs.sharedPersonaData != rhs.sharedPersonaData {
			return false
		}
		if lhs.hasAuthenticationSigningKey != rhs.hasAuthenticationSigningKey {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(identityAddress)
		hasher.combine(displayName)
		hasher.combine(simpleAccounts)
		hasher.combine(sharedPersonaData)
		hasher.combine(hasAuthenticationSigningKey)
	}
}

// MARK: - FfiConverterTypeAuthorizedPersonaDetailed
public struct FfiConverterTypeAuthorizedPersonaDetailed: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedPersonaDetailed {
		try AuthorizedPersonaDetailed(
			identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
			displayName: FfiConverterTypeDisplayName.read(from: &buf),
			simpleAccounts: FfiConverterOptionSequenceTypeAccountForDisplay.read(from: &buf),
			sharedPersonaData: FfiConverterTypePersonaData.read(from: &buf),
			hasAuthenticationSigningKey: FfiConverterBool.read(from: &buf)
		)
	}

	public static func write(_ value: AuthorizedPersonaDetailed, into buf: inout [UInt8]) {
		FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
		FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
		FfiConverterOptionSequenceTypeAccountForDisplay.write(value.simpleAccounts, into: &buf)
		FfiConverterTypePersonaData.write(value.sharedPersonaData, into: &buf)
		FfiConverterBool.write(value.hasAuthenticationSigningKey, into: &buf)
	}
}

public func FfiConverterTypeAuthorizedPersonaDetailed_lift(_ buf: RustBuffer) throws -> AuthorizedPersonaDetailed {
	try FfiConverterTypeAuthorizedPersonaDetailed.lift(buf)
}

public func FfiConverterTypeAuthorizedPersonaDetailed_lower(_ value: AuthorizedPersonaDetailed) -> RustBuffer {
	FfiConverterTypeAuthorizedPersonaDetailed.lower(value)
}

// MARK: - AuthorizedPersonaSimple
/**
 * Simple data representation of a Persona the user has shared with a Dapp.
 * Simple meaning "the bare minimum amount of data" that enabled `Sargon` to
 * be able to reconstruct a `AuthorizedPersonaDetailed` value, used to populate
 * views.
 *
 * N.B. as of 2024-01-31 of `Sargon` we have not yet implemented the struct
 * `AuthorizedPersonaDetailed` since it is not JSON, but logic, and we have yet
 * to migrate `Sargon` into iOS/Android clients, thus we will defer the work
 * of mapping `AuthorizedPersonaSimple` -> `AuthorizedPersonaDetailed`.
 */
public struct AuthorizedPersonaSimple {
	/**
	 * The globally unique identifier of a Persona is its address, used
	 * to lookup persona
	 */
	public var identityAddress: IdentityAddress
	/**
	 * Date of last login for this persona.
	 */
	public var lastLogin: Timestamp
	/**
	 * List of "ongoing accountAddresses" that user given the dApp access to.
	 */
	public var sharedAccounts: SharedToDappWithPersonaAccountAddresses?
	/**
	 * ID to PersonaData entries to user has shared with a Dapp.
	 */
	public var sharedPersonaData: SharedPersonaData

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The globally unique identifier of a Persona is its address, used
		 * to lookup persona
		 */ identityAddress: IdentityAddress,
		/**
			* Date of last login for this persona.
			*/ lastLogin: Timestamp,
		/**
			* List of "ongoing accountAddresses" that user given the dApp access to.
			*/ sharedAccounts: SharedToDappWithPersonaAccountAddresses?,
		/**
			* ID to PersonaData entries to user has shared with a Dapp.
			*/ sharedPersonaData: SharedPersonaData
	) {
		self.identityAddress = identityAddress
		self.lastLogin = lastLogin
		self.sharedAccounts = sharedAccounts
		self.sharedPersonaData = sharedPersonaData
	}
}

// MARK: Sendable
extension AuthorizedPersonaSimple: Sendable {}

// MARK: Equatable, Hashable
extension AuthorizedPersonaSimple: Equatable, Hashable {
	public static func == (lhs: AuthorizedPersonaSimple, rhs: AuthorizedPersonaSimple) -> Bool {
		if lhs.identityAddress != rhs.identityAddress {
			return false
		}
		if lhs.lastLogin != rhs.lastLogin {
			return false
		}
		if lhs.sharedAccounts != rhs.sharedAccounts {
			return false
		}
		if lhs.sharedPersonaData != rhs.sharedPersonaData {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(identityAddress)
		hasher.combine(lastLogin)
		hasher.combine(sharedAccounts)
		hasher.combine(sharedPersonaData)
	}
}

// MARK: - FfiConverterTypeAuthorizedPersonaSimple
public struct FfiConverterTypeAuthorizedPersonaSimple: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedPersonaSimple {
		try AuthorizedPersonaSimple(
			identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
			lastLogin: FfiConverterTypeTimestamp.read(from: &buf),
			sharedAccounts: FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses.read(from: &buf),
			sharedPersonaData: FfiConverterTypeSharedPersonaData.read(from: &buf)
		)
	}

	public static func write(_ value: AuthorizedPersonaSimple, into buf: inout [UInt8]) {
		FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
		FfiConverterTypeTimestamp.write(value.lastLogin, into: &buf)
		FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses.write(value.sharedAccounts, into: &buf)
		FfiConverterTypeSharedPersonaData.write(value.sharedPersonaData, into: &buf)
	}
}

public func FfiConverterTypeAuthorizedPersonaSimple_lift(_ buf: RustBuffer) throws -> AuthorizedPersonaSimple {
	try FfiConverterTypeAuthorizedPersonaSimple.lift(buf)
}

public func FfiConverterTypeAuthorizedPersonaSimple_lower(_ value: AuthorizedPersonaSimple) -> RustBuffer {
	FfiConverterTypeAuthorizedPersonaSimple.lower(value)
}

// MARK: - Bip39Seed
/**
 * A BIP39 seed for hierarchal deterministic wallets, as per the [BIP39 standard][doc].
 *
 * We typically obtain this by calling [`to_seed` on `MnemonicWithPassphrase`][MnemonicWithPassphrase::to_seed].
 *
 * [doc]: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#user-content-From_mnemonic_to_seed
 */
public struct Bip39Seed {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Bip39Seed: Sendable {}

// MARK: Equatable, Hashable
extension Bip39Seed: Equatable, Hashable {
	public static func == (lhs: Bip39Seed, rhs: Bip39Seed) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeBIP39Seed
public struct FfiConverterTypeBIP39Seed: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Seed {
		try Bip39Seed(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Bip39Seed, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeBIP39Seed_lift(_ buf: RustBuffer) throws -> Bip39Seed {
	try FfiConverterTypeBIP39Seed.lift(buf)
}

public func FfiConverterTypeBIP39Seed_lower(_ value: Bip39Seed) -> RustBuffer {
	FfiConverterTypeBIP39Seed.lower(value)
}

// MARK: - Bip39Word
/**
 * A word in the BIP39 word list of `language` at known `index` (0-2047).
 */
public struct Bip39Word {
	public var word: String
	public var index: U11
	public var language: Bip39Language

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(word: String, index: U11, language: Bip39Language) {
		self.word = word
		self.index = index
		self.language = language
	}
}

// MARK: Sendable
extension Bip39Word: Sendable {}

// MARK: Equatable, Hashable
extension Bip39Word: Equatable, Hashable {
	public static func == (lhs: Bip39Word, rhs: Bip39Word) -> Bool {
		if lhs.word != rhs.word {
			return false
		}
		if lhs.index != rhs.index {
			return false
		}
		if lhs.language != rhs.language {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(word)
		hasher.combine(index)
		hasher.combine(language)
	}
}

// MARK: - FfiConverterTypeBIP39Word
public struct FfiConverterTypeBIP39Word: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Word {
		try Bip39Word(
			word: FfiConverterString.read(from: &buf),
			index: FfiConverterTypeU11.read(from: &buf),
			language: FfiConverterTypeBIP39Language.read(from: &buf)
		)
	}

	public static func write(_ value: Bip39Word, into buf: inout [UInt8]) {
		FfiConverterString.write(value.word, into: &buf)
		FfiConverterTypeU11.write(value.index, into: &buf)
		FfiConverterTypeBIP39Language.write(value.language, into: &buf)
	}
}

public func FfiConverterTypeBIP39Word_lift(_ buf: RustBuffer) throws -> Bip39Word {
	try FfiConverterTypeBIP39Word.lift(buf)
}

public func FfiConverterTypeBIP39Word_lower(_ value: Bip39Word) -> RustBuffer {
	FfiConverterTypeBIP39Word.lower(value)
}

// MARK: - Bip44LikePath
/**
 * Either a canonical BIP44 derivation path like so:
 *
 * `m / purpose' / coin_type' / account' / change / address_index`
 *
 * Or an Radix Olympia BIP44 "like" path, where the `address_index` accidentally
 * was made hardened, i.e.:
 *
 * `m / purpose' / coin_type' / account' / change / address_index'`
 *
 * This was a mistake made during implementation of Radix Olympia.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * fn parse(s: &str) -> Result<BIP44LikePath> {
 * s.parse::<BIP44LikePath>()
 * }
 *
 * assert!(parse("m/44'/1022'/0'/0/0").is_ok()); // Canonical BIP44
 * assert!(parse("m/44'/1022'/0'/0/0'").is_ok()); // BIP44 like
 *
 * assert_eq!(parse("m/44'/1022'/0'/0'/0"), Err(CommonError::InvalidBIP44LikePathChangeWasUnexpectedlyHardened));
 * assert_eq!(parse("m/44'/1022'/0'/0'/0'"), Err(CommonError::InvalidBIP44LikePathChangeWasUnexpectedlyHardened));
 * assert_eq!(parse("m/44'/0'/0'/0/0'"), Err(CommonError::CoinTypeNotFound { bad_value: 0 }));
 * ```
 */
public struct Bip44LikePath {
	public var account: HdPathComponent
	public var change: HdPathComponent
	public var index: HdPathComponent

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(account: HdPathComponent, change: HdPathComponent, index: HdPathComponent) {
		self.account = account
		self.change = change
		self.index = index
	}
}

// MARK: Sendable
extension Bip44LikePath: Sendable {}

// MARK: Equatable, Hashable
extension Bip44LikePath: Equatable, Hashable {
	public static func == (lhs: Bip44LikePath, rhs: Bip44LikePath) -> Bool {
		if lhs.account != rhs.account {
			return false
		}
		if lhs.change != rhs.change {
			return false
		}
		if lhs.index != rhs.index {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(account)
		hasher.combine(change)
		hasher.combine(index)
	}
}

// MARK: - FfiConverterTypeBIP44LikePath
public struct FfiConverterTypeBIP44LikePath: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip44LikePath {
		try Bip44LikePath(
			account: FfiConverterTypeHDPathComponent.read(from: &buf),
			change: FfiConverterTypeHDPathComponent.read(from: &buf),
			index: FfiConverterTypeHDPathComponent.read(from: &buf)
		)
	}

	public static func write(_ value: Bip44LikePath, into buf: inout [UInt8]) {
		FfiConverterTypeHDPathComponent.write(value.account, into: &buf)
		FfiConverterTypeHDPathComponent.write(value.change, into: &buf)
		FfiConverterTypeHDPathComponent.write(value.index, into: &buf)
	}
}

public func FfiConverterTypeBIP44LikePath_lift(_ buf: RustBuffer) throws -> Bip44LikePath {
	try FfiConverterTypeBIP44LikePath.lift(buf)
}

public func FfiConverterTypeBIP44LikePath_lower(_ value: Bip44LikePath) -> RustBuffer {
	FfiConverterTypeBIP44LikePath.lower(value)
}

// MARK: - Blob
/**
 * Blob is a wrapper a bag of bytes
 */
public struct Blob {
	fileprivate let secretMagic: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: BagOfBytes) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension Blob: Sendable {}

// MARK: Equatable, Hashable
extension Blob: Equatable, Hashable {
	public static func == (lhs: Blob, rhs: Blob) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeBlob
public struct FfiConverterTypeBlob: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Blob {
		try Blob(
			secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Blob, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeBlob_lift(_ buf: RustBuffer) throws -> Blob {
	try FfiConverterTypeBlob.lift(buf)
}

public func FfiConverterTypeBlob_lower(_ value: Blob) -> RustBuffer {
	FfiConverterTypeBlob.lower(value)
}

// MARK: - Blobs
/**
 * Vec of Blobs
 */
public struct Blobs {
	fileprivate let secretMagic: [Blob]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: [Blob]) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension Blobs: Sendable {}

// MARK: Equatable, Hashable
extension Blobs: Equatable, Hashable {
	public static func == (lhs: Blobs, rhs: Blobs) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeBlobs
public struct FfiConverterTypeBlobs: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Blobs {
		try Blobs(
			secretMagic: FfiConverterSequenceTypeBlob.read(from: &buf)
		)
	}

	public static func write(_ value: Blobs, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeBlob.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeBlobs_lift(_ buf: RustBuffer) throws -> Blobs {
	try FfiConverterTypeBlobs.lift(buf)
}

public func FfiConverterTypeBlobs_lower(_ value: Blobs) -> RustBuffer {
	FfiConverterTypeBlobs.lower(value)
}

// MARK: - CollectionOfEmailAddresses
/**
 * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
 * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
 * contain elements with the same value, but under different IDs.
 */
public struct CollectionOfEmailAddresses {
	public var collection: [PersonaDataIdentifiedEmailAddress]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(collection: [PersonaDataIdentifiedEmailAddress]) {
		self.collection = collection
	}
}

// MARK: Sendable
extension CollectionOfEmailAddresses: Sendable {}

// MARK: Equatable, Hashable
extension CollectionOfEmailAddresses: Equatable, Hashable {
	public static func == (lhs: CollectionOfEmailAddresses, rhs: CollectionOfEmailAddresses) -> Bool {
		if lhs.collection != rhs.collection {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(collection)
	}
}

// MARK: - FfiConverterTypeCollectionOfEmailAddresses
public struct FfiConverterTypeCollectionOfEmailAddresses: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionOfEmailAddresses {
		try CollectionOfEmailAddresses(
			collection: FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress.read(from: &buf)
		)
	}

	public static func write(_ value: CollectionOfEmailAddresses, into buf: inout [UInt8]) {
		FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress.write(value.collection, into: &buf)
	}
}

public func FfiConverterTypeCollectionOfEmailAddresses_lift(_ buf: RustBuffer) throws -> CollectionOfEmailAddresses {
	try FfiConverterTypeCollectionOfEmailAddresses.lift(buf)
}

public func FfiConverterTypeCollectionOfEmailAddresses_lower(_ value: CollectionOfEmailAddresses) -> RustBuffer {
	FfiConverterTypeCollectionOfEmailAddresses.lower(value)
}

// MARK: - CollectionOfPhoneNumbers
/**
 * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
 * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
 * contain elements with the same value, but under different IDs.
 */
public struct CollectionOfPhoneNumbers {
	public var collection: [PersonaDataIdentifiedPhoneNumber]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(collection: [PersonaDataIdentifiedPhoneNumber]) {
		self.collection = collection
	}
}

// MARK: Sendable
extension CollectionOfPhoneNumbers: Sendable {}

// MARK: Equatable, Hashable
extension CollectionOfPhoneNumbers: Equatable, Hashable {
	public static func == (lhs: CollectionOfPhoneNumbers, rhs: CollectionOfPhoneNumbers) -> Bool {
		if lhs.collection != rhs.collection {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(collection)
	}
}

// MARK: - FfiConverterTypeCollectionOfPhoneNumbers
public struct FfiConverterTypeCollectionOfPhoneNumbers: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionOfPhoneNumbers {
		try CollectionOfPhoneNumbers(
			collection: FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber.read(from: &buf)
		)
	}

	public static func write(_ value: CollectionOfPhoneNumbers, into buf: inout [UInt8]) {
		FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber.write(value.collection, into: &buf)
	}
}

public func FfiConverterTypeCollectionOfPhoneNumbers_lift(_ buf: RustBuffer) throws -> CollectionOfPhoneNumbers {
	try FfiConverterTypeCollectionOfPhoneNumbers.lift(buf)
}

public func FfiConverterTypeCollectionOfPhoneNumbers_lower(_ value: CollectionOfPhoneNumbers) -> RustBuffer {
	FfiConverterTypeCollectionOfPhoneNumbers.lower(value)
}

// MARK: - CompiledNotarizedIntent
public struct CompiledNotarizedIntent {
	fileprivate let secretMagic: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: BagOfBytes) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension CompiledNotarizedIntent: Sendable {}

// MARK: Equatable, Hashable
extension CompiledNotarizedIntent: Equatable, Hashable {
	public static func == (lhs: CompiledNotarizedIntent, rhs: CompiledNotarizedIntent) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeCompiledNotarizedIntent
public struct FfiConverterTypeCompiledNotarizedIntent: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompiledNotarizedIntent {
		try CompiledNotarizedIntent(
			secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: CompiledNotarizedIntent, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeCompiledNotarizedIntent_lift(_ buf: RustBuffer) throws -> CompiledNotarizedIntent {
	try FfiConverterTypeCompiledNotarizedIntent.lift(buf)
}

public func FfiConverterTypeCompiledNotarizedIntent_lower(_ value: CompiledNotarizedIntent) -> RustBuffer {
	FfiConverterTypeCompiledNotarizedIntent.lower(value)
}

// MARK: - CompiledSubintent
public struct CompiledSubintent {
	/**
	 * A base-64 encoded version of the compiled subintent
	 */
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * A base-64 encoded version of the compiled subintent
		 */ secretMagic: String
	) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension CompiledSubintent: Sendable {}

// MARK: Equatable, Hashable
extension CompiledSubintent: Equatable, Hashable {
	public static func == (lhs: CompiledSubintent, rhs: CompiledSubintent) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeCompiledSubintent
public struct FfiConverterTypeCompiledSubintent: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompiledSubintent {
		try CompiledSubintent(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: CompiledSubintent, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeCompiledSubintent_lift(_ buf: RustBuffer) throws -> CompiledSubintent {
	try FfiConverterTypeCompiledSubintent.lift(buf)
}

public func FfiConverterTypeCompiledSubintent_lower(_ value: CompiledSubintent) -> RustBuffer {
	FfiConverterTypeCompiledSubintent.lower(value)
}

// MARK: - CompiledTransactionIntent
public struct CompiledTransactionIntent {
	/**
	 * A base-64 encoded version of the compiled intent
	 */
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * A base-64 encoded version of the compiled intent
		 */ secretMagic: String
	) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension CompiledTransactionIntent: Sendable {}

// MARK: Equatable, Hashable
extension CompiledTransactionIntent: Equatable, Hashable {
	public static func == (lhs: CompiledTransactionIntent, rhs: CompiledTransactionIntent) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeCompiledTransactionIntent
public struct FfiConverterTypeCompiledTransactionIntent: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompiledTransactionIntent {
		try CompiledTransactionIntent(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: CompiledTransactionIntent, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeCompiledTransactionIntent_lift(_ buf: RustBuffer) throws -> CompiledTransactionIntent {
	try FfiConverterTypeCompiledTransactionIntent.lift(buf)
}

public func FfiConverterTypeCompiledTransactionIntent_lower(_ value: CompiledTransactionIntent) -> RustBuffer {
	FfiConverterTypeCompiledTransactionIntent.lower(value)
}

// MARK: - ComponentAddress
/**
 * An address to some On-Ledger (OnNetwork) component, e.g. a Dapp, being an instantiation
 * of some Scrypto blueprint, e.g:
 * `"component_rdx1cptxxxxxxxxxfaucetxxxxxxxxx000527798379xxxxxxxxxfaucet"`
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of ComponentAddress:
 * * GlobalGenericComponent
 * * InternalGenericComponent
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalComponentAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L243-L246
 */
public struct ComponentAddress {
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension ComponentAddress: Sendable {}

// MARK: Equatable, Hashable
extension ComponentAddress: Equatable, Hashable {
	public static func == (lhs: ComponentAddress, rhs: ComponentAddress) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeComponentAddress
public struct FfiConverterTypeComponentAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComponentAddress {
		try ComponentAddress(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: ComponentAddress, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeComponentAddress_lift(_ buf: RustBuffer) throws -> ComponentAddress {
	try FfiConverterTypeComponentAddress.lift(buf)
}

public func FfiConverterTypeComponentAddress_lower(_ value: ComponentAddress) -> RustBuffer {
	FfiConverterTypeComponentAddress.lower(value)
}

// MARK: - ConfirmationRoleWithFactorInstances
/**
 * ConfirmationRole is used to confirm recovery.
 */
public struct ConfirmationRoleWithFactorInstances {
	/**
	 * Factors which are used in combination with other instances, amounting to at
	 * least `threshold` many instances to perform some function with this role.
	 *
	 * # Implementation
	 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
	 * we might wanna use duplicates, allowing us to build a "template"
	 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
	 * meaning an instance of this template at FactorSource level
	 * (`SecurityStructureOfFactorSources`) will contain two different
	 * `TrustedContactFactorSource`s.
	 */
	public var thresholdFactors: [FactorInstance]
	/**
	 * How many threshold factors that must be used to perform some function with this role.
	 */
	public var threshold: UInt8
	/**
	 * Overriding / Super admin / "sudo" / God / factors, **ANY**
	 * single of these factor which can perform the function of this role,
	 * disregarding of `threshold`.
	 */
	public var overrideFactors: [FactorInstance]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Factors which are used in combination with other instances, amounting to at
		 * least `threshold` many instances to perform some function with this role.
		 *
		 * # Implementation
		 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
		 * we might wanna use duplicates, allowing us to build a "template"
		 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
		 * meaning an instance of this template at FactorSource level
		 * (`SecurityStructureOfFactorSources`) will contain two different
		 * `TrustedContactFactorSource`s.
		 */ thresholdFactors: [FactorInstance],
		/**
			* How many threshold factors that must be used to perform some function with this role.
			*/ threshold: UInt8,
		/**
			* Overriding / Super admin / "sudo" / God / factors, **ANY**
			* single of these factor which can perform the function of this role,
			* disregarding of `threshold`.
			*/ overrideFactors: [FactorInstance]
	) {
		self.thresholdFactors = thresholdFactors
		self.threshold = threshold
		self.overrideFactors = overrideFactors
	}
}

// MARK: Sendable
extension ConfirmationRoleWithFactorInstances: Sendable {}

// MARK: Equatable, Hashable
extension ConfirmationRoleWithFactorInstances: Equatable, Hashable {
	public static func == (lhs: ConfirmationRoleWithFactorInstances, rhs: ConfirmationRoleWithFactorInstances) -> Bool {
		if lhs.thresholdFactors != rhs.thresholdFactors {
			return false
		}
		if lhs.threshold != rhs.threshold {
			return false
		}
		if lhs.overrideFactors != rhs.overrideFactors {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(thresholdFactors)
		hasher.combine(threshold)
		hasher.combine(overrideFactors)
	}
}

// MARK: - FfiConverterTypeConfirmationRoleWithFactorInstances
public struct FfiConverterTypeConfirmationRoleWithFactorInstances: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationRoleWithFactorInstances {
		try ConfirmationRoleWithFactorInstances(
			thresholdFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf),
			threshold: FfiConverterUInt8.read(from: &buf),
			overrideFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf)
		)
	}

	public static func write(_ value: ConfirmationRoleWithFactorInstances, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeFactorInstance.write(value.thresholdFactors, into: &buf)
		FfiConverterUInt8.write(value.threshold, into: &buf)
		FfiConverterSequenceTypeFactorInstance.write(value.overrideFactors, into: &buf)
	}
}

public func FfiConverterTypeConfirmationRoleWithFactorInstances_lift(_ buf: RustBuffer) throws -> ConfirmationRoleWithFactorInstances {
	try FfiConverterTypeConfirmationRoleWithFactorInstances.lift(buf)
}

public func FfiConverterTypeConfirmationRoleWithFactorInstances_lower(_ value: ConfirmationRoleWithFactorInstances) -> RustBuffer {
	FfiConverterTypeConfirmationRoleWithFactorInstances.lower(value)
}

// MARK: - ConfirmationRoleWithFactorSourceIDs
/**
 * ConfirmationRole is used to confirm recovery.
 */
public struct ConfirmationRoleWithFactorSourceIDs {
	/**
	 * Factors which are used in combination with other instances, amounting to at
	 * least `threshold` many instances to perform some function with this role.
	 *
	 * # Implementation
	 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
	 * we might wanna use duplicates, allowing us to build a "template"
	 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
	 * meaning an instance of this template at FactorSource level
	 * (`SecurityStructureOfFactorSources`) will contain two different
	 * `TrustedContactFactorSource`s.
	 */
	public var thresholdFactors: [FactorSourceId]
	/**
	 * How many threshold factors that must be used to perform some function with this role.
	 */
	public var threshold: UInt8
	/**
	 * Overriding / Super admin / "sudo" / God / factors, **ANY**
	 * single of these factor which can perform the function of this role,
	 * disregarding of `threshold`.
	 */
	public var overrideFactors: [FactorSourceId]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Factors which are used in combination with other instances, amounting to at
		 * least `threshold` many instances to perform some function with this role.
		 *
		 * # Implementation
		 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
		 * we might wanna use duplicates, allowing us to build a "template"
		 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
		 * meaning an instance of this template at FactorSource level
		 * (`SecurityStructureOfFactorSources`) will contain two different
		 * `TrustedContactFactorSource`s.
		 */ thresholdFactors: [FactorSourceId],
		/**
			* How many threshold factors that must be used to perform some function with this role.
			*/ threshold: UInt8,
		/**
			* Overriding / Super admin / "sudo" / God / factors, **ANY**
			* single of these factor which can perform the function of this role,
			* disregarding of `threshold`.
			*/ overrideFactors: [FactorSourceId]
	) {
		self.thresholdFactors = thresholdFactors
		self.threshold = threshold
		self.overrideFactors = overrideFactors
	}
}

// MARK: Sendable
extension ConfirmationRoleWithFactorSourceIDs: Sendable {}

// MARK: Equatable, Hashable
extension ConfirmationRoleWithFactorSourceIDs: Equatable, Hashable {
	public static func == (lhs: ConfirmationRoleWithFactorSourceIDs, rhs: ConfirmationRoleWithFactorSourceIDs) -> Bool {
		if lhs.thresholdFactors != rhs.thresholdFactors {
			return false
		}
		if lhs.threshold != rhs.threshold {
			return false
		}
		if lhs.overrideFactors != rhs.overrideFactors {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(thresholdFactors)
		hasher.combine(threshold)
		hasher.combine(overrideFactors)
	}
}

// MARK: - FfiConverterTypeConfirmationRoleWithFactorSourceIDs
public struct FfiConverterTypeConfirmationRoleWithFactorSourceIDs: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationRoleWithFactorSourceIDs {
		try ConfirmationRoleWithFactorSourceIDs(
			thresholdFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf),
			threshold: FfiConverterUInt8.read(from: &buf),
			overrideFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
		)
	}

	public static func write(_ value: ConfirmationRoleWithFactorSourceIDs, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeFactorSourceID.write(value.thresholdFactors, into: &buf)
		FfiConverterUInt8.write(value.threshold, into: &buf)
		FfiConverterSequenceTypeFactorSourceID.write(value.overrideFactors, into: &buf)
	}
}

public func FfiConverterTypeConfirmationRoleWithFactorSourceIDs_lift(_ buf: RustBuffer) throws -> ConfirmationRoleWithFactorSourceIDs {
	try FfiConverterTypeConfirmationRoleWithFactorSourceIDs.lift(buf)
}

public func FfiConverterTypeConfirmationRoleWithFactorSourceIDs_lower(_ value: ConfirmationRoleWithFactorSourceIDs) -> RustBuffer {
	FfiConverterTypeConfirmationRoleWithFactorSourceIDs.lower(value)
}

// MARK: - ConfirmationRoleWithFactorSources
/**
 * ConfirmationRole is used to confirm recovery.
 */
public struct ConfirmationRoleWithFactorSources {
	/**
	 * Factors which are used in combination with other instances, amounting to at
	 * least `threshold` many instances to perform some function with this role.
	 *
	 * # Implementation
	 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
	 * we might wanna use duplicates, allowing us to build a "template"
	 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
	 * meaning an instance of this template at FactorSource level
	 * (`SecurityStructureOfFactorSources`) will contain two different
	 * `TrustedContactFactorSource`s.
	 */
	public var thresholdFactors: [FactorSource]
	/**
	 * How many threshold factors that must be used to perform some function with this role.
	 */
	public var threshold: UInt8
	/**
	 * Overriding / Super admin / "sudo" / God / factors, **ANY**
	 * single of these factor which can perform the function of this role,
	 * disregarding of `threshold`.
	 */
	public var overrideFactors: [FactorSource]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Factors which are used in combination with other instances, amounting to at
		 * least `threshold` many instances to perform some function with this role.
		 *
		 * # Implementation
		 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
		 * we might wanna use duplicates, allowing us to build a "template"
		 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
		 * meaning an instance of this template at FactorSource level
		 * (`SecurityStructureOfFactorSources`) will contain two different
		 * `TrustedContactFactorSource`s.
		 */ thresholdFactors: [FactorSource],
		/**
			* How many threshold factors that must be used to perform some function with this role.
			*/ threshold: UInt8,
		/**
			* Overriding / Super admin / "sudo" / God / factors, **ANY**
			* single of these factor which can perform the function of this role,
			* disregarding of `threshold`.
			*/ overrideFactors: [FactorSource]
	) {
		self.thresholdFactors = thresholdFactors
		self.threshold = threshold
		self.overrideFactors = overrideFactors
	}
}

// MARK: Sendable
extension ConfirmationRoleWithFactorSources: Sendable {}

// MARK: Equatable, Hashable
extension ConfirmationRoleWithFactorSources: Equatable, Hashable {
	public static func == (lhs: ConfirmationRoleWithFactorSources, rhs: ConfirmationRoleWithFactorSources) -> Bool {
		if lhs.thresholdFactors != rhs.thresholdFactors {
			return false
		}
		if lhs.threshold != rhs.threshold {
			return false
		}
		if lhs.overrideFactors != rhs.overrideFactors {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(thresholdFactors)
		hasher.combine(threshold)
		hasher.combine(overrideFactors)
	}
}

// MARK: - FfiConverterTypeConfirmationRoleWithFactorSources
public struct FfiConverterTypeConfirmationRoleWithFactorSources: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationRoleWithFactorSources {
		try ConfirmationRoleWithFactorSources(
			thresholdFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf),
			threshold: FfiConverterUInt8.read(from: &buf),
			overrideFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf)
		)
	}

	public static func write(_ value: ConfirmationRoleWithFactorSources, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeFactorSource.write(value.thresholdFactors, into: &buf)
		FfiConverterUInt8.write(value.threshold, into: &buf)
		FfiConverterSequenceTypeFactorSource.write(value.overrideFactors, into: &buf)
	}
}

public func FfiConverterTypeConfirmationRoleWithFactorSources_lift(_ buf: RustBuffer) throws -> ConfirmationRoleWithFactorSources {
	try FfiConverterTypeConfirmationRoleWithFactorSources.lift(buf)
}

public func FfiConverterTypeConfirmationRoleWithFactorSources_lower(_ value: ConfirmationRoleWithFactorSources) -> RustBuffer {
	FfiConverterTypeConfirmationRoleWithFactorSources.lower(value)
}

// MARK: - ContentHint
/**
 * A hint describing the contents of a Profile, acting as a
 * summary of a Profile used by a ProfileSnapshot Header.
 *
 * Important to know that this is just a **hint**, the values
 * SHOULD be kept up to date, might might not be, since they
 * are stored values which must be kept in sync.
 */
public struct ContentHint {
	/**
	 * The total number of accounts on all networks.
	 *
	 * Important to remember that this is a counter inside a
	 * content **hint**. This counter SHOULD be update when
	 * new accounts are created, but failing to do is of no
	 * real consequence.
	 *
	 * This counter includes any by user hidden accounts.
	 */
	public var numberOfAccountsOnAllNetworksInTotal: UInt16
	/**
	 * The total number of personas on all networks.
	 *
	 * Important to remember that this is a counter inside a
	 * content **hint**. This counter SHOULD be update when
	 * new accounts are created, but failing to do is of no
	 * real consequence.
	 *
	 * This counter includes any by user hidden personas.
	 */
	public var numberOfPersonasOnAllNetworksInTotal: UInt16
	/**
	 * The total number of networks that the user has used, i.e.
	 * on which she has any accounts or personas.
	 */
	public var numberOfNetworks: UInt16

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The total number of accounts on all networks.
		 *
		 * Important to remember that this is a counter inside a
		 * content **hint**. This counter SHOULD be update when
		 * new accounts are created, but failing to do is of no
		 * real consequence.
		 *
		 * This counter includes any by user hidden accounts.
		 */ numberOfAccountsOnAllNetworksInTotal: UInt16,
		/**
			* The total number of personas on all networks.
			*
			* Important to remember that this is a counter inside a
			* content **hint**. This counter SHOULD be update when
			* new accounts are created, but failing to do is of no
			* real consequence.
			*
			* This counter includes any by user hidden personas.
			*/ numberOfPersonasOnAllNetworksInTotal: UInt16,
		/**
			* The total number of networks that the user has used, i.e.
			* on which she has any accounts or personas.
			*/ numberOfNetworks: UInt16
	) {
		self.numberOfAccountsOnAllNetworksInTotal = numberOfAccountsOnAllNetworksInTotal
		self.numberOfPersonasOnAllNetworksInTotal = numberOfPersonasOnAllNetworksInTotal
		self.numberOfNetworks = numberOfNetworks
	}
}

// MARK: Sendable
extension ContentHint: Sendable {}

// MARK: Equatable, Hashable
extension ContentHint: Equatable, Hashable {
	public static func == (lhs: ContentHint, rhs: ContentHint) -> Bool {
		if lhs.numberOfAccountsOnAllNetworksInTotal != rhs.numberOfAccountsOnAllNetworksInTotal {
			return false
		}
		if lhs.numberOfPersonasOnAllNetworksInTotal != rhs.numberOfPersonasOnAllNetworksInTotal {
			return false
		}
		if lhs.numberOfNetworks != rhs.numberOfNetworks {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(numberOfAccountsOnAllNetworksInTotal)
		hasher.combine(numberOfPersonasOnAllNetworksInTotal)
		hasher.combine(numberOfNetworks)
	}
}

// MARK: - FfiConverterTypeContentHint
public struct FfiConverterTypeContentHint: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContentHint {
		try ContentHint(
			numberOfAccountsOnAllNetworksInTotal: FfiConverterUInt16.read(from: &buf),
			numberOfPersonasOnAllNetworksInTotal: FfiConverterUInt16.read(from: &buf),
			numberOfNetworks: FfiConverterUInt16.read(from: &buf)
		)
	}

	public static func write(_ value: ContentHint, into buf: inout [UInt8]) {
		FfiConverterUInt16.write(value.numberOfAccountsOnAllNetworksInTotal, into: &buf)
		FfiConverterUInt16.write(value.numberOfPersonasOnAllNetworksInTotal, into: &buf)
		FfiConverterUInt16.write(value.numberOfNetworks, into: &buf)
	}
}

public func FfiConverterTypeContentHint_lift(_ buf: RustBuffer) throws -> ContentHint {
	try FfiConverterTypeContentHint.lift(buf)
}

public func FfiConverterTypeContentHint_lower(_ value: ContentHint) -> RustBuffer {
	FfiConverterTypeContentHint.lower(value)
}

// MARK: - CreateDeleteAccountManifestOutcome
public struct CreateDeleteAccountManifestOutcome {
	public var manifest: TransactionManifest
	public var nonTransferableResources: [ResourceAddress]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(manifest: TransactionManifest, nonTransferableResources: [ResourceAddress]) {
		self.manifest = manifest
		self.nonTransferableResources = nonTransferableResources
	}
}

// MARK: Sendable
extension CreateDeleteAccountManifestOutcome: Sendable {}

// MARK: Equatable, Hashable
extension CreateDeleteAccountManifestOutcome: Equatable, Hashable {
	public static func == (lhs: CreateDeleteAccountManifestOutcome, rhs: CreateDeleteAccountManifestOutcome) -> Bool {
		if lhs.manifest != rhs.manifest {
			return false
		}
		if lhs.nonTransferableResources != rhs.nonTransferableResources {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(manifest)
		hasher.combine(nonTransferableResources)
	}
}

// MARK: - FfiConverterTypeCreateDeleteAccountManifestOutcome
public struct FfiConverterTypeCreateDeleteAccountManifestOutcome: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateDeleteAccountManifestOutcome {
		try CreateDeleteAccountManifestOutcome(
			manifest: FfiConverterTypeTransactionManifest.read(from: &buf),
			nonTransferableResources: FfiConverterSequenceTypeResourceAddress.read(from: &buf)
		)
	}

	public static func write(_ value: CreateDeleteAccountManifestOutcome, into buf: inout [UInt8]) {
		FfiConverterTypeTransactionManifest.write(value.manifest, into: &buf)
		FfiConverterSequenceTypeResourceAddress.write(value.nonTransferableResources, into: &buf)
	}
}

public func FfiConverterTypeCreateDeleteAccountManifestOutcome_lift(_ buf: RustBuffer) throws -> CreateDeleteAccountManifestOutcome {
	try FfiConverterTypeCreateDeleteAccountManifestOutcome.lift(buf)
}

public func FfiConverterTypeCreateDeleteAccountManifestOutcome_lower(_ value: CreateDeleteAccountManifestOutcome) -> RustBuffer {
	FfiConverterTypeCreateDeleteAccountManifestOutcome.lower(value)
}

// MARK: - DappToWalletInteraction
public struct DappToWalletInteraction {
	public var interactionId: WalletInteractionId
	public var items: DappToWalletInteractionItems
	public var metadata: DappToWalletInteractionMetadata

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(interactionId: WalletInteractionId, items: DappToWalletInteractionItems, metadata: DappToWalletInteractionMetadata) {
		self.interactionId = interactionId
		self.items = items
		self.metadata = metadata
	}
}

// MARK: Sendable
extension DappToWalletInteraction: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteraction: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteraction, rhs: DappToWalletInteraction) -> Bool {
		if lhs.interactionId != rhs.interactionId {
			return false
		}
		if lhs.items != rhs.items {
			return false
		}
		if lhs.metadata != rhs.metadata {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(interactionId)
		hasher.combine(items)
		hasher.combine(metadata)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteraction
public struct FfiConverterTypeDappToWalletInteraction: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteraction {
		try DappToWalletInteraction(
			interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
			items: FfiConverterTypeDappToWalletInteractionItems.read(from: &buf),
			metadata: FfiConverterTypeDappToWalletInteractionMetadata.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteraction, into buf: inout [UInt8]) {
		FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
		FfiConverterTypeDappToWalletInteractionItems.write(value.items, into: &buf)
		FfiConverterTypeDappToWalletInteractionMetadata.write(value.metadata, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteraction_lift(_ buf: RustBuffer) throws -> DappToWalletInteraction {
	try FfiConverterTypeDappToWalletInteraction.lift(buf)
}

public func FfiConverterTypeDappToWalletInteraction_lower(_ value: DappToWalletInteraction) -> RustBuffer {
	FfiConverterTypeDappToWalletInteraction.lower(value)
}

// MARK: - DappToWalletInteractionAccountsRequestItem
public struct DappToWalletInteractionAccountsRequestItem {
	public var numberOfAccounts: RequestedQuantity
	public var challenge: DappToWalletInteractionAuthChallengeNonce?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(numberOfAccounts: RequestedQuantity, challenge: DappToWalletInteractionAuthChallengeNonce?) {
		self.numberOfAccounts = numberOfAccounts
		self.challenge = challenge
	}
}

// MARK: Sendable
extension DappToWalletInteractionAccountsRequestItem: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionAccountsRequestItem: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionAccountsRequestItem, rhs: DappToWalletInteractionAccountsRequestItem) -> Bool {
		if lhs.numberOfAccounts != rhs.numberOfAccounts {
			return false
		}
		if lhs.challenge != rhs.challenge {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(numberOfAccounts)
		hasher.combine(challenge)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionAccountsRequestItem
public struct FfiConverterTypeDappToWalletInteractionAccountsRequestItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAccountsRequestItem {
		try DappToWalletInteractionAccountsRequestItem(
			numberOfAccounts: FfiConverterTypeRequestedQuantity.read(from: &buf),
			challenge: FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionAccountsRequestItem, into buf: inout [UInt8]) {
		FfiConverterTypeRequestedQuantity.write(value.numberOfAccounts, into: &buf)
		FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionAccountsRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAccountsRequestItem {
	try FfiConverterTypeDappToWalletInteractionAccountsRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAccountsRequestItem_lower(_ value: DappToWalletInteractionAccountsRequestItem) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionAccountsRequestItem.lower(value)
}

// MARK: - DappToWalletInteractionAuthLoginWithChallengeRequestItem
public struct DappToWalletInteractionAuthLoginWithChallengeRequestItem {
	public var challenge: DappToWalletInteractionAuthChallengeNonce

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(challenge: DappToWalletInteractionAuthChallengeNonce) {
		self.challenge = challenge
	}
}

// MARK: Sendable
extension DappToWalletInteractionAuthLoginWithChallengeRequestItem: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionAuthLoginWithChallengeRequestItem: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionAuthLoginWithChallengeRequestItem, rhs: DappToWalletInteractionAuthLoginWithChallengeRequestItem) -> Bool {
		if lhs.challenge != rhs.challenge {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(challenge)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem
public struct FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthLoginWithChallengeRequestItem {
		try DappToWalletInteractionAuthLoginWithChallengeRequestItem(
			challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionAuthLoginWithChallengeRequestItem, into buf: inout [UInt8]) {
		FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthLoginWithChallengeRequestItem {
	try FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem_lower(_ value: DappToWalletInteractionAuthLoginWithChallengeRequestItem) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.lower(value)
}

// MARK: - DappToWalletInteractionAuthUsePersonaRequestItem
public struct DappToWalletInteractionAuthUsePersonaRequestItem {
	public var identityAddress: IdentityAddress

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(identityAddress: IdentityAddress) {
		self.identityAddress = identityAddress
	}
}

// MARK: Sendable
extension DappToWalletInteractionAuthUsePersonaRequestItem: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionAuthUsePersonaRequestItem: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionAuthUsePersonaRequestItem, rhs: DappToWalletInteractionAuthUsePersonaRequestItem) -> Bool {
		if lhs.identityAddress != rhs.identityAddress {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(identityAddress)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem
public struct FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthUsePersonaRequestItem {
		try DappToWalletInteractionAuthUsePersonaRequestItem(
			identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionAuthUsePersonaRequestItem, into buf: inout [UInt8]) {
		FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthUsePersonaRequestItem {
	try FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem_lower(_ value: DappToWalletInteractionAuthUsePersonaRequestItem) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.lower(value)
}

// MARK: - DappToWalletInteractionAuthorizedRequestItems
public struct DappToWalletInteractionAuthorizedRequestItems {
	public var auth: DappToWalletInteractionAuthRequestItem
	public var reset: DappToWalletInteractionResetRequestItem?
	public var ongoingAccounts: DappToWalletInteractionAccountsRequestItem?
	public var ongoingPersonaData: DappToWalletInteractionPersonaDataRequestItem?
	public var oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?
	public var oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?
	public var proofOfOwnership: DappToWalletInteractionProofOfOwnershipRequestItem?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(auth: DappToWalletInteractionAuthRequestItem, reset: DappToWalletInteractionResetRequestItem?, ongoingAccounts: DappToWalletInteractionAccountsRequestItem?, ongoingPersonaData: DappToWalletInteractionPersonaDataRequestItem?, oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?, oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?, proofOfOwnership: DappToWalletInteractionProofOfOwnershipRequestItem?) {
		self.auth = auth
		self.reset = reset
		self.ongoingAccounts = ongoingAccounts
		self.ongoingPersonaData = ongoingPersonaData
		self.oneTimeAccounts = oneTimeAccounts
		self.oneTimePersonaData = oneTimePersonaData
		self.proofOfOwnership = proofOfOwnership
	}
}

// MARK: Sendable
extension DappToWalletInteractionAuthorizedRequestItems: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionAuthorizedRequestItems: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionAuthorizedRequestItems, rhs: DappToWalletInteractionAuthorizedRequestItems) -> Bool {
		if lhs.auth != rhs.auth {
			return false
		}
		if lhs.reset != rhs.reset {
			return false
		}
		if lhs.ongoingAccounts != rhs.ongoingAccounts {
			return false
		}
		if lhs.ongoingPersonaData != rhs.ongoingPersonaData {
			return false
		}
		if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
			return false
		}
		if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
			return false
		}
		if lhs.proofOfOwnership != rhs.proofOfOwnership {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(auth)
		hasher.combine(reset)
		hasher.combine(ongoingAccounts)
		hasher.combine(ongoingPersonaData)
		hasher.combine(oneTimeAccounts)
		hasher.combine(oneTimePersonaData)
		hasher.combine(proofOfOwnership)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems
public struct FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthorizedRequestItems {
		try DappToWalletInteractionAuthorizedRequestItems(
			auth: FfiConverterTypeDappToWalletInteractionAuthRequestItem.read(from: &buf),
			reset: FfiConverterOptionTypeDappToWalletInteractionResetRequestItem.read(from: &buf),
			ongoingAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf),
			ongoingPersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf),
			oneTimeAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf),
			oneTimePersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf),
			proofOfOwnership: FfiConverterOptionTypeDappToWalletInteractionProofOfOwnershipRequestItem.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionAuthorizedRequestItems, into buf: inout [UInt8]) {
		FfiConverterTypeDappToWalletInteractionAuthRequestItem.write(value.auth, into: &buf)
		FfiConverterOptionTypeDappToWalletInteractionResetRequestItem.write(value.reset, into: &buf)
		FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.ongoingAccounts, into: &buf)
		FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.ongoingPersonaData, into: &buf)
		FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.oneTimeAccounts, into: &buf)
		FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.oneTimePersonaData, into: &buf)
		FfiConverterOptionTypeDappToWalletInteractionProofOfOwnershipRequestItem.write(value.proofOfOwnership, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthorizedRequestItems {
	try FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems_lower(_ value: DappToWalletInteractionAuthorizedRequestItems) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.lower(value)
}

// MARK: - DappToWalletInteractionMetadata
public struct DappToWalletInteractionMetadata {
	public var version: WalletInteractionVersion
	public var networkId: NetworkId
	public var origin: DappOrigin
	public var dappDefinitionAddress: AccountAddress

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(version: WalletInteractionVersion, networkId: NetworkId, origin: DappOrigin, dappDefinitionAddress: AccountAddress) {
		self.version = version
		self.networkId = networkId
		self.origin = origin
		self.dappDefinitionAddress = dappDefinitionAddress
	}
}

// MARK: Sendable
extension DappToWalletInteractionMetadata: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionMetadata: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionMetadata, rhs: DappToWalletInteractionMetadata) -> Bool {
		if lhs.version != rhs.version {
			return false
		}
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.origin != rhs.origin {
			return false
		}
		if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(version)
		hasher.combine(networkId)
		hasher.combine(origin)
		hasher.combine(dappDefinitionAddress)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionMetadata
public struct FfiConverterTypeDappToWalletInteractionMetadata: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionMetadata {
		try DappToWalletInteractionMetadata(
			version: FfiConverterTypeWalletInteractionVersion.read(from: &buf),
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			origin: FfiConverterTypeDappOrigin.read(from: &buf),
			dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionMetadata, into buf: inout [UInt8]) {
		FfiConverterTypeWalletInteractionVersion.write(value.version, into: &buf)
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
		FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionMetadata_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionMetadata {
	try FfiConverterTypeDappToWalletInteractionMetadata.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionMetadata_lower(_ value: DappToWalletInteractionMetadata) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionMetadata.lower(value)
}

// MARK: - DappToWalletInteractionMetadataUnvalidated
public struct DappToWalletInteractionMetadataUnvalidated {
	public var version: WalletInteractionVersion
	public var networkId: NetworkId
	public var origin: DappOrigin
	public var dappDefinitionAddress: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(version: WalletInteractionVersion, networkId: NetworkId, origin: DappOrigin, dappDefinitionAddress: String) {
		self.version = version
		self.networkId = networkId
		self.origin = origin
		self.dappDefinitionAddress = dappDefinitionAddress
	}
}

// MARK: Sendable
extension DappToWalletInteractionMetadataUnvalidated: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionMetadataUnvalidated: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionMetadataUnvalidated, rhs: DappToWalletInteractionMetadataUnvalidated) -> Bool {
		if lhs.version != rhs.version {
			return false
		}
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.origin != rhs.origin {
			return false
		}
		if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(version)
		hasher.combine(networkId)
		hasher.combine(origin)
		hasher.combine(dappDefinitionAddress)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionMetadataUnvalidated
public struct FfiConverterTypeDappToWalletInteractionMetadataUnvalidated: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionMetadataUnvalidated {
		try DappToWalletInteractionMetadataUnvalidated(
			version: FfiConverterTypeWalletInteractionVersion.read(from: &buf),
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			origin: FfiConverterTypeDappOrigin.read(from: &buf),
			dappDefinitionAddress: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionMetadataUnvalidated, into buf: inout [UInt8]) {
		FfiConverterTypeWalletInteractionVersion.write(value.version, into: &buf)
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
		FfiConverterString.write(value.dappDefinitionAddress, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionMetadataUnvalidated_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionMetadataUnvalidated {
	try FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionMetadataUnvalidated_lower(_ value: DappToWalletInteractionMetadataUnvalidated) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.lower(value)
}

// MARK: - DappToWalletInteractionPersonaDataRequestItem
public struct DappToWalletInteractionPersonaDataRequestItem {
	public var isRequestingName: Bool?
	public var numberOfRequestedEmailAddresses: RequestedQuantity?
	public var numberOfRequestedPhoneNumbers: RequestedQuantity?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(isRequestingName: Bool?, numberOfRequestedEmailAddresses: RequestedQuantity?, numberOfRequestedPhoneNumbers: RequestedQuantity?) {
		self.isRequestingName = isRequestingName
		self.numberOfRequestedEmailAddresses = numberOfRequestedEmailAddresses
		self.numberOfRequestedPhoneNumbers = numberOfRequestedPhoneNumbers
	}
}

// MARK: Sendable
extension DappToWalletInteractionPersonaDataRequestItem: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionPersonaDataRequestItem: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionPersonaDataRequestItem, rhs: DappToWalletInteractionPersonaDataRequestItem) -> Bool {
		if lhs.isRequestingName != rhs.isRequestingName {
			return false
		}
		if lhs.numberOfRequestedEmailAddresses != rhs.numberOfRequestedEmailAddresses {
			return false
		}
		if lhs.numberOfRequestedPhoneNumbers != rhs.numberOfRequestedPhoneNumbers {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(isRequestingName)
		hasher.combine(numberOfRequestedEmailAddresses)
		hasher.combine(numberOfRequestedPhoneNumbers)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem
public struct FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionPersonaDataRequestItem {
		try DappToWalletInteractionPersonaDataRequestItem(
			isRequestingName: FfiConverterOptionBool.read(from: &buf),
			numberOfRequestedEmailAddresses: FfiConverterOptionTypeRequestedQuantity.read(from: &buf),
			numberOfRequestedPhoneNumbers: FfiConverterOptionTypeRequestedQuantity.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionPersonaDataRequestItem, into buf: inout [UInt8]) {
		FfiConverterOptionBool.write(value.isRequestingName, into: &buf)
		FfiConverterOptionTypeRequestedQuantity.write(value.numberOfRequestedEmailAddresses, into: &buf)
		FfiConverterOptionTypeRequestedQuantity.write(value.numberOfRequestedPhoneNumbers, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionPersonaDataRequestItem {
	try FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem_lower(_ value: DappToWalletInteractionPersonaDataRequestItem) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.lower(value)
}

// MARK: - DappToWalletInteractionPreAuthorizationItems
public struct DappToWalletInteractionPreAuthorizationItems {
	public var request: DappToWalletInteractionSubintentRequestItem

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(request: DappToWalletInteractionSubintentRequestItem) {
		self.request = request
	}
}

// MARK: Sendable
extension DappToWalletInteractionPreAuthorizationItems: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionPreAuthorizationItems: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionPreAuthorizationItems, rhs: DappToWalletInteractionPreAuthorizationItems) -> Bool {
		if lhs.request != rhs.request {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(request)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionPreAuthorizationItems
public struct FfiConverterTypeDappToWalletInteractionPreAuthorizationItems: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionPreAuthorizationItems {
		try DappToWalletInteractionPreAuthorizationItems(
			request: FfiConverterTypeDappToWalletInteractionSubintentRequestItem.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionPreAuthorizationItems, into buf: inout [UInt8]) {
		FfiConverterTypeDappToWalletInteractionSubintentRequestItem.write(value.request, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionPreAuthorizationItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionPreAuthorizationItems {
	try FfiConverterTypeDappToWalletInteractionPreAuthorizationItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionPreAuthorizationItems_lower(_ value: DappToWalletInteractionPreAuthorizationItems) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionPreAuthorizationItems.lower(value)
}

// MARK: - DappToWalletInteractionProofOfOwnershipRequestItem
/**
 * A request to prove ownership of `Accounts` and/or a `Persona`.
 */
public struct DappToWalletInteractionProofOfOwnershipRequestItem {
	/**
	 * The challenge that must be signed to prove ownership.
	 */
	public var challenge: DappToWalletInteractionAuthChallengeNonce
	/**
	 * The list of `AccountAddress`es for which the wallet must prove ownership.
	 */
	public var accountAddresses: [AccountAddress]?
	/**
	 * The `IdentityAddress` for which the wallet must prove ownership.
	 */
	public var identityAddress: IdentityAddress?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The challenge that must be signed to prove ownership.
		 */ challenge: DappToWalletInteractionAuthChallengeNonce,
		/**
			* The list of `AccountAddress`es for which the wallet must prove ownership.
			*/ accountAddresses: [AccountAddress]?,
		/**
			* The `IdentityAddress` for which the wallet must prove ownership.
			*/ identityAddress: IdentityAddress?
	) {
		self.challenge = challenge
		self.accountAddresses = accountAddresses
		self.identityAddress = identityAddress
	}
}

// MARK: Sendable
extension DappToWalletInteractionProofOfOwnershipRequestItem: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionProofOfOwnershipRequestItem: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionProofOfOwnershipRequestItem, rhs: DappToWalletInteractionProofOfOwnershipRequestItem) -> Bool {
		if lhs.challenge != rhs.challenge {
			return false
		}
		if lhs.accountAddresses != rhs.accountAddresses {
			return false
		}
		if lhs.identityAddress != rhs.identityAddress {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(challenge)
		hasher.combine(accountAddresses)
		hasher.combine(identityAddress)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem
public struct FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionProofOfOwnershipRequestItem {
		try DappToWalletInteractionProofOfOwnershipRequestItem(
			challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf),
			accountAddresses: FfiConverterOptionSequenceTypeAccountAddress.read(from: &buf),
			identityAddress: FfiConverterOptionTypeIdentityAddress.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionProofOfOwnershipRequestItem, into buf: inout [UInt8]) {
		FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
		FfiConverterOptionSequenceTypeAccountAddress.write(value.accountAddresses, into: &buf)
		FfiConverterOptionTypeIdentityAddress.write(value.identityAddress, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionProofOfOwnershipRequestItem {
	try FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem_lower(_ value: DappToWalletInteractionProofOfOwnershipRequestItem) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem.lower(value)
}

// MARK: - DappToWalletInteractionResetRequestItem
public struct DappToWalletInteractionResetRequestItem {
	public var accounts: Bool
	public var personaData: Bool

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(accounts: Bool, personaData: Bool) {
		self.accounts = accounts
		self.personaData = personaData
	}
}

// MARK: Sendable
extension DappToWalletInteractionResetRequestItem: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionResetRequestItem: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionResetRequestItem, rhs: DappToWalletInteractionResetRequestItem) -> Bool {
		if lhs.accounts != rhs.accounts {
			return false
		}
		if lhs.personaData != rhs.personaData {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(accounts)
		hasher.combine(personaData)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionResetRequestItem
public struct FfiConverterTypeDappToWalletInteractionResetRequestItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionResetRequestItem {
		try DappToWalletInteractionResetRequestItem(
			accounts: FfiConverterBool.read(from: &buf),
			personaData: FfiConverterBool.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionResetRequestItem, into buf: inout [UInt8]) {
		FfiConverterBool.write(value.accounts, into: &buf)
		FfiConverterBool.write(value.personaData, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionResetRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionResetRequestItem {
	try FfiConverterTypeDappToWalletInteractionResetRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionResetRequestItem_lower(_ value: DappToWalletInteractionResetRequestItem) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionResetRequestItem.lower(value)
}

// MARK: - DappToWalletInteractionSendTransactionItem
public struct DappToWalletInteractionSendTransactionItem {
	public var unvalidatedManifest: UnvalidatedTransactionManifest
	public var version: TxVersion
	public var message: String?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(unvalidatedManifest: UnvalidatedTransactionManifest, version: TxVersion, message: String?) {
		self.unvalidatedManifest = unvalidatedManifest
		self.version = version
		self.message = message
	}
}

// MARK: Sendable
extension DappToWalletInteractionSendTransactionItem: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionSendTransactionItem: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionSendTransactionItem, rhs: DappToWalletInteractionSendTransactionItem) -> Bool {
		if lhs.unvalidatedManifest != rhs.unvalidatedManifest {
			return false
		}
		if lhs.version != rhs.version {
			return false
		}
		if lhs.message != rhs.message {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(unvalidatedManifest)
		hasher.combine(version)
		hasher.combine(message)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionSendTransactionItem
public struct FfiConverterTypeDappToWalletInteractionSendTransactionItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSendTransactionItem {
		try DappToWalletInteractionSendTransactionItem(
			unvalidatedManifest: FfiConverterTypeUnvalidatedTransactionManifest.read(from: &buf),
			version: FfiConverterTypeTXVersion.read(from: &buf),
			message: FfiConverterOptionString.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionSendTransactionItem, into buf: inout [UInt8]) {
		FfiConverterTypeUnvalidatedTransactionManifest.write(value.unvalidatedManifest, into: &buf)
		FfiConverterTypeTXVersion.write(value.version, into: &buf)
		FfiConverterOptionString.write(value.message, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionSendTransactionItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSendTransactionItem {
	try FfiConverterTypeDappToWalletInteractionSendTransactionItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSendTransactionItem_lower(_ value: DappToWalletInteractionSendTransactionItem) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionSendTransactionItem.lower(value)
}

// MARK: - DappToWalletInteractionSubintentExpireAfterDelay
/**
 * Suggests that the subintent's expiry timestamp is set to `current_time + expire_after_seconds`
 * at the last moment, right before the intent is fixed for signing.
 */
public struct DappToWalletInteractionSubintentExpireAfterDelay {
	/**
	 * The time (in seconds) after the subintent is signed that it will expire.
	 */
	public var expireAfterSeconds: UInt64

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The time (in seconds) after the subintent is signed that it will expire.
		 */ expireAfterSeconds: UInt64
	) {
		self.expireAfterSeconds = expireAfterSeconds
	}
}

// MARK: Sendable
extension DappToWalletInteractionSubintentExpireAfterDelay: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionSubintentExpireAfterDelay: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionSubintentExpireAfterDelay, rhs: DappToWalletInteractionSubintentExpireAfterDelay) -> Bool {
		if lhs.expireAfterSeconds != rhs.expireAfterSeconds {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(expireAfterSeconds)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay
public struct FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentExpireAfterDelay {
		try DappToWalletInteractionSubintentExpireAfterDelay(
			expireAfterSeconds: FfiConverterUInt64.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionSubintentExpireAfterDelay, into buf: inout [UInt8]) {
		FfiConverterUInt64.write(value.expireAfterSeconds, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentExpireAfterDelay {
	try FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay_lower(_ value: DappToWalletInteractionSubintentExpireAfterDelay) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay.lower(value)
}

// MARK: - DappToWalletInteractionSubintentExpireAtTime
/**
 * The subintent expires at a specific fixed timestamp
 */
public struct DappToWalletInteractionSubintentExpireAtTime {
	/**
	 * The unix timestamp in seconds when the subintent expires.
	 */
	public var unixTimestampSeconds: UInt64

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The unix timestamp in seconds when the subintent expires.
		 */ unixTimestampSeconds: UInt64
	) {
		self.unixTimestampSeconds = unixTimestampSeconds
	}
}

// MARK: Sendable
extension DappToWalletInteractionSubintentExpireAtTime: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionSubintentExpireAtTime: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionSubintentExpireAtTime, rhs: DappToWalletInteractionSubintentExpireAtTime) -> Bool {
		if lhs.unixTimestampSeconds != rhs.unixTimestampSeconds {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(unixTimestampSeconds)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime
public struct FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentExpireAtTime {
		try DappToWalletInteractionSubintentExpireAtTime(
			unixTimestampSeconds: FfiConverterUInt64.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionSubintentExpireAtTime, into buf: inout [UInt8]) {
		FfiConverterUInt64.write(value.unixTimestampSeconds, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentExpireAtTime {
	try FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime_lower(_ value: DappToWalletInteractionSubintentExpireAtTime) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime.lower(value)
}

// MARK: - DappToWalletInteractionSubintentRequestItem
public struct DappToWalletInteractionSubintentRequestItem {
	public var version: SubintentVersion
	public var unvalidatedManifest: UnvalidatedSubintentManifest
	public var message: String?
	public var expiration: DappToWalletInteractionSubintentExpiration

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(version: SubintentVersion, unvalidatedManifest: UnvalidatedSubintentManifest, message: String?, expiration: DappToWalletInteractionSubintentExpiration) {
		self.version = version
		self.unvalidatedManifest = unvalidatedManifest
		self.message = message
		self.expiration = expiration
	}
}

// MARK: Sendable
extension DappToWalletInteractionSubintentRequestItem: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionSubintentRequestItem: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionSubintentRequestItem, rhs: DappToWalletInteractionSubintentRequestItem) -> Bool {
		if lhs.version != rhs.version {
			return false
		}
		if lhs.unvalidatedManifest != rhs.unvalidatedManifest {
			return false
		}
		if lhs.message != rhs.message {
			return false
		}
		if lhs.expiration != rhs.expiration {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(version)
		hasher.combine(unvalidatedManifest)
		hasher.combine(message)
		hasher.combine(expiration)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionSubintentRequestItem
public struct FfiConverterTypeDappToWalletInteractionSubintentRequestItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentRequestItem {
		try DappToWalletInteractionSubintentRequestItem(
			version: FfiConverterTypeSubintentVersion.read(from: &buf),
			unvalidatedManifest: FfiConverterTypeUnvalidatedSubintentManifest.read(from: &buf),
			message: FfiConverterOptionString.read(from: &buf),
			expiration: FfiConverterTypeDappToWalletInteractionSubintentExpiration.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionSubintentRequestItem, into buf: inout [UInt8]) {
		FfiConverterTypeSubintentVersion.write(value.version, into: &buf)
		FfiConverterTypeUnvalidatedSubintentManifest.write(value.unvalidatedManifest, into: &buf)
		FfiConverterOptionString.write(value.message, into: &buf)
		FfiConverterTypeDappToWalletInteractionSubintentExpiration.write(value.expiration, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionSubintentRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentRequestItem {
	try FfiConverterTypeDappToWalletInteractionSubintentRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSubintentRequestItem_lower(_ value: DappToWalletInteractionSubintentRequestItem) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionSubintentRequestItem.lower(value)
}

// MARK: - DappToWalletInteractionTransactionItems
public struct DappToWalletInteractionTransactionItems {
	public var send: DappToWalletInteractionSendTransactionItem

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(send: DappToWalletInteractionSendTransactionItem) {
		self.send = send
	}
}

// MARK: Sendable
extension DappToWalletInteractionTransactionItems: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionTransactionItems: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionTransactionItems, rhs: DappToWalletInteractionTransactionItems) -> Bool {
		if lhs.send != rhs.send {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(send)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionTransactionItems
public struct FfiConverterTypeDappToWalletInteractionTransactionItems: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionTransactionItems {
		try DappToWalletInteractionTransactionItems(
			send: FfiConverterTypeDappToWalletInteractionSendTransactionItem.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionTransactionItems, into buf: inout [UInt8]) {
		FfiConverterTypeDappToWalletInteractionSendTransactionItem.write(value.send, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionTransactionItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionTransactionItems {
	try FfiConverterTypeDappToWalletInteractionTransactionItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionTransactionItems_lower(_ value: DappToWalletInteractionTransactionItems) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionTransactionItems.lower(value)
}

// MARK: - DappToWalletInteractionUnauthorizedRequestItems
public struct DappToWalletInteractionUnauthorizedRequestItems {
	public var oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?
	public var oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?, oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?) {
		self.oneTimeAccounts = oneTimeAccounts
		self.oneTimePersonaData = oneTimePersonaData
	}
}

// MARK: Sendable
extension DappToWalletInteractionUnauthorizedRequestItems: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionUnauthorizedRequestItems: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionUnauthorizedRequestItems, rhs: DappToWalletInteractionUnauthorizedRequestItems) -> Bool {
		if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
			return false
		}
		if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(oneTimeAccounts)
		hasher.combine(oneTimePersonaData)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems
public struct FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionUnauthorizedRequestItems {
		try DappToWalletInteractionUnauthorizedRequestItems(
			oneTimeAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf),
			oneTimePersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionUnauthorizedRequestItems, into buf: inout [UInt8]) {
		FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.oneTimeAccounts, into: &buf)
		FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.oneTimePersonaData, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionUnauthorizedRequestItems {
	try FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems_lower(_ value: DappToWalletInteractionUnauthorizedRequestItems) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.lower(value)
}

// MARK: - DappToWalletInteractionUnvalidated
public struct DappToWalletInteractionUnvalidated {
	public var interactionId: WalletInteractionId
	public var items: DappToWalletInteractionItems
	public var metadata: DappToWalletInteractionMetadataUnvalidated

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(interactionId: WalletInteractionId, items: DappToWalletInteractionItems, metadata: DappToWalletInteractionMetadataUnvalidated) {
		self.interactionId = interactionId
		self.items = items
		self.metadata = metadata
	}
}

// MARK: Sendable
extension DappToWalletInteractionUnvalidated: Sendable {}

// MARK: Equatable, Hashable
extension DappToWalletInteractionUnvalidated: Equatable, Hashable {
	public static func == (lhs: DappToWalletInteractionUnvalidated, rhs: DappToWalletInteractionUnvalidated) -> Bool {
		if lhs.interactionId != rhs.interactionId {
			return false
		}
		if lhs.items != rhs.items {
			return false
		}
		if lhs.metadata != rhs.metadata {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(interactionId)
		hasher.combine(items)
		hasher.combine(metadata)
	}
}

// MARK: - FfiConverterTypeDappToWalletInteractionUnvalidated
public struct FfiConverterTypeDappToWalletInteractionUnvalidated: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionUnvalidated {
		try DappToWalletInteractionUnvalidated(
			interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
			items: FfiConverterTypeDappToWalletInteractionItems.read(from: &buf),
			metadata: FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.read(from: &buf)
		)
	}

	public static func write(_ value: DappToWalletInteractionUnvalidated, into buf: inout [UInt8]) {
		FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
		FfiConverterTypeDappToWalletInteractionItems.write(value.items, into: &buf)
		FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.write(value.metadata, into: &buf)
	}
}

public func FfiConverterTypeDappToWalletInteractionUnvalidated_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionUnvalidated {
	try FfiConverterTypeDappToWalletInteractionUnvalidated.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionUnvalidated_lower(_ value: DappToWalletInteractionUnvalidated) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionUnvalidated.lower(value)
}

// MARK: - DappWalletInteractionPersona
public struct DappWalletInteractionPersona {
	public var identityAddress: IdentityAddress
	public var label: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(identityAddress: IdentityAddress, label: String) {
		self.identityAddress = identityAddress
		self.label = label
	}
}

// MARK: Sendable
extension DappWalletInteractionPersona: Sendable {}

// MARK: Equatable, Hashable
extension DappWalletInteractionPersona: Equatable, Hashable {
	public static func == (lhs: DappWalletInteractionPersona, rhs: DappWalletInteractionPersona) -> Bool {
		if lhs.identityAddress != rhs.identityAddress {
			return false
		}
		if lhs.label != rhs.label {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(identityAddress)
		hasher.combine(label)
	}
}

// MARK: - FfiConverterTypeDappWalletInteractionPersona
public struct FfiConverterTypeDappWalletInteractionPersona: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappWalletInteractionPersona {
		try DappWalletInteractionPersona(
			identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
			label: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: DappWalletInteractionPersona, into buf: inout [UInt8]) {
		FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
		FfiConverterString.write(value.label, into: &buf)
	}
}

public func FfiConverterTypeDappWalletInteractionPersona_lift(_ buf: RustBuffer) throws -> DappWalletInteractionPersona {
	try FfiConverterTypeDappWalletInteractionPersona.lift(buf)
}

public func FfiConverterTypeDappWalletInteractionPersona_lower(_ value: DappWalletInteractionPersona) -> RustBuffer {
	FfiConverterTypeDappWalletInteractionPersona.lower(value)
}

// MARK: - Decimal192
/**
 * `Decimal192` represents a 192 bit representation of a fixed-scale decimal number.
 *
 * The finite set of values are of the form `m / 10^18`, where `m` is
 * an integer such that `-2^(192 - 1) <= m < 2^(192 - 1)`.
 *
 * Fractional part: ~60 bits/18 digits
 * Integer part   : 132 bits /40 digits
 * Max            :  3138550867693340381917894711603833208051.177722232017256447
 * Min            : -3138550867693340381917894711603833208051.177722232017256448
 *
 * Unless otherwise specified, all operations will panic if underflow/overflow.
 *
 * Powering it is the [Scrypto Decimal type, see docs][scrypto].
 *
 * Note: This type cannot be called `Decimal`, since it results in naming collision
 * in the Swift land (clash with `Foundation.Decimal`) instead we have created a
 * type alias `Decimal = Decimal192` which we use in Rust land.
 *
 * [scrypto]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/math/decimal.rs#L42
 */
public struct Decimal192 {
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension Decimal192: Sendable {}

// MARK: Equatable, Hashable
extension Decimal192: Equatable, Hashable {
	public static func == (lhs: Decimal192, rhs: Decimal192) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeDecimal192
public struct FfiConverterTypeDecimal192: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Decimal192 {
		try Decimal192(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: Decimal192, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeDecimal192_lift(_ buf: RustBuffer) throws -> Decimal192 {
	try FfiConverterTypeDecimal192.lift(buf)
}

public func FfiConverterTypeDecimal192_lower(_ value: Decimal192) -> RustBuffer {
	FfiConverterTypeDecimal192.lower(value)
}

// MARK: - DeviceFactorSource
/**
 * A factor source representing the host device which SargonOS runs on, typically
 * an iPhone or Android device.
 *
 * This is the initial factor source of
 * all new Accounts and Personas. Users authenticate signing by authorizing
 * the host to access a mnemonic stored in secure storage on
 * the device.
 */
public struct DeviceFactorSource {
	/**
	 * Unique and stable identifier of this factor source, stemming from the
	 * hash of a special child key of the HD root of the mnemonic.
	 */
	public var id: FactorSourceIdFromHash
	/**
	 * Common properties shared between FactorSources of different kinds,
	 * describing its state, when added, and supported cryptographic parameters.
	 */
	public var common: FactorSourceCommon
	/**
	 * Properties describing a DeviceFactorSource to help user disambiguate between it and another one.
	 */
	public var hint: DeviceFactorSourceHint

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Unique and stable identifier of this factor source, stemming from the
		 * hash of a special child key of the HD root of the mnemonic.
		 */ id: FactorSourceIdFromHash,
		/**
			* Common properties shared between FactorSources of different kinds,
			* describing its state, when added, and supported cryptographic parameters.
			*/ common: FactorSourceCommon,
		/**
			* Properties describing a DeviceFactorSource to help user disambiguate between it and another one.
			*/ hint: DeviceFactorSourceHint
	) {
		self.id = id
		self.common = common
		self.hint = hint
	}
}

// MARK: Sendable
extension DeviceFactorSource: Sendable {}

// MARK: Equatable, Hashable
extension DeviceFactorSource: Equatable, Hashable {
	public static func == (lhs: DeviceFactorSource, rhs: DeviceFactorSource) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.common != rhs.common {
			return false
		}
		if lhs.hint != rhs.hint {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(common)
		hasher.combine(hint)
	}
}

// MARK: - FfiConverterTypeDeviceFactorSource
public struct FfiConverterTypeDeviceFactorSource: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSource {
		try DeviceFactorSource(
			id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
			common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
			hint: FfiConverterTypeDeviceFactorSourceHint.read(from: &buf)
		)
	}

	public static func write(_ value: DeviceFactorSource, into buf: inout [UInt8]) {
		FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
		FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
		FfiConverterTypeDeviceFactorSourceHint.write(value.hint, into: &buf)
	}
}

public func FfiConverterTypeDeviceFactorSource_lift(_ buf: RustBuffer) throws -> DeviceFactorSource {
	try FfiConverterTypeDeviceFactorSource.lift(buf)
}

public func FfiConverterTypeDeviceFactorSource_lower(_ value: DeviceFactorSource) -> RustBuffer {
	FfiConverterTypeDeviceFactorSource.lower(value)
}

// MARK: - DeviceFactorSourceHint
/**
 * Properties describing a DeviceFactorSource to help user disambiguate between
 * it and another one.
 */
public struct DeviceFactorSourceHint {
	/**
	 * "iPhone RED"
	 */
	public var name: String
	/**
	 * "iPhone SE 2nd gen"
	 */
	public var model: String
	/**
	 * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
	 * standard, a multiple of 3, from 12 to 24 words.
	 */
	public var mnemonicWordCount: Bip39WordCount
	/**
	 * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
	 *
	 * It is possible that the host device has been updated to a new
	 * version than recorded here, but Sargon or host clients might
	 * just not have updated this value here.
	 *
	 * MUST be optional since this was added on 2024-05-03 and
	 * was not present in earlier version of wallet (pre 1.6.0).
	 */
	public var systemVersion: String?
	/**
	 * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
	 *
	 * It is possible that the host device has been updated to a new
	 * version than recorded here, but Sargon or host clients might
	 * just not have updated this value here.
	 *
	 * MUST be optional since this was added on 2024-05-03 and
	 * was not present in earlier version of wallet (pre 1.6.0).
	 */
	public var hostAppVersion: String?
	/**
	 * The vendor of the device host, e.g. "Apple" or "Samsung".
	 *
	 * MUST be optional since this was added on 2024-05-03 and
	 * was not present in earlier version of wallet (pre 1.6.0).
	 */
	public var hostVendor: String?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * "iPhone RED"
		 */ name: String,
		/**
			* "iPhone SE 2nd gen"
			*/ model: String,
		/**
			* The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
			* standard, a multiple of 3, from 12 to 24 words.
			*/ mnemonicWordCount: Bip39WordCount,
		/**
			* The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
			*
			* It is possible that the host device has been updated to a new
			* version than recorded here, but Sargon or host clients might
			* just not have updated this value here.
			*
			* MUST be optional since this was added on 2024-05-03 and
			* was not present in earlier version of wallet (pre 1.6.0).
			*/ systemVersion: String?,
		/**
			* The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
			*
			* It is possible that the host device has been updated to a new
			* version than recorded here, but Sargon or host clients might
			* just not have updated this value here.
			*
			* MUST be optional since this was added on 2024-05-03 and
			* was not present in earlier version of wallet (pre 1.6.0).
			*/ hostAppVersion: String?,
		/**
			* The vendor of the device host, e.g. "Apple" or "Samsung".
			*
			* MUST be optional since this was added on 2024-05-03 and
			* was not present in earlier version of wallet (pre 1.6.0).
			*/ hostVendor: String?
	) {
		self.name = name
		self.model = model
		self.mnemonicWordCount = mnemonicWordCount
		self.systemVersion = systemVersion
		self.hostAppVersion = hostAppVersion
		self.hostVendor = hostVendor
	}
}

// MARK: Sendable
extension DeviceFactorSourceHint: Sendable {}

// MARK: Equatable, Hashable
extension DeviceFactorSourceHint: Equatable, Hashable {
	public static func == (lhs: DeviceFactorSourceHint, rhs: DeviceFactorSourceHint) -> Bool {
		if lhs.name != rhs.name {
			return false
		}
		if lhs.model != rhs.model {
			return false
		}
		if lhs.mnemonicWordCount != rhs.mnemonicWordCount {
			return false
		}
		if lhs.systemVersion != rhs.systemVersion {
			return false
		}
		if lhs.hostAppVersion != rhs.hostAppVersion {
			return false
		}
		if lhs.hostVendor != rhs.hostVendor {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(name)
		hasher.combine(model)
		hasher.combine(mnemonicWordCount)
		hasher.combine(systemVersion)
		hasher.combine(hostAppVersion)
		hasher.combine(hostVendor)
	}
}

// MARK: - FfiConverterTypeDeviceFactorSourceHint
public struct FfiConverterTypeDeviceFactorSourceHint: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSourceHint {
		try DeviceFactorSourceHint(
			name: FfiConverterString.read(from: &buf),
			model: FfiConverterString.read(from: &buf),
			mnemonicWordCount: FfiConverterTypeBIP39WordCount.read(from: &buf),
			systemVersion: FfiConverterOptionString.read(from: &buf),
			hostAppVersion: FfiConverterOptionString.read(from: &buf),
			hostVendor: FfiConverterOptionString.read(from: &buf)
		)
	}

	public static func write(_ value: DeviceFactorSourceHint, into buf: inout [UInt8]) {
		FfiConverterString.write(value.name, into: &buf)
		FfiConverterString.write(value.model, into: &buf)
		FfiConverterTypeBIP39WordCount.write(value.mnemonicWordCount, into: &buf)
		FfiConverterOptionString.write(value.systemVersion, into: &buf)
		FfiConverterOptionString.write(value.hostAppVersion, into: &buf)
		FfiConverterOptionString.write(value.hostVendor, into: &buf)
	}
}

public func FfiConverterTypeDeviceFactorSourceHint_lift(_ buf: RustBuffer) throws -> DeviceFactorSourceHint {
	try FfiConverterTypeDeviceFactorSourceHint.lift(buf)
}

public func FfiConverterTypeDeviceFactorSourceHint_lower(_ value: DeviceFactorSourceHint) -> RustBuffer {
	FfiConverterTypeDeviceFactorSourceHint.lower(value)
}

// MARK: - DeviceInfo
/**
 * A short summary of a device the Profile is being used
 * on, typically an iPhone or an Android phone.
 */
public struct DeviceInfo {
	/**
	 * A best effort stable and unique identifier of this
	 * device.
	 *
	 * Apple has made it so that iOS devices cannot
	 * query iOS for a unique identifier of the device, thus
	 * the iOS team has made their own impl of a best effort
	 * stable identifier.
	 */
	public var id: DeviceId
	/**
	 * The date this description of the device was made, might
	 * be equal to when the app was first ever launched on the
	 * device.
	 */
	public var date: Timestamp
	/**
	 * A short description of the device, we devices should
	 * read the device model and a given name from the device
	 * if they are able to.
	 */
	public var description: String
	/**
	 * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
	 *
	 * It is possible that the host device has been updated to a new
	 * version than recorded here, but Sargon or host clients might
	 * just not have updated this value here.
	 *
	 * MUST be optional since this was added on 2024-05-03 and
	 * was not present in earlier version of wallet (pre 1.6.0).
	 */
	public var systemVersion: String?
	/**
	 * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
	 *
	 * It is possible that the host device has been updated to a new
	 * version than recorded here, but Sargon or host clients might
	 * just not have updated this value here.
	 *
	 * MUST be optional since this was added on 2024-05-03 and
	 * was not present in earlier version of wallet (pre 1.6.0).
	 */
	public var hostAppVersion: String?
	/**
	 * The vendor of the host client, e.g. "Apple" for iPhone clients,
	 * or "Samsung" for Android clients.
	 *
	 * MUST be optional since this was added on 2024-05-16 and
	 * was not present in earlier version of wallet (pre 1.6.0).
	 */
	public var hostVendor: String?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * A best effort stable and unique identifier of this
		 * device.
		 *
		 * Apple has made it so that iOS devices cannot
		 * query iOS for a unique identifier of the device, thus
		 * the iOS team has made their own impl of a best effort
		 * stable identifier.
		 */ id: DeviceId,
		/**
			* The date this description of the device was made, might
			* be equal to when the app was first ever launched on the
			* device.
			*/ date: Timestamp,
		/**
			* A short description of the device, we devices should
			* read the device model and a given name from the device
			* if they are able to.
			*/ description: String,
		/**
			* The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
			*
			* It is possible that the host device has been updated to a new
			* version than recorded here, but Sargon or host clients might
			* just not have updated this value here.
			*
			* MUST be optional since this was added on 2024-05-03 and
			* was not present in earlier version of wallet (pre 1.6.0).
			*/ systemVersion: String?,
		/**
			* The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
			*
			* It is possible that the host device has been updated to a new
			* version than recorded here, but Sargon or host clients might
			* just not have updated this value here.
			*
			* MUST be optional since this was added on 2024-05-03 and
			* was not present in earlier version of wallet (pre 1.6.0).
			*/ hostAppVersion: String?,
		/**
			* The vendor of the host client, e.g. "Apple" for iPhone clients,
			* or "Samsung" for Android clients.
			*
			* MUST be optional since this was added on 2024-05-16 and
			* was not present in earlier version of wallet (pre 1.6.0).
			*/ hostVendor: String?
	) {
		self.id = id
		self.date = date
		self.description = description
		self.systemVersion = systemVersion
		self.hostAppVersion = hostAppVersion
		self.hostVendor = hostVendor
	}
}

// MARK: Sendable
extension DeviceInfo: Sendable {}

// MARK: Equatable, Hashable
extension DeviceInfo: Equatable, Hashable {
	public static func == (lhs: DeviceInfo, rhs: DeviceInfo) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.date != rhs.date {
			return false
		}
		if lhs.description != rhs.description {
			return false
		}
		if lhs.systemVersion != rhs.systemVersion {
			return false
		}
		if lhs.hostAppVersion != rhs.hostAppVersion {
			return false
		}
		if lhs.hostVendor != rhs.hostVendor {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(date)
		hasher.combine(description)
		hasher.combine(systemVersion)
		hasher.combine(hostAppVersion)
		hasher.combine(hostVendor)
	}
}

// MARK: - FfiConverterTypeDeviceInfo
public struct FfiConverterTypeDeviceInfo: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceInfo {
		try DeviceInfo(
			id: FfiConverterTypeDeviceID.read(from: &buf),
			date: FfiConverterTypeTimestamp.read(from: &buf),
			description: FfiConverterString.read(from: &buf),
			systemVersion: FfiConverterOptionString.read(from: &buf),
			hostAppVersion: FfiConverterOptionString.read(from: &buf),
			hostVendor: FfiConverterOptionString.read(from: &buf)
		)
	}

	public static func write(_ value: DeviceInfo, into buf: inout [UInt8]) {
		FfiConverterTypeDeviceID.write(value.id, into: &buf)
		FfiConverterTypeTimestamp.write(value.date, into: &buf)
		FfiConverterString.write(value.description, into: &buf)
		FfiConverterOptionString.write(value.systemVersion, into: &buf)
		FfiConverterOptionString.write(value.hostAppVersion, into: &buf)
		FfiConverterOptionString.write(value.hostVendor, into: &buf)
	}
}

public func FfiConverterTypeDeviceInfo_lift(_ buf: RustBuffer) throws -> DeviceInfo {
	try FfiConverterTypeDeviceInfo.lift(buf)
}

public func FfiConverterTypeDeviceInfo_lower(_ value: DeviceInfo) -> RustBuffer {
	FfiConverterTypeDeviceInfo.lower(value)
}

// MARK: - DeviceInfoDescription
/**
 * A name and model of a host device.
 *
 * This used to be a String only in Pre 1.6.0 wallets, so
 * we have a custom Deserialize impl of it.
 */
public struct DeviceInfoDescription {
	/**
	 * Host device name, e.g. "My Precious"
	 */
	public var name: String
	/**
	 * Host device model, e.g. "iPhone 15 Pro"
	 */
	public var model: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Host device name, e.g. "My Precious"
		 */ name: String,
		/**
			* Host device model, e.g. "iPhone 15 Pro"
			*/ model: String
	) {
		self.name = name
		self.model = model
	}
}

// MARK: Sendable
extension DeviceInfoDescription: Sendable {}

// MARK: Equatable, Hashable
extension DeviceInfoDescription: Equatable, Hashable {
	public static func == (lhs: DeviceInfoDescription, rhs: DeviceInfoDescription) -> Bool {
		if lhs.name != rhs.name {
			return false
		}
		if lhs.model != rhs.model {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(name)
		hasher.combine(model)
	}
}

// MARK: - FfiConverterTypeDeviceInfoDescription
public struct FfiConverterTypeDeviceInfoDescription: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceInfoDescription {
		try DeviceInfoDescription(
			name: FfiConverterString.read(from: &buf),
			model: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: DeviceInfoDescription, into buf: inout [UInt8]) {
		FfiConverterString.write(value.name, into: &buf)
		FfiConverterString.write(value.model, into: &buf)
	}
}

public func FfiConverterTypeDeviceInfoDescription_lift(_ buf: RustBuffer) throws -> DeviceInfoDescription {
	try FfiConverterTypeDeviceInfoDescription.lift(buf)
}

public func FfiConverterTypeDeviceInfoDescription_lower(_ value: DeviceInfoDescription) -> RustBuffer {
	FfiConverterTypeDeviceInfoDescription.lower(value)
}

// MARK: - DisplayName
/**
 * A max 30 chars long string used for display purposes, e.g.
 * the name of an Account or Persona.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 * #[allow(clippy::upper_case_acronyms)]
 * type SUT = DisplayName;
 *
 * assert_eq!(SUT::MAX_LEN, 30);
 * assert_eq!("Satoshi".parse::<SUT>().unwrap().to_string(), "Satoshi");
 * ```
 *
 * Names with longer than 30 chars are trimmed.
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 * #[allow(clippy::upper_case_acronyms)]
 * type SUT = DisplayName;
 * assert_eq!("A very big name that is over than 30 characters long".parse::<SUT>().unwrap().to_string(), "A very big name that is over t");
 * ```

 */
public struct DisplayName {
	public var value: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: String) {
		self.value = value
	}
}

// MARK: Sendable
extension DisplayName: Sendable {}

// MARK: Equatable, Hashable
extension DisplayName: Equatable, Hashable {
	public static func == (lhs: DisplayName, rhs: DisplayName) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeDisplayName
public struct FfiConverterTypeDisplayName: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DisplayName {
		try DisplayName(
			value: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: DisplayName, into buf: inout [UInt8]) {
		FfiConverterString.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeDisplayName_lift(_ buf: RustBuffer) throws -> DisplayName {
	try FfiConverterTypeDisplayName.lift(buf)
}

public func FfiConverterTypeDisplayName_lower(_ value: DisplayName) -> RustBuffer {
	FfiConverterTypeDisplayName.lower(value)
}

// MARK: - Ed25519PublicKey
/**
 * An Ed25519 public key used to verify cryptographic signatures (EdDSA signatures).
 */
public struct Ed25519PublicKey {
	fileprivate let secretMagic: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: BagOfBytes) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension Ed25519PublicKey: Sendable {}

// MARK: Equatable, Hashable
extension Ed25519PublicKey: Equatable, Hashable {
	public static func == (lhs: Ed25519PublicKey, rhs: Ed25519PublicKey) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeEd25519PublicKey
public struct FfiConverterTypeEd25519PublicKey: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519PublicKey {
		try Ed25519PublicKey(
			secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Ed25519PublicKey, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeEd25519PublicKey_lift(_ buf: RustBuffer) throws -> Ed25519PublicKey {
	try FfiConverterTypeEd25519PublicKey.lift(buf)
}

public func FfiConverterTypeEd25519PublicKey_lower(_ value: Ed25519PublicKey) -> RustBuffer {
	FfiConverterTypeEd25519PublicKey.lower(value)
}

// MARK: - Ed25519Signature
/**
 * Represents an ED25519 signature.
 */
public struct Ed25519Signature {
	public var bytes: Exactly64Bytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(bytes: Exactly64Bytes) {
		self.bytes = bytes
	}
}

// MARK: Sendable
extension Ed25519Signature: Sendable {}

// MARK: Equatable, Hashable
extension Ed25519Signature: Equatable, Hashable {
	public static func == (lhs: Ed25519Signature, rhs: Ed25519Signature) -> Bool {
		if lhs.bytes != rhs.bytes {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(bytes)
	}
}

// MARK: - FfiConverterTypeEd25519Signature
public struct FfiConverterTypeEd25519Signature: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519Signature {
		try Ed25519Signature(
			bytes: FfiConverterTypeExactly64Bytes.read(from: &buf)
		)
	}

	public static func write(_ value: Ed25519Signature, into buf: inout [UInt8]) {
		FfiConverterTypeExactly64Bytes.write(value.bytes, into: &buf)
	}
}

public func FfiConverterTypeEd25519Signature_lift(_ buf: RustBuffer) throws -> Ed25519Signature {
	try FfiConverterTypeEd25519Signature.lift(buf)
}

public func FfiConverterTypeEd25519Signature_lower(_ value: Ed25519Signature) -> RustBuffer {
	FfiConverterTypeEd25519Signature.lower(value)
}

// MARK: - EmailAddress
/**
 * An email address.
 *
 * Current implementation does not validate the email address other than it
 * cannot be empty (in the future we might add some simple validation).
 */
public struct EmailAddress {
	public var email: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(email: String) {
		self.email = email
	}
}

// MARK: Sendable
extension EmailAddress: Sendable {}

// MARK: Equatable, Hashable
extension EmailAddress: Equatable, Hashable {
	public static func == (lhs: EmailAddress, rhs: EmailAddress) -> Bool {
		if lhs.email != rhs.email {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(email)
	}
}

// MARK: - FfiConverterTypeEmailAddress
public struct FfiConverterTypeEmailAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmailAddress {
		try EmailAddress(
			email: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: EmailAddress, into buf: inout [UInt8]) {
		FfiConverterString.write(value.email, into: &buf)
	}
}

public func FfiConverterTypeEmailAddress_lift(_ buf: RustBuffer) throws -> EmailAddress {
	try FfiConverterTypeEmailAddress.lift(buf)
}

public func FfiConverterTypeEmailAddress_lower(_ value: EmailAddress) -> RustBuffer {
	FfiConverterTypeEmailAddress.lower(value)
}

// MARK: - Entropy16Bytes
public struct Entropy16Bytes {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Entropy16Bytes: Sendable {}

// MARK: Equatable, Hashable
extension Entropy16Bytes: Equatable, Hashable {
	public static func == (lhs: Entropy16Bytes, rhs: Entropy16Bytes) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeEntropy16Bytes
public struct FfiConverterTypeEntropy16Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy16Bytes {
		try Entropy16Bytes(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Entropy16Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeEntropy16Bytes_lift(_ buf: RustBuffer) throws -> Entropy16Bytes {
	try FfiConverterTypeEntropy16Bytes.lift(buf)
}

public func FfiConverterTypeEntropy16Bytes_lower(_ value: Entropy16Bytes) -> RustBuffer {
	FfiConverterTypeEntropy16Bytes.lower(value)
}

// MARK: - Entropy20Bytes
public struct Entropy20Bytes {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Entropy20Bytes: Sendable {}

// MARK: Equatable, Hashable
extension Entropy20Bytes: Equatable, Hashable {
	public static func == (lhs: Entropy20Bytes, rhs: Entropy20Bytes) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeEntropy20Bytes
public struct FfiConverterTypeEntropy20Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy20Bytes {
		try Entropy20Bytes(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Entropy20Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeEntropy20Bytes_lift(_ buf: RustBuffer) throws -> Entropy20Bytes {
	try FfiConverterTypeEntropy20Bytes.lift(buf)
}

public func FfiConverterTypeEntropy20Bytes_lower(_ value: Entropy20Bytes) -> RustBuffer {
	FfiConverterTypeEntropy20Bytes.lower(value)
}

// MARK: - Entropy24Bytes
public struct Entropy24Bytes {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Entropy24Bytes: Sendable {}

// MARK: Equatable, Hashable
extension Entropy24Bytes: Equatable, Hashable {
	public static func == (lhs: Entropy24Bytes, rhs: Entropy24Bytes) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeEntropy24Bytes
public struct FfiConverterTypeEntropy24Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy24Bytes {
		try Entropy24Bytes(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Entropy24Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeEntropy24Bytes_lift(_ buf: RustBuffer) throws -> Entropy24Bytes {
	try FfiConverterTypeEntropy24Bytes.lift(buf)
}

public func FfiConverterTypeEntropy24Bytes_lower(_ value: Entropy24Bytes) -> RustBuffer {
	FfiConverterTypeEntropy24Bytes.lower(value)
}

// MARK: - Entropy28Bytes
public struct Entropy28Bytes {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Entropy28Bytes: Sendable {}

// MARK: Equatable, Hashable
extension Entropy28Bytes: Equatable, Hashable {
	public static func == (lhs: Entropy28Bytes, rhs: Entropy28Bytes) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeEntropy28Bytes
public struct FfiConverterTypeEntropy28Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy28Bytes {
		try Entropy28Bytes(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Entropy28Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeEntropy28Bytes_lift(_ buf: RustBuffer) throws -> Entropy28Bytes {
	try FfiConverterTypeEntropy28Bytes.lift(buf)
}

public func FfiConverterTypeEntropy28Bytes_lower(_ value: Entropy28Bytes) -> RustBuffer {
	FfiConverterTypeEntropy28Bytes.lower(value)
}

// MARK: - Entropy32Bytes
public struct Entropy32Bytes {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Entropy32Bytes: Sendable {}

// MARK: Equatable, Hashable
extension Entropy32Bytes: Equatable, Hashable {
	public static func == (lhs: Entropy32Bytes, rhs: Entropy32Bytes) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeEntropy32Bytes
public struct FfiConverterTypeEntropy32Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy32Bytes {
		try Entropy32Bytes(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Entropy32Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeEntropy32Bytes_lift(_ buf: RustBuffer) throws -> Entropy32Bytes {
	try FfiConverterTypeEntropy32Bytes.lift(buf)
}

public func FfiConverterTypeEntropy32Bytes_lower(_ value: Entropy32Bytes) -> RustBuffer {
	FfiConverterTypeEntropy32Bytes.lower(value)
}

// MARK: - EventNotification
/**
 * A notification containing a timestamped and unique `event`, host client
 * can subscribe to these notifications by using the EventBusDriver.
 */
public struct EventNotification {
	public var id: Uuid
	public var event: Event
	public var timestamp: Timestamp

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(id: Uuid, event: Event, timestamp: Timestamp) {
		self.id = id
		self.event = event
		self.timestamp = timestamp
	}
}

// MARK: Sendable
extension EventNotification: Sendable {}

// MARK: Equatable, Hashable
extension EventNotification: Equatable, Hashable {
	public static func == (lhs: EventNotification, rhs: EventNotification) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.event != rhs.event {
			return false
		}
		if lhs.timestamp != rhs.timestamp {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(event)
		hasher.combine(timestamp)
	}
}

// MARK: - FfiConverterTypeEventNotification
public struct FfiConverterTypeEventNotification: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventNotification {
		try EventNotification(
			id: FfiConverterTypeUuid.read(from: &buf),
			event: FfiConverterTypeEvent.read(from: &buf),
			timestamp: FfiConverterTypeTimestamp.read(from: &buf)
		)
	}

	public static func write(_ value: EventNotification, into buf: inout [UInt8]) {
		FfiConverterTypeUuid.write(value.id, into: &buf)
		FfiConverterTypeEvent.write(value.event, into: &buf)
		FfiConverterTypeTimestamp.write(value.timestamp, into: &buf)
	}
}

public func FfiConverterTypeEventNotification_lift(_ buf: RustBuffer) throws -> EventNotification {
	try FfiConverterTypeEventNotification.lift(buf)
}

public func FfiConverterTypeEventNotification_lower(_ value: EventNotification) -> RustBuffer {
	FfiConverterTypeEventNotification.lower(value)
}

// MARK: - Exactly12Bytes
/**
 * 12 bytes, used by AES encryption, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly12Bytes {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Exactly12Bytes: Sendable {}

// MARK: Equatable, Hashable
extension Exactly12Bytes: Equatable, Hashable {
	public static func == (lhs: Exactly12Bytes, rhs: Exactly12Bytes) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeExactly12Bytes
public struct FfiConverterTypeExactly12Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly12Bytes {
		try Exactly12Bytes(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Exactly12Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeExactly12Bytes_lift(_ buf: RustBuffer) throws -> Exactly12Bytes {
	try FfiConverterTypeExactly12Bytes.lift(buf)
}

public func FfiConverterTypeExactly12Bytes_lower(_ value: Exactly12Bytes) -> RustBuffer {
	FfiConverterTypeExactly12Bytes.lower(value)
}

// MARK: - Exactly29Bytes
/**
 * 29 bytes, typically used as PublicKeyHash, or otherwise NodeId payload,
 * implementation wise those bytes are stored inside a `BagOfBytes`
 * (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly29Bytes {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Exactly29Bytes: Sendable {}

// MARK: Equatable, Hashable
extension Exactly29Bytes: Equatable, Hashable {
	public static func == (lhs: Exactly29Bytes, rhs: Exactly29Bytes) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeExactly29Bytes
public struct FfiConverterTypeExactly29Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly29Bytes {
		try Exactly29Bytes(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Exactly29Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeExactly29Bytes_lift(_ buf: RustBuffer) throws -> Exactly29Bytes {
	try FfiConverterTypeExactly29Bytes.lift(buf)
}

public func FfiConverterTypeExactly29Bytes_lower(_ value: Exactly29Bytes) -> RustBuffer {
	FfiConverterTypeExactly29Bytes.lower(value)
}

// MARK: - Exactly32Bytes
/**
 * 32 bytes, most commonly used fixed length bytes, used by PrivateKeys,
 * Ed25519PublicKey, and BIP39 entropy, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly32Bytes {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Exactly32Bytes: Sendable {}

// MARK: Equatable, Hashable
extension Exactly32Bytes: Equatable, Hashable {
	public static func == (lhs: Exactly32Bytes, rhs: Exactly32Bytes) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeExactly32Bytes
public struct FfiConverterTypeExactly32Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly32Bytes {
		try Exactly32Bytes(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Exactly32Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeExactly32Bytes_lift(_ buf: RustBuffer) throws -> Exactly32Bytes {
	try FfiConverterTypeExactly32Bytes.lift(buf)
}

public func FfiConverterTypeExactly32Bytes_lower(_ value: Exactly32Bytes) -> RustBuffer {
	FfiConverterTypeExactly32Bytes.lower(value)
}

// MARK: - Exactly33Bytes
/**
 * 33 bytes, used by Secp256k1PublicKeys, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly33Bytes {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Exactly33Bytes: Sendable {}

// MARK: Equatable, Hashable
extension Exactly33Bytes: Equatable, Hashable {
	public static func == (lhs: Exactly33Bytes, rhs: Exactly33Bytes) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeExactly33Bytes
public struct FfiConverterTypeExactly33Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly33Bytes {
		try Exactly33Bytes(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Exactly33Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeExactly33Bytes_lift(_ buf: RustBuffer) throws -> Exactly33Bytes {
	try FfiConverterTypeExactly33Bytes.lift(buf)
}

public func FfiConverterTypeExactly33Bytes_lower(_ value: Exactly33Bytes) -> RustBuffer {
	FfiConverterTypeExactly33Bytes.lower(value)
}

// MARK: - Exactly60Bytes
/**
 * 60 bytes, used as encrypted mnemonic for security questions factor
 * source. 32 bytes mnemonic when encrypted results in exactly this length.
 */
public struct Exactly60Bytes {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Exactly60Bytes: Sendable {}

// MARK: Equatable, Hashable
extension Exactly60Bytes: Equatable, Hashable {
	public static func == (lhs: Exactly60Bytes, rhs: Exactly60Bytes) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeExactly60Bytes
public struct FfiConverterTypeExactly60Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly60Bytes {
		try Exactly60Bytes(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Exactly60Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeExactly60Bytes_lift(_ buf: RustBuffer) throws -> Exactly60Bytes {
	try FfiConverterTypeExactly60Bytes.lift(buf)
}

public func FfiConverterTypeExactly60Bytes_lower(_ value: Exactly60Bytes) -> RustBuffer {
	FfiConverterTypeExactly60Bytes.lower(value)
}

// MARK: - Exactly64Bytes
/**
 * 64 bytes, used by Ed25519Signatures, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly64Bytes {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Exactly64Bytes: Sendable {}

// MARK: Equatable, Hashable
extension Exactly64Bytes: Equatable, Hashable {
	public static func == (lhs: Exactly64Bytes, rhs: Exactly64Bytes) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeExactly64Bytes
public struct FfiConverterTypeExactly64Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly64Bytes {
		try Exactly64Bytes(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Exactly64Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeExactly64Bytes_lift(_ buf: RustBuffer) throws -> Exactly64Bytes {
	try FfiConverterTypeExactly64Bytes.lift(buf)
}

public func FfiConverterTypeExactly64Bytes_lower(_ value: Exactly64Bytes) -> RustBuffer {
	FfiConverterTypeExactly64Bytes.lower(value)
}

// MARK: - Exactly65Bytes
/**
 * 65 bytes, used by Secp256k1Signatures, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly65Bytes {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Exactly65Bytes: Sendable {}

// MARK: Equatable, Hashable
extension Exactly65Bytes: Equatable, Hashable {
	public static func == (lhs: Exactly65Bytes, rhs: Exactly65Bytes) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeExactly65Bytes
public struct FfiConverterTypeExactly65Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly65Bytes {
		try Exactly65Bytes(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Exactly65Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeExactly65Bytes_lift(_ buf: RustBuffer) throws -> Exactly65Bytes {
	try FfiConverterTypeExactly65Bytes.lift(buf)
}

public func FfiConverterTypeExactly65Bytes_lower(_ value: Exactly65Bytes) -> RustBuffer {
	FfiConverterTypeExactly65Bytes.lower(value)
}

// MARK: - ExecutionSummary
/**
 * A summary of the execution of the manifest and the information that helps
 * wallets present the contents of a transaction.
 */
public struct ExecutionSummary {
	/**
	 * Per account, a list of all token balances that has been withdrawn from that account.
	 */
	public var withdrawals: [AccountAddress: [ResourceIndicator]]
	/**
	 * Per account, a list of all token balances that has been deposited into that account.
	 */
	public var deposits: [AccountAddress: [ResourceIndicator]]
	/**
	 * Addresses of accounts encountered in the manifest where privileged
	 * methods were called. The wallets will need to collect signatures
	 * of the accounts of all those addresses, which might be multiple
	 * signatures per Account, if MFA has been setup.
	 */
	public var addressesOfAccountsRequiringAuth: [AccountAddress]
	/**
	 * Addresses of identities (Personas) encountered in the manifest where privileged
	 * methods were called. The wallets will need to collect signatures
	 * of the identities of all those addresses, which might be multiple
	 * signatures per Persona, if MFA has been setup.
	 */
	public var addressesOfIdentitiesRequiringAuth: [IdentityAddress]
	/**
	 * Information on the global entities created in the transaction.
	 */
	public var newEntities: NewEntities
	/**
	 * The various classifications that this manifest matched against. Note
	 * that an empty set means that the manifest is non-conforming.
	 */
	public var detailedClassification: [DetailedManifestClass]
	/**
	 * List of newly created Non-Fungibles during this transaction.
	 */
	public var newlyCreatedNonFungibles: [NonFungibleGlobalId]
	/**
	 * The set of instructions encountered in the manifest that are reserved
	 * and can only be included in the manifest by the wallet itself.
	 */
	public var reservedInstructions: [ReservedInstruction]
	/**
	 * The list of the resources of proofs that were presented in the manifest.
	 */
	public var presentedProofs: [ResourceSpecifier]
	/**
	 * The set of all the encountered `ManifestEncounteredComponentAddress`es` in the manifest. This is
	 * to be primarily used for the "using dApps" section of the wallet's tx
	 * review screen.
	 */
	public var encounteredAddresses: [ManifestEncounteredComponentAddress]
	/**
	 * Information on how much fees were contingent and how much were not.
	 */
	public var feeLocks: FeeLocks
	/**
	 * Detailed information on the amount of cost units consumed.
	 */
	public var feeSummary: FeeSummary

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Per account, a list of all token balances that has been withdrawn from that account.
		 */ withdrawals: [AccountAddress: [ResourceIndicator]],
		/**
			* Per account, a list of all token balances that has been deposited into that account.
			*/ deposits: [AccountAddress: [ResourceIndicator]],
		/**
			* Addresses of accounts encountered in the manifest where privileged
			* methods were called. The wallets will need to collect signatures
			* of the accounts of all those addresses, which might be multiple
			* signatures per Account, if MFA has been setup.
			*/ addressesOfAccountsRequiringAuth: [AccountAddress],
		/**
			* Addresses of identities (Personas) encountered in the manifest where privileged
			* methods were called. The wallets will need to collect signatures
			* of the identities of all those addresses, which might be multiple
			* signatures per Persona, if MFA has been setup.
			*/ addressesOfIdentitiesRequiringAuth: [IdentityAddress],
		/**
			* Information on the global entities created in the transaction.
			*/ newEntities: NewEntities,
		/**
			* The various classifications that this manifest matched against. Note
			* that an empty set means that the manifest is non-conforming.
			*/ detailedClassification: [DetailedManifestClass],
		/**
			* List of newly created Non-Fungibles during this transaction.
			*/ newlyCreatedNonFungibles: [NonFungibleGlobalId],
		/**
			* The set of instructions encountered in the manifest that are reserved
			* and can only be included in the manifest by the wallet itself.
			*/ reservedInstructions: [ReservedInstruction],
		/**
			* The list of the resources of proofs that were presented in the manifest.
			*/ presentedProofs: [ResourceSpecifier],
		/**
			* The set of all the encountered `ManifestEncounteredComponentAddress`es` in the manifest. This is
			* to be primarily used for the "using dApps" section of the wallet's tx
			* review screen.
			*/ encounteredAddresses: [ManifestEncounteredComponentAddress],
		/**
			* Information on how much fees were contingent and how much were not.
			*/ feeLocks: FeeLocks,
		/**
			* Detailed information on the amount of cost units consumed.
			*/ feeSummary: FeeSummary
	) {
		self.withdrawals = withdrawals
		self.deposits = deposits
		self.addressesOfAccountsRequiringAuth = addressesOfAccountsRequiringAuth
		self.addressesOfIdentitiesRequiringAuth = addressesOfIdentitiesRequiringAuth
		self.newEntities = newEntities
		self.detailedClassification = detailedClassification
		self.newlyCreatedNonFungibles = newlyCreatedNonFungibles
		self.reservedInstructions = reservedInstructions
		self.presentedProofs = presentedProofs
		self.encounteredAddresses = encounteredAddresses
		self.feeLocks = feeLocks
		self.feeSummary = feeSummary
	}
}

// MARK: Sendable
extension ExecutionSummary: Sendable {}

// MARK: Equatable, Hashable
extension ExecutionSummary: Equatable, Hashable {
	public static func == (lhs: ExecutionSummary, rhs: ExecutionSummary) -> Bool {
		if lhs.withdrawals != rhs.withdrawals {
			return false
		}
		if lhs.deposits != rhs.deposits {
			return false
		}
		if lhs.addressesOfAccountsRequiringAuth != rhs.addressesOfAccountsRequiringAuth {
			return false
		}
		if lhs.addressesOfIdentitiesRequiringAuth != rhs.addressesOfIdentitiesRequiringAuth {
			return false
		}
		if lhs.newEntities != rhs.newEntities {
			return false
		}
		if lhs.detailedClassification != rhs.detailedClassification {
			return false
		}
		if lhs.newlyCreatedNonFungibles != rhs.newlyCreatedNonFungibles {
			return false
		}
		if lhs.reservedInstructions != rhs.reservedInstructions {
			return false
		}
		if lhs.presentedProofs != rhs.presentedProofs {
			return false
		}
		if lhs.encounteredAddresses != rhs.encounteredAddresses {
			return false
		}
		if lhs.feeLocks != rhs.feeLocks {
			return false
		}
		if lhs.feeSummary != rhs.feeSummary {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(withdrawals)
		hasher.combine(deposits)
		hasher.combine(addressesOfAccountsRequiringAuth)
		hasher.combine(addressesOfIdentitiesRequiringAuth)
		hasher.combine(newEntities)
		hasher.combine(detailedClassification)
		hasher.combine(newlyCreatedNonFungibles)
		hasher.combine(reservedInstructions)
		hasher.combine(presentedProofs)
		hasher.combine(encounteredAddresses)
		hasher.combine(feeLocks)
		hasher.combine(feeSummary)
	}
}

// MARK: - FfiConverterTypeExecutionSummary
public struct FfiConverterTypeExecutionSummary: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExecutionSummary {
		try ExecutionSummary(
			withdrawals: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.read(from: &buf),
			deposits: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.read(from: &buf),
			addressesOfAccountsRequiringAuth: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
			addressesOfIdentitiesRequiringAuth: FfiConverterSequenceTypeIdentityAddress.read(from: &buf),
			newEntities: FfiConverterTypeNewEntities.read(from: &buf),
			detailedClassification: FfiConverterSequenceTypeDetailedManifestClass.read(from: &buf),
			newlyCreatedNonFungibles: FfiConverterSequenceTypeNonFungibleGlobalId.read(from: &buf),
			reservedInstructions: FfiConverterSequenceTypeReservedInstruction.read(from: &buf),
			presentedProofs: FfiConverterSequenceTypeResourceSpecifier.read(from: &buf),
			encounteredAddresses: FfiConverterSequenceTypeManifestEncounteredComponentAddress.read(from: &buf),
			feeLocks: FfiConverterTypeFeeLocks.read(from: &buf),
			feeSummary: FfiConverterTypeFeeSummary.read(from: &buf)
		)
	}

	public static func write(_ value: ExecutionSummary, into buf: inout [UInt8]) {
		FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.write(value.withdrawals, into: &buf)
		FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.write(value.deposits, into: &buf)
		FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsRequiringAuth, into: &buf)
		FfiConverterSequenceTypeIdentityAddress.write(value.addressesOfIdentitiesRequiringAuth, into: &buf)
		FfiConverterTypeNewEntities.write(value.newEntities, into: &buf)
		FfiConverterSequenceTypeDetailedManifestClass.write(value.detailedClassification, into: &buf)
		FfiConverterSequenceTypeNonFungibleGlobalId.write(value.newlyCreatedNonFungibles, into: &buf)
		FfiConverterSequenceTypeReservedInstruction.write(value.reservedInstructions, into: &buf)
		FfiConverterSequenceTypeResourceSpecifier.write(value.presentedProofs, into: &buf)
		FfiConverterSequenceTypeManifestEncounteredComponentAddress.write(value.encounteredAddresses, into: &buf)
		FfiConverterTypeFeeLocks.write(value.feeLocks, into: &buf)
		FfiConverterTypeFeeSummary.write(value.feeSummary, into: &buf)
	}
}

public func FfiConverterTypeExecutionSummary_lift(_ buf: RustBuffer) throws -> ExecutionSummary {
	try FfiConverterTypeExecutionSummary.lift(buf)
}

public func FfiConverterTypeExecutionSummary_lower(_ value: ExecutionSummary) -> RustBuffer {
	FfiConverterTypeExecutionSummary.lower(value)
}

// MARK: - FactorInstance
public struct FactorInstance {
	/**
	 * The ID of the `FactorSource` that was used to produce this
	 * factor instance. We will lookup the `FactorSource` in the
	 * `Profile` and can present user with instruction to re-access
	 * this factor source in order control the `badge`.
	 */
	public var factorSourceId: FactorSourceId
	/**
	 * Either a "physical" badge (NFT) or some source for recreation of a producer
	 * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
	 * is derived which produces virtual badges (signatures).
	 */
	public var badge: FactorInstanceBadge

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The ID of the `FactorSource` that was used to produce this
		 * factor instance. We will lookup the `FactorSource` in the
		 * `Profile` and can present user with instruction to re-access
		 * this factor source in order control the `badge`.
		 */ factorSourceId: FactorSourceId,
		/**
			* Either a "physical" badge (NFT) or some source for recreation of a producer
			* of a virtual badge (signature), e.g. a HD derivation path, from which a private key
			* is derived which produces virtual badges (signatures).
			*/ badge: FactorInstanceBadge
	) {
		self.factorSourceId = factorSourceId
		self.badge = badge
	}
}

// MARK: Sendable
extension FactorInstance: Sendable {}

// MARK: Equatable, Hashable
extension FactorInstance: Equatable, Hashable {
	public static func == (lhs: FactorInstance, rhs: FactorInstance) -> Bool {
		if lhs.factorSourceId != rhs.factorSourceId {
			return false
		}
		if lhs.badge != rhs.badge {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(factorSourceId)
		hasher.combine(badge)
	}
}

// MARK: - FfiConverterTypeFactorInstance
public struct FfiConverterTypeFactorInstance: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstance {
		try FactorInstance(
			factorSourceId: FfiConverterTypeFactorSourceID.read(from: &buf),
			badge: FfiConverterTypeFactorInstanceBadge.read(from: &buf)
		)
	}

	public static func write(_ value: FactorInstance, into buf: inout [UInt8]) {
		FfiConverterTypeFactorSourceID.write(value.factorSourceId, into: &buf)
		FfiConverterTypeFactorInstanceBadge.write(value.badge, into: &buf)
	}
}

public func FfiConverterTypeFactorInstance_lift(_ buf: RustBuffer) throws -> FactorInstance {
	try FfiConverterTypeFactorInstance.lift(buf)
}

public func FfiConverterTypeFactorInstance_lower(_ value: FactorInstance) -> RustBuffer {
	FfiConverterTypeFactorInstance.lower(value)
}

// MARK: - FactorInstanceForDebugPurposes
public struct FactorInstanceForDebugPurposes {
	public var derivationPathFull: String
	public var indexAgnosticDerivationPath: String
	public var publicKeyHex: String
	public var factorSourceId: String
	public var derivationEntityIndex: UInt32
	public var factorSourceKind: FactorSourceKind

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(derivationPathFull: String, indexAgnosticDerivationPath: String, publicKeyHex: String, factorSourceId: String, derivationEntityIndex: UInt32, factorSourceKind: FactorSourceKind) {
		self.derivationPathFull = derivationPathFull
		self.indexAgnosticDerivationPath = indexAgnosticDerivationPath
		self.publicKeyHex = publicKeyHex
		self.factorSourceId = factorSourceId
		self.derivationEntityIndex = derivationEntityIndex
		self.factorSourceKind = factorSourceKind
	}
}

// MARK: Sendable
extension FactorInstanceForDebugPurposes: Sendable {}

// MARK: Equatable, Hashable
extension FactorInstanceForDebugPurposes: Equatable, Hashable {
	public static func == (lhs: FactorInstanceForDebugPurposes, rhs: FactorInstanceForDebugPurposes) -> Bool {
		if lhs.derivationPathFull != rhs.derivationPathFull {
			return false
		}
		if lhs.indexAgnosticDerivationPath != rhs.indexAgnosticDerivationPath {
			return false
		}
		if lhs.publicKeyHex != rhs.publicKeyHex {
			return false
		}
		if lhs.factorSourceId != rhs.factorSourceId {
			return false
		}
		if lhs.derivationEntityIndex != rhs.derivationEntityIndex {
			return false
		}
		if lhs.factorSourceKind != rhs.factorSourceKind {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(derivationPathFull)
		hasher.combine(indexAgnosticDerivationPath)
		hasher.combine(publicKeyHex)
		hasher.combine(factorSourceId)
		hasher.combine(derivationEntityIndex)
		hasher.combine(factorSourceKind)
	}
}

// MARK: - FfiConverterTypeFactorInstanceForDebugPurposes
public struct FfiConverterTypeFactorInstanceForDebugPurposes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceForDebugPurposes {
		try FactorInstanceForDebugPurposes(
			derivationPathFull: FfiConverterString.read(from: &buf),
			indexAgnosticDerivationPath: FfiConverterString.read(from: &buf),
			publicKeyHex: FfiConverterString.read(from: &buf),
			factorSourceId: FfiConverterString.read(from: &buf),
			derivationEntityIndex: FfiConverterUInt32.read(from: &buf),
			factorSourceKind: FfiConverterTypeFactorSourceKind.read(from: &buf)
		)
	}

	public static func write(_ value: FactorInstanceForDebugPurposes, into buf: inout [UInt8]) {
		FfiConverterString.write(value.derivationPathFull, into: &buf)
		FfiConverterString.write(value.indexAgnosticDerivationPath, into: &buf)
		FfiConverterString.write(value.publicKeyHex, into: &buf)
		FfiConverterString.write(value.factorSourceId, into: &buf)
		FfiConverterUInt32.write(value.derivationEntityIndex, into: &buf)
		FfiConverterTypeFactorSourceKind.write(value.factorSourceKind, into: &buf)
	}
}

public func FfiConverterTypeFactorInstanceForDebugPurposes_lift(_ buf: RustBuffer) throws -> FactorInstanceForDebugPurposes {
	try FfiConverterTypeFactorInstanceForDebugPurposes.lift(buf)
}

public func FfiConverterTypeFactorInstanceForDebugPurposes_lower(_ value: FactorInstanceForDebugPurposes) -> RustBuffer {
	FfiConverterTypeFactorInstanceForDebugPurposes.lower(value)
}

// MARK: - FactorSourceCommon
/**
 * Common properties shared between FactorSources of different kinds, describing
 * its state, when added, and supported cryptographic parameters.
 */
public struct FactorSourceCommon {
	/**
	 * Cryptographic parameters a certain FactorSource supports, e.g. Elliptic Curves.
	 *
	 * Since Radix Wallet App version 1.3.0, it is possible to add crypto
	 * parameters to a FactorSource, e.g. when a user with a DeviceFactorSource
	 * with babylon crypto parameters, lets call it `B`, with mnemonic `M` adds
	 * `M` again but as an "Olympia" factor source, then the olympia crypto
	 * parameters are added to `B`.
	 */
	public var cryptoParameters: FactorSourceCryptoParameters
	/**
	 * When this factor source for originally added by the user.
	 */
	public var addedOn: Timestamp
	/**
	 * Date of last usage of this factor source
	 *
	 * This is the only mutable property, it is mutable
	 * since we will update it every time this FactorSource
	 * is used.
	 */
	public var lastUsedOn: Timestamp
	/**
	 * Flags which describe a certain state a FactorSource might be in, e.g. `Main` (BDFS).
	 */
	public var flags: [FactorSourceFlag]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Cryptographic parameters a certain FactorSource supports, e.g. Elliptic Curves.
		 *
		 * Since Radix Wallet App version 1.3.0, it is possible to add crypto
		 * parameters to a FactorSource, e.g. when a user with a DeviceFactorSource
		 * with babylon crypto parameters, lets call it `B`, with mnemonic `M` adds
		 * `M` again but as an "Olympia" factor source, then the olympia crypto
		 * parameters are added to `B`.
		 */ cryptoParameters: FactorSourceCryptoParameters,
		/**
			* When this factor source for originally added by the user.
			*/ addedOn: Timestamp,
		/**
			* Date of last usage of this factor source
			*
			* This is the only mutable property, it is mutable
			* since we will update it every time this FactorSource
			* is used.
			*/ lastUsedOn: Timestamp,
		/**
			* Flags which describe a certain state a FactorSource might be in, e.g. `Main` (BDFS).
			*/ flags: [FactorSourceFlag]
	) {
		self.cryptoParameters = cryptoParameters
		self.addedOn = addedOn
		self.lastUsedOn = lastUsedOn
		self.flags = flags
	}
}

// MARK: Sendable
extension FactorSourceCommon: Sendable {}

// MARK: Equatable, Hashable
extension FactorSourceCommon: Equatable, Hashable {
	public static func == (lhs: FactorSourceCommon, rhs: FactorSourceCommon) -> Bool {
		if lhs.cryptoParameters != rhs.cryptoParameters {
			return false
		}
		if lhs.addedOn != rhs.addedOn {
			return false
		}
		if lhs.lastUsedOn != rhs.lastUsedOn {
			return false
		}
		if lhs.flags != rhs.flags {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(cryptoParameters)
		hasher.combine(addedOn)
		hasher.combine(lastUsedOn)
		hasher.combine(flags)
	}
}

// MARK: - FfiConverterTypeFactorSourceCommon
public struct FfiConverterTypeFactorSourceCommon: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceCommon {
		try FactorSourceCommon(
			cryptoParameters: FfiConverterTypeFactorSourceCryptoParameters.read(from: &buf),
			addedOn: FfiConverterTypeTimestamp.read(from: &buf),
			lastUsedOn: FfiConverterTypeTimestamp.read(from: &buf),
			flags: FfiConverterSequenceTypeFactorSourceFlag.read(from: &buf)
		)
	}

	public static func write(_ value: FactorSourceCommon, into buf: inout [UInt8]) {
		FfiConverterTypeFactorSourceCryptoParameters.write(value.cryptoParameters, into: &buf)
		FfiConverterTypeTimestamp.write(value.addedOn, into: &buf)
		FfiConverterTypeTimestamp.write(value.lastUsedOn, into: &buf)
		FfiConverterSequenceTypeFactorSourceFlag.write(value.flags, into: &buf)
	}
}

public func FfiConverterTypeFactorSourceCommon_lift(_ buf: RustBuffer) throws -> FactorSourceCommon {
	try FfiConverterTypeFactorSourceCommon.lift(buf)
}

public func FfiConverterTypeFactorSourceCommon_lower(_ value: FactorSourceCommon) -> RustBuffer {
	FfiConverterTypeFactorSourceCommon.lower(value)
}

// MARK: - FactorSourceCryptoParameters
/**
 * Cryptographic parameters a certain FactorSource supports, e.g. which Elliptic Curves
 * it supports and which Hierarchical Deterministic (HD) derivations schemes it supports,
 * if any.
 */
public struct FactorSourceCryptoParameters {
	/**
	 * Describes with which Elliptic Curves a Factor Source can be used, e.g. a
	 * "Babylon" `DeviceFactorSource` is not capable of deriving keys on the curve
	 * `secp256k1` - only Olympia imported FactorSources can do that.
	 *
	 * Either `[curve25519]` or `[secp256k1, curve25519]`
	 *
	 * Must not be empty.
	 */
	public var supportedCurves: [Slip10Curve]
	/**
	 * If not empty: Describes which kind of Hierarchical Deterministic (HD)
	 * derivations a FactorSource is capable of doing - if empty: the
	 * FactorSource does not support HD derivation.
	 *
	 * Either BIP44 or CAP26 (SLIP10)
	 */
	public var supportedDerivationPathSchemes: [DerivationPathScheme]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Describes with which Elliptic Curves a Factor Source can be used, e.g. a
		 * "Babylon" `DeviceFactorSource` is not capable of deriving keys on the curve
		 * `secp256k1` - only Olympia imported FactorSources can do that.
		 *
		 * Either `[curve25519]` or `[secp256k1, curve25519]`
		 *
		 * Must not be empty.
		 */ supportedCurves: [Slip10Curve],
		/**
			* If not empty: Describes which kind of Hierarchical Deterministic (HD)
			* derivations a FactorSource is capable of doing - if empty: the
			* FactorSource does not support HD derivation.
			*
			* Either BIP44 or CAP26 (SLIP10)
			*/ supportedDerivationPathSchemes: [DerivationPathScheme]
	) {
		self.supportedCurves = supportedCurves
		self.supportedDerivationPathSchemes = supportedDerivationPathSchemes
	}
}

// MARK: Sendable
extension FactorSourceCryptoParameters: Sendable {}

// MARK: Equatable, Hashable
extension FactorSourceCryptoParameters: Equatable, Hashable {
	public static func == (lhs: FactorSourceCryptoParameters, rhs: FactorSourceCryptoParameters) -> Bool {
		if lhs.supportedCurves != rhs.supportedCurves {
			return false
		}
		if lhs.supportedDerivationPathSchemes != rhs.supportedDerivationPathSchemes {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(supportedCurves)
		hasher.combine(supportedDerivationPathSchemes)
	}
}

// MARK: - FfiConverterTypeFactorSourceCryptoParameters
public struct FfiConverterTypeFactorSourceCryptoParameters: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceCryptoParameters {
		try FactorSourceCryptoParameters(
			supportedCurves: FfiConverterSequenceTypeSLIP10Curve.read(from: &buf),
			supportedDerivationPathSchemes: FfiConverterSequenceTypeDerivationPathScheme.read(from: &buf)
		)
	}

	public static func write(_ value: FactorSourceCryptoParameters, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeSLIP10Curve.write(value.supportedCurves, into: &buf)
		FfiConverterSequenceTypeDerivationPathScheme.write(value.supportedDerivationPathSchemes, into: &buf)
	}
}

public func FfiConverterTypeFactorSourceCryptoParameters_lift(_ buf: RustBuffer) throws -> FactorSourceCryptoParameters {
	try FfiConverterTypeFactorSourceCryptoParameters.lift(buf)
}

public func FfiConverterTypeFactorSourceCryptoParameters_lower(_ value: FactorSourceCryptoParameters) -> RustBuffer {
	FfiConverterTypeFactorSourceCryptoParameters.lower(value)
}

// MARK: - FactorSourceIdFromAddress
/**
 * FactorSourceID from an AccountAddress, typically used by `trustedContact` FactorSource.
 */
public struct FactorSourceIdFromAddress {
	/**
	 * The kind of the FactorSource this ID refers to, typically `trustedContact`.
	 */
	public var kind: FactorSourceKind
	/**
	 * An account address which the FactorSource this ID refers uses/needs.
	 */
	public var body: AccountAddress

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The kind of the FactorSource this ID refers to, typically `trustedContact`.
		 */ kind: FactorSourceKind,
		/**
			* An account address which the FactorSource this ID refers uses/needs.
			*/ body: AccountAddress
	) {
		self.kind = kind
		self.body = body
	}
}

// MARK: Sendable
extension FactorSourceIdFromAddress: Sendable {}

// MARK: Equatable, Hashable
extension FactorSourceIdFromAddress: Equatable, Hashable {
	public static func == (lhs: FactorSourceIdFromAddress, rhs: FactorSourceIdFromAddress) -> Bool {
		if lhs.kind != rhs.kind {
			return false
		}
		if lhs.body != rhs.body {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(kind)
		hasher.combine(body)
	}
}

// MARK: - FfiConverterTypeFactorSourceIDFromAddress
public struct FfiConverterTypeFactorSourceIDFromAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIdFromAddress {
		try FactorSourceIdFromAddress(
			kind: FfiConverterTypeFactorSourceKind.read(from: &buf),
			body: FfiConverterTypeAccountAddress.read(from: &buf)
		)
	}

	public static func write(_ value: FactorSourceIdFromAddress, into buf: inout [UInt8]) {
		FfiConverterTypeFactorSourceKind.write(value.kind, into: &buf)
		FfiConverterTypeAccountAddress.write(value.body, into: &buf)
	}
}

public func FfiConverterTypeFactorSourceIDFromAddress_lift(_ buf: RustBuffer) throws -> FactorSourceIdFromAddress {
	try FfiConverterTypeFactorSourceIDFromAddress.lift(buf)
}

public func FfiConverterTypeFactorSourceIDFromAddress_lower(_ value: FactorSourceIdFromAddress) -> RustBuffer {
	FfiConverterTypeFactorSourceIDFromAddress.lower(value)
}

// MARK: - FactorSourceIdFromHash
/**
 * FactorSourceID from the blake2b hash of the special HD public key derived at `CAP26::GetID`,
 * for a certain `FactorSourceKind`
 */
public struct FactorSourceIdFromHash {
	/**
	 * The kind of the FactorSource this ID refers to, typically `device` or `ledger`.
	 */
	public var kind: FactorSourceKind
	/**
	 * The blake2b hash of the special HD public key derived at `CAP26::GetID`.
	 */
	public var body: Exactly32Bytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The kind of the FactorSource this ID refers to, typically `device` or `ledger`.
		 */ kind: FactorSourceKind,
		/**
			* The blake2b hash of the special HD public key derived at `CAP26::GetID`.
			*/ body: Exactly32Bytes
	) {
		self.kind = kind
		self.body = body
	}
}

// MARK: Sendable
extension FactorSourceIdFromHash: Sendable {}

// MARK: Equatable, Hashable
extension FactorSourceIdFromHash: Equatable, Hashable {
	public static func == (lhs: FactorSourceIdFromHash, rhs: FactorSourceIdFromHash) -> Bool {
		if lhs.kind != rhs.kind {
			return false
		}
		if lhs.body != rhs.body {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(kind)
		hasher.combine(body)
	}
}

// MARK: - FfiConverterTypeFactorSourceIDFromHash
public struct FfiConverterTypeFactorSourceIDFromHash: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIdFromHash {
		try FactorSourceIdFromHash(
			kind: FfiConverterTypeFactorSourceKind.read(from: &buf),
			body: FfiConverterTypeExactly32Bytes.read(from: &buf)
		)
	}

	public static func write(_ value: FactorSourceIdFromHash, into buf: inout [UInt8]) {
		FfiConverterTypeFactorSourceKind.write(value.kind, into: &buf)
		FfiConverterTypeExactly32Bytes.write(value.body, into: &buf)
	}
}

public func FfiConverterTypeFactorSourceIDFromHash_lift(_ buf: RustBuffer) throws -> FactorSourceIdFromHash {
	try FfiConverterTypeFactorSourceIDFromHash.lift(buf)
}

public func FfiConverterTypeFactorSourceIDFromHash_lower(_ value: FactorSourceIdFromHash) -> RustBuffer {
	FfiConverterTypeFactorSourceIDFromHash.lower(value)
}

// MARK: - FeeLocks
/**
 * Information on how much fees were contingent and how much were not.
 */
public struct FeeLocks {
	public var lock: Decimal192
	public var contingentLock: Decimal192

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(lock: Decimal192, contingentLock: Decimal192) {
		self.lock = lock
		self.contingentLock = contingentLock
	}
}

// MARK: Sendable
extension FeeLocks: Sendable {}

// MARK: Equatable, Hashable
extension FeeLocks: Equatable, Hashable {
	public static func == (lhs: FeeLocks, rhs: FeeLocks) -> Bool {
		if lhs.lock != rhs.lock {
			return false
		}
		if lhs.contingentLock != rhs.contingentLock {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(lock)
		hasher.combine(contingentLock)
	}
}

// MARK: - FfiConverterTypeFeeLocks
public struct FfiConverterTypeFeeLocks: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeLocks {
		try FeeLocks(
			lock: FfiConverterTypeDecimal192.read(from: &buf),
			contingentLock: FfiConverterTypeDecimal192.read(from: &buf)
		)
	}

	public static func write(_ value: FeeLocks, into buf: inout [UInt8]) {
		FfiConverterTypeDecimal192.write(value.lock, into: &buf)
		FfiConverterTypeDecimal192.write(value.contingentLock, into: &buf)
	}
}

public func FfiConverterTypeFeeLocks_lift(_ buf: RustBuffer) throws -> FeeLocks {
	try FfiConverterTypeFeeLocks.lift(buf)
}

public func FfiConverterTypeFeeLocks_lower(_ value: FeeLocks) -> RustBuffer {
	FfiConverterTypeFeeLocks.lower(value)
}

// MARK: - FeeSummary
/**
 * Detailed information on the amount of cost units consumed.
 */
public struct FeeSummary {
	public var executionCost: Decimal192
	public var finalizationCost: Decimal192
	public var royaltyCost: Decimal192
	public var storageExpansionCost: Decimal192

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(executionCost: Decimal192, finalizationCost: Decimal192, royaltyCost: Decimal192, storageExpansionCost: Decimal192) {
		self.executionCost = executionCost
		self.finalizationCost = finalizationCost
		self.royaltyCost = royaltyCost
		self.storageExpansionCost = storageExpansionCost
	}
}

// MARK: Sendable
extension FeeSummary: Sendable {}

// MARK: Equatable, Hashable
extension FeeSummary: Equatable, Hashable {
	public static func == (lhs: FeeSummary, rhs: FeeSummary) -> Bool {
		if lhs.executionCost != rhs.executionCost {
			return false
		}
		if lhs.finalizationCost != rhs.finalizationCost {
			return false
		}
		if lhs.royaltyCost != rhs.royaltyCost {
			return false
		}
		if lhs.storageExpansionCost != rhs.storageExpansionCost {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(executionCost)
		hasher.combine(finalizationCost)
		hasher.combine(royaltyCost)
		hasher.combine(storageExpansionCost)
	}
}

// MARK: - FfiConverterTypeFeeSummary
public struct FfiConverterTypeFeeSummary: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSummary {
		try FeeSummary(
			executionCost: FfiConverterTypeDecimal192.read(from: &buf),
			finalizationCost: FfiConverterTypeDecimal192.read(from: &buf),
			royaltyCost: FfiConverterTypeDecimal192.read(from: &buf),
			storageExpansionCost: FfiConverterTypeDecimal192.read(from: &buf)
		)
	}

	public static func write(_ value: FeeSummary, into buf: inout [UInt8]) {
		FfiConverterTypeDecimal192.write(value.executionCost, into: &buf)
		FfiConverterTypeDecimal192.write(value.finalizationCost, into: &buf)
		FfiConverterTypeDecimal192.write(value.royaltyCost, into: &buf)
		FfiConverterTypeDecimal192.write(value.storageExpansionCost, into: &buf)
	}
}

public func FfiConverterTypeFeeSummary_lift(_ buf: RustBuffer) throws -> FeeSummary {
	try FfiConverterTypeFeeSummary.lift(buf)
}

public func FfiConverterTypeFeeSummary_lower(_ value: FeeSummary) -> RustBuffer {
	FfiConverterTypeFeeSummary.lower(value)
}

// MARK: - Gateway
/**
 * A gateway to some Radix Network, which is a high level REST API which clients (wallets) can
 * consume in order to query asset balances and submit transactions.
 */
public struct Gateway {
	/**
	 * The Radix network the API is a Gateway to.
	 */
	public var network: NetworkDefinition
	/**
	 * The URL to the gateways API endpoint
	 */
	public var url: Url

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The Radix network the API is a Gateway to.
		 */ network: NetworkDefinition,
		/**
			* The URL to the gateways API endpoint
			*/ url: Url
	) {
		self.network = network
		self.url = url
	}
}

// MARK: Sendable
extension Gateway: Sendable {}

// MARK: Equatable, Hashable
extension Gateway: Equatable, Hashable {
	public static func == (lhs: Gateway, rhs: Gateway) -> Bool {
		if lhs.network != rhs.network {
			return false
		}
		if lhs.url != rhs.url {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(network)
		hasher.combine(url)
	}
}

// MARK: - FfiConverterTypeGateway
public struct FfiConverterTypeGateway: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Gateway {
		try Gateway(
			network: FfiConverterTypeNetworkDefinition.read(from: &buf),
			url: FfiConverterTypeUrl.read(from: &buf)
		)
	}

	public static func write(_ value: Gateway, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkDefinition.write(value.network, into: &buf)
		FfiConverterTypeUrl.write(value.url, into: &buf)
	}
}

public func FfiConverterTypeGateway_lift(_ buf: RustBuffer) throws -> Gateway {
	try FfiConverterTypeGateway.lift(buf)
}

public func FfiConverterTypeGateway_lower(_ value: Gateway) -> RustBuffer {
	FfiConverterTypeGateway.lower(value)
}

// MARK: - HdPath
public struct HdPath {
	public var components: [HdPathComponent]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(components: [HdPathComponent]) {
		self.components = components
	}
}

// MARK: Sendable
extension HdPath: Sendable {}

// MARK: Equatable, Hashable
extension HdPath: Equatable, Hashable {
	public static func == (lhs: HdPath, rhs: HdPath) -> Bool {
		if lhs.components != rhs.components {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(components)
	}
}

// MARK: - FfiConverterTypeHDPath
public struct FfiConverterTypeHDPath: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdPath {
		try HdPath(
			components: FfiConverterSequenceTypeHDPathComponent.read(from: &buf)
		)
	}

	public static func write(_ value: HdPath, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeHDPathComponent.write(value.components, into: &buf)
	}
}

public func FfiConverterTypeHDPath_lift(_ buf: RustBuffer) throws -> HdPath {
	try FfiConverterTypeHDPath.lift(buf)
}

public func FfiConverterTypeHDPath_lower(_ value: HdPath) -> RustBuffer {
	FfiConverterTypeHDPath.lower(value)
}

// MARK: - Hash
/**
 * Represents a 32-byte hash digest.
 *
 * Made UniFFI convertible via HashSecretMagic,
 * exposed in Swift/Kotlin as its own struct/data class, with
 * hidden secret magic.
 */
public struct Hash {
	public var value: Exactly32Bytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: Exactly32Bytes) {
		self.value = value
	}
}

// MARK: Sendable
extension Hash: Sendable {}

// MARK: Equatable, Hashable
extension Hash: Equatable, Hashable {
	public static func == (lhs: Hash, rhs: Hash) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeHash
public struct FfiConverterTypeHash: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hash {
		try Hash(
			value: FfiConverterTypeExactly32Bytes.read(from: &buf)
		)
	}

	public static func write(_ value: Hash, into buf: inout [UInt8]) {
		FfiConverterTypeExactly32Bytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeHash_lift(_ buf: RustBuffer) throws -> Hash {
	try FfiConverterTypeHash.lift(buf)
}

public func FfiConverterTypeHash_lower(_ value: Hash) -> RustBuffer {
	FfiConverterTypeHash.lower(value)
}

// MARK: - Header
/**
 * The header of a Profile(Snapshot) contains crucial metadata
 * about this Profile, such as which JSON data format it is
 * compatible with and which device was used to create it and
 * a hint about its contents.
 */
public struct Header {
	/**
	 * A versioning number that is increased when breaking
	 * changes is made to ProfileSnapshot JSON data format.
	 */
	public var snapshotVersion: ProfileSnapshotVersion
	/**
	 * An immutable and unique identifier of a Profile.
	 */
	public var id: ProfileId
	/**
	 * The device which was used to create the Profile.
	 */
	public var creatingDevice: DeviceInfo
	/**
	 * The device on which the profile was last used.
	 */
	public var lastUsedOnDevice: DeviceInfo
	/**
	 * When the Profile was last modified.
	 */
	public var lastModified: Timestamp
	/**
	 * Hint about the contents of the profile, e.g. number of Accounts and Personas.
	 */
	public var contentHint: ContentHint

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * A versioning number that is increased when breaking
		 * changes is made to ProfileSnapshot JSON data format.
		 */ snapshotVersion: ProfileSnapshotVersion,
		/**
			* An immutable and unique identifier of a Profile.
			*/ id: ProfileId,
		/**
			* The device which was used to create the Profile.
			*/ creatingDevice: DeviceInfo,
		/**
			* The device on which the profile was last used.
			*/ lastUsedOnDevice: DeviceInfo,
		/**
			* When the Profile was last modified.
			*/ lastModified: Timestamp,
		/**
			* Hint about the contents of the profile, e.g. number of Accounts and Personas.
			*/ contentHint: ContentHint
	) {
		self.snapshotVersion = snapshotVersion
		self.id = id
		self.creatingDevice = creatingDevice
		self.lastUsedOnDevice = lastUsedOnDevice
		self.lastModified = lastModified
		self.contentHint = contentHint
	}
}

// MARK: Sendable
extension Header: Sendable {}

// MARK: Equatable, Hashable
extension Header: Equatable, Hashable {
	public static func == (lhs: Header, rhs: Header) -> Bool {
		if lhs.snapshotVersion != rhs.snapshotVersion {
			return false
		}
		if lhs.id != rhs.id {
			return false
		}
		if lhs.creatingDevice != rhs.creatingDevice {
			return false
		}
		if lhs.lastUsedOnDevice != rhs.lastUsedOnDevice {
			return false
		}
		if lhs.lastModified != rhs.lastModified {
			return false
		}
		if lhs.contentHint != rhs.contentHint {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(snapshotVersion)
		hasher.combine(id)
		hasher.combine(creatingDevice)
		hasher.combine(lastUsedOnDevice)
		hasher.combine(lastModified)
		hasher.combine(contentHint)
	}
}

// MARK: - FfiConverterTypeHeader
public struct FfiConverterTypeHeader: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Header {
		try Header(
			snapshotVersion: FfiConverterTypeProfileSnapshotVersion.read(from: &buf),
			id: FfiConverterTypeProfileID.read(from: &buf),
			creatingDevice: FfiConverterTypeDeviceInfo.read(from: &buf),
			lastUsedOnDevice: FfiConverterTypeDeviceInfo.read(from: &buf),
			lastModified: FfiConverterTypeTimestamp.read(from: &buf),
			contentHint: FfiConverterTypeContentHint.read(from: &buf)
		)
	}

	public static func write(_ value: Header, into buf: inout [UInt8]) {
		FfiConverterTypeProfileSnapshotVersion.write(value.snapshotVersion, into: &buf)
		FfiConverterTypeProfileID.write(value.id, into: &buf)
		FfiConverterTypeDeviceInfo.write(value.creatingDevice, into: &buf)
		FfiConverterTypeDeviceInfo.write(value.lastUsedOnDevice, into: &buf)
		FfiConverterTypeTimestamp.write(value.lastModified, into: &buf)
		FfiConverterTypeContentHint.write(value.contentHint, into: &buf)
	}
}

public func FfiConverterTypeHeader_lift(_ buf: RustBuffer) throws -> Header {
	try FfiConverterTypeHeader.lift(buf)
}

public func FfiConverterTypeHeader_lower(_ value: Header) -> RustBuffer {
	FfiConverterTypeHeader.lower(value)
}

// MARK: - HiddenConstructor
public struct HiddenConstructor {
	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init() {}
}

// MARK: Sendable
extension HiddenConstructor: Sendable {}

// MARK: Equatable, Hashable
extension HiddenConstructor: Equatable, Hashable {
	public static func == (lhs: HiddenConstructor, rhs: HiddenConstructor) -> Bool {
		true
	}

	public func hash(into hasher: inout Hasher) {}
}

// MARK: - FfiConverterTypeHiddenConstructor
public struct FfiConverterTypeHiddenConstructor: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HiddenConstructor {
		HiddenConstructor()
	}

	public static func write(_ value: HiddenConstructor, into buf: inout [UInt8]) {}
}

public func FfiConverterTypeHiddenConstructor_lift(_ buf: RustBuffer) throws -> HiddenConstructor {
	try FfiConverterTypeHiddenConstructor.lift(buf)
}

public func FfiConverterTypeHiddenConstructor_lower(_ value: HiddenConstructor) -> RustBuffer {
	FfiConverterTypeHiddenConstructor.lower(value)
}

// MARK: - HierarchicalDeterministicFactorInstance
/**
 * A virtual hierarchical deterministic `FactorInstance`
 */
public struct HierarchicalDeterministicFactorInstance {
	public var factorSourceId: FactorSourceIdFromHash
	public var publicKey: HierarchicalDeterministicPublicKey

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(factorSourceId: FactorSourceIdFromHash, publicKey: HierarchicalDeterministicPublicKey) {
		self.factorSourceId = factorSourceId
		self.publicKey = publicKey
	}
}

// MARK: Sendable
extension HierarchicalDeterministicFactorInstance: Sendable {}

// MARK: Equatable, Hashable
extension HierarchicalDeterministicFactorInstance: Equatable, Hashable {
	public static func == (lhs: HierarchicalDeterministicFactorInstance, rhs: HierarchicalDeterministicFactorInstance) -> Bool {
		if lhs.factorSourceId != rhs.factorSourceId {
			return false
		}
		if lhs.publicKey != rhs.publicKey {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(factorSourceId)
		hasher.combine(publicKey)
	}
}

// MARK: - FfiConverterTypeHierarchicalDeterministicFactorInstance
public struct FfiConverterTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HierarchicalDeterministicFactorInstance {
		try HierarchicalDeterministicFactorInstance(
			factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
			publicKey: FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf)
		)
	}

	public static func write(_ value: HierarchicalDeterministicFactorInstance, into buf: inout [UInt8]) {
		FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
		FfiConverterTypeHierarchicalDeterministicPublicKey.write(value.publicKey, into: &buf)
	}
}

public func FfiConverterTypeHierarchicalDeterministicFactorInstance_lift(_ buf: RustBuffer) throws -> HierarchicalDeterministicFactorInstance {
	try FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(buf)
}

public func FfiConverterTypeHierarchicalDeterministicFactorInstance_lower(_ value: HierarchicalDeterministicFactorInstance) -> RustBuffer {
	FfiConverterTypeHierarchicalDeterministicFactorInstance.lower(value)
}

// MARK: - HierarchicalDeterministicPublicKey
/**
 * The **source** of a virtual hierarchical deterministic badge, contains a
 * derivation path and public key, from which a private key is derived which
 * produces virtual badges (signatures).
 *
 * The `.device` `FactorSource` produces `FactorInstance`s with this kind if badge source.
 */
public struct HierarchicalDeterministicPublicKey {
	/**
	 * The expected public key of the private key derived at `derivationPath`
	 */
	public var publicKey: PublicKey
	/**
	 * The HD derivation path for the key pair which produces virtual badges (signatures).
	 */
	public var derivationPath: DerivationPath

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The expected public key of the private key derived at `derivationPath`
		 */ publicKey: PublicKey,
		/**
			* The HD derivation path for the key pair which produces virtual badges (signatures).
			*/ derivationPath: DerivationPath
	) {
		self.publicKey = publicKey
		self.derivationPath = derivationPath
	}
}

// MARK: Sendable
extension HierarchicalDeterministicPublicKey: Sendable {}

// MARK: Equatable, Hashable
extension HierarchicalDeterministicPublicKey: Equatable, Hashable {
	public static func == (lhs: HierarchicalDeterministicPublicKey, rhs: HierarchicalDeterministicPublicKey) -> Bool {
		if lhs.publicKey != rhs.publicKey {
			return false
		}
		if lhs.derivationPath != rhs.derivationPath {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(publicKey)
		hasher.combine(derivationPath)
	}
}

// MARK: - FfiConverterTypeHierarchicalDeterministicPublicKey
public struct FfiConverterTypeHierarchicalDeterministicPublicKey: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HierarchicalDeterministicPublicKey {
		try HierarchicalDeterministicPublicKey(
			publicKey: FfiConverterTypePublicKey.read(from: &buf),
			derivationPath: FfiConverterTypeDerivationPath.read(from: &buf)
		)
	}

	public static func write(_ value: HierarchicalDeterministicPublicKey, into buf: inout [UInt8]) {
		FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
		FfiConverterTypeDerivationPath.write(value.derivationPath, into: &buf)
	}
}

public func FfiConverterTypeHierarchicalDeterministicPublicKey_lift(_ buf: RustBuffer) throws -> HierarchicalDeterministicPublicKey {
	try FfiConverterTypeHierarchicalDeterministicPublicKey.lift(buf)
}

public func FfiConverterTypeHierarchicalDeterministicPublicKey_lower(_ value: HierarchicalDeterministicPublicKey) -> RustBuffer {
	FfiConverterTypeHierarchicalDeterministicPublicKey.lower(value)
}

// MARK: - HostId
public struct HostId {
	/**
	 * A best effort stable and unique identifier of this
	 * host's device.
	 */
	public var id: DeviceId
	/**
	 * The date this id of the device was generated, might
	 * be equal to when the app was first ever launched on the
	 * device.
	 */
	public var generatedAt: Timestamp

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * A best effort stable and unique identifier of this
		 * host's device.
		 */ id: DeviceId,
		/**
			* The date this id of the device was generated, might
			* be equal to when the app was first ever launched on the
			* device.
			*/ generatedAt: Timestamp
	) {
		self.id = id
		self.generatedAt = generatedAt
	}
}

// MARK: Sendable
extension HostId: Sendable {}

// MARK: Equatable, Hashable
extension HostId: Equatable, Hashable {
	public static func == (lhs: HostId, rhs: HostId) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.generatedAt != rhs.generatedAt {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(generatedAt)
	}
}

// MARK: - FfiConverterTypeHostId
public struct FfiConverterTypeHostId: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostId {
		try HostId(
			id: FfiConverterTypeDeviceID.read(from: &buf),
			generatedAt: FfiConverterTypeTimestamp.read(from: &buf)
		)
	}

	public static func write(_ value: HostId, into buf: inout [UInt8]) {
		FfiConverterTypeDeviceID.write(value.id, into: &buf)
		FfiConverterTypeTimestamp.write(value.generatedAt, into: &buf)
	}
}

public func FfiConverterTypeHostId_lift(_ buf: RustBuffer) throws -> HostId {
	try FfiConverterTypeHostId.lift(buf)
}

public func FfiConverterTypeHostId_lower(_ value: HostId) -> RustBuffer {
	FfiConverterTypeHostId.lower(value)
}

// MARK: - HostInfo
public struct HostInfo {
	/**
	 * A short description of the device. The host should
	 * read the device model and a given name from the device
	 * if they are able to.
	 */
	public var description: DeviceInfoDescription
	/**
	 * The **current** os and version of the device's operating system, e.g. "iOS 17.4.1".
	 */
	public var hostOs: HostOs
	/**
	 * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
	 */
	public var hostAppVersion: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * A short description of the device. The host should
		 * read the device model and a given name from the device
		 * if they are able to.
		 */ description: DeviceInfoDescription,
		/**
			* The **current** os and version of the device's operating system, e.g. "iOS 17.4.1".
			*/ hostOs: HostOs,
		/**
			* The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
			*/ hostAppVersion: String
	) {
		self.description = description
		self.hostOs = hostOs
		self.hostAppVersion = hostAppVersion
	}
}

// MARK: Sendable
extension HostInfo: Sendable {}

// MARK: Equatable, Hashable
extension HostInfo: Equatable, Hashable {
	public static func == (lhs: HostInfo, rhs: HostInfo) -> Bool {
		if lhs.description != rhs.description {
			return false
		}
		if lhs.hostOs != rhs.hostOs {
			return false
		}
		if lhs.hostAppVersion != rhs.hostAppVersion {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(description)
		hasher.combine(hostOs)
		hasher.combine(hostAppVersion)
	}
}

// MARK: - FfiConverterTypeHostInfo
public struct FfiConverterTypeHostInfo: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostInfo {
		try HostInfo(
			description: FfiConverterTypeDeviceInfoDescription.read(from: &buf),
			hostOs: FfiConverterTypeHostOS.read(from: &buf),
			hostAppVersion: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: HostInfo, into buf: inout [UInt8]) {
		FfiConverterTypeDeviceInfoDescription.write(value.description, into: &buf)
		FfiConverterTypeHostOS.write(value.hostOs, into: &buf)
		FfiConverterString.write(value.hostAppVersion, into: &buf)
	}
}

public func FfiConverterTypeHostInfo_lift(_ buf: RustBuffer) throws -> HostInfo {
	try FfiConverterTypeHostInfo.lift(buf)
}

public func FfiConverterTypeHostInfo_lower(_ value: HostInfo) -> RustBuffer {
	FfiConverterTypeHostInfo.lower(value)
}

// MARK: - IdentityAddress
/**
 * Human readable address of an identity, which are used by Personas. Always starts with
 * the prefix `"identity_"`, for example:
 *
 * `identity_rdx12tgzjrz9u0xz4l28vf04hz87eguclmfaq4d2p8f8lv7zg9ssnzku8j`
 *
 * Addresses are checksummed, as per Bech32. **Only** *Identity* addresses starts with
 * the prefix `"identity_"`.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of IdentityAddresses:
 * * GlobalIdentity,
 * * GlobalVirtualSecp256k1Identity,
 * * GlobalVirtualEd25519Identity
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert_eq!(
 * "identity_rdx12tgzjrz9u0xz4l28vf04hz87eguclmfaq4d2p8f8lv7zg9ssnzku8j".parse::<IdentityAddress>().unwrap().network_id(),
 * NetworkID::Mainnet
 * );
 * ```
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalIdentityAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L229-L234
 */
public struct IdentityAddress {
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension IdentityAddress: Sendable {}

// MARK: Equatable, Hashable
extension IdentityAddress: Equatable, Hashable {
	public static func == (lhs: IdentityAddress, rhs: IdentityAddress) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeIdentityAddress
public struct FfiConverterTypeIdentityAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityAddress {
		try IdentityAddress(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: IdentityAddress, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeIdentityAddress_lift(_ buf: RustBuffer) throws -> IdentityAddress {
	try FfiConverterTypeIdentityAddress.lift(buf)
}

public func FfiConverterTypeIdentityAddress_lower(_ value: IdentityAddress) -> RustBuffer {
	FfiConverterTypeIdentityAddress.lower(value)
}

// MARK: - IdentityPath
public struct IdentityPath {
	public var networkId: NetworkId
	public var keyKind: Cap26KeyKind
	public var index: Hardened

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(networkId: NetworkId, keyKind: Cap26KeyKind, index: Hardened) {
		self.networkId = networkId
		self.keyKind = keyKind
		self.index = index
	}
}

// MARK: Sendable
extension IdentityPath: Sendable {}

// MARK: Equatable, Hashable
extension IdentityPath: Equatable, Hashable {
	public static func == (lhs: IdentityPath, rhs: IdentityPath) -> Bool {
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.keyKind != rhs.keyKind {
			return false
		}
		if lhs.index != rhs.index {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(networkId)
		hasher.combine(keyKind)
		hasher.combine(index)
	}
}

// MARK: - FfiConverterTypeIdentityPath
public struct FfiConverterTypeIdentityPath: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityPath {
		try IdentityPath(
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			keyKind: FfiConverterTypeCAP26KeyKind.read(from: &buf),
			index: FfiConverterTypeHardened.read(from: &buf)
		)
	}

	public static func write(_ value: IdentityPath, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeCAP26KeyKind.write(value.keyKind, into: &buf)
		FfiConverterTypeHardened.write(value.index, into: &buf)
	}
}

public func FfiConverterTypeIdentityPath_lift(_ buf: RustBuffer) throws -> IdentityPath {
	try FfiConverterTypeIdentityPath.lift(buf)
}

public func FfiConverterTypeIdentityPath_lower(_ value: IdentityPath) -> RustBuffer {
	FfiConverterTypeIdentityPath.lower(value)
}

// MARK: - Instant
/**
 * Represents a Unix timestamp, capturing the seconds since the unix epoch.
 */
public struct Instant {
	public var secondsSinceUnixEpoch: Int64

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(secondsSinceUnixEpoch: Int64) {
		self.secondsSinceUnixEpoch = secondsSinceUnixEpoch
	}
}

// MARK: Sendable
extension Instant: Sendable {}

// MARK: Equatable, Hashable
extension Instant: Equatable, Hashable {
	public static func == (lhs: Instant, rhs: Instant) -> Bool {
		if lhs.secondsSinceUnixEpoch != rhs.secondsSinceUnixEpoch {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secondsSinceUnixEpoch)
	}
}

// MARK: - FfiConverterTypeInstant
public struct FfiConverterTypeInstant: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Instant {
		try Instant(
			secondsSinceUnixEpoch: FfiConverterInt64.read(from: &buf)
		)
	}

	public static func write(_ value: Instant, into buf: inout [UInt8]) {
		FfiConverterInt64.write(value.secondsSinceUnixEpoch, into: &buf)
	}
}

public func FfiConverterTypeInstant_lift(_ buf: RustBuffer) throws -> Instant {
	try FfiConverterTypeInstant.lift(buf)
}

public func FfiConverterTypeInstant_lower(_ value: Instant) -> RustBuffer {
	FfiConverterTypeInstant.lower(value)
}

// MARK: - Instructions
public struct Instructions {
	fileprivate let secretMagic: String
	public var networkId: NetworkId

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String, networkId: NetworkId) {
		self.secretMagic = secretMagic
		self.networkId = networkId
	}
}

// MARK: Sendable
extension Instructions: Sendable {}

// MARK: Equatable, Hashable
extension Instructions: Equatable, Hashable {
	public static func == (lhs: Instructions, rhs: Instructions) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		if lhs.networkId != rhs.networkId {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
		hasher.combine(networkId)
	}
}

// MARK: - FfiConverterTypeInstructions
public struct FfiConverterTypeInstructions: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Instructions {
		try Instructions(
			secretMagic: FfiConverterString.read(from: &buf),
			networkId: FfiConverterTypeNetworkID.read(from: &buf)
		)
	}

	public static func write(_ value: Instructions, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
	}
}

public func FfiConverterTypeInstructions_lift(_ buf: RustBuffer) throws -> Instructions {
	try FfiConverterTypeInstructions.lift(buf)
}

public func FfiConverterTypeInstructions_lower(_ value: Instructions) -> RustBuffer {
	FfiConverterTypeInstructions.lower(value)
}

// MARK: - IntentDiscriminator
/**
 * A random number generated part of an intent header,
 * ensuring every intent is unique even though its
 * transaction manifest might be equal. This intent discriminator is
 * generated by wallets for incoming intents.
 *
 * `IntentDiscriminator` is similar to the `Nonce` used in `TransactionHeader`.
 */
public struct IntentDiscriminator {
	fileprivate let secretMagic: UInt64

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: UInt64) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension IntentDiscriminator: Sendable {}

// MARK: Equatable, Hashable
extension IntentDiscriminator: Equatable, Hashable {
	public static func == (lhs: IntentDiscriminator, rhs: IntentDiscriminator) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeIntentDiscriminator
public struct FfiConverterTypeIntentDiscriminator: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentDiscriminator {
		try IntentDiscriminator(
			secretMagic: FfiConverterUInt64.read(from: &buf)
		)
	}

	public static func write(_ value: IntentDiscriminator, into buf: inout [UInt8]) {
		FfiConverterUInt64.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeIntentDiscriminator_lift(_ buf: RustBuffer) throws -> IntentDiscriminator {
	try FfiConverterTypeIntentDiscriminator.lift(buf)
}

public func FfiConverterTypeIntentDiscriminator_lower(_ value: IntentDiscriminator) -> RustBuffer {
	FfiConverterTypeIntentDiscriminator.lower(value)
}

// MARK: - IntentHeaderV2
/**
 * Represents the header of an intent in V2, containing network ID,
 * epoch range, optional proposer timestamps, and an intent discriminator.
 */
public struct IntentHeaderV2 {
	public var networkId: NetworkId
	public var startEpochInclusive: Epoch
	public var endEpochExclusive: Epoch
	public var minProposerTimestampInclusive: Instant?
	public var maxProposerTimestampExclusive: Instant?
	/**
	 * This field is intended to enable a network user to generate an identical intent with
	 * a new hash. Users can simply set this randomly if they wish to. A u64 is large
	 * enough to avoid any risk of collision over the course of a single epoch anyway.
	 *
	 * This field's name intent_discriminator is the new name for what was the nonce field in
	 * IntentV1. This was poorly named, as it caused confusion with an Ethereum-style nonce.
	 */
	public var intentDiscriminator: IntentDiscriminator

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(networkId: NetworkId, startEpochInclusive: Epoch, endEpochExclusive: Epoch, minProposerTimestampInclusive: Instant?, maxProposerTimestampExclusive: Instant?,
	            /**
	            	* This field is intended to enable a network user to generate an identical intent with
	            	* a new hash. Users can simply set this randomly if they wish to. A u64 is large
	            	* enough to avoid any risk of collision over the course of a single epoch anyway.
	            	*
	            	* This field's name intent_discriminator is the new name for what was the nonce field in
	            	* IntentV1. This was poorly named, as it caused confusion with an Ethereum-style nonce.
	            	*/ intentDiscriminator: IntentDiscriminator)
	{
		self.networkId = networkId
		self.startEpochInclusive = startEpochInclusive
		self.endEpochExclusive = endEpochExclusive
		self.minProposerTimestampInclusive = minProposerTimestampInclusive
		self.maxProposerTimestampExclusive = maxProposerTimestampExclusive
		self.intentDiscriminator = intentDiscriminator
	}
}

// MARK: Sendable
extension IntentHeaderV2: Sendable {}

// MARK: Equatable, Hashable
extension IntentHeaderV2: Equatable, Hashable {
	public static func == (lhs: IntentHeaderV2, rhs: IntentHeaderV2) -> Bool {
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.startEpochInclusive != rhs.startEpochInclusive {
			return false
		}
		if lhs.endEpochExclusive != rhs.endEpochExclusive {
			return false
		}
		if lhs.minProposerTimestampInclusive != rhs.minProposerTimestampInclusive {
			return false
		}
		if lhs.maxProposerTimestampExclusive != rhs.maxProposerTimestampExclusive {
			return false
		}
		if lhs.intentDiscriminator != rhs.intentDiscriminator {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(networkId)
		hasher.combine(startEpochInclusive)
		hasher.combine(endEpochExclusive)
		hasher.combine(minProposerTimestampInclusive)
		hasher.combine(maxProposerTimestampExclusive)
		hasher.combine(intentDiscriminator)
	}
}

// MARK: - FfiConverterTypeIntentHeaderV2
public struct FfiConverterTypeIntentHeaderV2: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentHeaderV2 {
		try IntentHeaderV2(
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			startEpochInclusive: FfiConverterTypeEpoch.read(from: &buf),
			endEpochExclusive: FfiConverterTypeEpoch.read(from: &buf),
			minProposerTimestampInclusive: FfiConverterOptionTypeInstant.read(from: &buf),
			maxProposerTimestampExclusive: FfiConverterOptionTypeInstant.read(from: &buf),
			intentDiscriminator: FfiConverterTypeIntentDiscriminator.read(from: &buf)
		)
	}

	public static func write(_ value: IntentHeaderV2, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeEpoch.write(value.startEpochInclusive, into: &buf)
		FfiConverterTypeEpoch.write(value.endEpochExclusive, into: &buf)
		FfiConverterOptionTypeInstant.write(value.minProposerTimestampInclusive, into: &buf)
		FfiConverterOptionTypeInstant.write(value.maxProposerTimestampExclusive, into: &buf)
		FfiConverterTypeIntentDiscriminator.write(value.intentDiscriminator, into: &buf)
	}
}

public func FfiConverterTypeIntentHeaderV2_lift(_ buf: RustBuffer) throws -> IntentHeaderV2 {
	try FfiConverterTypeIntentHeaderV2.lift(buf)
}

public func FfiConverterTypeIntentHeaderV2_lower(_ value: IntentHeaderV2) -> RustBuffer {
	FfiConverterTypeIntentHeaderV2.lower(value)
}

// MARK: - IntentSignature
public struct IntentSignature {
	public var value: SignatureWithPublicKey

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: SignatureWithPublicKey) {
		self.value = value
	}
}

// MARK: Sendable
extension IntentSignature: Sendable {}

// MARK: Equatable, Hashable
extension IntentSignature: Equatable, Hashable {
	public static func == (lhs: IntentSignature, rhs: IntentSignature) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeIntentSignature
public struct FfiConverterTypeIntentSignature: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentSignature {
		try IntentSignature(
			value: FfiConverterTypeSignatureWithPublicKey.read(from: &buf)
		)
	}

	public static func write(_ value: IntentSignature, into buf: inout [UInt8]) {
		FfiConverterTypeSignatureWithPublicKey.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeIntentSignature_lift(_ buf: RustBuffer) throws -> IntentSignature {
	try FfiConverterTypeIntentSignature.lift(buf)
}

public func FfiConverterTypeIntentSignature_lower(_ value: IntentSignature) -> RustBuffer {
	FfiConverterTypeIntentSignature.lower(value)
}

// MARK: - IntentSignatures
public struct IntentSignatures {
	public var signatures: [IntentSignature]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(signatures: [IntentSignature]) {
		self.signatures = signatures
	}
}

// MARK: Sendable
extension IntentSignatures: Sendable {}

// MARK: Equatable, Hashable
extension IntentSignatures: Equatable, Hashable {
	public static func == (lhs: IntentSignatures, rhs: IntentSignatures) -> Bool {
		if lhs.signatures != rhs.signatures {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(signatures)
	}
}

// MARK: - FfiConverterTypeIntentSignatures
public struct FfiConverterTypeIntentSignatures: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentSignatures {
		try IntentSignatures(
			signatures: FfiConverterSequenceTypeIntentSignature.read(from: &buf)
		)
	}

	public static func write(_ value: IntentSignatures, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeIntentSignature.write(value.signatures, into: &buf)
	}
}

public func FfiConverterTypeIntentSignatures_lift(_ buf: RustBuffer) throws -> IntentSignatures {
	try FfiConverterTypeIntentSignatures.lift(buf)
}

public func FfiConverterTypeIntentSignatures_lower(_ value: IntentSignatures) -> RustBuffer {
	FfiConverterTypeIntentSignatures.lower(value)
}

// MARK: - KeyAgreementPublicKey
/**
 * PublicKey on Curve25519 used for key agreement (ECDH) with some `KeyAgreementPrivateKey`.
 */
public struct KeyAgreementPublicKey {
	public var value: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: BagOfBytes) {
		self.value = value
	}
}

// MARK: Sendable
extension KeyAgreementPublicKey: Sendable {}

// MARK: Equatable, Hashable
extension KeyAgreementPublicKey: Equatable, Hashable {
	public static func == (lhs: KeyAgreementPublicKey, rhs: KeyAgreementPublicKey) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeKeyAgreementPublicKey
public struct FfiConverterTypeKeyAgreementPublicKey: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyAgreementPublicKey {
		try KeyAgreementPublicKey(
			value: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: KeyAgreementPublicKey, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeKeyAgreementPublicKey_lift(_ buf: RustBuffer) throws -> KeyAgreementPublicKey {
	try FfiConverterTypeKeyAgreementPublicKey.lift(buf)
}

public func FfiConverterTypeKeyAgreementPublicKey_lower(_ value: KeyAgreementPublicKey) -> RustBuffer {
	FfiConverterTypeKeyAgreementPublicKey.lower(value)
}

// MARK: - LedgerHardwareWalletFactorSource
public struct LedgerHardwareWalletFactorSource {
	/**
	 * Unique and stable identifier of this factor source, stemming from the
	 * hash of a special child key of the HD root of the mnemonic,
	 * that is secured by the Ledger Hardware Wallet device.
	 */
	public var id: FactorSourceIdFromHash
	/**
	 * Common properties shared between FactorSources of different kinds,
	 * describing its state, when added, and supported cryptographic parameters.
	 */
	public var common: FactorSourceCommon
	/**
	 * Properties describing a LedgerHardwareWalletFactorSource to help user disambiguate between it and another one.
	 */
	public var hint: LedgerHardwareWalletHint

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Unique and stable identifier of this factor source, stemming from the
		 * hash of a special child key of the HD root of the mnemonic,
		 * that is secured by the Ledger Hardware Wallet device.
		 */ id: FactorSourceIdFromHash,
		/**
			* Common properties shared between FactorSources of different kinds,
			* describing its state, when added, and supported cryptographic parameters.
			*/ common: FactorSourceCommon,
		/**
			* Properties describing a LedgerHardwareWalletFactorSource to help user disambiguate between it and another one.
			*/ hint: LedgerHardwareWalletHint
	) {
		self.id = id
		self.common = common
		self.hint = hint
	}
}

// MARK: Sendable
extension LedgerHardwareWalletFactorSource: Sendable {}

// MARK: Equatable, Hashable
extension LedgerHardwareWalletFactorSource: Equatable, Hashable {
	public static func == (lhs: LedgerHardwareWalletFactorSource, rhs: LedgerHardwareWalletFactorSource) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.common != rhs.common {
			return false
		}
		if lhs.hint != rhs.hint {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(common)
		hasher.combine(hint)
	}
}

// MARK: - FfiConverterTypeLedgerHardwareWalletFactorSource
public struct FfiConverterTypeLedgerHardwareWalletFactorSource: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletFactorSource {
		try LedgerHardwareWalletFactorSource(
			id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
			common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
			hint: FfiConverterTypeLedgerHardwareWalletHint.read(from: &buf)
		)
	}

	public static func write(_ value: LedgerHardwareWalletFactorSource, into buf: inout [UInt8]) {
		FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
		FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
		FfiConverterTypeLedgerHardwareWalletHint.write(value.hint, into: &buf)
	}
}

public func FfiConverterTypeLedgerHardwareWalletFactorSource_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletFactorSource {
	try FfiConverterTypeLedgerHardwareWalletFactorSource.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletFactorSource_lower(_ value: LedgerHardwareWalletFactorSource) -> RustBuffer {
	FfiConverterTypeLedgerHardwareWalletFactorSource.lower(value)
}

// MARK: - LedgerHardwareWalletHint
public struct LedgerHardwareWalletHint {
	/**
	 * "Orange, scratched"
	 */
	public var name: String
	/**
	 * E.g. `nanoS+`
	 */
	public var model: LedgerHardwareWalletModel

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * "Orange, scratched"
		 */ name: String,
		/**
			* E.g. `nanoS+`
			*/ model: LedgerHardwareWalletModel
	) {
		self.name = name
		self.model = model
	}
}

// MARK: Sendable
extension LedgerHardwareWalletHint: Sendable {}

// MARK: Equatable, Hashable
extension LedgerHardwareWalletHint: Equatable, Hashable {
	public static func == (lhs: LedgerHardwareWalletHint, rhs: LedgerHardwareWalletHint) -> Bool {
		if lhs.name != rhs.name {
			return false
		}
		if lhs.model != rhs.model {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(name)
		hasher.combine(model)
	}
}

// MARK: - FfiConverterTypeLedgerHardwareWalletHint
public struct FfiConverterTypeLedgerHardwareWalletHint: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletHint {
		try LedgerHardwareWalletHint(
			name: FfiConverterString.read(from: &buf),
			model: FfiConverterTypeLedgerHardwareWalletModel.read(from: &buf)
		)
	}

	public static func write(_ value: LedgerHardwareWalletHint, into buf: inout [UInt8]) {
		FfiConverterString.write(value.name, into: &buf)
		FfiConverterTypeLedgerHardwareWalletModel.write(value.model, into: &buf)
	}
}

public func FfiConverterTypeLedgerHardwareWalletHint_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletHint {
	try FfiConverterTypeLedgerHardwareWalletHint.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletHint_lower(_ value: LedgerHardwareWalletHint) -> RustBuffer {
	FfiConverterTypeLedgerHardwareWalletHint.lower(value)
}

// MARK: - LegacyOlympiaAccountAddress
public struct LegacyOlympiaAccountAddress {
	public var value: Secp256k1PublicKey

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: Secp256k1PublicKey) {
		self.value = value
	}
}

// MARK: Sendable
extension LegacyOlympiaAccountAddress: Sendable {}

// MARK: Equatable, Hashable
extension LegacyOlympiaAccountAddress: Equatable, Hashable {
	public static func == (lhs: LegacyOlympiaAccountAddress, rhs: LegacyOlympiaAccountAddress) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeLegacyOlympiaAccountAddress
public struct FfiConverterTypeLegacyOlympiaAccountAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyOlympiaAccountAddress {
		try LegacyOlympiaAccountAddress(
			value: FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
		)
	}

	public static func write(_ value: LegacyOlympiaAccountAddress, into buf: inout [UInt8]) {
		FfiConverterTypeSecp256k1PublicKey.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeLegacyOlympiaAccountAddress_lift(_ buf: RustBuffer) throws -> LegacyOlympiaAccountAddress {
	try FfiConverterTypeLegacyOlympiaAccountAddress.lift(buf)
}

public func FfiConverterTypeLegacyOlympiaAccountAddress_lower(_ value: LegacyOlympiaAccountAddress) -> RustBuffer {
	FfiConverterTypeLegacyOlympiaAccountAddress.lower(value)
}

// MARK: - LinkConnectionQrData
/**
 * The QR code data scanned from the Connector Extension
 */
public struct LinkConnectionQrData {
	/**
	 * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
	 * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
	 * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
	 */
	public var purpose: RadixConnectPurpose
	/**
	 * Used to be able to re-establish the P2P connection
	 */
	public var password: RadixConnectPassword
	/**
	 * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
	 * Each client keeps a record of linked clients' public keys to prevent duplicate links.
	 * This is the public key of the other client and it also serves as the seed for the link `ID`.
	 */
	public var publicKeyOfOtherParty: Ed25519PublicKey
	/**
	 * Represents a signature produced by Connector Extension by signing the hash of the `password`
	 * with the private key of the `public_key_of_other_party`.
	 */
	public var signature: Ed25519Signature

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
		 * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
		 * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
		 */ purpose: RadixConnectPurpose,
		/**
			* Used to be able to re-establish the P2P connection
			*/ password: RadixConnectPassword,
		/**
			* Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
			* Each client keeps a record of linked clients' public keys to prevent duplicate links.
			* This is the public key of the other client and it also serves as the seed for the link `ID`.
			*/ publicKeyOfOtherParty: Ed25519PublicKey,
		/**
			* Represents a signature produced by Connector Extension by signing the hash of the `password`
			* with the private key of the `public_key_of_other_party`.
			*/ signature: Ed25519Signature
	) {
		self.purpose = purpose
		self.password = password
		self.publicKeyOfOtherParty = publicKeyOfOtherParty
		self.signature = signature
	}
}

// MARK: Sendable
extension LinkConnectionQrData: Sendable {}

// MARK: Equatable, Hashable
extension LinkConnectionQrData: Equatable, Hashable {
	public static func == (lhs: LinkConnectionQrData, rhs: LinkConnectionQrData) -> Bool {
		if lhs.purpose != rhs.purpose {
			return false
		}
		if lhs.password != rhs.password {
			return false
		}
		if lhs.publicKeyOfOtherParty != rhs.publicKeyOfOtherParty {
			return false
		}
		if lhs.signature != rhs.signature {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(purpose)
		hasher.combine(password)
		hasher.combine(publicKeyOfOtherParty)
		hasher.combine(signature)
	}
}

// MARK: - FfiConverterTypeLinkConnectionQRData
public struct FfiConverterTypeLinkConnectionQRData: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LinkConnectionQrData {
		try LinkConnectionQrData(
			purpose: FfiConverterTypeRadixConnectPurpose.read(from: &buf),
			password: FfiConverterTypeRadixConnectPassword.read(from: &buf),
			publicKeyOfOtherParty: FfiConverterTypeEd25519PublicKey.read(from: &buf),
			signature: FfiConverterTypeEd25519Signature.read(from: &buf)
		)
	}

	public static func write(_ value: LinkConnectionQrData, into buf: inout [UInt8]) {
		FfiConverterTypeRadixConnectPurpose.write(value.purpose, into: &buf)
		FfiConverterTypeRadixConnectPassword.write(value.password, into: &buf)
		FfiConverterTypeEd25519PublicKey.write(value.publicKeyOfOtherParty, into: &buf)
		FfiConverterTypeEd25519Signature.write(value.signature, into: &buf)
	}
}

public func FfiConverterTypeLinkConnectionQRData_lift(_ buf: RustBuffer) throws -> LinkConnectionQrData {
	try FfiConverterTypeLinkConnectionQRData.lift(buf)
}

public func FfiConverterTypeLinkConnectionQRData_lower(_ value: LinkConnectionQrData) -> RustBuffer {
	FfiConverterTypeLinkConnectionQRData.lower(value)
}

// MARK: - LocaleConfig
public struct LocaleConfig {
	public var decimalSeparator: String?
	public var groupingSeparator: String?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(decimalSeparator: String?, groupingSeparator: String?) {
		self.decimalSeparator = decimalSeparator
		self.groupingSeparator = groupingSeparator
	}
}

// MARK: Sendable
extension LocaleConfig: Sendable {}

// MARK: Equatable, Hashable
extension LocaleConfig: Equatable, Hashable {
	public static func == (lhs: LocaleConfig, rhs: LocaleConfig) -> Bool {
		if lhs.decimalSeparator != rhs.decimalSeparator {
			return false
		}
		if lhs.groupingSeparator != rhs.groupingSeparator {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(decimalSeparator)
		hasher.combine(groupingSeparator)
	}
}

// MARK: - FfiConverterTypeLocaleConfig
public struct FfiConverterTypeLocaleConfig: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocaleConfig {
		try LocaleConfig(
			decimalSeparator: FfiConverterOptionString.read(from: &buf),
			groupingSeparator: FfiConverterOptionString.read(from: &buf)
		)
	}

	public static func write(_ value: LocaleConfig, into buf: inout [UInt8]) {
		FfiConverterOptionString.write(value.decimalSeparator, into: &buf)
		FfiConverterOptionString.write(value.groupingSeparator, into: &buf)
	}
}

public func FfiConverterTypeLocaleConfig_lift(_ buf: RustBuffer) throws -> LocaleConfig {
	try FfiConverterTypeLocaleConfig.lift(buf)
}

public func FfiConverterTypeLocaleConfig_lower(_ value: LocaleConfig) -> RustBuffer {
	FfiConverterTypeLocaleConfig.lower(value)
}

// MARK: - LockerAddress
/**
 * Addresses to a specific locker, owned by a dApp, holding assets, either fungible or non_fungible,
 * that can be claimed by destined account addresses.
 * Identities cannot own assets so they do not have vaults, but Accounts do, e.g.:
 * e.g.:
 * `"locker_rdx1tz474x29nxxd4k2p2reete9xyz4apawv63dphxkr00qt23vyju49fq"`
 *
 * A `LockerAddress` has the [Scrypto's `EntityType`][entt] `GlobalAccountLocker`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalLockerAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radix-engine-toolkit/blob/476d779fee08ed1e561ac8fc8730a2a404b7de79/crates/radix-engine-toolkit-uniffi/src/common/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/476d779fee08ed1e561ac8fc8730a2a404b7de79/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L262-L265
 */
public struct LockerAddress {
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension LockerAddress: Sendable {}

// MARK: Equatable, Hashable
extension LockerAddress: Equatable, Hashable {
	public static func == (lhs: LockerAddress, rhs: LockerAddress) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeLockerAddress
public struct FfiConverterTypeLockerAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockerAddress {
		try LockerAddress(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: LockerAddress, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeLockerAddress_lift(_ buf: RustBuffer) throws -> LockerAddress {
	try FfiConverterTypeLockerAddress.lift(buf)
}

public func FfiConverterTypeLockerAddress_lower(_ value: LockerAddress) -> RustBuffer {
	FfiConverterTypeLockerAddress.lower(value)
}

// MARK: - ManifestSummary
/**
 * A summary of the manifest
 */
public struct ManifestSummary {
	/**
	 * The withdrawals done in the manifest.
	 */
	public var accountWithdrawals: [AccountAddress: [AccountWithdraw]]
	/**
	 * The deposits done in the manifest.
	 */
	public var accountDeposits: [AccountAddress: AccountDeposits]
	/**
	 * The list of the resources of proofs that were presented in the manifest.
	 */
	public var presentedProofs: [ResourceSpecifier]
	/**
	 * Addresses of accounts withdrawn from in the manifest.
	 */
	public var addressesOfAccountsWithdrawnFrom: [AccountAddress]
	/**
	 * Addresses of accounts deposited into in the manifest.
	 */
	public var addressesOfAccountsDepositedInto: [AccountAddress]
	/**
	 * The set of all the global entities encountered in the manifest. This is
	 * to be primarily used for the "using dApps" section of the wallet's tx
	 * review screen.
	 */
	public var encounteredEntities: [ManifestEncounteredComponentAddress]
	/**
	 * Addresses of accounts encountered in the manifest where privileged
	 * methods were called. The wallets will need to collect signatures
	 * of the accounts of all those addresses, which might be multiple
	 * signatures per Account, if MFA has been setup.
	 */
	public var addressesOfAccountsRequiringAuth: [AccountAddress]
	/**
	 * Addresses of identities (Personas) encountered in the manifest where privileged
	 * methods were called. The wallets will need to collect signatures
	 * of the identities of all those addresses, which might be multiple
	 * signatures per Persona, if MFA has been setup.
	 */
	public var addressesOfPersonasRequiringAuth: [IdentityAddress]
	/**
	 * The set of instructions encountered in the manifest that are reserved
	 * and can only be included in the manifest by the wallet itself.
	 */
	public var reservedInstructions: [ReservedInstruction]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The withdrawals done in the manifest.
		 */ accountWithdrawals: [AccountAddress: [AccountWithdraw]],
		/**
			* The deposits done in the manifest.
			*/ accountDeposits: [AccountAddress: AccountDeposits],
		/**
			* The list of the resources of proofs that were presented in the manifest.
			*/ presentedProofs: [ResourceSpecifier],
		/**
			* Addresses of accounts withdrawn from in the manifest.
			*/ addressesOfAccountsWithdrawnFrom: [AccountAddress],
		/**
			* Addresses of accounts deposited into in the manifest.
			*/ addressesOfAccountsDepositedInto: [AccountAddress],
		/**
			* The set of all the global entities encountered in the manifest. This is
			* to be primarily used for the "using dApps" section of the wallet's tx
			* review screen.
			*/ encounteredEntities: [ManifestEncounteredComponentAddress],
		/**
			* Addresses of accounts encountered in the manifest where privileged
			* methods were called. The wallets will need to collect signatures
			* of the accounts of all those addresses, which might be multiple
			* signatures per Account, if MFA has been setup.
			*/ addressesOfAccountsRequiringAuth: [AccountAddress],
		/**
			* Addresses of identities (Personas) encountered in the manifest where privileged
			* methods were called. The wallets will need to collect signatures
			* of the identities of all those addresses, which might be multiple
			* signatures per Persona, if MFA has been setup.
			*/ addressesOfPersonasRequiringAuth: [IdentityAddress],
		/**
			* The set of instructions encountered in the manifest that are reserved
			* and can only be included in the manifest by the wallet itself.
			*/ reservedInstructions: [ReservedInstruction]
	) {
		self.accountWithdrawals = accountWithdrawals
		self.accountDeposits = accountDeposits
		self.presentedProofs = presentedProofs
		self.addressesOfAccountsWithdrawnFrom = addressesOfAccountsWithdrawnFrom
		self.addressesOfAccountsDepositedInto = addressesOfAccountsDepositedInto
		self.encounteredEntities = encounteredEntities
		self.addressesOfAccountsRequiringAuth = addressesOfAccountsRequiringAuth
		self.addressesOfPersonasRequiringAuth = addressesOfPersonasRequiringAuth
		self.reservedInstructions = reservedInstructions
	}
}

// MARK: Sendable
extension ManifestSummary: Sendable {}

// MARK: Equatable, Hashable
extension ManifestSummary: Equatable, Hashable {
	public static func == (lhs: ManifestSummary, rhs: ManifestSummary) -> Bool {
		if lhs.accountWithdrawals != rhs.accountWithdrawals {
			return false
		}
		if lhs.accountDeposits != rhs.accountDeposits {
			return false
		}
		if lhs.presentedProofs != rhs.presentedProofs {
			return false
		}
		if lhs.addressesOfAccountsWithdrawnFrom != rhs.addressesOfAccountsWithdrawnFrom {
			return false
		}
		if lhs.addressesOfAccountsDepositedInto != rhs.addressesOfAccountsDepositedInto {
			return false
		}
		if lhs.encounteredEntities != rhs.encounteredEntities {
			return false
		}
		if lhs.addressesOfAccountsRequiringAuth != rhs.addressesOfAccountsRequiringAuth {
			return false
		}
		if lhs.addressesOfPersonasRequiringAuth != rhs.addressesOfPersonasRequiringAuth {
			return false
		}
		if lhs.reservedInstructions != rhs.reservedInstructions {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(accountWithdrawals)
		hasher.combine(accountDeposits)
		hasher.combine(presentedProofs)
		hasher.combine(addressesOfAccountsWithdrawnFrom)
		hasher.combine(addressesOfAccountsDepositedInto)
		hasher.combine(encounteredEntities)
		hasher.combine(addressesOfAccountsRequiringAuth)
		hasher.combine(addressesOfPersonasRequiringAuth)
		hasher.combine(reservedInstructions)
	}
}

// MARK: - FfiConverterTypeManifestSummary
public struct FfiConverterTypeManifestSummary: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestSummary {
		try ManifestSummary(
			accountWithdrawals: FfiConverterDictionaryTypeAccountAddressSequenceTypeAccountWithdraw.read(from: &buf),
			accountDeposits: FfiConverterDictionaryTypeAccountAddressTypeAccountDeposits.read(from: &buf),
			presentedProofs: FfiConverterSequenceTypeResourceSpecifier.read(from: &buf),
			addressesOfAccountsWithdrawnFrom: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
			addressesOfAccountsDepositedInto: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
			encounteredEntities: FfiConverterSequenceTypeManifestEncounteredComponentAddress.read(from: &buf),
			addressesOfAccountsRequiringAuth: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
			addressesOfPersonasRequiringAuth: FfiConverterSequenceTypeIdentityAddress.read(from: &buf),
			reservedInstructions: FfiConverterSequenceTypeReservedInstruction.read(from: &buf)
		)
	}

	public static func write(_ value: ManifestSummary, into buf: inout [UInt8]) {
		FfiConverterDictionaryTypeAccountAddressSequenceTypeAccountWithdraw.write(value.accountWithdrawals, into: &buf)
		FfiConverterDictionaryTypeAccountAddressTypeAccountDeposits.write(value.accountDeposits, into: &buf)
		FfiConverterSequenceTypeResourceSpecifier.write(value.presentedProofs, into: &buf)
		FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsWithdrawnFrom, into: &buf)
		FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsDepositedInto, into: &buf)
		FfiConverterSequenceTypeManifestEncounteredComponentAddress.write(value.encounteredEntities, into: &buf)
		FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsRequiringAuth, into: &buf)
		FfiConverterSequenceTypeIdentityAddress.write(value.addressesOfPersonasRequiringAuth, into: &buf)
		FfiConverterSequenceTypeReservedInstruction.write(value.reservedInstructions, into: &buf)
	}
}

public func FfiConverterTypeManifestSummary_lift(_ buf: RustBuffer) throws -> ManifestSummary {
	try FfiConverterTypeManifestSummary.lift(buf)
}

public func FfiConverterTypeManifestSummary_lower(_ value: ManifestSummary) -> RustBuffer {
	FfiConverterTypeManifestSummary.lower(value)
}

// MARK: - MatrixOfFactorInstances
/**
 * A matrix of FactorInstances
 */
public struct MatrixOfFactorInstances {
	/**
	 * Used for Signing transactions
	 */
	public var primaryRole: PrimaryRoleWithFactorInstances
	/**
	 * Used to initiate recovery - resetting the used Security Shield
	 * of an entity.
	 */
	public var recoveryRole: RecoveryRoleWithFactorInstances
	/**
	 * To confirm recovery.
	 */
	public var confirmationRole: ConfirmationRoleWithFactorInstances

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Used for Signing transactions
		 */ primaryRole: PrimaryRoleWithFactorInstances,
		/**
			* Used to initiate recovery - resetting the used Security Shield
			* of an entity.
			*/ recoveryRole: RecoveryRoleWithFactorInstances,
		/**
			* To confirm recovery.
			*/ confirmationRole: ConfirmationRoleWithFactorInstances
	) {
		self.primaryRole = primaryRole
		self.recoveryRole = recoveryRole
		self.confirmationRole = confirmationRole
	}
}

// MARK: Sendable
extension MatrixOfFactorInstances: Sendable {}

// MARK: Equatable, Hashable
extension MatrixOfFactorInstances: Equatable, Hashable {
	public static func == (lhs: MatrixOfFactorInstances, rhs: MatrixOfFactorInstances) -> Bool {
		if lhs.primaryRole != rhs.primaryRole {
			return false
		}
		if lhs.recoveryRole != rhs.recoveryRole {
			return false
		}
		if lhs.confirmationRole != rhs.confirmationRole {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(primaryRole)
		hasher.combine(recoveryRole)
		hasher.combine(confirmationRole)
	}
}

// MARK: - FfiConverterTypeMatrixOfFactorInstances
public struct FfiConverterTypeMatrixOfFactorInstances: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixOfFactorInstances {
		try MatrixOfFactorInstances(
			primaryRole: FfiConverterTypePrimaryRoleWithFactorInstances.read(from: &buf),
			recoveryRole: FfiConverterTypeRecoveryRoleWithFactorInstances.read(from: &buf),
			confirmationRole: FfiConverterTypeConfirmationRoleWithFactorInstances.read(from: &buf)
		)
	}

	public static func write(_ value: MatrixOfFactorInstances, into buf: inout [UInt8]) {
		FfiConverterTypePrimaryRoleWithFactorInstances.write(value.primaryRole, into: &buf)
		FfiConverterTypeRecoveryRoleWithFactorInstances.write(value.recoveryRole, into: &buf)
		FfiConverterTypeConfirmationRoleWithFactorInstances.write(value.confirmationRole, into: &buf)
	}
}

public func FfiConverterTypeMatrixOfFactorInstances_lift(_ buf: RustBuffer) throws -> MatrixOfFactorInstances {
	try FfiConverterTypeMatrixOfFactorInstances.lift(buf)
}

public func FfiConverterTypeMatrixOfFactorInstances_lower(_ value: MatrixOfFactorInstances) -> RustBuffer {
	FfiConverterTypeMatrixOfFactorInstances.lower(value)
}

// MARK: - MatrixOfFactorSourceIDs
public struct MatrixOfFactorSourceIDs {
	/**
	 * Used for Signing transactions
	 */
	public var primaryRole: PrimaryRoleWithFactorSourceIDs
	/**
	 * Used to initiate recovery - resetting the used Security Shield
	 * of an entity.
	 */
	public var recoveryRole: RecoveryRoleWithFactorSourceIDs
	/**
	 * To confirm recovery.
	 */
	public var confirmationRole: ConfirmationRoleWithFactorSourceIDs

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Used for Signing transactions
		 */ primaryRole: PrimaryRoleWithFactorSourceIDs,
		/**
			* Used to initiate recovery - resetting the used Security Shield
			* of an entity.
			*/ recoveryRole: RecoveryRoleWithFactorSourceIDs,
		/**
			* To confirm recovery.
			*/ confirmationRole: ConfirmationRoleWithFactorSourceIDs
	) {
		self.primaryRole = primaryRole
		self.recoveryRole = recoveryRole
		self.confirmationRole = confirmationRole
	}
}

// MARK: Sendable
extension MatrixOfFactorSourceIDs: Sendable {}

// MARK: Equatable, Hashable
extension MatrixOfFactorSourceIDs: Equatable, Hashable {
	public static func == (lhs: MatrixOfFactorSourceIDs, rhs: MatrixOfFactorSourceIDs) -> Bool {
		if lhs.primaryRole != rhs.primaryRole {
			return false
		}
		if lhs.recoveryRole != rhs.recoveryRole {
			return false
		}
		if lhs.confirmationRole != rhs.confirmationRole {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(primaryRole)
		hasher.combine(recoveryRole)
		hasher.combine(confirmationRole)
	}
}

// MARK: - FfiConverterTypeMatrixOfFactorSourceIDs
public struct FfiConverterTypeMatrixOfFactorSourceIDs: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixOfFactorSourceIDs {
		try MatrixOfFactorSourceIDs(
			primaryRole: FfiConverterTypePrimaryRoleWithFactorSourceIDs.read(from: &buf),
			recoveryRole: FfiConverterTypeRecoveryRoleWithFactorSourceIDs.read(from: &buf),
			confirmationRole: FfiConverterTypeConfirmationRoleWithFactorSourceIDs.read(from: &buf)
		)
	}

	public static func write(_ value: MatrixOfFactorSourceIDs, into buf: inout [UInt8]) {
		FfiConverterTypePrimaryRoleWithFactorSourceIDs.write(value.primaryRole, into: &buf)
		FfiConverterTypeRecoveryRoleWithFactorSourceIDs.write(value.recoveryRole, into: &buf)
		FfiConverterTypeConfirmationRoleWithFactorSourceIDs.write(value.confirmationRole, into: &buf)
	}
}

public func FfiConverterTypeMatrixOfFactorSourceIDs_lift(_ buf: RustBuffer) throws -> MatrixOfFactorSourceIDs {
	try FfiConverterTypeMatrixOfFactorSourceIDs.lift(buf)
}

public func FfiConverterTypeMatrixOfFactorSourceIDs_lower(_ value: MatrixOfFactorSourceIDs) -> RustBuffer {
	FfiConverterTypeMatrixOfFactorSourceIDs.lower(value)
}

// MARK: - MatrixOfFactorSources
public struct MatrixOfFactorSources {
	/**
	 * Used for Signing transactions
	 */
	public var primaryRole: PrimaryRoleWithFactorSources
	/**
	 * Used to initiate recovery - resetting the used Security Shield
	 * of an entity.
	 */
	public var recoveryRole: RecoveryRoleWithFactorSources
	/**
	 * To confirm recovery.
	 */
	public var confirmationRole: ConfirmationRoleWithFactorSources

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Used for Signing transactions
		 */ primaryRole: PrimaryRoleWithFactorSources,
		/**
			* Used to initiate recovery - resetting the used Security Shield
			* of an entity.
			*/ recoveryRole: RecoveryRoleWithFactorSources,
		/**
			* To confirm recovery.
			*/ confirmationRole: ConfirmationRoleWithFactorSources
	) {
		self.primaryRole = primaryRole
		self.recoveryRole = recoveryRole
		self.confirmationRole = confirmationRole
	}
}

// MARK: Sendable
extension MatrixOfFactorSources: Sendable {}

// MARK: Equatable, Hashable
extension MatrixOfFactorSources: Equatable, Hashable {
	public static func == (lhs: MatrixOfFactorSources, rhs: MatrixOfFactorSources) -> Bool {
		if lhs.primaryRole != rhs.primaryRole {
			return false
		}
		if lhs.recoveryRole != rhs.recoveryRole {
			return false
		}
		if lhs.confirmationRole != rhs.confirmationRole {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(primaryRole)
		hasher.combine(recoveryRole)
		hasher.combine(confirmationRole)
	}
}

// MARK: - FfiConverterTypeMatrixOfFactorSources
public struct FfiConverterTypeMatrixOfFactorSources: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixOfFactorSources {
		try MatrixOfFactorSources(
			primaryRole: FfiConverterTypePrimaryRoleWithFactorSources.read(from: &buf),
			recoveryRole: FfiConverterTypeRecoveryRoleWithFactorSources.read(from: &buf),
			confirmationRole: FfiConverterTypeConfirmationRoleWithFactorSources.read(from: &buf)
		)
	}

	public static func write(_ value: MatrixOfFactorSources, into buf: inout [UInt8]) {
		FfiConverterTypePrimaryRoleWithFactorSources.write(value.primaryRole, into: &buf)
		FfiConverterTypeRecoveryRoleWithFactorSources.write(value.recoveryRole, into: &buf)
		FfiConverterTypeConfirmationRoleWithFactorSources.write(value.confirmationRole, into: &buf)
	}
}

public func FfiConverterTypeMatrixOfFactorSources_lift(_ buf: RustBuffer) throws -> MatrixOfFactorSources {
	try FfiConverterTypeMatrixOfFactorSources.lift(buf)
}

public func FfiConverterTypeMatrixOfFactorSources_lower(_ value: MatrixOfFactorSources) -> RustBuffer {
	FfiConverterTypeMatrixOfFactorSources.lower(value)
}

// MARK: - Mnemonic
public struct Mnemonic {
	public var words: [Bip39Word]
	public var wordCount: Bip39WordCount
	public var language: Bip39Language

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(words: [Bip39Word], wordCount: Bip39WordCount, language: Bip39Language) {
		self.words = words
		self.wordCount = wordCount
		self.language = language
	}
}

// MARK: Sendable
extension Mnemonic: Sendable {}

// MARK: Equatable, Hashable
extension Mnemonic: Equatable, Hashable {
	public static func == (lhs: Mnemonic, rhs: Mnemonic) -> Bool {
		if lhs.words != rhs.words {
			return false
		}
		if lhs.wordCount != rhs.wordCount {
			return false
		}
		if lhs.language != rhs.language {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(words)
		hasher.combine(wordCount)
		hasher.combine(language)
	}
}

// MARK: - FfiConverterTypeMnemonic
public struct FfiConverterTypeMnemonic: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
		try Mnemonic(
			words: FfiConverterSequenceTypeBIP39Word.read(from: &buf),
			wordCount: FfiConverterTypeBIP39WordCount.read(from: &buf),
			language: FfiConverterTypeBIP39Language.read(from: &buf)
		)
	}

	public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeBIP39Word.write(value.words, into: &buf)
		FfiConverterTypeBIP39WordCount.write(value.wordCount, into: &buf)
		FfiConverterTypeBIP39Language.write(value.language, into: &buf)
	}
}

public func FfiConverterTypeMnemonic_lift(_ buf: RustBuffer) throws -> Mnemonic {
	try FfiConverterTypeMnemonic.lift(buf)
}

public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> RustBuffer {
	FfiConverterTypeMnemonic.lower(value)
}

// MARK: - MnemonicWithPassphrase
/**
 * A BIP39 Mnemonic and BIP39 passphrase - aka "25th word" tuple,
 * from which we can derive a HD Root used for derivation.
 */
public struct MnemonicWithPassphrase {
	public var mnemonic: Mnemonic
	public var passphrase: Bip39Passphrase

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(mnemonic: Mnemonic, passphrase: Bip39Passphrase) {
		self.mnemonic = mnemonic
		self.passphrase = passphrase
	}
}

// MARK: Sendable
extension MnemonicWithPassphrase: Sendable {}

// MARK: Equatable, Hashable
extension MnemonicWithPassphrase: Equatable, Hashable {
	public static func == (lhs: MnemonicWithPassphrase, rhs: MnemonicWithPassphrase) -> Bool {
		if lhs.mnemonic != rhs.mnemonic {
			return false
		}
		if lhs.passphrase != rhs.passphrase {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(mnemonic)
		hasher.combine(passphrase)
	}
}

// MARK: - FfiConverterTypeMnemonicWithPassphrase
public struct FfiConverterTypeMnemonicWithPassphrase: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicWithPassphrase {
		try MnemonicWithPassphrase(
			mnemonic: FfiConverterTypeMnemonic.read(from: &buf),
			passphrase: FfiConverterTypeBIP39Passphrase.read(from: &buf)
		)
	}

	public static func write(_ value: MnemonicWithPassphrase, into buf: inout [UInt8]) {
		FfiConverterTypeMnemonic.write(value.mnemonic, into: &buf)
		FfiConverterTypeBIP39Passphrase.write(value.passphrase, into: &buf)
	}
}

public func FfiConverterTypeMnemonicWithPassphrase_lift(_ buf: RustBuffer) throws -> MnemonicWithPassphrase {
	try FfiConverterTypeMnemonicWithPassphrase.lift(buf)
}

public func FfiConverterTypeMnemonicWithPassphrase_lower(_ value: MnemonicWithPassphrase) -> RustBuffer {
	FfiConverterTypeMnemonicWithPassphrase.lower(value)
}

// MARK: - NetworkDefinition
/**
 * A version of the Radix Network, for a NetworkID with an identifier (name) and display description (display name)
 */
public struct NetworkDefinition {
	/**
	 * A String identifier (always lowercase) with the name of the Network that MUST match what Gateway returns.
	 */
	public var logicalName: String
	/**
	 * The canonical identifier of this network.
	 */
	public var id: NetworkId
	/**
	 * A name of the network intended for display purposes only.
	 */
	public var displayDescription: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * A String identifier (always lowercase) with the name of the Network that MUST match what Gateway returns.
		 */ logicalName: String,
		/**
			* The canonical identifier of this network.
			*/ id: NetworkId,
		/**
			* A name of the network intended for display purposes only.
			*/ displayDescription: String
	) {
		self.logicalName = logicalName
		self.id = id
		self.displayDescription = displayDescription
	}
}

// MARK: Sendable
extension NetworkDefinition: Sendable {}

// MARK: Equatable, Hashable
extension NetworkDefinition: Equatable, Hashable {
	public static func == (lhs: NetworkDefinition, rhs: NetworkDefinition) -> Bool {
		if lhs.logicalName != rhs.logicalName {
			return false
		}
		if lhs.id != rhs.id {
			return false
		}
		if lhs.displayDescription != rhs.displayDescription {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(logicalName)
		hasher.combine(id)
		hasher.combine(displayDescription)
	}
}

// MARK: - FfiConverterTypeNetworkDefinition
public struct FfiConverterTypeNetworkDefinition: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkDefinition {
		try NetworkDefinition(
			logicalName: FfiConverterString.read(from: &buf),
			id: FfiConverterTypeNetworkID.read(from: &buf),
			displayDescription: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: NetworkDefinition, into buf: inout [UInt8]) {
		FfiConverterString.write(value.logicalName, into: &buf)
		FfiConverterTypeNetworkID.write(value.id, into: &buf)
		FfiConverterString.write(value.displayDescription, into: &buf)
	}
}

public func FfiConverterTypeNetworkDefinition_lift(_ buf: RustBuffer) throws -> NetworkDefinition {
	try FfiConverterTypeNetworkDefinition.lift(buf)
}

public func FfiConverterTypeNetworkDefinition_lower(_ value: NetworkDefinition) -> RustBuffer {
	FfiConverterTypeNetworkDefinition.lower(value)
}

// MARK: - NetworkRequest
public struct NetworkRequest {
	public var url: Url
	public var method: NetworkMethod
	public var headers: [String: String]
	public var body: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(url: Url, method: NetworkMethod, headers: [String: String], body: BagOfBytes) {
		self.url = url
		self.method = method
		self.headers = headers
		self.body = body
	}
}

// MARK: Sendable
extension NetworkRequest: Sendable {}

// MARK: Equatable, Hashable
extension NetworkRequest: Equatable, Hashable {
	public static func == (lhs: NetworkRequest, rhs: NetworkRequest) -> Bool {
		if lhs.url != rhs.url {
			return false
		}
		if lhs.method != rhs.method {
			return false
		}
		if lhs.headers != rhs.headers {
			return false
		}
		if lhs.body != rhs.body {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(url)
		hasher.combine(method)
		hasher.combine(headers)
		hasher.combine(body)
	}
}

// MARK: - FfiConverterTypeNetworkRequest
public struct FfiConverterTypeNetworkRequest: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkRequest {
		try NetworkRequest(
			url: FfiConverterTypeUrl.read(from: &buf),
			method: FfiConverterTypeNetworkMethod.read(from: &buf),
			headers: FfiConverterDictionaryStringString.read(from: &buf),
			body: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: NetworkRequest, into buf: inout [UInt8]) {
		FfiConverterTypeUrl.write(value.url, into: &buf)
		FfiConverterTypeNetworkMethod.write(value.method, into: &buf)
		FfiConverterDictionaryStringString.write(value.headers, into: &buf)
		FfiConverterTypeBagOfBytes.write(value.body, into: &buf)
	}
}

public func FfiConverterTypeNetworkRequest_lift(_ buf: RustBuffer) throws -> NetworkRequest {
	try FfiConverterTypeNetworkRequest.lift(buf)
}

public func FfiConverterTypeNetworkRequest_lower(_ value: NetworkRequest) -> RustBuffer {
	FfiConverterTypeNetworkRequest.lower(value)
}

// MARK: - NetworkResponse
public struct NetworkResponse {
	public var statusCode: UInt16
	/**
	 * Can be empty.
	 */
	public var body: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(statusCode: UInt16,
	            /**
	            	* Can be empty.
	            	*/ body: BagOfBytes)
	{
		self.statusCode = statusCode
		self.body = body
	}
}

// MARK: Sendable
extension NetworkResponse: Sendable {}

// MARK: Equatable, Hashable
extension NetworkResponse: Equatable, Hashable {
	public static func == (lhs: NetworkResponse, rhs: NetworkResponse) -> Bool {
		if lhs.statusCode != rhs.statusCode {
			return false
		}
		if lhs.body != rhs.body {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(statusCode)
		hasher.combine(body)
	}
}

// MARK: - FfiConverterTypeNetworkResponse
public struct FfiConverterTypeNetworkResponse: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkResponse {
		try NetworkResponse(
			statusCode: FfiConverterUInt16.read(from: &buf),
			body: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: NetworkResponse, into buf: inout [UInt8]) {
		FfiConverterUInt16.write(value.statusCode, into: &buf)
		FfiConverterTypeBagOfBytes.write(value.body, into: &buf)
	}
}

public func FfiConverterTypeNetworkResponse_lift(_ buf: RustBuffer) throws -> NetworkResponse {
	try FfiConverterTypeNetworkResponse.lift(buf)
}

public func FfiConverterTypeNetworkResponse_lower(_ value: NetworkResponse) -> RustBuffer {
	FfiConverterTypeNetworkResponse.lower(value)
}

// MARK: - NewEntities
/**
 * Information on the global entities created in the transaction.
 */
public struct NewEntities {
	public var metadata: [ResourceAddress: NewlyCreatedResource]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(metadata: [ResourceAddress: NewlyCreatedResource]) {
		self.metadata = metadata
	}
}

// MARK: Sendable
extension NewEntities: Sendable {}

// MARK: Equatable, Hashable
extension NewEntities: Equatable, Hashable {
	public static func == (lhs: NewEntities, rhs: NewEntities) -> Bool {
		if lhs.metadata != rhs.metadata {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(metadata)
	}
}

// MARK: - FfiConverterTypeNewEntities
public struct FfiConverterTypeNewEntities: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewEntities {
		try NewEntities(
			metadata: FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource.read(from: &buf)
		)
	}

	public static func write(_ value: NewEntities, into buf: inout [UInt8]) {
		FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource.write(value.metadata, into: &buf)
	}
}

public func FfiConverterTypeNewEntities_lift(_ buf: RustBuffer) throws -> NewEntities {
	try FfiConverterTypeNewEntities.lift(buf)
}

public func FfiConverterTypeNewEntities_lower(_ value: NewEntities) -> RustBuffer {
	FfiConverterTypeNewEntities.lower(value)
}

// MARK: - NewlyCreatedResource
/**
 * Metadata about a newly created Resource
 */
public struct NewlyCreatedResource {
	public var name: String?
	public var symbol: String?
	public var description: String?
	public var iconUrl: String?
	public var tags: [String]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(name: String?, symbol: String?, description: String?, iconUrl: String?, tags: [String]) {
		self.name = name
		self.symbol = symbol
		self.description = description
		self.iconUrl = iconUrl
		self.tags = tags
	}
}

// MARK: Sendable
extension NewlyCreatedResource: Sendable {}

// MARK: Equatable, Hashable
extension NewlyCreatedResource: Equatable, Hashable {
	public static func == (lhs: NewlyCreatedResource, rhs: NewlyCreatedResource) -> Bool {
		if lhs.name != rhs.name {
			return false
		}
		if lhs.symbol != rhs.symbol {
			return false
		}
		if lhs.description != rhs.description {
			return false
		}
		if lhs.iconUrl != rhs.iconUrl {
			return false
		}
		if lhs.tags != rhs.tags {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(name)
		hasher.combine(symbol)
		hasher.combine(description)
		hasher.combine(iconUrl)
		hasher.combine(tags)
	}
}

// MARK: - FfiConverterTypeNewlyCreatedResource
public struct FfiConverterTypeNewlyCreatedResource: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewlyCreatedResource {
		try NewlyCreatedResource(
			name: FfiConverterOptionString.read(from: &buf),
			symbol: FfiConverterOptionString.read(from: &buf),
			description: FfiConverterOptionString.read(from: &buf),
			iconUrl: FfiConverterOptionString.read(from: &buf),
			tags: FfiConverterSequenceString.read(from: &buf)
		)
	}

	public static func write(_ value: NewlyCreatedResource, into buf: inout [UInt8]) {
		FfiConverterOptionString.write(value.name, into: &buf)
		FfiConverterOptionString.write(value.symbol, into: &buf)
		FfiConverterOptionString.write(value.description, into: &buf)
		FfiConverterOptionString.write(value.iconUrl, into: &buf)
		FfiConverterSequenceString.write(value.tags, into: &buf)
	}
}

public func FfiConverterTypeNewlyCreatedResource_lift(_ buf: RustBuffer) throws -> NewlyCreatedResource {
	try FfiConverterTypeNewlyCreatedResource.lift(buf)
}

public func FfiConverterTypeNewlyCreatedResource_lower(_ value: NewlyCreatedResource) -> RustBuffer {
	FfiConverterTypeNewlyCreatedResource.lower(value)
}

// MARK: - NonEmptyMax32Bytes
/**
 * 32 bytes, typically used as entropy for Mnemonics.
 */
public struct NonEmptyMax32Bytes {
	public var bagOfBytes: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(bagOfBytes: BagOfBytes) {
		self.bagOfBytes = bagOfBytes
	}
}

// MARK: Sendable
extension NonEmptyMax32Bytes: Sendable {}

// MARK: Equatable, Hashable
extension NonEmptyMax32Bytes: Equatable, Hashable {
	public static func == (lhs: NonEmptyMax32Bytes, rhs: NonEmptyMax32Bytes) -> Bool {
		if lhs.bagOfBytes != rhs.bagOfBytes {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(bagOfBytes)
	}
}

// MARK: - FfiConverterTypeNonEmptyMax32Bytes
public struct FfiConverterTypeNonEmptyMax32Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonEmptyMax32Bytes {
		try NonEmptyMax32Bytes(
			bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: NonEmptyMax32Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
	}
}

public func FfiConverterTypeNonEmptyMax32Bytes_lift(_ buf: RustBuffer) throws -> NonEmptyMax32Bytes {
	try FfiConverterTypeNonEmptyMax32Bytes.lift(buf)
}

public func FfiConverterTypeNonEmptyMax32Bytes_lower(_ value: NonEmptyMax32Bytes) -> RustBuffer {
	FfiConverterTypeNonEmptyMax32Bytes.lower(value)
}

// MARK: - NonEmptyMax64Bytes
/**
 * 64 bytes, typically used by NonFungibleLocalId::Bytes
 */
public struct NonEmptyMax64Bytes {
	public var bagOfBytes: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(bagOfBytes: BagOfBytes) {
		self.bagOfBytes = bagOfBytes
	}
}

// MARK: Sendable
extension NonEmptyMax64Bytes: Sendable {}

// MARK: Equatable, Hashable
extension NonEmptyMax64Bytes: Equatable, Hashable {
	public static func == (lhs: NonEmptyMax64Bytes, rhs: NonEmptyMax64Bytes) -> Bool {
		if lhs.bagOfBytes != rhs.bagOfBytes {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(bagOfBytes)
	}
}

// MARK: - FfiConverterTypeNonEmptyMax64Bytes
public struct FfiConverterTypeNonEmptyMax64Bytes: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonEmptyMax64Bytes {
		try NonEmptyMax64Bytes(
			bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: NonEmptyMax64Bytes, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
	}
}

public func FfiConverterTypeNonEmptyMax64Bytes_lift(_ buf: RustBuffer) throws -> NonEmptyMax64Bytes {
	try FfiConverterTypeNonEmptyMax64Bytes.lift(buf)
}

public func FfiConverterTypeNonEmptyMax64Bytes_lower(_ value: NonEmptyMax64Bytes) -> RustBuffer {
	FfiConverterTypeNonEmptyMax64Bytes.lower(value)
}

// MARK: - NonFungibleGlobalId
public struct NonFungibleGlobalId {
	public var resourceAddress: ResourceAddress
	public var nonFungibleLocalId: NonFungibleLocalId

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(resourceAddress: ResourceAddress, nonFungibleLocalId: NonFungibleLocalId) {
		self.resourceAddress = resourceAddress
		self.nonFungibleLocalId = nonFungibleLocalId
	}
}

// MARK: Sendable
extension NonFungibleGlobalId: Sendable {}

// MARK: Equatable, Hashable
extension NonFungibleGlobalId: Equatable, Hashable {
	public static func == (lhs: NonFungibleGlobalId, rhs: NonFungibleGlobalId) -> Bool {
		if lhs.resourceAddress != rhs.resourceAddress {
			return false
		}
		if lhs.nonFungibleLocalId != rhs.nonFungibleLocalId {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(resourceAddress)
		hasher.combine(nonFungibleLocalId)
	}
}

// MARK: - FfiConverterTypeNonFungibleGlobalId
public struct FfiConverterTypeNonFungibleGlobalId: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleGlobalId {
		try NonFungibleGlobalId(
			resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
			nonFungibleLocalId: FfiConverterTypeNonFungibleLocalId.read(from: &buf)
		)
	}

	public static func write(_ value: NonFungibleGlobalId, into buf: inout [UInt8]) {
		FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
		FfiConverterTypeNonFungibleLocalId.write(value.nonFungibleLocalId, into: &buf)
	}
}

public func FfiConverterTypeNonFungibleGlobalId_lift(_ buf: RustBuffer) throws -> NonFungibleGlobalId {
	try FfiConverterTypeNonFungibleGlobalId.lift(buf)
}

public func FfiConverterTypeNonFungibleGlobalId_lower(_ value: NonFungibleGlobalId) -> RustBuffer {
	FfiConverterTypeNonFungibleGlobalId.lower(value)
}

// MARK: - NonFungibleLocalIdString
/**
 * A string matching `[_0-9a-zA-Z]{1,64}`.
 *
 * This is an internal wrapping of Scrypto's `StringNonFungibleLocalId`
 * with a UniFFI custom converter using `String` as `Builtin`.
 *
 * Using this type instead of `String` directly in `NonFungibleLocalId::Str`,
 * allows us to do impl `From<NonFungibleLocalId> for NonFungibleLocalId` instead
 * of `TryFrom<NonFungibleLocalId>`.
 */
public struct NonFungibleLocalIdString {
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension NonFungibleLocalIdString: Sendable {}

// MARK: Equatable, Hashable
extension NonFungibleLocalIdString: Equatable, Hashable {
	public static func == (lhs: NonFungibleLocalIdString, rhs: NonFungibleLocalIdString) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeNonFungibleLocalIdString
public struct FfiConverterTypeNonFungibleLocalIdString: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalIdString {
		try NonFungibleLocalIdString(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: NonFungibleLocalIdString, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeNonFungibleLocalIdString_lift(_ buf: RustBuffer) throws -> NonFungibleLocalIdString {
	try FfiConverterTypeNonFungibleLocalIdString.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalIdString_lower(_ value: NonFungibleLocalIdString) -> RustBuffer {
	FfiConverterTypeNonFungibleLocalIdString.lower(value)
}

// MARK: - NonFungibleResourceAddress
/**
 * NonFungibleResourceAddress is a specialized ResourceAddress for resources
 * which are non fungible, it ALWAYS has an `'n'` after bech32 separator `'1'`, e.g.:
 * `"resource_rdx1nfyg2f68jw7hfdlg5hzvd8ylsa7e0kjl68t5t62v3ttamtejc9wlxa"`.
 *
 * As opposed to a fungible resource address, e.g. that of XRD which has `'t'`
 * after bech32 separator `'1'`, see:
 * `"resource_rdx1tknxxxxxxxxxradxrdxxxxxxxxx009923554798xxxxxxxxxradxrd"`
 *
 * This means that given an instance of `NonFungibleResourceAddress`, it is
 * guaranteed that its entity type is [`::GlobalNonFungibleResourceManager`],
 * and not `::GlobalFungibleResourceManager`.
 *
 * This type can safely be used with [`StakeClaim`]s, unfortunately since Radix Engine
 * and/or network does not validate the resource address of a `NonFungibleGlobalId`,
 * we cannot use this for that type.
 */
public struct NonFungibleResourceAddress {
	public var value: ResourceAddress

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: ResourceAddress) {
		self.value = value
	}
}

// MARK: Sendable
extension NonFungibleResourceAddress: Sendable {}

// MARK: Equatable, Hashable
extension NonFungibleResourceAddress: Equatable, Hashable {
	public static func == (lhs: NonFungibleResourceAddress, rhs: NonFungibleResourceAddress) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeNonFungibleResourceAddress
public struct FfiConverterTypeNonFungibleResourceAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleResourceAddress {
		try NonFungibleResourceAddress(
			value: FfiConverterTypeResourceAddress.read(from: &buf)
		)
	}

	public static func write(_ value: NonFungibleResourceAddress, into buf: inout [UInt8]) {
		FfiConverterTypeResourceAddress.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeNonFungibleResourceAddress_lift(_ buf: RustBuffer) throws -> NonFungibleResourceAddress {
	try FfiConverterTypeNonFungibleResourceAddress.lift(buf)
}

public func FfiConverterTypeNonFungibleResourceAddress_lower(_ value: NonFungibleResourceAddress) -> RustBuffer {
	FfiConverterTypeNonFungibleResourceAddress.lower(value)
}

// MARK: - Nonce
public struct Nonce {
	fileprivate let secretMagic: UInt32

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: UInt32) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension Nonce: Sendable {}

// MARK: Equatable, Hashable
extension Nonce: Equatable, Hashable {
	public static func == (lhs: Nonce, rhs: Nonce) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeNonce
public struct FfiConverterTypeNonce: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nonce {
		try Nonce(
			secretMagic: FfiConverterUInt32.read(from: &buf)
		)
	}

	public static func write(_ value: Nonce, into buf: inout [UInt8]) {
		FfiConverterUInt32.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeNonce_lift(_ buf: RustBuffer) throws -> Nonce {
	try FfiConverterTypeNonce.lift(buf)
}

public func FfiConverterTypeNonce_lower(_ value: Nonce) -> RustBuffer {
	FfiConverterTypeNonce.lower(value)
}

// MARK: - NotarizedTransaction
public struct NotarizedTransaction {
	public var signedIntent: SignedIntent
	public var notarySignature: NotarySignature

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(signedIntent: SignedIntent, notarySignature: NotarySignature) {
		self.signedIntent = signedIntent
		self.notarySignature = notarySignature
	}
}

// MARK: Sendable
extension NotarizedTransaction: Sendable {}

// MARK: Equatable, Hashable
extension NotarizedTransaction: Equatable, Hashable {
	public static func == (lhs: NotarizedTransaction, rhs: NotarizedTransaction) -> Bool {
		if lhs.signedIntent != rhs.signedIntent {
			return false
		}
		if lhs.notarySignature != rhs.notarySignature {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(signedIntent)
		hasher.combine(notarySignature)
	}
}

// MARK: - FfiConverterTypeNotarizedTransaction
public struct FfiConverterTypeNotarizedTransaction: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarizedTransaction {
		try NotarizedTransaction(
			signedIntent: FfiConverterTypeSignedIntent.read(from: &buf),
			notarySignature: FfiConverterTypeNotarySignature.read(from: &buf)
		)
	}

	public static func write(_ value: NotarizedTransaction, into buf: inout [UInt8]) {
		FfiConverterTypeSignedIntent.write(value.signedIntent, into: &buf)
		FfiConverterTypeNotarySignature.write(value.notarySignature, into: &buf)
	}
}

public func FfiConverterTypeNotarizedTransaction_lift(_ buf: RustBuffer) throws -> NotarizedTransaction {
	try FfiConverterTypeNotarizedTransaction.lift(buf)
}

public func FfiConverterTypeNotarizedTransaction_lower(_ value: NotarizedTransaction) -> RustBuffer {
	FfiConverterTypeNotarizedTransaction.lower(value)
}

// MARK: - NotarySignature
public struct NotarySignature {
	fileprivate let secretMagic: Signature

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: Signature) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension NotarySignature: Sendable {}

// MARK: Equatable, Hashable
extension NotarySignature: Equatable, Hashable {
	public static func == (lhs: NotarySignature, rhs: NotarySignature) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeNotarySignature
public struct FfiConverterTypeNotarySignature: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarySignature {
		try NotarySignature(
			secretMagic: FfiConverterTypeSignature.read(from: &buf)
		)
	}

	public static func write(_ value: NotarySignature, into buf: inout [UInt8]) {
		FfiConverterTypeSignature.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeNotarySignature_lift(_ buf: RustBuffer) throws -> NotarySignature {
	try FfiConverterTypeNotarySignature.lift(buf)
}

public func FfiConverterTypeNotarySignature_lower(_ value: NotarySignature) -> RustBuffer {
	FfiConverterTypeNotarySignature.lower(value)
}

// MARK: - OffDeviceMnemonicFactorSource
/**
 * A factor source representing a Mnemonic the user has to input every time
 * the use the factor source, since it is not saved on the device, it is said
 * to be "off device".
 */
public struct OffDeviceMnemonicFactorSource {
	/**
	 * Unique and stable identifier of this factor source, stemming from the
	 * hash of a special child key of the HD root of the mnemonic.
	 */
	public var id: FactorSourceIdFromHash
	/**
	 * Common properties shared between FactorSources of different kinds,
	 * describing its state, when added, and supported cryptographic parameters.
	 */
	public var common: FactorSourceCommon
	/**
	 * Properties describing a OffDeviceMnemonicFactorSource to help user
	 * disambiguate between it and another one.
	 */
	public var hint: OffDeviceMnemonicHint

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Unique and stable identifier of this factor source, stemming from the
		 * hash of a special child key of the HD root of the mnemonic.
		 */ id: FactorSourceIdFromHash,
		/**
			* Common properties shared between FactorSources of different kinds,
			* describing its state, when added, and supported cryptographic parameters.
			*/ common: FactorSourceCommon,
		/**
			* Properties describing a OffDeviceMnemonicFactorSource to help user
			* disambiguate between it and another one.
			*/ hint: OffDeviceMnemonicHint
	) {
		self.id = id
		self.common = common
		self.hint = hint
	}
}

// MARK: Sendable
extension OffDeviceMnemonicFactorSource: Sendable {}

// MARK: Equatable, Hashable
extension OffDeviceMnemonicFactorSource: Equatable, Hashable {
	public static func == (lhs: OffDeviceMnemonicFactorSource, rhs: OffDeviceMnemonicFactorSource) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.common != rhs.common {
			return false
		}
		if lhs.hint != rhs.hint {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(common)
		hasher.combine(hint)
	}
}

// MARK: - FfiConverterTypeOffDeviceMnemonicFactorSource
public struct FfiConverterTypeOffDeviceMnemonicFactorSource: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OffDeviceMnemonicFactorSource {
		try OffDeviceMnemonicFactorSource(
			id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
			common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
			hint: FfiConverterTypeOffDeviceMnemonicHint.read(from: &buf)
		)
	}

	public static func write(_ value: OffDeviceMnemonicFactorSource, into buf: inout [UInt8]) {
		FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
		FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
		FfiConverterTypeOffDeviceMnemonicHint.write(value.hint, into: &buf)
	}
}

public func FfiConverterTypeOffDeviceMnemonicFactorSource_lift(_ buf: RustBuffer) throws -> OffDeviceMnemonicFactorSource {
	try FfiConverterTypeOffDeviceMnemonicFactorSource.lift(buf)
}

public func FfiConverterTypeOffDeviceMnemonicFactorSource_lower(_ value: OffDeviceMnemonicFactorSource) -> RustBuffer {
	FfiConverterTypeOffDeviceMnemonicFactorSource.lower(value)
}

// MARK: - OffDeviceMnemonicHint
/**
 * Properties describing a DeviceFactorSource to help user disambiguate between
 * it and another one.
 */
public struct OffDeviceMnemonicHint {
	public var displayName: DisplayName

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(displayName: DisplayName) {
		self.displayName = displayName
	}
}

// MARK: Sendable
extension OffDeviceMnemonicHint: Sendable {}

// MARK: Equatable, Hashable
extension OffDeviceMnemonicHint: Equatable, Hashable {
	public static func == (lhs: OffDeviceMnemonicHint, rhs: OffDeviceMnemonicHint) -> Bool {
		if lhs.displayName != rhs.displayName {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(displayName)
	}
}

// MARK: - FfiConverterTypeOffDeviceMnemonicHint
public struct FfiConverterTypeOffDeviceMnemonicHint: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OffDeviceMnemonicHint {
		try OffDeviceMnemonicHint(
			displayName: FfiConverterTypeDisplayName.read(from: &buf)
		)
	}

	public static func write(_ value: OffDeviceMnemonicHint, into buf: inout [UInt8]) {
		FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
	}
}

public func FfiConverterTypeOffDeviceMnemonicHint_lift(_ buf: RustBuffer) throws -> OffDeviceMnemonicHint {
	try FfiConverterTypeOffDeviceMnemonicHint.lift(buf)
}

public func FfiConverterTypeOffDeviceMnemonicHint_lower(_ value: OffDeviceMnemonicHint) -> RustBuffer {
	FfiConverterTypeOffDeviceMnemonicHint.lower(value)
}

// MARK: - OnLedgerSettings
/**
 * Account settings that user has set on the account component
 * On-Ledger, that is set via a transaction mutating the state
 * on the network.
 *
 * This settings include third-party deposits, controlling who
 * can send which assets to this account.
 *
 * These settings SHOULD be kept in sync between local state
 * (in Profile) and On-Ledger.
 */
public struct OnLedgerSettings {
	/**
	 * Controls the ability of third-parties to deposit into this account
	 */
	public var thirdPartyDeposits: ThirdPartyDeposits

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Controls the ability of third-parties to deposit into this account
		 */ thirdPartyDeposits: ThirdPartyDeposits
	) {
		self.thirdPartyDeposits = thirdPartyDeposits
	}
}

// MARK: Sendable
extension OnLedgerSettings: Sendable {}

// MARK: Equatable, Hashable
extension OnLedgerSettings: Equatable, Hashable {
	public static func == (lhs: OnLedgerSettings, rhs: OnLedgerSettings) -> Bool {
		if lhs.thirdPartyDeposits != rhs.thirdPartyDeposits {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(thirdPartyDeposits)
	}
}

// MARK: - FfiConverterTypeOnLedgerSettings
public struct FfiConverterTypeOnLedgerSettings: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnLedgerSettings {
		try OnLedgerSettings(
			thirdPartyDeposits: FfiConverterTypeThirdPartyDeposits.read(from: &buf)
		)
	}

	public static func write(_ value: OnLedgerSettings, into buf: inout [UInt8]) {
		FfiConverterTypeThirdPartyDeposits.write(value.thirdPartyDeposits, into: &buf)
	}
}

public func FfiConverterTypeOnLedgerSettings_lift(_ buf: RustBuffer) throws -> OnLedgerSettings {
	try FfiConverterTypeOnLedgerSettings.lift(buf)
}

public func FfiConverterTypeOnLedgerSettings_lower(_ value: OnLedgerSettings) -> RustBuffer {
	FfiConverterTypeOnLedgerSettings.lower(value)
}

// MARK: - P2pLink
/**
 * A client the user have connected P2P with, typically a WebRTC connection with the dApp or Connector Extension.
 * Each client generates a curve25119 keypair. The public key is used as an identifier for the client.
 * The hash of the connection password is used to establish the P2P connection.
 * There can be multiple types of links (trusted vs untrusted) differentiated by `RadixConnectPurpose`.
 * Here are the [CAP-36][doc] requirements.
 *
 * [doc]: https://radixdlt.atlassian.net/wiki/spaces/AT/pages/3251863610/CAP-36+WebRTC+Clients+Protocol
 */
public struct P2pLink {
	/**
	 * The most important property of this struct, the `RadixConnectPassword`,
	 * is used to be able to re-establish the P2P connection
	 */
	public var connectionPassword: RadixConnectPassword
	/**
	 * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
	 * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
	 * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
	 */
	public var connectionPurpose: RadixConnectPurpose
	/**
	 * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
	 * Each client keeps a record of linked clients' public keys to prevent duplicate links.
	 * This is the public key of the other client and it also serves as the seed for the link `ID`.
	 */
	public var publicKey: Ed25519PublicKey
	/**
	 * Client name, e.g. "Chrome on Macbook" or "My work Android" or "My wifes iPhone SE".
	 */
	public var displayName: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The most important property of this struct, the `RadixConnectPassword`,
		 * is used to be able to re-establish the P2P connection
		 */ connectionPassword: RadixConnectPassword,
		/**
			* The purpose of the connection, set by the other client, typically Connector Extension or dApp.
			* As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
			* The user needs to make a conscious decision about general purpose links (because it comes with security risk).
			*/ connectionPurpose: RadixConnectPurpose,
		/**
			* Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
			* Each client keeps a record of linked clients' public keys to prevent duplicate links.
			* This is the public key of the other client and it also serves as the seed for the link `ID`.
			*/ publicKey: Ed25519PublicKey,
		/**
			* Client name, e.g. "Chrome on Macbook" or "My work Android" or "My wifes iPhone SE".
			*/ displayName: String
	) {
		self.connectionPassword = connectionPassword
		self.connectionPurpose = connectionPurpose
		self.publicKey = publicKey
		self.displayName = displayName
	}
}

// MARK: Sendable
extension P2pLink: Sendable {}

// MARK: Equatable, Hashable
extension P2pLink: Equatable, Hashable {
	public static func == (lhs: P2pLink, rhs: P2pLink) -> Bool {
		if lhs.connectionPassword != rhs.connectionPassword {
			return false
		}
		if lhs.connectionPurpose != rhs.connectionPurpose {
			return false
		}
		if lhs.publicKey != rhs.publicKey {
			return false
		}
		if lhs.displayName != rhs.displayName {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(connectionPassword)
		hasher.combine(connectionPurpose)
		hasher.combine(publicKey)
		hasher.combine(displayName)
	}
}

// MARK: - FfiConverterTypeP2PLink
public struct FfiConverterTypeP2PLink: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> P2pLink {
		try P2pLink(
			connectionPassword: FfiConverterTypeRadixConnectPassword.read(from: &buf),
			connectionPurpose: FfiConverterTypeRadixConnectPurpose.read(from: &buf),
			publicKey: FfiConverterTypeEd25519PublicKey.read(from: &buf),
			displayName: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: P2pLink, into buf: inout [UInt8]) {
		FfiConverterTypeRadixConnectPassword.write(value.connectionPassword, into: &buf)
		FfiConverterTypeRadixConnectPurpose.write(value.connectionPurpose, into: &buf)
		FfiConverterTypeEd25519PublicKey.write(value.publicKey, into: &buf)
		FfiConverterString.write(value.displayName, into: &buf)
	}
}

public func FfiConverterTypeP2PLink_lift(_ buf: RustBuffer) throws -> P2pLink {
	try FfiConverterTypeP2PLink.lift(buf)
}

public func FfiConverterTypeP2PLink_lower(_ value: P2pLink) -> RustBuffer {
	FfiConverterTypeP2PLink.lower(value)
}

// MARK: - PackageAddress
/**
 * The unique address identifying a package - which is a collection of blueprints on Ledger, e.g.:
 * `"package_rdx1pkgxxxxxxxxxfaucetxxxxxxxxx000034355863xxxxxxxxxfaucet"`
 *
 * PackageAddress has [Scrypto's `EntityType`][entt] type `GlobalPackage`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalPackageAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L241C29-L241C42
 */
public struct PackageAddress {
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension PackageAddress: Sendable {}

// MARK: Equatable, Hashable
extension PackageAddress: Equatable, Hashable {
	public static func == (lhs: PackageAddress, rhs: PackageAddress) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypePackageAddress
public struct FfiConverterTypePackageAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PackageAddress {
		try PackageAddress(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: PackageAddress, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypePackageAddress_lift(_ buf: RustBuffer) throws -> PackageAddress {
	try FfiConverterTypePackageAddress.lift(buf)
}

public func FfiConverterTypePackageAddress_lower(_ value: PackageAddress) -> RustBuffer {
	FfiConverterTypePackageAddress.lower(value)
}

// MARK: - PassphraseFactorSource
/**
 * NOT IMPLEMENTED NOR USED YET
 *
 * A passphrase based FactorSource is essentially a Input Key Material based Mnemonic,
 * user needs to input the passphrase - key material - every time they use this factor source
 */
public struct PassphraseFactorSource {
	/**
	 * Unique and stable identifier of this factor source, stemming from the
	 * hash of a special child key of the HD root of the mnemonic.
	 */
	public var id: FactorSourceIdFromHash
	/**
	 * Common properties shared between FactorSources of different kinds,
	 * describing its state, when added, and supported cryptographic parameters.
	 */
	public var common: FactorSourceCommon

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Unique and stable identifier of this factor source, stemming from the
		 * hash of a special child key of the HD root of the mnemonic.
		 */ id: FactorSourceIdFromHash,
		/**
			* Common properties shared between FactorSources of different kinds,
			* describing its state, when added, and supported cryptographic parameters.
			*/ common: FactorSourceCommon
	) {
		self.id = id
		self.common = common
	}
}

// MARK: Sendable
extension PassphraseFactorSource: Sendable {}

// MARK: Equatable, Hashable
extension PassphraseFactorSource: Equatable, Hashable {
	public static func == (lhs: PassphraseFactorSource, rhs: PassphraseFactorSource) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.common != rhs.common {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(common)
	}
}

// MARK: - FfiConverterTypePassphraseFactorSource
public struct FfiConverterTypePassphraseFactorSource: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PassphraseFactorSource {
		try PassphraseFactorSource(
			id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
			common: FfiConverterTypeFactorSourceCommon.read(from: &buf)
		)
	}

	public static func write(_ value: PassphraseFactorSource, into buf: inout [UInt8]) {
		FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
		FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
	}
}

public func FfiConverterTypePassphraseFactorSource_lift(_ buf: RustBuffer) throws -> PassphraseFactorSource {
	try FfiConverterTypePassphraseFactorSource.lift(buf)
}

public func FfiConverterTypePassphraseFactorSource_lower(_ value: PassphraseFactorSource) -> RustBuffer {
	FfiConverterTypePassphraseFactorSource.lower(value)
}

// MARK: - PerAssetFungibleResource
public struct PerAssetFungibleResource {
	public var resourceAddress: ResourceAddress
	public var divisibility: UInt8?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(resourceAddress: ResourceAddress, divisibility: UInt8?) {
		self.resourceAddress = resourceAddress
		self.divisibility = divisibility
	}
}

// MARK: Sendable
extension PerAssetFungibleResource: Sendable {}

// MARK: Equatable, Hashable
extension PerAssetFungibleResource: Equatable, Hashable {
	public static func == (lhs: PerAssetFungibleResource, rhs: PerAssetFungibleResource) -> Bool {
		if lhs.resourceAddress != rhs.resourceAddress {
			return false
		}
		if lhs.divisibility != rhs.divisibility {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(resourceAddress)
		hasher.combine(divisibility)
	}
}

// MARK: - FfiConverterTypePerAssetFungibleResource
public struct FfiConverterTypePerAssetFungibleResource: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetFungibleResource {
		try PerAssetFungibleResource(
			resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
			divisibility: FfiConverterOptionUInt8.read(from: &buf)
		)
	}

	public static func write(_ value: PerAssetFungibleResource, into buf: inout [UInt8]) {
		FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
		FfiConverterOptionUInt8.write(value.divisibility, into: &buf)
	}
}

public func FfiConverterTypePerAssetFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetFungibleResource {
	try FfiConverterTypePerAssetFungibleResource.lift(buf)
}

public func FfiConverterTypePerAssetFungibleResource_lower(_ value: PerAssetFungibleResource) -> RustBuffer {
	FfiConverterTypePerAssetFungibleResource.lower(value)
}

// MARK: - PerAssetFungibleTransfer
/**
 * A fungible transfer to `recipient`, with a specified amount of tokens to send.
 */
public struct PerAssetFungibleTransfer {
	/**
	 * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
	 * typically wallets sets this to try if and only if the recipient is a self-owned account
	 * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
	 * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
	 * which resource is known (`resource_address` is owned or has been owned before).
	 */
	public var useTryDepositOrAbort: Bool
	/**
	 * Amount
	 */
	public var amount: Decimal192
	/**
	 * The account or account address to send the tokens to.
	 */
	public var recipient: AccountOrAddressOf

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
		 * typically wallets sets this to try if and only if the recipient is a self-owned account
		 * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
		 * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
		 * which resource is known (`resource_address` is owned or has been owned before).
		 */ useTryDepositOrAbort: Bool,
		/**
			* Amount
			*/ amount: Decimal192,
		/**
			* The account or account address to send the tokens to.
			*/ recipient: AccountOrAddressOf
	) {
		self.useTryDepositOrAbort = useTryDepositOrAbort
		self.amount = amount
		self.recipient = recipient
	}
}

// MARK: Sendable
extension PerAssetFungibleTransfer: Sendable {}

// MARK: Equatable, Hashable
extension PerAssetFungibleTransfer: Equatable, Hashable {
	public static func == (lhs: PerAssetFungibleTransfer, rhs: PerAssetFungibleTransfer) -> Bool {
		if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
			return false
		}
		if lhs.amount != rhs.amount {
			return false
		}
		if lhs.recipient != rhs.recipient {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(useTryDepositOrAbort)
		hasher.combine(amount)
		hasher.combine(recipient)
	}
}

// MARK: - FfiConverterTypePerAssetFungibleTransfer
public struct FfiConverterTypePerAssetFungibleTransfer: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetFungibleTransfer {
		try PerAssetFungibleTransfer(
			useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
			amount: FfiConverterTypeDecimal192.read(from: &buf),
			recipient: FfiConverterTypeAccountOrAddressOf.read(from: &buf)
		)
	}

	public static func write(_ value: PerAssetFungibleTransfer, into buf: inout [UInt8]) {
		FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
		FfiConverterTypeDecimal192.write(value.amount, into: &buf)
		FfiConverterTypeAccountOrAddressOf.write(value.recipient, into: &buf)
	}
}

public func FfiConverterTypePerAssetFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerAssetFungibleTransfer {
	try FfiConverterTypePerAssetFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerAssetFungibleTransfer_lower(_ value: PerAssetFungibleTransfer) -> RustBuffer {
	FfiConverterTypePerAssetFungibleTransfer.lower(value)
}

// MARK: - PerAssetNonFungibleTransfer
/**
 * A non fungible transfer to `recipient`, with specified Local IDs to send.
 */
public struct PerAssetNonFungibleTransfer {
	/**
	 * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
	 * typically wallets sets this to try if and only if the recipient is a self-owned account
	 * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
	 * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
	 * which resource is known (`resource_address` is owned or has been owned before).
	 */
	public var useTryDepositOrAbort: Bool
	/**
	 * Amount
	 */
	public var nonFungibleLocalIds: [NonFungibleLocalId]
	/**
	 * The account or account address to send the tokens to.
	 */
	public var recipient: AccountOrAddressOf

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
		 * typically wallets sets this to try if and only if the recipient is a self-owned account
		 * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
		 * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
		 * which resource is known (`resource_address` is owned or has been owned before).
		 */ useTryDepositOrAbort: Bool,
		/**
			* Amount
			*/ nonFungibleLocalIds: [NonFungibleLocalId],
		/**
			* The account or account address to send the tokens to.
			*/ recipient: AccountOrAddressOf
	) {
		self.useTryDepositOrAbort = useTryDepositOrAbort
		self.nonFungibleLocalIds = nonFungibleLocalIds
		self.recipient = recipient
	}
}

// MARK: Sendable
extension PerAssetNonFungibleTransfer: Sendable {}

// MARK: Equatable, Hashable
extension PerAssetNonFungibleTransfer: Equatable, Hashable {
	public static func == (lhs: PerAssetNonFungibleTransfer, rhs: PerAssetNonFungibleTransfer) -> Bool {
		if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
			return false
		}
		if lhs.nonFungibleLocalIds != rhs.nonFungibleLocalIds {
			return false
		}
		if lhs.recipient != rhs.recipient {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(useTryDepositOrAbort)
		hasher.combine(nonFungibleLocalIds)
		hasher.combine(recipient)
	}
}

// MARK: - FfiConverterTypePerAssetNonFungibleTransfer
public struct FfiConverterTypePerAssetNonFungibleTransfer: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetNonFungibleTransfer {
		try PerAssetNonFungibleTransfer(
			useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
			nonFungibleLocalIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
			recipient: FfiConverterTypeAccountOrAddressOf.read(from: &buf)
		)
	}

	public static func write(_ value: PerAssetNonFungibleTransfer, into buf: inout [UInt8]) {
		FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
		FfiConverterSequenceTypeNonFungibleLocalId.write(value.nonFungibleLocalIds, into: &buf)
		FfiConverterTypeAccountOrAddressOf.write(value.recipient, into: &buf)
	}
}

public func FfiConverterTypePerAssetNonFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerAssetNonFungibleTransfer {
	try FfiConverterTypePerAssetNonFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerAssetNonFungibleTransfer_lower(_ value: PerAssetNonFungibleTransfer) -> RustBuffer {
	FfiConverterTypePerAssetNonFungibleTransfer.lower(value)
}

// MARK: - PerAssetTransfers
public struct PerAssetTransfers {
	public var fromAccount: AccountAddress
	public var fungibleResources: [PerAssetTransfersOfFungibleResource]
	public var nonFungibleResources: [PerAssetTransfersOfNonFungibleResource]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(fromAccount: AccountAddress, fungibleResources: [PerAssetTransfersOfFungibleResource], nonFungibleResources: [PerAssetTransfersOfNonFungibleResource]) {
		self.fromAccount = fromAccount
		self.fungibleResources = fungibleResources
		self.nonFungibleResources = nonFungibleResources
	}
}

// MARK: Sendable
extension PerAssetTransfers: Sendable {}

// MARK: Equatable, Hashable
extension PerAssetTransfers: Equatable, Hashable {
	public static func == (lhs: PerAssetTransfers, rhs: PerAssetTransfers) -> Bool {
		if lhs.fromAccount != rhs.fromAccount {
			return false
		}
		if lhs.fungibleResources != rhs.fungibleResources {
			return false
		}
		if lhs.nonFungibleResources != rhs.nonFungibleResources {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(fromAccount)
		hasher.combine(fungibleResources)
		hasher.combine(nonFungibleResources)
	}
}

// MARK: - FfiConverterTypePerAssetTransfers
public struct FfiConverterTypePerAssetTransfers: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfers {
		try PerAssetTransfers(
			fromAccount: FfiConverterTypeAccountAddress.read(from: &buf),
			fungibleResources: FfiConverterSequenceTypePerAssetTransfersOfFungibleResource.read(from: &buf),
			nonFungibleResources: FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource.read(from: &buf)
		)
	}

	public static func write(_ value: PerAssetTransfers, into buf: inout [UInt8]) {
		FfiConverterTypeAccountAddress.write(value.fromAccount, into: &buf)
		FfiConverterSequenceTypePerAssetTransfersOfFungibleResource.write(value.fungibleResources, into: &buf)
		FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource.write(value.nonFungibleResources, into: &buf)
	}
}

public func FfiConverterTypePerAssetTransfers_lift(_ buf: RustBuffer) throws -> PerAssetTransfers {
	try FfiConverterTypePerAssetTransfers.lift(buf)
}

public func FfiConverterTypePerAssetTransfers_lower(_ value: PerAssetTransfers) -> RustBuffer {
	FfiConverterTypePerAssetTransfers.lower(value)
}

// MARK: - PerAssetTransfersOfFungibleResource
public struct PerAssetTransfersOfFungibleResource {
	public var resource: PerAssetFungibleResource
	public var transfers: [PerAssetFungibleTransfer]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(resource: PerAssetFungibleResource, transfers: [PerAssetFungibleTransfer]) {
		self.resource = resource
		self.transfers = transfers
	}
}

// MARK: Sendable
extension PerAssetTransfersOfFungibleResource: Sendable {}

// MARK: Equatable, Hashable
extension PerAssetTransfersOfFungibleResource: Equatable, Hashable {
	public static func == (lhs: PerAssetTransfersOfFungibleResource, rhs: PerAssetTransfersOfFungibleResource) -> Bool {
		if lhs.resource != rhs.resource {
			return false
		}
		if lhs.transfers != rhs.transfers {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(resource)
		hasher.combine(transfers)
	}
}

// MARK: - FfiConverterTypePerAssetTransfersOfFungibleResource
public struct FfiConverterTypePerAssetTransfersOfFungibleResource: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfersOfFungibleResource {
		try PerAssetTransfersOfFungibleResource(
			resource: FfiConverterTypePerAssetFungibleResource.read(from: &buf),
			transfers: FfiConverterSequenceTypePerAssetFungibleTransfer.read(from: &buf)
		)
	}

	public static func write(_ value: PerAssetTransfersOfFungibleResource, into buf: inout [UInt8]) {
		FfiConverterTypePerAssetFungibleResource.write(value.resource, into: &buf)
		FfiConverterSequenceTypePerAssetFungibleTransfer.write(value.transfers, into: &buf)
	}
}

public func FfiConverterTypePerAssetTransfersOfFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetTransfersOfFungibleResource {
	try FfiConverterTypePerAssetTransfersOfFungibleResource.lift(buf)
}

public func FfiConverterTypePerAssetTransfersOfFungibleResource_lower(_ value: PerAssetTransfersOfFungibleResource) -> RustBuffer {
	FfiConverterTypePerAssetTransfersOfFungibleResource.lower(value)
}

// MARK: - PerAssetTransfersOfNonFungibleResource
public struct PerAssetTransfersOfNonFungibleResource {
	public var resource: ResourceAddress
	public var transfers: [PerAssetNonFungibleTransfer]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(resource: ResourceAddress, transfers: [PerAssetNonFungibleTransfer]) {
		self.resource = resource
		self.transfers = transfers
	}
}

// MARK: Sendable
extension PerAssetTransfersOfNonFungibleResource: Sendable {}

// MARK: Equatable, Hashable
extension PerAssetTransfersOfNonFungibleResource: Equatable, Hashable {
	public static func == (lhs: PerAssetTransfersOfNonFungibleResource, rhs: PerAssetTransfersOfNonFungibleResource) -> Bool {
		if lhs.resource != rhs.resource {
			return false
		}
		if lhs.transfers != rhs.transfers {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(resource)
		hasher.combine(transfers)
	}
}

// MARK: - FfiConverterTypePerAssetTransfersOfNonFungibleResource
public struct FfiConverterTypePerAssetTransfersOfNonFungibleResource: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfersOfNonFungibleResource {
		try PerAssetTransfersOfNonFungibleResource(
			resource: FfiConverterTypeResourceAddress.read(from: &buf),
			transfers: FfiConverterSequenceTypePerAssetNonFungibleTransfer.read(from: &buf)
		)
	}

	public static func write(_ value: PerAssetTransfersOfNonFungibleResource, into buf: inout [UInt8]) {
		FfiConverterTypeResourceAddress.write(value.resource, into: &buf)
		FfiConverterSequenceTypePerAssetNonFungibleTransfer.write(value.transfers, into: &buf)
	}
}

public func FfiConverterTypePerAssetTransfersOfNonFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetTransfersOfNonFungibleResource {
	try FfiConverterTypePerAssetTransfersOfNonFungibleResource.lift(buf)
}

public func FfiConverterTypePerAssetTransfersOfNonFungibleResource_lower(_ value: PerAssetTransfersOfNonFungibleResource) -> RustBuffer {
	FfiConverterTypePerAssetTransfersOfNonFungibleResource.lower(value)
}

// MARK: - PerRecipientAssetTransfer
public struct PerRecipientAssetTransfer {
	public var recipient: AccountOrAddressOf
	public var fungibles: [PerRecipientFungibleTransfer]
	public var nonFungibles: [PerRecipientNonFungibleTransfer]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(recipient: AccountOrAddressOf, fungibles: [PerRecipientFungibleTransfer], nonFungibles: [PerRecipientNonFungibleTransfer]) {
		self.recipient = recipient
		self.fungibles = fungibles
		self.nonFungibles = nonFungibles
	}
}

// MARK: Sendable
extension PerRecipientAssetTransfer: Sendable {}

// MARK: Equatable, Hashable
extension PerRecipientAssetTransfer: Equatable, Hashable {
	public static func == (lhs: PerRecipientAssetTransfer, rhs: PerRecipientAssetTransfer) -> Bool {
		if lhs.recipient != rhs.recipient {
			return false
		}
		if lhs.fungibles != rhs.fungibles {
			return false
		}
		if lhs.nonFungibles != rhs.nonFungibles {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(recipient)
		hasher.combine(fungibles)
		hasher.combine(nonFungibles)
	}
}

// MARK: - FfiConverterTypePerRecipientAssetTransfer
public struct FfiConverterTypePerRecipientAssetTransfer: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientAssetTransfer {
		try PerRecipientAssetTransfer(
			recipient: FfiConverterTypeAccountOrAddressOf.read(from: &buf),
			fungibles: FfiConverterSequenceTypePerRecipientFungibleTransfer.read(from: &buf),
			nonFungibles: FfiConverterSequenceTypePerRecipientNonFungibleTransfer.read(from: &buf)
		)
	}

	public static func write(_ value: PerRecipientAssetTransfer, into buf: inout [UInt8]) {
		FfiConverterTypeAccountOrAddressOf.write(value.recipient, into: &buf)
		FfiConverterSequenceTypePerRecipientFungibleTransfer.write(value.fungibles, into: &buf)
		FfiConverterSequenceTypePerRecipientNonFungibleTransfer.write(value.nonFungibles, into: &buf)
	}
}

public func FfiConverterTypePerRecipientAssetTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientAssetTransfer {
	try FfiConverterTypePerRecipientAssetTransfer.lift(buf)
}

public func FfiConverterTypePerRecipientAssetTransfer_lower(_ value: PerRecipientAssetTransfer) -> RustBuffer {
	FfiConverterTypePerRecipientAssetTransfer.lower(value)
}

// MARK: - PerRecipientAssetTransfers
public struct PerRecipientAssetTransfers {
	public var addressOfSender: AccountAddress
	public var transfers: [PerRecipientAssetTransfer]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(addressOfSender: AccountAddress, transfers: [PerRecipientAssetTransfer]) {
		self.addressOfSender = addressOfSender
		self.transfers = transfers
	}
}

// MARK: Sendable
extension PerRecipientAssetTransfers: Sendable {}

// MARK: Equatable, Hashable
extension PerRecipientAssetTransfers: Equatable, Hashable {
	public static func == (lhs: PerRecipientAssetTransfers, rhs: PerRecipientAssetTransfers) -> Bool {
		if lhs.addressOfSender != rhs.addressOfSender {
			return false
		}
		if lhs.transfers != rhs.transfers {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(addressOfSender)
		hasher.combine(transfers)
	}
}

// MARK: - FfiConverterTypePerRecipientAssetTransfers
public struct FfiConverterTypePerRecipientAssetTransfers: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientAssetTransfers {
		try PerRecipientAssetTransfers(
			addressOfSender: FfiConverterTypeAccountAddress.read(from: &buf),
			transfers: FfiConverterSequenceTypePerRecipientAssetTransfer.read(from: &buf)
		)
	}

	public static func write(_ value: PerRecipientAssetTransfers, into buf: inout [UInt8]) {
		FfiConverterTypeAccountAddress.write(value.addressOfSender, into: &buf)
		FfiConverterSequenceTypePerRecipientAssetTransfer.write(value.transfers, into: &buf)
	}
}

public func FfiConverterTypePerRecipientAssetTransfers_lift(_ buf: RustBuffer) throws -> PerRecipientAssetTransfers {
	try FfiConverterTypePerRecipientAssetTransfers.lift(buf)
}

public func FfiConverterTypePerRecipientAssetTransfers_lower(_ value: PerRecipientAssetTransfers) -> RustBuffer {
	FfiConverterTypePerRecipientAssetTransfers.lower(value)
}

// MARK: - PerRecipientFungibleTransfer
/**
 * A fungible transfer of `resource_address` token, with a specified amount
 * of tokens and divisibility.
 */
public struct PerRecipientFungibleTransfer {
	/**
	 * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
	 * typically wallets sets this to try if and only if the recipient is a self-owned account
	 * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
	 * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
	 * which resource is known (`resource_address` is owned or has been owned before).
	 */
	public var useTryDepositOrAbort: Bool
	/**
	 * Amount
	 */
	public var amount: Decimal192
	public var divisibility: UInt8?
	/**
	 * The address of the resource being sent
	 */
	public var resourceAddress: ResourceAddress

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
		 * typically wallets sets this to try if and only if the recipient is a self-owned account
		 * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
		 * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
		 * which resource is known (`resource_address` is owned or has been owned before).
		 */ useTryDepositOrAbort: Bool,
		/**
			* Amount
			*/ amount: Decimal192, divisibility: UInt8?,
		/**
			* The address of the resource being sent
			*/ resourceAddress: ResourceAddress
	) {
		self.useTryDepositOrAbort = useTryDepositOrAbort
		self.amount = amount
		self.divisibility = divisibility
		self.resourceAddress = resourceAddress
	}
}

// MARK: Sendable
extension PerRecipientFungibleTransfer: Sendable {}

// MARK: Equatable, Hashable
extension PerRecipientFungibleTransfer: Equatable, Hashable {
	public static func == (lhs: PerRecipientFungibleTransfer, rhs: PerRecipientFungibleTransfer) -> Bool {
		if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
			return false
		}
		if lhs.amount != rhs.amount {
			return false
		}
		if lhs.divisibility != rhs.divisibility {
			return false
		}
		if lhs.resourceAddress != rhs.resourceAddress {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(useTryDepositOrAbort)
		hasher.combine(amount)
		hasher.combine(divisibility)
		hasher.combine(resourceAddress)
	}
}

// MARK: - FfiConverterTypePerRecipientFungibleTransfer
public struct FfiConverterTypePerRecipientFungibleTransfer: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientFungibleTransfer {
		try PerRecipientFungibleTransfer(
			useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
			amount: FfiConverterTypeDecimal192.read(from: &buf),
			divisibility: FfiConverterOptionUInt8.read(from: &buf),
			resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf)
		)
	}

	public static func write(_ value: PerRecipientFungibleTransfer, into buf: inout [UInt8]) {
		FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
		FfiConverterTypeDecimal192.write(value.amount, into: &buf)
		FfiConverterOptionUInt8.write(value.divisibility, into: &buf)
		FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
	}
}

public func FfiConverterTypePerRecipientFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientFungibleTransfer {
	try FfiConverterTypePerRecipientFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerRecipientFungibleTransfer_lower(_ value: PerRecipientFungibleTransfer) -> RustBuffer {
	FfiConverterTypePerRecipientFungibleTransfer.lower(value)
}

// MARK: - PerRecipientNonFungibleTransfer
/**
 * A non fungible transfer of `resource_address` token, with specified Local IDs to send.
 */
public struct PerRecipientNonFungibleTransfer {
	/**
	 * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
	 * typically wallets sets this to try if and only if the recipient is a self-owned account
	 * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
	 * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
	 * which resource is known (`resource_address` is owned or has been owned before).
	 */
	public var useTryDepositOrAbort: Bool
	/**
	 * The local IDS of the NonFungible tokens being sent
	 */
	public var localIds: [NonFungibleLocalId]
	/**
	 * The address of the resource being sent
	 */
	public var resourceAddress: ResourceAddress

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
		 * typically wallets sets this to try if and only if the recipient is a self-owned account
		 * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
		 * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
		 * which resource is known (`resource_address` is owned or has been owned before).
		 */ useTryDepositOrAbort: Bool,
		/**
			* The local IDS of the NonFungible tokens being sent
			*/ localIds: [NonFungibleLocalId],
		/**
			* The address of the resource being sent
			*/ resourceAddress: ResourceAddress
	) {
		self.useTryDepositOrAbort = useTryDepositOrAbort
		self.localIds = localIds
		self.resourceAddress = resourceAddress
	}
}

// MARK: Sendable
extension PerRecipientNonFungibleTransfer: Sendable {}

// MARK: Equatable, Hashable
extension PerRecipientNonFungibleTransfer: Equatable, Hashable {
	public static func == (lhs: PerRecipientNonFungibleTransfer, rhs: PerRecipientNonFungibleTransfer) -> Bool {
		if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
			return false
		}
		if lhs.localIds != rhs.localIds {
			return false
		}
		if lhs.resourceAddress != rhs.resourceAddress {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(useTryDepositOrAbort)
		hasher.combine(localIds)
		hasher.combine(resourceAddress)
	}
}

// MARK: - FfiConverterTypePerRecipientNonFungibleTransfer
public struct FfiConverterTypePerRecipientNonFungibleTransfer: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientNonFungibleTransfer {
		try PerRecipientNonFungibleTransfer(
			useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
			localIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
			resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf)
		)
	}

	public static func write(_ value: PerRecipientNonFungibleTransfer, into buf: inout [UInt8]) {
		FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
		FfiConverterSequenceTypeNonFungibleLocalId.write(value.localIds, into: &buf)
		FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
	}
}

public func FfiConverterTypePerRecipientNonFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientNonFungibleTransfer {
	try FfiConverterTypePerRecipientNonFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerRecipientNonFungibleTransfer_lower(_ value: PerRecipientNonFungibleTransfer) -> RustBuffer {
	FfiConverterTypePerRecipientNonFungibleTransfer.lower(value)
}

// MARK: - Persona
/**
 * A Persona is an identity a user chooses to login to a dApp with, using
 * RadixConnect - Radix decentralized login solution. A persona is very
 * similar to [`Account`]s, in the sense that they are On-Network/On-Ledger
 * components, with a unique network dependent address ([`IdentityAddress`])
 * and with a security state (see [`EntitySecurityState`]) knowing which
 * factor instances that control this component, but with one important
 * difference: a Persona cannot hold funds. It is impossible to transfer
 * any asset to a Persona. The On-Network component representation of
 * the Persona is called `Identity`. The concept "Persona" is a Radix
 * Wallet (Profile) *application* of an Identity.
 *
 * Personas have data (see [`PersonaData`]), which is personal information
 * a user has associated with a this Persona, of different kinds, such as name,
 * email address(es) or phone number(s). The `PersonaData` is **never** uploaded
 * to the Radix Network, i.e. it is a pure Radix Wallet (Profile) construct,
 * On-Network Identities does not know of PersonaData, and never will (well
 * technically, nothing stops a user from building their own wallet and uploading
 * personal information to the metadata of the Identity component... but `Sargon`
 * never will, nor will the Radix Wallet.).
 */
public struct Persona {
	/**
	 * The ID of the network this account can be used with.
	 */
	public var networkId: NetworkId
	/**
	 * The address of an identity, used by Personas, a bech32 encoding of a public key hash
	 * that starts with the prefix `"identity_"`, dependent on NetworkID, meaning the same
	 * public key used for two IdentityAddresses on two different networks will not have
	 * the same address.
	 */
	public var address: IdentityAddress
	/**
	 * An off-ledger display name or description chosen by the user when they
	 * created this persona.
	 */
	public var displayName: DisplayName
	/**
	 * Describes the state this Persona is in, in regards to how
	 * the user controls it, i.e. if it is controlled by a single factor (private key)
	 * or an `AccessController` with a potential Multi-Factor setup.
	 */
	public var securityState: EntitySecurityState
	/**
	 * An order set of `EntityFlag`s used to describe certain Off-ledger
	 * user state about this Persona, e.g. if it is marked as hidden or not.
	 */
	public var flags: [EntityFlag]
	/**
	 * Personal information a user has associated with a certain Persona, of different kinds, such as name,
	 * email address(es) or phone number(s). This information is only ever stored in Profile and is never
	 * uploaded to the Radix Network.
	 */
	public var personaData: PersonaData

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The ID of the network this account can be used with.
		 */ networkId: NetworkId,
		/**
			* The address of an identity, used by Personas, a bech32 encoding of a public key hash
			* that starts with the prefix `"identity_"`, dependent on NetworkID, meaning the same
			* public key used for two IdentityAddresses on two different networks will not have
			* the same address.
			*/ address: IdentityAddress,
		/**
			* An off-ledger display name or description chosen by the user when they
			* created this persona.
			*/ displayName: DisplayName,
		/**
			* Describes the state this Persona is in, in regards to how
			* the user controls it, i.e. if it is controlled by a single factor (private key)
			* or an `AccessController` with a potential Multi-Factor setup.
			*/ securityState: EntitySecurityState,
		/**
			* An order set of `EntityFlag`s used to describe certain Off-ledger
			* user state about this Persona, e.g. if it is marked as hidden or not.
			*/ flags: [EntityFlag],
		/**
			* Personal information a user has associated with a certain Persona, of different kinds, such as name,
			* email address(es) or phone number(s). This information is only ever stored in Profile and is never
			* uploaded to the Radix Network.
			*/ personaData: PersonaData
	) {
		self.networkId = networkId
		self.address = address
		self.displayName = displayName
		self.securityState = securityState
		self.flags = flags
		self.personaData = personaData
	}
}

// MARK: Sendable
extension Persona: Sendable {}

// MARK: Equatable, Hashable
extension Persona: Equatable, Hashable {
	public static func == (lhs: Persona, rhs: Persona) -> Bool {
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.address != rhs.address {
			return false
		}
		if lhs.displayName != rhs.displayName {
			return false
		}
		if lhs.securityState != rhs.securityState {
			return false
		}
		if lhs.flags != rhs.flags {
			return false
		}
		if lhs.personaData != rhs.personaData {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(networkId)
		hasher.combine(address)
		hasher.combine(displayName)
		hasher.combine(securityState)
		hasher.combine(flags)
		hasher.combine(personaData)
	}
}

// MARK: - FfiConverterTypePersona
public struct FfiConverterTypePersona: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Persona {
		try Persona(
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			address: FfiConverterTypeIdentityAddress.read(from: &buf),
			displayName: FfiConverterTypeDisplayName.read(from: &buf),
			securityState: FfiConverterTypeEntitySecurityState.read(from: &buf),
			flags: FfiConverterSequenceTypeEntityFlag.read(from: &buf),
			personaData: FfiConverterTypePersonaData.read(from: &buf)
		)
	}

	public static func write(_ value: Persona, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeIdentityAddress.write(value.address, into: &buf)
		FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
		FfiConverterTypeEntitySecurityState.write(value.securityState, into: &buf)
		FfiConverterSequenceTypeEntityFlag.write(value.flags, into: &buf)
		FfiConverterTypePersonaData.write(value.personaData, into: &buf)
	}
}

public func FfiConverterTypePersona_lift(_ buf: RustBuffer) throws -> Persona {
	try FfiConverterTypePersona.lift(buf)
}

public func FfiConverterTypePersona_lower(_ value: Persona) -> RustBuffer {
	FfiConverterTypePersona.lower(value)
}

// MARK: - PersonaData
/**
 * Personal information a user has associated with a certain Persona, of different kinds, such as name,
 * email address(es) or phone number(s). This information is only ever stored in Profile and is never
 * uploaded to the Radix Network.
 *
 * These entries of different kinds can be queried for in a request sent by a dApp, e.g.
 * Radix Dashboard might ask "Give me ongoing access to Name and 2 Email addresses for
 * a Persona" (just a silly example, Radix Dashboard would never ask for that and why 2 email addresses?).
 *
 * The Profile will then use the fact that each Persona Data Entry has a stable ID so that Profile can
 * refer the entry just by the ID, and Profile can thus record which Persona Data Entry a user has selected
 * to share with the dApp, without duplicating the value of that entry (just like how we use FactorSourceIDs).
 * Since a dApp can ask for *ongoing* access next time the user interacts with the same dApp, if user has
 * not revoked the dApps access, the wallet clients will automatically send back the Persona Data Entry values
 * even if they have been updated - the value might have changed but their IDs have not. Thus if a user
 * deletes a Persona Data Entry (e.g. a phone number), and later re-inputs the same phone number, even
 * it the exact same value is used, it will still be treated as a new entry since its ID is new, meaning
 * that the next time the user interacts with a previously authorized dApp the wallet cannot automatically
 * respond back to dApp with the PersonaData, but user will have to re-authorize the request for ongoing
 * access for the requested PersonaData entries.
 */
public struct PersonaData {
	/**
	 * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
	 * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
	 *
	 * Note that the type is Option of `PersonaDataIdentifiedName` and not of type [`PersonaDataEntryName`][name],
	 * `PersonaDataIdentifiedName` is essentially a tuple of `(Uuid, PersonaDataEntryName)`.
	 *
	 * [name]: PersonaDataEntryName
	 */
	public var name: PersonaDataIdentifiedName?
	/**
	 * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
	 * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
	 * contain elements with the same value, but under different IDs.
	 */
	public var phoneNumbers: CollectionOfPhoneNumbers
	/**
	 * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
	 * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
	 * contain elements with the same value, but under different IDs.
	 */
	public var emailAddresses: CollectionOfEmailAddresses

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
		 * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
		 *
		 * Note that the type is Option of `PersonaDataIdentifiedName` and not of type [`PersonaDataEntryName`][name],
		 * `PersonaDataIdentifiedName` is essentially a tuple of `(Uuid, PersonaDataEntryName)`.
		 *
		 * [name]: PersonaDataEntryName
		 */ name: PersonaDataIdentifiedName?,
		/**
			* A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
			* `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
			* contain elements with the same value, but under different IDs.
			*/ phoneNumbers: CollectionOfPhoneNumbers,
		/**
			* A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
			* `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
			* contain elements with the same value, but under different IDs.
			*/ emailAddresses: CollectionOfEmailAddresses
	) {
		self.name = name
		self.phoneNumbers = phoneNumbers
		self.emailAddresses = emailAddresses
	}
}

// MARK: Sendable
extension PersonaData: Sendable {}

// MARK: Equatable, Hashable
extension PersonaData: Equatable, Hashable {
	public static func == (lhs: PersonaData, rhs: PersonaData) -> Bool {
		if lhs.name != rhs.name {
			return false
		}
		if lhs.phoneNumbers != rhs.phoneNumbers {
			return false
		}
		if lhs.emailAddresses != rhs.emailAddresses {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(name)
		hasher.combine(phoneNumbers)
		hasher.combine(emailAddresses)
	}
}

// MARK: - FfiConverterTypePersonaData
public struct FfiConverterTypePersonaData: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaData {
		try PersonaData(
			name: FfiConverterOptionTypePersonaDataIdentifiedName.read(from: &buf),
			phoneNumbers: FfiConverterTypeCollectionOfPhoneNumbers.read(from: &buf),
			emailAddresses: FfiConverterTypeCollectionOfEmailAddresses.read(from: &buf)
		)
	}

	public static func write(_ value: PersonaData, into buf: inout [UInt8]) {
		FfiConverterOptionTypePersonaDataIdentifiedName.write(value.name, into: &buf)
		FfiConverterTypeCollectionOfPhoneNumbers.write(value.phoneNumbers, into: &buf)
		FfiConverterTypeCollectionOfEmailAddresses.write(value.emailAddresses, into: &buf)
	}
}

public func FfiConverterTypePersonaData_lift(_ buf: RustBuffer) throws -> PersonaData {
	try FfiConverterTypePersonaData.lift(buf)
}

public func FfiConverterTypePersonaData_lower(_ value: PersonaData) -> RustBuffer {
	FfiConverterTypePersonaData.lower(value)
}

// MARK: - PersonaDataEntryName
/**
 * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
 * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
 *
 * Nickname is optional in the sense that it can be left blank. Family name and given names are never empty.
 *
 * If a name has multiple given names, they all go into the `given_names` String, e.g. Pippi Longstocking's real name -
 * her Swedish name - is in full: "Pippilotta Viktualia Rullgardina Krusmynta Efraimsdotter Lngstrump", where her
 * given names: "Pippilotta Viktualia Rullgardina Krusmynta Efraimsdotter" are put in the `given_names` field, and
 * "Lngstrump" (Longstocking) is her family name.
 */
public struct PersonaDataEntryName {
	public var variant: PersonaDataNameVariant
	public var familyName: String
	public var givenNames: String
	public var nickname: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(variant: PersonaDataNameVariant, familyName: String, givenNames: String, nickname: String) {
		self.variant = variant
		self.familyName = familyName
		self.givenNames = givenNames
		self.nickname = nickname
	}
}

// MARK: Sendable
extension PersonaDataEntryName: Sendable {}

// MARK: Equatable, Hashable
extension PersonaDataEntryName: Equatable, Hashable {
	public static func == (lhs: PersonaDataEntryName, rhs: PersonaDataEntryName) -> Bool {
		if lhs.variant != rhs.variant {
			return false
		}
		if lhs.familyName != rhs.familyName {
			return false
		}
		if lhs.givenNames != rhs.givenNames {
			return false
		}
		if lhs.nickname != rhs.nickname {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(variant)
		hasher.combine(familyName)
		hasher.combine(givenNames)
		hasher.combine(nickname)
	}
}

// MARK: - FfiConverterTypePersonaDataEntryName
public struct FfiConverterTypePersonaDataEntryName: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryName {
		try PersonaDataEntryName(
			variant: FfiConverterTypePersonaDataNameVariant.read(from: &buf),
			familyName: FfiConverterString.read(from: &buf),
			givenNames: FfiConverterString.read(from: &buf),
			nickname: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: PersonaDataEntryName, into buf: inout [UInt8]) {
		FfiConverterTypePersonaDataNameVariant.write(value.variant, into: &buf)
		FfiConverterString.write(value.familyName, into: &buf)
		FfiConverterString.write(value.givenNames, into: &buf)
		FfiConverterString.write(value.nickname, into: &buf)
	}
}

public func FfiConverterTypePersonaDataEntryName_lift(_ buf: RustBuffer) throws -> PersonaDataEntryName {
	try FfiConverterTypePersonaDataEntryName.lift(buf)
}

public func FfiConverterTypePersonaDataEntryName_lower(_ value: PersonaDataEntryName) -> RustBuffer {
	FfiConverterTypePersonaDataEntryName.lower(value)
}

// MARK: - PersonaDataEntryPhoneNumber
/**
 * A persons telephone number they have chosen to associated with a Persona, e.g.
 * `+46 987 654 321` (don't try calling this number, it does not exist).
 *
 * Current implementation does not validate the phone number other than it
 * cannot be empty, since telephone number validation is tricky.
 */
public struct PersonaDataEntryPhoneNumber {
	public var number: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(number: String) {
		self.number = number
	}
}

// MARK: Sendable
extension PersonaDataEntryPhoneNumber: Sendable {}

// MARK: Equatable, Hashable
extension PersonaDataEntryPhoneNumber: Equatable, Hashable {
	public static func == (lhs: PersonaDataEntryPhoneNumber, rhs: PersonaDataEntryPhoneNumber) -> Bool {
		if lhs.number != rhs.number {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(number)
	}
}

// MARK: - FfiConverterTypePersonaDataEntryPhoneNumber
public struct FfiConverterTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryPhoneNumber {
		try PersonaDataEntryPhoneNumber(
			number: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: PersonaDataEntryPhoneNumber, into buf: inout [UInt8]) {
		FfiConverterString.write(value.number, into: &buf)
	}
}

public func FfiConverterTypePersonaDataEntryPhoneNumber_lift(_ buf: RustBuffer) throws -> PersonaDataEntryPhoneNumber {
	try FfiConverterTypePersonaDataEntryPhoneNumber.lift(buf)
}

public func FfiConverterTypePersonaDataEntryPhoneNumber_lower(_ value: PersonaDataEntryPhoneNumber) -> RustBuffer {
	FfiConverterTypePersonaDataEntryPhoneNumber.lower(value)
}

// MARK: - PersonaDataIdentifiedEmailAddress
/**
 * An identifiable Persona email address. Essentially it is a tuple of a
 * [`(PersonaDataEntryEmailAddress, Uuid)`].
 */
public struct PersonaDataIdentifiedEmailAddress {
	public var id: PersonaDataEntryId
	public var value: EmailAddress

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(id: PersonaDataEntryId, value: EmailAddress) {
		self.id = id
		self.value = value
	}
}

// MARK: Sendable
extension PersonaDataIdentifiedEmailAddress: Sendable {}

// MARK: Equatable, Hashable
extension PersonaDataIdentifiedEmailAddress: Equatable, Hashable {
	public static func == (lhs: PersonaDataIdentifiedEmailAddress, rhs: PersonaDataIdentifiedEmailAddress) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypePersonaDataIdentifiedEmailAddress
public struct FfiConverterTypePersonaDataIdentifiedEmailAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedEmailAddress {
		try PersonaDataIdentifiedEmailAddress(
			id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
			value: FfiConverterTypeEmailAddress.read(from: &buf)
		)
	}

	public static func write(_ value: PersonaDataIdentifiedEmailAddress, into buf: inout [UInt8]) {
		FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
		FfiConverterTypeEmailAddress.write(value.value, into: &buf)
	}
}

public func FfiConverterTypePersonaDataIdentifiedEmailAddress_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedEmailAddress {
	try FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedEmailAddress_lower(_ value: PersonaDataIdentifiedEmailAddress) -> RustBuffer {
	FfiConverterTypePersonaDataIdentifiedEmailAddress.lower(value)
}

// MARK: - PersonaDataIdentifiedName
/**
 * An identifiable Persona name. Essentially it is a tuple of a
 * [`(PersonaDataEntryName, Uuid)`].
 */
public struct PersonaDataIdentifiedName {
	public var id: PersonaDataEntryId
	public var value: PersonaDataEntryName

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(id: PersonaDataEntryId, value: PersonaDataEntryName) {
		self.id = id
		self.value = value
	}
}

// MARK: Sendable
extension PersonaDataIdentifiedName: Sendable {}

// MARK: Equatable, Hashable
extension PersonaDataIdentifiedName: Equatable, Hashable {
	public static func == (lhs: PersonaDataIdentifiedName, rhs: PersonaDataIdentifiedName) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypePersonaDataIdentifiedName
public struct FfiConverterTypePersonaDataIdentifiedName: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedName {
		try PersonaDataIdentifiedName(
			id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
			value: FfiConverterTypePersonaDataEntryName.read(from: &buf)
		)
	}

	public static func write(_ value: PersonaDataIdentifiedName, into buf: inout [UInt8]) {
		FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
		FfiConverterTypePersonaDataEntryName.write(value.value, into: &buf)
	}
}

public func FfiConverterTypePersonaDataIdentifiedName_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedName {
	try FfiConverterTypePersonaDataIdentifiedName.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedName_lower(_ value: PersonaDataIdentifiedName) -> RustBuffer {
	FfiConverterTypePersonaDataIdentifiedName.lower(value)
}

// MARK: - PersonaDataIdentifiedPhoneNumber
/**
 * An identifiable Persona phone number. Essentially it is a tuple of a
 * [`(PersonaDataEntryPhoneNumber, Uuid)`].
 */
public struct PersonaDataIdentifiedPhoneNumber {
	public var id: PersonaDataEntryId
	public var value: PersonaDataEntryPhoneNumber

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(id: PersonaDataEntryId, value: PersonaDataEntryPhoneNumber) {
		self.id = id
		self.value = value
	}
}

// MARK: Sendable
extension PersonaDataIdentifiedPhoneNumber: Sendable {}

// MARK: Equatable, Hashable
extension PersonaDataIdentifiedPhoneNumber: Equatable, Hashable {
	public static func == (lhs: PersonaDataIdentifiedPhoneNumber, rhs: PersonaDataIdentifiedPhoneNumber) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypePersonaDataIdentifiedPhoneNumber
public struct FfiConverterTypePersonaDataIdentifiedPhoneNumber: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedPhoneNumber {
		try PersonaDataIdentifiedPhoneNumber(
			id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
			value: FfiConverterTypePersonaDataEntryPhoneNumber.read(from: &buf)
		)
	}

	public static func write(_ value: PersonaDataIdentifiedPhoneNumber, into buf: inout [UInt8]) {
		FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
		FfiConverterTypePersonaDataEntryPhoneNumber.write(value.value, into: &buf)
	}
}

public func FfiConverterTypePersonaDataIdentifiedPhoneNumber_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedPhoneNumber {
	try FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedPhoneNumber_lower(_ value: PersonaDataIdentifiedPhoneNumber) -> RustBuffer {
	FfiConverterTypePersonaDataIdentifiedPhoneNumber.lower(value)
}

// MARK: - PlaintextMessage
public struct PlaintextMessage {
	public var mimeType: String
	public var message: MessageContents

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(mimeType: String, message: MessageContents) {
		self.mimeType = mimeType
		self.message = message
	}
}

// MARK: Sendable
extension PlaintextMessage: Sendable {}

// MARK: Equatable, Hashable
extension PlaintextMessage: Equatable, Hashable {
	public static func == (lhs: PlaintextMessage, rhs: PlaintextMessage) -> Bool {
		if lhs.mimeType != rhs.mimeType {
			return false
		}
		if lhs.message != rhs.message {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(mimeType)
		hasher.combine(message)
	}
}

// MARK: - FfiConverterTypePlaintextMessage
public struct FfiConverterTypePlaintextMessage: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlaintextMessage {
		try PlaintextMessage(
			mimeType: FfiConverterString.read(from: &buf),
			message: FfiConverterTypeMessageContents.read(from: &buf)
		)
	}

	public static func write(_ value: PlaintextMessage, into buf: inout [UInt8]) {
		FfiConverterString.write(value.mimeType, into: &buf)
		FfiConverterTypeMessageContents.write(value.message, into: &buf)
	}
}

public func FfiConverterTypePlaintextMessage_lift(_ buf: RustBuffer) throws -> PlaintextMessage {
	try FfiConverterTypePlaintextMessage.lift(buf)
}

public func FfiConverterTypePlaintextMessage_lower(_ value: PlaintextMessage) -> RustBuffer {
	FfiConverterTypePlaintextMessage.lower(value)
}

// MARK: - PoolAddress
/**
 * Addresses identifying an OnLedger (OnNetwork) Liquidity Pool (LP) of tokens that users can contribute
 * Liquidity too, e.g.:
 * `"pool_rdx1c325zs6dz3un8ykkjavy9fkvvyzarkaehgsl408qup6f95aup3le3w"`
 *
 * Typically users contribute to Liquidity Pools by using a Dapp and the Radix Wallet.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of PoolAddresses:
 * * GlobalOneResourcePool
 * * GlobalTwoResourcePool
 * * GlobalMultiResourcePool
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalPoolAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L256-L261
 */
public struct PoolAddress {
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension PoolAddress: Sendable {}

// MARK: Equatable, Hashable
extension PoolAddress: Equatable, Hashable {
	public static func == (lhs: PoolAddress, rhs: PoolAddress) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypePoolAddress
public struct FfiConverterTypePoolAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PoolAddress {
		try PoolAddress(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: PoolAddress, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypePoolAddress_lift(_ buf: RustBuffer) throws -> PoolAddress {
	try FfiConverterTypePoolAddress.lift(buf)
}

public func FfiConverterTypePoolAddress_lower(_ value: PoolAddress) -> RustBuffer {
	FfiConverterTypePoolAddress.lower(value)
}

// MARK: - PreAuthEnclosedManifest
/**
 * Pre-Auth analysis enclosed manifest, which does not contain any interactions with the parent manifest,
 * thus its preview can be computed as if it would have been a standalone transaction.
 */
public struct PreAuthEnclosedManifest {
	public var manifest: SubintentManifest
	public var summary: ExecutionSummary

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(manifest: SubintentManifest, summary: ExecutionSummary) {
		self.manifest = manifest
		self.summary = summary
	}
}

// MARK: Sendable
extension PreAuthEnclosedManifest: Sendable {}

// MARK: Equatable, Hashable
extension PreAuthEnclosedManifest: Equatable, Hashable {
	public static func == (lhs: PreAuthEnclosedManifest, rhs: PreAuthEnclosedManifest) -> Bool {
		if lhs.manifest != rhs.manifest {
			return false
		}
		if lhs.summary != rhs.summary {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(manifest)
		hasher.combine(summary)
	}
}

// MARK: - FfiConverterTypePreAuthEnclosedManifest
public struct FfiConverterTypePreAuthEnclosedManifest: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreAuthEnclosedManifest {
		try PreAuthEnclosedManifest(
			manifest: FfiConverterTypeSubintentManifest.read(from: &buf),
			summary: FfiConverterTypeExecutionSummary.read(from: &buf)
		)
	}

	public static func write(_ value: PreAuthEnclosedManifest, into buf: inout [UInt8]) {
		FfiConverterTypeSubintentManifest.write(value.manifest, into: &buf)
		FfiConverterTypeExecutionSummary.write(value.summary, into: &buf)
	}
}

public func FfiConverterTypePreAuthEnclosedManifest_lift(_ buf: RustBuffer) throws -> PreAuthEnclosedManifest {
	try FfiConverterTypePreAuthEnclosedManifest.lift(buf)
}

public func FfiConverterTypePreAuthEnclosedManifest_lower(_ value: PreAuthEnclosedManifest) -> RustBuffer {
	FfiConverterTypePreAuthEnclosedManifest.lower(value)
}

// MARK: - PreAuthOpenManifest
/**
 * Pre-Auth analysis open manifest, which contains multiple interactions with the parent manifest,
 * thus its preview can be computed only based on the static analysis manifest summary
 */
public struct PreAuthOpenManifest {
	public var manifest: SubintentManifest
	public var summary: ManifestSummary

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(manifest: SubintentManifest, summary: ManifestSummary) {
		self.manifest = manifest
		self.summary = summary
	}
}

// MARK: Sendable
extension PreAuthOpenManifest: Sendable {}

// MARK: Equatable, Hashable
extension PreAuthOpenManifest: Equatable, Hashable {
	public static func == (lhs: PreAuthOpenManifest, rhs: PreAuthOpenManifest) -> Bool {
		if lhs.manifest != rhs.manifest {
			return false
		}
		if lhs.summary != rhs.summary {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(manifest)
		hasher.combine(summary)
	}
}

// MARK: - FfiConverterTypePreAuthOpenManifest
public struct FfiConverterTypePreAuthOpenManifest: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreAuthOpenManifest {
		try PreAuthOpenManifest(
			manifest: FfiConverterTypeSubintentManifest.read(from: &buf),
			summary: FfiConverterTypeManifestSummary.read(from: &buf)
		)
	}

	public static func write(_ value: PreAuthOpenManifest, into buf: inout [UInt8]) {
		FfiConverterTypeSubintentManifest.write(value.manifest, into: &buf)
		FfiConverterTypeManifestSummary.write(value.summary, into: &buf)
	}
}

public func FfiConverterTypePreAuthOpenManifest_lift(_ buf: RustBuffer) throws -> PreAuthOpenManifest {
	try FfiConverterTypePreAuthOpenManifest.lift(buf)
}

public func FfiConverterTypePreAuthOpenManifest_lower(_ value: PreAuthOpenManifest) -> RustBuffer {
	FfiConverterTypePreAuthOpenManifest.lower(value)
}

// MARK: - PredictedDecimal
public struct PredictedDecimal {
	public var value: Decimal192
	public var instructionIndex: UInt64

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: Decimal192, instructionIndex: UInt64) {
		self.value = value
		self.instructionIndex = instructionIndex
	}
}

// MARK: Sendable
extension PredictedDecimal: Sendable {}

// MARK: Equatable, Hashable
extension PredictedDecimal: Equatable, Hashable {
	public static func == (lhs: PredictedDecimal, rhs: PredictedDecimal) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		if lhs.instructionIndex != rhs.instructionIndex {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
		hasher.combine(instructionIndex)
	}
}

// MARK: - FfiConverterTypePredictedDecimal
public struct FfiConverterTypePredictedDecimal: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredictedDecimal {
		try PredictedDecimal(
			value: FfiConverterTypeDecimal192.read(from: &buf),
			instructionIndex: FfiConverterUInt64.read(from: &buf)
		)
	}

	public static func write(_ value: PredictedDecimal, into buf: inout [UInt8]) {
		FfiConverterTypeDecimal192.write(value.value, into: &buf)
		FfiConverterUInt64.write(value.instructionIndex, into: &buf)
	}
}

public func FfiConverterTypePredictedDecimal_lift(_ buf: RustBuffer) throws -> PredictedDecimal {
	try FfiConverterTypePredictedDecimal.lift(buf)
}

public func FfiConverterTypePredictedDecimal_lower(_ value: PredictedDecimal) -> RustBuffer {
	FfiConverterTypePredictedDecimal.lower(value)
}

// MARK: - PredictedNonFungibleLocalIds
public struct PredictedNonFungibleLocalIds {
	public var value: [NonFungibleLocalId]
	public var instructionIndex: UInt64

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: [NonFungibleLocalId], instructionIndex: UInt64) {
		self.value = value
		self.instructionIndex = instructionIndex
	}
}

// MARK: Sendable
extension PredictedNonFungibleLocalIds: Sendable {}

// MARK: Equatable, Hashable
extension PredictedNonFungibleLocalIds: Equatable, Hashable {
	public static func == (lhs: PredictedNonFungibleLocalIds, rhs: PredictedNonFungibleLocalIds) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		if lhs.instructionIndex != rhs.instructionIndex {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
		hasher.combine(instructionIndex)
	}
}

// MARK: - FfiConverterTypePredictedNonFungibleLocalIds
public struct FfiConverterTypePredictedNonFungibleLocalIds: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredictedNonFungibleLocalIds {
		try PredictedNonFungibleLocalIds(
			value: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
			instructionIndex: FfiConverterUInt64.read(from: &buf)
		)
	}

	public static func write(_ value: PredictedNonFungibleLocalIds, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeNonFungibleLocalId.write(value.value, into: &buf)
		FfiConverterUInt64.write(value.instructionIndex, into: &buf)
	}
}

public func FfiConverterTypePredictedNonFungibleLocalIds_lift(_ buf: RustBuffer) throws -> PredictedNonFungibleLocalIds {
	try FfiConverterTypePredictedNonFungibleLocalIds.lift(buf)
}

public func FfiConverterTypePredictedNonFungibleLocalIds_lower(_ value: PredictedNonFungibleLocalIds) -> RustBuffer {
	FfiConverterTypePredictedNonFungibleLocalIds.lower(value)
}

// MARK: - PrimaryRoleWithFactorInstances
/**
 * PrimaryRole is used for Signing Transactions.
 */
public struct PrimaryRoleWithFactorInstances {
	/**
	 * Factors which are used in combination with other instances, amounting to at
	 * least `threshold` many instances to perform some function with this role.
	 *
	 * # Implementation
	 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
	 * we might wanna use duplicates, allowing us to build a "template"
	 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
	 * meaning an instance of this template at FactorSource level
	 * (`SecurityStructureOfFactorSources`) will contain two different
	 * `TrustedContactFactorSource`s.
	 */
	public var thresholdFactors: [FactorInstance]
	/**
	 * How many threshold factors that must be used to perform some function with this role.
	 */
	public var threshold: UInt8
	/**
	 * Overriding / Super admin / "sudo" / God / factors, **ANY**
	 * single of these factor which can perform the function of this role,
	 * disregarding of `threshold`.
	 */
	public var overrideFactors: [FactorInstance]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Factors which are used in combination with other instances, amounting to at
		 * least `threshold` many instances to perform some function with this role.
		 *
		 * # Implementation
		 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
		 * we might wanna use duplicates, allowing us to build a "template"
		 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
		 * meaning an instance of this template at FactorSource level
		 * (`SecurityStructureOfFactorSources`) will contain two different
		 * `TrustedContactFactorSource`s.
		 */ thresholdFactors: [FactorInstance],
		/**
			* How many threshold factors that must be used to perform some function with this role.
			*/ threshold: UInt8,
		/**
			* Overriding / Super admin / "sudo" / God / factors, **ANY**
			* single of these factor which can perform the function of this role,
			* disregarding of `threshold`.
			*/ overrideFactors: [FactorInstance]
	) {
		self.thresholdFactors = thresholdFactors
		self.threshold = threshold
		self.overrideFactors = overrideFactors
	}
}

// MARK: Sendable
extension PrimaryRoleWithFactorInstances: Sendable {}

// MARK: Equatable, Hashable
extension PrimaryRoleWithFactorInstances: Equatable, Hashable {
	public static func == (lhs: PrimaryRoleWithFactorInstances, rhs: PrimaryRoleWithFactorInstances) -> Bool {
		if lhs.thresholdFactors != rhs.thresholdFactors {
			return false
		}
		if lhs.threshold != rhs.threshold {
			return false
		}
		if lhs.overrideFactors != rhs.overrideFactors {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(thresholdFactors)
		hasher.combine(threshold)
		hasher.combine(overrideFactors)
	}
}

// MARK: - FfiConverterTypePrimaryRoleWithFactorInstances
public struct FfiConverterTypePrimaryRoleWithFactorInstances: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimaryRoleWithFactorInstances {
		try PrimaryRoleWithFactorInstances(
			thresholdFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf),
			threshold: FfiConverterUInt8.read(from: &buf),
			overrideFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf)
		)
	}

	public static func write(_ value: PrimaryRoleWithFactorInstances, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeFactorInstance.write(value.thresholdFactors, into: &buf)
		FfiConverterUInt8.write(value.threshold, into: &buf)
		FfiConverterSequenceTypeFactorInstance.write(value.overrideFactors, into: &buf)
	}
}

public func FfiConverterTypePrimaryRoleWithFactorInstances_lift(_ buf: RustBuffer) throws -> PrimaryRoleWithFactorInstances {
	try FfiConverterTypePrimaryRoleWithFactorInstances.lift(buf)
}

public func FfiConverterTypePrimaryRoleWithFactorInstances_lower(_ value: PrimaryRoleWithFactorInstances) -> RustBuffer {
	FfiConverterTypePrimaryRoleWithFactorInstances.lower(value)
}

// MARK: - PrimaryRoleWithFactorSourceIDs
/**
 * PrimaryRole is used for Signing Transactions.
 */
public struct PrimaryRoleWithFactorSourceIDs {
	/**
	 * Factors which are used in combination with other instances, amounting to at
	 * least `threshold` many instances to perform some function with this role.
	 *
	 * # Implementation
	 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
	 * we might wanna use duplicates, allowing us to build a "template"
	 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
	 * meaning an instance of this template at FactorSource level
	 * (`SecurityStructureOfFactorSources`) will contain two different
	 * `TrustedContactFactorSource`s.
	 */
	public var thresholdFactors: [FactorSourceId]
	/**
	 * How many threshold factors that must be used to perform some function with this role.
	 */
	public var threshold: UInt8
	/**
	 * Overriding / Super admin / "sudo" / God / factors, **ANY**
	 * single of these factor which can perform the function of this role,
	 * disregarding of `threshold`.
	 */
	public var overrideFactors: [FactorSourceId]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Factors which are used in combination with other instances, amounting to at
		 * least `threshold` many instances to perform some function with this role.
		 *
		 * # Implementation
		 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
		 * we might wanna use duplicates, allowing us to build a "template"
		 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
		 * meaning an instance of this template at FactorSource level
		 * (`SecurityStructureOfFactorSources`) will contain two different
		 * `TrustedContactFactorSource`s.
		 */ thresholdFactors: [FactorSourceId],
		/**
			* How many threshold factors that must be used to perform some function with this role.
			*/ threshold: UInt8,
		/**
			* Overriding / Super admin / "sudo" / God / factors, **ANY**
			* single of these factor which can perform the function of this role,
			* disregarding of `threshold`.
			*/ overrideFactors: [FactorSourceId]
	) {
		self.thresholdFactors = thresholdFactors
		self.threshold = threshold
		self.overrideFactors = overrideFactors
	}
}

// MARK: Sendable
extension PrimaryRoleWithFactorSourceIDs: Sendable {}

// MARK: Equatable, Hashable
extension PrimaryRoleWithFactorSourceIDs: Equatable, Hashable {
	public static func == (lhs: PrimaryRoleWithFactorSourceIDs, rhs: PrimaryRoleWithFactorSourceIDs) -> Bool {
		if lhs.thresholdFactors != rhs.thresholdFactors {
			return false
		}
		if lhs.threshold != rhs.threshold {
			return false
		}
		if lhs.overrideFactors != rhs.overrideFactors {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(thresholdFactors)
		hasher.combine(threshold)
		hasher.combine(overrideFactors)
	}
}

// MARK: - FfiConverterTypePrimaryRoleWithFactorSourceIDs
public struct FfiConverterTypePrimaryRoleWithFactorSourceIDs: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimaryRoleWithFactorSourceIDs {
		try PrimaryRoleWithFactorSourceIDs(
			thresholdFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf),
			threshold: FfiConverterUInt8.read(from: &buf),
			overrideFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
		)
	}

	public static func write(_ value: PrimaryRoleWithFactorSourceIDs, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeFactorSourceID.write(value.thresholdFactors, into: &buf)
		FfiConverterUInt8.write(value.threshold, into: &buf)
		FfiConverterSequenceTypeFactorSourceID.write(value.overrideFactors, into: &buf)
	}
}

public func FfiConverterTypePrimaryRoleWithFactorSourceIDs_lift(_ buf: RustBuffer) throws -> PrimaryRoleWithFactorSourceIDs {
	try FfiConverterTypePrimaryRoleWithFactorSourceIDs.lift(buf)
}

public func FfiConverterTypePrimaryRoleWithFactorSourceIDs_lower(_ value: PrimaryRoleWithFactorSourceIDs) -> RustBuffer {
	FfiConverterTypePrimaryRoleWithFactorSourceIDs.lower(value)
}

// MARK: - PrimaryRoleWithFactorSources
/**
 * PrimaryRole is used for Signing Transactions.
 */
public struct PrimaryRoleWithFactorSources {
	/**
	 * Factors which are used in combination with other instances, amounting to at
	 * least `threshold` many instances to perform some function with this role.
	 *
	 * # Implementation
	 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
	 * we might wanna use duplicates, allowing us to build a "template"
	 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
	 * meaning an instance of this template at FactorSource level
	 * (`SecurityStructureOfFactorSources`) will contain two different
	 * `TrustedContactFactorSource`s.
	 */
	public var thresholdFactors: [FactorSource]
	/**
	 * How many threshold factors that must be used to perform some function with this role.
	 */
	public var threshold: UInt8
	/**
	 * Overriding / Super admin / "sudo" / God / factors, **ANY**
	 * single of these factor which can perform the function of this role,
	 * disregarding of `threshold`.
	 */
	public var overrideFactors: [FactorSource]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Factors which are used in combination with other instances, amounting to at
		 * least `threshold` many instances to perform some function with this role.
		 *
		 * # Implementation
		 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
		 * we might wanna use duplicates, allowing us to build a "template"
		 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
		 * meaning an instance of this template at FactorSource level
		 * (`SecurityStructureOfFactorSources`) will contain two different
		 * `TrustedContactFactorSource`s.
		 */ thresholdFactors: [FactorSource],
		/**
			* How many threshold factors that must be used to perform some function with this role.
			*/ threshold: UInt8,
		/**
			* Overriding / Super admin / "sudo" / God / factors, **ANY**
			* single of these factor which can perform the function of this role,
			* disregarding of `threshold`.
			*/ overrideFactors: [FactorSource]
	) {
		self.thresholdFactors = thresholdFactors
		self.threshold = threshold
		self.overrideFactors = overrideFactors
	}
}

// MARK: Sendable
extension PrimaryRoleWithFactorSources: Sendable {}

// MARK: Equatable, Hashable
extension PrimaryRoleWithFactorSources: Equatable, Hashable {
	public static func == (lhs: PrimaryRoleWithFactorSources, rhs: PrimaryRoleWithFactorSources) -> Bool {
		if lhs.thresholdFactors != rhs.thresholdFactors {
			return false
		}
		if lhs.threshold != rhs.threshold {
			return false
		}
		if lhs.overrideFactors != rhs.overrideFactors {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(thresholdFactors)
		hasher.combine(threshold)
		hasher.combine(overrideFactors)
	}
}

// MARK: - FfiConverterTypePrimaryRoleWithFactorSources
public struct FfiConverterTypePrimaryRoleWithFactorSources: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimaryRoleWithFactorSources {
		try PrimaryRoleWithFactorSources(
			thresholdFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf),
			threshold: FfiConverterUInt8.read(from: &buf),
			overrideFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf)
		)
	}

	public static func write(_ value: PrimaryRoleWithFactorSources, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeFactorSource.write(value.thresholdFactors, into: &buf)
		FfiConverterUInt8.write(value.threshold, into: &buf)
		FfiConverterSequenceTypeFactorSource.write(value.overrideFactors, into: &buf)
	}
}

public func FfiConverterTypePrimaryRoleWithFactorSources_lift(_ buf: RustBuffer) throws -> PrimaryRoleWithFactorSources {
	try FfiConverterTypePrimaryRoleWithFactorSources.lift(buf)
}

public func FfiConverterTypePrimaryRoleWithFactorSources_lower(_ value: PrimaryRoleWithFactorSources) -> RustBuffer {
	FfiConverterTypePrimaryRoleWithFactorSources.lower(value)
}

// MARK: - PrivateHierarchicalDeterministicFactorSource
public struct PrivateHierarchicalDeterministicFactorSource {
	public var mnemonicWithPassphrase: MnemonicWithPassphrase
	public var factorSource: DeviceFactorSource

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(mnemonicWithPassphrase: MnemonicWithPassphrase, factorSource: DeviceFactorSource) {
		self.mnemonicWithPassphrase = mnemonicWithPassphrase
		self.factorSource = factorSource
	}
}

// MARK: Sendable
extension PrivateHierarchicalDeterministicFactorSource: Sendable {}

// MARK: Equatable, Hashable
extension PrivateHierarchicalDeterministicFactorSource: Equatable, Hashable {
	public static func == (lhs: PrivateHierarchicalDeterministicFactorSource, rhs: PrivateHierarchicalDeterministicFactorSource) -> Bool {
		if lhs.mnemonicWithPassphrase != rhs.mnemonicWithPassphrase {
			return false
		}
		if lhs.factorSource != rhs.factorSource {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(mnemonicWithPassphrase)
		hasher.combine(factorSource)
	}
}

// MARK: - FfiConverterTypePrivateHierarchicalDeterministicFactorSource
public struct FfiConverterTypePrivateHierarchicalDeterministicFactorSource: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrivateHierarchicalDeterministicFactorSource {
		try PrivateHierarchicalDeterministicFactorSource(
			mnemonicWithPassphrase: FfiConverterTypeMnemonicWithPassphrase.read(from: &buf),
			factorSource: FfiConverterTypeDeviceFactorSource.read(from: &buf)
		)
	}

	public static func write(_ value: PrivateHierarchicalDeterministicFactorSource, into buf: inout [UInt8]) {
		FfiConverterTypeMnemonicWithPassphrase.write(value.mnemonicWithPassphrase, into: &buf)
		FfiConverterTypeDeviceFactorSource.write(value.factorSource, into: &buf)
	}
}

public func FfiConverterTypePrivateHierarchicalDeterministicFactorSource_lift(_ buf: RustBuffer) throws -> PrivateHierarchicalDeterministicFactorSource {
	try FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(buf)
}

public func FfiConverterTypePrivateHierarchicalDeterministicFactorSource_lower(_ value: PrivateHierarchicalDeterministicFactorSource) -> RustBuffer {
	FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lower(value)
}

// MARK: - Profile
/**
 * The canonical representation of a users accounts, personas,
 * authorized dapps, security factors, settings and more.
 *
 * This large structure of values is called 'wallet backup data'
 * in user facing tests in host applications, but internally at
 * RDX Works known as "the Profile".
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert_eq!(Profile::sample(), Profile::sample())
 * ```
 */
public struct Profile {
	/**
	 * The header of a Profile(Snapshot) contains crucial metadata
	 * about this Profile, such as which JSON data format it is
	 * compatible with and which device was used to create it and
	 * a hint about its contents.
	 */
	public var header: Header
	/**
	 * All sources of factors, used for authorization such as spending funds, contains no
	 * secrets.
	 */
	public var factorSources: [FactorSource]
	/**
	 * Settings for this profile in the app, contains default security configs
	 * as well as display settings.
	 */
	public var appPreferences: AppPreferences
	/**
	 * An ordered mapping of NetworkID -> `Profile.Network`, containing
	 * all the users Accounts, Personas and AuthorizedDapps the user
	 * has created and interacted with on this network.
	 */
	public var networks: [ProfileNetwork]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The header of a Profile(Snapshot) contains crucial metadata
		 * about this Profile, such as which JSON data format it is
		 * compatible with and which device was used to create it and
		 * a hint about its contents.
		 */ header: Header,
		/**
			* All sources of factors, used for authorization such as spending funds, contains no
			* secrets.
			*/ factorSources: [FactorSource],
		/**
			* Settings for this profile in the app, contains default security configs
			* as well as display settings.
			*/ appPreferences: AppPreferences,
		/**
			* An ordered mapping of NetworkID -> `Profile.Network`, containing
			* all the users Accounts, Personas and AuthorizedDapps the user
			* has created and interacted with on this network.
			*/ networks: [ProfileNetwork]
	) {
		self.header = header
		self.factorSources = factorSources
		self.appPreferences = appPreferences
		self.networks = networks
	}
}

// MARK: Sendable
extension Profile: Sendable {}

// MARK: Equatable, Hashable
extension Profile: Equatable, Hashable {
	public static func == (lhs: Profile, rhs: Profile) -> Bool {
		if lhs.header != rhs.header {
			return false
		}
		if lhs.factorSources != rhs.factorSources {
			return false
		}
		if lhs.appPreferences != rhs.appPreferences {
			return false
		}
		if lhs.networks != rhs.networks {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(header)
		hasher.combine(factorSources)
		hasher.combine(appPreferences)
		hasher.combine(networks)
	}
}

// MARK: - FfiConverterTypeProfile
public struct FfiConverterTypeProfile: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Profile {
		try Profile(
			header: FfiConverterTypeHeader.read(from: &buf),
			factorSources: FfiConverterSequenceTypeFactorSource.read(from: &buf),
			appPreferences: FfiConverterTypeAppPreferences.read(from: &buf),
			networks: FfiConverterSequenceTypeProfileNetwork.read(from: &buf)
		)
	}

	public static func write(_ value: Profile, into buf: inout [UInt8]) {
		FfiConverterTypeHeader.write(value.header, into: &buf)
		FfiConverterSequenceTypeFactorSource.write(value.factorSources, into: &buf)
		FfiConverterTypeAppPreferences.write(value.appPreferences, into: &buf)
		FfiConverterSequenceTypeProfileNetwork.write(value.networks, into: &buf)
	}
}

public func FfiConverterTypeProfile_lift(_ buf: RustBuffer) throws -> Profile {
	try FfiConverterTypeProfile.lift(buf)
}

public func FfiConverterTypeProfile_lower(_ value: Profile) -> RustBuffer {
	FfiConverterTypeProfile.lower(value)
}

// MARK: - ProfileNetwork
/**
 * [`Accounts`], [`Personas`] and [`AuthorizedDapps`] for some [`ProfileNetwork`]
 * which user has created/interacted with, all on the same [Radix Network][`NetworkDefinition`],
 * identified by `id` ([`NetworkID`]).
 */
public struct ProfileNetwork {
	/**
	 * The ID of the network that has been used to generate the `accounts` and `personas`
	 * and on which the `authorizedDapps` have been deployed on.
	 */
	public var id: NetworkId
	/**
	 * An ordered set of [`Accounts`]` on this network, which are [`Account`]s
	 * the user has created on this network.
	 */
	public var accounts: [Account]
	/**
	 * An ordered set of [`Personas`] on this network, which are [`Persona`]s
	 * the user has created on this network.
	 */
	public var personas: [Persona]
	/**
	 * An ordered set of [`AuthorizedDapps`] on this network, which are
	 * [`AuthorizedDapp`]s that the user has interacted with.
	 */
	public var authorizedDapps: [AuthorizedDapp]
	/**
	 * Configuration related to resources
	 */
	public var resourcePreferences: [ResourceAppPreference]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The ID of the network that has been used to generate the `accounts` and `personas`
		 * and on which the `authorizedDapps` have been deployed on.
		 */ id: NetworkId,
		/**
			* An ordered set of [`Accounts`]` on this network, which are [`Account`]s
			* the user has created on this network.
			*/ accounts: [Account],
		/**
			* An ordered set of [`Personas`] on this network, which are [`Persona`]s
			* the user has created on this network.
			*/ personas: [Persona],
		/**
			* An ordered set of [`AuthorizedDapps`] on this network, which are
			* [`AuthorizedDapp`]s that the user has interacted with.
			*/ authorizedDapps: [AuthorizedDapp],
		/**
			* Configuration related to resources
			*/ resourcePreferences: [ResourceAppPreference]
	) {
		self.id = id
		self.accounts = accounts
		self.personas = personas
		self.authorizedDapps = authorizedDapps
		self.resourcePreferences = resourcePreferences
	}
}

// MARK: Sendable
extension ProfileNetwork: Sendable {}

// MARK: Equatable, Hashable
extension ProfileNetwork: Equatable, Hashable {
	public static func == (lhs: ProfileNetwork, rhs: ProfileNetwork) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.accounts != rhs.accounts {
			return false
		}
		if lhs.personas != rhs.personas {
			return false
		}
		if lhs.authorizedDapps != rhs.authorizedDapps {
			return false
		}
		if lhs.resourcePreferences != rhs.resourcePreferences {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(accounts)
		hasher.combine(personas)
		hasher.combine(authorizedDapps)
		hasher.combine(resourcePreferences)
	}
}

// MARK: - FfiConverterTypeProfileNetwork
public struct FfiConverterTypeProfileNetwork: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileNetwork {
		try ProfileNetwork(
			id: FfiConverterTypeNetworkID.read(from: &buf),
			accounts: FfiConverterSequenceTypeAccount.read(from: &buf),
			personas: FfiConverterSequenceTypePersona.read(from: &buf),
			authorizedDapps: FfiConverterSequenceTypeAuthorizedDapp.read(from: &buf),
			resourcePreferences: FfiConverterSequenceTypeResourceAppPreference.read(from: &buf)
		)
	}

	public static func write(_ value: ProfileNetwork, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkID.write(value.id, into: &buf)
		FfiConverterSequenceTypeAccount.write(value.accounts, into: &buf)
		FfiConverterSequenceTypePersona.write(value.personas, into: &buf)
		FfiConverterSequenceTypeAuthorizedDapp.write(value.authorizedDapps, into: &buf)
		FfiConverterSequenceTypeResourceAppPreference.write(value.resourcePreferences, into: &buf)
	}
}

public func FfiConverterTypeProfileNetwork_lift(_ buf: RustBuffer) throws -> ProfileNetwork {
	try FfiConverterTypeProfileNetwork.lift(buf)
}

public func FfiConverterTypeProfileNetwork_lower(_ value: ProfileNetwork) -> RustBuffer {
	FfiConverterTypeProfileNetwork.lower(value)
}

// MARK: - RadixConnectMobileSessionRequest
/**
 * The request received from the dApp that needs to be handled.
 */
public struct RadixConnectMobileSessionRequest {
	/**
	 * The id of the session established with the dApp.
	 * Needs to be passed back by the Host as to know which session to respond to.
	 */
	public var sessionId: SessionId
	/**
	 * The interaction received from the dApp.
	 */
	public var interaction: DappToWalletInteractionUnvalidated
	/**
	 * The origin of the dApp.
	 */
	public var origin: DappOrigin
	/**
	 * Whether the origin requires validation.
	 */
	public var originRequiresValidation: Bool

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The id of the session established with the dApp.
		 * Needs to be passed back by the Host as to know which session to respond to.
		 */ sessionId: SessionId,
		/**
			* The interaction received from the dApp.
			*/ interaction: DappToWalletInteractionUnvalidated,
		/**
			* The origin of the dApp.
			*/ origin: DappOrigin,
		/**
			* Whether the origin requires validation.
			*/ originRequiresValidation: Bool
	) {
		self.sessionId = sessionId
		self.interaction = interaction
		self.origin = origin
		self.originRequiresValidation = originRequiresValidation
	}
}

// MARK: Sendable
extension RadixConnectMobileSessionRequest: Sendable {}

// MARK: Equatable, Hashable
extension RadixConnectMobileSessionRequest: Equatable, Hashable {
	public static func == (lhs: RadixConnectMobileSessionRequest, rhs: RadixConnectMobileSessionRequest) -> Bool {
		if lhs.sessionId != rhs.sessionId {
			return false
		}
		if lhs.interaction != rhs.interaction {
			return false
		}
		if lhs.origin != rhs.origin {
			return false
		}
		if lhs.originRequiresValidation != rhs.originRequiresValidation {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(sessionId)
		hasher.combine(interaction)
		hasher.combine(origin)
		hasher.combine(originRequiresValidation)
	}
}

// MARK: - FfiConverterTypeRadixConnectMobileSessionRequest
public struct FfiConverterTypeRadixConnectMobileSessionRequest: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileSessionRequest {
		try RadixConnectMobileSessionRequest(
			sessionId: FfiConverterTypeSessionID.read(from: &buf),
			interaction: FfiConverterTypeDappToWalletInteractionUnvalidated.read(from: &buf),
			origin: FfiConverterTypeDappOrigin.read(from: &buf),
			originRequiresValidation: FfiConverterBool.read(from: &buf)
		)
	}

	public static func write(_ value: RadixConnectMobileSessionRequest, into buf: inout [UInt8]) {
		FfiConverterTypeSessionID.write(value.sessionId, into: &buf)
		FfiConverterTypeDappToWalletInteractionUnvalidated.write(value.interaction, into: &buf)
		FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
		FfiConverterBool.write(value.originRequiresValidation, into: &buf)
	}
}

public func FfiConverterTypeRadixConnectMobileSessionRequest_lift(_ buf: RustBuffer) throws -> RadixConnectMobileSessionRequest {
	try FfiConverterTypeRadixConnectMobileSessionRequest.lift(buf)
}

public func FfiConverterTypeRadixConnectMobileSessionRequest_lower(_ value: RadixConnectMobileSessionRequest) -> RustBuffer {
	FfiConverterTypeRadixConnectMobileSessionRequest.lower(value)
}

// MARK: - RadixConnectMobileWalletResponse
public struct RadixConnectMobileWalletResponse {
	public var sessionId: SessionId
	public var response: WalletToDappInteractionResponse

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(sessionId: SessionId, response: WalletToDappInteractionResponse) {
		self.sessionId = sessionId
		self.response = response
	}
}

// MARK: Sendable
extension RadixConnectMobileWalletResponse: Sendable {}

// MARK: Equatable, Hashable
extension RadixConnectMobileWalletResponse: Equatable, Hashable {
	public static func == (lhs: RadixConnectMobileWalletResponse, rhs: RadixConnectMobileWalletResponse) -> Bool {
		if lhs.sessionId != rhs.sessionId {
			return false
		}
		if lhs.response != rhs.response {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(sessionId)
		hasher.combine(response)
	}
}

// MARK: - FfiConverterTypeRadixConnectMobileWalletResponse
public struct FfiConverterTypeRadixConnectMobileWalletResponse: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileWalletResponse {
		try RadixConnectMobileWalletResponse(
			sessionId: FfiConverterTypeSessionID.read(from: &buf),
			response: FfiConverterTypeWalletToDappInteractionResponse.read(from: &buf)
		)
	}

	public static func write(_ value: RadixConnectMobileWalletResponse, into buf: inout [UInt8]) {
		FfiConverterTypeSessionID.write(value.sessionId, into: &buf)
		FfiConverterTypeWalletToDappInteractionResponse.write(value.response, into: &buf)
	}
}

public func FfiConverterTypeRadixConnectMobileWalletResponse_lift(_ buf: RustBuffer) throws -> RadixConnectMobileWalletResponse {
	try FfiConverterTypeRadixConnectMobileWalletResponse.lift(buf)
}

public func FfiConverterTypeRadixConnectMobileWalletResponse_lower(_ value: RadixConnectMobileWalletResponse) -> RustBuffer {
	FfiConverterTypeRadixConnectMobileWalletResponse.lower(value)
}

// MARK: - RadixConnectPassword
/**
 * The hash of the connection password is used to connect to the Radix Connect Signaling Server,
 * over web sockets. The actual `ConnectionPassword` is used to encrypt all messages sent via
 * the Signaling Server.
 */
public struct RadixConnectPassword {
	public var value: Exactly32Bytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(value: Exactly32Bytes) {
		self.value = value
	}
}

// MARK: Sendable
extension RadixConnectPassword: Sendable {}

// MARK: Equatable, Hashable
extension RadixConnectPassword: Equatable, Hashable {
	public static func == (lhs: RadixConnectPassword, rhs: RadixConnectPassword) -> Bool {
		if lhs.value != rhs.value {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(value)
	}
}

// MARK: - FfiConverterTypeRadixConnectPassword
public struct FfiConverterTypeRadixConnectPassword: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectPassword {
		try RadixConnectPassword(
			value: FfiConverterTypeExactly32Bytes.read(from: &buf)
		)
	}

	public static func write(_ value: RadixConnectPassword, into buf: inout [UInt8]) {
		FfiConverterTypeExactly32Bytes.write(value.value, into: &buf)
	}
}

public func FfiConverterTypeRadixConnectPassword_lift(_ buf: RustBuffer) throws -> RadixConnectPassword {
	try FfiConverterTypeRadixConnectPassword.lift(buf)
}

public func FfiConverterTypeRadixConnectPassword_lower(_ value: RadixConnectPassword) -> RustBuffer {
	FfiConverterTypeRadixConnectPassword.lower(value)
}

// MARK: - RecoveryRoleWithFactorInstances
/**
 * RecoveryRole is used to recover lost access to an entity.
 */
public struct RecoveryRoleWithFactorInstances {
	/**
	 * Factors which are used in combination with other instances, amounting to at
	 * least `threshold` many instances to perform some function with this role.
	 *
	 * # Implementation
	 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
	 * we might wanna use duplicates, allowing us to build a "template"
	 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
	 * meaning an instance of this template at FactorSource level
	 * (`SecurityStructureOfFactorSources`) will contain two different
	 * `TrustedContactFactorSource`s.
	 */
	public var thresholdFactors: [FactorInstance]
	/**
	 * How many threshold factors that must be used to perform some function with this role.
	 */
	public var threshold: UInt8
	/**
	 * Overriding / Super admin / "sudo" / God / factors, **ANY**
	 * single of these factor which can perform the function of this role,
	 * disregarding of `threshold`.
	 */
	public var overrideFactors: [FactorInstance]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Factors which are used in combination with other instances, amounting to at
		 * least `threshold` many instances to perform some function with this role.
		 *
		 * # Implementation
		 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
		 * we might wanna use duplicates, allowing us to build a "template"
		 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
		 * meaning an instance of this template at FactorSource level
		 * (`SecurityStructureOfFactorSources`) will contain two different
		 * `TrustedContactFactorSource`s.
		 */ thresholdFactors: [FactorInstance],
		/**
			* How many threshold factors that must be used to perform some function with this role.
			*/ threshold: UInt8,
		/**
			* Overriding / Super admin / "sudo" / God / factors, **ANY**
			* single of these factor which can perform the function of this role,
			* disregarding of `threshold`.
			*/ overrideFactors: [FactorInstance]
	) {
		self.thresholdFactors = thresholdFactors
		self.threshold = threshold
		self.overrideFactors = overrideFactors
	}
}

// MARK: Sendable
extension RecoveryRoleWithFactorInstances: Sendable {}

// MARK: Equatable, Hashable
extension RecoveryRoleWithFactorInstances: Equatable, Hashable {
	public static func == (lhs: RecoveryRoleWithFactorInstances, rhs: RecoveryRoleWithFactorInstances) -> Bool {
		if lhs.thresholdFactors != rhs.thresholdFactors {
			return false
		}
		if lhs.threshold != rhs.threshold {
			return false
		}
		if lhs.overrideFactors != rhs.overrideFactors {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(thresholdFactors)
		hasher.combine(threshold)
		hasher.combine(overrideFactors)
	}
}

// MARK: - FfiConverterTypeRecoveryRoleWithFactorInstances
public struct FfiConverterTypeRecoveryRoleWithFactorInstances: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryRoleWithFactorInstances {
		try RecoveryRoleWithFactorInstances(
			thresholdFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf),
			threshold: FfiConverterUInt8.read(from: &buf),
			overrideFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf)
		)
	}

	public static func write(_ value: RecoveryRoleWithFactorInstances, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeFactorInstance.write(value.thresholdFactors, into: &buf)
		FfiConverterUInt8.write(value.threshold, into: &buf)
		FfiConverterSequenceTypeFactorInstance.write(value.overrideFactors, into: &buf)
	}
}

public func FfiConverterTypeRecoveryRoleWithFactorInstances_lift(_ buf: RustBuffer) throws -> RecoveryRoleWithFactorInstances {
	try FfiConverterTypeRecoveryRoleWithFactorInstances.lift(buf)
}

public func FfiConverterTypeRecoveryRoleWithFactorInstances_lower(_ value: RecoveryRoleWithFactorInstances) -> RustBuffer {
	FfiConverterTypeRecoveryRoleWithFactorInstances.lower(value)
}

// MARK: - RecoveryRoleWithFactorSourceIDs
/**
 * RecoveryRole is used to recover lost access to an entity.
 */
public struct RecoveryRoleWithFactorSourceIDs {
	/**
	 * Factors which are used in combination with other instances, amounting to at
	 * least `threshold` many instances to perform some function with this role.
	 *
	 * # Implementation
	 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
	 * we might wanna use duplicates, allowing us to build a "template"
	 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
	 * meaning an instance of this template at FactorSource level
	 * (`SecurityStructureOfFactorSources`) will contain two different
	 * `TrustedContactFactorSource`s.
	 */
	public var thresholdFactors: [FactorSourceId]
	/**
	 * How many threshold factors that must be used to perform some function with this role.
	 */
	public var threshold: UInt8
	/**
	 * Overriding / Super admin / "sudo" / God / factors, **ANY**
	 * single of these factor which can perform the function of this role,
	 * disregarding of `threshold`.
	 */
	public var overrideFactors: [FactorSourceId]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Factors which are used in combination with other instances, amounting to at
		 * least `threshold` many instances to perform some function with this role.
		 *
		 * # Implementation
		 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
		 * we might wanna use duplicates, allowing us to build a "template"
		 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
		 * meaning an instance of this template at FactorSource level
		 * (`SecurityStructureOfFactorSources`) will contain two different
		 * `TrustedContactFactorSource`s.
		 */ thresholdFactors: [FactorSourceId],
		/**
			* How many threshold factors that must be used to perform some function with this role.
			*/ threshold: UInt8,
		/**
			* Overriding / Super admin / "sudo" / God / factors, **ANY**
			* single of these factor which can perform the function of this role,
			* disregarding of `threshold`.
			*/ overrideFactors: [FactorSourceId]
	) {
		self.thresholdFactors = thresholdFactors
		self.threshold = threshold
		self.overrideFactors = overrideFactors
	}
}

// MARK: Sendable
extension RecoveryRoleWithFactorSourceIDs: Sendable {}

// MARK: Equatable, Hashable
extension RecoveryRoleWithFactorSourceIDs: Equatable, Hashable {
	public static func == (lhs: RecoveryRoleWithFactorSourceIDs, rhs: RecoveryRoleWithFactorSourceIDs) -> Bool {
		if lhs.thresholdFactors != rhs.thresholdFactors {
			return false
		}
		if lhs.threshold != rhs.threshold {
			return false
		}
		if lhs.overrideFactors != rhs.overrideFactors {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(thresholdFactors)
		hasher.combine(threshold)
		hasher.combine(overrideFactors)
	}
}

// MARK: - FfiConverterTypeRecoveryRoleWithFactorSourceIDs
public struct FfiConverterTypeRecoveryRoleWithFactorSourceIDs: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryRoleWithFactorSourceIDs {
		try RecoveryRoleWithFactorSourceIDs(
			thresholdFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf),
			threshold: FfiConverterUInt8.read(from: &buf),
			overrideFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
		)
	}

	public static func write(_ value: RecoveryRoleWithFactorSourceIDs, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeFactorSourceID.write(value.thresholdFactors, into: &buf)
		FfiConverterUInt8.write(value.threshold, into: &buf)
		FfiConverterSequenceTypeFactorSourceID.write(value.overrideFactors, into: &buf)
	}
}

public func FfiConverterTypeRecoveryRoleWithFactorSourceIDs_lift(_ buf: RustBuffer) throws -> RecoveryRoleWithFactorSourceIDs {
	try FfiConverterTypeRecoveryRoleWithFactorSourceIDs.lift(buf)
}

public func FfiConverterTypeRecoveryRoleWithFactorSourceIDs_lower(_ value: RecoveryRoleWithFactorSourceIDs) -> RustBuffer {
	FfiConverterTypeRecoveryRoleWithFactorSourceIDs.lower(value)
}

// MARK: - RecoveryRoleWithFactorSources
/**
 * RecoveryRole is used to recover lost access to an entity.
 */
public struct RecoveryRoleWithFactorSources {
	/**
	 * Factors which are used in combination with other instances, amounting to at
	 * least `threshold` many instances to perform some function with this role.
	 *
	 * # Implementation
	 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
	 * we might wanna use duplicates, allowing us to build a "template"
	 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
	 * meaning an instance of this template at FactorSource level
	 * (`SecurityStructureOfFactorSources`) will contain two different
	 * `TrustedContactFactorSource`s.
	 */
	public var thresholdFactors: [FactorSource]
	/**
	 * How many threshold factors that must be used to perform some function with this role.
	 */
	public var threshold: UInt8
	/**
	 * Overriding / Super admin / "sudo" / God / factors, **ANY**
	 * single of these factor which can perform the function of this role,
	 * disregarding of `threshold`.
	 */
	public var overrideFactors: [FactorSource]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Factors which are used in combination with other instances, amounting to at
		 * least `threshold` many instances to perform some function with this role.
		 *
		 * # Implementation
		 * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
		 * we might wanna use duplicates, allowing us to build a "template"
		 * structure where a role might contain two `FactorSourceKind::TrustedContact`,
		 * meaning an instance of this template at FactorSource level
		 * (`SecurityStructureOfFactorSources`) will contain two different
		 * `TrustedContactFactorSource`s.
		 */ thresholdFactors: [FactorSource],
		/**
			* How many threshold factors that must be used to perform some function with this role.
			*/ threshold: UInt8,
		/**
			* Overriding / Super admin / "sudo" / God / factors, **ANY**
			* single of these factor which can perform the function of this role,
			* disregarding of `threshold`.
			*/ overrideFactors: [FactorSource]
	) {
		self.thresholdFactors = thresholdFactors
		self.threshold = threshold
		self.overrideFactors = overrideFactors
	}
}

// MARK: Sendable
extension RecoveryRoleWithFactorSources: Sendable {}

// MARK: Equatable, Hashable
extension RecoveryRoleWithFactorSources: Equatable, Hashable {
	public static func == (lhs: RecoveryRoleWithFactorSources, rhs: RecoveryRoleWithFactorSources) -> Bool {
		if lhs.thresholdFactors != rhs.thresholdFactors {
			return false
		}
		if lhs.threshold != rhs.threshold {
			return false
		}
		if lhs.overrideFactors != rhs.overrideFactors {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(thresholdFactors)
		hasher.combine(threshold)
		hasher.combine(overrideFactors)
	}
}

// MARK: - FfiConverterTypeRecoveryRoleWithFactorSources
public struct FfiConverterTypeRecoveryRoleWithFactorSources: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryRoleWithFactorSources {
		try RecoveryRoleWithFactorSources(
			thresholdFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf),
			threshold: FfiConverterUInt8.read(from: &buf),
			overrideFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf)
		)
	}

	public static func write(_ value: RecoveryRoleWithFactorSources, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeFactorSource.write(value.thresholdFactors, into: &buf)
		FfiConverterUInt8.write(value.threshold, into: &buf)
		FfiConverterSequenceTypeFactorSource.write(value.overrideFactors, into: &buf)
	}
}

public func FfiConverterTypeRecoveryRoleWithFactorSources_lift(_ buf: RustBuffer) throws -> RecoveryRoleWithFactorSources {
	try FfiConverterTypeRecoveryRoleWithFactorSources.lift(buf)
}

public func FfiConverterTypeRecoveryRoleWithFactorSources_lower(_ value: RecoveryRoleWithFactorSources) -> RustBuffer {
	FfiConverterTypeRecoveryRoleWithFactorSources.lower(value)
}

// MARK: - RequestedQuantity
/**
 * A requested (by Dapp) quantity, e.g. "I want AT LEAST 3 account addresses" or
 * "I want EXACTLY 2 email addresses".
 */
public struct RequestedQuantity {
	public var quantifier: RequestedNumberQuantifier
	public var quantity: UInt16

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(quantifier: RequestedNumberQuantifier, quantity: UInt16) {
		self.quantifier = quantifier
		self.quantity = quantity
	}
}

// MARK: Sendable
extension RequestedQuantity: Sendable {}

// MARK: Equatable, Hashable
extension RequestedQuantity: Equatable, Hashable {
	public static func == (lhs: RequestedQuantity, rhs: RequestedQuantity) -> Bool {
		if lhs.quantifier != rhs.quantifier {
			return false
		}
		if lhs.quantity != rhs.quantity {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(quantifier)
		hasher.combine(quantity)
	}
}

// MARK: - FfiConverterTypeRequestedQuantity
public struct FfiConverterTypeRequestedQuantity: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedQuantity {
		try RequestedQuantity(
			quantifier: FfiConverterTypeRequestedNumberQuantifier.read(from: &buf),
			quantity: FfiConverterUInt16.read(from: &buf)
		)
	}

	public static func write(_ value: RequestedQuantity, into buf: inout [UInt8]) {
		FfiConverterTypeRequestedNumberQuantifier.write(value.quantifier, into: &buf)
		FfiConverterUInt16.write(value.quantity, into: &buf)
	}
}

public func FfiConverterTypeRequestedQuantity_lift(_ buf: RustBuffer) throws -> RequestedQuantity {
	try FfiConverterTypeRequestedQuantity.lift(buf)
}

public func FfiConverterTypeRequestedQuantity_lower(_ value: RequestedQuantity) -> RustBuffer {
	FfiConverterTypeRequestedQuantity.lower(value)
}

// MARK: - ResourceAddress
/**
 * Addresses identifying an asset, either fungible (Token) or non_fungible (NFT), on the Radix network, e.g.
 * `"resource_rdx1tknxxxxxxxxxradxrdxxxxxxxxx009923554798xxxxxxxxxradxrd"`
 * Being the unique identifier of the Radix Token, the Rad, on mainnet.
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of ResourceAddresses:
 * * GlobalFungibleResourceManager
 * * GlobalNonFungibleResourceManager
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalResourceAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L236-L239
 */
public struct ResourceAddress {
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension ResourceAddress: Sendable {}

// MARK: Equatable, Hashable
extension ResourceAddress: Equatable, Hashable {
	public static func == (lhs: ResourceAddress, rhs: ResourceAddress) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeResourceAddress
public struct FfiConverterTypeResourceAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAddress {
		try ResourceAddress(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: ResourceAddress, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeResourceAddress_lift(_ buf: RustBuffer) throws -> ResourceAddress {
	try FfiConverterTypeResourceAddress.lift(buf)
}

public func FfiConverterTypeResourceAddress_lower(_ value: ResourceAddress) -> RustBuffer {
	FfiConverterTypeResourceAddress.lower(value)
}

// MARK: - ResourceAppPreference
/**
 * A preference the user has configured off-ledger for a given resource.
 * Allows users, for example, to hide a given resource on their accounts.
 *
 * Named like this to differ from RET's `ResourcePreference`.
 */
public struct ResourceAppPreference {
	/**
	 * The resource for which the preference is set up.
	 */
	public var resource: ResourceIdentifier
	/**
	 * The visibility of the resource (hidden or visible).
	 */
	public var visibility: ResourceVisibility

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The resource for which the preference is set up.
		 */ resource: ResourceIdentifier,
		/**
			* The visibility of the resource (hidden or visible).
			*/ visibility: ResourceVisibility
	) {
		self.resource = resource
		self.visibility = visibility
	}
}

// MARK: Sendable
extension ResourceAppPreference: Sendable {}

// MARK: Equatable, Hashable
extension ResourceAppPreference: Equatable, Hashable {
	public static func == (lhs: ResourceAppPreference, rhs: ResourceAppPreference) -> Bool {
		if lhs.resource != rhs.resource {
			return false
		}
		if lhs.visibility != rhs.visibility {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(resource)
		hasher.combine(visibility)
	}
}

// MARK: - FfiConverterTypeResourceAppPreference
public struct FfiConverterTypeResourceAppPreference: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAppPreference {
		try ResourceAppPreference(
			resource: FfiConverterTypeResourceIdentifier.read(from: &buf),
			visibility: FfiConverterTypeResourceVisibility.read(from: &buf)
		)
	}

	public static func write(_ value: ResourceAppPreference, into buf: inout [UInt8]) {
		FfiConverterTypeResourceIdentifier.write(value.resource, into: &buf)
		FfiConverterTypeResourceVisibility.write(value.visibility, into: &buf)
	}
}

public func FfiConverterTypeResourceAppPreference_lift(_ buf: RustBuffer) throws -> ResourceAppPreference {
	try FfiConverterTypeResourceAppPreference.lift(buf)
}

public func FfiConverterTypeResourceAppPreference_lower(_ value: ResourceAppPreference) -> RustBuffer {
	FfiConverterTypeResourceAppPreference.lower(value)
}

// MARK: - SargonBuildInformation
public struct SargonBuildInformation {
	public var sargonVersion: String
	public var dependencies: SargonDependencies

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(sargonVersion: String, dependencies: SargonDependencies) {
		self.sargonVersion = sargonVersion
		self.dependencies = dependencies
	}
}

// MARK: Sendable
extension SargonBuildInformation: Sendable {}

// MARK: Equatable, Hashable
extension SargonBuildInformation: Equatable, Hashable {
	public static func == (lhs: SargonBuildInformation, rhs: SargonBuildInformation) -> Bool {
		if lhs.sargonVersion != rhs.sargonVersion {
			return false
		}
		if lhs.dependencies != rhs.dependencies {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(sargonVersion)
		hasher.combine(dependencies)
	}
}

// MARK: - FfiConverterTypeSargonBuildInformation
public struct FfiConverterTypeSargonBuildInformation: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonBuildInformation {
		try SargonBuildInformation(
			sargonVersion: FfiConverterString.read(from: &buf),
			dependencies: FfiConverterTypeSargonDependencies.read(from: &buf)
		)
	}

	public static func write(_ value: SargonBuildInformation, into buf: inout [UInt8]) {
		FfiConverterString.write(value.sargonVersion, into: &buf)
		FfiConverterTypeSargonDependencies.write(value.dependencies, into: &buf)
	}
}

public func FfiConverterTypeSargonBuildInformation_lift(_ buf: RustBuffer) throws -> SargonBuildInformation {
	try FfiConverterTypeSargonBuildInformation.lift(buf)
}

public func FfiConverterTypeSargonBuildInformation_lower(_ value: SargonBuildInformation) -> RustBuffer {
	FfiConverterTypeSargonBuildInformation.lower(value)
}

// MARK: - SargonDependencies
public struct SargonDependencies {
	public var radixEngineToolkit: DependencyInformation
	public var scryptoRadixEngine: DependencyInformation

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(radixEngineToolkit: DependencyInformation, scryptoRadixEngine: DependencyInformation) {
		self.radixEngineToolkit = radixEngineToolkit
		self.scryptoRadixEngine = scryptoRadixEngine
	}
}

// MARK: Sendable
extension SargonDependencies: Sendable {}

// MARK: Equatable, Hashable
extension SargonDependencies: Equatable, Hashable {
	public static func == (lhs: SargonDependencies, rhs: SargonDependencies) -> Bool {
		if lhs.radixEngineToolkit != rhs.radixEngineToolkit {
			return false
		}
		if lhs.scryptoRadixEngine != rhs.scryptoRadixEngine {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(radixEngineToolkit)
		hasher.combine(scryptoRadixEngine)
	}
}

// MARK: - FfiConverterTypeSargonDependencies
public struct FfiConverterTypeSargonDependencies: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonDependencies {
		try SargonDependencies(
			radixEngineToolkit: FfiConverterTypeDependencyInformation.read(from: &buf),
			scryptoRadixEngine: FfiConverterTypeDependencyInformation.read(from: &buf)
		)
	}

	public static func write(_ value: SargonDependencies, into buf: inout [UInt8]) {
		FfiConverterTypeDependencyInformation.write(value.radixEngineToolkit, into: &buf)
		FfiConverterTypeDependencyInformation.write(value.scryptoRadixEngine, into: &buf)
	}
}

public func FfiConverterTypeSargonDependencies_lift(_ buf: RustBuffer) throws -> SargonDependencies {
	try FfiConverterTypeSargonDependencies.lift(buf)
}

public func FfiConverterTypeSargonDependencies_lower(_ value: SargonDependencies) -> RustBuffer {
	FfiConverterTypeSargonDependencies.lower(value)
}

// MARK: - SavedGateways
/**
 * The currently used Gateway and a collection of other by user added
 * or predefined Gateways the user can switch to.
 */
public struct SavedGateways {
	/**
	 * The currently used Gateway, when a user query's asset balances of
	 * accounts or submits transactions, this Gateway will be used.
	 */
	public var current: Gateway
	/**
	 * Other by user added or predefined Gateways the user can switch to.
	 * It might be Gateways with different URLs on the SAME network, or
	 * other networks, the identifier of a Gateway is the URL.
	 */
	public var other: [Gateway]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The currently used Gateway, when a user query's asset balances of
		 * accounts or submits transactions, this Gateway will be used.
		 */ current: Gateway,
		/**
			* Other by user added or predefined Gateways the user can switch to.
			* It might be Gateways with different URLs on the SAME network, or
			* other networks, the identifier of a Gateway is the URL.
			*/ other: [Gateway]
	) {
		self.current = current
		self.other = other
	}
}

// MARK: Sendable
extension SavedGateways: Sendable {}

// MARK: Equatable, Hashable
extension SavedGateways: Equatable, Hashable {
	public static func == (lhs: SavedGateways, rhs: SavedGateways) -> Bool {
		if lhs.current != rhs.current {
			return false
		}
		if lhs.other != rhs.other {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(current)
		hasher.combine(other)
	}
}

// MARK: - FfiConverterTypeSavedGateways
public struct FfiConverterTypeSavedGateways: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SavedGateways {
		try SavedGateways(
			current: FfiConverterTypeGateway.read(from: &buf),
			other: FfiConverterSequenceTypeGateway.read(from: &buf)
		)
	}

	public static func write(_ value: SavedGateways, into buf: inout [UInt8]) {
		FfiConverterTypeGateway.write(value.current, into: &buf)
		FfiConverterSequenceTypeGateway.write(value.other, into: &buf)
	}
}

public func FfiConverterTypeSavedGateways_lift(_ buf: RustBuffer) throws -> SavedGateways {
	try FfiConverterTypeSavedGateways.lift(buf)
}

public func FfiConverterTypeSavedGateways_lower(_ value: SavedGateways) -> RustBuffer {
	FfiConverterTypeSavedGateways.lower(value)
}

// MARK: - Secp256k1PublicKey
/**
 * A `secp256k1` public key used to verify cryptographic signatures (ECDSA signatures).
 */
public struct Secp256k1PublicKey {
	fileprivate let secretMagic: BagOfBytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: BagOfBytes) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension Secp256k1PublicKey: Sendable {}

// MARK: Equatable, Hashable
extension Secp256k1PublicKey: Equatable, Hashable {
	public static func == (lhs: Secp256k1PublicKey, rhs: Secp256k1PublicKey) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeSecp256k1PublicKey
public struct FfiConverterTypeSecp256k1PublicKey: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1PublicKey {
		try Secp256k1PublicKey(
			secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
		)
	}

	public static func write(_ value: Secp256k1PublicKey, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeSecp256k1PublicKey_lift(_ buf: RustBuffer) throws -> Secp256k1PublicKey {
	try FfiConverterTypeSecp256k1PublicKey.lift(buf)
}

public func FfiConverterTypeSecp256k1PublicKey_lower(_ value: Secp256k1PublicKey) -> RustBuffer {
	FfiConverterTypeSecp256k1PublicKey.lower(value)
}

// MARK: - Secp256k1Signature
/**
 * Represents an Secp256k1 signature.
 */
public struct Secp256k1Signature {
	public var bytes: Exactly65Bytes

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(bytes: Exactly65Bytes) {
		self.bytes = bytes
	}
}

// MARK: Sendable
extension Secp256k1Signature: Sendable {}

// MARK: Equatable, Hashable
extension Secp256k1Signature: Equatable, Hashable {
	public static func == (lhs: Secp256k1Signature, rhs: Secp256k1Signature) -> Bool {
		if lhs.bytes != rhs.bytes {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(bytes)
	}
}

// MARK: - FfiConverterTypeSecp256k1Signature
public struct FfiConverterTypeSecp256k1Signature: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1Signature {
		try Secp256k1Signature(
			bytes: FfiConverterTypeExactly65Bytes.read(from: &buf)
		)
	}

	public static func write(_ value: Secp256k1Signature, into buf: inout [UInt8]) {
		FfiConverterTypeExactly65Bytes.write(value.bytes, into: &buf)
	}
}

public func FfiConverterTypeSecp256k1Signature_lift(_ buf: RustBuffer) throws -> Secp256k1Signature {
	try FfiConverterTypeSecp256k1Signature.lift(buf)
}

public func FfiConverterTypeSecp256k1Signature_lower(_ value: Secp256k1Signature) -> RustBuffer {
	FfiConverterTypeSecp256k1Signature.lower(value)
}

// MARK: - SecuredEntityControl
/**
 * Advanced security control of an entity which has been "securified",
 * meaning an MFA security structure (`SecurityStructureOfFactorSources`)
 * which user has created has been applied to it.
 */
public struct SecuredEntityControl {
	/**
	 * The address of the access controller which controls this entity.
	 *
	 * Looking up the public key (hashes) set in the key-value store at
	 * this address reveils the true factors (public keys) used to protect
	 * this entity. It will be the same as the ones in `security_structure`
	 * if we have not changed them locally, which we should not do unless
	 * we are sure the Ledger corresponds to the values in `security_structure`.
	 */
	public var accessControllerAddress: AccessControllerAddress
	/**
	 * The believed-to-be-current security structure of FactorInstances which
	 * secures this entity.
	 */
	public var securityStructure: SecurityStructureOfFactorInstances

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The address of the access controller which controls this entity.
		 *
		 * Looking up the public key (hashes) set in the key-value store at
		 * this address reveils the true factors (public keys) used to protect
		 * this entity. It will be the same as the ones in `security_structure`
		 * if we have not changed them locally, which we should not do unless
		 * we are sure the Ledger corresponds to the values in `security_structure`.
		 */ accessControllerAddress: AccessControllerAddress,
		/**
			* The believed-to-be-current security structure of FactorInstances which
			* secures this entity.
			*/ securityStructure: SecurityStructureOfFactorInstances
	) {
		self.accessControllerAddress = accessControllerAddress
		self.securityStructure = securityStructure
	}
}

// MARK: Sendable
extension SecuredEntityControl: Sendable {}

// MARK: Equatable, Hashable
extension SecuredEntityControl: Equatable, Hashable {
	public static func == (lhs: SecuredEntityControl, rhs: SecuredEntityControl) -> Bool {
		if lhs.accessControllerAddress != rhs.accessControllerAddress {
			return false
		}
		if lhs.securityStructure != rhs.securityStructure {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(accessControllerAddress)
		hasher.combine(securityStructure)
	}
}

// MARK: - FfiConverterTypeSecuredEntityControl
public struct FfiConverterTypeSecuredEntityControl: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecuredEntityControl {
		try SecuredEntityControl(
			accessControllerAddress: FfiConverterTypeAccessControllerAddress.read(from: &buf),
			securityStructure: FfiConverterTypeSecurityStructureOfFactorInstances.read(from: &buf)
		)
	}

	public static func write(_ value: SecuredEntityControl, into buf: inout [UInt8]) {
		FfiConverterTypeAccessControllerAddress.write(value.accessControllerAddress, into: &buf)
		FfiConverterTypeSecurityStructureOfFactorInstances.write(value.securityStructure, into: &buf)
	}
}

public func FfiConverterTypeSecuredEntityControl_lift(_ buf: RustBuffer) throws -> SecuredEntityControl {
	try FfiConverterTypeSecuredEntityControl.lift(buf)
}

public func FfiConverterTypeSecuredEntityControl_lower(_ value: SecuredEntityControl) -> RustBuffer {
	FfiConverterTypeSecuredEntityControl.lower(value)
}

// MARK: - SecurifiedU30
public struct SecurifiedU30 {
	fileprivate let secretMagic: U30

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: U30) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension SecurifiedU30: Sendable {}

// MARK: Equatable, Hashable
extension SecurifiedU30: Equatable, Hashable {
	public static func == (lhs: SecurifiedU30, rhs: SecurifiedU30) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeSecurifiedU30
public struct FfiConverterTypeSecurifiedU30: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurifiedU30 {
		try SecurifiedU30(
			secretMagic: FfiConverterTypeU30.read(from: &buf)
		)
	}

	public static func write(_ value: SecurifiedU30, into buf: inout [UInt8]) {
		FfiConverterTypeU30.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeSecurifiedU30_lift(_ buf: RustBuffer) throws -> SecurifiedU30 {
	try FfiConverterTypeSecurifiedU30.lift(buf)
}

public func FfiConverterTypeSecurifiedU30_lower(_ value: SecurifiedU30) -> RustBuffer {
	FfiConverterTypeSecurifiedU30.lower(value)
}

// MARK: - Security
/**
 * Controls e.g. if Profile Snapshot gets synced to iCloud or not, and whether
 * developer mode is enabled or not. In future (MFA) we will also save a list of
 * MFA security structure configurations.
 */
public struct Security {
	public var isCloudProfileSyncEnabled: Bool
	public var isDeveloperModeEnabled: Bool
	public var isAdvancedLockEnabled: Bool
	public var securityStructuresOfFactorSourceIds: [SecurityStructureOfFactorSourceIDs]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(isCloudProfileSyncEnabled: Bool, isDeveloperModeEnabled: Bool, isAdvancedLockEnabled: Bool, securityStructuresOfFactorSourceIds: [SecurityStructureOfFactorSourceIDs]) {
		self.isCloudProfileSyncEnabled = isCloudProfileSyncEnabled
		self.isDeveloperModeEnabled = isDeveloperModeEnabled
		self.isAdvancedLockEnabled = isAdvancedLockEnabled
		self.securityStructuresOfFactorSourceIds = securityStructuresOfFactorSourceIds
	}
}

// MARK: Sendable
extension Security: Sendable {}

// MARK: Equatable, Hashable
extension Security: Equatable, Hashable {
	public static func == (lhs: Security, rhs: Security) -> Bool {
		if lhs.isCloudProfileSyncEnabled != rhs.isCloudProfileSyncEnabled {
			return false
		}
		if lhs.isDeveloperModeEnabled != rhs.isDeveloperModeEnabled {
			return false
		}
		if lhs.isAdvancedLockEnabled != rhs.isAdvancedLockEnabled {
			return false
		}
		if lhs.securityStructuresOfFactorSourceIds != rhs.securityStructuresOfFactorSourceIds {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(isCloudProfileSyncEnabled)
		hasher.combine(isDeveloperModeEnabled)
		hasher.combine(isAdvancedLockEnabled)
		hasher.combine(securityStructuresOfFactorSourceIds)
	}
}

// MARK: - FfiConverterTypeSecurity
public struct FfiConverterTypeSecurity: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Security {
		try Security(
			isCloudProfileSyncEnabled: FfiConverterBool.read(from: &buf),
			isDeveloperModeEnabled: FfiConverterBool.read(from: &buf),
			isAdvancedLockEnabled: FfiConverterBool.read(from: &buf),
			securityStructuresOfFactorSourceIds: FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.read(from: &buf)
		)
	}

	public static func write(_ value: Security, into buf: inout [UInt8]) {
		FfiConverterBool.write(value.isCloudProfileSyncEnabled, into: &buf)
		FfiConverterBool.write(value.isDeveloperModeEnabled, into: &buf)
		FfiConverterBool.write(value.isAdvancedLockEnabled, into: &buf)
		FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.write(value.securityStructuresOfFactorSourceIds, into: &buf)
	}
}

public func FfiConverterTypeSecurity_lift(_ buf: RustBuffer) throws -> Security {
	try FfiConverterTypeSecurity.lift(buf)
}

public func FfiConverterTypeSecurity_lower(_ value: Security) -> RustBuffer {
	FfiConverterTypeSecurity.lower(value)
}

// MARK: - SecurityQuestionNotProductionReadyExpectedAnswerFormat
/**
 *  NOT PRODUCTION READY YET 
 * A specification of expected format for an answer to a security question.
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityQuestionNotProductionReadyExpectedAnswerFormat {
	/**
	 * E.g. `"<CITY>, <YEAR>"`
	 */
	public var answerStructure: String
	/**
	 * An example of a possible answer that matches `answer_structure`.
	 * E.g. `"Berlin, 1976"`
	 */
	public var exampleAnswer: String
	/**
	 * If user is about to select the question:
	 * `"What was the name of your first stuffed animal?"`
	 *
	 * Then we can discourage the user from selecting that question
	 * if the answer is in `["Teddy", "Peter Rabbit", "Winnie (the Poh)"]`
	 */
	public var unsafeAnswers: [String]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * E.g. `"<CITY>, <YEAR>"`
		 */ answerStructure: String,
		/**
			* An example of a possible answer that matches `answer_structure`.
			* E.g. `"Berlin, 1976"`
			*/ exampleAnswer: String,
		/**
			* If user is about to select the question:
			* `"What was the name of your first stuffed animal?"`
			*
			* Then we can discourage the user from selecting that question
			* if the answer is in `["Teddy", "Peter Rabbit", "Winnie (the Poh)"]`
			*/ unsafeAnswers: [String]
	) {
		self.answerStructure = answerStructure
		self.exampleAnswer = exampleAnswer
		self.unsafeAnswers = unsafeAnswers
	}
}

// MARK: Sendable
extension SecurityQuestionNotProductionReadyExpectedAnswerFormat: Sendable {}

// MARK: Equatable, Hashable
extension SecurityQuestionNotProductionReadyExpectedAnswerFormat: Equatable, Hashable {
	public static func == (lhs: SecurityQuestionNotProductionReadyExpectedAnswerFormat, rhs: SecurityQuestionNotProductionReadyExpectedAnswerFormat) -> Bool {
		if lhs.answerStructure != rhs.answerStructure {
			return false
		}
		if lhs.exampleAnswer != rhs.exampleAnswer {
			return false
		}
		if lhs.unsafeAnswers != rhs.unsafeAnswers {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(answerStructure)
		hasher.combine(exampleAnswer)
		hasher.combine(unsafeAnswers)
	}
}

// MARK: - FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat
public struct FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionNotProductionReadyExpectedAnswerFormat {
		try SecurityQuestionNotProductionReadyExpectedAnswerFormat(
			answerStructure: FfiConverterString.read(from: &buf),
			exampleAnswer: FfiConverterString.read(from: &buf),
			unsafeAnswers: FfiConverterSequenceString.read(from: &buf)
		)
	}

	public static func write(_ value: SecurityQuestionNotProductionReadyExpectedAnswerFormat, into buf: inout [UInt8]) {
		FfiConverterString.write(value.answerStructure, into: &buf)
		FfiConverterString.write(value.exampleAnswer, into: &buf)
		FfiConverterSequenceString.write(value.unsafeAnswers, into: &buf)
	}
}

public func FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat_lift(_ buf: RustBuffer) throws -> SecurityQuestionNotProductionReadyExpectedAnswerFormat {
	try FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat.lift(buf)
}

public func FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat_lower(_ value: SecurityQuestionNotProductionReadyExpectedAnswerFormat) -> RustBuffer {
	FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat.lower(value)
}

// MARK: - SecurityQuestionsSealedNotProductionReadyMnemonic
/**
 *  NOT PRODUCTION READY YET 
 * A mnemonic encrypted by answers to security questions
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityQuestionsSealedNotProductionReadyMnemonic {
	public var securityQuestions: [SecurityNotProductionReadyQuestion]
	/**
	 * A versioned Key Derivation Function (KDF) algorithm used to produce a set
	 * of Encryption keys from a set of security questions and answers
	 */
	public var kdfScheme: SecurityQuestionsNotProductionReadyKdfScheme
	/**
	 * The scheme used to encrypt the Security Questions factor source
	 * mnemonic using one combination of answers to questions, one of many.
	 */
	public var encryptionScheme: EncryptionScheme
	/**
	 * The N many encryptions of the mnemonic, where N corresponds to the number of derived keys
	 * from the `keyDerivationScheme`
	 */
	public var encryptions: [Exactly60Bytes]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(securityQuestions: [SecurityNotProductionReadyQuestion],
	            /**
	            	* A versioned Key Derivation Function (KDF) algorithm used to produce a set
	            	* of Encryption keys from a set of security questions and answers
	            	*/ kdfScheme: SecurityQuestionsNotProductionReadyKdfScheme,
	            /**
	            	* The scheme used to encrypt the Security Questions factor source
	            	* mnemonic using one combination of answers to questions, one of many.
	            	*/ encryptionScheme: EncryptionScheme,
	            /**
	            	* The N many encryptions of the mnemonic, where N corresponds to the number of derived keys
	            	* from the `keyDerivationScheme`
	            	*/ encryptions: [Exactly60Bytes])
	{
		self.securityQuestions = securityQuestions
		self.kdfScheme = kdfScheme
		self.encryptionScheme = encryptionScheme
		self.encryptions = encryptions
	}
}

// MARK: Sendable
extension SecurityQuestionsSealedNotProductionReadyMnemonic: Sendable {}

// MARK: Equatable, Hashable
extension SecurityQuestionsSealedNotProductionReadyMnemonic: Equatable, Hashable {
	public static func == (lhs: SecurityQuestionsSealedNotProductionReadyMnemonic, rhs: SecurityQuestionsSealedNotProductionReadyMnemonic) -> Bool {
		if lhs.securityQuestions != rhs.securityQuestions {
			return false
		}
		if lhs.kdfScheme != rhs.kdfScheme {
			return false
		}
		if lhs.encryptionScheme != rhs.encryptionScheme {
			return false
		}
		if lhs.encryptions != rhs.encryptions {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(securityQuestions)
		hasher.combine(kdfScheme)
		hasher.combine(encryptionScheme)
		hasher.combine(encryptions)
	}
}

// MARK: - FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic
public struct FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsSealedNotProductionReadyMnemonic {
		try SecurityQuestionsSealedNotProductionReadyMnemonic(
			securityQuestions: FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question.read(from: &buf),
			kdfScheme: FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme.read(from: &buf),
			encryptionScheme: FfiConverterTypeEncryptionScheme.read(from: &buf),
			encryptions: FfiConverterSequenceTypeExactly60Bytes.read(from: &buf)
		)
	}

	public static func write(_ value: SecurityQuestionsSealedNotProductionReadyMnemonic, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question.write(value.securityQuestions, into: &buf)
		FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme.write(value.kdfScheme, into: &buf)
		FfiConverterTypeEncryptionScheme.write(value.encryptionScheme, into: &buf)
		FfiConverterSequenceTypeExactly60Bytes.write(value.encryptions, into: &buf)
	}
}

public func FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic_lift(_ buf: RustBuffer) throws -> SecurityQuestionsSealedNotProductionReadyMnemonic {
	try FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic.lift(buf)
}

public func FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic_lower(_ value: SecurityQuestionsSealedNotProductionReadyMnemonic) -> RustBuffer {
	FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic.lower(value)
}

// MARK: - SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold
/**
 *  NOT PRODUCTION READY YET 
 * A key derivation function which produces Encryption Keys from a set of
 * key exchange keys, by performing Diffie-Hellman key exchange on each
 * Key Exchange Key in a Set, by "folding" from left to right.
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold {
	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init() {}
}

// MARK: Sendable
extension SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold: Sendable {}

// MARK: Equatable, Hashable
extension SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold: Equatable, Hashable {
	public static func == (lhs: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold, rhs: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold) -> Bool {
		true
	}

	public func hash(into hasher: inout Hasher) {}
}

// MARK: - FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold
public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold {
		SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold()
	}

	public static func write(_ value: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold, into buf: inout [UInt8]) {}
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold {
	try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold_lower(_ value: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold) -> RustBuffer {
	FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.lower(value)
}

// MARK: - SecurityQuestionsNotProductionReadyFactorSource
/**
 *  NOT PRODUCTION READY YET 
 * A mnemonic "sealed" by "security questions" (personal questions).
 *
 * The user select P personal questions from a set of Q predefined questions,
 * then answers them. The user will be able to "open" (decrypt) the "sealed"
 * (encrypted) mnemonic by providing at least P-1 correct answers to the P,
 * questions, that is to say, she is allowed to input one incorrect answer.
 * This is important since it makes this factor source kind more convenient
 * to use, especially if a significant time has passed between user answering
 * the questions for the first and the second time.
 *
 * In order to make it possible for user to input one incorrect answer, we need
 * to encrypt the mnemonic with many keys, keys being formed from many combinations
 * of question-answer-based input. To do this we use a function `qna2bin`
 * (question and answer to binary), to deterministically form Curve25519 key pairs,
 * P many (one per question/answer pair), and then we combine these keys using
 * ECDH (key exchange) to form composite (symmetric) encryption keys using P-1
 * many Ed25519 keys per composite encryption key.
 *
 * E.g. User selects 6 questions out of 20:
 * Q1: "What was the make and models of your first car?"
 * Q2: "In which town and which year did your parents meet?"
 * Q3: "What was the name of your first stuffed animal?"
 * Q4: "What was the name of the boy or the girl you first kissed?"
 * Q5: "What was the first exam you failed?"
 * Q6: "What is the middle name of your youngest child?"
 *
 * She answers them, forming
 * `let qa: Vec<(Questions, Answer)> = [(q_0, a_0), (q_1, a_1), .., (q_5, a_5)]`
 * question, answer pairs.
 *
 * The answers will be "normalized", trying to make it easier for user to provide
 * the same used answer later in time, we can do this by for example removing
 * whitespace, delimiters and apostrophes, and lowercase all chars.
 *
 * We form 6 binary inputs, call them `bins` using function `qna2bin` taking a
 * question/answer pair as input and outputting 32 bytes.
 * `let bins: Vec<Exactly32Bytes> = qa.iter().map(qna2bin).collect()`
 *
 * We form 6 X25519PrivateKey meant for Diffie-Hellman key exchange from `bin`
 * `let ec_keys: Vec<X25519PrivateKey> = bins.iter().map(bin2key).collect()`
 *
 * We form ["6 choose 4" ("P choose P-1")][choose] = 15 many combinations
 * (e.g. using [`combinations method from itertools`](itertools))
 *
 * ```ignore
 * let k = 4;
 * assert_eq!(ec_keys.len(), 6);
 * let key_combinations = Vec<Vec<X25519PrivateKey>> = ec_keys.combinations(k);
 * assert_eq!(key_combinations.len(), 15);
 * assert_eq!(key_combinations.iter().all(|v| v.len() == k);
 * ```
 *
 * We map the 15 `Vec<X25519PrivateKey>` into `X25519PublicKeys` using `multi_party_ecdh`:
 *
 * ```ignore
 * let ecdh_keys: Vec<X25519PublicKey> = key_combinations.iter().map(multi_party_ecdh).collect();
 * assert_eq!(sec_keys.len(), 15);
 * ```
 *
 * Where `multi_party_ecdh` is a function taking `Vec<X25519PrivateKey>` as input and
 * returning a `Key<Aes256Gcm>` by doing key exchange between all keys, like so:
 *
 * ```ignore
 * fn key_exchange_between_more_than_two_keys(
 * &self,
 * between: Vec<&X25519PrivateKey>,
 * ) -> X25519PublicKey {
 * let mut private_keys = between.clone();
 * assert!(private_keys.len() > 2);
 * let tail = private_keys.split_off(1);
 * let head = private_keys.into_iter().last().unwrap();
 *
 * tail.into_iter().fold(head.public_key(), |acc_pub, x_priv| {
 * let shared_secret = x_priv.diffie_hellman(&acc_pub);
 * X25519PublicKey::from_bytes(shared_secret.to_bytes())
 * })
 * }
 * ```
 *
 * We form 15 Symmetric Encryption keys from the 15 `X25519PublicKey` by simply
 * mapping the data of the public keys into AesGCM keys:
 *
 * ```ignore
 * let sec_keys: Vec<Key<AesGcm>> = ecdh_keys.iter().map(ec2sec).collect()
 * assert_eq!(sec_keys.len(), 15);
 * ```
 *
 * We encrypt the mnemonic 15 times, using each symmetric key in `sec_keys`:
 *
 * ```ignore
 * let encryptions: Vec<AesGcmSealedBox> = sec_keys.iter().map(|x| x.enc)
 * assert_eq!(encryptions.len(), 15);
 * ```
 *
 * Decryption is then the reverse process, trying to decrypt any of the 15
 * encrypted mnemonics with any of the 15 symmetric (de)encryption keys we
 * re-calculate from the answers user gives at this later point in time.
 *
 * Author / Inventor: Alexander Cyon (alex.cyon@gmail.com) in the year 2022.
 *
 *  NOT PRODUCTION READY YET 
 *
 * [choose]: https://en.wikipedia.org/wiki/Combination
 * [itertools]: https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.combinations

 */
public struct SecurityQuestionsNotProductionReadyFactorSource {
	/**
	 * Unique and stable identifier of this factor source, stemming from the
	 * hash of a special child key of the HD root of the mnemonic.
	 */
	public var id: FactorSourceIdFromHash
	/**
	 * Common properties shared between FactorSources of different kinds,
	 * describing its state, when added, and supported cryptographic parameters.
	 */
	public var common: FactorSourceCommon
	/**
	 * The sealed mnemonic containing multiple different encryptions of a
	 * mnemonic encrypted by different encryptions keys, being various combinations
	 * of questions and answers derived keys, allowing for only 4 out of 6 answers
	 * to be correct.
	 */
	public var sealedMnemonic: SecurityQuestionsSealedNotProductionReadyMnemonic

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Unique and stable identifier of this factor source, stemming from the
		 * hash of a special child key of the HD root of the mnemonic.
		 */ id: FactorSourceIdFromHash,
		/**
			* Common properties shared between FactorSources of different kinds,
			* describing its state, when added, and supported cryptographic parameters.
			*/ common: FactorSourceCommon,
		/**
			* The sealed mnemonic containing multiple different encryptions of a
			* mnemonic encrypted by different encryptions keys, being various combinations
			* of questions and answers derived keys, allowing for only 4 out of 6 answers
			* to be correct.
			*/ sealedMnemonic: SecurityQuestionsSealedNotProductionReadyMnemonic
	) {
		self.id = id
		self.common = common
		self.sealedMnemonic = sealedMnemonic
	}
}

// MARK: Sendable
extension SecurityQuestionsNotProductionReadyFactorSource: Sendable {}

// MARK: Equatable, Hashable
extension SecurityQuestionsNotProductionReadyFactorSource: Equatable, Hashable {
	public static func == (lhs: SecurityQuestionsNotProductionReadyFactorSource, rhs: SecurityQuestionsNotProductionReadyFactorSource) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.common != rhs.common {
			return false
		}
		if lhs.sealedMnemonic != rhs.sealedMnemonic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(common)
		hasher.combine(sealedMnemonic)
	}
}

// MARK: - FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource
public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyFactorSource {
		try SecurityQuestionsNotProductionReadyFactorSource(
			id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
			common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
			sealedMnemonic: FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic.read(from: &buf)
		)
	}

	public static func write(_ value: SecurityQuestionsNotProductionReadyFactorSource, into buf: inout [UInt8]) {
		FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
		FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
		FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic.write(value.sealedMnemonic, into: &buf)
	}
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyFactorSource {
	try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource_lower(_ value: SecurityQuestionsNotProductionReadyFactorSource) -> RustBuffer {
	FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lower(value)
}

// MARK: - SecurityQuestionsNotProductionReadyKdfSchemeVersion1
/**
 *  NOT PRODUCTION READY YET 
 * Version1 of SecurityQuestions KDF, derives encryption keys from security
 * questions and answers, using two "sub-KDFs".
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityQuestionsNotProductionReadyKdfSchemeVersion1 {
	public var kdfKeyExchangesKeysFromQuestionsAndAnswers: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8
	public var kdfEncryptionKeysFromKeyExchangeKeys: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(kdfKeyExchangesKeysFromQuestionsAndAnswers: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8, kdfEncryptionKeysFromKeyExchangeKeys: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold) {
		self.kdfKeyExchangesKeysFromQuestionsAndAnswers = kdfKeyExchangesKeysFromQuestionsAndAnswers
		self.kdfEncryptionKeysFromKeyExchangeKeys = kdfEncryptionKeysFromKeyExchangeKeys
	}
}

// MARK: Sendable
extension SecurityQuestionsNotProductionReadyKdfSchemeVersion1: Sendable {}

// MARK: Equatable, Hashable
extension SecurityQuestionsNotProductionReadyKdfSchemeVersion1: Equatable, Hashable {
	public static func == (lhs: SecurityQuestionsNotProductionReadyKdfSchemeVersion1, rhs: SecurityQuestionsNotProductionReadyKdfSchemeVersion1) -> Bool {
		if lhs.kdfKeyExchangesKeysFromQuestionsAndAnswers != rhs.kdfKeyExchangesKeysFromQuestionsAndAnswers {
			return false
		}
		if lhs.kdfEncryptionKeysFromKeyExchangeKeys != rhs.kdfEncryptionKeysFromKeyExchangeKeys {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(kdfKeyExchangesKeysFromQuestionsAndAnswers)
		hasher.combine(kdfEncryptionKeysFromKeyExchangeKeys)
	}
}

// MARK: - FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1
public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyKdfSchemeVersion1 {
		try SecurityQuestionsNotProductionReadyKdfSchemeVersion1(
			kdfKeyExchangesKeysFromQuestionsAndAnswers: FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.read(from: &buf),
			kdfEncryptionKeysFromKeyExchangeKeys: FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.read(from: &buf)
		)
	}

	public static func write(_ value: SecurityQuestionsNotProductionReadyKdfSchemeVersion1, into buf: inout [UInt8]) {
		FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.write(value.kdfKeyExchangesKeysFromQuestionsAndAnswers, into: &buf)
		FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.write(value.kdfEncryptionKeysFromKeyExchangeKeys, into: &buf)
	}
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyKdfSchemeVersion1 {
	try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1_lower(_ value: SecurityQuestionsNotProductionReadyKdfSchemeVersion1) -> RustBuffer {
	FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1.lower(value)
}

// MARK: - SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8
/**
 *  NOT PRODUCTION READY YET 
 * A Key Derivation Scheme which lowercases, trims and ut8f encodes answers.
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8 {
	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init() {}
}

// MARK: Sendable
extension SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8: Sendable {}

// MARK: Equatable, Hashable
extension SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8: Equatable, Hashable {
	public static func == (lhs: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8, rhs: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8) -> Bool {
		true
	}

	public func hash(into hasher: inout Hasher) {}
}

// MARK: - FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8
public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8 {
		SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8()
	}

	public static func write(_ value: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8, into buf: inout [UInt8]) {}
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8 {
	try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8_lower(_ value: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8) -> RustBuffer {
	FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.lower(value)
}

// MARK: - SecurityStructureMetadata
public struct SecurityStructureMetadata {
	public var id: SecurityStructureId
	public var displayName: DisplayName
	public var createdOn: Timestamp
	public var lastUpdatedOn: Timestamp

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(id: SecurityStructureId, displayName: DisplayName, createdOn: Timestamp, lastUpdatedOn: Timestamp) {
		self.id = id
		self.displayName = displayName
		self.createdOn = createdOn
		self.lastUpdatedOn = lastUpdatedOn
	}
}

// MARK: Sendable
extension SecurityStructureMetadata: Sendable {}

// MARK: Equatable, Hashable
extension SecurityStructureMetadata: Equatable, Hashable {
	public static func == (lhs: SecurityStructureMetadata, rhs: SecurityStructureMetadata) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.displayName != rhs.displayName {
			return false
		}
		if lhs.createdOn != rhs.createdOn {
			return false
		}
		if lhs.lastUpdatedOn != rhs.lastUpdatedOn {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(displayName)
		hasher.combine(createdOn)
		hasher.combine(lastUpdatedOn)
	}
}

// MARK: - FfiConverterTypeSecurityStructureMetadata
public struct FfiConverterTypeSecurityStructureMetadata: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureMetadata {
		try SecurityStructureMetadata(
			id: FfiConverterTypeSecurityStructureID.read(from: &buf),
			displayName: FfiConverterTypeDisplayName.read(from: &buf),
			createdOn: FfiConverterTypeTimestamp.read(from: &buf),
			lastUpdatedOn: FfiConverterTypeTimestamp.read(from: &buf)
		)
	}

	public static func write(_ value: SecurityStructureMetadata, into buf: inout [UInt8]) {
		FfiConverterTypeSecurityStructureID.write(value.id, into: &buf)
		FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
		FfiConverterTypeTimestamp.write(value.createdOn, into: &buf)
		FfiConverterTypeTimestamp.write(value.lastUpdatedOn, into: &buf)
	}
}

public func FfiConverterTypeSecurityStructureMetadata_lift(_ buf: RustBuffer) throws -> SecurityStructureMetadata {
	try FfiConverterTypeSecurityStructureMetadata.lift(buf)
}

public func FfiConverterTypeSecurityStructureMetadata_lower(_ value: SecurityStructureMetadata) -> RustBuffer {
	FfiConverterTypeSecurityStructureMetadata.lower(value)
}

// MARK: - SecurityStructureOfFactorInstances
public struct SecurityStructureOfFactorInstances {
	/**
	 * The ID of the `SecurityStructureOfFactorSourceIDs` in
	 * `profile.app_preferences.security.security_structures_of_factor_source_ids`
	 * which was used to derive the factor instances in this structure. Or rather:
	 * The id of `SecurityStructureOfFactorSources`.
	 */
	public var securityStructureId: SecurityStructureId
	/**
	 * The structure of factors to use for certain roles, Primary, Recovery
	 * and Confirmation role.
	 */
	public var matrixOfFactors: MatrixOfFactorInstances

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The ID of the `SecurityStructureOfFactorSourceIDs` in
		 * `profile.app_preferences.security.security_structures_of_factor_source_ids`
		 * which was used to derive the factor instances in this structure. Or rather:
		 * The id of `SecurityStructureOfFactorSources`.
		 */ securityStructureId: SecurityStructureId,
		/**
			* The structure of factors to use for certain roles, Primary, Recovery
			* and Confirmation role.
			*/ matrixOfFactors: MatrixOfFactorInstances
	) {
		self.securityStructureId = securityStructureId
		self.matrixOfFactors = matrixOfFactors
	}
}

// MARK: Sendable
extension SecurityStructureOfFactorInstances: Sendable {}

// MARK: Equatable, Hashable
extension SecurityStructureOfFactorInstances: Equatable, Hashable {
	public static func == (lhs: SecurityStructureOfFactorInstances, rhs: SecurityStructureOfFactorInstances) -> Bool {
		if lhs.securityStructureId != rhs.securityStructureId {
			return false
		}
		if lhs.matrixOfFactors != rhs.matrixOfFactors {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(securityStructureId)
		hasher.combine(matrixOfFactors)
	}
}

// MARK: - FfiConverterTypeSecurityStructureOfFactorInstances
public struct FfiConverterTypeSecurityStructureOfFactorInstances: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureOfFactorInstances {
		try SecurityStructureOfFactorInstances(
			securityStructureId: FfiConverterTypeSecurityStructureID.read(from: &buf),
			matrixOfFactors: FfiConverterTypeMatrixOfFactorInstances.read(from: &buf)
		)
	}

	public static func write(_ value: SecurityStructureOfFactorInstances, into buf: inout [UInt8]) {
		FfiConverterTypeSecurityStructureID.write(value.securityStructureId, into: &buf)
		FfiConverterTypeMatrixOfFactorInstances.write(value.matrixOfFactors, into: &buf)
	}
}

public func FfiConverterTypeSecurityStructureOfFactorInstances_lift(_ buf: RustBuffer) throws -> SecurityStructureOfFactorInstances {
	try FfiConverterTypeSecurityStructureOfFactorInstances.lift(buf)
}

public func FfiConverterTypeSecurityStructureOfFactorInstances_lower(_ value: SecurityStructureOfFactorInstances) -> RustBuffer {
	FfiConverterTypeSecurityStructureOfFactorInstances.lower(value)
}

// MARK: - SecurityStructureOfFactorSourceIDs
/**
 * A security structure at FactorSourceID level, this is
 * what is serialized and store into Profile, we convert
 * into this structure from `SecurityStructureOfFactorSources`.
 */
public struct SecurityStructureOfFactorSourceIDs {
	/**
	 * Metadata of this Security Structure, such as globally unique and
	 * stable identifier, creation date and user chosen label (name).
	 */
	public var metadata: SecurityStructureMetadata
	/**
	 * The amount of time until Confirmation Role is automatically
	 * exercised, inputted by user in Days in UI, but translate it into
	 * epochs ("block time").
	 */
	public var numberOfEpochsUntilAutoConfirmation: UInt64
	/**
	 * The structure of factors to use for certain roles, Primary, Recovery
	 * and Confirmation role.
	 */
	public var matrixOfFactors: MatrixOfFactorSourceIDs

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Metadata of this Security Structure, such as globally unique and
		 * stable identifier, creation date and user chosen label (name).
		 */ metadata: SecurityStructureMetadata,
		/**
			* The amount of time until Confirmation Role is automatically
			* exercised, inputted by user in Days in UI, but translate it into
			* epochs ("block time").
			*/ numberOfEpochsUntilAutoConfirmation: UInt64,
		/**
			* The structure of factors to use for certain roles, Primary, Recovery
			* and Confirmation role.
			*/ matrixOfFactors: MatrixOfFactorSourceIDs
	) {
		self.metadata = metadata
		self.numberOfEpochsUntilAutoConfirmation = numberOfEpochsUntilAutoConfirmation
		self.matrixOfFactors = matrixOfFactors
	}
}

// MARK: Sendable
extension SecurityStructureOfFactorSourceIDs: Sendable {}

// MARK: Equatable, Hashable
extension SecurityStructureOfFactorSourceIDs: Equatable, Hashable {
	public static func == (lhs: SecurityStructureOfFactorSourceIDs, rhs: SecurityStructureOfFactorSourceIDs) -> Bool {
		if lhs.metadata != rhs.metadata {
			return false
		}
		if lhs.numberOfEpochsUntilAutoConfirmation != rhs.numberOfEpochsUntilAutoConfirmation {
			return false
		}
		if lhs.matrixOfFactors != rhs.matrixOfFactors {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(metadata)
		hasher.combine(numberOfEpochsUntilAutoConfirmation)
		hasher.combine(matrixOfFactors)
	}
}

// MARK: - FfiConverterTypeSecurityStructureOfFactorSourceIDs
public struct FfiConverterTypeSecurityStructureOfFactorSourceIDs: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureOfFactorSourceIDs {
		try SecurityStructureOfFactorSourceIDs(
			metadata: FfiConverterTypeSecurityStructureMetadata.read(from: &buf),
			numberOfEpochsUntilAutoConfirmation: FfiConverterUInt64.read(from: &buf),
			matrixOfFactors: FfiConverterTypeMatrixOfFactorSourceIDs.read(from: &buf)
		)
	}

	public static func write(_ value: SecurityStructureOfFactorSourceIDs, into buf: inout [UInt8]) {
		FfiConverterTypeSecurityStructureMetadata.write(value.metadata, into: &buf)
		FfiConverterUInt64.write(value.numberOfEpochsUntilAutoConfirmation, into: &buf)
		FfiConverterTypeMatrixOfFactorSourceIDs.write(value.matrixOfFactors, into: &buf)
	}
}

public func FfiConverterTypeSecurityStructureOfFactorSourceIDs_lift(_ buf: RustBuffer) throws -> SecurityStructureOfFactorSourceIDs {
	try FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(buf)
}

public func FfiConverterTypeSecurityStructureOfFactorSourceIDs_lower(_ value: SecurityStructureOfFactorSourceIDs) -> RustBuffer {
	FfiConverterTypeSecurityStructureOfFactorSourceIDs.lower(value)
}

// MARK: - SecurityStructureOfFactorSources
/**
 * Security structure at `FactorSource` level.
 * This is what user view, creates and manages.
 *
 * Before it gets saved into Profile gets converted into
 * `SecurityStructureOfFactorSourceIDs`
 */
public struct SecurityStructureOfFactorSources {
	/**
	 * Metadata of this Security Structure, such as globally unique and
	 * stable identifier, creation date and user chosen label (name).
	 */
	public var metadata: SecurityStructureMetadata
	/**
	 * The amount of time until Confirmation Role is automatically
	 * exercised, inputted by user in Days in UI, but translate it into
	 * epochs ("block time").
	 */
	public var numberOfEpochsUntilAutoConfirmation: UInt64
	/**
	 * The structure of factors to use for certain roles, Primary, Recovery
	 * and Confirmation role.
	 */
	public var matrixOfFactors: MatrixOfFactorSources

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Metadata of this Security Structure, such as globally unique and
		 * stable identifier, creation date and user chosen label (name).
		 */ metadata: SecurityStructureMetadata,
		/**
			* The amount of time until Confirmation Role is automatically
			* exercised, inputted by user in Days in UI, but translate it into
			* epochs ("block time").
			*/ numberOfEpochsUntilAutoConfirmation: UInt64,
		/**
			* The structure of factors to use for certain roles, Primary, Recovery
			* and Confirmation role.
			*/ matrixOfFactors: MatrixOfFactorSources
	) {
		self.metadata = metadata
		self.numberOfEpochsUntilAutoConfirmation = numberOfEpochsUntilAutoConfirmation
		self.matrixOfFactors = matrixOfFactors
	}
}

// MARK: Sendable
extension SecurityStructureOfFactorSources: Sendable {}

// MARK: Equatable, Hashable
extension SecurityStructureOfFactorSources: Equatable, Hashable {
	public static func == (lhs: SecurityStructureOfFactorSources, rhs: SecurityStructureOfFactorSources) -> Bool {
		if lhs.metadata != rhs.metadata {
			return false
		}
		if lhs.numberOfEpochsUntilAutoConfirmation != rhs.numberOfEpochsUntilAutoConfirmation {
			return false
		}
		if lhs.matrixOfFactors != rhs.matrixOfFactors {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(metadata)
		hasher.combine(numberOfEpochsUntilAutoConfirmation)
		hasher.combine(matrixOfFactors)
	}
}

// MARK: - FfiConverterTypeSecurityStructureOfFactorSources
public struct FfiConverterTypeSecurityStructureOfFactorSources: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureOfFactorSources {
		try SecurityStructureOfFactorSources(
			metadata: FfiConverterTypeSecurityStructureMetadata.read(from: &buf),
			numberOfEpochsUntilAutoConfirmation: FfiConverterUInt64.read(from: &buf),
			matrixOfFactors: FfiConverterTypeMatrixOfFactorSources.read(from: &buf)
		)
	}

	public static func write(_ value: SecurityStructureOfFactorSources, into buf: inout [UInt8]) {
		FfiConverterTypeSecurityStructureMetadata.write(value.metadata, into: &buf)
		FfiConverterUInt64.write(value.numberOfEpochsUntilAutoConfirmation, into: &buf)
		FfiConverterTypeMatrixOfFactorSources.write(value.matrixOfFactors, into: &buf)
	}
}

public func FfiConverterTypeSecurityStructureOfFactorSources_lift(_ buf: RustBuffer) throws -> SecurityStructureOfFactorSources {
	try FfiConverterTypeSecurityStructureOfFactorSources.lift(buf)
}

public func FfiConverterTypeSecurityStructureOfFactorSources_lower(_ value: SecurityStructureOfFactorSources) -> RustBuffer {
	FfiConverterTypeSecurityStructureOfFactorSources.lower(value)
}

// MARK: - SecurityNotProductionReadyQuestion
/**
 *  NOT PRODUCTION READY YET 
 * A security question
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityNotProductionReadyQuestion {
	public var id: UInt16
	public var version: UInt8
	public var kind: SecurityQuestionKind
	public var question: String
	public var expectedAnswerFormat: SecurityQuestionNotProductionReadyExpectedAnswerFormat

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(id: UInt16, version: UInt8, kind: SecurityQuestionKind, question: String, expectedAnswerFormat: SecurityQuestionNotProductionReadyExpectedAnswerFormat) {
		self.id = id
		self.version = version
		self.kind = kind
		self.question = question
		self.expectedAnswerFormat = expectedAnswerFormat
	}
}

// MARK: Sendable
extension SecurityNotProductionReadyQuestion: Sendable {}

// MARK: Equatable, Hashable
extension SecurityNotProductionReadyQuestion: Equatable, Hashable {
	public static func == (lhs: SecurityNotProductionReadyQuestion, rhs: SecurityNotProductionReadyQuestion) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.version != rhs.version {
			return false
		}
		if lhs.kind != rhs.kind {
			return false
		}
		if lhs.question != rhs.question {
			return false
		}
		if lhs.expectedAnswerFormat != rhs.expectedAnswerFormat {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(version)
		hasher.combine(kind)
		hasher.combine(question)
		hasher.combine(expectedAnswerFormat)
	}
}

// MARK: - FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question
public struct FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityNotProductionReadyQuestion {
		try SecurityNotProductionReadyQuestion(
			id: FfiConverterUInt16.read(from: &buf),
			version: FfiConverterUInt8.read(from: &buf),
			kind: FfiConverterTypeSecurityQuestionKind.read(from: &buf),
			question: FfiConverterString.read(from: &buf),
			expectedAnswerFormat: FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat.read(from: &buf)
		)
	}

	public static func write(_ value: SecurityNotProductionReadyQuestion, into buf: inout [UInt8]) {
		FfiConverterUInt16.write(value.id, into: &buf)
		FfiConverterUInt8.write(value.version, into: &buf)
		FfiConverterTypeSecurityQuestionKind.write(value.kind, into: &buf)
		FfiConverterString.write(value.question, into: &buf)
		FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat.write(value.expectedAnswerFormat, into: &buf)
	}
}

public func FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question_lift(_ buf: RustBuffer) throws -> SecurityNotProductionReadyQuestion {
	try FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.lift(buf)
}

public func FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question_lower(_ value: SecurityNotProductionReadyQuestion) -> RustBuffer {
	FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.lower(value)
}

// MARK: - SecurityNotProductionReadyQuestionAndAnswer
/**
 *  NOT PRODUCTION READY YET 
 * A pair of security question and answer
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityNotProductionReadyQuestionAndAnswer {
	public var question: SecurityNotProductionReadyQuestion
	public var answer: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(question: SecurityNotProductionReadyQuestion, answer: String) {
		self.question = question
		self.answer = answer
	}
}

// MARK: Sendable
extension SecurityNotProductionReadyQuestionAndAnswer: Sendable {}

// MARK: Equatable, Hashable
extension SecurityNotProductionReadyQuestionAndAnswer: Equatable, Hashable {
	public static func == (lhs: SecurityNotProductionReadyQuestionAndAnswer, rhs: SecurityNotProductionReadyQuestionAndAnswer) -> Bool {
		if lhs.question != rhs.question {
			return false
		}
		if lhs.answer != rhs.answer {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(question)
		hasher.combine(answer)
	}
}

// MARK: - FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer
public struct FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityNotProductionReadyQuestionAndAnswer {
		try SecurityNotProductionReadyQuestionAndAnswer(
			question: FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.read(from: &buf),
			answer: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: SecurityNotProductionReadyQuestionAndAnswer, into buf: inout [UInt8]) {
		FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.write(value.question, into: &buf)
		FfiConverterString.write(value.answer, into: &buf)
	}
}

public func FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer_lift(_ buf: RustBuffer) throws -> SecurityNotProductionReadyQuestionAndAnswer {
	try FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lift(buf)
}

public func FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer_lower(_ value: SecurityNotProductionReadyQuestionAndAnswer) -> RustBuffer {
	FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lower(value)
}

// MARK: - SharedPersonaData
/**
 * Identities for PersonaData entry values a user have shared with a dApp.
 */
public struct SharedPersonaData {
	/**
	 * ID of a `PersonaDataEntryName` the user has shared with some dApp on some network,
	 * can be `None`.
	 */
	public var name: PersonaDataEntryId?
	/**
	 * IDs of a `PersonaDataEntryEmailAddress`es the user has shared with some dApp on some network
	 * can be `None`, or can be `Some(<EMPTY>)`.
	 */
	public var emailAddresses: SharedToDappWithPersonaIDsOfPersonaDataEntries?
	/**
	 * IDs of a `PersonaDataEntryPhoneNumber`s the user has shared with some dApp on some network
	 * can be `None`, or can be `Some(<EMPTY>)`.
	 */
	public var phoneNumbers: SharedToDappWithPersonaIDsOfPersonaDataEntries?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * ID of a `PersonaDataEntryName` the user has shared with some dApp on some network,
		 * can be `None`.
		 */ name: PersonaDataEntryId?,
		/**
			* IDs of a `PersonaDataEntryEmailAddress`es the user has shared with some dApp on some network
			* can be `None`, or can be `Some(<EMPTY>)`.
			*/ emailAddresses: SharedToDappWithPersonaIDsOfPersonaDataEntries?,
		/**
			* IDs of a `PersonaDataEntryPhoneNumber`s the user has shared with some dApp on some network
			* can be `None`, or can be `Some(<EMPTY>)`.
			*/ phoneNumbers: SharedToDappWithPersonaIDsOfPersonaDataEntries?
	) {
		self.name = name
		self.emailAddresses = emailAddresses
		self.phoneNumbers = phoneNumbers
	}
}

// MARK: Sendable
extension SharedPersonaData: Sendable {}

// MARK: Equatable, Hashable
extension SharedPersonaData: Equatable, Hashable {
	public static func == (lhs: SharedPersonaData, rhs: SharedPersonaData) -> Bool {
		if lhs.name != rhs.name {
			return false
		}
		if lhs.emailAddresses != rhs.emailAddresses {
			return false
		}
		if lhs.phoneNumbers != rhs.phoneNumbers {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(name)
		hasher.combine(emailAddresses)
		hasher.combine(phoneNumbers)
	}
}

// MARK: - FfiConverterTypeSharedPersonaData
public struct FfiConverterTypeSharedPersonaData: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedPersonaData {
		try SharedPersonaData(
			name: FfiConverterOptionTypePersonaDataEntryID.read(from: &buf),
			emailAddresses: FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf),
			phoneNumbers: FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf)
		)
	}

	public static func write(_ value: SharedPersonaData, into buf: inout [UInt8]) {
		FfiConverterOptionTypePersonaDataEntryID.write(value.name, into: &buf)
		FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value.emailAddresses, into: &buf)
		FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value.phoneNumbers, into: &buf)
	}
}

public func FfiConverterTypeSharedPersonaData_lift(_ buf: RustBuffer) throws -> SharedPersonaData {
	try FfiConverterTypeSharedPersonaData.lift(buf)
}

public func FfiConverterTypeSharedPersonaData_lower(_ value: SharedPersonaData) -> RustBuffer {
	FfiConverterTypeSharedPersonaData.lower(value)
}

// MARK: - SharedToDappWithPersonaAccountAddresses
/**
 * IDs that have been shared with an Dapp the user has interacted with
 * that fulfill a Dapp request's specified [`RequestedQuantity`].
 */
public struct SharedToDappWithPersonaAccountAddresses {
	/**
	 * The requested quantity to be shared by user, sent by a Dapp.
	 */
	public var request: RequestedQuantity
	/**
	 * The by user shared IDs of data identifiable data shared with the
	 * Dapp.
	 */
	public var ids: [AccountAddress]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The requested quantity to be shared by user, sent by a Dapp.
		 */ request: RequestedQuantity,
		/**
			* The by user shared IDs of data identifiable data shared with the
			* Dapp.
			*/ ids: [AccountAddress]
	) {
		self.request = request
		self.ids = ids
	}
}

// MARK: Sendable
extension SharedToDappWithPersonaAccountAddresses: Sendable {}

// MARK: Equatable, Hashable
extension SharedToDappWithPersonaAccountAddresses: Equatable, Hashable {
	public static func == (lhs: SharedToDappWithPersonaAccountAddresses, rhs: SharedToDappWithPersonaAccountAddresses) -> Bool {
		if lhs.request != rhs.request {
			return false
		}
		if lhs.ids != rhs.ids {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(request)
		hasher.combine(ids)
	}
}

// MARK: - FfiConverterTypeSharedToDappWithPersonaAccountAddresses
public struct FfiConverterTypeSharedToDappWithPersonaAccountAddresses: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedToDappWithPersonaAccountAddresses {
		try SharedToDappWithPersonaAccountAddresses(
			request: FfiConverterTypeRequestedQuantity.read(from: &buf),
			ids: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
		)
	}

	public static func write(_ value: SharedToDappWithPersonaAccountAddresses, into buf: inout [UInt8]) {
		FfiConverterTypeRequestedQuantity.write(value.request, into: &buf)
		FfiConverterSequenceTypeAccountAddress.write(value.ids, into: &buf)
	}
}

public func FfiConverterTypeSharedToDappWithPersonaAccountAddresses_lift(_ buf: RustBuffer) throws -> SharedToDappWithPersonaAccountAddresses {
	try FfiConverterTypeSharedToDappWithPersonaAccountAddresses.lift(buf)
}

public func FfiConverterTypeSharedToDappWithPersonaAccountAddresses_lower(_ value: SharedToDappWithPersonaAccountAddresses) -> RustBuffer {
	FfiConverterTypeSharedToDappWithPersonaAccountAddresses.lower(value)
}

// MARK: - SharedToDappWithPersonaIDsOfPersonaDataEntries
/**
 * IDs that have been shared with an Dapp the user has interacted with
 * that fulfill a Dapp request's specified [`RequestedQuantity`].
 */
public struct SharedToDappWithPersonaIDsOfPersonaDataEntries {
	/**
	 * The requested quantity to be shared by user, sent by a Dapp.
	 */
	public var request: RequestedQuantity
	/**
	 * The by user shared IDs of data identifiable data shared with the
	 * Dapp.
	 */
	public var ids: [PersonaDataEntryId]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The requested quantity to be shared by user, sent by a Dapp.
		 */ request: RequestedQuantity,
		/**
			* The by user shared IDs of data identifiable data shared with the
			* Dapp.
			*/ ids: [PersonaDataEntryId]
	) {
		self.request = request
		self.ids = ids
	}
}

// MARK: Sendable
extension SharedToDappWithPersonaIDsOfPersonaDataEntries: Sendable {}

// MARK: Equatable, Hashable
extension SharedToDappWithPersonaIDsOfPersonaDataEntries: Equatable, Hashable {
	public static func == (lhs: SharedToDappWithPersonaIDsOfPersonaDataEntries, rhs: SharedToDappWithPersonaIDsOfPersonaDataEntries) -> Bool {
		if lhs.request != rhs.request {
			return false
		}
		if lhs.ids != rhs.ids {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(request)
		hasher.combine(ids)
	}
}

// MARK: - FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries
public struct FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedToDappWithPersonaIDsOfPersonaDataEntries {
		try SharedToDappWithPersonaIDsOfPersonaDataEntries(
			request: FfiConverterTypeRequestedQuantity.read(from: &buf),
			ids: FfiConverterSequenceTypePersonaDataEntryID.read(from: &buf)
		)
	}

	public static func write(_ value: SharedToDappWithPersonaIDsOfPersonaDataEntries, into buf: inout [UInt8]) {
		FfiConverterTypeRequestedQuantity.write(value.request, into: &buf)
		FfiConverterSequenceTypePersonaDataEntryID.write(value.ids, into: &buf)
	}
}

public func FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries_lift(_ buf: RustBuffer) throws -> SharedToDappWithPersonaIDsOfPersonaDataEntries {
	try FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.lift(buf)
}

public func FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries_lower(_ value: SharedToDappWithPersonaIDsOfPersonaDataEntries) -> RustBuffer {
	FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.lower(value)
}

// MARK: - SignedIntent
public struct SignedIntent {
	public var intent: TransactionIntent
	public var intentSignatures: IntentSignatures

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(intent: TransactionIntent, intentSignatures: IntentSignatures) {
		self.intent = intent
		self.intentSignatures = intentSignatures
	}
}

// MARK: Sendable
extension SignedIntent: Sendable {}

// MARK: Equatable, Hashable
extension SignedIntent: Equatable, Hashable {
	public static func == (lhs: SignedIntent, rhs: SignedIntent) -> Bool {
		if lhs.intent != rhs.intent {
			return false
		}
		if lhs.intentSignatures != rhs.intentSignatures {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(intent)
		hasher.combine(intentSignatures)
	}
}

// MARK: - FfiConverterTypeSignedIntent
public struct FfiConverterTypeSignedIntent: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedIntent {
		try SignedIntent(
			intent: FfiConverterTypeTransactionIntent.read(from: &buf),
			intentSignatures: FfiConverterTypeIntentSignatures.read(from: &buf)
		)
	}

	public static func write(_ value: SignedIntent, into buf: inout [UInt8]) {
		FfiConverterTypeTransactionIntent.write(value.intent, into: &buf)
		FfiConverterTypeIntentSignatures.write(value.intentSignatures, into: &buf)
	}
}

public func FfiConverterTypeSignedIntent_lift(_ buf: RustBuffer) throws -> SignedIntent {
	try FfiConverterTypeSignedIntent.lift(buf)
}

public func FfiConverterTypeSignedIntent_lower(_ value: SignedIntent) -> RustBuffer {
	FfiConverterTypeSignedIntent.lower(value)
}

// MARK: - SignedSubintent
public struct SignedSubintent {
	public var subintent: Subintent
	public var subintentSignatures: IntentSignatures

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(subintent: Subintent, subintentSignatures: IntentSignatures) {
		self.subintent = subintent
		self.subintentSignatures = subintentSignatures
	}
}

// MARK: Sendable
extension SignedSubintent: Sendable {}

// MARK: Equatable, Hashable
extension SignedSubintent: Equatable, Hashable {
	public static func == (lhs: SignedSubintent, rhs: SignedSubintent) -> Bool {
		if lhs.subintent != rhs.subintent {
			return false
		}
		if lhs.subintentSignatures != rhs.subintentSignatures {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(subintent)
		hasher.combine(subintentSignatures)
	}
}

// MARK: - FfiConverterTypeSignedSubintent
public struct FfiConverterTypeSignedSubintent: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedSubintent {
		try SignedSubintent(
			subintent: FfiConverterTypeSubintent.read(from: &buf),
			subintentSignatures: FfiConverterTypeIntentSignatures.read(from: &buf)
		)
	}

	public static func write(_ value: SignedSubintent, into buf: inout [UInt8]) {
		FfiConverterTypeSubintent.write(value.subintent, into: &buf)
		FfiConverterTypeIntentSignatures.write(value.subintentSignatures, into: &buf)
	}
}

public func FfiConverterTypeSignedSubintent_lift(_ buf: RustBuffer) throws -> SignedSubintent {
	try FfiConverterTypeSignedSubintent.lift(buf)
}

public func FfiConverterTypeSignedSubintent_lower(_ value: SignedSubintent) -> RustBuffer {
	FfiConverterTypeSignedSubintent.lower(value)
}

// MARK: - SignedTransactionIntentHash
/**
 * A Signed Intent Hash is a bech32 encoded string starting with `"signedintent_"
 */
public struct SignedTransactionIntentHash {
	/**
	 * Which network this transaction hash is used on
	 */
	public var networkId: NetworkId
	/**
	 * the hash of the intent
	 */
	public var hash: Hash
	/**
	 * Bech32 encoded TX id
	 */
	public var bech32EncodedTxId: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Which network this transaction hash is used on
		 */ networkId: NetworkId,
		/**
			* the hash of the intent
			*/ hash: Hash,
		/**
			* Bech32 encoded TX id
			*/ bech32EncodedTxId: String
	) {
		self.networkId = networkId
		self.hash = hash
		self.bech32EncodedTxId = bech32EncodedTxId
	}
}

// MARK: Sendable
extension SignedTransactionIntentHash: Sendable {}

// MARK: Equatable, Hashable
extension SignedTransactionIntentHash: Equatable, Hashable {
	public static func == (lhs: SignedTransactionIntentHash, rhs: SignedTransactionIntentHash) -> Bool {
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.hash != rhs.hash {
			return false
		}
		if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(networkId)
		hasher.combine(hash)
		hasher.combine(bech32EncodedTxId)
	}
}

// MARK: - FfiConverterTypeSignedTransactionIntentHash
public struct FfiConverterTypeSignedTransactionIntentHash: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedTransactionIntentHash {
		try SignedTransactionIntentHash(
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			hash: FfiConverterTypeHash.read(from: &buf),
			bech32EncodedTxId: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: SignedTransactionIntentHash, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeHash.write(value.hash, into: &buf)
		FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
	}
}

public func FfiConverterTypeSignedTransactionIntentHash_lift(_ buf: RustBuffer) throws -> SignedTransactionIntentHash {
	try FfiConverterTypeSignedTransactionIntentHash.lift(buf)
}

public func FfiConverterTypeSignedTransactionIntentHash_lower(_ value: SignedTransactionIntentHash) -> RustBuffer {
	FfiConverterTypeSignedTransactionIntentHash.lower(value)
}

// MARK: - SimpleNonFungibleResourceBounds
/**
 * Represents the bounds for a simple non_fungible resource, which can be either exact or not exact.
 */
public struct SimpleNonFungibleResourceBounds {
	public var certainIds: [NonFungibleLocalId]
	public var additionalAmount: SimpleCountedResourceBounds?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(certainIds: [NonFungibleLocalId], additionalAmount: SimpleCountedResourceBounds?) {
		self.certainIds = certainIds
		self.additionalAmount = additionalAmount
	}
}

// MARK: Sendable
extension SimpleNonFungibleResourceBounds: Sendable {}

// MARK: Equatable, Hashable
extension SimpleNonFungibleResourceBounds: Equatable, Hashable {
	public static func == (lhs: SimpleNonFungibleResourceBounds, rhs: SimpleNonFungibleResourceBounds) -> Bool {
		if lhs.certainIds != rhs.certainIds {
			return false
		}
		if lhs.additionalAmount != rhs.additionalAmount {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(certainIds)
		hasher.combine(additionalAmount)
	}
}

// MARK: - FfiConverterTypeSimpleNonFungibleResourceBounds
public struct FfiConverterTypeSimpleNonFungibleResourceBounds: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleNonFungibleResourceBounds {
		try SimpleNonFungibleResourceBounds(
			certainIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
			additionalAmount: FfiConverterOptionTypeSimpleCountedResourceBounds.read(from: &buf)
		)
	}

	public static func write(_ value: SimpleNonFungibleResourceBounds, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeNonFungibleLocalId.write(value.certainIds, into: &buf)
		FfiConverterOptionTypeSimpleCountedResourceBounds.write(value.additionalAmount, into: &buf)
	}
}

public func FfiConverterTypeSimpleNonFungibleResourceBounds_lift(_ buf: RustBuffer) throws -> SimpleNonFungibleResourceBounds {
	try FfiConverterTypeSimpleNonFungibleResourceBounds.lift(buf)
}

public func FfiConverterTypeSimpleNonFungibleResourceBounds_lower(_ value: SimpleNonFungibleResourceBounds) -> RustBuffer {
	FfiConverterTypeSimpleNonFungibleResourceBounds.lower(value)
}

// MARK: - StakeClaim
public struct StakeClaim {
	public var validatorAddress: ValidatorAddress
	public var resourceAddress: NonFungibleResourceAddress
	public var ids: [NonFungibleLocalId]
	/**
	 * The summed claim amount across ids
	 */
	public var amount: Decimal192

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(validatorAddress: ValidatorAddress, resourceAddress: NonFungibleResourceAddress, ids: [NonFungibleLocalId],
	            /**
	            	* The summed claim amount across ids
	            	*/ amount: Decimal192)
	{
		self.validatorAddress = validatorAddress
		self.resourceAddress = resourceAddress
		self.ids = ids
		self.amount = amount
	}
}

// MARK: Sendable
extension StakeClaim: Sendable {}

// MARK: Equatable, Hashable
extension StakeClaim: Equatable, Hashable {
	public static func == (lhs: StakeClaim, rhs: StakeClaim) -> Bool {
		if lhs.validatorAddress != rhs.validatorAddress {
			return false
		}
		if lhs.resourceAddress != rhs.resourceAddress {
			return false
		}
		if lhs.ids != rhs.ids {
			return false
		}
		if lhs.amount != rhs.amount {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(validatorAddress)
		hasher.combine(resourceAddress)
		hasher.combine(ids)
		hasher.combine(amount)
	}
}

// MARK: - FfiConverterTypeStakeClaim
public struct FfiConverterTypeStakeClaim: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StakeClaim {
		try StakeClaim(
			validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf),
			resourceAddress: FfiConverterTypeNonFungibleResourceAddress.read(from: &buf),
			ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
			amount: FfiConverterTypeDecimal192.read(from: &buf)
		)
	}

	public static func write(_ value: StakeClaim, into buf: inout [UInt8]) {
		FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
		FfiConverterTypeNonFungibleResourceAddress.write(value.resourceAddress, into: &buf)
		FfiConverterSequenceTypeNonFungibleLocalId.write(value.ids, into: &buf)
		FfiConverterTypeDecimal192.write(value.amount, into: &buf)
	}
}

public func FfiConverterTypeStakeClaim_lift(_ buf: RustBuffer) throws -> StakeClaim {
	try FfiConverterTypeStakeClaim.lift(buf)
}

public func FfiConverterTypeStakeClaim_lower(_ value: StakeClaim) -> RustBuffer {
	FfiConverterTypeStakeClaim.lower(value)
}

// MARK: - Subintent
public struct Subintent {
	public var header: IntentHeaderV2
	public var manifest: SubintentManifest
	public var message: MessageV2

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(header: IntentHeaderV2, manifest: SubintentManifest, message: MessageV2) {
		self.header = header
		self.manifest = manifest
		self.message = message
	}
}

// MARK: Sendable
extension Subintent: Sendable {}

// MARK: Equatable, Hashable
extension Subintent: Equatable, Hashable {
	public static func == (lhs: Subintent, rhs: Subintent) -> Bool {
		if lhs.header != rhs.header {
			return false
		}
		if lhs.manifest != rhs.manifest {
			return false
		}
		if lhs.message != rhs.message {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(header)
		hasher.combine(manifest)
		hasher.combine(message)
	}
}

// MARK: - FfiConverterTypeSubintent
public struct FfiConverterTypeSubintent: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Subintent {
		try Subintent(
			header: FfiConverterTypeIntentHeaderV2.read(from: &buf),
			manifest: FfiConverterTypeSubintentManifest.read(from: &buf),
			message: FfiConverterTypeMessageV2.read(from: &buf)
		)
	}

	public static func write(_ value: Subintent, into buf: inout [UInt8]) {
		FfiConverterTypeIntentHeaderV2.write(value.header, into: &buf)
		FfiConverterTypeSubintentManifest.write(value.manifest, into: &buf)
		FfiConverterTypeMessageV2.write(value.message, into: &buf)
	}
}

public func FfiConverterTypeSubintent_lift(_ buf: RustBuffer) throws -> Subintent {
	try FfiConverterTypeSubintent.lift(buf)
}

public func FfiConverterTypeSubintent_lower(_ value: Subintent) -> RustBuffer {
	FfiConverterTypeSubintent.lower(value)
}

// MARK: - SubintentHash
/**
 * `IntentHash` used to identify transactions.
 * Representation is bech32 encoded string starting with `txid_` e.g.:
 * `"txid_rdx19rpveua6xuhvz0axu0mwpqk8fywr83atv8mkrugchvw6uuslgppqh9cnj4"`
 */
public struct SubintentHash {
	/**
	 * Which network this transaction hash is used on
	 */
	public var networkId: NetworkId
	/**
	 * the hash of the intent
	 */
	public var hash: Hash
	/**
	 * Bech32 encoded TX id
	 */
	public var bech32EncodedTxId: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Which network this transaction hash is used on
		 */ networkId: NetworkId,
		/**
			* the hash of the intent
			*/ hash: Hash,
		/**
			* Bech32 encoded TX id
			*/ bech32EncodedTxId: String
	) {
		self.networkId = networkId
		self.hash = hash
		self.bech32EncodedTxId = bech32EncodedTxId
	}
}

// MARK: Sendable
extension SubintentHash: Sendable {}

// MARK: Equatable, Hashable
extension SubintentHash: Equatable, Hashable {
	public static func == (lhs: SubintentHash, rhs: SubintentHash) -> Bool {
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.hash != rhs.hash {
			return false
		}
		if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(networkId)
		hasher.combine(hash)
		hasher.combine(bech32EncodedTxId)
	}
}

// MARK: - FfiConverterTypeSubintentHash
public struct FfiConverterTypeSubintentHash: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubintentHash {
		try SubintentHash(
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			hash: FfiConverterTypeHash.read(from: &buf),
			bech32EncodedTxId: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: SubintentHash, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeHash.write(value.hash, into: &buf)
		FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
	}
}

public func FfiConverterTypeSubintentHash_lift(_ buf: RustBuffer) throws -> SubintentHash {
	try FfiConverterTypeSubintentHash.lift(buf)
}

public func FfiConverterTypeSubintentHash_lower(_ value: SubintentHash) -> RustBuffer {
	FfiConverterTypeSubintentHash.lower(value)
}

// MARK: - SubintentManifest
public struct SubintentManifest {
	public var rawManifest: BagOfBytes
	public var networkId: NetworkId

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(rawManifest: BagOfBytes, networkId: NetworkId) {
		self.rawManifest = rawManifest
		self.networkId = networkId
	}
}

// MARK: Sendable
extension SubintentManifest: Sendable {}

// MARK: Equatable, Hashable
extension SubintentManifest: Equatable, Hashable {
	public static func == (lhs: SubintentManifest, rhs: SubintentManifest) -> Bool {
		if lhs.rawManifest != rhs.rawManifest {
			return false
		}
		if lhs.networkId != rhs.networkId {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(rawManifest)
		hasher.combine(networkId)
	}
}

// MARK: - FfiConverterTypeSubintentManifest
public struct FfiConverterTypeSubintentManifest: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubintentManifest {
		try SubintentManifest(
			rawManifest: FfiConverterTypeBagOfBytes.read(from: &buf),
			networkId: FfiConverterTypeNetworkID.read(from: &buf)
		)
	}

	public static func write(_ value: SubintentManifest, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.rawManifest, into: &buf)
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
	}
}

public func FfiConverterTypeSubintentManifest_lift(_ buf: RustBuffer) throws -> SubintentManifest {
	try FfiConverterTypeSubintentManifest.lift(buf)
}

public func FfiConverterTypeSubintentManifest_lower(_ value: SubintentManifest) -> RustBuffer {
	FfiConverterTypeSubintentManifest.lower(value)
}

// MARK: - ThirdPartyDeposits
/**
 * Controls the ability of third-parties to deposit into a certain account, this is
 * useful for users who wish to not be able to receive airdrops.
 */
public struct ThirdPartyDeposits {
	/**
	 * Controls the ability of third-parties to deposit into this account
	 */
	public var depositRule: DepositRule
	/**
	 * Denies or allows third-party deposits of specific assets by ignoring the `depositMode`
	 * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
	 * thus the value is unknown.
	 */
	public var assetsExceptionList: [AssetException]?
	/**
	 * Allows certain third-party depositors to deposit assets freely.
	 * Note: There is no `deny` counterpart for this.
	 * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
	 * thus the value is unknown.
	 */
	public var depositorsAllowList: [ResourceOrNonFungible]?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Controls the ability of third-parties to deposit into this account
		 */ depositRule: DepositRule,
		/**
			* Denies or allows third-party deposits of specific assets by ignoring the `depositMode`
			* `nil` means that the account was "recovered" using "Account Recovery Scan" features,
			* thus the value is unknown.
			*/ assetsExceptionList: [AssetException]?,
		/**
			* Allows certain third-party depositors to deposit assets freely.
			* Note: There is no `deny` counterpart for this.
			* `nil` means that the account was "recovered" using "Account Recovery Scan" features,
			* thus the value is unknown.
			*/ depositorsAllowList: [ResourceOrNonFungible]?
	) {
		self.depositRule = depositRule
		self.assetsExceptionList = assetsExceptionList
		self.depositorsAllowList = depositorsAllowList
	}
}

// MARK: Sendable
extension ThirdPartyDeposits: Sendable {}

// MARK: Equatable, Hashable
extension ThirdPartyDeposits: Equatable, Hashable {
	public static func == (lhs: ThirdPartyDeposits, rhs: ThirdPartyDeposits) -> Bool {
		if lhs.depositRule != rhs.depositRule {
			return false
		}
		if lhs.assetsExceptionList != rhs.assetsExceptionList {
			return false
		}
		if lhs.depositorsAllowList != rhs.depositorsAllowList {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(depositRule)
		hasher.combine(assetsExceptionList)
		hasher.combine(depositorsAllowList)
	}
}

// MARK: - FfiConverterTypeThirdPartyDeposits
public struct FfiConverterTypeThirdPartyDeposits: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThirdPartyDeposits {
		try ThirdPartyDeposits(
			depositRule: FfiConverterTypeDepositRule.read(from: &buf),
			assetsExceptionList: FfiConverterOptionSequenceTypeAssetException.read(from: &buf),
			depositorsAllowList: FfiConverterOptionSequenceTypeResourceOrNonFungible.read(from: &buf)
		)
	}

	public static func write(_ value: ThirdPartyDeposits, into buf: inout [UInt8]) {
		FfiConverterTypeDepositRule.write(value.depositRule, into: &buf)
		FfiConverterOptionSequenceTypeAssetException.write(value.assetsExceptionList, into: &buf)
		FfiConverterOptionSequenceTypeResourceOrNonFungible.write(value.depositorsAllowList, into: &buf)
	}
}

public func FfiConverterTypeThirdPartyDeposits_lift(_ buf: RustBuffer) throws -> ThirdPartyDeposits {
	try FfiConverterTypeThirdPartyDeposits.lift(buf)
}

public func FfiConverterTypeThirdPartyDeposits_lower(_ value: ThirdPartyDeposits) -> RustBuffer {
	FfiConverterTypeThirdPartyDeposits.lower(value)
}

// MARK: - TokenDefinitionMetadata
public struct TokenDefinitionMetadata {
	public var name: String
	public var description: String
	public var symbol: String
	public var iconUrl: String
	public var tags: [String]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(name: String, description: String, symbol: String, iconUrl: String, tags: [String]) {
		self.name = name
		self.description = description
		self.symbol = symbol
		self.iconUrl = iconUrl
		self.tags = tags
	}
}

// MARK: Sendable
extension TokenDefinitionMetadata: Sendable {}

// MARK: Equatable, Hashable
extension TokenDefinitionMetadata: Equatable, Hashable {
	public static func == (lhs: TokenDefinitionMetadata, rhs: TokenDefinitionMetadata) -> Bool {
		if lhs.name != rhs.name {
			return false
		}
		if lhs.description != rhs.description {
			return false
		}
		if lhs.symbol != rhs.symbol {
			return false
		}
		if lhs.iconUrl != rhs.iconUrl {
			return false
		}
		if lhs.tags != rhs.tags {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(name)
		hasher.combine(description)
		hasher.combine(symbol)
		hasher.combine(iconUrl)
		hasher.combine(tags)
	}
}

// MARK: - FfiConverterTypeTokenDefinitionMetadata
public struct FfiConverterTypeTokenDefinitionMetadata: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenDefinitionMetadata {
		try TokenDefinitionMetadata(
			name: FfiConverterString.read(from: &buf),
			description: FfiConverterString.read(from: &buf),
			symbol: FfiConverterString.read(from: &buf),
			iconUrl: FfiConverterString.read(from: &buf),
			tags: FfiConverterSequenceString.read(from: &buf)
		)
	}

	public static func write(_ value: TokenDefinitionMetadata, into buf: inout [UInt8]) {
		FfiConverterString.write(value.name, into: &buf)
		FfiConverterString.write(value.description, into: &buf)
		FfiConverterString.write(value.symbol, into: &buf)
		FfiConverterString.write(value.iconUrl, into: &buf)
		FfiConverterSequenceString.write(value.tags, into: &buf)
	}
}

public func FfiConverterTypeTokenDefinitionMetadata_lift(_ buf: RustBuffer) throws -> TokenDefinitionMetadata {
	try FfiConverterTypeTokenDefinitionMetadata.lift(buf)
}

public func FfiConverterTypeTokenDefinitionMetadata_lower(_ value: TokenDefinitionMetadata) -> RustBuffer {
	FfiConverterTypeTokenDefinitionMetadata.lower(value)
}

// MARK: - TrackedPoolContribution
/**
 * A contribution to a pool observed in the transaction
 */
public struct TrackedPoolContribution {
	public var poolAddress: PoolAddress
	public var contributedResources: [ResourceAddress: Decimal192]
	public var poolUnitsResourceAddress: ResourceAddress
	public var poolUnitsAmount: Decimal192

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(poolAddress: PoolAddress, contributedResources: [ResourceAddress: Decimal192], poolUnitsResourceAddress: ResourceAddress, poolUnitsAmount: Decimal192) {
		self.poolAddress = poolAddress
		self.contributedResources = contributedResources
		self.poolUnitsResourceAddress = poolUnitsResourceAddress
		self.poolUnitsAmount = poolUnitsAmount
	}
}

// MARK: Sendable
extension TrackedPoolContribution: Sendable {}

// MARK: Equatable, Hashable
extension TrackedPoolContribution: Equatable, Hashable {
	public static func == (lhs: TrackedPoolContribution, rhs: TrackedPoolContribution) -> Bool {
		if lhs.poolAddress != rhs.poolAddress {
			return false
		}
		if lhs.contributedResources != rhs.contributedResources {
			return false
		}
		if lhs.poolUnitsResourceAddress != rhs.poolUnitsResourceAddress {
			return false
		}
		if lhs.poolUnitsAmount != rhs.poolUnitsAmount {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(poolAddress)
		hasher.combine(contributedResources)
		hasher.combine(poolUnitsResourceAddress)
		hasher.combine(poolUnitsAmount)
	}
}

// MARK: - FfiConverterTypeTrackedPoolContribution
public struct FfiConverterTypeTrackedPoolContribution: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedPoolContribution {
		try TrackedPoolContribution(
			poolAddress: FfiConverterTypePoolAddress.read(from: &buf),
			contributedResources: FfiConverterDictionaryTypeResourceAddressTypeDecimal192.read(from: &buf),
			poolUnitsResourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
			poolUnitsAmount: FfiConverterTypeDecimal192.read(from: &buf)
		)
	}

	public static func write(_ value: TrackedPoolContribution, into buf: inout [UInt8]) {
		FfiConverterTypePoolAddress.write(value.poolAddress, into: &buf)
		FfiConverterDictionaryTypeResourceAddressTypeDecimal192.write(value.contributedResources, into: &buf)
		FfiConverterTypeResourceAddress.write(value.poolUnitsResourceAddress, into: &buf)
		FfiConverterTypeDecimal192.write(value.poolUnitsAmount, into: &buf)
	}
}

public func FfiConverterTypeTrackedPoolContribution_lift(_ buf: RustBuffer) throws -> TrackedPoolContribution {
	try FfiConverterTypeTrackedPoolContribution.lift(buf)
}

public func FfiConverterTypeTrackedPoolContribution_lower(_ value: TrackedPoolContribution) -> RustBuffer {
	FfiConverterTypeTrackedPoolContribution.lower(value)
}

// MARK: - TrackedPoolRedemption
/**
 * A pool redemptions observed in the transaction
 */
public struct TrackedPoolRedemption {
	public var poolAddress: PoolAddress
	public var poolUnitsResourceAddress: ResourceAddress
	public var poolUnitsAmount: Decimal192
	public var redeemedResources: [ResourceAddress: Decimal192]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(poolAddress: PoolAddress, poolUnitsResourceAddress: ResourceAddress, poolUnitsAmount: Decimal192, redeemedResources: [ResourceAddress: Decimal192]) {
		self.poolAddress = poolAddress
		self.poolUnitsResourceAddress = poolUnitsResourceAddress
		self.poolUnitsAmount = poolUnitsAmount
		self.redeemedResources = redeemedResources
	}
}

// MARK: Sendable
extension TrackedPoolRedemption: Sendable {}

// MARK: Equatable, Hashable
extension TrackedPoolRedemption: Equatable, Hashable {
	public static func == (lhs: TrackedPoolRedemption, rhs: TrackedPoolRedemption) -> Bool {
		if lhs.poolAddress != rhs.poolAddress {
			return false
		}
		if lhs.poolUnitsResourceAddress != rhs.poolUnitsResourceAddress {
			return false
		}
		if lhs.poolUnitsAmount != rhs.poolUnitsAmount {
			return false
		}
		if lhs.redeemedResources != rhs.redeemedResources {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(poolAddress)
		hasher.combine(poolUnitsResourceAddress)
		hasher.combine(poolUnitsAmount)
		hasher.combine(redeemedResources)
	}
}

// MARK: - FfiConverterTypeTrackedPoolRedemption
public struct FfiConverterTypeTrackedPoolRedemption: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedPoolRedemption {
		try TrackedPoolRedemption(
			poolAddress: FfiConverterTypePoolAddress.read(from: &buf),
			poolUnitsResourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
			poolUnitsAmount: FfiConverterTypeDecimal192.read(from: &buf),
			redeemedResources: FfiConverterDictionaryTypeResourceAddressTypeDecimal192.read(from: &buf)
		)
	}

	public static func write(_ value: TrackedPoolRedemption, into buf: inout [UInt8]) {
		FfiConverterTypePoolAddress.write(value.poolAddress, into: &buf)
		FfiConverterTypeResourceAddress.write(value.poolUnitsResourceAddress, into: &buf)
		FfiConverterTypeDecimal192.write(value.poolUnitsAmount, into: &buf)
		FfiConverterDictionaryTypeResourceAddressTypeDecimal192.write(value.redeemedResources, into: &buf)
	}
}

public func FfiConverterTypeTrackedPoolRedemption_lift(_ buf: RustBuffer) throws -> TrackedPoolRedemption {
	try FfiConverterTypeTrackedPoolRedemption.lift(buf)
}

public func FfiConverterTypeTrackedPoolRedemption_lower(_ value: TrackedPoolRedemption) -> RustBuffer {
	FfiConverterTypeTrackedPoolRedemption.lower(value)
}

// MARK: - TrackedValidatorClaim
/**
 * A validator claim observed in the transaction
 */
public struct TrackedValidatorClaim {
	public var validatorAddress: ValidatorAddress
	public var claimNftAddress: ResourceAddress
	public var claimNftIds: [NonFungibleLocalId]
	public var xrdAmount: Decimal192

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(validatorAddress: ValidatorAddress, claimNftAddress: ResourceAddress, claimNftIds: [NonFungibleLocalId], xrdAmount: Decimal192) {
		self.validatorAddress = validatorAddress
		self.claimNftAddress = claimNftAddress
		self.claimNftIds = claimNftIds
		self.xrdAmount = xrdAmount
	}
}

// MARK: Sendable
extension TrackedValidatorClaim: Sendable {}

// MARK: Equatable, Hashable
extension TrackedValidatorClaim: Equatable, Hashable {
	public static func == (lhs: TrackedValidatorClaim, rhs: TrackedValidatorClaim) -> Bool {
		if lhs.validatorAddress != rhs.validatorAddress {
			return false
		}
		if lhs.claimNftAddress != rhs.claimNftAddress {
			return false
		}
		if lhs.claimNftIds != rhs.claimNftIds {
			return false
		}
		if lhs.xrdAmount != rhs.xrdAmount {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(validatorAddress)
		hasher.combine(claimNftAddress)
		hasher.combine(claimNftIds)
		hasher.combine(xrdAmount)
	}
}

// MARK: - FfiConverterTypeTrackedValidatorClaim
public struct FfiConverterTypeTrackedValidatorClaim: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorClaim {
		try TrackedValidatorClaim(
			validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf),
			claimNftAddress: FfiConverterTypeResourceAddress.read(from: &buf),
			claimNftIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
			xrdAmount: FfiConverterTypeDecimal192.read(from: &buf)
		)
	}

	public static func write(_ value: TrackedValidatorClaim, into buf: inout [UInt8]) {
		FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
		FfiConverterTypeResourceAddress.write(value.claimNftAddress, into: &buf)
		FfiConverterSequenceTypeNonFungibleLocalId.write(value.claimNftIds, into: &buf)
		FfiConverterTypeDecimal192.write(value.xrdAmount, into: &buf)
	}
}

public func FfiConverterTypeTrackedValidatorClaim_lift(_ buf: RustBuffer) throws -> TrackedValidatorClaim {
	try FfiConverterTypeTrackedValidatorClaim.lift(buf)
}

public func FfiConverterTypeTrackedValidatorClaim_lower(_ value: TrackedValidatorClaim) -> RustBuffer {
	FfiConverterTypeTrackedValidatorClaim.lower(value)
}

// MARK: - TrackedValidatorStake
/**
 * A validator stake observed in the transaction
 */
public struct TrackedValidatorStake {
	public var validatorAddress: ValidatorAddress
	public var xrdAmount: Decimal192
	public var liquidStakeUnitAddress: ResourceAddress
	public var liquidStakeUnitAmount: Decimal192

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(validatorAddress: ValidatorAddress, xrdAmount: Decimal192, liquidStakeUnitAddress: ResourceAddress, liquidStakeUnitAmount: Decimal192) {
		self.validatorAddress = validatorAddress
		self.xrdAmount = xrdAmount
		self.liquidStakeUnitAddress = liquidStakeUnitAddress
		self.liquidStakeUnitAmount = liquidStakeUnitAmount
	}
}

// MARK: Sendable
extension TrackedValidatorStake: Sendable {}

// MARK: Equatable, Hashable
extension TrackedValidatorStake: Equatable, Hashable {
	public static func == (lhs: TrackedValidatorStake, rhs: TrackedValidatorStake) -> Bool {
		if lhs.validatorAddress != rhs.validatorAddress {
			return false
		}
		if lhs.xrdAmount != rhs.xrdAmount {
			return false
		}
		if lhs.liquidStakeUnitAddress != rhs.liquidStakeUnitAddress {
			return false
		}
		if lhs.liquidStakeUnitAmount != rhs.liquidStakeUnitAmount {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(validatorAddress)
		hasher.combine(xrdAmount)
		hasher.combine(liquidStakeUnitAddress)
		hasher.combine(liquidStakeUnitAmount)
	}
}

// MARK: - FfiConverterTypeTrackedValidatorStake
public struct FfiConverterTypeTrackedValidatorStake: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorStake {
		try TrackedValidatorStake(
			validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf),
			xrdAmount: FfiConverterTypeDecimal192.read(from: &buf),
			liquidStakeUnitAddress: FfiConverterTypeResourceAddress.read(from: &buf),
			liquidStakeUnitAmount: FfiConverterTypeDecimal192.read(from: &buf)
		)
	}

	public static func write(_ value: TrackedValidatorStake, into buf: inout [UInt8]) {
		FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
		FfiConverterTypeDecimal192.write(value.xrdAmount, into: &buf)
		FfiConverterTypeResourceAddress.write(value.liquidStakeUnitAddress, into: &buf)
		FfiConverterTypeDecimal192.write(value.liquidStakeUnitAmount, into: &buf)
	}
}

public func FfiConverterTypeTrackedValidatorStake_lift(_ buf: RustBuffer) throws -> TrackedValidatorStake {
	try FfiConverterTypeTrackedValidatorStake.lift(buf)
}

public func FfiConverterTypeTrackedValidatorStake_lower(_ value: TrackedValidatorStake) -> RustBuffer {
	FfiConverterTypeTrackedValidatorStake.lower(value)
}

// MARK: - TransactionGuarantee
public struct TransactionGuarantee {
	/**
	 * The guaranteed amount to be obtained on this transaction. For manifest & display purposes.
	 */
	public var amount: Decimal192
	/**
	 * The percentage the user has selected, which generated the `amount`. For display purposes only.
	 */
	public var percentage: Decimal192
	public var instructionIndex: UInt64
	public var resourceAddress: ResourceAddress
	public var resourceDivisibility: UInt8?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The guaranteed amount to be obtained on this transaction. For manifest & display purposes.
		 */ amount: Decimal192,
		/**
			* The percentage the user has selected, which generated the `amount`. For display purposes only.
			*/ percentage: Decimal192, instructionIndex: UInt64, resourceAddress: ResourceAddress, resourceDivisibility: UInt8?
	) {
		self.amount = amount
		self.percentage = percentage
		self.instructionIndex = instructionIndex
		self.resourceAddress = resourceAddress
		self.resourceDivisibility = resourceDivisibility
	}
}

// MARK: Sendable
extension TransactionGuarantee: Sendable {}

// MARK: Equatable, Hashable
extension TransactionGuarantee: Equatable, Hashable {
	public static func == (lhs: TransactionGuarantee, rhs: TransactionGuarantee) -> Bool {
		if lhs.amount != rhs.amount {
			return false
		}
		if lhs.percentage != rhs.percentage {
			return false
		}
		if lhs.instructionIndex != rhs.instructionIndex {
			return false
		}
		if lhs.resourceAddress != rhs.resourceAddress {
			return false
		}
		if lhs.resourceDivisibility != rhs.resourceDivisibility {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(amount)
		hasher.combine(percentage)
		hasher.combine(instructionIndex)
		hasher.combine(resourceAddress)
		hasher.combine(resourceDivisibility)
	}
}

// MARK: - FfiConverterTypeTransactionGuarantee
public struct FfiConverterTypeTransactionGuarantee: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionGuarantee {
		try TransactionGuarantee(
			amount: FfiConverterTypeDecimal192.read(from: &buf),
			percentage: FfiConverterTypeDecimal192.read(from: &buf),
			instructionIndex: FfiConverterUInt64.read(from: &buf),
			resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
			resourceDivisibility: FfiConverterOptionUInt8.read(from: &buf)
		)
	}

	public static func write(_ value: TransactionGuarantee, into buf: inout [UInt8]) {
		FfiConverterTypeDecimal192.write(value.amount, into: &buf)
		FfiConverterTypeDecimal192.write(value.percentage, into: &buf)
		FfiConverterUInt64.write(value.instructionIndex, into: &buf)
		FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
		FfiConverterOptionUInt8.write(value.resourceDivisibility, into: &buf)
	}
}

public func FfiConverterTypeTransactionGuarantee_lift(_ buf: RustBuffer) throws -> TransactionGuarantee {
	try FfiConverterTypeTransactionGuarantee.lift(buf)
}

public func FfiConverterTypeTransactionGuarantee_lower(_ value: TransactionGuarantee) -> RustBuffer {
	FfiConverterTypeTransactionGuarantee.lower(value)
}

// MARK: - TransactionHeader
public struct TransactionHeader {
	public var networkId: NetworkId
	public var startEpochInclusive: Epoch
	public var endEpochExclusive: Epoch
	public var nonce: Nonce
	public var notaryPublicKey: PublicKey
	public var notaryIsSignatory: Bool
	public var tipPercentage: UInt16

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(networkId: NetworkId, startEpochInclusive: Epoch, endEpochExclusive: Epoch, nonce: Nonce, notaryPublicKey: PublicKey, notaryIsSignatory: Bool, tipPercentage: UInt16) {
		self.networkId = networkId
		self.startEpochInclusive = startEpochInclusive
		self.endEpochExclusive = endEpochExclusive
		self.nonce = nonce
		self.notaryPublicKey = notaryPublicKey
		self.notaryIsSignatory = notaryIsSignatory
		self.tipPercentage = tipPercentage
	}
}

// MARK: Sendable
extension TransactionHeader: Sendable {}

// MARK: Equatable, Hashable
extension TransactionHeader: Equatable, Hashable {
	public static func == (lhs: TransactionHeader, rhs: TransactionHeader) -> Bool {
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.startEpochInclusive != rhs.startEpochInclusive {
			return false
		}
		if lhs.endEpochExclusive != rhs.endEpochExclusive {
			return false
		}
		if lhs.nonce != rhs.nonce {
			return false
		}
		if lhs.notaryPublicKey != rhs.notaryPublicKey {
			return false
		}
		if lhs.notaryIsSignatory != rhs.notaryIsSignatory {
			return false
		}
		if lhs.tipPercentage != rhs.tipPercentage {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(networkId)
		hasher.combine(startEpochInclusive)
		hasher.combine(endEpochExclusive)
		hasher.combine(nonce)
		hasher.combine(notaryPublicKey)
		hasher.combine(notaryIsSignatory)
		hasher.combine(tipPercentage)
	}
}

// MARK: - FfiConverterTypeTransactionHeader
public struct FfiConverterTypeTransactionHeader: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHeader {
		try TransactionHeader(
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			startEpochInclusive: FfiConverterTypeEpoch.read(from: &buf),
			endEpochExclusive: FfiConverterTypeEpoch.read(from: &buf),
			nonce: FfiConverterTypeNonce.read(from: &buf),
			notaryPublicKey: FfiConverterTypePublicKey.read(from: &buf),
			notaryIsSignatory: FfiConverterBool.read(from: &buf),
			tipPercentage: FfiConverterUInt16.read(from: &buf)
		)
	}

	public static func write(_ value: TransactionHeader, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeEpoch.write(value.startEpochInclusive, into: &buf)
		FfiConverterTypeEpoch.write(value.endEpochExclusive, into: &buf)
		FfiConverterTypeNonce.write(value.nonce, into: &buf)
		FfiConverterTypePublicKey.write(value.notaryPublicKey, into: &buf)
		FfiConverterBool.write(value.notaryIsSignatory, into: &buf)
		FfiConverterUInt16.write(value.tipPercentage, into: &buf)
	}
}

public func FfiConverterTypeTransactionHeader_lift(_ buf: RustBuffer) throws -> TransactionHeader {
	try FfiConverterTypeTransactionHeader.lift(buf)
}

public func FfiConverterTypeTransactionHeader_lower(_ value: TransactionHeader) -> RustBuffer {
	FfiConverterTypeTransactionHeader.lower(value)
}

// MARK: - TransactionIntent
public struct TransactionIntent {
	public var header: TransactionHeader
	public var manifest: TransactionManifest
	public var message: Message

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(header: TransactionHeader, manifest: TransactionManifest, message: Message) {
		self.header = header
		self.manifest = manifest
		self.message = message
	}
}

// MARK: Sendable
extension TransactionIntent: Sendable {}

// MARK: Equatable, Hashable
extension TransactionIntent: Equatable, Hashable {
	public static func == (lhs: TransactionIntent, rhs: TransactionIntent) -> Bool {
		if lhs.header != rhs.header {
			return false
		}
		if lhs.manifest != rhs.manifest {
			return false
		}
		if lhs.message != rhs.message {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(header)
		hasher.combine(manifest)
		hasher.combine(message)
	}
}

// MARK: - FfiConverterTypeTransactionIntent
public struct FfiConverterTypeTransactionIntent: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionIntent {
		try TransactionIntent(
			header: FfiConverterTypeTransactionHeader.read(from: &buf),
			manifest: FfiConverterTypeTransactionManifest.read(from: &buf),
			message: FfiConverterTypeMessage.read(from: &buf)
		)
	}

	public static func write(_ value: TransactionIntent, into buf: inout [UInt8]) {
		FfiConverterTypeTransactionHeader.write(value.header, into: &buf)
		FfiConverterTypeTransactionManifest.write(value.manifest, into: &buf)
		FfiConverterTypeMessage.write(value.message, into: &buf)
	}
}

public func FfiConverterTypeTransactionIntent_lift(_ buf: RustBuffer) throws -> TransactionIntent {
	try FfiConverterTypeTransactionIntent.lift(buf)
}

public func FfiConverterTypeTransactionIntent_lower(_ value: TransactionIntent) -> RustBuffer {
	FfiConverterTypeTransactionIntent.lower(value)
}

// MARK: - TransactionIntentHash
/**
 * `IntentHash` used to identify transactions.
 * Representation is bech32 encoded string starting with `txid_` e.g.:
 * `"txid_rdx19rpveua6xuhvz0axu0mwpqk8fywr83atv8mkrugchvw6uuslgppqh9cnj4"`
 */
public struct TransactionIntentHash {
	/**
	 * Which network this transaction hash is used on
	 */
	public var networkId: NetworkId
	/**
	 * the hash of the intent
	 */
	public var hash: Hash
	/**
	 * Bech32 encoded TX id
	 */
	public var bech32EncodedTxId: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Which network this transaction hash is used on
		 */ networkId: NetworkId,
		/**
			* the hash of the intent
			*/ hash: Hash,
		/**
			* Bech32 encoded TX id
			*/ bech32EncodedTxId: String
	) {
		self.networkId = networkId
		self.hash = hash
		self.bech32EncodedTxId = bech32EncodedTxId
	}
}

// MARK: Sendable
extension TransactionIntentHash: Sendable {}

// MARK: Equatable, Hashable
extension TransactionIntentHash: Equatable, Hashable {
	public static func == (lhs: TransactionIntentHash, rhs: TransactionIntentHash) -> Bool {
		if lhs.networkId != rhs.networkId {
			return false
		}
		if lhs.hash != rhs.hash {
			return false
		}
		if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(networkId)
		hasher.combine(hash)
		hasher.combine(bech32EncodedTxId)
	}
}

// MARK: - FfiConverterTypeTransactionIntentHash
public struct FfiConverterTypeTransactionIntentHash: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionIntentHash {
		try TransactionIntentHash(
			networkId: FfiConverterTypeNetworkID.read(from: &buf),
			hash: FfiConverterTypeHash.read(from: &buf),
			bech32EncodedTxId: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: TransactionIntentHash, into buf: inout [UInt8]) {
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
		FfiConverterTypeHash.write(value.hash, into: &buf)
		FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
	}
}

public func FfiConverterTypeTransactionIntentHash_lift(_ buf: RustBuffer) throws -> TransactionIntentHash {
	try FfiConverterTypeTransactionIntentHash.lift(buf)
}

public func FfiConverterTypeTransactionIntentHash_lower(_ value: TransactionIntentHash) -> RustBuffer {
	FfiConverterTypeTransactionIntentHash.lower(value)
}

// MARK: - TransactionManifest
public struct TransactionManifest {
	public var rawManifest: BagOfBytes
	public var networkId: NetworkId

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(rawManifest: BagOfBytes, networkId: NetworkId) {
		self.rawManifest = rawManifest
		self.networkId = networkId
	}
}

// MARK: Sendable
extension TransactionManifest: Sendable {}

// MARK: Equatable, Hashable
extension TransactionManifest: Equatable, Hashable {
	public static func == (lhs: TransactionManifest, rhs: TransactionManifest) -> Bool {
		if lhs.rawManifest != rhs.rawManifest {
			return false
		}
		if lhs.networkId != rhs.networkId {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(rawManifest)
		hasher.combine(networkId)
	}
}

// MARK: - FfiConverterTypeTransactionManifest
public struct FfiConverterTypeTransactionManifest: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifest {
		try TransactionManifest(
			rawManifest: FfiConverterTypeBagOfBytes.read(from: &buf),
			networkId: FfiConverterTypeNetworkID.read(from: &buf)
		)
	}

	public static func write(_ value: TransactionManifest, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.rawManifest, into: &buf)
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
	}
}

public func FfiConverterTypeTransactionManifest_lift(_ buf: RustBuffer) throws -> TransactionManifest {
	try FfiConverterTypeTransactionManifest.lift(buf)
}

public func FfiConverterTypeTransactionManifest_lower(_ value: TransactionManifest) -> RustBuffer {
	FfiConverterTypeTransactionManifest.lower(value)
}

// MARK: - TransactionManifestV2
public struct TransactionManifestV2 {
	public var rawManifest: BagOfBytes
	public var networkId: NetworkId

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(rawManifest: BagOfBytes, networkId: NetworkId) {
		self.rawManifest = rawManifest
		self.networkId = networkId
	}
}

// MARK: Sendable
extension TransactionManifestV2: Sendable {}

// MARK: Equatable, Hashable
extension TransactionManifestV2: Equatable, Hashable {
	public static func == (lhs: TransactionManifestV2, rhs: TransactionManifestV2) -> Bool {
		if lhs.rawManifest != rhs.rawManifest {
			return false
		}
		if lhs.networkId != rhs.networkId {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(rawManifest)
		hasher.combine(networkId)
	}
}

// MARK: - FfiConverterTypeTransactionManifestV2
public struct FfiConverterTypeTransactionManifestV2: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifestV2 {
		try TransactionManifestV2(
			rawManifest: FfiConverterTypeBagOfBytes.read(from: &buf),
			networkId: FfiConverterTypeNetworkID.read(from: &buf)
		)
	}

	public static func write(_ value: TransactionManifestV2, into buf: inout [UInt8]) {
		FfiConverterTypeBagOfBytes.write(value.rawManifest, into: &buf)
		FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
	}
}

public func FfiConverterTypeTransactionManifestV2_lift(_ buf: RustBuffer) throws -> TransactionManifestV2 {
	try FfiConverterTypeTransactionManifestV2.lift(buf)
}

public func FfiConverterTypeTransactionManifestV2_lower(_ value: TransactionManifestV2) -> RustBuffer {
	FfiConverterTypeTransactionManifestV2.lower(value)
}

// MARK: - TransactionPreferences
/**
 * User Preferences relating to submission of transactions.
 */
public struct TransactionPreferences {
	/**
	 * The deposit guarantee that will automatically be added for
	 * all deposits in transactions.
	 */
	public var defaultDepositGuarantee: Decimal192

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The deposit guarantee that will automatically be added for
		 * all deposits in transactions.
		 */ defaultDepositGuarantee: Decimal192
	) {
		self.defaultDepositGuarantee = defaultDepositGuarantee
	}
}

// MARK: Sendable
extension TransactionPreferences: Sendable {}

// MARK: Equatable, Hashable
extension TransactionPreferences: Equatable, Hashable {
	public static func == (lhs: TransactionPreferences, rhs: TransactionPreferences) -> Bool {
		if lhs.defaultDepositGuarantee != rhs.defaultDepositGuarantee {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(defaultDepositGuarantee)
	}
}

// MARK: - FfiConverterTypeTransactionPreferences
public struct FfiConverterTypeTransactionPreferences: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionPreferences {
		try TransactionPreferences(
			defaultDepositGuarantee: FfiConverterTypeDecimal192.read(from: &buf)
		)
	}

	public static func write(_ value: TransactionPreferences, into buf: inout [UInt8]) {
		FfiConverterTypeDecimal192.write(value.defaultDepositGuarantee, into: &buf)
	}
}

public func FfiConverterTypeTransactionPreferences_lift(_ buf: RustBuffer) throws -> TransactionPreferences {
	try FfiConverterTypeTransactionPreferences.lift(buf)
}

public func FfiConverterTypeTransactionPreferences_lower(_ value: TransactionPreferences) -> RustBuffer {
	FfiConverterTypeTransactionPreferences.lower(value)
}

// MARK: - TransactionToReview
/**
 * This is the result of the transaction preview analysis.
 * It contains all the information needed to compute and display the transaction details to the user.
 */
public struct TransactionToReview {
	public var transactionManifest: TransactionManifest
	public var executionSummary: ExecutionSummary

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(transactionManifest: TransactionManifest, executionSummary: ExecutionSummary) {
		self.transactionManifest = transactionManifest
		self.executionSummary = executionSummary
	}
}

// MARK: Sendable
extension TransactionToReview: Sendable {}

// MARK: Equatable, Hashable
extension TransactionToReview: Equatable, Hashable {
	public static func == (lhs: TransactionToReview, rhs: TransactionToReview) -> Bool {
		if lhs.transactionManifest != rhs.transactionManifest {
			return false
		}
		if lhs.executionSummary != rhs.executionSummary {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(transactionManifest)
		hasher.combine(executionSummary)
	}
}

// MARK: - FfiConverterTypeTransactionToReview
public struct FfiConverterTypeTransactionToReview: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionToReview {
		try TransactionToReview(
			transactionManifest: FfiConverterTypeTransactionManifest.read(from: &buf),
			executionSummary: FfiConverterTypeExecutionSummary.read(from: &buf)
		)
	}

	public static func write(_ value: TransactionToReview, into buf: inout [UInt8]) {
		FfiConverterTypeTransactionManifest.write(value.transactionManifest, into: &buf)
		FfiConverterTypeExecutionSummary.write(value.executionSummary, into: &buf)
	}
}

public func FfiConverterTypeTransactionToReview_lift(_ buf: RustBuffer) throws -> TransactionToReview {
	try FfiConverterTypeTransactionToReview.lift(buf)
}

public func FfiConverterTypeTransactionToReview_lower(_ value: TransactionToReview) -> RustBuffer {
	FfiConverterTypeTransactionToReview.lower(value)
}

// MARK: - TrustedContactFactorSource
/**
 * A factor source representing a person, company, organization or otherwise
 * entity that the user trusts to help her with recovery, if ever needed.
 */
public struct TrustedContactFactorSource {
	/**
	 * Unique and stable identifier of this factor source.
	 */
	public var id: FactorSourceIdFromAddress
	/**
	 * Common properties shared between FactorSources of different kinds,
	 * describing its state, when added, and supported cryptographic parameters.
	 */
	public var common: FactorSourceCommon
	/**
	 * The contact information about the contact that is 'trusted'.
	 */
	public var contact: TrustedContactFactorSourceContact

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * Unique and stable identifier of this factor source.
		 */ id: FactorSourceIdFromAddress,
		/**
			* Common properties shared between FactorSources of different kinds,
			* describing its state, when added, and supported cryptographic parameters.
			*/ common: FactorSourceCommon,
		/**
			* The contact information about the contact that is 'trusted'.
			*/ contact: TrustedContactFactorSourceContact
	) {
		self.id = id
		self.common = common
		self.contact = contact
	}
}

// MARK: Sendable
extension TrustedContactFactorSource: Sendable {}

// MARK: Equatable, Hashable
extension TrustedContactFactorSource: Equatable, Hashable {
	public static func == (lhs: TrustedContactFactorSource, rhs: TrustedContactFactorSource) -> Bool {
		if lhs.id != rhs.id {
			return false
		}
		if lhs.common != rhs.common {
			return false
		}
		if lhs.contact != rhs.contact {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(id)
		hasher.combine(common)
		hasher.combine(contact)
	}
}

// MARK: - FfiConverterTypeTrustedContactFactorSource
public struct FfiConverterTypeTrustedContactFactorSource: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrustedContactFactorSource {
		try TrustedContactFactorSource(
			id: FfiConverterTypeFactorSourceIDFromAddress.read(from: &buf),
			common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
			contact: FfiConverterTypeTrustedContactFactorSourceContact.read(from: &buf)
		)
	}

	public static func write(_ value: TrustedContactFactorSource, into buf: inout [UInt8]) {
		FfiConverterTypeFactorSourceIDFromAddress.write(value.id, into: &buf)
		FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
		FfiConverterTypeTrustedContactFactorSourceContact.write(value.contact, into: &buf)
	}
}

public func FfiConverterTypeTrustedContactFactorSource_lift(_ buf: RustBuffer) throws -> TrustedContactFactorSource {
	try FfiConverterTypeTrustedContactFactorSource.lift(buf)
}

public func FfiConverterTypeTrustedContactFactorSource_lower(_ value: TrustedContactFactorSource) -> RustBuffer {
	FfiConverterTypeTrustedContactFactorSource.lower(value)
}

// MARK: - TrustedContactFactorSourceContact
/**
 * Hints about the trusted contact.
 */
public struct TrustedContactFactorSourceContact {
	/**
	 * The email address of the contact that the user trusts
	 */
	public var emailAddress: EmailAddress
	/**
	 * The name of the contact that the user trusts
	 */
	public var name: DisplayName

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * The email address of the contact that the user trusts
		 */ emailAddress: EmailAddress,
		/**
			* The name of the contact that the user trusts
			*/ name: DisplayName
	) {
		self.emailAddress = emailAddress
		self.name = name
	}
}

// MARK: Sendable
extension TrustedContactFactorSourceContact: Sendable {}

// MARK: Equatable, Hashable
extension TrustedContactFactorSourceContact: Equatable, Hashable {
	public static func == (lhs: TrustedContactFactorSourceContact, rhs: TrustedContactFactorSourceContact) -> Bool {
		if lhs.emailAddress != rhs.emailAddress {
			return false
		}
		if lhs.name != rhs.name {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(emailAddress)
		hasher.combine(name)
	}
}

// MARK: - FfiConverterTypeTrustedContactFactorSourceContact
public struct FfiConverterTypeTrustedContactFactorSourceContact: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrustedContactFactorSourceContact {
		try TrustedContactFactorSourceContact(
			emailAddress: FfiConverterTypeEmailAddress.read(from: &buf),
			name: FfiConverterTypeDisplayName.read(from: &buf)
		)
	}

	public static func write(_ value: TrustedContactFactorSourceContact, into buf: inout [UInt8]) {
		FfiConverterTypeEmailAddress.write(value.emailAddress, into: &buf)
		FfiConverterTypeDisplayName.write(value.name, into: &buf)
	}
}

public func FfiConverterTypeTrustedContactFactorSourceContact_lift(_ buf: RustBuffer) throws -> TrustedContactFactorSourceContact {
	try FfiConverterTypeTrustedContactFactorSourceContact.lift(buf)
}

public func FfiConverterTypeTrustedContactFactorSourceContact_lower(_ value: TrustedContactFactorSourceContact) -> RustBuffer {
	FfiConverterTypeTrustedContactFactorSourceContact.lower(value)
}

// MARK: - U11
public struct U11 {
	public var inner: UInt16

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(inner: UInt16) {
		self.inner = inner
	}
}

// MARK: Sendable
extension U11: Sendable {}

// MARK: Equatable, Hashable
extension U11: Equatable, Hashable {
	public static func == (lhs: U11, rhs: U11) -> Bool {
		if lhs.inner != rhs.inner {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(inner)
	}
}

// MARK: - FfiConverterTypeU11
public struct FfiConverterTypeU11: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U11 {
		try U11(
			inner: FfiConverterUInt16.read(from: &buf)
		)
	}

	public static func write(_ value: U11, into buf: inout [UInt8]) {
		FfiConverterUInt16.write(value.inner, into: &buf)
	}
}

public func FfiConverterTypeU11_lift(_ buf: RustBuffer) throws -> U11 {
	try FfiConverterTypeU11.lift(buf)
}

public func FfiConverterTypeU11_lower(_ value: U11) -> RustBuffer {
	FfiConverterTypeU11.lower(value)
}

// MARK: - U30
public struct U30 {
	fileprivate let secretMagic: UInt32

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: UInt32) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension U30: Sendable {}

// MARK: Equatable, Hashable
extension U30: Equatable, Hashable {
	public static func == (lhs: U30, rhs: U30) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeU30
public struct FfiConverterTypeU30: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U30 {
		try U30(
			secretMagic: FfiConverterUInt32.read(from: &buf)
		)
	}

	public static func write(_ value: U30, into buf: inout [UInt8]) {
		FfiConverterUInt32.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeU30_lift(_ buf: RustBuffer) throws -> U30 {
	try FfiConverterTypeU30.lift(buf)
}

public func FfiConverterTypeU30_lower(_ value: U30) -> RustBuffer {
	FfiConverterTypeU30.lower(value)
}

// MARK: - U31
public struct U31 {
	fileprivate let secretMagic: UInt32

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: UInt32) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension U31: Sendable {}

// MARK: Equatable, Hashable
extension U31: Equatable, Hashable {
	public static func == (lhs: U31, rhs: U31) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeU31
public struct FfiConverterTypeU31: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U31 {
		try U31(
			secretMagic: FfiConverterUInt32.read(from: &buf)
		)
	}

	public static func write(_ value: U31, into buf: inout [UInt8]) {
		FfiConverterUInt32.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeU31_lift(_ buf: RustBuffer) throws -> U31 {
	try FfiConverterTypeU31.lift(buf)
}

public func FfiConverterTypeU31_lower(_ value: U31) -> RustBuffer {
	FfiConverterTypeU31.lower(value)
}

// MARK: - Unhardened
public struct Unhardened {
	fileprivate let secretMagic: U31

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: U31) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension Unhardened: Sendable {}

// MARK: Equatable, Hashable
extension Unhardened: Equatable, Hashable {
	public static func == (lhs: Unhardened, rhs: Unhardened) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeUnhardened
public struct FfiConverterTypeUnhardened: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unhardened {
		try Unhardened(
			secretMagic: FfiConverterTypeU31.read(from: &buf)
		)
	}

	public static func write(_ value: Unhardened, into buf: inout [UInt8]) {
		FfiConverterTypeU31.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeUnhardened_lift(_ buf: RustBuffer) throws -> Unhardened {
	try FfiConverterTypeUnhardened.lift(buf)
}

public func FfiConverterTypeUnhardened_lower(_ value: Unhardened) -> RustBuffer {
	FfiConverterTypeUnhardened.lower(value)
}

// MARK: - UnsecuredEntityControl
/**
 * Basic security control of an unsecured entity. When said entity
 * is "securified" it will no longer be controlled by this `UnsecuredEntityControl`
 * but rather by an `AccessControl`. It is a name space holding the
 * single factor instance which was used to create
 */
public struct UnsecuredEntityControl {
	public var transactionSigning: HierarchicalDeterministicFactorInstance
	/**
	 * The factor instance which can be used for ROLA.
	 */
	public var authenticationSigning: HierarchicalDeterministicFactorInstance?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(transactionSigning: HierarchicalDeterministicFactorInstance,
	            /**
	            	* The factor instance which can be used for ROLA.
	            	*/ authenticationSigning: HierarchicalDeterministicFactorInstance?)
	{
		self.transactionSigning = transactionSigning
		self.authenticationSigning = authenticationSigning
	}
}

// MARK: Sendable
extension UnsecuredEntityControl: Sendable {}

// MARK: Equatable, Hashable
extension UnsecuredEntityControl: Equatable, Hashable {
	public static func == (lhs: UnsecuredEntityControl, rhs: UnsecuredEntityControl) -> Bool {
		if lhs.transactionSigning != rhs.transactionSigning {
			return false
		}
		if lhs.authenticationSigning != rhs.authenticationSigning {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(transactionSigning)
		hasher.combine(authenticationSigning)
	}
}

// MARK: - FfiConverterTypeUnsecuredEntityControl
public struct FfiConverterTypeUnsecuredEntityControl: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsecuredEntityControl {
		try UnsecuredEntityControl(
			transactionSigning: FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf),
			authenticationSigning: FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
		)
	}

	public static func write(_ value: UnsecuredEntityControl, into buf: inout [UInt8]) {
		FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value.transactionSigning, into: &buf)
		FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.write(value.authenticationSigning, into: &buf)
	}
}

public func FfiConverterTypeUnsecuredEntityControl_lift(_ buf: RustBuffer) throws -> UnsecuredEntityControl {
	try FfiConverterTypeUnsecuredEntityControl.lift(buf)
}

public func FfiConverterTypeUnsecuredEntityControl_lower(_ value: UnsecuredEntityControl) -> RustBuffer {
	FfiConverterTypeUnsecuredEntityControl.lower(value)
}

// MARK: - UnsecurifiedHardened
public struct UnsecurifiedHardened {
	fileprivate let secretMagic: U30

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: U30) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension UnsecurifiedHardened: Sendable {}

// MARK: Equatable, Hashable
extension UnsecurifiedHardened: Equatable, Hashable {
	public static func == (lhs: UnsecurifiedHardened, rhs: UnsecurifiedHardened) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeUnsecurifiedHardened
public struct FfiConverterTypeUnsecurifiedHardened: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsecurifiedHardened {
		try UnsecurifiedHardened(
			secretMagic: FfiConverterTypeU30.read(from: &buf)
		)
	}

	public static func write(_ value: UnsecurifiedHardened, into buf: inout [UInt8]) {
		FfiConverterTypeU30.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeUnsecurifiedHardened_lift(_ buf: RustBuffer) throws -> UnsecurifiedHardened {
	try FfiConverterTypeUnsecurifiedHardened.lift(buf)
}

public func FfiConverterTypeUnsecurifiedHardened_lower(_ value: UnsecurifiedHardened) -> RustBuffer {
	FfiConverterTypeUnsecurifiedHardened.lower(value)
}

// MARK: - UnstakeData
/**
 * The data associated with the various validator claim NFTs
 */
public struct UnstakeData {
	public var name: String
	/**
	 * An epoch number at (or after) which the pending unstaked XRD may be claimed.
	 */
	public var claimEpoch: Epoch
	/**
	 * An XRD amount to be claimed.
	 */
	public var claimAmount: Decimal192

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(name: String,
	            /**
	            	* An epoch number at (or after) which the pending unstaked XRD may be claimed.
	            	*/ claimEpoch: Epoch,
	            /**
	            	* An XRD amount to be claimed.
	            	*/ claimAmount: Decimal192)
	{
		self.name = name
		self.claimEpoch = claimEpoch
		self.claimAmount = claimAmount
	}
}

// MARK: Sendable
extension UnstakeData: Sendable {}

// MARK: Equatable, Hashable
extension UnstakeData: Equatable, Hashable {
	public static func == (lhs: UnstakeData, rhs: UnstakeData) -> Bool {
		if lhs.name != rhs.name {
			return false
		}
		if lhs.claimEpoch != rhs.claimEpoch {
			return false
		}
		if lhs.claimAmount != rhs.claimAmount {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(name)
		hasher.combine(claimEpoch)
		hasher.combine(claimAmount)
	}
}

// MARK: - FfiConverterTypeUnstakeData
public struct FfiConverterTypeUnstakeData: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstakeData {
		try UnstakeData(
			name: FfiConverterString.read(from: &buf),
			claimEpoch: FfiConverterTypeEpoch.read(from: &buf),
			claimAmount: FfiConverterTypeDecimal192.read(from: &buf)
		)
	}

	public static func write(_ value: UnstakeData, into buf: inout [UInt8]) {
		FfiConverterString.write(value.name, into: &buf)
		FfiConverterTypeEpoch.write(value.claimEpoch, into: &buf)
		FfiConverterTypeDecimal192.write(value.claimAmount, into: &buf)
	}
}

public func FfiConverterTypeUnstakeData_lift(_ buf: RustBuffer) throws -> UnstakeData {
	try FfiConverterTypeUnstakeData.lift(buf)
}

public func FfiConverterTypeUnstakeData_lower(_ value: UnstakeData) -> RustBuffer {
	FfiConverterTypeUnstakeData.lower(value)
}

// MARK: - UnvalidatedSubintentManifest
public struct UnvalidatedSubintentManifest {
	public var subintentManifestString: String
	public var blobs: Blobs

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(subintentManifestString: String, blobs: Blobs) {
		self.subintentManifestString = subintentManifestString
		self.blobs = blobs
	}
}

// MARK: Sendable
extension UnvalidatedSubintentManifest: Sendable {}

// MARK: Equatable, Hashable
extension UnvalidatedSubintentManifest: Equatable, Hashable {
	public static func == (lhs: UnvalidatedSubintentManifest, rhs: UnvalidatedSubintentManifest) -> Bool {
		if lhs.subintentManifestString != rhs.subintentManifestString {
			return false
		}
		if lhs.blobs != rhs.blobs {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(subintentManifestString)
		hasher.combine(blobs)
	}
}

// MARK: - FfiConverterTypeUnvalidatedSubintentManifest
public struct FfiConverterTypeUnvalidatedSubintentManifest: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnvalidatedSubintentManifest {
		try UnvalidatedSubintentManifest(
			subintentManifestString: FfiConverterString.read(from: &buf),
			blobs: FfiConverterTypeBlobs.read(from: &buf)
		)
	}

	public static func write(_ value: UnvalidatedSubintentManifest, into buf: inout [UInt8]) {
		FfiConverterString.write(value.subintentManifestString, into: &buf)
		FfiConverterTypeBlobs.write(value.blobs, into: &buf)
	}
}

public func FfiConverterTypeUnvalidatedSubintentManifest_lift(_ buf: RustBuffer) throws -> UnvalidatedSubintentManifest {
	try FfiConverterTypeUnvalidatedSubintentManifest.lift(buf)
}

public func FfiConverterTypeUnvalidatedSubintentManifest_lower(_ value: UnvalidatedSubintentManifest) -> RustBuffer {
	FfiConverterTypeUnvalidatedSubintentManifest.lower(value)
}

// MARK: - UnvalidatedTransactionManifest
public struct UnvalidatedTransactionManifest {
	public var transactionManifestString: String
	public var blobs: Blobs

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(transactionManifestString: String, blobs: Blobs) {
		self.transactionManifestString = transactionManifestString
		self.blobs = blobs
	}
}

// MARK: Sendable
extension UnvalidatedTransactionManifest: Sendable {}

// MARK: Equatable, Hashable
extension UnvalidatedTransactionManifest: Equatable, Hashable {
	public static func == (lhs: UnvalidatedTransactionManifest, rhs: UnvalidatedTransactionManifest) -> Bool {
		if lhs.transactionManifestString != rhs.transactionManifestString {
			return false
		}
		if lhs.blobs != rhs.blobs {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(transactionManifestString)
		hasher.combine(blobs)
	}
}

// MARK: - FfiConverterTypeUnvalidatedTransactionManifest
public struct FfiConverterTypeUnvalidatedTransactionManifest: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnvalidatedTransactionManifest {
		try UnvalidatedTransactionManifest(
			transactionManifestString: FfiConverterString.read(from: &buf),
			blobs: FfiConverterTypeBlobs.read(from: &buf)
		)
	}

	public static func write(_ value: UnvalidatedTransactionManifest, into buf: inout [UInt8]) {
		FfiConverterString.write(value.transactionManifestString, into: &buf)
		FfiConverterTypeBlobs.write(value.blobs, into: &buf)
	}
}

public func FfiConverterTypeUnvalidatedTransactionManifest_lift(_ buf: RustBuffer) throws -> UnvalidatedTransactionManifest {
	try FfiConverterTypeUnvalidatedTransactionManifest.lift(buf)
}

public func FfiConverterTypeUnvalidatedTransactionManifest_lower(_ value: UnvalidatedTransactionManifest) -> RustBuffer {
	FfiConverterTypeUnvalidatedTransactionManifest.lower(value)
}

// MARK: - ValidatorAddress
/**
 * Address to a Validator that secures the network by validating transactions, users can stake to these
 * validators (Delegated Proof of Stake) by using the Dashboard and sending a TX to the Radix Wallet to sign;
 * e.g.:
 * `"validator_rdx1sd5368vqdmjk0y2w7ymdts02cz9c52858gpyny56xdvzuheepdeyy0"`
 *
 * A `ValidatorAddress` has the [Scrypto's `EntityType`][entt] `GlobalValidator`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalValidatorAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L249-L250
 */
public struct ValidatorAddress {
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension ValidatorAddress: Sendable {}

// MARK: Equatable, Hashable
extension ValidatorAddress: Equatable, Hashable {
	public static func == (lhs: ValidatorAddress, rhs: ValidatorAddress) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeValidatorAddress
public struct FfiConverterTypeValidatorAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorAddress {
		try ValidatorAddress(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: ValidatorAddress, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeValidatorAddress_lift(_ buf: RustBuffer) throws -> ValidatorAddress {
	try FfiConverterTypeValidatorAddress.lift(buf)
}

public func FfiConverterTypeValidatorAddress_lower(_ value: ValidatorAddress) -> RustBuffer {
	FfiConverterTypeValidatorAddress.lower(value)
}

// MARK: - VaultAddress
/**
 * Addresses to a specific vault, owned by a user, holding asset of one kind, either fungible or non_fungible.
 * Identities cannot own assets so they do not have vaults, but Accounts do, e.g.:
 * `"internal_vault_rdx1tz474x29nxxd4k2p2reete9xyz4apawv63dphxkr00qt23vyju49fq"`
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of VaultAddresses:
 * * InternalFungibleVault
 * * InternalNonFungibleVault
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalVaultAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L251-L255
 */
public struct VaultAddress {
	fileprivate let secretMagic: String

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	fileprivate init(secretMagic: String) {
		self.secretMagic = secretMagic
	}
}

// MARK: Sendable
extension VaultAddress: Sendable {}

// MARK: Equatable, Hashable
extension VaultAddress: Equatable, Hashable {
	public static func == (lhs: VaultAddress, rhs: VaultAddress) -> Bool {
		if lhs.secretMagic != rhs.secretMagic {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(secretMagic)
	}
}

// MARK: - FfiConverterTypeVaultAddress
public struct FfiConverterTypeVaultAddress: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VaultAddress {
		try VaultAddress(
			secretMagic: FfiConverterString.read(from: &buf)
		)
	}

	public static func write(_ value: VaultAddress, into buf: inout [UInt8]) {
		FfiConverterString.write(value.secretMagic, into: &buf)
	}
}

public func FfiConverterTypeVaultAddress_lift(_ buf: RustBuffer) throws -> VaultAddress {
	try FfiConverterTypeVaultAddress.lift(buf)
}

public func FfiConverterTypeVaultAddress_lower(_ value: VaultAddress) -> RustBuffer {
	FfiConverterTypeVaultAddress.lower(value)
}

// MARK: - WalletInteractionWalletAccount
public struct WalletInteractionWalletAccount {
	public var address: AccountAddress
	public var label: DisplayName
	public var appearanceId: AppearanceId

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(address: AccountAddress, label: DisplayName, appearanceId: AppearanceId) {
		self.address = address
		self.label = label
		self.appearanceId = appearanceId
	}
}

// MARK: Sendable
extension WalletInteractionWalletAccount: Sendable {}

// MARK: Equatable, Hashable
extension WalletInteractionWalletAccount: Equatable, Hashable {
	public static func == (lhs: WalletInteractionWalletAccount, rhs: WalletInteractionWalletAccount) -> Bool {
		if lhs.address != rhs.address {
			return false
		}
		if lhs.label != rhs.label {
			return false
		}
		if lhs.appearanceId != rhs.appearanceId {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(address)
		hasher.combine(label)
		hasher.combine(appearanceId)
	}
}

// MARK: - FfiConverterTypeWalletInteractionWalletAccount
public struct FfiConverterTypeWalletInteractionWalletAccount: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionWalletAccount {
		try WalletInteractionWalletAccount(
			address: FfiConverterTypeAccountAddress.read(from: &buf),
			label: FfiConverterTypeDisplayName.read(from: &buf),
			appearanceId: FfiConverterTypeAppearanceID.read(from: &buf)
		)
	}

	public static func write(_ value: WalletInteractionWalletAccount, into buf: inout [UInt8]) {
		FfiConverterTypeAccountAddress.write(value.address, into: &buf)
		FfiConverterTypeDisplayName.write(value.label, into: &buf)
		FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
	}
}

public func FfiConverterTypeWalletInteractionWalletAccount_lift(_ buf: RustBuffer) throws -> WalletInteractionWalletAccount {
	try FfiConverterTypeWalletInteractionWalletAccount.lift(buf)
}

public func FfiConverterTypeWalletInteractionWalletAccount_lower(_ value: WalletInteractionWalletAccount) -> RustBuffer {
	FfiConverterTypeWalletInteractionWalletAccount.lower(value)
}

// MARK: - WalletToDappInteractionAccountProof
public struct WalletToDappInteractionAccountProof {
	public var accountAddress: AccountAddress
	public var proof: WalletToDappInteractionAuthProof

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(accountAddress: AccountAddress, proof: WalletToDappInteractionAuthProof) {
		self.accountAddress = accountAddress
		self.proof = proof
	}
}

// MARK: Sendable
extension WalletToDappInteractionAccountProof: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionAccountProof: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionAccountProof, rhs: WalletToDappInteractionAccountProof) -> Bool {
		if lhs.accountAddress != rhs.accountAddress {
			return false
		}
		if lhs.proof != rhs.proof {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(accountAddress)
		hasher.combine(proof)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionAccountProof
public struct FfiConverterTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAccountProof {
		try WalletToDappInteractionAccountProof(
			accountAddress: FfiConverterTypeAccountAddress.read(from: &buf),
			proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionAccountProof, into buf: inout [UInt8]) {
		FfiConverterTypeAccountAddress.write(value.accountAddress, into: &buf)
		FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionAccountProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAccountProof {
	try FfiConverterTypeWalletToDappInteractionAccountProof.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAccountProof_lower(_ value: WalletToDappInteractionAccountProof) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionAccountProof.lower(value)
}

// MARK: - WalletToDappInteractionAccountsRequestResponseItem
public struct WalletToDappInteractionAccountsRequestResponseItem {
	public var accounts: [WalletInteractionWalletAccount]
	public var challenge: DappToWalletInteractionAuthChallengeNonce?
	public var proofs: [WalletToDappInteractionAccountProof]?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(accounts: [WalletInteractionWalletAccount], challenge: DappToWalletInteractionAuthChallengeNonce?, proofs: [WalletToDappInteractionAccountProof]?) {
		self.accounts = accounts
		self.challenge = challenge
		self.proofs = proofs
	}
}

// MARK: Sendable
extension WalletToDappInteractionAccountsRequestResponseItem: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionAccountsRequestResponseItem: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionAccountsRequestResponseItem, rhs: WalletToDappInteractionAccountsRequestResponseItem) -> Bool {
		if lhs.accounts != rhs.accounts {
			return false
		}
		if lhs.challenge != rhs.challenge {
			return false
		}
		if lhs.proofs != rhs.proofs {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(accounts)
		hasher.combine(challenge)
		hasher.combine(proofs)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem
public struct FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAccountsRequestResponseItem {
		try WalletToDappInteractionAccountsRequestResponseItem(
			accounts: FfiConverterSequenceTypeWalletInteractionWalletAccount.read(from: &buf),
			challenge: FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf),
			proofs: FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionAccountsRequestResponseItem, into buf: inout [UInt8]) {
		FfiConverterSequenceTypeWalletInteractionWalletAccount.write(value.accounts, into: &buf)
		FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
		FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof.write(value.proofs, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAccountsRequestResponseItem {
	try FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem_lower(_ value: WalletToDappInteractionAccountsRequestResponseItem) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.lower(value)
}

// MARK: - WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem
public struct WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
	public var persona: DappWalletInteractionPersona
	public var challenge: DappToWalletInteractionAuthChallengeNonce
	public var proof: WalletToDappInteractionAuthProof

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(persona: DappWalletInteractionPersona, challenge: DappToWalletInteractionAuthChallengeNonce, proof: WalletToDappInteractionAuthProof) {
		self.persona = persona
		self.challenge = challenge
		self.proof = proof
	}
}

// MARK: Sendable
extension WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem, rhs: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem) -> Bool {
		if lhs.persona != rhs.persona {
			return false
		}
		if lhs.challenge != rhs.challenge {
			return false
		}
		if lhs.proof != rhs.proof {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(persona)
		hasher.combine(challenge)
		hasher.combine(proof)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem
public struct FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
		try WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem(
			persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf),
			challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf),
			proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem, into buf: inout [UInt8]) {
		FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
		FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
		FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
	try FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem_lower(_ value: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.lower(value)
}

// MARK: - WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem
public struct WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
	public var persona: DappWalletInteractionPersona

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(persona: DappWalletInteractionPersona) {
		self.persona = persona
	}
}

// MARK: Sendable
extension WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem, rhs: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem) -> Bool {
		if lhs.persona != rhs.persona {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(persona)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem
public struct FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
		try WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem(
			persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem, into buf: inout [UInt8]) {
		FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
	try FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem_lower(_ value: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.lower(value)
}

// MARK: - WalletToDappInteractionAuthProof
public struct WalletToDappInteractionAuthProof {
	public var publicKey: PublicKey
	public var curve: Slip10Curve
	public var signature: Signature

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(publicKey: PublicKey, curve: Slip10Curve, signature: Signature) {
		self.publicKey = publicKey
		self.curve = curve
		self.signature = signature
	}
}

// MARK: Sendable
extension WalletToDappInteractionAuthProof: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionAuthProof: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionAuthProof, rhs: WalletToDappInteractionAuthProof) -> Bool {
		if lhs.publicKey != rhs.publicKey {
			return false
		}
		if lhs.curve != rhs.curve {
			return false
		}
		if lhs.signature != rhs.signature {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(publicKey)
		hasher.combine(curve)
		hasher.combine(signature)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionAuthProof
public struct FfiConverterTypeWalletToDappInteractionAuthProof: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthProof {
		try WalletToDappInteractionAuthProof(
			publicKey: FfiConverterTypePublicKey.read(from: &buf),
			curve: FfiConverterTypeSLIP10Curve.read(from: &buf),
			signature: FfiConverterTypeSignature.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionAuthProof, into buf: inout [UInt8]) {
		FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
		FfiConverterTypeSLIP10Curve.write(value.curve, into: &buf)
		FfiConverterTypeSignature.write(value.signature, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionAuthProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthProof {
	try FfiConverterTypeWalletToDappInteractionAuthProof.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthProof_lower(_ value: WalletToDappInteractionAuthProof) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionAuthProof.lower(value)
}

// MARK: - WalletToDappInteractionAuthUsePersonaRequestResponseItem
public struct WalletToDappInteractionAuthUsePersonaRequestResponseItem {
	public var persona: DappWalletInteractionPersona

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(persona: DappWalletInteractionPersona) {
		self.persona = persona
	}
}

// MARK: Sendable
extension WalletToDappInteractionAuthUsePersonaRequestResponseItem: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionAuthUsePersonaRequestResponseItem: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionAuthUsePersonaRequestResponseItem, rhs: WalletToDappInteractionAuthUsePersonaRequestResponseItem) -> Bool {
		if lhs.persona != rhs.persona {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(persona)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem
public struct FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthUsePersonaRequestResponseItem {
		try WalletToDappInteractionAuthUsePersonaRequestResponseItem(
			persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionAuthUsePersonaRequestResponseItem, into buf: inout [UInt8]) {
		FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthUsePersonaRequestResponseItem {
	try FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem_lower(_ value: WalletToDappInteractionAuthUsePersonaRequestResponseItem) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.lower(value)
}

// MARK: - WalletToDappInteractionAuthorizedRequestResponseItems
public struct WalletToDappInteractionAuthorizedRequestResponseItems {
	public var auth: WalletToDappInteractionAuthRequestResponseItem
	public var ongoingAccounts: WalletToDappInteractionAccountsRequestResponseItem?
	public var ongoingPersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?
	public var oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?
	public var oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?
	public var proofOfOwnership: WalletToDappInteractionProofOfOwnershipRequestResponseItem?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(auth: WalletToDappInteractionAuthRequestResponseItem, ongoingAccounts: WalletToDappInteractionAccountsRequestResponseItem?, ongoingPersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?, oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?, oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?, proofOfOwnership: WalletToDappInteractionProofOfOwnershipRequestResponseItem?) {
		self.auth = auth
		self.ongoingAccounts = ongoingAccounts
		self.ongoingPersonaData = ongoingPersonaData
		self.oneTimeAccounts = oneTimeAccounts
		self.oneTimePersonaData = oneTimePersonaData
		self.proofOfOwnership = proofOfOwnership
	}
}

// MARK: Sendable
extension WalletToDappInteractionAuthorizedRequestResponseItems: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionAuthorizedRequestResponseItems: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionAuthorizedRequestResponseItems, rhs: WalletToDappInteractionAuthorizedRequestResponseItems) -> Bool {
		if lhs.auth != rhs.auth {
			return false
		}
		if lhs.ongoingAccounts != rhs.ongoingAccounts {
			return false
		}
		if lhs.ongoingPersonaData != rhs.ongoingPersonaData {
			return false
		}
		if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
			return false
		}
		if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
			return false
		}
		if lhs.proofOfOwnership != rhs.proofOfOwnership {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(auth)
		hasher.combine(ongoingAccounts)
		hasher.combine(ongoingPersonaData)
		hasher.combine(oneTimeAccounts)
		hasher.combine(oneTimePersonaData)
		hasher.combine(proofOfOwnership)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems
public struct FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthorizedRequestResponseItems {
		try WalletToDappInteractionAuthorizedRequestResponseItems(
			auth: FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.read(from: &buf),
			ongoingAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf),
			ongoingPersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf),
			oneTimeAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf),
			oneTimePersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf),
			proofOfOwnership: FfiConverterOptionTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionAuthorizedRequestResponseItems, into buf: inout [UInt8]) {
		FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.write(value.auth, into: &buf)
		FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.ongoingAccounts, into: &buf)
		FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.ongoingPersonaData, into: &buf)
		FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.oneTimeAccounts, into: &buf)
		FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.oneTimePersonaData, into: &buf)
		FfiConverterOptionTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.write(value.proofOfOwnership, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthorizedRequestResponseItems {
	try FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems_lower(_ value: WalletToDappInteractionAuthorizedRequestResponseItems) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.lower(value)
}

// MARK: - WalletToDappInteractionFailureResponse
public struct WalletToDappInteractionFailureResponse {
	public var interactionId: WalletInteractionId
	public var error: DappWalletInteractionErrorType
	public var message: String?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(interactionId: WalletInteractionId, error: DappWalletInteractionErrorType, message: String?) {
		self.interactionId = interactionId
		self.error = error
		self.message = message
	}
}

// MARK: Sendable
extension WalletToDappInteractionFailureResponse: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionFailureResponse: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionFailureResponse, rhs: WalletToDappInteractionFailureResponse) -> Bool {
		if lhs.interactionId != rhs.interactionId {
			return false
		}
		if lhs.error != rhs.error {
			return false
		}
		if lhs.message != rhs.message {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(interactionId)
		hasher.combine(error)
		hasher.combine(message)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionFailureResponse
public struct FfiConverterTypeWalletToDappInteractionFailureResponse: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionFailureResponse {
		try WalletToDappInteractionFailureResponse(
			interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
			error: FfiConverterTypeDappWalletInteractionErrorType.read(from: &buf),
			message: FfiConverterOptionString.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionFailureResponse, into buf: inout [UInt8]) {
		FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
		FfiConverterTypeDappWalletInteractionErrorType.write(value.error, into: &buf)
		FfiConverterOptionString.write(value.message, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionFailureResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionFailureResponse {
	try FfiConverterTypeWalletToDappInteractionFailureResponse.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionFailureResponse_lower(_ value: WalletToDappInteractionFailureResponse) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionFailureResponse.lower(value)
}

// MARK: - WalletToDappInteractionPersonaDataRequestResponseItem
public struct WalletToDappInteractionPersonaDataRequestResponseItem {
	public var name: PersonaDataEntryName?
	public var emailAddresses: [EmailAddress]?
	public var phoneNumbers: [PersonaDataEntryPhoneNumber]?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(name: PersonaDataEntryName?, emailAddresses: [EmailAddress]?, phoneNumbers: [PersonaDataEntryPhoneNumber]?) {
		self.name = name
		self.emailAddresses = emailAddresses
		self.phoneNumbers = phoneNumbers
	}
}

// MARK: Sendable
extension WalletToDappInteractionPersonaDataRequestResponseItem: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionPersonaDataRequestResponseItem: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionPersonaDataRequestResponseItem, rhs: WalletToDappInteractionPersonaDataRequestResponseItem) -> Bool {
		if lhs.name != rhs.name {
			return false
		}
		if lhs.emailAddresses != rhs.emailAddresses {
			return false
		}
		if lhs.phoneNumbers != rhs.phoneNumbers {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(name)
		hasher.combine(emailAddresses)
		hasher.combine(phoneNumbers)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem
public struct FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionPersonaDataRequestResponseItem {
		try WalletToDappInteractionPersonaDataRequestResponseItem(
			name: FfiConverterOptionTypePersonaDataEntryName.read(from: &buf),
			emailAddresses: FfiConverterOptionSequenceTypeEmailAddress.read(from: &buf),
			phoneNumbers: FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionPersonaDataRequestResponseItem, into buf: inout [UInt8]) {
		FfiConverterOptionTypePersonaDataEntryName.write(value.name, into: &buf)
		FfiConverterOptionSequenceTypeEmailAddress.write(value.emailAddresses, into: &buf)
		FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber.write(value.phoneNumbers, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionPersonaDataRequestResponseItem {
	try FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem_lower(_ value: WalletToDappInteractionPersonaDataRequestResponseItem) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.lower(value)
}

// MARK: - WalletToDappInteractionPersonaProof
public struct WalletToDappInteractionPersonaProof {
	public var identityAddress: IdentityAddress
	public var proof: WalletToDappInteractionAuthProof

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(identityAddress: IdentityAddress, proof: WalletToDappInteractionAuthProof) {
		self.identityAddress = identityAddress
		self.proof = proof
	}
}

// MARK: Sendable
extension WalletToDappInteractionPersonaProof: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionPersonaProof: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionPersonaProof, rhs: WalletToDappInteractionPersonaProof) -> Bool {
		if lhs.identityAddress != rhs.identityAddress {
			return false
		}
		if lhs.proof != rhs.proof {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(identityAddress)
		hasher.combine(proof)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionPersonaProof
public struct FfiConverterTypeWalletToDappInteractionPersonaProof: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionPersonaProof {
		try WalletToDappInteractionPersonaProof(
			identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
			proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionPersonaProof, into buf: inout [UInt8]) {
		FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
		FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionPersonaProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionPersonaProof {
	try FfiConverterTypeWalletToDappInteractionPersonaProof.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionPersonaProof_lower(_ value: WalletToDappInteractionPersonaProof) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionPersonaProof.lower(value)
}

// MARK: - WalletToDappInteractionPreAuthorizationResponseItems
public struct WalletToDappInteractionPreAuthorizationResponseItems {
	public var response: WalletToDappInteractionSubintentResponseItem

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(response: WalletToDappInteractionSubintentResponseItem) {
		self.response = response
	}
}

// MARK: Sendable
extension WalletToDappInteractionPreAuthorizationResponseItems: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionPreAuthorizationResponseItems: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionPreAuthorizationResponseItems, rhs: WalletToDappInteractionPreAuthorizationResponseItems) -> Bool {
		if lhs.response != rhs.response {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(response)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems
public struct FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionPreAuthorizationResponseItems {
		try WalletToDappInteractionPreAuthorizationResponseItems(
			response: FfiConverterTypeWalletToDappInteractionSubintentResponseItem.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionPreAuthorizationResponseItems, into buf: inout [UInt8]) {
		FfiConverterTypeWalletToDappInteractionSubintentResponseItem.write(value.response, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionPreAuthorizationResponseItems {
	try FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems_lower(_ value: WalletToDappInteractionPreAuthorizationResponseItems) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.lower(value)
}

// MARK: - WalletToDappInteractionProofOfOwnershipRequestResponseItem
/**
 * A response with the list of proofs of ownership for `Accounts`/`Personas`
 * and the challenge that was signed.
 */
public struct WalletToDappInteractionProofOfOwnershipRequestResponseItem {
	public var challenge: DappToWalletInteractionAuthChallengeNonce
	public var proofs: [WalletToDappInteractionProofOfOwnership]

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(challenge: DappToWalletInteractionAuthChallengeNonce, proofs: [WalletToDappInteractionProofOfOwnership]) {
		self.challenge = challenge
		self.proofs = proofs
	}
}

// MARK: Sendable
extension WalletToDappInteractionProofOfOwnershipRequestResponseItem: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionProofOfOwnershipRequestResponseItem: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionProofOfOwnershipRequestResponseItem, rhs: WalletToDappInteractionProofOfOwnershipRequestResponseItem) -> Bool {
		if lhs.challenge != rhs.challenge {
			return false
		}
		if lhs.proofs != rhs.proofs {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(challenge)
		hasher.combine(proofs)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem
public struct FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionProofOfOwnershipRequestResponseItem {
		try WalletToDappInteractionProofOfOwnershipRequestResponseItem(
			challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf),
			proofs: FfiConverterSequenceTypeWalletToDappInteractionProofOfOwnership.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionProofOfOwnershipRequestResponseItem, into buf: inout [UInt8]) {
		FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
		FfiConverterSequenceTypeWalletToDappInteractionProofOfOwnership.write(value.proofs, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionProofOfOwnershipRequestResponseItem {
	try FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem_lower(_ value: WalletToDappInteractionProofOfOwnershipRequestResponseItem) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.lower(value)
}

// MARK: - WalletToDappInteractionSendTransactionResponseItem
public struct WalletToDappInteractionSendTransactionResponseItem {
	public var transactionIntentHash: TransactionIntentHash

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(transactionIntentHash: TransactionIntentHash) {
		self.transactionIntentHash = transactionIntentHash
	}
}

// MARK: Sendable
extension WalletToDappInteractionSendTransactionResponseItem: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionSendTransactionResponseItem: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionSendTransactionResponseItem, rhs: WalletToDappInteractionSendTransactionResponseItem) -> Bool {
		if lhs.transactionIntentHash != rhs.transactionIntentHash {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(transactionIntentHash)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem
public struct FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSendTransactionResponseItem {
		try WalletToDappInteractionSendTransactionResponseItem(
			transactionIntentHash: FfiConverterTypeTransactionIntentHash.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionSendTransactionResponseItem, into buf: inout [UInt8]) {
		FfiConverterTypeTransactionIntentHash.write(value.transactionIntentHash, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSendTransactionResponseItem {
	try FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem_lower(_ value: WalletToDappInteractionSendTransactionResponseItem) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.lower(value)
}

// MARK: - WalletToDappInteractionSubintentResponseItem
public struct WalletToDappInteractionSubintentResponseItem {
	/**
	 * A signed subintent
	 */
	public var signedSubintent: SignedSubintent
	/**
	 * The timestamp at which the subintent expires
	 */
	public var expirationTimestamp: Instant

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(
		/**
		 * A signed subintent
		 */ signedSubintent: SignedSubintent,
		/**
			* The timestamp at which the subintent expires
			*/ expirationTimestamp: Instant
	) {
		self.signedSubintent = signedSubintent
		self.expirationTimestamp = expirationTimestamp
	}
}

// MARK: Sendable
extension WalletToDappInteractionSubintentResponseItem: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionSubintentResponseItem: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionSubintentResponseItem, rhs: WalletToDappInteractionSubintentResponseItem) -> Bool {
		if lhs.signedSubintent != rhs.signedSubintent {
			return false
		}
		if lhs.expirationTimestamp != rhs.expirationTimestamp {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(signedSubintent)
		hasher.combine(expirationTimestamp)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionSubintentResponseItem
public struct FfiConverterTypeWalletToDappInteractionSubintentResponseItem: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSubintentResponseItem {
		try WalletToDappInteractionSubintentResponseItem(
			signedSubintent: FfiConverterTypeSignedSubintent.read(from: &buf),
			expirationTimestamp: FfiConverterTypeInstant.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionSubintentResponseItem, into buf: inout [UInt8]) {
		FfiConverterTypeSignedSubintent.write(value.signedSubintent, into: &buf)
		FfiConverterTypeInstant.write(value.expirationTimestamp, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionSubintentResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSubintentResponseItem {
	try FfiConverterTypeWalletToDappInteractionSubintentResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionSubintentResponseItem_lower(_ value: WalletToDappInteractionSubintentResponseItem) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionSubintentResponseItem.lower(value)
}

// MARK: - WalletToDappInteractionSuccessResponse
public struct WalletToDappInteractionSuccessResponse {
	public var interactionId: WalletInteractionId
	public var items: WalletToDappInteractionResponseItems

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(interactionId: WalletInteractionId, items: WalletToDappInteractionResponseItems) {
		self.interactionId = interactionId
		self.items = items
	}
}

// MARK: Sendable
extension WalletToDappInteractionSuccessResponse: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionSuccessResponse: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionSuccessResponse, rhs: WalletToDappInteractionSuccessResponse) -> Bool {
		if lhs.interactionId != rhs.interactionId {
			return false
		}
		if lhs.items != rhs.items {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(interactionId)
		hasher.combine(items)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionSuccessResponse
public struct FfiConverterTypeWalletToDappInteractionSuccessResponse: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSuccessResponse {
		try WalletToDappInteractionSuccessResponse(
			interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
			items: FfiConverterTypeWalletToDappInteractionResponseItems.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionSuccessResponse, into buf: inout [UInt8]) {
		FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
		FfiConverterTypeWalletToDappInteractionResponseItems.write(value.items, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionSuccessResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSuccessResponse {
	try FfiConverterTypeWalletToDappInteractionSuccessResponse.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionSuccessResponse_lower(_ value: WalletToDappInteractionSuccessResponse) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionSuccessResponse.lower(value)
}

// MARK: - WalletToDappInteractionTransactionResponseItems
public struct WalletToDappInteractionTransactionResponseItems {
	public var send: WalletToDappInteractionSendTransactionResponseItem

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(send: WalletToDappInteractionSendTransactionResponseItem) {
		self.send = send
	}
}

// MARK: Sendable
extension WalletToDappInteractionTransactionResponseItems: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionTransactionResponseItems: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionTransactionResponseItems, rhs: WalletToDappInteractionTransactionResponseItems) -> Bool {
		if lhs.send != rhs.send {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(send)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionTransactionResponseItems
public struct FfiConverterTypeWalletToDappInteractionTransactionResponseItems: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionTransactionResponseItems {
		try WalletToDappInteractionTransactionResponseItems(
			send: FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionTransactionResponseItems, into buf: inout [UInt8]) {
		FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.write(value.send, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionTransactionResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionTransactionResponseItems {
	try FfiConverterTypeWalletToDappInteractionTransactionResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionTransactionResponseItems_lower(_ value: WalletToDappInteractionTransactionResponseItems) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionTransactionResponseItems.lower(value)
}

// MARK: - WalletToDappInteractionUnauthorizedRequestResponseItems
public struct WalletToDappInteractionUnauthorizedRequestResponseItems {
	public var oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?
	public var oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?

	// Default memberwise initializers are never public by default, so we
	// declare one manually.
	public init(oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?, oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?) {
		self.oneTimeAccounts = oneTimeAccounts
		self.oneTimePersonaData = oneTimePersonaData
	}
}

// MARK: Sendable
extension WalletToDappInteractionUnauthorizedRequestResponseItems: Sendable {}

// MARK: Equatable, Hashable
extension WalletToDappInteractionUnauthorizedRequestResponseItems: Equatable, Hashable {
	public static func == (lhs: WalletToDappInteractionUnauthorizedRequestResponseItems, rhs: WalletToDappInteractionUnauthorizedRequestResponseItems) -> Bool {
		if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
			return false
		}
		if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
			return false
		}
		return true
	}

	public func hash(into hasher: inout Hasher) {
		hasher.combine(oneTimeAccounts)
		hasher.combine(oneTimePersonaData)
	}
}

// MARK: - FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems
public struct FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems: FfiConverterRustBuffer {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionUnauthorizedRequestResponseItems {
		try WalletToDappInteractionUnauthorizedRequestResponseItems(
			oneTimeAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf),
			oneTimePersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf)
		)
	}

	public static func write(_ value: WalletToDappInteractionUnauthorizedRequestResponseItems, into buf: inout [UInt8]) {
		FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.oneTimeAccounts, into: &buf)
		FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.oneTimePersonaData, into: &buf)
	}
}

public func FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionUnauthorizedRequestResponseItems {
	try FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems_lower(_ value: WalletToDappInteractionUnauthorizedRequestResponseItems) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.lower(value)
}

// MARK: - AccountLockerClaimableResource
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A claimable resource in an account locker.
 */

public enum AccountLockerClaimableResource {
	/**
	 * A fungible resource with a specific claimable amount
	 */
	case fungible(resourceAddress: ResourceAddress, amount: Decimal192)
	/**
	 * A non_fungible resource with the total number of items that can be claimed
	 */
	case nonFungible(resourceAddress: ResourceAddress, numberOfItems: UInt64)
}

// MARK: - FfiConverterTypeAccountLockerClaimableResource
public struct FfiConverterTypeAccountLockerClaimableResource: FfiConverterRustBuffer {
	typealias SwiftType = AccountLockerClaimableResource

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountLockerClaimableResource {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .fungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), amount: FfiConverterTypeDecimal192.read(from: &buf))

		case 2: return try .nonFungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), numberOfItems: FfiConverterUInt64.read(from: &buf))

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: AccountLockerClaimableResource, into buf: inout [UInt8]) {
		switch value {
		case let .fungible(resourceAddress, amount):
			writeInt(&buf, Int32(1))
			FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
			FfiConverterTypeDecimal192.write(amount, into: &buf)

		case let .nonFungible(resourceAddress, numberOfItems):
			writeInt(&buf, Int32(2))
			FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
			FfiConverterUInt64.write(numberOfItems, into: &buf)
		}
	}
}

public func FfiConverterTypeAccountLockerClaimableResource_lift(_ buf: RustBuffer) throws -> AccountLockerClaimableResource {
	try FfiConverterTypeAccountLockerClaimableResource.lift(buf)
}

public func FfiConverterTypeAccountLockerClaimableResource_lower(_ value: AccountLockerClaimableResource) -> RustBuffer {
	FfiConverterTypeAccountLockerClaimableResource.lower(value)
}

// MARK: - AccountLockerClaimableResource + Sendable
extension AccountLockerClaimableResource: Sendable {}

// MARK: - AccountLockerClaimableResource + Equatable, Hashable
extension AccountLockerClaimableResource: Equatable, Hashable {}

// MARK: - AccountOrAddressOf
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AccountOrAddressOf {
	case profileAccount(value: Account
	)
	case addressOfExternalAccount(value: AccountAddress
	)
}

// MARK: - FfiConverterTypeAccountOrAddressOf
public struct FfiConverterTypeAccountOrAddressOf: FfiConverterRustBuffer {
	typealias SwiftType = AccountOrAddressOf

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountOrAddressOf {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .profileAccount(value: FfiConverterTypeAccount.read(from: &buf)
			)

		case 2: return try .addressOfExternalAccount(value: FfiConverterTypeAccountAddress.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: AccountOrAddressOf, into buf: inout [UInt8]) {
		switch value {
		case let .profileAccount(value):
			writeInt(&buf, Int32(1))
			FfiConverterTypeAccount.write(value, into: &buf)

		case let .addressOfExternalAccount(value):
			writeInt(&buf, Int32(2))
			FfiConverterTypeAccountAddress.write(value, into: &buf)
		}
	}
}

public func FfiConverterTypeAccountOrAddressOf_lift(_ buf: RustBuffer) throws -> AccountOrAddressOf {
	try FfiConverterTypeAccountOrAddressOf.lift(buf)
}

public func FfiConverterTypeAccountOrAddressOf_lower(_ value: AccountOrAddressOf) -> RustBuffer {
	FfiConverterTypeAccountOrAddressOf.lower(value)
}

// MARK: - AccountOrAddressOf + Sendable
extension AccountOrAddressOf: Sendable {}

// MARK: - AccountOrAddressOf + Equatable, Hashable
extension AccountOrAddressOf: Equatable, Hashable {}

// MARK: - AccountOrPersona
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either an `Account` or a `Persona`.
 */

public enum AccountOrPersona {
	/**
	 * An `Account`
	 *
	 * Note:
	 * This case/variant can not be named `account`/ `Account` due
	 * to Kotlin UniFFI limitation.
	 */
	case accountEntity(Account
	)
	/**
	 * A `Persona`
	 *
	 * Note:
	 * This is named `personaEntity` / `PersonaEntity` to match
	 * `accountEntity` / `AccountEntity` which can not be named
	 * `account`/ `Account` due to Kotlin UniFFI limitation.
	 */
	case personaEntity(Persona
	)
}

// MARK: - FfiConverterTypeAccountOrPersona
public struct FfiConverterTypeAccountOrPersona: FfiConverterRustBuffer {
	typealias SwiftType = AccountOrPersona

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountOrPersona {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .accountEntity(FfiConverterTypeAccount.read(from: &buf)
			)

		case 2: return try .personaEntity(FfiConverterTypePersona.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: AccountOrPersona, into buf: inout [UInt8]) {
		switch value {
		case let .accountEntity(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeAccount.write(v1, into: &buf)

		case let .personaEntity(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypePersona.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeAccountOrPersona_lift(_ buf: RustBuffer) throws -> AccountOrPersona {
	try FfiConverterTypeAccountOrPersona.lift(buf)
}

public func FfiConverterTypeAccountOrPersona_lower(_ value: AccountOrPersona) -> RustBuffer {
	FfiConverterTypeAccountOrPersona.lower(value)
}

// MARK: - AccountOrPersona + Sendable
extension AccountOrPersona: Sendable {}

// MARK: - AccountOrPersona + Equatable, Hashable
extension AccountOrPersona: Equatable, Hashable {}

// MARK: - AccountWithdraw
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents a withdrawal from an account, either by amount or by specific IDs.
 */

public enum AccountWithdraw {
	/**
	 * Withdraw a specific amount from the account.
	 */
	case amount(resourceAddress: ResourceAddress, amount: Decimal192)
	/**
	 * Withdraw specific IDs from the account.
	 */
	case ids(resourceAddress: ResourceAddress, ids: [NonFungibleLocalId])
}

// MARK: - FfiConverterTypeAccountWithdraw
public struct FfiConverterTypeAccountWithdraw: FfiConverterRustBuffer {
	typealias SwiftType = AccountWithdraw

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountWithdraw {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .amount(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), amount: FfiConverterTypeDecimal192.read(from: &buf))

		case 2: return try .ids(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf))

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: AccountWithdraw, into buf: inout [UInt8]) {
		switch value {
		case let .amount(resourceAddress, amount):
			writeInt(&buf, Int32(1))
			FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
			FfiConverterTypeDecimal192.write(amount, into: &buf)

		case let .ids(resourceAddress, ids):
			writeInt(&buf, Int32(2))
			FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
			FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
		}
	}
}

public func FfiConverterTypeAccountWithdraw_lift(_ buf: RustBuffer) throws -> AccountWithdraw {
	try FfiConverterTypeAccountWithdraw.lift(buf)
}

public func FfiConverterTypeAccountWithdraw_lower(_ value: AccountWithdraw) -> RustBuffer {
	FfiConverterTypeAccountWithdraw.lower(value)
}

// MARK: - AccountWithdraw + Sendable
extension AccountWithdraw: Sendable {}

// MARK: - AccountWithdraw + Equatable, Hashable
extension AccountWithdraw: Equatable, Hashable {}

// MARK: - Address
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of addresses.
 *
 * Does not include `LegacyOlympiaAccountAddress` nor `NonFungibleResourceAddress`
 */

public enum Address {
	case accessController(AccessControllerAddress
	)
	case account(AccountAddress
	)
	case component(ComponentAddress
	)
	case identity(IdentityAddress
	)
	case package(PackageAddress
	)
	case pool(PoolAddress
	)
	case resource(ResourceAddress
	)
	case validator(ValidatorAddress
	)
	case vault(VaultAddress
	)
	case locker(LockerAddress
	)
}

// MARK: - FfiConverterTypeAddress
public struct FfiConverterTypeAddress: FfiConverterRustBuffer {
	typealias SwiftType = Address

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .accessController(FfiConverterTypeAccessControllerAddress.read(from: &buf)
			)

		case 2: return try .account(FfiConverterTypeAccountAddress.read(from: &buf)
			)

		case 3: return try .component(FfiConverterTypeComponentAddress.read(from: &buf)
			)

		case 4: return try .identity(FfiConverterTypeIdentityAddress.read(from: &buf)
			)

		case 5: return try .package(FfiConverterTypePackageAddress.read(from: &buf)
			)

		case 6: return try .pool(FfiConverterTypePoolAddress.read(from: &buf)
			)

		case 7: return try .resource(FfiConverterTypeResourceAddress.read(from: &buf)
			)

		case 8: return try .validator(FfiConverterTypeValidatorAddress.read(from: &buf)
			)

		case 9: return try .vault(FfiConverterTypeVaultAddress.read(from: &buf)
			)

		case 10: return try .locker(FfiConverterTypeLockerAddress.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: Address, into buf: inout [UInt8]) {
		switch value {
		case let .accessController(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeAccessControllerAddress.write(v1, into: &buf)

		case let .account(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeAccountAddress.write(v1, into: &buf)

		case let .component(v1):
			writeInt(&buf, Int32(3))
			FfiConverterTypeComponentAddress.write(v1, into: &buf)

		case let .identity(v1):
			writeInt(&buf, Int32(4))
			FfiConverterTypeIdentityAddress.write(v1, into: &buf)

		case let .package(v1):
			writeInt(&buf, Int32(5))
			FfiConverterTypePackageAddress.write(v1, into: &buf)

		case let .pool(v1):
			writeInt(&buf, Int32(6))
			FfiConverterTypePoolAddress.write(v1, into: &buf)

		case let .resource(v1):
			writeInt(&buf, Int32(7))
			FfiConverterTypeResourceAddress.write(v1, into: &buf)

		case let .validator(v1):
			writeInt(&buf, Int32(8))
			FfiConverterTypeValidatorAddress.write(v1, into: &buf)

		case let .vault(v1):
			writeInt(&buf, Int32(9))
			FfiConverterTypeVaultAddress.write(v1, into: &buf)

		case let .locker(v1):
			writeInt(&buf, Int32(10))
			FfiConverterTypeLockerAddress.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeAddress_lift(_ buf: RustBuffer) throws -> Address {
	try FfiConverterTypeAddress.lift(buf)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> RustBuffer {
	FfiConverterTypeAddress.lower(value)
}

// MARK: - Address + Sendable
extension Address: Sendable {}

// MARK: - Address + Equatable, Hashable
extension Address: Equatable, Hashable {}

// MARK: - AddressFormat
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AddressFormat {
	case full
	case raw
	case `default`
}

// MARK: - FfiConverterTypeAddressFormat
public struct FfiConverterTypeAddressFormat: FfiConverterRustBuffer {
	typealias SwiftType = AddressFormat

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressFormat {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .full

		case 2: return .raw

		case 3: return .default

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: AddressFormat, into buf: inout [UInt8]) {
		switch value {
		case .full:
			writeInt(&buf, Int32(1))

		case .raw:
			writeInt(&buf, Int32(2))

		case .default:
			writeInt(&buf, Int32(3))
		}
	}
}

public func FfiConverterTypeAddressFormat_lift(_ buf: RustBuffer) throws -> AddressFormat {
	try FfiConverterTypeAddressFormat.lift(buf)
}

public func FfiConverterTypeAddressFormat_lower(_ value: AddressFormat) -> RustBuffer {
	FfiConverterTypeAddressFormat.lower(value)
}

// MARK: - AddressFormat + Sendable
extension AddressFormat: Sendable {}

// MARK: - AddressFormat + Equatable, Hashable
extension AddressFormat: Equatable, Hashable {}

// MARK: - AddressOfAccountOrPersona
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of addresses of either an Account or a Persona (IdentityAddress)
 */

public enum AddressOfAccountOrPersona {
	case account(AccountAddress
	)
	case identity(IdentityAddress
	)
}

// MARK: - FfiConverterTypeAddressOfAccountOrPersona
public struct FfiConverterTypeAddressOfAccountOrPersona: FfiConverterRustBuffer {
	typealias SwiftType = AddressOfAccountOrPersona

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressOfAccountOrPersona {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .account(FfiConverterTypeAccountAddress.read(from: &buf)
			)

		case 2: return try .identity(FfiConverterTypeIdentityAddress.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: AddressOfAccountOrPersona, into buf: inout [UInt8]) {
		switch value {
		case let .account(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeAccountAddress.write(v1, into: &buf)

		case let .identity(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeIdentityAddress.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeAddressOfAccountOrPersona_lift(_ buf: RustBuffer) throws -> AddressOfAccountOrPersona {
	try FfiConverterTypeAddressOfAccountOrPersona.lift(buf)
}

public func FfiConverterTypeAddressOfAccountOrPersona_lower(_ value: AddressOfAccountOrPersona) -> RustBuffer {
	FfiConverterTypeAddressOfAccountOrPersona.lower(value)
}

// MARK: - AddressOfAccountOrPersona + Sendable
extension AddressOfAccountOrPersona: Sendable {}

// MARK: - AddressOfAccountOrPersona + Equatable, Hashable
extension AddressOfAccountOrPersona: Equatable, Hashable {}

// MARK: - ArculusCardModel
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The model of a Arculus Card.
 */

public enum ArculusCardModel {
	/**
	 * Arculus card model: "Arculus Cold Storage Wallet",
	 * for more info [see][link].
	 *
	 * [link]: https://www.getarculus.com/products/arculus-cold-storage-wallet.html
	 */
	case arculusColdStorageWallet
}

// MARK: - FfiConverterTypeArculusCardModel
public struct FfiConverterTypeArculusCardModel: FfiConverterRustBuffer {
	typealias SwiftType = ArculusCardModel

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCardModel {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .arculusColdStorageWallet

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ArculusCardModel, into buf: inout [UInt8]) {
		switch value {
		case .arculusColdStorageWallet:
			writeInt(&buf, Int32(1))
		}
	}
}

public func FfiConverterTypeArculusCardModel_lift(_ buf: RustBuffer) throws -> ArculusCardModel {
	try FfiConverterTypeArculusCardModel.lift(buf)
}

public func FfiConverterTypeArculusCardModel_lower(_ value: ArculusCardModel) -> RustBuffer {
	FfiConverterTypeArculusCardModel.lower(value)
}

// MARK: - ArculusCardModel + Sendable
extension ArculusCardModel: Sendable {}

// MARK: - ArculusCardModel + Equatable, Hashable
extension ArculusCardModel: Equatable, Hashable {}

// MARK: - AuthorizedDappPreferenceDeposits
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Indicates whether the Wallet should show direct deposit claims for the given Dapp.
 */

public enum AuthorizedDappPreferenceDeposits {
	case hidden
	case visible
}

// MARK: - FfiConverterTypeAuthorizedDappPreferenceDeposits
public struct FfiConverterTypeAuthorizedDappPreferenceDeposits: FfiConverterRustBuffer {
	typealias SwiftType = AuthorizedDappPreferenceDeposits

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappPreferenceDeposits {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .hidden

		case 2: return .visible

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: AuthorizedDappPreferenceDeposits, into buf: inout [UInt8]) {
		switch value {
		case .hidden:
			writeInt(&buf, Int32(1))

		case .visible:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeAuthorizedDappPreferenceDeposits_lift(_ buf: RustBuffer) throws -> AuthorizedDappPreferenceDeposits {
	try FfiConverterTypeAuthorizedDappPreferenceDeposits.lift(buf)
}

public func FfiConverterTypeAuthorizedDappPreferenceDeposits_lower(_ value: AuthorizedDappPreferenceDeposits) -> RustBuffer {
	FfiConverterTypeAuthorizedDappPreferenceDeposits.lower(value)
}

// MARK: - AuthorizedDappPreferenceDeposits + Sendable
extension AuthorizedDappPreferenceDeposits: Sendable {}

// MARK: - AuthorizedDappPreferenceDeposits + Equatable, Hashable
extension AuthorizedDappPreferenceDeposits: Equatable, Hashable {}

// MARK: - Bip39Entropy
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * BIP39 entropy, ranging from 16-32 bytes with discrete values being multiples of in between the range.
 */

public enum Bip39Entropy {
	case entropyOf16Bytes(Entropy16Bytes
	)
	case entropyOf20Bytes(Entropy20Bytes
	)
	case entropyOf24Bytes(Entropy24Bytes
	)
	case entropyOf28Bytes(Entropy28Bytes
	)
	case entropyOf32Bytes(Entropy32Bytes
	)
}

// MARK: - FfiConverterTypeBIP39Entropy
public struct FfiConverterTypeBIP39Entropy: FfiConverterRustBuffer {
	typealias SwiftType = Bip39Entropy

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Entropy {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .entropyOf16Bytes(FfiConverterTypeEntropy16Bytes.read(from: &buf)
			)

		case 2: return try .entropyOf20Bytes(FfiConverterTypeEntropy20Bytes.read(from: &buf)
			)

		case 3: return try .entropyOf24Bytes(FfiConverterTypeEntropy24Bytes.read(from: &buf)
			)

		case 4: return try .entropyOf28Bytes(FfiConverterTypeEntropy28Bytes.read(from: &buf)
			)

		case 5: return try .entropyOf32Bytes(FfiConverterTypeEntropy32Bytes.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: Bip39Entropy, into buf: inout [UInt8]) {
		switch value {
		case let .entropyOf16Bytes(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeEntropy16Bytes.write(v1, into: &buf)

		case let .entropyOf20Bytes(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeEntropy20Bytes.write(v1, into: &buf)

		case let .entropyOf24Bytes(v1):
			writeInt(&buf, Int32(3))
			FfiConverterTypeEntropy24Bytes.write(v1, into: &buf)

		case let .entropyOf28Bytes(v1):
			writeInt(&buf, Int32(4))
			FfiConverterTypeEntropy28Bytes.write(v1, into: &buf)

		case let .entropyOf32Bytes(v1):
			writeInt(&buf, Int32(5))
			FfiConverterTypeEntropy32Bytes.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeBIP39Entropy_lift(_ buf: RustBuffer) throws -> Bip39Entropy {
	try FfiConverterTypeBIP39Entropy.lift(buf)
}

public func FfiConverterTypeBIP39Entropy_lower(_ value: Bip39Entropy) -> RustBuffer {
	FfiConverterTypeBIP39Entropy.lower(value)
}

// MARK: - Bip39Entropy + Sendable
extension Bip39Entropy: Sendable {}

// MARK: - Bip39Entropy + Equatable, Hashable
extension Bip39Entropy: Equatable, Hashable {}

// MARK: - Bip39Language
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Language to be used for the mnemonic phrase.
 *
 * The English language is always available, other languages are enabled using
 * the compilation features.
 */

public enum Bip39Language {
	/**
	 * The English language.
	 */
	case english
	/**
	 * The French language.
	 */
	case french
}

// MARK: - FfiConverterTypeBIP39Language
public struct FfiConverterTypeBIP39Language: FfiConverterRustBuffer {
	typealias SwiftType = Bip39Language

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Language {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .english

		case 2: return .french

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: Bip39Language, into buf: inout [UInt8]) {
		switch value {
		case .english:
			writeInt(&buf, Int32(1))

		case .french:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeBIP39Language_lift(_ buf: RustBuffer) throws -> Bip39Language {
	try FfiConverterTypeBIP39Language.lift(buf)
}

public func FfiConverterTypeBIP39Language_lower(_ value: Bip39Language) -> RustBuffer {
	FfiConverterTypeBIP39Language.lower(value)
}

// MARK: - Bip39Language + Sendable
extension Bip39Language: Sendable {}

// MARK: - Bip39Language + Equatable, Hashable
extension Bip39Language: Equatable, Hashable {}

// MARK: - Bip39WordCount
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
 * standard, a multiple of 3, from 12 to 24 words. All "Babylon" `DeviceFactorSource`s
 * use 24 words.
 */

public enum Bip39WordCount: UInt8 {
	/**
	 * 24 words, used by all "Babylon" `DeviceFactorSource`s
	 */
	case twentyFour = 24
	/**
	 * 21 words, potentially used by third-party Olympia wallets.
	 */
	case twentyOne = 21
	/**
	 * 18 words, potentially used by third-party Olympia wallets.
	 */
	case eighteen = 18
	/**
	 * 15 words, potentially used by third-party Olympia wallets.
	 */
	case fifteen = 15
	/**
	 * 12 words, used by Radix Olympia legacy wallet.
	 */
	case twelve = 12
}

// MARK: - FfiConverterTypeBIP39WordCount
public struct FfiConverterTypeBIP39WordCount: FfiConverterRustBuffer {
	typealias SwiftType = Bip39WordCount

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39WordCount {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .twentyFour

		case 2: return .twentyOne

		case 3: return .eighteen

		case 4: return .fifteen

		case 5: return .twelve

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: Bip39WordCount, into buf: inout [UInt8]) {
		switch value {
		case .twentyFour:
			writeInt(&buf, Int32(1))

		case .twentyOne:
			writeInt(&buf, Int32(2))

		case .eighteen:
			writeInt(&buf, Int32(3))

		case .fifteen:
			writeInt(&buf, Int32(4))

		case .twelve:
			writeInt(&buf, Int32(5))
		}
	}
}

public func FfiConverterTypeBIP39WordCount_lift(_ buf: RustBuffer) throws -> Bip39WordCount {
	try FfiConverterTypeBIP39WordCount.lift(buf)
}

public func FfiConverterTypeBIP39WordCount_lower(_ value: Bip39WordCount) -> RustBuffer {
	FfiConverterTypeBIP39WordCount.lower(value)
}

// MARK: - Bip39WordCount + Sendable
extension Bip39WordCount: Sendable {}

// MARK: - Bip39WordCount + Equatable, Hashable
extension Bip39WordCount: Equatable, Hashable {}

// MARK: - Cap26EntityKind
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Account or Identity (used by Personas) part of a CAP26 derivation
 * path.
 */

public enum Cap26EntityKind {
	/**
	 * An Account entity type
	 */
	case account
	/**
	 * An Identity entity type (used by Personas)
	 */
	case identity
}

// MARK: - FfiConverterTypeCAP26EntityKind
public struct FfiConverterTypeCAP26EntityKind: FfiConverterRustBuffer {
	typealias SwiftType = Cap26EntityKind

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26EntityKind {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .account

		case 2: return .identity

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: Cap26EntityKind, into buf: inout [UInt8]) {
		switch value {
		case .account:
			writeInt(&buf, Int32(1))

		case .identity:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeCAP26EntityKind_lift(_ buf: RustBuffer) throws -> Cap26EntityKind {
	try FfiConverterTypeCAP26EntityKind.lift(buf)
}

public func FfiConverterTypeCAP26EntityKind_lower(_ value: Cap26EntityKind) -> RustBuffer {
	FfiConverterTypeCAP26EntityKind.lower(value)
}

// MARK: - Cap26EntityKind + Sendable
extension Cap26EntityKind: Sendable {}

// MARK: - Cap26EntityKind + Equatable, Hashable
extension Cap26EntityKind: Equatable, Hashable {}

// MARK: - Cap26KeyKind
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Cap26KeyKind {
	/**
	 * For a key to be used for signing transactions.
	 * The value is the ascii sum of `"TRANSACTION_SIGNING"`
	 */
	case transactionSigning
	/**
	 * For a key to be used for signing authentication..
	 * The value is the ascii sum of `"AUTHENTICATION_SIGNING"`
	 */
	case authenticationSigning
	/**
	 * For a key to be used for encrypting messages.
	 * The value is the ascii sum of `"MESSAGE_ENCRYPTION"`
	 */
	case messageEncryption
}

// MARK: - FfiConverterTypeCAP26KeyKind
public struct FfiConverterTypeCAP26KeyKind: FfiConverterRustBuffer {
	typealias SwiftType = Cap26KeyKind

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26KeyKind {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .transactionSigning

		case 2: return .authenticationSigning

		case 3: return .messageEncryption

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: Cap26KeyKind, into buf: inout [UInt8]) {
		switch value {
		case .transactionSigning:
			writeInt(&buf, Int32(1))

		case .authenticationSigning:
			writeInt(&buf, Int32(2))

		case .messageEncryption:
			writeInt(&buf, Int32(3))
		}
	}
}

public func FfiConverterTypeCAP26KeyKind_lift(_ buf: RustBuffer) throws -> Cap26KeyKind {
	try FfiConverterTypeCAP26KeyKind.lift(buf)
}

public func FfiConverterTypeCAP26KeyKind_lower(_ value: Cap26KeyKind) -> RustBuffer {
	FfiConverterTypeCAP26KeyKind.lower(value)
}

// MARK: - Cap26KeyKind + Sendable
extension Cap26KeyKind: Sendable {}

// MARK: - Cap26KeyKind + Equatable, Hashable
extension Cap26KeyKind: Equatable, Hashable {}

// MARK: - ChangeGatewayOutcome
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ChangeGatewayOutcome {
	/**
	 * If we did in fact change the gateway, and if the gateway was unknown
	 * or known before it was added, i.e. `is_new` will be true iff the gateway
	 * was unknown before changing to it.
	 */
	case didChange(
		/**
		 * If the Gateway we just switched to already was in the `other` list of
		 * saved gateways in AppPreferences, or if it was entirely new.
		 */ isNew: Bool
	)
	/**
	 * We tried to change to the current gateway.
	 */
	case noChange
}

// MARK: - FfiConverterTypeChangeGatewayOutcome
public struct FfiConverterTypeChangeGatewayOutcome: FfiConverterRustBuffer {
	typealias SwiftType = ChangeGatewayOutcome

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChangeGatewayOutcome {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .didChange(isNew: FfiConverterBool.read(from: &buf)
			)

		case 2: return .noChange

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ChangeGatewayOutcome, into buf: inout [UInt8]) {
		switch value {
		case let .didChange(isNew):
			writeInt(&buf, Int32(1))
			FfiConverterBool.write(isNew, into: &buf)

		case .noChange:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeChangeGatewayOutcome_lift(_ buf: RustBuffer) throws -> ChangeGatewayOutcome {
	try FfiConverterTypeChangeGatewayOutcome.lift(buf)
}

public func FfiConverterTypeChangeGatewayOutcome_lower(_ value: ChangeGatewayOutcome) -> RustBuffer {
	FfiConverterTypeChangeGatewayOutcome.lower(value)
}

// MARK: - ChangeGatewayOutcome + Sendable
extension ChangeGatewayOutcome: Sendable {}

// MARK: - ChangeGatewayOutcome + Equatable, Hashable
extension ChangeGatewayOutcome: Equatable, Hashable {}

// MARK: - ChangeSource
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Created by the visitor, generally references a particular instruction,
 * or maybe an initial YIELD_TO_PARENT.
 */

public enum ChangeSource {
	case initialYieldFromParent
	case invocation(instructionIndex: UInt64
	)
	case newBucket(instructionIndex: UInt64
	)
	case assertion(instructionIndex: UInt64
	)
}

// MARK: - FfiConverterTypeChangeSource
public struct FfiConverterTypeChangeSource: FfiConverterRustBuffer {
	typealias SwiftType = ChangeSource

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChangeSource {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .initialYieldFromParent

		case 2: return try .invocation(instructionIndex: FfiConverterUInt64.read(from: &buf)
			)

		case 3: return try .newBucket(instructionIndex: FfiConverterUInt64.read(from: &buf)
			)

		case 4: return try .assertion(instructionIndex: FfiConverterUInt64.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ChangeSource, into buf: inout [UInt8]) {
		switch value {
		case .initialYieldFromParent:
			writeInt(&buf, Int32(1))

		case let .invocation(instructionIndex):
			writeInt(&buf, Int32(2))
			FfiConverterUInt64.write(instructionIndex, into: &buf)

		case let .newBucket(instructionIndex):
			writeInt(&buf, Int32(3))
			FfiConverterUInt64.write(instructionIndex, into: &buf)

		case let .assertion(instructionIndex):
			writeInt(&buf, Int32(4))
			FfiConverterUInt64.write(instructionIndex, into: &buf)
		}
	}
}

public func FfiConverterTypeChangeSource_lift(_ buf: RustBuffer) throws -> ChangeSource {
	try FfiConverterTypeChangeSource.lift(buf)
}

public func FfiConverterTypeChangeSource_lower(_ value: ChangeSource) -> RustBuffer {
	FfiConverterTypeChangeSource.lower(value)
}

// MARK: - ChangeSource + Sendable
extension ChangeSource: Sendable {}

// MARK: - ChangeSource + Equatable, Hashable
extension ChangeSource: Equatable, Hashable {}

// MARK: - CommonError
public enum CommonError {
	case Unknown
	case InvalidEd25519PrivateKeyFromBytes(badValue: BagOfBytes
	)
	case InvalidEd25519PrivateKeyFromString(badValue: String
	)
	case InvalidSecp256k1PrivateKeyFromBytes(badValue: BagOfBytes
	)
	case InvalidSecp256k1PrivateKeyFromString(badValue: String
	)
	case InvalidEd25519PublicKeyFromBytes(badValue: BagOfBytes
	)
	case InvalidEd25519PublicKeyFromString(badValue: String
	)
	case InvalidSecp256k1PublicKeyFromBytes(badValue: BagOfBytes
	)
	case InvalidSecp256k1PublicKeyFromString(badValue: String
	)
	case InvalidSecp256k1PublicKeyPointNotOnCurve
	case InvalidEd25519PublicKeyPointNotOnCurve
	case StringNotHex(badValue: String
	)
	case InvalidByteCount(expected: UInt64, found: UInt64)
	case InvalidBip32Path(badValue: String
	)
	case InvalidDepthOfBip44Path(expected: UInt64, found: UInt64)
	case InvalidBip44LikePathAccountWasNotHardened
	case InvalidBip44LikePathChangeWasUnexpectedlyHardened
	case InvalidDepthOfCap26Path(expected: UInt64, found: UInt64)
	case NotAllComponentsAreHardened
	case Bip44PurposeNotFound(badValue: UInt32
	)
	case CoinTypeNotFound(badValue: UInt32
	)
	case InvalidNetworkIdExceedsLimit(badValue: UInt32
	)
	case InvalidEntityKind(badValue: UInt32
	)
	case WrongEntityKind(expected: Cap26EntityKind, found: Cap26EntityKind)
	case InvalidKeyKind(badValue: UInt32
	)
	case UnsupportedNetworkId(badValue: UInt8
	)
	case InvalidGetIdPath(badValue: UInt32
	)
	case UnknownBip39Word
	case InvalidMnemonicPhrase
	case InvalidBip39WordCount(badValue: UInt64
	)
	case InvalidAppearanceId(badValue: UInt8
	)
	case InvalidAccountAddress(badValue: String
	)
	case UnsupportedEntityType
	case FailedToDecodeAddressFromBech32(badValue: String
	)
	case MismatchingEntityTypeWhileDecodingAddress
	case MismatchingHrpWhileDecodingAddress
	case UnknownNetworkId(badValue: UInt8
	)
	case InvalidNonFungibleGlobalId(badValue: String
	)
	case FactorSourceCryptoParametersSupportedCurvesInvalidSize
	case BadgeIsNotVirtualHierarchicalDeterministic
	case FactorSourceIdNotFromHash
	case ExpectedAccountPathButGotSomethingElse
	case WrongEntityKindOfInFactorInstancesPath
	case WrongKeyKindOfTransactionSigningFactorInstance
	case WrongKeyKindOfAuthenticationSigningFactorInstance
	case ExpectedDeviceFactorSourceGotSomethingElse
	case ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse
	case UnknownNetworkWithName(badValue: String
	)
	case UnknownNetworkForId(badValue: UInt8
	)
	case GatewaysDiscrepancyOtherShouldNotContainCurrent
	case InvalidGatewaysJsonCurrentNotFoundAmongstSaved
	case InvalidUrl(badValue: String
	)
	case AccountOnWrongNetwork(expected: NetworkId, found: NetworkId)
	case FactorSourcesMustNotBeEmpty
	case UpdateFactorSourceMutateFailed
	case CastFactorSourceWrongKind(expected: FactorSourceKind, found: FactorSourceKind)
	case InvalidLength(expected: UInt64, found: UInt64, data: BagOfBytes)
	case InvalidNonFungibleLocalIdString
	case InvalidNonFungibleLocalIdBytes
	case DecimalError
	case InvalidBip39Index(badValue: UInt16
	)
	case InvalidDisplayNameEmpty
	case SecureStorageAccessError(key: SecureStorageKey, errorKind: SecureStorageAccessErrorKind, errorMessage: String)
	case InvalidIso8601String(badValue: String
	)
	case UnknownAccount
	case SecureStorageReadError
	case UnableToLoadDeviceFactorSourceFromSecureStorage
	case SecureStorageWriteError
	case FailedToSerializeToJson
	case FailedToDeserializeJsonToValue(jsonByteCount: UInt64, typeName: String, serdeMessage: String)
	case InvalidProfileId(badValue: String
	)
	case FailedToLoadProfileHeadersList
	case ProfileDoesNotContainFactorSourceWithId(badValue: FactorSourceId
	)
	case AccountAlreadyPresent(badValue: AccountAddress
	)
	case UnableToAcquireWriteLockForProfile
	case UnableToSaveMnemonicToSecureStorage(badValue: FactorSourceIdFromHash
	)
	case UnableToLoadMnemonicFromSecureStorage(badValue: FactorSourceIdFromHash
	)
	case UnableToSaveFactorSourceToProfile(badValue: FactorSourceId
	)
	case ExpectedIdentityPathButGotSomethingElse
	case PersonaDataInvalidPhoneNumberEmpty
	case EmailAddressEmpty
	case PersonaDataInvalidNameFamilyNameEmpty
	case PersonaDataInvalidNameGivenNamesEmpty
	case InvalidUuiDv4(badValue: String
	)
	case UnrecognizedLocaleIdentifier(badValue: String
	)
	case FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(nodeIdAsHex: String, networkId: NetworkId)
	case InvalidOlympiaAddressString(badValue: String
	)
	case InvalidInstructionsString(underlying: String
	)
	case ExecutionSummaryFail(underlying: String
	)
	case FailedToDecodeEngineToolkitReceipt
	case BytesEmpty
	case TooManyBytes(max: UInt64, found: UInt64)
	case InvalidInstructionsWrongNetwork(foundInInstructions: NetworkId, specifiedToInstructionsCtor: NetworkId)
	case FailedToDecodeBytesToManifestInstructions
	case FailedToDecodeTransactionHash(badValue: String
	)
	case FailedToHashIntent
	case EncryptedMessagesAreNotYetSupported
	case FailedToBech32DecodeTransactionHashAfterHavingTestedAllNetworkId(badValue: String
	)
	case FailedToParseSignatureFromString(badValue: String
	)
	case InvalidSignaturesForIntentSomeDidNotValidateIntentHash
	case FailedToDecompileBytesIntoNotarizedTransaction
	case FailedToRecoverSecp256k1PublicKeyFromSignature
	case FungibleResourceAddressNotAcceptedInNonFungibleContext
	case DecimalOverflow(badValue: String
	)
	case InvalidAddressNotOlympiaMainnet(badValue: String
	)
	case FailedToParseSignatureFromBytes(badValue: String
	)
	case InvalidIntentFailedToEncode(underlying: String
	)
	case InvalidInstructionsFailedToDecompile(underlying: String
	)
	case InvalidTransactionMaxSborDepthExceeded(max: UInt16
	)
	case InvalidSignedIntentFailedToEncode(underlying: String
	)
	case InvalidNotarizedIntentFailedToEncode(underlying: String
	)
	case NetworkResponseBadCode(code: UInt16
	)
	case NetworkResponseEmptyBody
	case NetworkResponseJsonDeserialize(intoType: String
	)
	case NetworkRequestInvalidUrl(badValue: String
	)
	case NetworkRequestGenericFailure(underlying: String
	)
	case GatewaySubmitDuplicateTx(intentHash: String
	)
	case SupportedCurvesMustNotBeEmpty
	case ProfileNetworksMustNotBeEmpty
	case UnknownSlip10Curve(badValue: String
	)
	case AesDecryptionFailed
	case InvalidAesBytesTooShort(expectedAtLeast: UInt64, found: UInt64)
	case InvalidFactorSourceKind(badValue: String
	)
	case InvalidLedgerHardwareWalletModel(badValue: String
	)
	case RadixConnectMobileInvalidRequestUrl(badValue: String
	)
	case RadixConnectMobileInvalidOrigin(badValue: String
	)
	case RadixConnectMobileInvalidSessionId(badValue: String
	)
	case RadixMobileInvalidInteractionId(badValue: String
	)
	case NetworkDiscrepancy(expected: NetworkId, actual: NetworkId)
	case DiscrepancyAuthorizedDappReferencedPersonaWhichDoesNotExist(address: IdentityAddress
	)
	case DiscrepancyAuthorizedDappReferencedAccountWhichDoesNotExist(address: AccountAddress
	)
	case AuthorizedDappReferencesFieldIdThatDoesNotExist
	case ElementDoesNotExist(id: String
	)
	case IdentifiableItemAlreadyExist(id: String
	)
	case InvalidRadixConnectPurpose(badValue: String
	)
	case TxGuaranteeIndexOutOfBounds(index: UInt64, count: UInt64)
	case InvalidKeyAgreementPublicKeyFromHex(badValue: String
	)
	case InvalidKeyAgreementPublicKeyFromBytes(badValue: BagOfBytes
	)
	case InvalidKeyAgreementPrivateKeyFromBytes(badValue: BagOfBytes
	)
	case RadixConnectMobileSessionNotFound(sessionId: SessionId
	)
	case RadixConnectMobileDappRequestNotFound(interactionId: WalletInteractionId
	)
	case RadixConnectMobileDappCallbackPathNotFound(origin: Url
	)
	case InvalidEd25519SignatureFromString(badValue: String
	)
	case RadixConnectMobileDappPublicKeyMismatch
	case RadixConnectMobileDappIdentityMismatch
	case RadixConnectMobileDappOriginMismatch
	case RadixConnectMobileInvalidDappSignature
	case RadixConnectMobileInvalidRequestFormat
	case RadixConnectMobileFailedToCreateNewSession
	case DeferredDeepLinkInvalidValueFormat(badValue: String
	)
	case FailedUpdatingHomeCards
	case EntityNotFound
	case HomeCardsNotFound
	case FailedSavingHomeCards
	case UnableToLoadProfileFromSecureStorage(profileId: ProfileId
	)
	case UnableToSaveHostIdToSecureStorage
	case UnableToAcquireReadLockForProfile
	case UnsafeStorageReadError
	case UnsafeStorageWriteError
	case FailedToCreateFilePathFromString(badValue: String
	)
	case ExpectedNonEmptyCollection
	case UnableToAddAllEntitiesDuplicatesFound
	case ProfileUsedOnOtherDevice(otherDeviceId: DeviceId, thisDeviceId: DeviceId)
	case InvalidDeviceId(badValue: String
	)
	case TriedToUpdateProfileWithOneWithDifferentId
	case InvalidPath(badValue: String
	)
	case FailedToSaveFile(path: String
	)
	case FailedToLoadFile(path: String
	)
	case FailedToDeleteFile(path: String
	)
	case NotPermissionToAccessFile(path: String
	)
	case InvalidArculusCardModel(badValue: String
	)
	case ExpectedArculusCardFactorSourceGotSomethingElse
	case FailedToDeriveKeyAfterMaxAttempts
	case FailedToDecryptSealedMnemonic
	case AnswersToSecurityQuestionsCannotBeEmpty
	case IntegrityViolationMutationOfFactorSourceIsNotAllowedToMutateItsId
	case InvalidSecurityStructureId(badValue: String
	)
	case StructureReferencesUnknownFactorSource(badValue: String
	)
	case InvalidQuestionsAndAnswersCount(expected: UInt16, found: UInt16)
	case ProfileStateNotLoaded(currentState: String
	)
	case FailedToCreateAddressFromGlobalAddressAndNetworkId(globalAddressAsHex: String, networkId: NetworkId)
	case EntitiesNotDerivedByFactorSource
	case NoNetworkInProfile(networkId: NetworkId
	)
	case FactorSourcesOfKindEmptyFactors
	case ExpectedPassphraseFactorSourceGotSomethingElse
	case UnknownPersona
	case InvalidSecurityStructureThresholdExceedsFactors(threshold: UInt8, factors: UInt8)
	case InvalidSecurityStructureFactorInBothThresholdAndOverride
	case OneOfReceivingAccountsDoesNotAllowDeposits
	case FailedTransactionPreview(errorMessage: String
	)
	case FailedToExtractTransactionReceiptBytes
	case ReservedInstructionsNotAllowedInManifest(reservedInstructions: String
	)
	case FailedToDecompileBytesIntoTransactionIntent
	case InvalidManifestFailedToDecompile(underlying: String
	)
	case InvalidSignedPartialTransactionFailedToCompile
	case InvalidSignedPartialTransactionFailedToDecompile
	case InvalidSignedPartialTransactionFailedToEncode(underlying: String
	)
	case FailedToGenerateManifestSummary(underlying: String
	)
	case IndexSecurifiedExpectedUnsecurified
	case IndexUnsecurifiedExpectedSecurified
	case IndexInGlobalKeySpaceIsLowerThanOffset
	case IndexOverflow
	case CannotAddMoreToIndexSinceItWouldChangeKeySpace
	case IndexNotHardened(badValue: UInt32
	)
	case FailedToDecompileBytesIntoSubintent
	case SubintentExpired
	case FreeToUse
	case MaxTransfersPerTransactionReached(amount: UInt64
	)
	case ReservedManifestClass(class: DetailedManifestClassKind
	)
	case FactorInstancesProviderDidNotDeriveEnoughFactors
	case CacheAlreadyContainsFactorInstance(derivationPath: String
	)
	case ExpectedPersonaButGotAccount(address: String
	)
	case AccountNotSecurified(address: String
	)
	case PersonaNotSecurified(address: String
	)
	case EntityOnWrongNetwork(entityKind: String, wrongNetwork: NetworkId, expectedNetwork: NetworkId)
	case SecurityStateNotSecurified
	case SecurityStateSecurifiedButExpectedUnsecurified
	case UnableToAddAllPersonasDuplicatesFound
	case MissingFactorMappingInstancesIntoRole
	case FactorSourceDiscrepancy
	case ExpectedAccountButGotPersona(address: String
	)
	case InvalidFactorSourceIdFromHashStringWrongComponentCount(expected: UInt64, found: UInt64)
	case FileAlreadyExists(path: String
	)
	case FailedToCanonicalize(path: String
	)
	case FactorInstancesDiscrepancy(addressOfEntity1: String, addressOfEntity2: String, factorSourceId: String)
	case UnableToAddAllAccountsDuplicatesFound
	case InvalidIndexAgnosticPathWrongLength
	case InvalidIndexAgnosticPathDoesNotEndWithSuffix
	case FailedToEncodeTransactionPreviewV2(underlying: String
	)
}

// MARK: - FfiConverterTypeCommonError
public struct FfiConverterTypeCommonError: FfiConverterRustBuffer {
	typealias SwiftType = CommonError

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CommonError {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .Unknown
		case 2: return try .InvalidEd25519PrivateKeyFromBytes(
				badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
			)
		case 3: return try .InvalidEd25519PrivateKeyFromString(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 4: return try .InvalidSecp256k1PrivateKeyFromBytes(
				badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
			)
		case 5: return try .InvalidSecp256k1PrivateKeyFromString(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 6: return try .InvalidEd25519PublicKeyFromBytes(
				badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
			)
		case 7: return try .InvalidEd25519PublicKeyFromString(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 8: return try .InvalidSecp256k1PublicKeyFromBytes(
				badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
			)
		case 9: return try .InvalidSecp256k1PublicKeyFromString(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 10: return .InvalidSecp256k1PublicKeyPointNotOnCurve
		case 11: return .InvalidEd25519PublicKeyPointNotOnCurve
		case 12: return try .StringNotHex(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 13: return try .InvalidByteCount(
				expected: FfiConverterUInt64.read(from: &buf),
				found: FfiConverterUInt64.read(from: &buf)
			)
		case 14: return try .InvalidBip32Path(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 15: return try .InvalidDepthOfBip44Path(
				expected: FfiConverterUInt64.read(from: &buf),
				found: FfiConverterUInt64.read(from: &buf)
			)
		case 16: return .InvalidBip44LikePathAccountWasNotHardened
		case 17: return .InvalidBip44LikePathChangeWasUnexpectedlyHardened
		case 18: return try .InvalidDepthOfCap26Path(
				expected: FfiConverterUInt64.read(from: &buf),
				found: FfiConverterUInt64.read(from: &buf)
			)
		case 19: return .NotAllComponentsAreHardened
		case 20: return try .Bip44PurposeNotFound(
				badValue: FfiConverterUInt32.read(from: &buf)
			)
		case 21: return try .CoinTypeNotFound(
				badValue: FfiConverterUInt32.read(from: &buf)
			)
		case 22: return try .InvalidNetworkIdExceedsLimit(
				badValue: FfiConverterUInt32.read(from: &buf)
			)
		case 23: return try .InvalidEntityKind(
				badValue: FfiConverterUInt32.read(from: &buf)
			)
		case 24: return try .WrongEntityKind(
				expected: FfiConverterTypeCAP26EntityKind.read(from: &buf),
				found: FfiConverterTypeCAP26EntityKind.read(from: &buf)
			)
		case 25: return try .InvalidKeyKind(
				badValue: FfiConverterUInt32.read(from: &buf)
			)
		case 26: return try .UnsupportedNetworkId(
				badValue: FfiConverterUInt8.read(from: &buf)
			)
		case 27: return try .InvalidGetIdPath(
				badValue: FfiConverterUInt32.read(from: &buf)
			)
		case 28: return .UnknownBip39Word
		case 29: return .InvalidMnemonicPhrase
		case 30: return try .InvalidBip39WordCount(
				badValue: FfiConverterUInt64.read(from: &buf)
			)
		case 31: return try .InvalidAppearanceId(
				badValue: FfiConverterUInt8.read(from: &buf)
			)
		case 32: return try .InvalidAccountAddress(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 33: return .UnsupportedEntityType
		case 34: return try .FailedToDecodeAddressFromBech32(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 35: return .MismatchingEntityTypeWhileDecodingAddress
		case 36: return .MismatchingHrpWhileDecodingAddress
		case 37: return try .UnknownNetworkId(
				badValue: FfiConverterUInt8.read(from: &buf)
			)
		case 38: return try .InvalidNonFungibleGlobalId(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 39: return .FactorSourceCryptoParametersSupportedCurvesInvalidSize
		case 40: return .BadgeIsNotVirtualHierarchicalDeterministic
		case 41: return .FactorSourceIdNotFromHash
		case 42: return .ExpectedAccountPathButGotSomethingElse
		case 43: return .WrongEntityKindOfInFactorInstancesPath
		case 44: return .WrongKeyKindOfTransactionSigningFactorInstance
		case 45: return .WrongKeyKindOfAuthenticationSigningFactorInstance
		case 46: return .ExpectedDeviceFactorSourceGotSomethingElse
		case 47: return .ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse
		case 48: return try .UnknownNetworkWithName(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 49: return try .UnknownNetworkForId(
				badValue: FfiConverterUInt8.read(from: &buf)
			)
		case 50: return .GatewaysDiscrepancyOtherShouldNotContainCurrent
		case 51: return .InvalidGatewaysJsonCurrentNotFoundAmongstSaved
		case 52: return try .InvalidUrl(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 53: return try .AccountOnWrongNetwork(
				expected: FfiConverterTypeNetworkID.read(from: &buf),
				found: FfiConverterTypeNetworkID.read(from: &buf)
			)
		case 54: return .FactorSourcesMustNotBeEmpty
		case 55: return .UpdateFactorSourceMutateFailed
		case 56: return try .CastFactorSourceWrongKind(
				expected: FfiConverterTypeFactorSourceKind.read(from: &buf),
				found: FfiConverterTypeFactorSourceKind.read(from: &buf)
			)
		case 57: return try .InvalidLength(
				expected: FfiConverterUInt64.read(from: &buf),
				found: FfiConverterUInt64.read(from: &buf),
				data: FfiConverterTypeBagOfBytes.read(from: &buf)
			)
		case 58: return .InvalidNonFungibleLocalIdString
		case 59: return .InvalidNonFungibleLocalIdBytes
		case 60: return .DecimalError
		case 61: return try .InvalidBip39Index(
				badValue: FfiConverterUInt16.read(from: &buf)
			)
		case 62: return .InvalidDisplayNameEmpty
		case 63: return try .SecureStorageAccessError(
				key: FfiConverterTypeSecureStorageKey.read(from: &buf),
				errorKind: FfiConverterTypeSecureStorageAccessErrorKind.read(from: &buf),
				errorMessage: FfiConverterString.read(from: &buf)
			)
		case 64: return try .InvalidIso8601String(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 65: return .UnknownAccount
		case 66: return .SecureStorageReadError
		case 67: return .UnableToLoadDeviceFactorSourceFromSecureStorage
		case 68: return .SecureStorageWriteError
		case 69: return .FailedToSerializeToJson
		case 70: return try .FailedToDeserializeJsonToValue(
				jsonByteCount: FfiConverterUInt64.read(from: &buf),
				typeName: FfiConverterString.read(from: &buf),
				serdeMessage: FfiConverterString.read(from: &buf)
			)
		case 71: return try .InvalidProfileId(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 72: return .FailedToLoadProfileHeadersList
		case 73: return try .ProfileDoesNotContainFactorSourceWithId(
				badValue: FfiConverterTypeFactorSourceID.read(from: &buf)
			)
		case 74: return try .AccountAlreadyPresent(
				badValue: FfiConverterTypeAccountAddress.read(from: &buf)
			)
		case 75: return .UnableToAcquireWriteLockForProfile
		case 76: return try .UnableToSaveMnemonicToSecureStorage(
				badValue: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
			)
		case 77: return try .UnableToLoadMnemonicFromSecureStorage(
				badValue: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
			)
		case 78: return try .UnableToSaveFactorSourceToProfile(
				badValue: FfiConverterTypeFactorSourceID.read(from: &buf)
			)
		case 79: return .ExpectedIdentityPathButGotSomethingElse
		case 80: return .PersonaDataInvalidPhoneNumberEmpty
		case 81: return .EmailAddressEmpty
		case 82: return .PersonaDataInvalidNameFamilyNameEmpty
		case 83: return .PersonaDataInvalidNameGivenNamesEmpty
		case 84: return try .InvalidUuiDv4(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 85: return try .UnrecognizedLocaleIdentifier(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 86: return try .FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(
				nodeIdAsHex: FfiConverterString.read(from: &buf),
				networkId: FfiConverterTypeNetworkID.read(from: &buf)
			)
		case 87: return try .InvalidOlympiaAddressString(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 88: return try .InvalidInstructionsString(
				underlying: FfiConverterString.read(from: &buf)
			)
		case 89: return try .ExecutionSummaryFail(
				underlying: FfiConverterString.read(from: &buf)
			)
		case 90: return .FailedToDecodeEngineToolkitReceipt
		case 91: return .BytesEmpty
		case 92: return try .TooManyBytes(
				max: FfiConverterUInt64.read(from: &buf),
				found: FfiConverterUInt64.read(from: &buf)
			)
		case 93: return try .InvalidInstructionsWrongNetwork(
				foundInInstructions: FfiConverterTypeNetworkID.read(from: &buf),
				specifiedToInstructionsCtor: FfiConverterTypeNetworkID.read(from: &buf)
			)
		case 94: return .FailedToDecodeBytesToManifestInstructions
		case 95: return try .FailedToDecodeTransactionHash(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 96: return .FailedToHashIntent
		case 97: return .EncryptedMessagesAreNotYetSupported
		case 98: return try .FailedToBech32DecodeTransactionHashAfterHavingTestedAllNetworkId(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 99: return try .FailedToParseSignatureFromString(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 100: return .InvalidSignaturesForIntentSomeDidNotValidateIntentHash
		case 101: return .FailedToDecompileBytesIntoNotarizedTransaction
		case 102: return .FailedToRecoverSecp256k1PublicKeyFromSignature
		case 103: return .FungibleResourceAddressNotAcceptedInNonFungibleContext
		case 104: return try .DecimalOverflow(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 105: return try .InvalidAddressNotOlympiaMainnet(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 106: return try .FailedToParseSignatureFromBytes(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 107: return try .InvalidIntentFailedToEncode(
				underlying: FfiConverterString.read(from: &buf)
			)
		case 108: return try .InvalidInstructionsFailedToDecompile(
				underlying: FfiConverterString.read(from: &buf)
			)
		case 109: return try .InvalidTransactionMaxSborDepthExceeded(
				max: FfiConverterUInt16.read(from: &buf)
			)
		case 110: return try .InvalidSignedIntentFailedToEncode(
				underlying: FfiConverterString.read(from: &buf)
			)
		case 111: return try .InvalidNotarizedIntentFailedToEncode(
				underlying: FfiConverterString.read(from: &buf)
			)
		case 112: return try .NetworkResponseBadCode(
				code: FfiConverterUInt16.read(from: &buf)
			)
		case 113: return .NetworkResponseEmptyBody
		case 114: return try .NetworkResponseJsonDeserialize(
				intoType: FfiConverterString.read(from: &buf)
			)
		case 115: return try .NetworkRequestInvalidUrl(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 116: return try .NetworkRequestGenericFailure(
				underlying: FfiConverterString.read(from: &buf)
			)
		case 117: return try .GatewaySubmitDuplicateTx(
				intentHash: FfiConverterString.read(from: &buf)
			)
		case 118: return .SupportedCurvesMustNotBeEmpty
		case 119: return .ProfileNetworksMustNotBeEmpty
		case 120: return try .UnknownSlip10Curve(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 121: return .AesDecryptionFailed
		case 122: return try .InvalidAesBytesTooShort(
				expectedAtLeast: FfiConverterUInt64.read(from: &buf),
				found: FfiConverterUInt64.read(from: &buf)
			)
		case 123: return try .InvalidFactorSourceKind(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 124: return try .InvalidLedgerHardwareWalletModel(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 125: return try .RadixConnectMobileInvalidRequestUrl(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 126: return try .RadixConnectMobileInvalidOrigin(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 127: return try .RadixConnectMobileInvalidSessionId(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 128: return try .RadixMobileInvalidInteractionId(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 129: return try .NetworkDiscrepancy(
				expected: FfiConverterTypeNetworkID.read(from: &buf),
				actual: FfiConverterTypeNetworkID.read(from: &buf)
			)
		case 130: return try .DiscrepancyAuthorizedDappReferencedPersonaWhichDoesNotExist(
				address: FfiConverterTypeIdentityAddress.read(from: &buf)
			)
		case 131: return try .DiscrepancyAuthorizedDappReferencedAccountWhichDoesNotExist(
				address: FfiConverterTypeAccountAddress.read(from: &buf)
			)
		case 132: return .AuthorizedDappReferencesFieldIdThatDoesNotExist
		case 133: return try .ElementDoesNotExist(
				id: FfiConverterString.read(from: &buf)
			)
		case 134: return try .IdentifiableItemAlreadyExist(
				id: FfiConverterString.read(from: &buf)
			)
		case 135: return try .InvalidRadixConnectPurpose(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 136: return try .TxGuaranteeIndexOutOfBounds(
				index: FfiConverterUInt64.read(from: &buf),
				count: FfiConverterUInt64.read(from: &buf)
			)
		case 137: return try .InvalidKeyAgreementPublicKeyFromHex(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 138: return try .InvalidKeyAgreementPublicKeyFromBytes(
				badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
			)
		case 139: return try .InvalidKeyAgreementPrivateKeyFromBytes(
				badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
			)
		case 140: return try .RadixConnectMobileSessionNotFound(
				sessionId: FfiConverterTypeSessionID.read(from: &buf)
			)
		case 141: return try .RadixConnectMobileDappRequestNotFound(
				interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf)
			)
		case 142: return try .RadixConnectMobileDappCallbackPathNotFound(
				origin: FfiConverterTypeUrl.read(from: &buf)
			)
		case 143: return try .InvalidEd25519SignatureFromString(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 144: return .RadixConnectMobileDappPublicKeyMismatch
		case 145: return .RadixConnectMobileDappIdentityMismatch
		case 146: return .RadixConnectMobileDappOriginMismatch
		case 147: return .RadixConnectMobileInvalidDappSignature
		case 148: return .RadixConnectMobileInvalidRequestFormat
		case 149: return .RadixConnectMobileFailedToCreateNewSession
		case 150: return try .DeferredDeepLinkInvalidValueFormat(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 151: return .FailedUpdatingHomeCards
		case 152: return .EntityNotFound
		case 153: return .HomeCardsNotFound
		case 154: return .FailedSavingHomeCards
		case 155: return try .UnableToLoadProfileFromSecureStorage(
				profileId: FfiConverterTypeProfileID.read(from: &buf)
			)
		case 156: return .UnableToSaveHostIdToSecureStorage
		case 157: return .UnableToAcquireReadLockForProfile
		case 158: return .UnsafeStorageReadError
		case 159: return .UnsafeStorageWriteError
		case 160: return try .FailedToCreateFilePathFromString(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 161: return .ExpectedNonEmptyCollection
		case 162: return .UnableToAddAllEntitiesDuplicatesFound
		case 163: return try .ProfileUsedOnOtherDevice(
				otherDeviceId: FfiConverterTypeDeviceID.read(from: &buf),
				thisDeviceId: FfiConverterTypeDeviceID.read(from: &buf)
			)
		case 164: return try .InvalidDeviceId(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 165: return .TriedToUpdateProfileWithOneWithDifferentId
		case 166: return try .InvalidPath(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 167: return try .FailedToSaveFile(
				path: FfiConverterString.read(from: &buf)
			)
		case 168: return try .FailedToLoadFile(
				path: FfiConverterString.read(from: &buf)
			)
		case 169: return try .FailedToDeleteFile(
				path: FfiConverterString.read(from: &buf)
			)
		case 170: return try .NotPermissionToAccessFile(
				path: FfiConverterString.read(from: &buf)
			)
		case 171: return try .InvalidArculusCardModel(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 172: return .ExpectedArculusCardFactorSourceGotSomethingElse
		case 173: return .FailedToDeriveKeyAfterMaxAttempts
		case 174: return .FailedToDecryptSealedMnemonic
		case 175: return .AnswersToSecurityQuestionsCannotBeEmpty
		case 176: return .IntegrityViolationMutationOfFactorSourceIsNotAllowedToMutateItsId
		case 177: return try .InvalidSecurityStructureId(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 178: return try .StructureReferencesUnknownFactorSource(
				badValue: FfiConverterString.read(from: &buf)
			)
		case 179: return try .InvalidQuestionsAndAnswersCount(
				expected: FfiConverterUInt16.read(from: &buf),
				found: FfiConverterUInt16.read(from: &buf)
			)
		case 180: return try .ProfileStateNotLoaded(
				currentState: FfiConverterString.read(from: &buf)
			)
		case 181: return try .FailedToCreateAddressFromGlobalAddressAndNetworkId(
				globalAddressAsHex: FfiConverterString.read(from: &buf),
				networkId: FfiConverterTypeNetworkID.read(from: &buf)
			)
		case 182: return .EntitiesNotDerivedByFactorSource
		case 183: return try .NoNetworkInProfile(
				networkId: FfiConverterTypeNetworkID.read(from: &buf)
			)
		case 184: return .FactorSourcesOfKindEmptyFactors
		case 185: return .ExpectedPassphraseFactorSourceGotSomethingElse
		case 186: return .UnknownPersona
		case 187: return try .InvalidSecurityStructureThresholdExceedsFactors(
				threshold: FfiConverterUInt8.read(from: &buf),
				factors: FfiConverterUInt8.read(from: &buf)
			)
		case 188: return .InvalidSecurityStructureFactorInBothThresholdAndOverride
		case 189: return .OneOfReceivingAccountsDoesNotAllowDeposits
		case 190: return try .FailedTransactionPreview(
				errorMessage: FfiConverterString.read(from: &buf)
			)
		case 191: return .FailedToExtractTransactionReceiptBytes
		case 192: return try .ReservedInstructionsNotAllowedInManifest(
				reservedInstructions: FfiConverterString.read(from: &buf)
			)
		case 193: return .FailedToDecompileBytesIntoTransactionIntent
		case 194: return try .InvalidManifestFailedToDecompile(
				underlying: FfiConverterString.read(from: &buf)
			)
		case 195: return .InvalidSignedPartialTransactionFailedToCompile
		case 196: return .InvalidSignedPartialTransactionFailedToDecompile
		case 197: return try .InvalidSignedPartialTransactionFailedToEncode(
				underlying: FfiConverterString.read(from: &buf)
			)
		case 198: return try .FailedToGenerateManifestSummary(
				underlying: FfiConverterString.read(from: &buf)
			)
		case 199: return .IndexSecurifiedExpectedUnsecurified
		case 200: return .IndexUnsecurifiedExpectedSecurified
		case 201: return .IndexInGlobalKeySpaceIsLowerThanOffset
		case 202: return .IndexOverflow
		case 203: return .CannotAddMoreToIndexSinceItWouldChangeKeySpace
		case 204: return try .IndexNotHardened(
				badValue: FfiConverterUInt32.read(from: &buf)
			)
		case 205: return .FailedToDecompileBytesIntoSubintent
		case 206: return .SubintentExpired
		case 207: return .FreeToUse
		case 208: return try .MaxTransfersPerTransactionReached(
				amount: FfiConverterUInt64.read(from: &buf)
			)
		case 209: return try .ReservedManifestClass(
				class: FfiConverterTypeDetailedManifestClassKind.read(from: &buf)
			)
		case 210: return .FactorInstancesProviderDidNotDeriveEnoughFactors
		case 211: return try .CacheAlreadyContainsFactorInstance(
				derivationPath: FfiConverterString.read(from: &buf)
			)
		case 212: return try .ExpectedPersonaButGotAccount(
				address: FfiConverterString.read(from: &buf)
			)
		case 213: return try .AccountNotSecurified(
				address: FfiConverterString.read(from: &buf)
			)
		case 214: return try .PersonaNotSecurified(
				address: FfiConverterString.read(from: &buf)
			)
		case 215: return try .EntityOnWrongNetwork(
				entityKind: FfiConverterString.read(from: &buf),
				wrongNetwork: FfiConverterTypeNetworkID.read(from: &buf),
				expectedNetwork: FfiConverterTypeNetworkID.read(from: &buf)
			)
		case 216: return .SecurityStateNotSecurified
		case 217: return .SecurityStateSecurifiedButExpectedUnsecurified
		case 218: return .UnableToAddAllPersonasDuplicatesFound
		case 219: return .MissingFactorMappingInstancesIntoRole
		case 220: return .FactorSourceDiscrepancy
		case 221: return try .ExpectedAccountButGotPersona(
				address: FfiConverterString.read(from: &buf)
			)
		case 222: return try .InvalidFactorSourceIdFromHashStringWrongComponentCount(
				expected: FfiConverterUInt64.read(from: &buf),
				found: FfiConverterUInt64.read(from: &buf)
			)
		case 223: return try .FileAlreadyExists(
				path: FfiConverterString.read(from: &buf)
			)
		case 224: return try .FailedToCanonicalize(
				path: FfiConverterString.read(from: &buf)
			)
		case 225: return try .FactorInstancesDiscrepancy(
				addressOfEntity1: FfiConverterString.read(from: &buf),
				addressOfEntity2: FfiConverterString.read(from: &buf),
				factorSourceId: FfiConverterString.read(from: &buf)
			)
		case 226: return .UnableToAddAllAccountsDuplicatesFound
		case 227: return .InvalidIndexAgnosticPathWrongLength
		case 228: return .InvalidIndexAgnosticPathDoesNotEndWithSuffix
		case 229: return try .FailedToEncodeTransactionPreviewV2(
				underlying: FfiConverterString.read(from: &buf)
			)
		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: CommonError, into buf: inout [UInt8]) {
		switch value {
		case .Unknown:
			writeInt(&buf, Int32(1))

		case let .InvalidEd25519PrivateKeyFromBytes(badValue):
			writeInt(&buf, Int32(2))
			FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

		case let .InvalidEd25519PrivateKeyFromString(badValue):
			writeInt(&buf, Int32(3))
			FfiConverterString.write(badValue, into: &buf)

		case let .InvalidSecp256k1PrivateKeyFromBytes(badValue):
			writeInt(&buf, Int32(4))
			FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

		case let .InvalidSecp256k1PrivateKeyFromString(badValue):
			writeInt(&buf, Int32(5))
			FfiConverterString.write(badValue, into: &buf)

		case let .InvalidEd25519PublicKeyFromBytes(badValue):
			writeInt(&buf, Int32(6))
			FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

		case let .InvalidEd25519PublicKeyFromString(badValue):
			writeInt(&buf, Int32(7))
			FfiConverterString.write(badValue, into: &buf)

		case let .InvalidSecp256k1PublicKeyFromBytes(badValue):
			writeInt(&buf, Int32(8))
			FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

		case let .InvalidSecp256k1PublicKeyFromString(badValue):
			writeInt(&buf, Int32(9))
			FfiConverterString.write(badValue, into: &buf)

		case .InvalidSecp256k1PublicKeyPointNotOnCurve:
			writeInt(&buf, Int32(10))

		case .InvalidEd25519PublicKeyPointNotOnCurve:
			writeInt(&buf, Int32(11))

		case let .StringNotHex(badValue):
			writeInt(&buf, Int32(12))
			FfiConverterString.write(badValue, into: &buf)

		case let .InvalidByteCount(expected, found):
			writeInt(&buf, Int32(13))
			FfiConverterUInt64.write(expected, into: &buf)
			FfiConverterUInt64.write(found, into: &buf)

		case let .InvalidBip32Path(badValue):
			writeInt(&buf, Int32(14))
			FfiConverterString.write(badValue, into: &buf)

		case let .InvalidDepthOfBip44Path(expected, found):
			writeInt(&buf, Int32(15))
			FfiConverterUInt64.write(expected, into: &buf)
			FfiConverterUInt64.write(found, into: &buf)

		case .InvalidBip44LikePathAccountWasNotHardened:
			writeInt(&buf, Int32(16))

		case .InvalidBip44LikePathChangeWasUnexpectedlyHardened:
			writeInt(&buf, Int32(17))

		case let .InvalidDepthOfCap26Path(expected, found):
			writeInt(&buf, Int32(18))
			FfiConverterUInt64.write(expected, into: &buf)
			FfiConverterUInt64.write(found, into: &buf)

		case .NotAllComponentsAreHardened:
			writeInt(&buf, Int32(19))

		case let .Bip44PurposeNotFound(badValue):
			writeInt(&buf, Int32(20))
			FfiConverterUInt32.write(badValue, into: &buf)

		case let .CoinTypeNotFound(badValue):
			writeInt(&buf, Int32(21))
			FfiConverterUInt32.write(badValue, into: &buf)

		case let .InvalidNetworkIdExceedsLimit(badValue):
			writeInt(&buf, Int32(22))
			FfiConverterUInt32.write(badValue, into: &buf)

		case let .InvalidEntityKind(badValue):
			writeInt(&buf, Int32(23))
			FfiConverterUInt32.write(badValue, into: &buf)

		case let .WrongEntityKind(expected, found):
			writeInt(&buf, Int32(24))
			FfiConverterTypeCAP26EntityKind.write(expected, into: &buf)
			FfiConverterTypeCAP26EntityKind.write(found, into: &buf)

		case let .InvalidKeyKind(badValue):
			writeInt(&buf, Int32(25))
			FfiConverterUInt32.write(badValue, into: &buf)

		case let .UnsupportedNetworkId(badValue):
			writeInt(&buf, Int32(26))
			FfiConverterUInt8.write(badValue, into: &buf)

		case let .InvalidGetIdPath(badValue):
			writeInt(&buf, Int32(27))
			FfiConverterUInt32.write(badValue, into: &buf)

		case .UnknownBip39Word:
			writeInt(&buf, Int32(28))

		case .InvalidMnemonicPhrase:
			writeInt(&buf, Int32(29))

		case let .InvalidBip39WordCount(badValue):
			writeInt(&buf, Int32(30))
			FfiConverterUInt64.write(badValue, into: &buf)

		case let .InvalidAppearanceId(badValue):
			writeInt(&buf, Int32(31))
			FfiConverterUInt8.write(badValue, into: &buf)

		case let .InvalidAccountAddress(badValue):
			writeInt(&buf, Int32(32))
			FfiConverterString.write(badValue, into: &buf)

		case .UnsupportedEntityType:
			writeInt(&buf, Int32(33))

		case let .FailedToDecodeAddressFromBech32(badValue):
			writeInt(&buf, Int32(34))
			FfiConverterString.write(badValue, into: &buf)

		case .MismatchingEntityTypeWhileDecodingAddress:
			writeInt(&buf, Int32(35))

		case .MismatchingHrpWhileDecodingAddress:
			writeInt(&buf, Int32(36))

		case let .UnknownNetworkId(badValue):
			writeInt(&buf, Int32(37))
			FfiConverterUInt8.write(badValue, into: &buf)

		case let .InvalidNonFungibleGlobalId(badValue):
			writeInt(&buf, Int32(38))
			FfiConverterString.write(badValue, into: &buf)

		case .FactorSourceCryptoParametersSupportedCurvesInvalidSize:
			writeInt(&buf, Int32(39))

		case .BadgeIsNotVirtualHierarchicalDeterministic:
			writeInt(&buf, Int32(40))

		case .FactorSourceIdNotFromHash:
			writeInt(&buf, Int32(41))

		case .ExpectedAccountPathButGotSomethingElse:
			writeInt(&buf, Int32(42))

		case .WrongEntityKindOfInFactorInstancesPath:
			writeInt(&buf, Int32(43))

		case .WrongKeyKindOfTransactionSigningFactorInstance:
			writeInt(&buf, Int32(44))

		case .WrongKeyKindOfAuthenticationSigningFactorInstance:
			writeInt(&buf, Int32(45))

		case .ExpectedDeviceFactorSourceGotSomethingElse:
			writeInt(&buf, Int32(46))

		case .ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse:
			writeInt(&buf, Int32(47))

		case let .UnknownNetworkWithName(badValue):
			writeInt(&buf, Int32(48))
			FfiConverterString.write(badValue, into: &buf)

		case let .UnknownNetworkForId(badValue):
			writeInt(&buf, Int32(49))
			FfiConverterUInt8.write(badValue, into: &buf)

		case .GatewaysDiscrepancyOtherShouldNotContainCurrent:
			writeInt(&buf, Int32(50))

		case .InvalidGatewaysJsonCurrentNotFoundAmongstSaved:
			writeInt(&buf, Int32(51))

		case let .InvalidUrl(badValue):
			writeInt(&buf, Int32(52))
			FfiConverterString.write(badValue, into: &buf)

		case let .AccountOnWrongNetwork(expected, found):
			writeInt(&buf, Int32(53))
			FfiConverterTypeNetworkID.write(expected, into: &buf)
			FfiConverterTypeNetworkID.write(found, into: &buf)

		case .FactorSourcesMustNotBeEmpty:
			writeInt(&buf, Int32(54))

		case .UpdateFactorSourceMutateFailed:
			writeInt(&buf, Int32(55))

		case let .CastFactorSourceWrongKind(expected, found):
			writeInt(&buf, Int32(56))
			FfiConverterTypeFactorSourceKind.write(expected, into: &buf)
			FfiConverterTypeFactorSourceKind.write(found, into: &buf)

		case let .InvalidLength(expected, found, data):
			writeInt(&buf, Int32(57))
			FfiConverterUInt64.write(expected, into: &buf)
			FfiConverterUInt64.write(found, into: &buf)
			FfiConverterTypeBagOfBytes.write(data, into: &buf)

		case .InvalidNonFungibleLocalIdString:
			writeInt(&buf, Int32(58))

		case .InvalidNonFungibleLocalIdBytes:
			writeInt(&buf, Int32(59))

		case .DecimalError:
			writeInt(&buf, Int32(60))

		case let .InvalidBip39Index(badValue):
			writeInt(&buf, Int32(61))
			FfiConverterUInt16.write(badValue, into: &buf)

		case .InvalidDisplayNameEmpty:
			writeInt(&buf, Int32(62))

		case let .SecureStorageAccessError(key, errorKind, errorMessage):
			writeInt(&buf, Int32(63))
			FfiConverterTypeSecureStorageKey.write(key, into: &buf)
			FfiConverterTypeSecureStorageAccessErrorKind.write(errorKind, into: &buf)
			FfiConverterString.write(errorMessage, into: &buf)

		case let .InvalidIso8601String(badValue):
			writeInt(&buf, Int32(64))
			FfiConverterString.write(badValue, into: &buf)

		case .UnknownAccount:
			writeInt(&buf, Int32(65))

		case .SecureStorageReadError:
			writeInt(&buf, Int32(66))

		case .UnableToLoadDeviceFactorSourceFromSecureStorage:
			writeInt(&buf, Int32(67))

		case .SecureStorageWriteError:
			writeInt(&buf, Int32(68))

		case .FailedToSerializeToJson:
			writeInt(&buf, Int32(69))

		case let .FailedToDeserializeJsonToValue(jsonByteCount, typeName, serdeMessage):
			writeInt(&buf, Int32(70))
			FfiConverterUInt64.write(jsonByteCount, into: &buf)
			FfiConverterString.write(typeName, into: &buf)
			FfiConverterString.write(serdeMessage, into: &buf)

		case let .InvalidProfileId(badValue):
			writeInt(&buf, Int32(71))
			FfiConverterString.write(badValue, into: &buf)

		case .FailedToLoadProfileHeadersList:
			writeInt(&buf, Int32(72))

		case let .ProfileDoesNotContainFactorSourceWithId(badValue):
			writeInt(&buf, Int32(73))
			FfiConverterTypeFactorSourceID.write(badValue, into: &buf)

		case let .AccountAlreadyPresent(badValue):
			writeInt(&buf, Int32(74))
			FfiConverterTypeAccountAddress.write(badValue, into: &buf)

		case .UnableToAcquireWriteLockForProfile:
			writeInt(&buf, Int32(75))

		case let .UnableToSaveMnemonicToSecureStorage(badValue):
			writeInt(&buf, Int32(76))
			FfiConverterTypeFactorSourceIDFromHash.write(badValue, into: &buf)

		case let .UnableToLoadMnemonicFromSecureStorage(badValue):
			writeInt(&buf, Int32(77))
			FfiConverterTypeFactorSourceIDFromHash.write(badValue, into: &buf)

		case let .UnableToSaveFactorSourceToProfile(badValue):
			writeInt(&buf, Int32(78))
			FfiConverterTypeFactorSourceID.write(badValue, into: &buf)

		case .ExpectedIdentityPathButGotSomethingElse:
			writeInt(&buf, Int32(79))

		case .PersonaDataInvalidPhoneNumberEmpty:
			writeInt(&buf, Int32(80))

		case .EmailAddressEmpty:
			writeInt(&buf, Int32(81))

		case .PersonaDataInvalidNameFamilyNameEmpty:
			writeInt(&buf, Int32(82))

		case .PersonaDataInvalidNameGivenNamesEmpty:
			writeInt(&buf, Int32(83))

		case let .InvalidUuiDv4(badValue):
			writeInt(&buf, Int32(84))
			FfiConverterString.write(badValue, into: &buf)

		case let .UnrecognizedLocaleIdentifier(badValue):
			writeInt(&buf, Int32(85))
			FfiConverterString.write(badValue, into: &buf)

		case let .FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(nodeIdAsHex, networkId):
			writeInt(&buf, Int32(86))
			FfiConverterString.write(nodeIdAsHex, into: &buf)
			FfiConverterTypeNetworkID.write(networkId, into: &buf)

		case let .InvalidOlympiaAddressString(badValue):
			writeInt(&buf, Int32(87))
			FfiConverterString.write(badValue, into: &buf)

		case let .InvalidInstructionsString(underlying):
			writeInt(&buf, Int32(88))
			FfiConverterString.write(underlying, into: &buf)

		case let .ExecutionSummaryFail(underlying):
			writeInt(&buf, Int32(89))
			FfiConverterString.write(underlying, into: &buf)

		case .FailedToDecodeEngineToolkitReceipt:
			writeInt(&buf, Int32(90))

		case .BytesEmpty:
			writeInt(&buf, Int32(91))

		case let .TooManyBytes(max, found):
			writeInt(&buf, Int32(92))
			FfiConverterUInt64.write(max, into: &buf)
			FfiConverterUInt64.write(found, into: &buf)

		case let .InvalidInstructionsWrongNetwork(foundInInstructions, specifiedToInstructionsCtor):
			writeInt(&buf, Int32(93))
			FfiConverterTypeNetworkID.write(foundInInstructions, into: &buf)
			FfiConverterTypeNetworkID.write(specifiedToInstructionsCtor, into: &buf)

		case .FailedToDecodeBytesToManifestInstructions:
			writeInt(&buf, Int32(94))

		case let .FailedToDecodeTransactionHash(badValue):
			writeInt(&buf, Int32(95))
			FfiConverterString.write(badValue, into: &buf)

		case .FailedToHashIntent:
			writeInt(&buf, Int32(96))

		case .EncryptedMessagesAreNotYetSupported:
			writeInt(&buf, Int32(97))

		case let .FailedToBech32DecodeTransactionHashAfterHavingTestedAllNetworkId(badValue):
			writeInt(&buf, Int32(98))
			FfiConverterString.write(badValue, into: &buf)

		case let .FailedToParseSignatureFromString(badValue):
			writeInt(&buf, Int32(99))
			FfiConverterString.write(badValue, into: &buf)

		case .InvalidSignaturesForIntentSomeDidNotValidateIntentHash:
			writeInt(&buf, Int32(100))

		case .FailedToDecompileBytesIntoNotarizedTransaction:
			writeInt(&buf, Int32(101))

		case .FailedToRecoverSecp256k1PublicKeyFromSignature:
			writeInt(&buf, Int32(102))

		case .FungibleResourceAddressNotAcceptedInNonFungibleContext:
			writeInt(&buf, Int32(103))

		case let .DecimalOverflow(badValue):
			writeInt(&buf, Int32(104))
			FfiConverterString.write(badValue, into: &buf)

		case let .InvalidAddressNotOlympiaMainnet(badValue):
			writeInt(&buf, Int32(105))
			FfiConverterString.write(badValue, into: &buf)

		case let .FailedToParseSignatureFromBytes(badValue):
			writeInt(&buf, Int32(106))
			FfiConverterString.write(badValue, into: &buf)

		case let .InvalidIntentFailedToEncode(underlying):
			writeInt(&buf, Int32(107))
			FfiConverterString.write(underlying, into: &buf)

		case let .InvalidInstructionsFailedToDecompile(underlying):
			writeInt(&buf, Int32(108))
			FfiConverterString.write(underlying, into: &buf)

		case let .InvalidTransactionMaxSborDepthExceeded(max):
			writeInt(&buf, Int32(109))
			FfiConverterUInt16.write(max, into: &buf)

		case let .InvalidSignedIntentFailedToEncode(underlying):
			writeInt(&buf, Int32(110))
			FfiConverterString.write(underlying, into: &buf)

		case let .InvalidNotarizedIntentFailedToEncode(underlying):
			writeInt(&buf, Int32(111))
			FfiConverterString.write(underlying, into: &buf)

		case let .NetworkResponseBadCode(code):
			writeInt(&buf, Int32(112))
			FfiConverterUInt16.write(code, into: &buf)

		case .NetworkResponseEmptyBody:
			writeInt(&buf, Int32(113))

		case let .NetworkResponseJsonDeserialize(intoType):
			writeInt(&buf, Int32(114))
			FfiConverterString.write(intoType, into: &buf)

		case let .NetworkRequestInvalidUrl(badValue):
			writeInt(&buf, Int32(115))
			FfiConverterString.write(badValue, into: &buf)

		case let .NetworkRequestGenericFailure(underlying):
			writeInt(&buf, Int32(116))
			FfiConverterString.write(underlying, into: &buf)

		case let .GatewaySubmitDuplicateTx(intentHash):
			writeInt(&buf, Int32(117))
			FfiConverterString.write(intentHash, into: &buf)

		case .SupportedCurvesMustNotBeEmpty:
			writeInt(&buf, Int32(118))

		case .ProfileNetworksMustNotBeEmpty:
			writeInt(&buf, Int32(119))

		case let .UnknownSlip10Curve(badValue):
			writeInt(&buf, Int32(120))
			FfiConverterString.write(badValue, into: &buf)

		case .AesDecryptionFailed:
			writeInt(&buf, Int32(121))

		case let .InvalidAesBytesTooShort(expectedAtLeast, found):
			writeInt(&buf, Int32(122))
			FfiConverterUInt64.write(expectedAtLeast, into: &buf)
			FfiConverterUInt64.write(found, into: &buf)

		case let .InvalidFactorSourceKind(badValue):
			writeInt(&buf, Int32(123))
			FfiConverterString.write(badValue, into: &buf)

		case let .InvalidLedgerHardwareWalletModel(badValue):
			writeInt(&buf, Int32(124))
			FfiConverterString.write(badValue, into: &buf)

		case let .RadixConnectMobileInvalidRequestUrl(badValue):
			writeInt(&buf, Int32(125))
			FfiConverterString.write(badValue, into: &buf)

		case let .RadixConnectMobileInvalidOrigin(badValue):
			writeInt(&buf, Int32(126))
			FfiConverterString.write(badValue, into: &buf)

		case let .RadixConnectMobileInvalidSessionId(badValue):
			writeInt(&buf, Int32(127))
			FfiConverterString.write(badValue, into: &buf)

		case let .RadixMobileInvalidInteractionId(badValue):
			writeInt(&buf, Int32(128))
			FfiConverterString.write(badValue, into: &buf)

		case let .NetworkDiscrepancy(expected, actual):
			writeInt(&buf, Int32(129))
			FfiConverterTypeNetworkID.write(expected, into: &buf)
			FfiConverterTypeNetworkID.write(actual, into: &buf)

		case let .DiscrepancyAuthorizedDappReferencedPersonaWhichDoesNotExist(address):
			writeInt(&buf, Int32(130))
			FfiConverterTypeIdentityAddress.write(address, into: &buf)

		case let .DiscrepancyAuthorizedDappReferencedAccountWhichDoesNotExist(address):
			writeInt(&buf, Int32(131))
			FfiConverterTypeAccountAddress.write(address, into: &buf)

		case .AuthorizedDappReferencesFieldIdThatDoesNotExist:
			writeInt(&buf, Int32(132))

		case let .ElementDoesNotExist(id):
			writeInt(&buf, Int32(133))
			FfiConverterString.write(id, into: &buf)

		case let .IdentifiableItemAlreadyExist(id):
			writeInt(&buf, Int32(134))
			FfiConverterString.write(id, into: &buf)

		case let .InvalidRadixConnectPurpose(badValue):
			writeInt(&buf, Int32(135))
			FfiConverterString.write(badValue, into: &buf)

		case let .TxGuaranteeIndexOutOfBounds(index, count):
			writeInt(&buf, Int32(136))
			FfiConverterUInt64.write(index, into: &buf)
			FfiConverterUInt64.write(count, into: &buf)

		case let .InvalidKeyAgreementPublicKeyFromHex(badValue):
			writeInt(&buf, Int32(137))
			FfiConverterString.write(badValue, into: &buf)

		case let .InvalidKeyAgreementPublicKeyFromBytes(badValue):
			writeInt(&buf, Int32(138))
			FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

		case let .InvalidKeyAgreementPrivateKeyFromBytes(badValue):
			writeInt(&buf, Int32(139))
			FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

		case let .RadixConnectMobileSessionNotFound(sessionId):
			writeInt(&buf, Int32(140))
			FfiConverterTypeSessionID.write(sessionId, into: &buf)

		case let .RadixConnectMobileDappRequestNotFound(interactionId):
			writeInt(&buf, Int32(141))
			FfiConverterTypeWalletInteractionId.write(interactionId, into: &buf)

		case let .RadixConnectMobileDappCallbackPathNotFound(origin):
			writeInt(&buf, Int32(142))
			FfiConverterTypeUrl.write(origin, into: &buf)

		case let .InvalidEd25519SignatureFromString(badValue):
			writeInt(&buf, Int32(143))
			FfiConverterString.write(badValue, into: &buf)

		case .RadixConnectMobileDappPublicKeyMismatch:
			writeInt(&buf, Int32(144))

		case .RadixConnectMobileDappIdentityMismatch:
			writeInt(&buf, Int32(145))

		case .RadixConnectMobileDappOriginMismatch:
			writeInt(&buf, Int32(146))

		case .RadixConnectMobileInvalidDappSignature:
			writeInt(&buf, Int32(147))

		case .RadixConnectMobileInvalidRequestFormat:
			writeInt(&buf, Int32(148))

		case .RadixConnectMobileFailedToCreateNewSession:
			writeInt(&buf, Int32(149))

		case let .DeferredDeepLinkInvalidValueFormat(badValue):
			writeInt(&buf, Int32(150))
			FfiConverterString.write(badValue, into: &buf)

		case .FailedUpdatingHomeCards:
			writeInt(&buf, Int32(151))

		case .EntityNotFound:
			writeInt(&buf, Int32(152))

		case .HomeCardsNotFound:
			writeInt(&buf, Int32(153))

		case .FailedSavingHomeCards:
			writeInt(&buf, Int32(154))

		case let .UnableToLoadProfileFromSecureStorage(profileId):
			writeInt(&buf, Int32(155))
			FfiConverterTypeProfileID.write(profileId, into: &buf)

		case .UnableToSaveHostIdToSecureStorage:
			writeInt(&buf, Int32(156))

		case .UnableToAcquireReadLockForProfile:
			writeInt(&buf, Int32(157))

		case .UnsafeStorageReadError:
			writeInt(&buf, Int32(158))

		case .UnsafeStorageWriteError:
			writeInt(&buf, Int32(159))

		case let .FailedToCreateFilePathFromString(badValue):
			writeInt(&buf, Int32(160))
			FfiConverterString.write(badValue, into: &buf)

		case .ExpectedNonEmptyCollection:
			writeInt(&buf, Int32(161))

		case .UnableToAddAllEntitiesDuplicatesFound:
			writeInt(&buf, Int32(162))

		case let .ProfileUsedOnOtherDevice(otherDeviceId, thisDeviceId):
			writeInt(&buf, Int32(163))
			FfiConverterTypeDeviceID.write(otherDeviceId, into: &buf)
			FfiConverterTypeDeviceID.write(thisDeviceId, into: &buf)

		case let .InvalidDeviceId(badValue):
			writeInt(&buf, Int32(164))
			FfiConverterString.write(badValue, into: &buf)

		case .TriedToUpdateProfileWithOneWithDifferentId:
			writeInt(&buf, Int32(165))

		case let .InvalidPath(badValue):
			writeInt(&buf, Int32(166))
			FfiConverterString.write(badValue, into: &buf)

		case let .FailedToSaveFile(path):
			writeInt(&buf, Int32(167))
			FfiConverterString.write(path, into: &buf)

		case let .FailedToLoadFile(path):
			writeInt(&buf, Int32(168))
			FfiConverterString.write(path, into: &buf)

		case let .FailedToDeleteFile(path):
			writeInt(&buf, Int32(169))
			FfiConverterString.write(path, into: &buf)

		case let .NotPermissionToAccessFile(path):
			writeInt(&buf, Int32(170))
			FfiConverterString.write(path, into: &buf)

		case let .InvalidArculusCardModel(badValue):
			writeInt(&buf, Int32(171))
			FfiConverterString.write(badValue, into: &buf)

		case .ExpectedArculusCardFactorSourceGotSomethingElse:
			writeInt(&buf, Int32(172))

		case .FailedToDeriveKeyAfterMaxAttempts:
			writeInt(&buf, Int32(173))

		case .FailedToDecryptSealedMnemonic:
			writeInt(&buf, Int32(174))

		case .AnswersToSecurityQuestionsCannotBeEmpty:
			writeInt(&buf, Int32(175))

		case .IntegrityViolationMutationOfFactorSourceIsNotAllowedToMutateItsId:
			writeInt(&buf, Int32(176))

		case let .InvalidSecurityStructureId(badValue):
			writeInt(&buf, Int32(177))
			FfiConverterString.write(badValue, into: &buf)

		case let .StructureReferencesUnknownFactorSource(badValue):
			writeInt(&buf, Int32(178))
			FfiConverterString.write(badValue, into: &buf)

		case let .InvalidQuestionsAndAnswersCount(expected, found):
			writeInt(&buf, Int32(179))
			FfiConverterUInt16.write(expected, into: &buf)
			FfiConverterUInt16.write(found, into: &buf)

		case let .ProfileStateNotLoaded(currentState):
			writeInt(&buf, Int32(180))
			FfiConverterString.write(currentState, into: &buf)

		case let .FailedToCreateAddressFromGlobalAddressAndNetworkId(globalAddressAsHex, networkId):
			writeInt(&buf, Int32(181))
			FfiConverterString.write(globalAddressAsHex, into: &buf)
			FfiConverterTypeNetworkID.write(networkId, into: &buf)

		case .EntitiesNotDerivedByFactorSource:
			writeInt(&buf, Int32(182))

		case let .NoNetworkInProfile(networkId):
			writeInt(&buf, Int32(183))
			FfiConverterTypeNetworkID.write(networkId, into: &buf)

		case .FactorSourcesOfKindEmptyFactors:
			writeInt(&buf, Int32(184))

		case .ExpectedPassphraseFactorSourceGotSomethingElse:
			writeInt(&buf, Int32(185))

		case .UnknownPersona:
			writeInt(&buf, Int32(186))

		case let .InvalidSecurityStructureThresholdExceedsFactors(threshold, factors):
			writeInt(&buf, Int32(187))
			FfiConverterUInt8.write(threshold, into: &buf)
			FfiConverterUInt8.write(factors, into: &buf)

		case .InvalidSecurityStructureFactorInBothThresholdAndOverride:
			writeInt(&buf, Int32(188))

		case .OneOfReceivingAccountsDoesNotAllowDeposits:
			writeInt(&buf, Int32(189))

		case let .FailedTransactionPreview(errorMessage):
			writeInt(&buf, Int32(190))
			FfiConverterString.write(errorMessage, into: &buf)

		case .FailedToExtractTransactionReceiptBytes:
			writeInt(&buf, Int32(191))

		case let .ReservedInstructionsNotAllowedInManifest(reservedInstructions):
			writeInt(&buf, Int32(192))
			FfiConverterString.write(reservedInstructions, into: &buf)

		case .FailedToDecompileBytesIntoTransactionIntent:
			writeInt(&buf, Int32(193))

		case let .InvalidManifestFailedToDecompile(underlying):
			writeInt(&buf, Int32(194))
			FfiConverterString.write(underlying, into: &buf)

		case .InvalidSignedPartialTransactionFailedToCompile:
			writeInt(&buf, Int32(195))

		case .InvalidSignedPartialTransactionFailedToDecompile:
			writeInt(&buf, Int32(196))

		case let .InvalidSignedPartialTransactionFailedToEncode(underlying):
			writeInt(&buf, Int32(197))
			FfiConverterString.write(underlying, into: &buf)

		case let .FailedToGenerateManifestSummary(underlying):
			writeInt(&buf, Int32(198))
			FfiConverterString.write(underlying, into: &buf)

		case .IndexSecurifiedExpectedUnsecurified:
			writeInt(&buf, Int32(199))

		case .IndexUnsecurifiedExpectedSecurified:
			writeInt(&buf, Int32(200))

		case .IndexInGlobalKeySpaceIsLowerThanOffset:
			writeInt(&buf, Int32(201))

		case .IndexOverflow:
			writeInt(&buf, Int32(202))

		case .CannotAddMoreToIndexSinceItWouldChangeKeySpace:
			writeInt(&buf, Int32(203))

		case let .IndexNotHardened(badValue):
			writeInt(&buf, Int32(204))
			FfiConverterUInt32.write(badValue, into: &buf)

		case .FailedToDecompileBytesIntoSubintent:
			writeInt(&buf, Int32(205))

		case .SubintentExpired:
			writeInt(&buf, Int32(206))

		case .FreeToUse:
			writeInt(&buf, Int32(207))

		case let .MaxTransfersPerTransactionReached(amount):
			writeInt(&buf, Int32(208))
			FfiConverterUInt64.write(amount, into: &buf)

		case let .ReservedManifestClass(`class`):
			writeInt(&buf, Int32(209))
			FfiConverterTypeDetailedManifestClassKind.write(`class`, into: &buf)

		case .FactorInstancesProviderDidNotDeriveEnoughFactors:
			writeInt(&buf, Int32(210))

		case let .CacheAlreadyContainsFactorInstance(derivationPath):
			writeInt(&buf, Int32(211))
			FfiConverterString.write(derivationPath, into: &buf)

		case let .ExpectedPersonaButGotAccount(address):
			writeInt(&buf, Int32(212))
			FfiConverterString.write(address, into: &buf)

		case let .AccountNotSecurified(address):
			writeInt(&buf, Int32(213))
			FfiConverterString.write(address, into: &buf)

		case let .PersonaNotSecurified(address):
			writeInt(&buf, Int32(214))
			FfiConverterString.write(address, into: &buf)

		case let .EntityOnWrongNetwork(entityKind, wrongNetwork, expectedNetwork):
			writeInt(&buf, Int32(215))
			FfiConverterString.write(entityKind, into: &buf)
			FfiConverterTypeNetworkID.write(wrongNetwork, into: &buf)
			FfiConverterTypeNetworkID.write(expectedNetwork, into: &buf)

		case .SecurityStateNotSecurified:
			writeInt(&buf, Int32(216))

		case .SecurityStateSecurifiedButExpectedUnsecurified:
			writeInt(&buf, Int32(217))

		case .UnableToAddAllPersonasDuplicatesFound:
			writeInt(&buf, Int32(218))

		case .MissingFactorMappingInstancesIntoRole:
			writeInt(&buf, Int32(219))

		case .FactorSourceDiscrepancy:
			writeInt(&buf, Int32(220))

		case let .ExpectedAccountButGotPersona(address):
			writeInt(&buf, Int32(221))
			FfiConverterString.write(address, into: &buf)

		case let .InvalidFactorSourceIdFromHashStringWrongComponentCount(expected, found):
			writeInt(&buf, Int32(222))
			FfiConverterUInt64.write(expected, into: &buf)
			FfiConverterUInt64.write(found, into: &buf)

		case let .FileAlreadyExists(path):
			writeInt(&buf, Int32(223))
			FfiConverterString.write(path, into: &buf)

		case let .FailedToCanonicalize(path):
			writeInt(&buf, Int32(224))
			FfiConverterString.write(path, into: &buf)

		case let .FactorInstancesDiscrepancy(addressOfEntity1, addressOfEntity2, factorSourceId):
			writeInt(&buf, Int32(225))
			FfiConverterString.write(addressOfEntity1, into: &buf)
			FfiConverterString.write(addressOfEntity2, into: &buf)
			FfiConverterString.write(factorSourceId, into: &buf)

		case .UnableToAddAllAccountsDuplicatesFound:
			writeInt(&buf, Int32(226))

		case .InvalidIndexAgnosticPathWrongLength:
			writeInt(&buf, Int32(227))

		case .InvalidIndexAgnosticPathDoesNotEndWithSuffix:
			writeInt(&buf, Int32(228))

		case let .FailedToEncodeTransactionPreviewV2(underlying):
			writeInt(&buf, Int32(229))
			FfiConverterString.write(underlying, into: &buf)
		}
	}
}

// MARK: - CommonError + Equatable, Hashable
extension CommonError: Equatable, Hashable {}

// MARK: - CommonError + Swift.Error
extension CommonError: Swift.Error {}

// MARK: - DappToWalletInteractionAuthRequestItem
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappToWalletInteractionAuthRequestItem {
	case loginWithChallenge(DappToWalletInteractionAuthLoginWithChallengeRequestItem
	)
	case loginWithoutChallenge
	case usePersona(DappToWalletInteractionAuthUsePersonaRequestItem
	)
}

// MARK: - FfiConverterTypeDappToWalletInteractionAuthRequestItem
public struct FfiConverterTypeDappToWalletInteractionAuthRequestItem: FfiConverterRustBuffer {
	typealias SwiftType = DappToWalletInteractionAuthRequestItem

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthRequestItem {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .loginWithChallenge(FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.read(from: &buf)
			)

		case 2: return .loginWithoutChallenge

		case 3: return try .usePersona(FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DappToWalletInteractionAuthRequestItem, into buf: inout [UInt8]) {
		switch value {
		case let .loginWithChallenge(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.write(v1, into: &buf)

		case .loginWithoutChallenge:
			writeInt(&buf, Int32(2))

		case let .usePersona(v1):
			writeInt(&buf, Int32(3))
			FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeDappToWalletInteractionAuthRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthRequestItem {
	try FfiConverterTypeDappToWalletInteractionAuthRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthRequestItem_lower(_ value: DappToWalletInteractionAuthRequestItem) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionAuthRequestItem.lower(value)
}

// MARK: - DappToWalletInteractionAuthRequestItem + Sendable
extension DappToWalletInteractionAuthRequestItem: Sendable {}

// MARK: - DappToWalletInteractionAuthRequestItem + Equatable, Hashable
extension DappToWalletInteractionAuthRequestItem: Equatable, Hashable {}

// MARK: - DappToWalletInteractionItems
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappToWalletInteractionItems {
	case unauthorizedRequest(DappToWalletInteractionUnauthorizedRequestItems
	)
	case authorizedRequest(DappToWalletInteractionAuthorizedRequestItems
	)
	case transaction(DappToWalletInteractionTransactionItems
	)
	case preAuthorization(DappToWalletInteractionPreAuthorizationItems
	)
}

// MARK: - FfiConverterTypeDappToWalletInteractionItems
public struct FfiConverterTypeDappToWalletInteractionItems: FfiConverterRustBuffer {
	typealias SwiftType = DappToWalletInteractionItems

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionItems {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .unauthorizedRequest(FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.read(from: &buf)
			)

		case 2: return try .authorizedRequest(FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.read(from: &buf)
			)

		case 3: return try .transaction(FfiConverterTypeDappToWalletInteractionTransactionItems.read(from: &buf)
			)

		case 4: return try .preAuthorization(FfiConverterTypeDappToWalletInteractionPreAuthorizationItems.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DappToWalletInteractionItems, into buf: inout [UInt8]) {
		switch value {
		case let .unauthorizedRequest(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.write(v1, into: &buf)

		case let .authorizedRequest(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.write(v1, into: &buf)

		case let .transaction(v1):
			writeInt(&buf, Int32(3))
			FfiConverterTypeDappToWalletInteractionTransactionItems.write(v1, into: &buf)

		case let .preAuthorization(v1):
			writeInt(&buf, Int32(4))
			FfiConverterTypeDappToWalletInteractionPreAuthorizationItems.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeDappToWalletInteractionItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionItems {
	try FfiConverterTypeDappToWalletInteractionItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionItems_lower(_ value: DappToWalletInteractionItems) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionItems.lower(value)
}

// MARK: - DappToWalletInteractionItems + Sendable
extension DappToWalletInteractionItems: Sendable {}

// MARK: - DappToWalletInteractionItems + Equatable, Hashable
extension DappToWalletInteractionItems: Equatable, Hashable {}

// MARK: - DappToWalletInteractionSubintentExpiration
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum that represents the different ways a subintent can expire.
 */

public enum DappToWalletInteractionSubintentExpiration {
	/**
	 * The subintent expires at a specific fixed timestamp.
	 *
	 * For example, a dApp sends a subintent for `User A` to approve sending 100 XRD before 5:00 PM,
	 * and a subintent for `User B` to approve sending 2 USDT with same expiration.
	 *
	 * If both users sign their subintents before 5:00 PM, the transaction to exchange
	 * 100 XRD over 2 USDT will succeed. Otherwise, it would fail.
	 */
	case atTime(DappToWalletInteractionSubintentExpireAtTime
	)
	/**
	 * The subintent expires X seconds after its signature.
	 *
	 * For example, a dApp sends a subintent for `User A` to approve sending 100 XRD with 1 hour expiration,
	 * and a subintent for `User B` to approve sending 2 USDT with same expiration.
	 *
	 * If both users sign their subintents within one hour from each other, the transaction to exchange
	 * 100 XRD over 2 USDT will succeed. Otherwise, it would fail.
	 */
	case afterDelay(DappToWalletInteractionSubintentExpireAfterDelay
	)
}

// MARK: - FfiConverterTypeDappToWalletInteractionSubintentExpiration
public struct FfiConverterTypeDappToWalletInteractionSubintentExpiration: FfiConverterRustBuffer {
	typealias SwiftType = DappToWalletInteractionSubintentExpiration

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentExpiration {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .atTime(FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime.read(from: &buf)
			)

		case 2: return try .afterDelay(FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DappToWalletInteractionSubintentExpiration, into buf: inout [UInt8]) {
		switch value {
		case let .atTime(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime.write(v1, into: &buf)

		case let .afterDelay(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpiration_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentExpiration {
	try FfiConverterTypeDappToWalletInteractionSubintentExpiration.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpiration_lower(_ value: DappToWalletInteractionSubintentExpiration) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionSubintentExpiration.lower(value)
}

// MARK: - DappToWalletInteractionSubintentExpiration + Sendable
extension DappToWalletInteractionSubintentExpiration: Sendable {}

// MARK: - DappToWalletInteractionSubintentExpiration + Equatable, Hashable
extension DappToWalletInteractionSubintentExpiration: Equatable, Hashable {}

// MARK: - DappToWalletInteractionSubintentExpirationStatus
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum that represents the expiration status of a subintent at a given time.
 *
 * Useful for determining if a subintent is still valid at the moment the Host apps
 * receive the corresponding request.
 */

public enum DappToWalletInteractionSubintentExpirationStatus {
	/**
	 * The subintent hasn't expired yet
	 */
	case valid
	/**
	 * The subintent is too close to its expiration. Although it hasn't expired yet, the Host apps
	 * shouldn't allow the user dealing with it.
	 */
	case expirationTooClose
	/**
	 * The subintent has already expired.
	 */
	case expired
}

// MARK: - FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus
public struct FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus: FfiConverterRustBuffer {
	typealias SwiftType = DappToWalletInteractionSubintentExpirationStatus

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentExpirationStatus {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .valid

		case 2: return .expirationTooClose

		case 3: return .expired

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DappToWalletInteractionSubintentExpirationStatus, into buf: inout [UInt8]) {
		switch value {
		case .valid:
			writeInt(&buf, Int32(1))

		case .expirationTooClose:
			writeInt(&buf, Int32(2))

		case .expired:
			writeInt(&buf, Int32(3))
		}
	}
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentExpirationStatus {
	try FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus_lower(_ value: DappToWalletInteractionSubintentExpirationStatus) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus.lower(value)
}

// MARK: - DappToWalletInteractionSubintentExpirationStatus + Sendable
extension DappToWalletInteractionSubintentExpirationStatus: Sendable {}

// MARK: - DappToWalletInteractionSubintentExpirationStatus + Equatable, Hashable
extension DappToWalletInteractionSubintentExpirationStatus: Equatable, Hashable {}

// MARK: - DappWalletInteractionErrorType
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappWalletInteractionErrorType {
	case rejectedByUser
	case wrongNetwork
	case failedToPrepareTransaction
	case failedToCompileTransaction
	case failedToSignTransaction
	case failedToSubmitTransaction
	case failedToPollSubmittedTransaction
	case failedToFindAccountWithEnoughFundsToLockFee
	case submittedTransactionWasDuplicate
	case submittedTransactionHasFailedTransactionStatus
	case submittedTransactionHasRejectedTransactionStatus
	case wrongAccountType
	case unknownWebsite
	case invalidOriginUrl
	case radixJsonNotFound
	case radixJsonUnknownFileFormat
	case unknownDappDefinitionAddress
	case invalidPersona
	case invalidRequest
	case incompatibleVersion
	case failedToSignAuthChallenge
	case invalidPersonaOrAccounts
	case expiredSubintent
	case subintentExpirationTooClose
}

// MARK: - FfiConverterTypeDappWalletInteractionErrorType
public struct FfiConverterTypeDappWalletInteractionErrorType: FfiConverterRustBuffer {
	typealias SwiftType = DappWalletInteractionErrorType

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappWalletInteractionErrorType {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .rejectedByUser

		case 2: return .wrongNetwork

		case 3: return .failedToPrepareTransaction

		case 4: return .failedToCompileTransaction

		case 5: return .failedToSignTransaction

		case 6: return .failedToSubmitTransaction

		case 7: return .failedToPollSubmittedTransaction

		case 8: return .failedToFindAccountWithEnoughFundsToLockFee

		case 9: return .submittedTransactionWasDuplicate

		case 10: return .submittedTransactionHasFailedTransactionStatus

		case 11: return .submittedTransactionHasRejectedTransactionStatus

		case 12: return .wrongAccountType

		case 13: return .unknownWebsite

		case 14: return .invalidOriginUrl

		case 15: return .radixJsonNotFound

		case 16: return .radixJsonUnknownFileFormat

		case 17: return .unknownDappDefinitionAddress

		case 18: return .invalidPersona

		case 19: return .invalidRequest

		case 20: return .incompatibleVersion

		case 21: return .failedToSignAuthChallenge

		case 22: return .invalidPersonaOrAccounts

		case 23: return .expiredSubintent

		case 24: return .subintentExpirationTooClose

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DappWalletInteractionErrorType, into buf: inout [UInt8]) {
		switch value {
		case .rejectedByUser:
			writeInt(&buf, Int32(1))

		case .wrongNetwork:
			writeInt(&buf, Int32(2))

		case .failedToPrepareTransaction:
			writeInt(&buf, Int32(3))

		case .failedToCompileTransaction:
			writeInt(&buf, Int32(4))

		case .failedToSignTransaction:
			writeInt(&buf, Int32(5))

		case .failedToSubmitTransaction:
			writeInt(&buf, Int32(6))

		case .failedToPollSubmittedTransaction:
			writeInt(&buf, Int32(7))

		case .failedToFindAccountWithEnoughFundsToLockFee:
			writeInt(&buf, Int32(8))

		case .submittedTransactionWasDuplicate:
			writeInt(&buf, Int32(9))

		case .submittedTransactionHasFailedTransactionStatus:
			writeInt(&buf, Int32(10))

		case .submittedTransactionHasRejectedTransactionStatus:
			writeInt(&buf, Int32(11))

		case .wrongAccountType:
			writeInt(&buf, Int32(12))

		case .unknownWebsite:
			writeInt(&buf, Int32(13))

		case .invalidOriginUrl:
			writeInt(&buf, Int32(14))

		case .radixJsonNotFound:
			writeInt(&buf, Int32(15))

		case .radixJsonUnknownFileFormat:
			writeInt(&buf, Int32(16))

		case .unknownDappDefinitionAddress:
			writeInt(&buf, Int32(17))

		case .invalidPersona:
			writeInt(&buf, Int32(18))

		case .invalidRequest:
			writeInt(&buf, Int32(19))

		case .incompatibleVersion:
			writeInt(&buf, Int32(20))

		case .failedToSignAuthChallenge:
			writeInt(&buf, Int32(21))

		case .invalidPersonaOrAccounts:
			writeInt(&buf, Int32(22))

		case .expiredSubintent:
			writeInt(&buf, Int32(23))

		case .subintentExpirationTooClose:
			writeInt(&buf, Int32(24))
		}
	}
}

public func FfiConverterTypeDappWalletInteractionErrorType_lift(_ buf: RustBuffer) throws -> DappWalletInteractionErrorType {
	try FfiConverterTypeDappWalletInteractionErrorType.lift(buf)
}

public func FfiConverterTypeDappWalletInteractionErrorType_lower(_ value: DappWalletInteractionErrorType) -> RustBuffer {
	FfiConverterTypeDappWalletInteractionErrorType.lower(value)
}

// MARK: - DappWalletInteractionErrorType + Sendable
extension DappWalletInteractionErrorType: Sendable {}

// MARK: - DappWalletInteractionErrorType + Equatable, Hashable
extension DappWalletInteractionErrorType: Equatable, Hashable {}

// MARK: - DependencyInformation
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DependencyInformation {
	case version(String
	)
	case tag(String
	)
	case branch(String
	)
	case rev(String
	)
}

// MARK: - FfiConverterTypeDependencyInformation
public struct FfiConverterTypeDependencyInformation: FfiConverterRustBuffer {
	typealias SwiftType = DependencyInformation

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DependencyInformation {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .version(FfiConverterString.read(from: &buf)
			)

		case 2: return try .tag(FfiConverterString.read(from: &buf)
			)

		case 3: return try .branch(FfiConverterString.read(from: &buf)
			)

		case 4: return try .rev(FfiConverterString.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DependencyInformation, into buf: inout [UInt8]) {
		switch value {
		case let .version(v1):
			writeInt(&buf, Int32(1))
			FfiConverterString.write(v1, into: &buf)

		case let .tag(v1):
			writeInt(&buf, Int32(2))
			FfiConverterString.write(v1, into: &buf)

		case let .branch(v1):
			writeInt(&buf, Int32(3))
			FfiConverterString.write(v1, into: &buf)

		case let .rev(v1):
			writeInt(&buf, Int32(4))
			FfiConverterString.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeDependencyInformation_lift(_ buf: RustBuffer) throws -> DependencyInformation {
	try FfiConverterTypeDependencyInformation.lift(buf)
}

public func FfiConverterTypeDependencyInformation_lower(_ value: DependencyInformation) -> RustBuffer {
	FfiConverterTypeDependencyInformation.lower(value)
}

// MARK: - DependencyInformation + Sendable
extension DependencyInformation: Sendable {}

// MARK: - DependencyInformation + Equatable, Hashable
extension DependencyInformation: Equatable, Hashable {}

// MARK: - DepositAddressExceptionRule
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The exception kind for deposit address
 */

public enum DepositAddressExceptionRule {
	/**
	 * A resource can always be deposited in to the account by third-parties
	 */
	case allow
	/**
	 * A resource can never be deposited in to the account by third-parties
	 */
	case deny
}

// MARK: - FfiConverterTypeDepositAddressExceptionRule
public struct FfiConverterTypeDepositAddressExceptionRule: FfiConverterRustBuffer {
	typealias SwiftType = DepositAddressExceptionRule

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositAddressExceptionRule {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .allow

		case 2: return .deny

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DepositAddressExceptionRule, into buf: inout [UInt8]) {
		switch value {
		case .allow:
			writeInt(&buf, Int32(1))

		case .deny:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeDepositAddressExceptionRule_lift(_ buf: RustBuffer) throws -> DepositAddressExceptionRule {
	try FfiConverterTypeDepositAddressExceptionRule.lift(buf)
}

public func FfiConverterTypeDepositAddressExceptionRule_lower(_ value: DepositAddressExceptionRule) -> RustBuffer {
	FfiConverterTypeDepositAddressExceptionRule.lower(value)
}

// MARK: - DepositAddressExceptionRule + Sendable
extension DepositAddressExceptionRule: Sendable {}

// MARK: - DepositAddressExceptionRule + Equatable, Hashable
extension DepositAddressExceptionRule: Equatable, Hashable {}

// MARK: - DepositRule
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The general deposit rule to apply
 */

public enum DepositRule {
	/**
	 * The account accepts **all** assets by default, except for exceptions (if any) which might not deposit/be deposited into this account.
	 */
	case acceptKnown
	/**
	 * The account accepts **known** assets by default, except for exceptions (if any) which might not deposit/be deposited into this account. By known we mean assets this account has received in the past.
	 */
	case acceptAll
	/**
	 * The account denies **all** assets by default, except for exceptions (if any) which might in fact deposit/be deposited into this account.
	 */
	case denyAll
}

// MARK: - FfiConverterTypeDepositRule
public struct FfiConverterTypeDepositRule: FfiConverterRustBuffer {
	typealias SwiftType = DepositRule

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositRule {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .acceptKnown

		case 2: return .acceptAll

		case 3: return .denyAll

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DepositRule, into buf: inout [UInt8]) {
		switch value {
		case .acceptKnown:
			writeInt(&buf, Int32(1))

		case .acceptAll:
			writeInt(&buf, Int32(2))

		case .denyAll:
			writeInt(&buf, Int32(3))
		}
	}
}

public func FfiConverterTypeDepositRule_lift(_ buf: RustBuffer) throws -> DepositRule {
	try FfiConverterTypeDepositRule.lift(buf)
}

public func FfiConverterTypeDepositRule_lower(_ value: DepositRule) -> RustBuffer {
	FfiConverterTypeDepositRule.lower(value)
}

// MARK: - DepositRule + Sendable
extension DepositRule: Sendable {}

// MARK: - DepositRule + Equatable, Hashable
extension DepositRule: Equatable, Hashable {}

// MARK: - DerivationPath
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A derivation path on either supported schemes, either Babylon (CAP26) or Olympia (BIP44Like).
 */

public enum DerivationPath {
	case account(value: AccountPath
	)
	case identity(value: IdentityPath
	)
	case bip44Like(value: Bip44LikePath
	)
}

// MARK: - FfiConverterTypeDerivationPath
public struct FfiConverterTypeDerivationPath: FfiConverterRustBuffer {
	typealias SwiftType = DerivationPath

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPath {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .account(value: FfiConverterTypeAccountPath.read(from: &buf)
			)

		case 2: return try .identity(value: FfiConverterTypeIdentityPath.read(from: &buf)
			)

		case 3: return try .bip44Like(value: FfiConverterTypeBIP44LikePath.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DerivationPath, into buf: inout [UInt8]) {
		switch value {
		case let .account(value):
			writeInt(&buf, Int32(1))
			FfiConverterTypeAccountPath.write(value, into: &buf)

		case let .identity(value):
			writeInt(&buf, Int32(2))
			FfiConverterTypeIdentityPath.write(value, into: &buf)

		case let .bip44Like(value):
			writeInt(&buf, Int32(3))
			FfiConverterTypeBIP44LikePath.write(value, into: &buf)
		}
	}
}

public func FfiConverterTypeDerivationPath_lift(_ buf: RustBuffer) throws -> DerivationPath {
	try FfiConverterTypeDerivationPath.lift(buf)
}

public func FfiConverterTypeDerivationPath_lower(_ value: DerivationPath) -> RustBuffer {
	FfiConverterTypeDerivationPath.lower(value)
}

// MARK: - DerivationPath + Sendable
extension DerivationPath: Sendable {}

// MARK: - DerivationPath + Equatable, Hashable
extension DerivationPath: Equatable, Hashable {}

// MARK: - DerivationPathScheme
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Which derivation path to used for some particular HD operations
 * such as signing or public key derivation. Radix Babylon introduces
 * a new scheme call Cap26 but we also need to support BIP44-like used
 * by Olympia.
 */

public enum DerivationPathScheme {
	/**
	 * A BIP32 based derivation path scheme, using SLIP10.
	 */
	case cap26
	/**
	 * A BIP32 based similar to BIP44, but not strict BIP44 since the
	 * last path component is hardened (a mistake made during Olympia),
	 * used to support legacy accounts imported from Olympia wallet.
	 */
	case bip44Olympia
}

// MARK: - FfiConverterTypeDerivationPathScheme
public struct FfiConverterTypeDerivationPathScheme: FfiConverterRustBuffer {
	typealias SwiftType = DerivationPathScheme

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPathScheme {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .cap26

		case 2: return .bip44Olympia

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DerivationPathScheme, into buf: inout [UInt8]) {
		switch value {
		case .cap26:
			writeInt(&buf, Int32(1))

		case .bip44Olympia:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeDerivationPathScheme_lift(_ buf: RustBuffer) throws -> DerivationPathScheme {
	try FfiConverterTypeDerivationPathScheme.lift(buf)
}

public func FfiConverterTypeDerivationPathScheme_lower(_ value: DerivationPathScheme) -> RustBuffer {
	FfiConverterTypeDerivationPathScheme.lower(value)
}

// MARK: - DerivationPathScheme + Sendable
extension DerivationPathScheme: Sendable {}

// MARK: - DerivationPathScheme + Equatable, Hashable
extension DerivationPathScheme: Equatable, Hashable {}

// MARK: - DetailedManifestClass
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The execution summary process not only determines the class of the manifest,
 * but also includes additional information about this class that the wallet
 * requires to display to the user.
 */

public enum DetailedManifestClass {
	/**
	 * A general manifest that involves any amount of arbitrary components
	 * and packages where nothing more concrete can be said about the manifest
	 * and its nature.
	 *
	 * No additional information is required beyond what the execution summary
	 * will provide.
	 */
	case general
	/**
	 * A manifest of a 1-to-1 transfer to a one-to-many transfer of resources.
	 */
	case transfer(
		/**
		 * When `true`, then this is a one-to-one transfer and the wallet can
		 * regard this as a "simple transfer" and communicate this information
		 * to the ledger hardware wallet. Otherwise, if `false`, then this is
		 * not a one-to-one transfer.
		 */ isOneToOne: Bool
	)
	/**
	 * A manifest where XRD is claimed from one or more validators.
	 */
	case validatorClaim(
		/**
		 * The addresses of validators in the transaction
		 */ validatorAddresses: [ValidatorAddress],
		/**
			* The claims observed in the transaction
			*/ validatorClaims: [TrackedValidatorClaim]
	)
	/**
	 * A manifest where XRD is staked to one or more validators.
	 */
	case validatorStake(
		/**
		 * The addresses of validators in the transaction
		 */ validatorAddresses: [ValidatorAddress],
		/**
			* The stake observed in the transaction
			*/ validatorStakes: [TrackedValidatorStake]
	)
	/**
	 * A manifest where XRD is unstaked from one or more validators.
	 */
	case validatorUnstake(
		/**
		 * The addresses of validators in the transaction
		 */ validatorAddresses: [ValidatorAddress],
		/**
			* The data associated with the various claim NFTs
			*/ claimsNonFungibleData: [NonFungibleGlobalId: UnstakeData]
	)
	/**
	 * A manifest that updated the deposit settings of the account.
	 */
	case accountDepositSettingsUpdate(
		/**
		 * Updates to the resource preferences of the account deposit settings.
		 * account_address -> (resource_address -> Update<new_preference>)
		 */ resourcePreferencesUpdates: [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]],
		/**
			* Changes to the account's deposit mode.
			* account_address -> new_default_deposit_mode
			*/ depositModeUpdates: [AccountAddress: DepositRule],
		/**
			* Additions to the authorized depositors
			*/ authorizedDepositorsAdded: [AccountAddress: [ResourceOrNonFungible]],
		/**
			* Removals from the authorized depositors
			*/ authorizedDepositorsRemoved: [AccountAddress: [ResourceOrNonFungible]]
	)
	/**
	 * A manifest that contributed some amount of resources to a liquidity
	 * pool that can be a one-resource pool, two-resource pool, or a
	 * multi-resource pool.
	 */
	case poolContribution(
		/**
		 * The addresses of the pools in the transaction
		 */ poolAddresses: [PoolAddress],
		/**
			* The contribution observed in the transaction
			*/ poolContributions: [TrackedPoolContribution]
	)
	/**
	 * A manifest that redeemed resources from a liquidity pool. Similar to
	 * contributions, this can be any of the three pool blueprints available
	 * in the pool package.
	 */
	case poolRedemption(
		/**
		 * The addresses of the pools in the transaction
		 */ poolAddresses: [PoolAddress],
		/**
			* The redemptions observed in the transaction
			*/ poolRedemptions: [TrackedPoolRedemption]
	)
	/**
	 * A manifest that deletes accounts.
	 */
	case deleteAccounts(
		/**
		 * The addresses of the accounts that are being deleted
		 */ accountAddresses: [AccountAddress]
	)
}

// MARK: - FfiConverterTypeDetailedManifestClass
public struct FfiConverterTypeDetailedManifestClass: FfiConverterRustBuffer {
	typealias SwiftType = DetailedManifestClass

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DetailedManifestClass {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .general

		case 2: return try .transfer(isOneToOne: FfiConverterBool.read(from: &buf)
			)

		case 3: return try .validatorClaim(validatorAddresses: FfiConverterSequenceTypeValidatorAddress.read(from: &buf), validatorClaims: FfiConverterSequenceTypeTrackedValidatorClaim.read(from: &buf))

		case 4: return try .validatorStake(validatorAddresses: FfiConverterSequenceTypeValidatorAddress.read(from: &buf), validatorStakes: FfiConverterSequenceTypeTrackedValidatorStake.read(from: &buf))

		case 5: return try .validatorUnstake(validatorAddresses: FfiConverterSequenceTypeValidatorAddress.read(from: &buf), claimsNonFungibleData: FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData.read(from: &buf))

		case 6: return try .accountDepositSettingsUpdate(resourcePreferencesUpdates: FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.read(from: &buf), depositModeUpdates: FfiConverterDictionaryTypeAccountAddressTypeDepositRule.read(from: &buf), authorizedDepositorsAdded: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.read(from: &buf), authorizedDepositorsRemoved: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.read(from: &buf))

		case 7: return try .poolContribution(poolAddresses: FfiConverterSequenceTypePoolAddress.read(from: &buf), poolContributions: FfiConverterSequenceTypeTrackedPoolContribution.read(from: &buf))

		case 8: return try .poolRedemption(poolAddresses: FfiConverterSequenceTypePoolAddress.read(from: &buf), poolRedemptions: FfiConverterSequenceTypeTrackedPoolRedemption.read(from: &buf))

		case 9: return try .deleteAccounts(accountAddresses: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DetailedManifestClass, into buf: inout [UInt8]) {
		switch value {
		case .general:
			writeInt(&buf, Int32(1))

		case let .transfer(isOneToOne):
			writeInt(&buf, Int32(2))
			FfiConverterBool.write(isOneToOne, into: &buf)

		case let .validatorClaim(validatorAddresses, validatorClaims):
			writeInt(&buf, Int32(3))
			FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
			FfiConverterSequenceTypeTrackedValidatorClaim.write(validatorClaims, into: &buf)

		case let .validatorStake(validatorAddresses, validatorStakes):
			writeInt(&buf, Int32(4))
			FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
			FfiConverterSequenceTypeTrackedValidatorStake.write(validatorStakes, into: &buf)

		case let .validatorUnstake(validatorAddresses, claimsNonFungibleData):
			writeInt(&buf, Int32(5))
			FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
			FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData.write(claimsNonFungibleData, into: &buf)

		case let .accountDepositSettingsUpdate(resourcePreferencesUpdates, depositModeUpdates, authorizedDepositorsAdded, authorizedDepositorsRemoved):
			writeInt(&buf, Int32(6))
			FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.write(resourcePreferencesUpdates, into: &buf)
			FfiConverterDictionaryTypeAccountAddressTypeDepositRule.write(depositModeUpdates, into: &buf)
			FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.write(authorizedDepositorsAdded, into: &buf)
			FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.write(authorizedDepositorsRemoved, into: &buf)

		case let .poolContribution(poolAddresses, poolContributions):
			writeInt(&buf, Int32(7))
			FfiConverterSequenceTypePoolAddress.write(poolAddresses, into: &buf)
			FfiConverterSequenceTypeTrackedPoolContribution.write(poolContributions, into: &buf)

		case let .poolRedemption(poolAddresses, poolRedemptions):
			writeInt(&buf, Int32(8))
			FfiConverterSequenceTypePoolAddress.write(poolAddresses, into: &buf)
			FfiConverterSequenceTypeTrackedPoolRedemption.write(poolRedemptions, into: &buf)

		case let .deleteAccounts(accountAddresses):
			writeInt(&buf, Int32(9))
			FfiConverterSequenceTypeAccountAddress.write(accountAddresses, into: &buf)
		}
	}
}

public func FfiConverterTypeDetailedManifestClass_lift(_ buf: RustBuffer) throws -> DetailedManifestClass {
	try FfiConverterTypeDetailedManifestClass.lift(buf)
}

public func FfiConverterTypeDetailedManifestClass_lower(_ value: DetailedManifestClass) -> RustBuffer {
	FfiConverterTypeDetailedManifestClass.lower(value)
}

// MARK: - DetailedManifestClass + Sendable
extension DetailedManifestClass: Sendable {}

// MARK: - DetailedManifestClass + Equatable, Hashable
extension DetailedManifestClass: Equatable, Hashable {}

// MARK: - DetailedManifestClassKind
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A discriminator type for the `DetailedManifestClass` enum.
 */

public enum DetailedManifestClassKind {
	case general
	case transfer
	case validatorClaim
	case validatorStake
	case validatorUnstake
	case accountDepositSettingsUpdate
	case poolContribution
	case poolRedemption
	case deleteAccounts
}

// MARK: - FfiConverterTypeDetailedManifestClassKind
public struct FfiConverterTypeDetailedManifestClassKind: FfiConverterRustBuffer {
	typealias SwiftType = DetailedManifestClassKind

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DetailedManifestClassKind {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .general

		case 2: return .transfer

		case 3: return .validatorClaim

		case 4: return .validatorStake

		case 5: return .validatorUnstake

		case 6: return .accountDepositSettingsUpdate

		case 7: return .poolContribution

		case 8: return .poolRedemption

		case 9: return .deleteAccounts

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DetailedManifestClassKind, into buf: inout [UInt8]) {
		switch value {
		case .general:
			writeInt(&buf, Int32(1))

		case .transfer:
			writeInt(&buf, Int32(2))

		case .validatorClaim:
			writeInt(&buf, Int32(3))

		case .validatorStake:
			writeInt(&buf, Int32(4))

		case .validatorUnstake:
			writeInt(&buf, Int32(5))

		case .accountDepositSettingsUpdate:
			writeInt(&buf, Int32(6))

		case .poolContribution:
			writeInt(&buf, Int32(7))

		case .poolRedemption:
			writeInt(&buf, Int32(8))

		case .deleteAccounts:
			writeInt(&buf, Int32(9))
		}
	}
}

public func FfiConverterTypeDetailedManifestClassKind_lift(_ buf: RustBuffer) throws -> DetailedManifestClassKind {
	try FfiConverterTypeDetailedManifestClassKind.lift(buf)
}

public func FfiConverterTypeDetailedManifestClassKind_lower(_ value: DetailedManifestClassKind) -> RustBuffer {
	FfiConverterTypeDetailedManifestClassKind.lower(value)
}

// MARK: - DetailedManifestClassKind + Sendable
extension DetailedManifestClassKind: Sendable {}

// MARK: - DetailedManifestClassKind + Equatable, Hashable
extension DetailedManifestClassKind: Equatable, Hashable {}

// MARK: - DeviceFactorSourceType
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * If we wanna create an Olympia DeviceFactorSource or
 * a Babylon one, either main or not.
 */

public enum DeviceFactorSourceType {
	case babylon(isMain: Bool
	)
	case olympia
}

// MARK: - FfiConverterTypeDeviceFactorSourceType
public struct FfiConverterTypeDeviceFactorSourceType: FfiConverterRustBuffer {
	typealias SwiftType = DeviceFactorSourceType

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSourceType {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .babylon(isMain: FfiConverterBool.read(from: &buf)
			)

		case 2: return .olympia

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: DeviceFactorSourceType, into buf: inout [UInt8]) {
		switch value {
		case let .babylon(isMain):
			writeInt(&buf, Int32(1))
			FfiConverterBool.write(isMain, into: &buf)

		case .olympia:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeDeviceFactorSourceType_lift(_ buf: RustBuffer) throws -> DeviceFactorSourceType {
	try FfiConverterTypeDeviceFactorSourceType.lift(buf)
}

public func FfiConverterTypeDeviceFactorSourceType_lower(_ value: DeviceFactorSourceType) -> RustBuffer {
	FfiConverterTypeDeviceFactorSourceType.lower(value)
}

// MARK: - DeviceFactorSourceType + Sendable
extension DeviceFactorSourceType: Sendable {}

// MARK: - DeviceFactorSourceType + Equatable, Hashable
extension DeviceFactorSourceType: Equatable, Hashable {}

// MARK: - EncryptionScheme
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EncryptionScheme {
	/**
	 * AES GCM 256 encryption
	 */
	case version1(AesGcm256
	)
}

// MARK: - FfiConverterTypeEncryptionScheme
public struct FfiConverterTypeEncryptionScheme: FfiConverterRustBuffer {
	typealias SwiftType = EncryptionScheme

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionScheme {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .version1(FfiConverterTypeAesGcm256.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: EncryptionScheme, into buf: inout [UInt8]) {
		switch value {
		case let .version1(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeAesGcm256.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeEncryptionScheme_lift(_ buf: RustBuffer) throws -> EncryptionScheme {
	try FfiConverterTypeEncryptionScheme.lift(buf)
}

public func FfiConverterTypeEncryptionScheme_lower(_ value: EncryptionScheme) -> RustBuffer {
	FfiConverterTypeEncryptionScheme.lower(value)
}

// MARK: - EncryptionScheme + Sendable
extension EncryptionScheme: Sendable {}

// MARK: - EncryptionScheme + Equatable, Hashable
extension EncryptionScheme: Equatable, Hashable {}

// MARK: - EntityFlag
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Flags used to mark state of an Account or Persona such as whether
 * user has marked it as deleted or not.
 */

public enum EntityFlag {
	/**
	 * The entity is marked as hidden by user. Entity should still be kept in Profile
	 * The user can "unhide" the entity and continue involving it in transactions on ledger.
	 */
	case hiddenByUser
	/**
	 * The entity is marked as tombstoned by the user. Entity should still be kept in Profile
	 * Such an entity cannot be involved in any transaction anymore.
	 */
	case tombstonedByUser
}

// MARK: - FfiConverterTypeEntityFlag
public struct FfiConverterTypeEntityFlag: FfiConverterRustBuffer {
	typealias SwiftType = EntityFlag

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityFlag {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .hiddenByUser

		case 2: return .tombstonedByUser

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: EntityFlag, into buf: inout [UInt8]) {
		switch value {
		case .hiddenByUser:
			writeInt(&buf, Int32(1))

		case .tombstonedByUser:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeEntityFlag_lift(_ buf: RustBuffer) throws -> EntityFlag {
	try FfiConverterTypeEntityFlag.lift(buf)
}

public func FfiConverterTypeEntityFlag_lower(_ value: EntityFlag) -> RustBuffer {
	FfiConverterTypeEntityFlag.lower(value)
}

// MARK: - EntityFlag + Sendable
extension EntityFlag: Sendable {}

// MARK: - EntityFlag + Equatable, Hashable
extension EntityFlag: Equatable, Hashable {}

// MARK: - EntityKind
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EntityKind {
	case account
	case persona
}

// MARK: - FfiConverterTypeEntityKind
public struct FfiConverterTypeEntityKind: FfiConverterRustBuffer {
	typealias SwiftType = EntityKind

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityKind {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .account

		case 2: return .persona

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: EntityKind, into buf: inout [UInt8]) {
		switch value {
		case .account:
			writeInt(&buf, Int32(1))

		case .persona:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeEntityKind_lift(_ buf: RustBuffer) throws -> EntityKind {
	try FfiConverterTypeEntityKind.lift(buf)
}

public func FfiConverterTypeEntityKind_lower(_ value: EntityKind) -> RustBuffer {
	FfiConverterTypeEntityKind.lower(value)
}

// MARK: - EntityKind + Sendable
extension EntityKind: Sendable {}

// MARK: - EntityKind + Equatable, Hashable
extension EntityKind: Equatable, Hashable {}

// MARK: - EntitySecurityState
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the state an entity - Account or Persona - is in, in regards to how
 * the user controls it, i.e. if it is controlled by a single factor (private key)
 * or an `AccessController` with a potential Multi-Factor setup.
 */

public enum EntitySecurityState {
	/**
	 * The account is controlled by a single factor (private key)
	 */
	case unsecured(value: UnsecuredEntityControl
	)
}

// MARK: - FfiConverterTypeEntitySecurityState
public struct FfiConverterTypeEntitySecurityState: FfiConverterRustBuffer {
	typealias SwiftType = EntitySecurityState

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntitySecurityState {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .unsecured(value: FfiConverterTypeUnsecuredEntityControl.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: EntitySecurityState, into buf: inout [UInt8]) {
		switch value {
		case let .unsecured(value):
			writeInt(&buf, Int32(1))
			FfiConverterTypeUnsecuredEntityControl.write(value, into: &buf)
		}
	}
}

public func FfiConverterTypeEntitySecurityState_lift(_ buf: RustBuffer) throws -> EntitySecurityState {
	try FfiConverterTypeEntitySecurityState.lift(buf)
}

public func FfiConverterTypeEntitySecurityState_lower(_ value: EntitySecurityState) -> RustBuffer {
	FfiConverterTypeEntitySecurityState.lower(value)
}

// MARK: - EntitySecurityState + Sendable
extension EntitySecurityState: Sendable {}

// MARK: - EntitySecurityState + Equatable, Hashable
extension EntitySecurityState: Equatable, Hashable {}

// MARK: - Event
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * SargonOS event contain information about something of interest that has
 * happened to the SargonOS, most prominently to the Profile. Host device
 * can subscribe to these events by use of `EventBusDriver`.
 */

public enum Event {
	/**
	 * The SargonOS just booted.
	 */
	case booted
	/**
	 * Current Gateway changed
	 */
	case gatewayChangedCurrent(to: Gateway, isNew: Bool)
	/**
	 * Profile has been saved, typically it has been modified and the new
	 * changed Profile got persisted into secure storage.
	 */
	case profileSaved
	/**
	 * A profile has been imported and has been set to active profile,
	 * and saved into secure storage.
	 */
	case profileImported(id: ProfileId
	)
	/**
	 * The active profile has been modified (might not have been saved yet).
	 */
	case profileModified(change: EventProfileModified
	)
	/**
	 * The Profile was last used on another device, user ought to claim it.
	 */
	case profileUsedOnOtherDevice(DeviceInfo
	)
}

// MARK: - FfiConverterTypeEvent
public struct FfiConverterTypeEvent: FfiConverterRustBuffer {
	typealias SwiftType = Event

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .booted

		case 2: return try .gatewayChangedCurrent(to: FfiConverterTypeGateway.read(from: &buf), isNew: FfiConverterBool.read(from: &buf))

		case 3: return .profileSaved

		case 4: return try .profileImported(id: FfiConverterTypeProfileID.read(from: &buf)
			)

		case 5: return try .profileModified(change: FfiConverterTypeEventProfileModified.read(from: &buf)
			)

		case 6: return try .profileUsedOnOtherDevice(FfiConverterTypeDeviceInfo.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: Event, into buf: inout [UInt8]) {
		switch value {
		case .booted:
			writeInt(&buf, Int32(1))

		case let .gatewayChangedCurrent(to, isNew):
			writeInt(&buf, Int32(2))
			FfiConverterTypeGateway.write(to, into: &buf)
			FfiConverterBool.write(isNew, into: &buf)

		case .profileSaved:
			writeInt(&buf, Int32(3))

		case let .profileImported(id):
			writeInt(&buf, Int32(4))
			FfiConverterTypeProfileID.write(id, into: &buf)

		case let .profileModified(change):
			writeInt(&buf, Int32(5))
			FfiConverterTypeEventProfileModified.write(change, into: &buf)

		case let .profileUsedOnOtherDevice(v1):
			writeInt(&buf, Int32(6))
			FfiConverterTypeDeviceInfo.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeEvent_lift(_ buf: RustBuffer) throws -> Event {
	try FfiConverterTypeEvent.lift(buf)
}

public func FfiConverterTypeEvent_lower(_ value: Event) -> RustBuffer {
	FfiConverterTypeEvent.lower(value)
}

// MARK: - Event + Sendable
extension Event: Sendable {}

// MARK: - Event + Equatable, Hashable
extension Event: Equatable, Hashable {}

// MARK: - EventKind
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A discriminator identifying the kind of `Event`, this has no associated
 * values and flattens the otherwise nested `Event` enum.
 */

public enum EventKind {
	/**
	 * Profile updated with a new account.
	 */
	case accountAdded
	/**
	 * Profile updated with new accounts.
	 */
	case accountsAdded
	/**
	 * An existing account has been updated
	 */
	case accountUpdated
	/**
	 * Existing accounts have been updated
	 */
	case accountsUpdated
	/**
	 * SargonOS did boot.
	 */
	case booted
	/**
	 * Current Gateway changed
	 */
	case gatewayChangedCurrent
	/**
	 * Profile updated with a new persona.
	 */
	case personaAdded
	/**
	 * Profile updated with new personas.
	 */
	case personasAdded
	/**
	 * An existing persona has been updated
	 */
	case personaUpdated
	/**
	 * Existing personas have been updated
	 */
	case personasUpdated
	/**
	 * Profile was saved.
	 */
	case profileSaved
	/**
	 * A profile has been imported and has been set to active profile,
	 * and saved into secure storage.
	 */
	case profileImported
	/**
	 * Profile was last used on another device.
	 */
	case profileUsedOnOtherDevice
	/**
	 * Profile updated with a new factor source.
	 */
	case factorSourceAdded
	/**
	 * Profile updated with multiple new factor sources.
	 */
	case factorSourcesAdded
	/**
	 * An existing factor source has been updated
	 */
	case factorSourceUpdated
	/**
	 * Profile updated with a new Security Structure.
	 */
	case securityStructureAdded
}

// MARK: - FfiConverterTypeEventKind
public struct FfiConverterTypeEventKind: FfiConverterRustBuffer {
	typealias SwiftType = EventKind

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventKind {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .accountAdded

		case 2: return .accountsAdded

		case 3: return .accountUpdated

		case 4: return .accountsUpdated

		case 5: return .booted

		case 6: return .gatewayChangedCurrent

		case 7: return .personaAdded

		case 8: return .personasAdded

		case 9: return .personaUpdated

		case 10: return .personasUpdated

		case 11: return .profileSaved

		case 12: return .profileImported

		case 13: return .profileUsedOnOtherDevice

		case 14: return .factorSourceAdded

		case 15: return .factorSourcesAdded

		case 16: return .factorSourceUpdated

		case 17: return .securityStructureAdded

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: EventKind, into buf: inout [UInt8]) {
		switch value {
		case .accountAdded:
			writeInt(&buf, Int32(1))

		case .accountsAdded:
			writeInt(&buf, Int32(2))

		case .accountUpdated:
			writeInt(&buf, Int32(3))

		case .accountsUpdated:
			writeInt(&buf, Int32(4))

		case .booted:
			writeInt(&buf, Int32(5))

		case .gatewayChangedCurrent:
			writeInt(&buf, Int32(6))

		case .personaAdded:
			writeInt(&buf, Int32(7))

		case .personasAdded:
			writeInt(&buf, Int32(8))

		case .personaUpdated:
			writeInt(&buf, Int32(9))

		case .personasUpdated:
			writeInt(&buf, Int32(10))

		case .profileSaved:
			writeInt(&buf, Int32(11))

		case .profileImported:
			writeInt(&buf, Int32(12))

		case .profileUsedOnOtherDevice:
			writeInt(&buf, Int32(13))

		case .factorSourceAdded:
			writeInt(&buf, Int32(14))

		case .factorSourcesAdded:
			writeInt(&buf, Int32(15))

		case .factorSourceUpdated:
			writeInt(&buf, Int32(16))

		case .securityStructureAdded:
			writeInt(&buf, Int32(17))
		}
	}
}

public func FfiConverterTypeEventKind_lift(_ buf: RustBuffer) throws -> EventKind {
	try FfiConverterTypeEventKind.lift(buf)
}

public func FfiConverterTypeEventKind_lower(_ value: EventKind) -> RustBuffer {
	FfiConverterTypeEventKind.lower(value)
}

// MARK: - EventKind + Sendable
extension EventKind: Sendable {}

// MARK: - EventKind + Equatable, Hashable
extension EventKind: Equatable, Hashable {}

// MARK: - EventProfileModified
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The active profile has been modified (might not have been saved yet).
 */

public enum EventProfileModified {
	/**
	 * A new account with `address` was inserted into the active profile
	 */
	case accountAdded(address: AccountAddress
	)
	/**
	 * New accounts with `addresses` were inserted into the active profile
	 */
	case accountsAdded(addresses: [AccountAddress]
	)
	/**
	 * An existing account has been updated
	 */
	case accountUpdated(address: AccountAddress
	)
	/**
	 * Existing accounts have been updated
	 */
	case accountsUpdated(addresses: [AccountAddress]
	)
	/**
	 * Profile updated with a new factor source.
	 */
	case factorSourceAdded(id: FactorSourceId
	)
	/**
	 * Profile updated with many new factor sources.
	 */
	case factorSourcesAdded(ids: [FactorSourceId]
	)
	/**
	 * An existing factor source has been updated
	 */
	case factorSourceUpdated(id: FactorSourceId
	)
	/**
	 * A new persona with `address` was inserted into the active profile
	 */
	case personaAdded(address: IdentityAddress
	)
	/**
	 * New personas with `addresses` were inserted into the active profile
	 */
	case personasAdded(addresses: [IdentityAddress]
	)
	/**
	 * An existing persona has been updated
	 */
	case personaUpdated(address: IdentityAddress
	)
	/**
	 * Existing personas have been updated
	 */
	case personasUpdated(addresses: [IdentityAddress]
	)
	/**
	 * Profile updated with a new Security Structure.
	 */
	case securityStructureAdded(id: SecurityStructureId
	)
}

// MARK: - FfiConverterTypeEventProfileModified
public struct FfiConverterTypeEventProfileModified: FfiConverterRustBuffer {
	typealias SwiftType = EventProfileModified

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventProfileModified {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .accountAdded(address: FfiConverterTypeAccountAddress.read(from: &buf)
			)

		case 2: return try .accountsAdded(addresses: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
			)

		case 3: return try .accountUpdated(address: FfiConverterTypeAccountAddress.read(from: &buf)
			)

		case 4: return try .accountsUpdated(addresses: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
			)

		case 5: return try .factorSourceAdded(id: FfiConverterTypeFactorSourceID.read(from: &buf)
			)

		case 6: return try .factorSourcesAdded(ids: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
			)

		case 7: return try .factorSourceUpdated(id: FfiConverterTypeFactorSourceID.read(from: &buf)
			)

		case 8: return try .personaAdded(address: FfiConverterTypeIdentityAddress.read(from: &buf)
			)

		case 9: return try .personasAdded(addresses: FfiConverterSequenceTypeIdentityAddress.read(from: &buf)
			)

		case 10: return try .personaUpdated(address: FfiConverterTypeIdentityAddress.read(from: &buf)
			)

		case 11: return try .personasUpdated(addresses: FfiConverterSequenceTypeIdentityAddress.read(from: &buf)
			)

		case 12: return try .securityStructureAdded(id: FfiConverterTypeSecurityStructureID.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: EventProfileModified, into buf: inout [UInt8]) {
		switch value {
		case let .accountAdded(address):
			writeInt(&buf, Int32(1))
			FfiConverterTypeAccountAddress.write(address, into: &buf)

		case let .accountsAdded(addresses):
			writeInt(&buf, Int32(2))
			FfiConverterSequenceTypeAccountAddress.write(addresses, into: &buf)

		case let .accountUpdated(address):
			writeInt(&buf, Int32(3))
			FfiConverterTypeAccountAddress.write(address, into: &buf)

		case let .accountsUpdated(addresses):
			writeInt(&buf, Int32(4))
			FfiConverterSequenceTypeAccountAddress.write(addresses, into: &buf)

		case let .factorSourceAdded(id):
			writeInt(&buf, Int32(5))
			FfiConverterTypeFactorSourceID.write(id, into: &buf)

		case let .factorSourcesAdded(ids):
			writeInt(&buf, Int32(6))
			FfiConverterSequenceTypeFactorSourceID.write(ids, into: &buf)

		case let .factorSourceUpdated(id):
			writeInt(&buf, Int32(7))
			FfiConverterTypeFactorSourceID.write(id, into: &buf)

		case let .personaAdded(address):
			writeInt(&buf, Int32(8))
			FfiConverterTypeIdentityAddress.write(address, into: &buf)

		case let .personasAdded(addresses):
			writeInt(&buf, Int32(9))
			FfiConverterSequenceTypeIdentityAddress.write(addresses, into: &buf)

		case let .personaUpdated(address):
			writeInt(&buf, Int32(10))
			FfiConverterTypeIdentityAddress.write(address, into: &buf)

		case let .personasUpdated(addresses):
			writeInt(&buf, Int32(11))
			FfiConverterSequenceTypeIdentityAddress.write(addresses, into: &buf)

		case let .securityStructureAdded(id):
			writeInt(&buf, Int32(12))
			FfiConverterTypeSecurityStructureID.write(id, into: &buf)
		}
	}
}

public func FfiConverterTypeEventProfileModified_lift(_ buf: RustBuffer) throws -> EventProfileModified {
	try FfiConverterTypeEventProfileModified.lift(buf)
}

public func FfiConverterTypeEventProfileModified_lower(_ value: EventProfileModified) -> RustBuffer {
	FfiConverterTypeEventProfileModified.lower(value)
}

// MARK: - EventProfileModified + Sendable
extension EventProfileModified: Sendable {}

// MARK: - EventProfileModified + Equatable, Hashable
extension EventProfileModified: Equatable, Hashable {}

// MARK: - FactorInstanceBadge
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either a "physical" badge (resource) or some source for recreation of a producer
 * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
 * is derived which produces virtual badges (signatures).
 */

public enum FactorInstanceBadge {
	case virtual(value: FactorInstanceBadgeVirtualSource
	)
	case physical(value: ResourceAddress
	)
}

// MARK: - FfiConverterTypeFactorInstanceBadge
public struct FfiConverterTypeFactorInstanceBadge: FfiConverterRustBuffer {
	typealias SwiftType = FactorInstanceBadge

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceBadge {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .virtual(value: FfiConverterTypeFactorInstanceBadgeVirtualSource.read(from: &buf)
			)

		case 2: return try .physical(value: FfiConverterTypeResourceAddress.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: FactorInstanceBadge, into buf: inout [UInt8]) {
		switch value {
		case let .virtual(value):
			writeInt(&buf, Int32(1))
			FfiConverterTypeFactorInstanceBadgeVirtualSource.write(value, into: &buf)

		case let .physical(value):
			writeInt(&buf, Int32(2))
			FfiConverterTypeResourceAddress.write(value, into: &buf)
		}
	}
}

public func FfiConverterTypeFactorInstanceBadge_lift(_ buf: RustBuffer) throws -> FactorInstanceBadge {
	try FfiConverterTypeFactorInstanceBadge.lift(buf)
}

public func FfiConverterTypeFactorInstanceBadge_lower(_ value: FactorInstanceBadge) -> RustBuffer {
	FfiConverterTypeFactorInstanceBadge.lower(value)
}

// MARK: - FactorInstanceBadge + Sendable
extension FactorInstanceBadge: Sendable {}

// MARK: - FactorInstanceBadge + Equatable, Hashable
extension FactorInstanceBadge: Equatable, Hashable {}

// MARK: - FactorInstanceBadgeVirtualSource
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FactorInstanceBadgeVirtualSource {
	case hierarchicalDeterministic(value: HierarchicalDeterministicPublicKey
	)
}

// MARK: - FfiConverterTypeFactorInstanceBadgeVirtualSource
public struct FfiConverterTypeFactorInstanceBadgeVirtualSource: FfiConverterRustBuffer {
	typealias SwiftType = FactorInstanceBadgeVirtualSource

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceBadgeVirtualSource {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .hierarchicalDeterministic(value: FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: FactorInstanceBadgeVirtualSource, into buf: inout [UInt8]) {
		switch value {
		case let .hierarchicalDeterministic(value):
			writeInt(&buf, Int32(1))
			FfiConverterTypeHierarchicalDeterministicPublicKey.write(value, into: &buf)
		}
	}
}

public func FfiConverterTypeFactorInstanceBadgeVirtualSource_lift(_ buf: RustBuffer) throws -> FactorInstanceBadgeVirtualSource {
	try FfiConverterTypeFactorInstanceBadgeVirtualSource.lift(buf)
}

public func FfiConverterTypeFactorInstanceBadgeVirtualSource_lower(_ value: FactorInstanceBadgeVirtualSource) -> RustBuffer {
	FfiConverterTypeFactorInstanceBadgeVirtualSource.lower(value)
}

// MARK: - FactorInstanceBadgeVirtualSource + Sendable
extension FactorInstanceBadgeVirtualSource: Sendable {}

// MARK: - FactorInstanceBadgeVirtualSource + Equatable, Hashable
extension FactorInstanceBadgeVirtualSource: Equatable, Hashable {}

// MARK: - FactorSource
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FactorSource {
	case device(value: DeviceFactorSource
	)
	case ledger(value: LedgerHardwareWalletFactorSource
	)
	case offDeviceMnemonic(value: OffDeviceMnemonicFactorSource
	)
	case arculusCard(value: ArculusCardFactorSource
	)
	case securityQuestions(value: SecurityQuestionsNotProductionReadyFactorSource
	)
	case trustedContact(value: TrustedContactFactorSource
	)
	case passphrase(value: PassphraseFactorSource
	)
}

// MARK: - FfiConverterTypeFactorSource
public struct FfiConverterTypeFactorSource: FfiConverterRustBuffer {
	typealias SwiftType = FactorSource

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSource {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .device(value: FfiConverterTypeDeviceFactorSource.read(from: &buf)
			)

		case 2: return try .ledger(value: FfiConverterTypeLedgerHardwareWalletFactorSource.read(from: &buf)
			)

		case 3: return try .offDeviceMnemonic(value: FfiConverterTypeOffDeviceMnemonicFactorSource.read(from: &buf)
			)

		case 4: return try .arculusCard(value: FfiConverterTypeArculusCardFactorSource.read(from: &buf)
			)

		case 5: return try .securityQuestions(value: FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.read(from: &buf)
			)

		case 6: return try .trustedContact(value: FfiConverterTypeTrustedContactFactorSource.read(from: &buf)
			)

		case 7: return try .passphrase(value: FfiConverterTypePassphraseFactorSource.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: FactorSource, into buf: inout [UInt8]) {
		switch value {
		case let .device(value):
			writeInt(&buf, Int32(1))
			FfiConverterTypeDeviceFactorSource.write(value, into: &buf)

		case let .ledger(value):
			writeInt(&buf, Int32(2))
			FfiConverterTypeLedgerHardwareWalletFactorSource.write(value, into: &buf)

		case let .offDeviceMnemonic(value):
			writeInt(&buf, Int32(3))
			FfiConverterTypeOffDeviceMnemonicFactorSource.write(value, into: &buf)

		case let .arculusCard(value):
			writeInt(&buf, Int32(4))
			FfiConverterTypeArculusCardFactorSource.write(value, into: &buf)

		case let .securityQuestions(value):
			writeInt(&buf, Int32(5))
			FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.write(value, into: &buf)

		case let .trustedContact(value):
			writeInt(&buf, Int32(6))
			FfiConverterTypeTrustedContactFactorSource.write(value, into: &buf)

		case let .passphrase(value):
			writeInt(&buf, Int32(7))
			FfiConverterTypePassphraseFactorSource.write(value, into: &buf)
		}
	}
}

public func FfiConverterTypeFactorSource_lift(_ buf: RustBuffer) throws -> FactorSource {
	try FfiConverterTypeFactorSource.lift(buf)
}

public func FfiConverterTypeFactorSource_lower(_ value: FactorSource) -> RustBuffer {
	FfiConverterTypeFactorSource.lower(value)
}

// MARK: - FactorSource + Sendable
extension FactorSource: Sendable {}

// MARK: - FactorSource + Equatable, Hashable
extension FactorSource: Equatable, Hashable {}

// MARK: - FactorSourceFlag
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Flags which describe a certain state a FactorSource might be in, primarily used
 * by DeviceFactorSource's to mark which "Babylon" FactorSource is the **main** one.
 */

public enum FactorSourceFlag {
	/**
	 * Used to mark a "babylon" `.device` FactorSource as "main". All new accounts
	 * and Personas are created using the `main` `DeviceFactorSource`.
	 *
	 * We can only ever have one.
	 * We might have zero `main` flags across all  `DeviceFactorSource`s if and only if we have only one  `DeviceFactorSource`s. If we have two or more  `DeviceFactorSource`s one of them MUST
	 * be marked with `main`.
	 */
	case main
	/**
	 * Until we have implemented "proper" deletion, we will "flag" a
	 * FactorSource as deleted by the user and hide it, meaning e.g.
	 * that in Multi-Factor Setup flows it will not show up.
	 */
	case deletedByUser
}

// MARK: - FfiConverterTypeFactorSourceFlag
public struct FfiConverterTypeFactorSourceFlag: FfiConverterRustBuffer {
	typealias SwiftType = FactorSourceFlag

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceFlag {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .main

		case 2: return .deletedByUser

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: FactorSourceFlag, into buf: inout [UInt8]) {
		switch value {
		case .main:
			writeInt(&buf, Int32(1))

		case .deletedByUser:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeFactorSourceFlag_lift(_ buf: RustBuffer) throws -> FactorSourceFlag {
	try FfiConverterTypeFactorSourceFlag.lift(buf)
}

public func FfiConverterTypeFactorSourceFlag_lower(_ value: FactorSourceFlag) -> RustBuffer {
	FfiConverterTypeFactorSourceFlag.lower(value)
}

// MARK: - FactorSourceFlag + Sendable
extension FactorSourceFlag: Sendable {}

// MARK: - FactorSourceFlag + Equatable, Hashable
extension FactorSourceFlag: Equatable, Hashable {}

// MARK: - FactorSourceId
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A unique and stable identifier of a FactorSource, e.g. a
 * DeviceFactorSource being a mnemonic securely stored in a
 * device (phone), where the ID of it is the hash of a special
 * key derived near the root of it.
 */

public enum FactorSourceId {
	/**
	 * FactorSourceID from the blake2b hash of the special HD public key derived at `CAP26::GetID`,
	 * for a certain `FactorSourceKind`
	 */
	case hash(value: FactorSourceIdFromHash
	)
	/**
	 * FactorSourceID from an AccountAddress, typically used by `trustedContact` FactorSource.
	 */
	case address(value: FactorSourceIdFromAddress
	)
}

// MARK: - FfiConverterTypeFactorSourceID
public struct FfiConverterTypeFactorSourceID: FfiConverterRustBuffer {
	typealias SwiftType = FactorSourceId

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceId {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .hash(value: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
			)

		case 2: return try .address(value: FfiConverterTypeFactorSourceIDFromAddress.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: FactorSourceId, into buf: inout [UInt8]) {
		switch value {
		case let .hash(value):
			writeInt(&buf, Int32(1))
			FfiConverterTypeFactorSourceIDFromHash.write(value, into: &buf)

		case let .address(value):
			writeInt(&buf, Int32(2))
			FfiConverterTypeFactorSourceIDFromAddress.write(value, into: &buf)
		}
	}
}

public func FfiConverterTypeFactorSourceID_lift(_ buf: RustBuffer) throws -> FactorSourceId {
	try FfiConverterTypeFactorSourceID.lift(buf)
}

public func FfiConverterTypeFactorSourceID_lower(_ value: FactorSourceId) -> RustBuffer {
	FfiConverterTypeFactorSourceID.lower(value)
}

// MARK: - FactorSourceId + Sendable
extension FactorSourceId: Sendable {}

// MARK: - FactorSourceId + Equatable, Hashable
extension FactorSourceId: Equatable, Hashable {}

// MARK: - FactorSourceKind
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The **kind** (or "type") of FactorSource describes how it is used.
 */

public enum FactorSourceKind {
	/**
	 * A user owned unencrypted mnemonic (and optional BIP39 passphrase) stored on device,
	 * thus directly usable. This kind is used as the standard factor source for all new
	 * wallet users.
	 *
	 * Attributes:
	 * * Mine
	 * * On device
	 * * Hierarchical deterministic (Mnemonic)
	 * * Entity creating
	 */
	case device
	/**
	 * A user owned hardware wallet by vendor Ledger HQ, most commonly
	 * a Ledger Nano S or Ledger Nano X. Less common models are Ledger Nano S Plus
	 * Ledger Stax.
	 *
	 * Attributes:
	 * * Mine
	 * * Off device
	 * * Hardware (requires Browser Connector Extension to communicate with wallet)
	 * * Hierarchical deterministic
	 * * Entity creating (accounts only)
	 */
	case ledgerHqHardwareWallet
	/**
	 * A user owned mnemonic (and optional BIP39 passphrase) user has to input when used,
	 * e.g. during signing.
	 *
	 * Attributes:
	 * * Mine
	 * * Off device
	 * * Hierarchical deterministic  (Mnemonic)
	 */
	case offDeviceMnemonic
	/**
	 * A contact, friend, company, organization or otherwise third party the user trusts enough
	 * to be given a recovery token user has minted and sent the this contact.
	 *
	 * Attributes:
	 * * **Not** mine
	 * * Off device
	 */
	case trustedContact
	/**
	 * An encrypted user owned mnemonic (*never* any BIP39 passphrase) which can
	 * be decrypted by answers to **security question**, which are personal questions
	 * that should be only known to the user.
	 *
	 * Attributes:
	 * * Mine
	 * * Off device
	 * * Hierarchical deterministic  (**Encrypted** mnemonic)
	 */
	case securityQuestions
	/**
	 * An Arculus card, in credit card size, communicating with host using NFC.
	 *
	 * For more info see [link]
	 *
	 * Attributes:
	 * * Mine
	 * * Off device
	 * * Hierarchical deterministic  (**Encrypted** mnemonic)\
	 * * Hardware (communicates with host using NFC)
	 *
	 * [link]: https://www.getarculus.com/
	 */
	case arculusCard
	/**
	 * Input key material for mnemonic (and optional BIP39 passphrase).
	 *
	 * Attributes:
	 * * Mine
	 * * Off device
	 * * Hierarchical deterministic (IKM -> HKDF -> Mnemonic)
	 */
	case passphrase
}

// MARK: - FfiConverterTypeFactorSourceKind
public struct FfiConverterTypeFactorSourceKind: FfiConverterRustBuffer {
	typealias SwiftType = FactorSourceKind

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceKind {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .device

		case 2: return .ledgerHqHardwareWallet

		case 3: return .offDeviceMnemonic

		case 4: return .trustedContact

		case 5: return .securityQuestions

		case 6: return .arculusCard

		case 7: return .passphrase

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: FactorSourceKind, into buf: inout [UInt8]) {
		switch value {
		case .device:
			writeInt(&buf, Int32(1))

		case .ledgerHqHardwareWallet:
			writeInt(&buf, Int32(2))

		case .offDeviceMnemonic:
			writeInt(&buf, Int32(3))

		case .trustedContact:
			writeInt(&buf, Int32(4))

		case .securityQuestions:
			writeInt(&buf, Int32(5))

		case .arculusCard:
			writeInt(&buf, Int32(6))

		case .passphrase:
			writeInt(&buf, Int32(7))
		}
	}
}

public func FfiConverterTypeFactorSourceKind_lift(_ buf: RustBuffer) throws -> FactorSourceKind {
	try FfiConverterTypeFactorSourceKind.lift(buf)
}

public func FfiConverterTypeFactorSourceKind_lower(_ value: FactorSourceKind) -> RustBuffer {
	FfiConverterTypeFactorSourceKind.lower(value)
}

// MARK: - FactorSourceKind + Sendable
extension FactorSourceKind: Sendable {}

// MARK: - FactorSourceKind + Equatable, Hashable
extension FactorSourceKind: Equatable, Hashable {}

// MARK: - FiatCurrency
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Fiat currency to measure and display the value of some XRD or other Radix assets value/worth in.
 */

public enum FiatCurrency {
	/**
	 * American dollars.
	 */
	case usd
	/**
	 * Swedish krona.
	 */
	case sek
}

// MARK: - FfiConverterTypeFiatCurrency
public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
	typealias SwiftType = FiatCurrency

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .usd

		case 2: return .sek

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
		switch value {
		case .usd:
			writeInt(&buf, Int32(1))

		case .sek:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
	try FfiConverterTypeFiatCurrency.lift(buf)
}

public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
	FfiConverterTypeFiatCurrency.lower(value)
}

// MARK: - FiatCurrency + Sendable
extension FiatCurrency: Sendable {}

// MARK: - FiatCurrency + Equatable, Hashable
extension FiatCurrency: Equatable, Hashable {}

// MARK: - FungibleResourceIndicator
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FungibleResourceIndicator {
	case guaranteed(decimal: Decimal192
	)
	case predicted(predictedDecimal: PredictedDecimal
	)
}

// MARK: - FfiConverterTypeFungibleResourceIndicator
public struct FfiConverterTypeFungibleResourceIndicator: FfiConverterRustBuffer {
	typealias SwiftType = FungibleResourceIndicator

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourceIndicator {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .guaranteed(decimal: FfiConverterTypeDecimal192.read(from: &buf)
			)

		case 2: return try .predicted(predictedDecimal: FfiConverterTypePredictedDecimal.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: FungibleResourceIndicator, into buf: inout [UInt8]) {
		switch value {
		case let .guaranteed(decimal):
			writeInt(&buf, Int32(1))
			FfiConverterTypeDecimal192.write(decimal, into: &buf)

		case let .predicted(predictedDecimal):
			writeInt(&buf, Int32(2))
			FfiConverterTypePredictedDecimal.write(predictedDecimal, into: &buf)
		}
	}
}

public func FfiConverterTypeFungibleResourceIndicator_lift(_ buf: RustBuffer) throws -> FungibleResourceIndicator {
	try FfiConverterTypeFungibleResourceIndicator.lift(buf)
}

public func FfiConverterTypeFungibleResourceIndicator_lower(_ value: FungibleResourceIndicator) -> RustBuffer {
	FfiConverterTypeFungibleResourceIndicator.lower(value)
}

// MARK: - FungibleResourceIndicator + Sendable
extension FungibleResourceIndicator: Sendable {}

// MARK: - FungibleResourceIndicator + Equatable, Hashable
extension FungibleResourceIndicator: Equatable, Hashable {}

// MARK: - HdPathComponent
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HdPathComponent {
	case unsecurifiedComponent(Unsecurified
	)
	case securifiedComponent(SecurifiedU30
	)
}

// MARK: - FfiConverterTypeHDPathComponent
public struct FfiConverterTypeHDPathComponent: FfiConverterRustBuffer {
	typealias SwiftType = HdPathComponent

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdPathComponent {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .unsecurifiedComponent(FfiConverterTypeUnsecurified.read(from: &buf)
			)

		case 2: return try .securifiedComponent(FfiConverterTypeSecurifiedU30.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: HdPathComponent, into buf: inout [UInt8]) {
		switch value {
		case let .unsecurifiedComponent(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeUnsecurified.write(v1, into: &buf)

		case let .securifiedComponent(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeSecurifiedU30.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeHDPathComponent_lift(_ buf: RustBuffer) throws -> HdPathComponent {
	try FfiConverterTypeHDPathComponent.lift(buf)
}

public func FfiConverterTypeHDPathComponent_lower(_ value: HdPathComponent) -> RustBuffer {
	FfiConverterTypeHDPathComponent.lower(value)
}

// MARK: - HdPathComponent + Sendable
extension HdPathComponent: Sendable {}

// MARK: - HdPathComponent + Equatable, Hashable
extension HdPathComponent: Equatable, Hashable {}

// MARK: - Hardened
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Hardened {
	case unsecurified(UnsecurifiedHardened
	)
	case securified(SecurifiedU30
	)
}

// MARK: - FfiConverterTypeHardened
public struct FfiConverterTypeHardened: FfiConverterRustBuffer {
	typealias SwiftType = Hardened

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hardened {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .unsecurified(FfiConverterTypeUnsecurifiedHardened.read(from: &buf)
			)

		case 2: return try .securified(FfiConverterTypeSecurifiedU30.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: Hardened, into buf: inout [UInt8]) {
		switch value {
		case let .unsecurified(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeUnsecurifiedHardened.write(v1, into: &buf)

		case let .securified(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeSecurifiedU30.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeHardened_lift(_ buf: RustBuffer) throws -> Hardened {
	try FfiConverterTypeHardened.lift(buf)
}

public func FfiConverterTypeHardened_lower(_ value: Hardened) -> RustBuffer {
	FfiConverterTypeHardened.lower(value)
}

// MARK: - Hardened + Sendable
extension Hardened: Sendable {}

// MARK: - Hardened + Equatable, Hashable
extension Hardened: Equatable, Hashable {}

// MARK: - HomeCard
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum describing the different cards that Wallet can display on home page.
 * Each card has an associated content and optional action.
 */

public enum HomeCard {
	/**
	 * Content: "Start RadQuest, learn about Radix, earn XRD and collectibles."
	 * Action: Redirect user to RadQuest.
	 */
	case startRadQuest
	/**
	 * Content: "Continue your Radix journey in your browser. Tap to dismiss."
	 * Action: None.
	 */
	case continueRadQuest
	/**
	 * Content: "You can now connect with your Radix Wallet. Tap to dismiss."
	 * Action: None.
	 */
	case dapp(iconUrl: Url?
	)
	/**
	 * Content: "To use Radix Wallet with desktop browsers, finish setup by visiting wallet.radixdlt.com"
	 * Action: None
	 */
	case connector
	/**
	 * Content: "Start digging into Web3 dApps on the Radix Ecosystem directory."
	 * Action: Redirect user to Radix Ecosystem.
	 */
	case discoverRadixDapps
}

// MARK: - FfiConverterTypeHomeCard
public struct FfiConverterTypeHomeCard: FfiConverterRustBuffer {
	typealias SwiftType = HomeCard

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCard {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .startRadQuest

		case 2: return .continueRadQuest

		case 3: return try .dapp(iconUrl: FfiConverterOptionTypeUrl.read(from: &buf)
			)

		case 4: return .connector

		case 5: return .discoverRadixDapps

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: HomeCard, into buf: inout [UInt8]) {
		switch value {
		case .startRadQuest:
			writeInt(&buf, Int32(1))

		case .continueRadQuest:
			writeInt(&buf, Int32(2))

		case let .dapp(iconUrl):
			writeInt(&buf, Int32(3))
			FfiConverterOptionTypeUrl.write(iconUrl, into: &buf)

		case .connector:
			writeInt(&buf, Int32(4))

		case .discoverRadixDapps:
			writeInt(&buf, Int32(5))
		}
	}
}

public func FfiConverterTypeHomeCard_lift(_ buf: RustBuffer) throws -> HomeCard {
	try FfiConverterTypeHomeCard.lift(buf)
}

public func FfiConverterTypeHomeCard_lower(_ value: HomeCard) -> RustBuffer {
	FfiConverterTypeHomeCard.lower(value)
}

// MARK: - HomeCard + Sendable
extension HomeCard: Sendable {}

// MARK: - HomeCard + Equatable, Hashable
extension HomeCard: Equatable, Hashable {}

// MARK: - HostOs
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the type of the Host machine and its version. Currently, as it stands at runtime
 * the possible values will be IOS or Android. Other is in place to facilitate unit tests
 * and to make sargon host agnostic.
 */

public enum HostOs {
	case ios(version: String
	)
	case android(vendor: String, version: String)
	case other(name: String, vendor: String, version: String)
}

// MARK: - FfiConverterTypeHostOS
public struct FfiConverterTypeHostOS: FfiConverterRustBuffer {
	typealias SwiftType = HostOs

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostOs {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .ios(version: FfiConverterString.read(from: &buf)
			)

		case 2: return try .android(vendor: FfiConverterString.read(from: &buf), version: FfiConverterString.read(from: &buf))

		case 3: return try .other(name: FfiConverterString.read(from: &buf), vendor: FfiConverterString.read(from: &buf), version: FfiConverterString.read(from: &buf))

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: HostOs, into buf: inout [UInt8]) {
		switch value {
		case let .ios(version):
			writeInt(&buf, Int32(1))
			FfiConverterString.write(version, into: &buf)

		case let .android(vendor, version):
			writeInt(&buf, Int32(2))
			FfiConverterString.write(vendor, into: &buf)
			FfiConverterString.write(version, into: &buf)

		case let .other(name, vendor, version):
			writeInt(&buf, Int32(3))
			FfiConverterString.write(name, into: &buf)
			FfiConverterString.write(vendor, into: &buf)
			FfiConverterString.write(version, into: &buf)
		}
	}
}

public func FfiConverterTypeHostOS_lift(_ buf: RustBuffer) throws -> HostOs {
	try FfiConverterTypeHostOS.lift(buf)
}

public func FfiConverterTypeHostOS_lower(_ value: HostOs) -> RustBuffer {
	FfiConverterTypeHostOS.lower(value)
}

// MARK: - HostOs + Sendable
extension HostOs: Sendable {}

// MARK: - HostOs + Equatable, Hashable
extension HostOs: Equatable, Hashable {}

// MARK: - KeySpace
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A discriminator of an `HDPathComponent`.
 */

public enum KeySpace {
	case unsecurified(isHardened: Bool
	)
	case securified
}

// MARK: - FfiConverterTypeKeySpace
public struct FfiConverterTypeKeySpace: FfiConverterRustBuffer {
	typealias SwiftType = KeySpace

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeySpace {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .unsecurified(isHardened: FfiConverterBool.read(from: &buf)
			)

		case 2: return .securified

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: KeySpace, into buf: inout [UInt8]) {
		switch value {
		case let .unsecurified(isHardened):
			writeInt(&buf, Int32(1))
			FfiConverterBool.write(isHardened, into: &buf)

		case .securified:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeKeySpace_lift(_ buf: RustBuffer) throws -> KeySpace {
	try FfiConverterTypeKeySpace.lift(buf)
}

public func FfiConverterTypeKeySpace_lower(_ value: KeySpace) -> RustBuffer {
	FfiConverterTypeKeySpace.lower(value)
}

// MARK: - KeySpace + Sendable
extension KeySpace: Sendable {}

// MARK: - KeySpace + Equatable, Hashable
extension KeySpace: Equatable, Hashable {}

// MARK: - LedgerHardwareWalletModel
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The model of a Ledger HQ hardware wallet NanoS, e.g.
 * *Ledger Nano S+*.
 */

public enum LedgerHardwareWalletModel {
	case nanoS
	case nanoSPlus
	case nanoX
}

// MARK: - FfiConverterTypeLedgerHardwareWalletModel
public struct FfiConverterTypeLedgerHardwareWalletModel: FfiConverterRustBuffer {
	typealias SwiftType = LedgerHardwareWalletModel

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletModel {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .nanoS

		case 2: return .nanoSPlus

		case 3: return .nanoX

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: LedgerHardwareWalletModel, into buf: inout [UInt8]) {
		switch value {
		case .nanoS:
			writeInt(&buf, Int32(1))

		case .nanoSPlus:
			writeInt(&buf, Int32(2))

		case .nanoX:
			writeInt(&buf, Int32(3))
		}
	}
}

public func FfiConverterTypeLedgerHardwareWalletModel_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletModel {
	try FfiConverterTypeLedgerHardwareWalletModel.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletModel_lower(_ value: LedgerHardwareWalletModel) -> RustBuffer {
	FfiConverterTypeLedgerHardwareWalletModel.lower(value)
}

// MARK: - LedgerHardwareWalletModel + Sendable
extension LedgerHardwareWalletModel: Sendable {}

// MARK: - LedgerHardwareWalletModel + Equatable, Hashable
extension LedgerHardwareWalletModel: Equatable, Hashable {}

// MARK: - LogFilter
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogFilter: UInt8 {
	/**
	 * Logging is turned off
	 */
	case off = 0
	/**
	 * The "error" level.
	 *
	 * Designates very serious errors.
	 */
	case error = 1
	/**
	 * The "warn" level.
	 *
	 * Designates hazardous situations.
	 */
	case warn = 2
	/**
	 * The "info" level.
	 *
	 * Designates useful information.
	 */
	case info = 3
	/**
	 * The "debug" level.
	 *
	 * Designates lower priority information.
	 */
	case debug = 4
	/**
	 * The "trace" level.
	 *
	 * Designates very low priority, often extremely verbose, information.
	 */
	case trace = 5
}

// MARK: - FfiConverterTypeLogFilter
public struct FfiConverterTypeLogFilter: FfiConverterRustBuffer {
	typealias SwiftType = LogFilter

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogFilter {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .off

		case 2: return .error

		case 3: return .warn

		case 4: return .info

		case 5: return .debug

		case 6: return .trace

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: LogFilter, into buf: inout [UInt8]) {
		switch value {
		case .off:
			writeInt(&buf, Int32(1))

		case .error:
			writeInt(&buf, Int32(2))

		case .warn:
			writeInt(&buf, Int32(3))

		case .info:
			writeInt(&buf, Int32(4))

		case .debug:
			writeInt(&buf, Int32(5))

		case .trace:
			writeInt(&buf, Int32(6))
		}
	}
}

public func FfiConverterTypeLogFilter_lift(_ buf: RustBuffer) throws -> LogFilter {
	try FfiConverterTypeLogFilter.lift(buf)
}

public func FfiConverterTypeLogFilter_lower(_ value: LogFilter) -> RustBuffer {
	FfiConverterTypeLogFilter.lower(value)
}

// MARK: - LogFilter + Sendable
extension LogFilter: Sendable {}

// MARK: - LogFilter + Equatable, Hashable
extension LogFilter: Equatable, Hashable {}

// MARK: - LogLevel
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel: UInt8 {
	/**
	 * The "error" level.
	 *
	 * Designates very serious errors.
	 */
	case error = 1
	/**
	 * The "warn" level.
	 *
	 * Designates hazardous situations.
	 */
	case warn = 2
	/**
	 * The "info" level.
	 *
	 * Designates useful information.
	 */
	case info = 3
	/**
	 * The "debug" level.
	 *
	 * Designates lower priority information.
	 */
	case debug = 4
	/**
	 * The "trace" level.
	 *
	 * Designates very low priority, often extremely verbose, information.
	 */
	case trace = 5
}

// MARK: - FfiConverterTypeLogLevel
public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
	typealias SwiftType = LogLevel

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .error

		case 2: return .warn

		case 3: return .info

		case 4: return .debug

		case 5: return .trace

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
		switch value {
		case .error:
			writeInt(&buf, Int32(1))

		case .warn:
			writeInt(&buf, Int32(2))

		case .info:
			writeInt(&buf, Int32(3))

		case .debug:
			writeInt(&buf, Int32(4))

		case .trace:
			writeInt(&buf, Int32(5))
		}
	}
}

public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
	try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
	FfiConverterTypeLogLevel.lower(value)
}

// MARK: - LogLevel + Sendable
extension LogLevel: Sendable {}

// MARK: - LogLevel + Equatable, Hashable
extension LogLevel: Equatable, Hashable {}

// MARK: - ManifestEncounteredComponentAddress
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of all the encountered addresses in the manifest.
 * This is to be primarily used for the "using dApps" section of the wallet's tx review screen.
 */

public enum ManifestEncounteredComponentAddress {
	case component(ComponentAddress
	)
	case locker(LockerAddress
	)
}

// MARK: - FfiConverterTypeManifestEncounteredComponentAddress
public struct FfiConverterTypeManifestEncounteredComponentAddress: FfiConverterRustBuffer {
	typealias SwiftType = ManifestEncounteredComponentAddress

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestEncounteredComponentAddress {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .component(FfiConverterTypeComponentAddress.read(from: &buf)
			)

		case 2: return try .locker(FfiConverterTypeLockerAddress.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ManifestEncounteredComponentAddress, into buf: inout [UInt8]) {
		switch value {
		case let .component(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeComponentAddress.write(v1, into: &buf)

		case let .locker(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeLockerAddress.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeManifestEncounteredComponentAddress_lift(_ buf: RustBuffer) throws -> ManifestEncounteredComponentAddress {
	try FfiConverterTypeManifestEncounteredComponentAddress.lift(buf)
}

public func FfiConverterTypeManifestEncounteredComponentAddress_lower(_ value: ManifestEncounteredComponentAddress) -> RustBuffer {
	FfiConverterTypeManifestEncounteredComponentAddress.lower(value)
}

// MARK: - ManifestEncounteredComponentAddress + Sendable
extension ManifestEncounteredComponentAddress: Sendable {}

// MARK: - ManifestEncounteredComponentAddress + Equatable, Hashable
extension ManifestEncounteredComponentAddress: Equatable, Hashable {}

// MARK: - Message
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Message {
	case plainText(plaintext: PlaintextMessage
	)
	case none
}

// MARK: - FfiConverterTypeMessage
public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
	typealias SwiftType = Message

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .plainText(plaintext: FfiConverterTypePlaintextMessage.read(from: &buf)
			)

		case 2: return .none

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: Message, into buf: inout [UInt8]) {
		switch value {
		case let .plainText(plaintext):
			writeInt(&buf, Int32(1))
			FfiConverterTypePlaintextMessage.write(plaintext, into: &buf)

		case .none:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
	try FfiConverterTypeMessage.lift(buf)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
	FfiConverterTypeMessage.lower(value)
}

// MARK: - Message + Sendable
extension Message: Sendable {}

// MARK: - Message + Equatable, Hashable
extension Message: Equatable, Hashable {}

// MARK: - MessageContents
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * We explicitly mark content as either String or Bytes - this distinguishes (along with the mime type)
 * whether the message is intended to be displayable as text, or not.
 *
 * This data model ensures that messages intended to be displayable as text are valid unicode strings.
 */

public enum MessageContents {
	case stringMessage(string: String
	)
	case binaryMessage(bagOfBytes: BagOfBytes
	)
}

// MARK: - FfiConverterTypeMessageContents
public struct FfiConverterTypeMessageContents: FfiConverterRustBuffer {
	typealias SwiftType = MessageContents

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageContents {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .stringMessage(string: FfiConverterString.read(from: &buf)
			)

		case 2: return try .binaryMessage(bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: MessageContents, into buf: inout [UInt8]) {
		switch value {
		case let .stringMessage(string):
			writeInt(&buf, Int32(1))
			FfiConverterString.write(string, into: &buf)

		case let .binaryMessage(bagOfBytes):
			writeInt(&buf, Int32(2))
			FfiConverterTypeBagOfBytes.write(bagOfBytes, into: &buf)
		}
	}
}

public func FfiConverterTypeMessageContents_lift(_ buf: RustBuffer) throws -> MessageContents {
	try FfiConverterTypeMessageContents.lift(buf)
}

public func FfiConverterTypeMessageContents_lower(_ value: MessageContents) -> RustBuffer {
	FfiConverterTypeMessageContents.lower(value)
}

// MARK: - MessageContents + Sendable
extension MessageContents: Sendable {}

// MARK: - MessageContents + Equatable, Hashable
extension MessageContents: Equatable, Hashable {}

// MARK: - MessageV2
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageV2 {
	case plainText(plaintext: PlaintextMessage
	)
	case none
}

// MARK: - FfiConverterTypeMessageV2
public struct FfiConverterTypeMessageV2: FfiConverterRustBuffer {
	typealias SwiftType = MessageV2

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageV2 {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .plainText(plaintext: FfiConverterTypePlaintextMessage.read(from: &buf)
			)

		case 2: return .none

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: MessageV2, into buf: inout [UInt8]) {
		switch value {
		case let .plainText(plaintext):
			writeInt(&buf, Int32(1))
			FfiConverterTypePlaintextMessage.write(plaintext, into: &buf)

		case .none:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeMessageV2_lift(_ buf: RustBuffer) throws -> MessageV2 {
	try FfiConverterTypeMessageV2.lift(buf)
}

public func FfiConverterTypeMessageV2_lower(_ value: MessageV2) -> RustBuffer {
	FfiConverterTypeMessageV2.lower(value)
}

// MARK: - MessageV2 + Sendable
extension MessageV2: Sendable {}

// MARK: - MessageV2 + Equatable, Hashable
extension MessageV2: Equatable, Hashable {}

// MARK: - NetworkId
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NetworkId: UInt8 {
	/**
	 * Mainnet (0x01 / 0d01)
	 *
	 * The Radix public network.
	 *
	 * https://github.com/radixdlt/radixdlt-scrypto/blob/v1.0.1/radix-engine-common/src/network/mod.rs#L79
	 */
	case mainnet = 1
	/**
	 * Stokenet (0x02 / 0d02)
	 *
	 * The public testnet for Radix.
	 *
	 * https://github.com/radixdlt/radixdlt-scrypto/blob/v1.0.1/radix-engine-common/src/network/mod.rs#L71
	 */
	case stokenet = 2
	/**
	 * Adapanet (0x0a / 0d10
	 */
	case adapanet = 10
	/**
	 * Nebunet (0x0b / 0d11 )
	 *
	 * The first Betanet of Babylon
	 */
	case nebunet = 11
	/**
	 * Kisharnet (0x0c / 0d12)
	 *
	 * The first release candidate of Babylon (RCnet v1)
	 */
	case kisharnet = 12
	/**
	 * Ansharnet (0x0d / 0d13)
	 *
	 * The second release candidate of Babylon (RCnet v2)
	 */
	case ansharnet = 13
	/**
	 * Zabanet (0x0e / 0d14)
	 *
	 * The third release candidate of Babylon (RCnet v3)
	 */
	case zabanet = 14
	/**
	 * Enkinet (0x21 / 0d33)
	 *
	 * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L94
	 */
	case enkinet = 33
	/**
	 * Hammunet
	 * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L95
	 * Decimal value: 34
	 */
	case hammunet = 34
	/**
	 * Nergalnet
	 * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L96
	 * Decimal value: 35
	 */
	case nergalnet = 35
	/**
	 * Mardunet
	 * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L97
	 * Decimal value: 36
	 */
	case mardunet = 36
	/**
	 * Simulator (0xf2 / 0d242)
	 */
	case simulator = 242
}

// MARK: - FfiConverterTypeNetworkID
public struct FfiConverterTypeNetworkID: FfiConverterRustBuffer {
	typealias SwiftType = NetworkId

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkId {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .mainnet

		case 2: return .stokenet

		case 3: return .adapanet

		case 4: return .nebunet

		case 5: return .kisharnet

		case 6: return .ansharnet

		case 7: return .zabanet

		case 8: return .enkinet

		case 9: return .hammunet

		case 10: return .nergalnet

		case 11: return .mardunet

		case 12: return .simulator

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: NetworkId, into buf: inout [UInt8]) {
		switch value {
		case .mainnet:
			writeInt(&buf, Int32(1))

		case .stokenet:
			writeInt(&buf, Int32(2))

		case .adapanet:
			writeInt(&buf, Int32(3))

		case .nebunet:
			writeInt(&buf, Int32(4))

		case .kisharnet:
			writeInt(&buf, Int32(5))

		case .ansharnet:
			writeInt(&buf, Int32(6))

		case .zabanet:
			writeInt(&buf, Int32(7))

		case .enkinet:
			writeInt(&buf, Int32(8))

		case .hammunet:
			writeInt(&buf, Int32(9))

		case .nergalnet:
			writeInt(&buf, Int32(10))

		case .mardunet:
			writeInt(&buf, Int32(11))

		case .simulator:
			writeInt(&buf, Int32(12))
		}
	}
}

public func FfiConverterTypeNetworkID_lift(_ buf: RustBuffer) throws -> NetworkId {
	try FfiConverterTypeNetworkID.lift(buf)
}

public func FfiConverterTypeNetworkID_lower(_ value: NetworkId) -> RustBuffer {
	FfiConverterTypeNetworkID.lower(value)
}

// MARK: - NetworkId + Sendable
extension NetworkId: Sendable {}

// MARK: - NetworkId + Equatable, Hashable
extension NetworkId: Equatable, Hashable {}

// MARK: - NetworkMethod
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NetworkMethod {
	case post
	case get
	case head
}

// MARK: - FfiConverterTypeNetworkMethod
public struct FfiConverterTypeNetworkMethod: FfiConverterRustBuffer {
	typealias SwiftType = NetworkMethod

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkMethod {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .post

		case 2: return .get

		case 3: return .head

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: NetworkMethod, into buf: inout [UInt8]) {
		switch value {
		case .post:
			writeInt(&buf, Int32(1))

		case .get:
			writeInt(&buf, Int32(2))

		case .head:
			writeInt(&buf, Int32(3))
		}
	}
}

public func FfiConverterTypeNetworkMethod_lift(_ buf: RustBuffer) throws -> NetworkMethod {
	try FfiConverterTypeNetworkMethod.lift(buf)
}

public func FfiConverterTypeNetworkMethod_lower(_ value: NetworkMethod) -> RustBuffer {
	FfiConverterTypeNetworkMethod.lower(value)
}

// MARK: - NetworkMethod + Sendable
extension NetworkMethod: Sendable {}

// MARK: - NetworkMethod + Equatable, Hashable
extension NetworkMethod: Equatable, Hashable {}

// MARK: - NonFungibleLocalId
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NonFungibleLocalId {
	/**
	 * Unsigned integers, up to u64.
	 *
	 * Create using `NonFungibleLocalId::integer(...)`.
	 */
	case integer(value: UInt64
	)
	/**
	 * String matching `[_0-9a-zA-Z]{1,64}`.
	 *
	 * Create using `NonFungibleLocalId::string(...).unwrap()`.
	 */
	case str(value: NonFungibleLocalIdString
	)
	/**
	 * Bytes, of length between 1 and 64.
	 *
	 * Create using `NonFungibleLocalId::bytes(...).unwrap()`.
	 */
	case bytes(value: NonEmptyMax64Bytes
	)
	/**
	 * RUID, v4, variant 1, big endian. See https://www.rfc-editor.org/rfc/rfc4122
	 *
	 * Create using `NonFungibleLocalId::ruid(...).unwrap()`.
	 */
	case ruid(value: Exactly32Bytes
	)
}

// MARK: - FfiConverterTypeNonFungibleLocalId
public struct FfiConverterTypeNonFungibleLocalId: FfiConverterRustBuffer {
	typealias SwiftType = NonFungibleLocalId

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalId {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .integer(value: FfiConverterUInt64.read(from: &buf)
			)

		case 2: return try .str(value: FfiConverterTypeNonFungibleLocalIdString.read(from: &buf)
			)

		case 3: return try .bytes(value: FfiConverterTypeNonEmptyMax64Bytes.read(from: &buf)
			)

		case 4: return try .ruid(value: FfiConverterTypeExactly32Bytes.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: NonFungibleLocalId, into buf: inout [UInt8]) {
		switch value {
		case let .integer(value):
			writeInt(&buf, Int32(1))
			FfiConverterUInt64.write(value, into: &buf)

		case let .str(value):
			writeInt(&buf, Int32(2))
			FfiConverterTypeNonFungibleLocalIdString.write(value, into: &buf)

		case let .bytes(value):
			writeInt(&buf, Int32(3))
			FfiConverterTypeNonEmptyMax64Bytes.write(value, into: &buf)

		case let .ruid(value):
			writeInt(&buf, Int32(4))
			FfiConverterTypeExactly32Bytes.write(value, into: &buf)
		}
	}
}

public func FfiConverterTypeNonFungibleLocalId_lift(_ buf: RustBuffer) throws -> NonFungibleLocalId {
	try FfiConverterTypeNonFungibleLocalId.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalId_lower(_ value: NonFungibleLocalId) -> RustBuffer {
	FfiConverterTypeNonFungibleLocalId.lower(value)
}

// MARK: - NonFungibleLocalId + Sendable
extension NonFungibleLocalId: Sendable {}

// MARK: - NonFungibleLocalId + Equatable, Hashable
extension NonFungibleLocalId: Equatable, Hashable {}

// MARK: - NonFungibleResourceIndicator
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NonFungibleResourceIndicator {
	case byAll(predictedAmount: PredictedDecimal, predictedIds: PredictedNonFungibleLocalIds)
	case byAmount(amount: Decimal192, predictedIds: PredictedNonFungibleLocalIds)
	case byIds(ids: [NonFungibleLocalId]
	)
}

// MARK: - FfiConverterTypeNonFungibleResourceIndicator
public struct FfiConverterTypeNonFungibleResourceIndicator: FfiConverterRustBuffer {
	typealias SwiftType = NonFungibleResourceIndicator

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleResourceIndicator {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .byAll(predictedAmount: FfiConverterTypePredictedDecimal.read(from: &buf), predictedIds: FfiConverterTypePredictedNonFungibleLocalIds.read(from: &buf))

		case 2: return try .byAmount(amount: FfiConverterTypeDecimal192.read(from: &buf), predictedIds: FfiConverterTypePredictedNonFungibleLocalIds.read(from: &buf))

		case 3: return try .byIds(ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: NonFungibleResourceIndicator, into buf: inout [UInt8]) {
		switch value {
		case let .byAll(predictedAmount, predictedIds):
			writeInt(&buf, Int32(1))
			FfiConverterTypePredictedDecimal.write(predictedAmount, into: &buf)
			FfiConverterTypePredictedNonFungibleLocalIds.write(predictedIds, into: &buf)

		case let .byAmount(amount, predictedIds):
			writeInt(&buf, Int32(2))
			FfiConverterTypeDecimal192.write(amount, into: &buf)
			FfiConverterTypePredictedNonFungibleLocalIds.write(predictedIds, into: &buf)

		case let .byIds(ids):
			writeInt(&buf, Int32(3))
			FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
		}
	}
}

public func FfiConverterTypeNonFungibleResourceIndicator_lift(_ buf: RustBuffer) throws -> NonFungibleResourceIndicator {
	try FfiConverterTypeNonFungibleResourceIndicator.lift(buf)
}

public func FfiConverterTypeNonFungibleResourceIndicator_lower(_ value: NonFungibleResourceIndicator) -> RustBuffer {
	FfiConverterTypeNonFungibleResourceIndicator.lower(value)
}

// MARK: - NonFungibleResourceIndicator + Sendable
extension NonFungibleResourceIndicator: Sendable {}

// MARK: - NonFungibleResourceIndicator + Equatable, Hashable
extension NonFungibleResourceIndicator: Equatable, Hashable {}

// MARK: - PersonaDataNameVariant
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PersonaDataNameVariant {
	case western
	case eastern
}

// MARK: - FfiConverterTypePersonaDataNameVariant
public struct FfiConverterTypePersonaDataNameVariant: FfiConverterRustBuffer {
	typealias SwiftType = PersonaDataNameVariant

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataNameVariant {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .western

		case 2: return .eastern

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: PersonaDataNameVariant, into buf: inout [UInt8]) {
		switch value {
		case .western:
			writeInt(&buf, Int32(1))

		case .eastern:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypePersonaDataNameVariant_lift(_ buf: RustBuffer) throws -> PersonaDataNameVariant {
	try FfiConverterTypePersonaDataNameVariant.lift(buf)
}

public func FfiConverterTypePersonaDataNameVariant_lower(_ value: PersonaDataNameVariant) -> RustBuffer {
	FfiConverterTypePersonaDataNameVariant.lower(value)
}

// MARK: - PersonaDataNameVariant + Sendable
extension PersonaDataNameVariant: Sendable {}

// MARK: - PersonaDataNameVariant + Equatable, Hashable
extension PersonaDataNameVariant: Equatable, Hashable {}

// MARK: - PoolKind
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The kind of the Pool, either One, Two or Multi resources.
 */

public enum PoolKind {
	/**
	 * A Pool to which user can contribute liquidity of a single
	 * resource kind.
	 */
	case oneResource
	/**
	 * A Pool to which user can contribute liquidity of two different
	 * resources
	 */
	case twoResources
	/**
	 * A Pool to which user can contribute liquidity of many different
	 * resources
	 */
	case multiResources
}

// MARK: - FfiConverterTypePoolKind
public struct FfiConverterTypePoolKind: FfiConverterRustBuffer {
	typealias SwiftType = PoolKind

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PoolKind {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .oneResource

		case 2: return .twoResources

		case 3: return .multiResources

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: PoolKind, into buf: inout [UInt8]) {
		switch value {
		case .oneResource:
			writeInt(&buf, Int32(1))

		case .twoResources:
			writeInt(&buf, Int32(2))

		case .multiResources:
			writeInt(&buf, Int32(3))
		}
	}
}

public func FfiConverterTypePoolKind_lift(_ buf: RustBuffer) throws -> PoolKind {
	try FfiConverterTypePoolKind.lift(buf)
}

public func FfiConverterTypePoolKind_lower(_ value: PoolKind) -> RustBuffer {
	FfiConverterTypePoolKind.lower(value)
}

// MARK: - PoolKind + Sendable
extension PoolKind: Sendable {}

// MARK: - PoolKind + Equatable, Hashable
extension PoolKind: Equatable, Hashable {}

// MARK: - PreAuthToReview
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * This is the result of the Pre-Auth preview analysis.
 * It contains all the information needed to compute and display the transaction details to the user.
 */

public enum PreAuthToReview {
	case open(PreAuthOpenManifest
	)
	case enclosed(PreAuthEnclosedManifest
	)
}

// MARK: - FfiConverterTypePreAuthToReview
public struct FfiConverterTypePreAuthToReview: FfiConverterRustBuffer {
	typealias SwiftType = PreAuthToReview

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreAuthToReview {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .open(FfiConverterTypePreAuthOpenManifest.read(from: &buf)
			)

		case 2: return try .enclosed(FfiConverterTypePreAuthEnclosedManifest.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: PreAuthToReview, into buf: inout [UInt8]) {
		switch value {
		case let .open(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypePreAuthOpenManifest.write(v1, into: &buf)

		case let .enclosed(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypePreAuthEnclosedManifest.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypePreAuthToReview_lift(_ buf: RustBuffer) throws -> PreAuthToReview {
	try FfiConverterTypePreAuthToReview.lift(buf)
}

public func FfiConverterTypePreAuthToReview_lower(_ value: PreAuthToReview) -> RustBuffer {
	FfiConverterTypePreAuthToReview.lower(value)
}

// MARK: - PreAuthToReview + Sendable
extension PreAuthToReview: Sendable {}

// MARK: - PreAuthToReview + Equatable, Hashable
extension PreAuthToReview: Equatable, Hashable {}

// MARK: - PreAuthorizationStatus
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * This is the result of the Pre-Authorization status polling for a given Subintent.
 */

public enum PreAuthorizationStatus {
	/**
	 * The Pre-Authorization has successfully been submitted in a transaction with the given intent hash.
	 */
	case success(intentHash: TransactionIntentHash
	)
	/**
	 * The Pre-Authorization has expired before being successfully submitted.
	 */
	case expired
}

// MARK: - FfiConverterTypePreAuthorizationStatus
public struct FfiConverterTypePreAuthorizationStatus: FfiConverterRustBuffer {
	typealias SwiftType = PreAuthorizationStatus

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreAuthorizationStatus {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .success(intentHash: FfiConverterTypeTransactionIntentHash.read(from: &buf)
			)

		case 2: return .expired

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: PreAuthorizationStatus, into buf: inout [UInt8]) {
		switch value {
		case let .success(intentHash):
			writeInt(&buf, Int32(1))
			FfiConverterTypeTransactionIntentHash.write(intentHash, into: &buf)

		case .expired:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypePreAuthorizationStatus_lift(_ buf: RustBuffer) throws -> PreAuthorizationStatus {
	try FfiConverterTypePreAuthorizationStatus.lift(buf)
}

public func FfiConverterTypePreAuthorizationStatus_lower(_ value: PreAuthorizationStatus) -> RustBuffer {
	FfiConverterTypePreAuthorizationStatus.lower(value)
}

// MARK: - PreAuthorizationStatus + Sendable
extension PreAuthorizationStatus: Sendable {}

// MARK: - PreAuthorizationStatus + Equatable, Hashable
extension PreAuthorizationStatus: Equatable, Hashable {}

// MARK: - ProfileFileContents
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of analyzing a file (bytes), containing either a Profile
 * which we were able to successfully JSON deserialize from the bytes,
 * or EncryptedProfile for which wallets will continue prompting the
 * user for an encryption password and then call JSON deserialize
 * of `EncryptedProfileSnapshot` using [`Profile::new_from_encryption_bytes`](Profile::new_from_encryption_bytes)
 * or if we failed to parse as Profile and `EncryptedProfileSnapshot`
 * then `NotProfile` is used, indicating that the bytes is not at all
 * a Profile.
 */

public enum ProfileFileContents {
	/**
	 * The JSON deserialized Profile from some bytes.
	 */
	case plaintextProfile(Profile
	)
	/**
	 * We successfully JSON deserialized the bytes into
	 * `EncryptedProfileSnapshot`, the wallets should proceed
	 * with asking the user for the decryption password.
	 */
	case encryptedProfile
	/**
	 * The bytes is neither a valid `Profile` nor `EncryptedProfile`,
	 * it is either a corrupt file or it is not at all a Profile file,
	 * contrary to the users beliefs (or the user accidentally selected
	 * a random file...)
	 */
	case notProfile
}

// MARK: - FfiConverterTypeProfileFileContents
public struct FfiConverterTypeProfileFileContents: FfiConverterRustBuffer {
	typealias SwiftType = ProfileFileContents

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileFileContents {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .plaintextProfile(FfiConverterTypeProfile.read(from: &buf)
			)

		case 2: return .encryptedProfile

		case 3: return .notProfile

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ProfileFileContents, into buf: inout [UInt8]) {
		switch value {
		case let .plaintextProfile(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeProfile.write(v1, into: &buf)

		case .encryptedProfile:
			writeInt(&buf, Int32(2))

		case .notProfile:
			writeInt(&buf, Int32(3))
		}
	}
}

public func FfiConverterTypeProfileFileContents_lift(_ buf: RustBuffer) throws -> ProfileFileContents {
	try FfiConverterTypeProfileFileContents.lift(buf)
}

public func FfiConverterTypeProfileFileContents_lower(_ value: ProfileFileContents) -> RustBuffer {
	FfiConverterTypeProfileFileContents.lower(value)
}

// MARK: - ProfileFileContents + Sendable
extension ProfileFileContents: Sendable {}

// MARK: - ProfileFileContents + Equatable, Hashable
extension ProfileFileContents: Equatable, Hashable {}

// MARK: - ProfileSnapshotVersion
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The version of the Profile Snapshot data format (JSON).
 */

public enum ProfileSnapshotVersion: UInt16 {
	/**
	 * The version we went live with on Babylon mainnet 2023-09-28,
	 * shipped with iOS 1.0.0 (7) and Android v 1.0.0.
	 */
	case v100 = 100
}

// MARK: - FfiConverterTypeProfileSnapshotVersion
public struct FfiConverterTypeProfileSnapshotVersion: FfiConverterRustBuffer {
	typealias SwiftType = ProfileSnapshotVersion

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileSnapshotVersion {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .v100

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ProfileSnapshotVersion, into buf: inout [UInt8]) {
		switch value {
		case .v100:
			writeInt(&buf, Int32(1))
		}
	}
}

public func FfiConverterTypeProfileSnapshotVersion_lift(_ buf: RustBuffer) throws -> ProfileSnapshotVersion {
	try FfiConverterTypeProfileSnapshotVersion.lift(buf)
}

public func FfiConverterTypeProfileSnapshotVersion_lower(_ value: ProfileSnapshotVersion) -> RustBuffer {
	FfiConverterTypeProfileSnapshotVersion.lower(value)
}

// MARK: - ProfileSnapshotVersion + Sendable
extension ProfileSnapshotVersion: Sendable {}

// MARK: - ProfileSnapshotVersion + Equatable, Hashable
extension ProfileSnapshotVersion: Equatable, Hashable {}

// MARK: - ProfileState
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ProfileState {
	/**
	 * When no profile exists in secure storage when OS is booted.
	 */
	case none
	/**
	 * When the profile snapshot retrieved from secure storage failed to convert into a
	 * valid Profile.
	 */
	case incompatible(CommonError
	)
	/**
	 * When a valid 'Profile' exists. This can either happen when the os boots, or a profile is
	 * restored, or the user creates a new profile.
	 */
	case loaded(Profile
	)
}

// MARK: - FfiConverterTypeProfileState
public struct FfiConverterTypeProfileState: FfiConverterRustBuffer {
	typealias SwiftType = ProfileState

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileState {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .none

		case 2: return try .incompatible(FfiConverterTypeCommonError.read(from: &buf)
			)

		case 3: return try .loaded(FfiConverterTypeProfile.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ProfileState, into buf: inout [UInt8]) {
		switch value {
		case .none:
			writeInt(&buf, Int32(1))

		case let .incompatible(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeCommonError.write(v1, into: &buf)

		case let .loaded(v1):
			writeInt(&buf, Int32(3))
			FfiConverterTypeProfile.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeProfileState_lift(_ buf: RustBuffer) throws -> ProfileState {
	try FfiConverterTypeProfileState.lift(buf)
}

public func FfiConverterTypeProfileState_lower(_ value: ProfileState) -> RustBuffer {
	FfiConverterTypeProfileState.lower(value)
}

// MARK: - ProfileState + Sendable
extension ProfileState: Sendable {}

// MARK: - ProfileState + Equatable, Hashable
extension ProfileState: Equatable, Hashable {}

// MARK: - PublicKey
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of supported public keys on different curves, supported
 * curves are `secp256k1` and `Curve25519`
 */

public enum PublicKey {
	/**
	 * An Ed25519 public key used to verify cryptographic signatures.
	 */
	case ed25519(Ed25519PublicKey
	)
	/**
	 * A secp256k1 public key used to verify cryptographic signatures (ECDSA signatures).
	 */
	case secp256k1(Secp256k1PublicKey
	)
}

// MARK: - FfiConverterTypePublicKey
public struct FfiConverterTypePublicKey: FfiConverterRustBuffer {
	typealias SwiftType = PublicKey

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .ed25519(FfiConverterTypeEd25519PublicKey.read(from: &buf)
			)

		case 2: return try .secp256k1(FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
		switch value {
		case let .ed25519(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeEd25519PublicKey.write(v1, into: &buf)

		case let .secp256k1(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeSecp256k1PublicKey.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypePublicKey_lift(_ buf: RustBuffer) throws -> PublicKey {
	try FfiConverterTypePublicKey.lift(buf)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
	FfiConverterTypePublicKey.lower(value)
}

// MARK: - PublicKey + Sendable
extension PublicKey: Sendable {}

// MARK: - PublicKey + Equatable, Hashable
extension PublicKey: Equatable, Hashable {}

// MARK: - PublicKeyHash
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Hashes of public keys, either Ed25519PublicKey or Secp256k1PublicKey
 */

public enum PublicKeyHash {
	case ed25519(value: Exactly29Bytes
	)
	case secp256k1(value: Exactly29Bytes
	)
}

// MARK: - FfiConverterTypePublicKeyHash
public struct FfiConverterTypePublicKeyHash: FfiConverterRustBuffer {
	typealias SwiftType = PublicKeyHash

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKeyHash {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .ed25519(value: FfiConverterTypeExactly29Bytes.read(from: &buf)
			)

		case 2: return try .secp256k1(value: FfiConverterTypeExactly29Bytes.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: PublicKeyHash, into buf: inout [UInt8]) {
		switch value {
		case let .ed25519(value):
			writeInt(&buf, Int32(1))
			FfiConverterTypeExactly29Bytes.write(value, into: &buf)

		case let .secp256k1(value):
			writeInt(&buf, Int32(2))
			FfiConverterTypeExactly29Bytes.write(value, into: &buf)
		}
	}
}

public func FfiConverterTypePublicKeyHash_lift(_ buf: RustBuffer) throws -> PublicKeyHash {
	try FfiConverterTypePublicKeyHash.lift(buf)
}

public func FfiConverterTypePublicKeyHash_lower(_ value: PublicKeyHash) -> RustBuffer {
	FfiConverterTypePublicKeyHash.lower(value)
}

// MARK: - PublicKeyHash + Sendable
extension PublicKeyHash: Sendable {}

// MARK: - PublicKeyHash + Equatable, Hashable
extension PublicKeyHash: Equatable, Hashable {}

// MARK: - RadixConnectPurpose
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
 * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
 * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
 */

public enum RadixConnectPurpose {
	case general
	case unknown
}

// MARK: - FfiConverterTypeRadixConnectPurpose
public struct FfiConverterTypeRadixConnectPurpose: FfiConverterRustBuffer {
	typealias SwiftType = RadixConnectPurpose

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectPurpose {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .general

		case 2: return .unknown

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: RadixConnectPurpose, into buf: inout [UInt8]) {
		switch value {
		case .general:
			writeInt(&buf, Int32(1))

		case .unknown:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeRadixConnectPurpose_lift(_ buf: RustBuffer) throws -> RadixConnectPurpose {
	try FfiConverterTypeRadixConnectPurpose.lift(buf)
}

public func FfiConverterTypeRadixConnectPurpose_lower(_ value: RadixConnectPurpose) -> RustBuffer {
	FfiConverterTypeRadixConnectPurpose.lower(value)
}

// MARK: - RadixConnectPurpose + Sendable
extension RadixConnectPurpose: Sendable {}

// MARK: - RadixConnectPurpose + Equatable, Hashable
extension RadixConnectPurpose: Equatable, Hashable {}

// MARK: - RequestedNumberQuantifier
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A quantifier of a quantity, either `atLeast` or `exactly`, as in
 * "I want AT LEAST 3" or "I want EXACTLY 10".
 *
 * This is typically sent by a Dapp when requesting access to accounts
 * or PersonaData.
 */

public enum RequestedNumberQuantifier {
	/**
	 * (Request access to) *exactly* N many of something, where quantity `N` is
	 * not part of this enum, e.g. "I want EXACTLY 2 accounts"
	 */
	case exactly
	/**
	 * (Request access to) *at least* N many of something, where quantity `N` is
	 * not part of this enum, e.g. "I want AT LEAST 3 accounts"
	 */
	case atLeast
}

// MARK: - FfiConverterTypeRequestedNumberQuantifier
public struct FfiConverterTypeRequestedNumberQuantifier: FfiConverterRustBuffer {
	typealias SwiftType = RequestedNumberQuantifier

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedNumberQuantifier {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .exactly

		case 2: return .atLeast

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: RequestedNumberQuantifier, into buf: inout [UInt8]) {
		switch value {
		case .exactly:
			writeInt(&buf, Int32(1))

		case .atLeast:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeRequestedNumberQuantifier_lift(_ buf: RustBuffer) throws -> RequestedNumberQuantifier {
	try FfiConverterTypeRequestedNumberQuantifier.lift(buf)
}

public func FfiConverterTypeRequestedNumberQuantifier_lower(_ value: RequestedNumberQuantifier) -> RustBuffer {
	FfiConverterTypeRequestedNumberQuantifier.lower(value)
}

// MARK: - RequestedNumberQuantifier + Sendable
extension RequestedNumberQuantifier: Sendable {}

// MARK: - RequestedNumberQuantifier + Equatable, Hashable
extension RequestedNumberQuantifier: Equatable, Hashable {}

// MARK: - ReservedInstruction
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The set of instructions that is only allowed in manifests created by the
 * wallet itself.
 */

public enum ReservedInstruction {
	case accountLockFee
	case accountSecurify
	case identitySecurify
	case accessControllerMethod
}

// MARK: - FfiConverterTypeReservedInstruction
public struct FfiConverterTypeReservedInstruction: FfiConverterRustBuffer {
	typealias SwiftType = ReservedInstruction

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReservedInstruction {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .accountLockFee

		case 2: return .accountSecurify

		case 3: return .identitySecurify

		case 4: return .accessControllerMethod

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ReservedInstruction, into buf: inout [UInt8]) {
		switch value {
		case .accountLockFee:
			writeInt(&buf, Int32(1))

		case .accountSecurify:
			writeInt(&buf, Int32(2))

		case .identitySecurify:
			writeInt(&buf, Int32(3))

		case .accessControllerMethod:
			writeInt(&buf, Int32(4))
		}
	}
}

public func FfiConverterTypeReservedInstruction_lift(_ buf: RustBuffer) throws -> ReservedInstruction {
	try FfiConverterTypeReservedInstruction.lift(buf)
}

public func FfiConverterTypeReservedInstruction_lower(_ value: ReservedInstruction) -> RustBuffer {
	FfiConverterTypeReservedInstruction.lower(value)
}

// MARK: - ReservedInstruction + Sendable
extension ReservedInstruction: Sendable {}

// MARK: - ReservedInstruction + Equatable, Hashable
extension ReservedInstruction: Equatable, Hashable {}

// MARK: - ResourceIdentifier
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum representation of an resource for which the user can set up its preferences.
 */

public enum ResourceIdentifier {
	case fungible(ResourceAddress
	)
	case nonFungible(ResourceAddress
	)
	case poolUnit(PoolAddress
	)
}

// MARK: - FfiConverterTypeResourceIdentifier
public struct FfiConverterTypeResourceIdentifier: FfiConverterRustBuffer {
	typealias SwiftType = ResourceIdentifier

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceIdentifier {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .fungible(FfiConverterTypeResourceAddress.read(from: &buf)
			)

		case 2: return try .nonFungible(FfiConverterTypeResourceAddress.read(from: &buf)
			)

		case 3: return try .poolUnit(FfiConverterTypePoolAddress.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ResourceIdentifier, into buf: inout [UInt8]) {
		switch value {
		case let .fungible(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeResourceAddress.write(v1, into: &buf)

		case let .nonFungible(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeResourceAddress.write(v1, into: &buf)

		case let .poolUnit(v1):
			writeInt(&buf, Int32(3))
			FfiConverterTypePoolAddress.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeResourceIdentifier_lift(_ buf: RustBuffer) throws -> ResourceIdentifier {
	try FfiConverterTypeResourceIdentifier.lift(buf)
}

public func FfiConverterTypeResourceIdentifier_lower(_ value: ResourceIdentifier) -> RustBuffer {
	FfiConverterTypeResourceIdentifier.lower(value)
}

// MARK: - ResourceIdentifier + Sendable
extension ResourceIdentifier: Sendable {}

// MARK: - ResourceIdentifier + Equatable, Hashable
extension ResourceIdentifier: Equatable, Hashable {}

// MARK: - ResourceIndicator
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourceIndicator {
	case fungible(resourceAddress: ResourceAddress, indicator: FungibleResourceIndicator)
	case nonFungible(resourceAddress: ResourceAddress, indicator: NonFungibleResourceIndicator)
}

// MARK: - FfiConverterTypeResourceIndicator
public struct FfiConverterTypeResourceIndicator: FfiConverterRustBuffer {
	typealias SwiftType = ResourceIndicator

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceIndicator {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .fungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), indicator: FfiConverterTypeFungibleResourceIndicator.read(from: &buf))

		case 2: return try .nonFungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), indicator: FfiConverterTypeNonFungibleResourceIndicator.read(from: &buf))

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ResourceIndicator, into buf: inout [UInt8]) {
		switch value {
		case let .fungible(resourceAddress, indicator):
			writeInt(&buf, Int32(1))
			FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
			FfiConverterTypeFungibleResourceIndicator.write(indicator, into: &buf)

		case let .nonFungible(resourceAddress, indicator):
			writeInt(&buf, Int32(2))
			FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
			FfiConverterTypeNonFungibleResourceIndicator.write(indicator, into: &buf)
		}
	}
}

public func FfiConverterTypeResourceIndicator_lift(_ buf: RustBuffer) throws -> ResourceIndicator {
	try FfiConverterTypeResourceIndicator.lift(buf)
}

public func FfiConverterTypeResourceIndicator_lower(_ value: ResourceIndicator) -> RustBuffer {
	FfiConverterTypeResourceIndicator.lower(value)
}

// MARK: - ResourceIndicator + Sendable
extension ResourceIndicator: Sendable {}

// MARK: - ResourceIndicator + Equatable, Hashable
extension ResourceIndicator: Equatable, Hashable {}

// MARK: - ResourceOrNonFungible
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The addresses that can be added as exception to the `DepositRule`
 */

public enum ResourceOrNonFungible {
	case resource(value: ResourceAddress
	)
	case nonFungible(value: NonFungibleGlobalId
	)
}

// MARK: - FfiConverterTypeResourceOrNonFungible
public struct FfiConverterTypeResourceOrNonFungible: FfiConverterRustBuffer {
	typealias SwiftType = ResourceOrNonFungible

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceOrNonFungible {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .resource(value: FfiConverterTypeResourceAddress.read(from: &buf)
			)

		case 2: return try .nonFungible(value: FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ResourceOrNonFungible, into buf: inout [UInt8]) {
		switch value {
		case let .resource(value):
			writeInt(&buf, Int32(1))
			FfiConverterTypeResourceAddress.write(value, into: &buf)

		case let .nonFungible(value):
			writeInt(&buf, Int32(2))
			FfiConverterTypeNonFungibleGlobalId.write(value, into: &buf)
		}
	}
}

public func FfiConverterTypeResourceOrNonFungible_lift(_ buf: RustBuffer) throws -> ResourceOrNonFungible {
	try FfiConverterTypeResourceOrNonFungible.lift(buf)
}

public func FfiConverterTypeResourceOrNonFungible_lower(_ value: ResourceOrNonFungible) -> RustBuffer {
	FfiConverterTypeResourceOrNonFungible.lower(value)
}

// MARK: - ResourceOrNonFungible + Sendable
extension ResourceOrNonFungible: Sendable {}

// MARK: - ResourceOrNonFungible + Equatable, Hashable
extension ResourceOrNonFungible: Equatable, Hashable {}

// MARK: - ResourcePreference
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourcePreference {
	case allowed
	case disallowed
}

// MARK: - FfiConverterTypeResourcePreference
public struct FfiConverterTypeResourcePreference: FfiConverterRustBuffer {
	typealias SwiftType = ResourcePreference

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreference {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .allowed

		case 2: return .disallowed

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ResourcePreference, into buf: inout [UInt8]) {
		switch value {
		case .allowed:
			writeInt(&buf, Int32(1))

		case .disallowed:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeResourcePreference_lift(_ buf: RustBuffer) throws -> ResourcePreference {
	try FfiConverterTypeResourcePreference.lift(buf)
}

public func FfiConverterTypeResourcePreference_lower(_ value: ResourcePreference) -> RustBuffer {
	FfiConverterTypeResourcePreference.lower(value)
}

// MARK: - ResourcePreference + Sendable
extension ResourcePreference: Sendable {}

// MARK: - ResourcePreference + Equatable, Hashable
extension ResourcePreference: Equatable, Hashable {}

// MARK: - ResourcePreferenceUpdate
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourcePreferenceUpdate {
	case set(value: ResourcePreference
	)
	case remove
}

// MARK: - FfiConverterTypeResourcePreferenceUpdate
public struct FfiConverterTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
	typealias SwiftType = ResourcePreferenceUpdate

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreferenceUpdate {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .set(value: FfiConverterTypeResourcePreference.read(from: &buf)
			)

		case 2: return .remove

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ResourcePreferenceUpdate, into buf: inout [UInt8]) {
		switch value {
		case let .set(value):
			writeInt(&buf, Int32(1))
			FfiConverterTypeResourcePreference.write(value, into: &buf)

		case .remove:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeResourcePreferenceUpdate_lift(_ buf: RustBuffer) throws -> ResourcePreferenceUpdate {
	try FfiConverterTypeResourcePreferenceUpdate.lift(buf)
}

public func FfiConverterTypeResourcePreferenceUpdate_lower(_ value: ResourcePreferenceUpdate) -> RustBuffer {
	FfiConverterTypeResourcePreferenceUpdate.lower(value)
}

// MARK: - ResourcePreferenceUpdate + Sendable
extension ResourcePreferenceUpdate: Sendable {}

// MARK: - ResourcePreferenceUpdate + Equatable, Hashable
extension ResourcePreferenceUpdate: Equatable, Hashable {}

// MARK: - ResourceSpecifier
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourceSpecifier {
	case fungible(resourceAddress: ResourceAddress, amount: Decimal192)
	case nonFungible(resourceAddress: ResourceAddress, ids: [NonFungibleLocalId])
}

// MARK: - FfiConverterTypeResourceSpecifier
public struct FfiConverterTypeResourceSpecifier: FfiConverterRustBuffer {
	typealias SwiftType = ResourceSpecifier

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceSpecifier {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .fungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), amount: FfiConverterTypeDecimal192.read(from: &buf))

		case 2: return try .nonFungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf))

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ResourceSpecifier, into buf: inout [UInt8]) {
		switch value {
		case let .fungible(resourceAddress, amount):
			writeInt(&buf, Int32(1))
			FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
			FfiConverterTypeDecimal192.write(amount, into: &buf)

		case let .nonFungible(resourceAddress, ids):
			writeInt(&buf, Int32(2))
			FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
			FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
		}
	}
}

public func FfiConverterTypeResourceSpecifier_lift(_ buf: RustBuffer) throws -> ResourceSpecifier {
	try FfiConverterTypeResourceSpecifier.lift(buf)
}

public func FfiConverterTypeResourceSpecifier_lower(_ value: ResourceSpecifier) -> RustBuffer {
	FfiConverterTypeResourceSpecifier.lower(value)
}

// MARK: - ResourceSpecifier + Sendable
extension ResourceSpecifier: Sendable {}

// MARK: - ResourceSpecifier + Equatable, Hashable
extension ResourceSpecifier: Equatable, Hashable {}

// MARK: - ResourceVisibility
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Indicates the visibility of a resource.
 */

public enum ResourceVisibility {
	case hidden
	case visible
}

// MARK: - FfiConverterTypeResourceVisibility
public struct FfiConverterTypeResourceVisibility: FfiConverterRustBuffer {
	typealias SwiftType = ResourceVisibility

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceVisibility {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .hidden

		case 2: return .visible

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: ResourceVisibility, into buf: inout [UInt8]) {
		switch value {
		case .hidden:
			writeInt(&buf, Int32(1))

		case .visible:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeResourceVisibility_lift(_ buf: RustBuffer) throws -> ResourceVisibility {
	try FfiConverterTypeResourceVisibility.lift(buf)
}

public func FfiConverterTypeResourceVisibility_lower(_ value: ResourceVisibility) -> RustBuffer {
	FfiConverterTypeResourceVisibility.lower(value)
}

// MARK: - ResourceVisibility + Sendable
extension ResourceVisibility: Sendable {}

// MARK: - ResourceVisibility + Equatable, Hashable
extension ResourceVisibility: Equatable, Hashable {}

// MARK: - RoundingMode
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Defines the rounding strategy used when you round e.g. `Decimal192`.
 *
 * Following the same naming convention as https://docs.rs/rust_decimal/latest/rust_decimal/enum.RoundingStrategy.html.
 */

public enum RoundingMode {
	/**
	 * The number is always rounded toward positive infinity, e.g. `3.1 -> 4`, `-3.1 -> -3`.
	 */
	case toPositiveInfinity
	/**
	 * The number is always rounded toward negative infinity, e.g. `3.1 -> 3`, `-3.1 -> -4`.
	 */
	case toNegativeInfinity
	/**
	 * The number is always rounded toward zero, e.g. `3.1 -> 3`, `-3.1 -> -3`.
	 */
	case toZero
	/**
	 * The number is always rounded away from zero, e.g. `3.1 -> 4`, `-3.1 -> -4`.
	 */
	case awayFromZero
	/**
	 * The number is rounded to the nearest, and when it is halfway between two others, it's rounded toward zero, e.g. `3.5 -> 3`, `-3.5 -> -3`.
	 */
	case toNearestMidpointTowardZero
	/**
	 * The number is rounded to the nearest, and when it is halfway between two others, it's rounded away from zero, e.g. `3.5 -> 4`, `-3.5 -> -4`.
	 */
	case toNearestMidpointAwayFromZero
	/**
	 * The number is rounded to the nearest, and when it is halfway between two others, it's rounded toward the nearest even number. Also known as "Bankers Rounding".
	 */
	case toNearestMidpointToEven
}

// MARK: - FfiConverterTypeRoundingMode
public struct FfiConverterTypeRoundingMode: FfiConverterRustBuffer {
	typealias SwiftType = RoundingMode

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoundingMode {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .toPositiveInfinity

		case 2: return .toNegativeInfinity

		case 3: return .toZero

		case 4: return .awayFromZero

		case 5: return .toNearestMidpointTowardZero

		case 6: return .toNearestMidpointAwayFromZero

		case 7: return .toNearestMidpointToEven

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: RoundingMode, into buf: inout [UInt8]) {
		switch value {
		case .toPositiveInfinity:
			writeInt(&buf, Int32(1))

		case .toNegativeInfinity:
			writeInt(&buf, Int32(2))

		case .toZero:
			writeInt(&buf, Int32(3))

		case .awayFromZero:
			writeInt(&buf, Int32(4))

		case .toNearestMidpointTowardZero:
			writeInt(&buf, Int32(5))

		case .toNearestMidpointAwayFromZero:
			writeInt(&buf, Int32(6))

		case .toNearestMidpointToEven:
			writeInt(&buf, Int32(7))
		}
	}
}

public func FfiConverterTypeRoundingMode_lift(_ buf: RustBuffer) throws -> RoundingMode {
	try FfiConverterTypeRoundingMode.lift(buf)
}

public func FfiConverterTypeRoundingMode_lower(_ value: RoundingMode) -> RustBuffer {
	FfiConverterTypeRoundingMode.lower(value)
}

// MARK: - RoundingMode + Sendable
extension RoundingMode: Sendable {}

// MARK: - RoundingMode + Equatable, Hashable
extension RoundingMode: Equatable, Hashable {}

// MARK: - Slip10Curve
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Elliptic Curves which the SLIP10 derivation algorithm supports.
 *
 * We use SLIP10 for hierarchical deterministic derivation since we
 * prefer using Curve25519 - which is incompatible with BIP32 (BIP44).
 *
 * For for information see [SLIP10 reference](https://github.com/satoshilabs/slips/blob/master/slip-0010.md)
 */

public enum Slip10Curve {
	/**
	 * Curve25519 which we use for Ed25519 for EdDSA signatures.
	 */
	case curve25519
	/**
	 * The bitcoin curve, used by Radix Olympia and still valid
	 * to support legacy accounts.
	 */
	case secp256k1
}

// MARK: - FfiConverterTypeSLIP10Curve
public struct FfiConverterTypeSLIP10Curve: FfiConverterRustBuffer {
	typealias SwiftType = Slip10Curve

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Slip10Curve {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .curve25519

		case 2: return .secp256k1

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: Slip10Curve, into buf: inout [UInt8]) {
		switch value {
		case .curve25519:
			writeInt(&buf, Int32(1))

		case .secp256k1:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeSLIP10Curve_lift(_ buf: RustBuffer) throws -> Slip10Curve {
	try FfiConverterTypeSLIP10Curve.lift(buf)
}

public func FfiConverterTypeSLIP10Curve_lower(_ value: Slip10Curve) -> RustBuffer {
	FfiConverterTypeSLIP10Curve.lower(value)
}

// MARK: - Slip10Curve + Sendable
extension Slip10Curve: Sendable {}

// MARK: - Slip10Curve + Equatable, Hashable
extension Slip10Curve: Equatable, Hashable {}

// MARK: - SecureStorageAccessErrorKind
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An error kind that might be returned during access to secure storage driver. These errors are
 * android specific and are defined [here](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt#constants_1)
 * Hosts, can print the error message provided by the system, and can ignore the error if
 * it `is_manual_cancellation`.
 */

public enum SecureStorageAccessErrorKind {
	/**
	 * The hardware is unavailable. Try again later.
	 */
	case hardwareUnavailable
	/**
	 * The sensor was unable to process the current image.
	 */
	case unableToProcess
	/**
	 * The current operation has been running too long and has timed out.
	 */
	case timeout
	/**
	 * The operation can't be completed because there is not enough device storage remaining.
	 */
	case noSpace
	/**
	 * The operation was canceled because the biometric sensor is unavailable.
	 * This may happen when the user is switched, the device is locked, or another
	 * pending operation prevents it.
	 */
	case cancelled
	/**
	 * The operation was canceled because the API is locked out due to too many attempts.
	 * This occurs after 5 failed attempts, and lasts for 30 seconds.
	 */
	case lockout
	/**
	 * The operation failed due to a vendor-specific error.
	 * This error kind may be used by hardware vendors to extend this list to cover
	 * errors that don't fall under one of the other predefined categories. Vendors are
	 * responsible for providing the strings for these errors.
	 *
	 * These messages are typically reserved for internal operations such as enrollment
	 * but may be used to express any error that is not otherwise covered.
	 * In this case, applications are expected to show the error message, but they are advised
	 * not to rely on the message ID, since this may vary by vendor and device.
	 */
	case vendor
	/**
	 * The operation was canceled because `Lockout` occurred too many times. Biometric
	 * authentication is disabled until the user unlocks with their device credential
	 * (i.e. PIN, pattern, or password).
	 */
	case lockoutPermanent
	/**
	 * The user canceled the operation.
	 * Upon receiving this, applications should use alternate authentication, such as a password.
	 * The application should also provide the user a way of returning to biometric authentication,
	 * such as a button.
	 */
	case userCancelled
	/**
	 * The user does not have any biometrics enrolled.
	 */
	case noBiometrics
	/**
	 * The device does not have the required authentication hardware.
	 */
	case hardwareNotPresent
	/**
	 * The user pressed the negative button.
	 */
	case negativeButton
	/**
	 * The device does not have pin, pattern, or password set up.
	 */
	case noDeviceCredential
}

// MARK: - FfiConverterTypeSecureStorageAccessErrorKind
public struct FfiConverterTypeSecureStorageAccessErrorKind: FfiConverterRustBuffer {
	typealias SwiftType = SecureStorageAccessErrorKind

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageAccessErrorKind {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .hardwareUnavailable

		case 2: return .unableToProcess

		case 3: return .timeout

		case 4: return .noSpace

		case 5: return .cancelled

		case 6: return .lockout

		case 7: return .vendor

		case 8: return .lockoutPermanent

		case 9: return .userCancelled

		case 10: return .noBiometrics

		case 11: return .hardwareNotPresent

		case 12: return .negativeButton

		case 13: return .noDeviceCredential

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: SecureStorageAccessErrorKind, into buf: inout [UInt8]) {
		switch value {
		case .hardwareUnavailable:
			writeInt(&buf, Int32(1))

		case .unableToProcess:
			writeInt(&buf, Int32(2))

		case .timeout:
			writeInt(&buf, Int32(3))

		case .noSpace:
			writeInt(&buf, Int32(4))

		case .cancelled:
			writeInt(&buf, Int32(5))

		case .lockout:
			writeInt(&buf, Int32(6))

		case .vendor:
			writeInt(&buf, Int32(7))

		case .lockoutPermanent:
			writeInt(&buf, Int32(8))

		case .userCancelled:
			writeInt(&buf, Int32(9))

		case .noBiometrics:
			writeInt(&buf, Int32(10))

		case .hardwareNotPresent:
			writeInt(&buf, Int32(11))

		case .negativeButton:
			writeInt(&buf, Int32(12))

		case .noDeviceCredential:
			writeInt(&buf, Int32(13))
		}
	}
}

public func FfiConverterTypeSecureStorageAccessErrorKind_lift(_ buf: RustBuffer) throws -> SecureStorageAccessErrorKind {
	try FfiConverterTypeSecureStorageAccessErrorKind.lift(buf)
}

public func FfiConverterTypeSecureStorageAccessErrorKind_lower(_ value: SecureStorageAccessErrorKind) -> RustBuffer {
	FfiConverterTypeSecureStorageAccessErrorKind.lower(value)
}

// MARK: - SecureStorageAccessErrorKind + Sendable
extension SecureStorageAccessErrorKind: Sendable {}

// MARK: - SecureStorageAccessErrorKind + Equatable, Hashable
extension SecureStorageAccessErrorKind: Equatable, Hashable {}

// MARK: - SecureStorageKey
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SecureStorageKey {
	case hostId
	case deviceFactorSourceMnemonic(factorSourceId: FactorSourceIdFromHash
	)
	case profileSnapshot(profileId: ProfileId
	)
}

// MARK: - FfiConverterTypeSecureStorageKey
public struct FfiConverterTypeSecureStorageKey: FfiConverterRustBuffer {
	typealias SwiftType = SecureStorageKey

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageKey {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .hostId

		case 2: return try .deviceFactorSourceMnemonic(factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
			)

		case 3: return try .profileSnapshot(profileId: FfiConverterTypeProfileID.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: SecureStorageKey, into buf: inout [UInt8]) {
		switch value {
		case .hostId:
			writeInt(&buf, Int32(1))

		case let .deviceFactorSourceMnemonic(factorSourceId):
			writeInt(&buf, Int32(2))
			FfiConverterTypeFactorSourceIDFromHash.write(factorSourceId, into: &buf)

		case let .profileSnapshot(profileId):
			writeInt(&buf, Int32(3))
			FfiConverterTypeProfileID.write(profileId, into: &buf)
		}
	}
}

public func FfiConverterTypeSecureStorageKey_lift(_ buf: RustBuffer) throws -> SecureStorageKey {
	try FfiConverterTypeSecureStorageKey.lift(buf)
}

public func FfiConverterTypeSecureStorageKey_lower(_ value: SecureStorageKey) -> RustBuffer {
	FfiConverterTypeSecureStorageKey.lower(value)
}

// MARK: - SecureStorageKey + Sendable
extension SecureStorageKey: Sendable {}

// MARK: - SecureStorageKey + Equatable, Hashable
extension SecureStorageKey: Equatable, Hashable {}

// MARK: - SecurityQuestionKind
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SecurityQuestionKind {
	case freeform
}

// MARK: - FfiConverterTypeSecurityQuestionKind
public struct FfiConverterTypeSecurityQuestionKind: FfiConverterRustBuffer {
	typealias SwiftType = SecurityQuestionKind

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionKind {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .freeform

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: SecurityQuestionKind, into buf: inout [UInt8]) {
		switch value {
		case .freeform:
			writeInt(&buf, Int32(1))
		}
	}
}

public func FfiConverterTypeSecurityQuestionKind_lift(_ buf: RustBuffer) throws -> SecurityQuestionKind {
	try FfiConverterTypeSecurityQuestionKind.lift(buf)
}

public func FfiConverterTypeSecurityQuestionKind_lower(_ value: SecurityQuestionKind) -> RustBuffer {
	FfiConverterTypeSecurityQuestionKind.lower(value)
}

// MARK: - SecurityQuestionKind + Sendable
extension SecurityQuestionKind: Sendable {}

// MARK: - SecurityQuestionKind + Equatable, Hashable
extension SecurityQuestionKind: Equatable, Hashable {}

// MARK: - SecurityQuestionsNotProductionReadyKdfScheme
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 *  NOT PRODUCTION READY YET 
 * The KDF algorithm used to derive the decryption key from a combination of answers to security questions.
 *
 * N.B. Not to be confused with the much simpler password based Key Derivation used
 * to encrypt Profile part of manual file export.
 *  NOT PRODUCTION READY YET 
 */

public enum SecurityQuestionsNotProductionReadyKdfScheme {
	/**
	 *  NOT PRODUCTION READY YET 
	 * First iteration of KDF for SecurityQuestions
	 *  NOT PRODUCTION READY YET 
	 */
	case version1(SecurityQuestionsNotProductionReadyKdfSchemeVersion1
	)
}

// MARK: - FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme
public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme: FfiConverterRustBuffer {
	typealias SwiftType = SecurityQuestionsNotProductionReadyKdfScheme

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyKdfScheme {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .version1(FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: SecurityQuestionsNotProductionReadyKdfScheme, into buf: inout [UInt8]) {
		switch value {
		case let .version1(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyKdfScheme {
	try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme_lower(_ value: SecurityQuestionsNotProductionReadyKdfScheme) -> RustBuffer {
	FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme.lower(value)
}

// MARK: - SecurityQuestionsNotProductionReadyKdfScheme + Sendable
extension SecurityQuestionsNotProductionReadyKdfScheme: Sendable {}

// MARK: - SecurityQuestionsNotProductionReadyKdfScheme + Equatable, Hashable
extension SecurityQuestionsNotProductionReadyKdfScheme: Equatable, Hashable {}

// MARK: - Signature
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either a Signature on `Curve25519` or `Secp256k1`
 */

public enum Signature {
	case secp256k1(value: Secp256k1Signature
	)
	case ed25519(value: Ed25519Signature
	)
}

// MARK: - FfiConverterTypeSignature
public struct FfiConverterTypeSignature: FfiConverterRustBuffer {
	typealias SwiftType = Signature

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Signature {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .secp256k1(value: FfiConverterTypeSecp256k1Signature.read(from: &buf)
			)

		case 2: return try .ed25519(value: FfiConverterTypeEd25519Signature.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: Signature, into buf: inout [UInt8]) {
		switch value {
		case let .secp256k1(value):
			writeInt(&buf, Int32(1))
			FfiConverterTypeSecp256k1Signature.write(value, into: &buf)

		case let .ed25519(value):
			writeInt(&buf, Int32(2))
			FfiConverterTypeEd25519Signature.write(value, into: &buf)
		}
	}
}

public func FfiConverterTypeSignature_lift(_ buf: RustBuffer) throws -> Signature {
	try FfiConverterTypeSignature.lift(buf)
}

public func FfiConverterTypeSignature_lower(_ value: Signature) -> RustBuffer {
	FfiConverterTypeSignature.lower(value)
}

// MARK: - Signature + Sendable
extension Signature: Sendable {}

// MARK: - Signature + Equatable, Hashable
extension Signature: Equatable, Hashable {}

// MARK: - SignatureWithPublicKey
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents any natively supported signature, including public key.
 */

public enum SignatureWithPublicKey {
	case secp256k1(publicKey: Secp256k1PublicKey, signature: Secp256k1Signature)
	case ed25519(publicKey: Ed25519PublicKey, signature: Ed25519Signature)
}

// MARK: - FfiConverterTypeSignatureWithPublicKey
public struct FfiConverterTypeSignatureWithPublicKey: FfiConverterRustBuffer {
	typealias SwiftType = SignatureWithPublicKey

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureWithPublicKey {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .secp256k1(publicKey: FfiConverterTypeSecp256k1PublicKey.read(from: &buf), signature: FfiConverterTypeSecp256k1Signature.read(from: &buf))

		case 2: return try .ed25519(publicKey: FfiConverterTypeEd25519PublicKey.read(from: &buf), signature: FfiConverterTypeEd25519Signature.read(from: &buf))

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: SignatureWithPublicKey, into buf: inout [UInt8]) {
		switch value {
		case let .secp256k1(publicKey, signature):
			writeInt(&buf, Int32(1))
			FfiConverterTypeSecp256k1PublicKey.write(publicKey, into: &buf)
			FfiConverterTypeSecp256k1Signature.write(signature, into: &buf)

		case let .ed25519(publicKey, signature):
			writeInt(&buf, Int32(2))
			FfiConverterTypeEd25519PublicKey.write(publicKey, into: &buf)
			FfiConverterTypeEd25519Signature.write(signature, into: &buf)
		}
	}
}

public func FfiConverterTypeSignatureWithPublicKey_lift(_ buf: RustBuffer) throws -> SignatureWithPublicKey {
	try FfiConverterTypeSignatureWithPublicKey.lift(buf)
}

public func FfiConverterTypeSignatureWithPublicKey_lower(_ value: SignatureWithPublicKey) -> RustBuffer {
	FfiConverterTypeSignatureWithPublicKey.lower(value)
}

// MARK: - SignatureWithPublicKey + Sendable
extension SignatureWithPublicKey: Sendable {}

// MARK: - SignatureWithPublicKey + Equatable, Hashable
extension SignatureWithPublicKey: Equatable, Hashable {}

// MARK: - SimpleCountedResourceBounds
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the bounds for a simple fungible resource, which can
 * be exact, at most, at least, between, or unknown amount.
 */

public enum SimpleCountedResourceBounds {
	case exact(amount: Decimal192
	)
	case atMost(amount: Decimal192
	)
	case atLeast(amount: Decimal192
	)
	case between(minAmount: Decimal192, maxAmount: Decimal192)
	case unknownAmount
}

// MARK: - FfiConverterTypeSimpleCountedResourceBounds
public struct FfiConverterTypeSimpleCountedResourceBounds: FfiConverterRustBuffer {
	typealias SwiftType = SimpleCountedResourceBounds

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleCountedResourceBounds {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .exact(amount: FfiConverterTypeDecimal192.read(from: &buf)
			)

		case 2: return try .atMost(amount: FfiConverterTypeDecimal192.read(from: &buf)
			)

		case 3: return try .atLeast(amount: FfiConverterTypeDecimal192.read(from: &buf)
			)

		case 4: return try .between(minAmount: FfiConverterTypeDecimal192.read(from: &buf), maxAmount: FfiConverterTypeDecimal192.read(from: &buf))

		case 5: return .unknownAmount

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: SimpleCountedResourceBounds, into buf: inout [UInt8]) {
		switch value {
		case let .exact(amount):
			writeInt(&buf, Int32(1))
			FfiConverterTypeDecimal192.write(amount, into: &buf)

		case let .atMost(amount):
			writeInt(&buf, Int32(2))
			FfiConverterTypeDecimal192.write(amount, into: &buf)

		case let .atLeast(amount):
			writeInt(&buf, Int32(3))
			FfiConverterTypeDecimal192.write(amount, into: &buf)

		case let .between(minAmount, maxAmount):
			writeInt(&buf, Int32(4))
			FfiConverterTypeDecimal192.write(minAmount, into: &buf)
			FfiConverterTypeDecimal192.write(maxAmount, into: &buf)

		case .unknownAmount:
			writeInt(&buf, Int32(5))
		}
	}
}

public func FfiConverterTypeSimpleCountedResourceBounds_lift(_ buf: RustBuffer) throws -> SimpleCountedResourceBounds {
	try FfiConverterTypeSimpleCountedResourceBounds.lift(buf)
}

public func FfiConverterTypeSimpleCountedResourceBounds_lower(_ value: SimpleCountedResourceBounds) -> RustBuffer {
	FfiConverterTypeSimpleCountedResourceBounds.lower(value)
}

// MARK: - SimpleCountedResourceBounds + Sendable
extension SimpleCountedResourceBounds: Sendable {}

// MARK: - SimpleCountedResourceBounds + Equatable, Hashable
extension SimpleCountedResourceBounds: Equatable, Hashable {}

// MARK: - SimpleResourceBounds
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the bounds for a simple resource, which can be either fungible or non_fungible.
 */

public enum SimpleResourceBounds {
	case fungible(resourceAddress: ResourceAddress, bounds: SimpleCountedResourceBounds)
	case nonFungible(resourceAddress: ResourceAddress, bounds: SimpleNonFungibleResourceBounds)
}

// MARK: - FfiConverterTypeSimpleResourceBounds
public struct FfiConverterTypeSimpleResourceBounds: FfiConverterRustBuffer {
	typealias SwiftType = SimpleResourceBounds

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleResourceBounds {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .fungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), bounds: FfiConverterTypeSimpleCountedResourceBounds.read(from: &buf))

		case 2: return try .nonFungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), bounds: FfiConverterTypeSimpleNonFungibleResourceBounds.read(from: &buf))

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: SimpleResourceBounds, into buf: inout [UInt8]) {
		switch value {
		case let .fungible(resourceAddress, bounds):
			writeInt(&buf, Int32(1))
			FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
			FfiConverterTypeSimpleCountedResourceBounds.write(bounds, into: &buf)

		case let .nonFungible(resourceAddress, bounds):
			writeInt(&buf, Int32(2))
			FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
			FfiConverterTypeSimpleNonFungibleResourceBounds.write(bounds, into: &buf)
		}
	}
}

public func FfiConverterTypeSimpleResourceBounds_lift(_ buf: RustBuffer) throws -> SimpleResourceBounds {
	try FfiConverterTypeSimpleResourceBounds.lift(buf)
}

public func FfiConverterTypeSimpleResourceBounds_lower(_ value: SimpleResourceBounds) -> RustBuffer {
	FfiConverterTypeSimpleResourceBounds.lower(value)
}

// MARK: - SimpleResourceBounds + Sendable
extension SimpleResourceBounds: Sendable {}

// MARK: - SimpleResourceBounds + Equatable, Hashable
extension SimpleResourceBounds: Equatable, Hashable {}

// MARK: - TransactionStatus
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionStatus {
	/**
	 * The transaction has been successfully processed and is now final.
	 */
	case success
	/**
	 * The transaction has been permanently rejected with the given `reason`.
	 */
	case permanentlyRejected(reason: TransactionStatusReason
	)
	/**
	 * The transaction has been temporarily rejected and may be processed in the future.
	 */
	case temporarilyRejected(currentEpoch: Epoch
	)
	/**
	 * The transaction has failed with the given `reason`.
	 */
	case failed(reason: TransactionStatusReason
	)
}

// MARK: - FfiConverterTypeTransactionStatus
public struct FfiConverterTypeTransactionStatus: FfiConverterRustBuffer {
	typealias SwiftType = TransactionStatus

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionStatus {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .success

		case 2: return try .permanentlyRejected(reason: FfiConverterTypeTransactionStatusReason.read(from: &buf)
			)

		case 3: return try .temporarilyRejected(currentEpoch: FfiConverterTypeEpoch.read(from: &buf)
			)

		case 4: return try .failed(reason: FfiConverterTypeTransactionStatusReason.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: TransactionStatus, into buf: inout [UInt8]) {
		switch value {
		case .success:
			writeInt(&buf, Int32(1))

		case let .permanentlyRejected(reason):
			writeInt(&buf, Int32(2))
			FfiConverterTypeTransactionStatusReason.write(reason, into: &buf)

		case let .temporarilyRejected(currentEpoch):
			writeInt(&buf, Int32(3))
			FfiConverterTypeEpoch.write(currentEpoch, into: &buf)

		case let .failed(reason):
			writeInt(&buf, Int32(4))
			FfiConverterTypeTransactionStatusReason.write(reason, into: &buf)
		}
	}
}

public func FfiConverterTypeTransactionStatus_lift(_ buf: RustBuffer) throws -> TransactionStatus {
	try FfiConverterTypeTransactionStatus.lift(buf)
}

public func FfiConverterTypeTransactionStatus_lower(_ value: TransactionStatus) -> RustBuffer {
	FfiConverterTypeTransactionStatus.lower(value)
}

// MARK: - TransactionStatus + Sendable
extension TransactionStatus: Sendable {}

// MARK: - TransactionStatus + Equatable, Hashable
extension TransactionStatus: Equatable, Hashable {}

// MARK: - TransactionStatusReason
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionStatusReason {
	/**
	 * The transaction was rejected for an unknown reason.
	 */
	case unknown
	/**
	 * The transaction was rejected because there was an application error in the worktop.
	 */
	case worktopError
}

// MARK: - FfiConverterTypeTransactionStatusReason
public struct FfiConverterTypeTransactionStatusReason: FfiConverterRustBuffer {
	typealias SwiftType = TransactionStatusReason

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionStatusReason {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .unknown

		case 2: return .worktopError

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: TransactionStatusReason, into buf: inout [UInt8]) {
		switch value {
		case .unknown:
			writeInt(&buf, Int32(1))

		case .worktopError:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeTransactionStatusReason_lift(_ buf: RustBuffer) throws -> TransactionStatusReason {
	try FfiConverterTypeTransactionStatusReason.lift(buf)
}

public func FfiConverterTypeTransactionStatusReason_lower(_ value: TransactionStatusReason) -> RustBuffer {
	FfiConverterTypeTransactionStatusReason.lower(value)
}

// MARK: - TransactionStatusReason + Sendable
extension TransactionStatusReason: Sendable {}

// MARK: - TransactionStatusReason + Equatable, Hashable
extension TransactionStatusReason: Equatable, Hashable {}

// MARK: - UnsafeStorageKey
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UnsafeStorageKey {
	case factorSourceUserHasWrittenDown
}

// MARK: - FfiConverterTypeUnsafeStorageKey
public struct FfiConverterTypeUnsafeStorageKey: FfiConverterRustBuffer {
	typealias SwiftType = UnsafeStorageKey

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsafeStorageKey {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .factorSourceUserHasWrittenDown

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: UnsafeStorageKey, into buf: inout [UInt8]) {
		switch value {
		case .factorSourceUserHasWrittenDown:
			writeInt(&buf, Int32(1))
		}
	}
}

public func FfiConverterTypeUnsafeStorageKey_lift(_ buf: RustBuffer) throws -> UnsafeStorageKey {
	try FfiConverterTypeUnsafeStorageKey.lift(buf)
}

public func FfiConverterTypeUnsafeStorageKey_lower(_ value: UnsafeStorageKey) -> RustBuffer {
	FfiConverterTypeUnsafeStorageKey.lower(value)
}

// MARK: - UnsafeStorageKey + Sendable
extension UnsafeStorageKey: Sendable {}

// MARK: - UnsafeStorageKey + Equatable, Hashable
extension UnsafeStorageKey: Equatable, Hashable {}

// MARK: - Unsecurified
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Unsecurified {
	case unhardenedComponent(Unhardened
	)
	case hardenedComponent(UnsecurifiedHardened
	)
}

// MARK: - FfiConverterTypeUnsecurified
public struct FfiConverterTypeUnsecurified: FfiConverterRustBuffer {
	typealias SwiftType = Unsecurified

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unsecurified {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .unhardenedComponent(FfiConverterTypeUnhardened.read(from: &buf)
			)

		case 2: return try .hardenedComponent(FfiConverterTypeUnsecurifiedHardened.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: Unsecurified, into buf: inout [UInt8]) {
		switch value {
		case let .unhardenedComponent(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeUnhardened.write(v1, into: &buf)

		case let .hardenedComponent(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeUnsecurifiedHardened.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeUnsecurified_lift(_ buf: RustBuffer) throws -> Unsecurified {
	try FfiConverterTypeUnsecurified.lift(buf)
}

public func FfiConverterTypeUnsecurified_lower(_ value: Unsecurified) -> RustBuffer {
	FfiConverterTypeUnsecurified.lower(value)
}

// MARK: - Unsecurified + Sendable
extension Unsecurified: Sendable {}

// MARK: - Unsecurified + Equatable, Hashable
extension Unsecurified: Equatable, Hashable {}

// MARK: - UnspecifiedResources
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents unspecified resources, which can be either none present or
 * may be present with a list of change sources.
 */

public enum UnspecifiedResources {
	/**
	 * There are no unspecified resources present
	 */
	case nonePresent
	/**
	 * There might be non-zero balances of unspecified resources present
	 */
	case mayBePresent
}

// MARK: - FfiConverterTypeUnspecifiedResources
public struct FfiConverterTypeUnspecifiedResources: FfiConverterRustBuffer {
	typealias SwiftType = UnspecifiedResources

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnspecifiedResources {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .nonePresent

		case 2: return .mayBePresent

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: UnspecifiedResources, into buf: inout [UInt8]) {
		switch value {
		case .nonePresent:
			writeInt(&buf, Int32(1))

		case .mayBePresent:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeUnspecifiedResources_lift(_ buf: RustBuffer) throws -> UnspecifiedResources {
	try FfiConverterTypeUnspecifiedResources.lift(buf)
}

public func FfiConverterTypeUnspecifiedResources_lower(_ value: UnspecifiedResources) -> RustBuffer {
	FfiConverterTypeUnspecifiedResources.lower(value)
}

// MARK: - UnspecifiedResources + Sendable
extension UnspecifiedResources: Sendable {}

// MARK: - UnspecifiedResources + Equatable, Hashable
extension UnspecifiedResources: Equatable, Hashable {}

// MARK: - VectorImageType
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VectorImageType {
	case svg
	case pdf
}

// MARK: - FfiConverterTypeVectorImageType
public struct FfiConverterTypeVectorImageType: FfiConverterRustBuffer {
	typealias SwiftType = VectorImageType

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VectorImageType {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return .svg

		case 2: return .pdf

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: VectorImageType, into buf: inout [UInt8]) {
		switch value {
		case .svg:
			writeInt(&buf, Int32(1))

		case .pdf:
			writeInt(&buf, Int32(2))
		}
	}
}

public func FfiConverterTypeVectorImageType_lift(_ buf: RustBuffer) throws -> VectorImageType {
	try FfiConverterTypeVectorImageType.lift(buf)
}

public func FfiConverterTypeVectorImageType_lower(_ value: VectorImageType) -> RustBuffer {
	FfiConverterTypeVectorImageType.lower(value)
}

// MARK: - VectorImageType + Sendable
extension VectorImageType: Sendable {}

// MARK: - VectorImageType + Equatable, Hashable
extension VectorImageType: Equatable, Hashable {}

// MARK: - WalletToDappInteractionAuthRequestResponseItem
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionAuthRequestResponseItem {
	case usePersona(WalletToDappInteractionAuthUsePersonaRequestResponseItem
	)
	case loginWithoutChallenge(WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem
	)
	case loginWithChallenge(WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem
	)
}

// MARK: - FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem
public struct FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem: FfiConverterRustBuffer {
	typealias SwiftType = WalletToDappInteractionAuthRequestResponseItem

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthRequestResponseItem {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .usePersona(FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.read(from: &buf)
			)

		case 2: return try .loginWithoutChallenge(FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.read(from: &buf)
			)

		case 3: return try .loginWithChallenge(FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: WalletToDappInteractionAuthRequestResponseItem, into buf: inout [UInt8]) {
		switch value {
		case let .usePersona(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.write(v1, into: &buf)

		case let .loginWithoutChallenge(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.write(v1, into: &buf)

		case let .loginWithChallenge(v1):
			writeInt(&buf, Int32(3))
			FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthRequestResponseItem {
	try FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem_lower(_ value: WalletToDappInteractionAuthRequestResponseItem) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.lower(value)
}

// MARK: - WalletToDappInteractionAuthRequestResponseItem + Sendable
extension WalletToDappInteractionAuthRequestResponseItem: Sendable {}

// MARK: - WalletToDappInteractionAuthRequestResponseItem + Equatable, Hashable
extension WalletToDappInteractionAuthRequestResponseItem: Equatable, Hashable {}

// MARK: - WalletToDappInteractionProofOfOwnership
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A proof of ownership of either an `Account` or a `Persona`.
 */

public enum WalletToDappInteractionProofOfOwnership {
	case account(WalletToDappInteractionAccountProof
	)
	case persona(WalletToDappInteractionPersonaProof
	)
}

// MARK: - FfiConverterTypeWalletToDappInteractionProofOfOwnership
public struct FfiConverterTypeWalletToDappInteractionProofOfOwnership: FfiConverterRustBuffer {
	typealias SwiftType = WalletToDappInteractionProofOfOwnership

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionProofOfOwnership {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .account(FfiConverterTypeWalletToDappInteractionAccountProof.read(from: &buf)
			)

		case 2: return try .persona(FfiConverterTypeWalletToDappInteractionPersonaProof.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: WalletToDappInteractionProofOfOwnership, into buf: inout [UInt8]) {
		switch value {
		case let .account(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeWalletToDappInteractionAccountProof.write(v1, into: &buf)

		case let .persona(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeWalletToDappInteractionPersonaProof.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeWalletToDappInteractionProofOfOwnership_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionProofOfOwnership {
	try FfiConverterTypeWalletToDappInteractionProofOfOwnership.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionProofOfOwnership_lower(_ value: WalletToDappInteractionProofOfOwnership) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionProofOfOwnership.lower(value)
}

// MARK: - WalletToDappInteractionProofOfOwnership + Sendable
extension WalletToDappInteractionProofOfOwnership: Sendable {}

// MARK: - WalletToDappInteractionProofOfOwnership + Equatable, Hashable
extension WalletToDappInteractionProofOfOwnership: Equatable, Hashable {}

// MARK: - WalletToDappInteractionResponse
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionResponse {
	case success(WalletToDappInteractionSuccessResponse
	)
	case failure(WalletToDappInteractionFailureResponse
	)
}

// MARK: - FfiConverterTypeWalletToDappInteractionResponse
public struct FfiConverterTypeWalletToDappInteractionResponse: FfiConverterRustBuffer {
	typealias SwiftType = WalletToDappInteractionResponse

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionResponse {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .success(FfiConverterTypeWalletToDappInteractionSuccessResponse.read(from: &buf)
			)

		case 2: return try .failure(FfiConverterTypeWalletToDappInteractionFailureResponse.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: WalletToDappInteractionResponse, into buf: inout [UInt8]) {
		switch value {
		case let .success(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeWalletToDappInteractionSuccessResponse.write(v1, into: &buf)

		case let .failure(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeWalletToDappInteractionFailureResponse.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeWalletToDappInteractionResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionResponse {
	try FfiConverterTypeWalletToDappInteractionResponse.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionResponse_lower(_ value: WalletToDappInteractionResponse) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionResponse.lower(value)
}

// MARK: - WalletToDappInteractionResponse + Sendable
extension WalletToDappInteractionResponse: Sendable {}

// MARK: - WalletToDappInteractionResponse + Equatable, Hashable
extension WalletToDappInteractionResponse: Equatable, Hashable {}

// MARK: - WalletToDappInteractionResponseItems
// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionResponseItems {
	case authorizedRequest(WalletToDappInteractionAuthorizedRequestResponseItems
	)
	case unauthorizedRequest(WalletToDappInteractionUnauthorizedRequestResponseItems
	)
	case transaction(WalletToDappInteractionTransactionResponseItems
	)
	case preAuthorization(WalletToDappInteractionPreAuthorizationResponseItems
	)
}

// MARK: - FfiConverterTypeWalletToDappInteractionResponseItems
public struct FfiConverterTypeWalletToDappInteractionResponseItems: FfiConverterRustBuffer {
	typealias SwiftType = WalletToDappInteractionResponseItems

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionResponseItems {
		let variant: Int32 = try readInt(&buf)
		switch variant {
		case 1: return try .authorizedRequest(FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.read(from: &buf)
			)

		case 2: return try .unauthorizedRequest(FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.read(from: &buf)
			)

		case 3: return try .transaction(FfiConverterTypeWalletToDappInteractionTransactionResponseItems.read(from: &buf)
			)

		case 4: return try .preAuthorization(FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.read(from: &buf)
			)

		default: throw UniffiInternalError.unexpectedEnumCase
		}
	}

	public static func write(_ value: WalletToDappInteractionResponseItems, into buf: inout [UInt8]) {
		switch value {
		case let .authorizedRequest(v1):
			writeInt(&buf, Int32(1))
			FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.write(v1, into: &buf)

		case let .unauthorizedRequest(v1):
			writeInt(&buf, Int32(2))
			FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.write(v1, into: &buf)

		case let .transaction(v1):
			writeInt(&buf, Int32(3))
			FfiConverterTypeWalletToDappInteractionTransactionResponseItems.write(v1, into: &buf)

		case let .preAuthorization(v1):
			writeInt(&buf, Int32(4))
			FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.write(v1, into: &buf)
		}
	}
}

public func FfiConverterTypeWalletToDappInteractionResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionResponseItems {
	try FfiConverterTypeWalletToDappInteractionResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionResponseItems_lower(_ value: WalletToDappInteractionResponseItems) -> RustBuffer {
	FfiConverterTypeWalletToDappInteractionResponseItems.lower(value)
}

// MARK: - WalletToDappInteractionResponseItems + Sendable
extension WalletToDappInteractionResponseItems: Sendable {}

// MARK: - WalletToDappInteractionResponseItems + Equatable, Hashable
extension WalletToDappInteractionResponseItems: Equatable, Hashable {}

// MARK: - FfiConverterOptionUInt8
private struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
	typealias SwiftType = UInt8?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterUInt8.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterUInt8.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionBool
private struct FfiConverterOptionBool: FfiConverterRustBuffer {
	typealias SwiftType = Bool?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterBool.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterBool.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionString
private struct FfiConverterOptionString: FfiConverterRustBuffer {
	typealias SwiftType = String?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterString.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterString.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeAccountAddress
private struct FfiConverterOptionTypeAccountAddress: FfiConverterRustBuffer {
	typealias SwiftType = AccountAddress?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeAccountAddress.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeAccountAddress.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem
private struct FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem: FfiConverterRustBuffer {
	typealias SwiftType = DappToWalletInteractionAccountsRequestItem?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeDappToWalletInteractionAccountsRequestItem.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem
private struct FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem: FfiConverterRustBuffer {
	typealias SwiftType = DappToWalletInteractionPersonaDataRequestItem?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeDappToWalletInteractionProofOfOwnershipRequestItem
private struct FfiConverterOptionTypeDappToWalletInteractionProofOfOwnershipRequestItem: FfiConverterRustBuffer {
	typealias SwiftType = DappToWalletInteractionProofOfOwnershipRequestItem?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeDappToWalletInteractionResetRequestItem
private struct FfiConverterOptionTypeDappToWalletInteractionResetRequestItem: FfiConverterRustBuffer {
	typealias SwiftType = DappToWalletInteractionResetRequestItem?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeDappToWalletInteractionResetRequestItem.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeDappToWalletInteractionResetRequestItem.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeDecimal192
private struct FfiConverterOptionTypeDecimal192: FfiConverterRustBuffer {
	typealias SwiftType = Decimal192?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeDecimal192.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeDecimal192.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeDisplayName
private struct FfiConverterOptionTypeDisplayName: FfiConverterRustBuffer {
	typealias SwiftType = DisplayName?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeDisplayName.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeDisplayName.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeHierarchicalDeterministicFactorInstance
private struct FfiConverterOptionTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
	typealias SwiftType = HierarchicalDeterministicFactorInstance?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeIdentityAddress
private struct FfiConverterOptionTypeIdentityAddress: FfiConverterRustBuffer {
	typealias SwiftType = IdentityAddress?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeIdentityAddress.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeIdentityAddress.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeInstant
private struct FfiConverterOptionTypeInstant: FfiConverterRustBuffer {
	typealias SwiftType = Instant?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeInstant.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeInstant.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypePersonaDataEntryName
private struct FfiConverterOptionTypePersonaDataEntryName: FfiConverterRustBuffer {
	typealias SwiftType = PersonaDataEntryName?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypePersonaDataEntryName.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypePersonaDataEntryName.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypePersonaDataIdentifiedName
private struct FfiConverterOptionTypePersonaDataIdentifiedName: FfiConverterRustBuffer {
	typealias SwiftType = PersonaDataIdentifiedName?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypePersonaDataIdentifiedName.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypePersonaDataIdentifiedName.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeRequestedQuantity
private struct FfiConverterOptionTypeRequestedQuantity: FfiConverterRustBuffer {
	typealias SwiftType = RequestedQuantity?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeRequestedQuantity.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeRequestedQuantity.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses
private struct FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses: FfiConverterRustBuffer {
	typealias SwiftType = SharedToDappWithPersonaAccountAddresses?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeSharedToDappWithPersonaAccountAddresses.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeSharedToDappWithPersonaAccountAddresses.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries
private struct FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries: FfiConverterRustBuffer {
	typealias SwiftType = SharedToDappWithPersonaIDsOfPersonaDataEntries?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem
private struct FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem: FfiConverterRustBuffer {
	typealias SwiftType = WalletToDappInteractionAccountsRequestResponseItem?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem
private struct FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem: FfiConverterRustBuffer {
	typealias SwiftType = WalletToDappInteractionPersonaDataRequestResponseItem?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem
private struct FfiConverterOptionTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem: FfiConverterRustBuffer {
	typealias SwiftType = WalletToDappInteractionProofOfOwnershipRequestResponseItem?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeSimpleCountedResourceBounds
private struct FfiConverterOptionTypeSimpleCountedResourceBounds: FfiConverterRustBuffer {
	typealias SwiftType = SimpleCountedResourceBounds?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeSimpleCountedResourceBounds.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeSimpleCountedResourceBounds.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionSequenceTypeAccountAddress
private struct FfiConverterOptionSequenceTypeAccountAddress: FfiConverterRustBuffer {
	typealias SwiftType = [AccountAddress]?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterSequenceTypeAccountAddress.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterSequenceTypeAccountAddress.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionSequenceTypeAccountForDisplay
private struct FfiConverterOptionSequenceTypeAccountForDisplay: FfiConverterRustBuffer {
	typealias SwiftType = [AccountForDisplay]?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterSequenceTypeAccountForDisplay.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterSequenceTypeAccountForDisplay.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionSequenceTypeAssetException
private struct FfiConverterOptionSequenceTypeAssetException: FfiConverterRustBuffer {
	typealias SwiftType = [AssetException]?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterSequenceTypeAssetException.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterSequenceTypeAssetException.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionSequenceTypeEmailAddress
private struct FfiConverterOptionSequenceTypeEmailAddress: FfiConverterRustBuffer {
	typealias SwiftType = [EmailAddress]?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterSequenceTypeEmailAddress.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterSequenceTypeEmailAddress.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber
private struct FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
	typealias SwiftType = [PersonaDataEntryPhoneNumber]?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterSequenceTypePersonaDataEntryPhoneNumber.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterSequenceTypePersonaDataEntryPhoneNumber.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof
private struct FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
	typealias SwiftType = [WalletToDappInteractionAccountProof]?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterSequenceTypeWalletToDappInteractionAccountProof.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterSequenceTypeWalletToDappInteractionAccountProof.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionSequenceTypeResourceOrNonFungible
private struct FfiConverterOptionSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
	typealias SwiftType = [ResourceOrNonFungible]?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterSequenceTypeResourceOrNonFungible.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeBagOfBytes
private struct FfiConverterOptionTypeBagOfBytes: FfiConverterRustBuffer {
	typealias SwiftType = BagOfBytes?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeBagOfBytes.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeBagOfBytes.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce
private struct FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce: FfiConverterRustBuffer {
	typealias SwiftType = DappToWalletInteractionAuthChallengeNonce?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypePersonaDataEntryID
private struct FfiConverterOptionTypePersonaDataEntryID: FfiConverterRustBuffer {
	typealias SwiftType = PersonaDataEntryId?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypePersonaDataEntryID.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypePersonaDataEntryID.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterOptionTypeUrl
private struct FfiConverterOptionTypeUrl: FfiConverterRustBuffer {
	typealias SwiftType = Url?

	public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
		guard let value else {
			writeInt(&buf, Int8(0))
			return
		}
		writeInt(&buf, Int8(1))
		FfiConverterTypeUrl.write(value, into: &buf)
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
		switch try readInt(&buf) as Int8 {
		case 0: return nil
		case 1: return try FfiConverterTypeUrl.read(from: &buf)
		default: throw UniffiInternalError.unexpectedOptionalTag
		}
	}
}

// MARK: - FfiConverterSequenceInt8
private struct FfiConverterSequenceInt8: FfiConverterRustBuffer {
	typealias SwiftType = [Int8]

	public static func write(_ value: [Int8], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterInt8.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int8] {
		let len: Int32 = try readInt(&buf)
		var seq = [Int8]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterInt8.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceString
private struct FfiConverterSequenceString: FfiConverterRustBuffer {
	typealias SwiftType = [String]

	public static func write(_ value: [String], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterString.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
		let len: Int32 = try readInt(&buf)
		var seq = [String]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterString.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAccount
private struct FfiConverterSequenceTypeAccount: FfiConverterRustBuffer {
	typealias SwiftType = [Account]

	public static func write(_ value: [Account], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAccount.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Account] {
		let len: Int32 = try readInt(&buf)
		var seq = [Account]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAccount.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAccountAddress
private struct FfiConverterSequenceTypeAccountAddress: FfiConverterRustBuffer {
	typealias SwiftType = [AccountAddress]

	public static func write(_ value: [AccountAddress], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAccountAddress.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress] {
		let len: Int32 = try readInt(&buf)
		var seq = [AccountAddress]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAccountAddress.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAccountForDisplay
private struct FfiConverterSequenceTypeAccountForDisplay: FfiConverterRustBuffer {
	typealias SwiftType = [AccountForDisplay]

	public static func write(_ value: [AccountForDisplay], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAccountForDisplay.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountForDisplay] {
		let len: Int32 = try readInt(&buf)
		var seq = [AccountForDisplay]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAccountForDisplay.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAppearanceID
private struct FfiConverterSequenceTypeAppearanceID: FfiConverterRustBuffer {
	typealias SwiftType = [AppearanceId]

	public static func write(_ value: [AppearanceId], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAppearanceID.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AppearanceId] {
		let len: Int32 = try readInt(&buf)
		var seq = [AppearanceId]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAppearanceID.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAssetException
private struct FfiConverterSequenceTypeAssetException: FfiConverterRustBuffer {
	typealias SwiftType = [AssetException]

	public static func write(_ value: [AssetException], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAssetException.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetException] {
		let len: Int32 = try readInt(&buf)
		var seq = [AssetException]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAssetException.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAuthorizedDapp
private struct FfiConverterSequenceTypeAuthorizedDapp: FfiConverterRustBuffer {
	typealias SwiftType = [AuthorizedDapp]

	public static func write(_ value: [AuthorizedDapp], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAuthorizedDapp.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedDapp] {
		let len: Int32 = try readInt(&buf)
		var seq = [AuthorizedDapp]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAuthorizedDapp.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAuthorizedPersonaDetailed
private struct FfiConverterSequenceTypeAuthorizedPersonaDetailed: FfiConverterRustBuffer {
	typealias SwiftType = [AuthorizedPersonaDetailed]

	public static func write(_ value: [AuthorizedPersonaDetailed], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAuthorizedPersonaDetailed.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedPersonaDetailed] {
		let len: Int32 = try readInt(&buf)
		var seq = [AuthorizedPersonaDetailed]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAuthorizedPersonaDetailed.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAuthorizedPersonaSimple
private struct FfiConverterSequenceTypeAuthorizedPersonaSimple: FfiConverterRustBuffer {
	typealias SwiftType = [AuthorizedPersonaSimple]

	public static func write(_ value: [AuthorizedPersonaSimple], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAuthorizedPersonaSimple.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedPersonaSimple] {
		let len: Int32 = try readInt(&buf)
		var seq = [AuthorizedPersonaSimple]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAuthorizedPersonaSimple.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeBIP39Word
private struct FfiConverterSequenceTypeBIP39Word: FfiConverterRustBuffer {
	typealias SwiftType = [Bip39Word]

	public static func write(_ value: [Bip39Word], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeBIP39Word.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip39Word] {
		let len: Int32 = try readInt(&buf)
		var seq = [Bip39Word]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeBIP39Word.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeBlob
private struct FfiConverterSequenceTypeBlob: FfiConverterRustBuffer {
	typealias SwiftType = [Blob]

	public static func write(_ value: [Blob], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeBlob.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Blob] {
		let len: Int32 = try readInt(&buf)
		var seq = [Blob]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeBlob.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeEmailAddress
private struct FfiConverterSequenceTypeEmailAddress: FfiConverterRustBuffer {
	typealias SwiftType = [EmailAddress]

	public static func write(_ value: [EmailAddress], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeEmailAddress.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EmailAddress] {
		let len: Int32 = try readInt(&buf)
		var seq = [EmailAddress]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeEmailAddress.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeExactly60Bytes
private struct FfiConverterSequenceTypeExactly60Bytes: FfiConverterRustBuffer {
	typealias SwiftType = [Exactly60Bytes]

	public static func write(_ value: [Exactly60Bytes], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeExactly60Bytes.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Exactly60Bytes] {
		let len: Int32 = try readInt(&buf)
		var seq = [Exactly60Bytes]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeExactly60Bytes.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeFactorInstance
private struct FfiConverterSequenceTypeFactorInstance: FfiConverterRustBuffer {
	typealias SwiftType = [FactorInstance]

	public static func write(_ value: [FactorInstance], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeFactorInstance.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorInstance] {
		let len: Int32 = try readInt(&buf)
		var seq = [FactorInstance]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeFactorInstance.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeFactorInstanceForDebugPurposes
private struct FfiConverterSequenceTypeFactorInstanceForDebugPurposes: FfiConverterRustBuffer {
	typealias SwiftType = [FactorInstanceForDebugPurposes]

	public static func write(_ value: [FactorInstanceForDebugPurposes], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeFactorInstanceForDebugPurposes.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorInstanceForDebugPurposes] {
		let len: Int32 = try readInt(&buf)
		var seq = [FactorInstanceForDebugPurposes]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeFactorInstanceForDebugPurposes.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeGateway
private struct FfiConverterSequenceTypeGateway: FfiConverterRustBuffer {
	typealias SwiftType = [Gateway]

	public static func write(_ value: [Gateway], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeGateway.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Gateway] {
		let len: Int32 = try readInt(&buf)
		var seq = [Gateway]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeGateway.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeHierarchicalDeterministicPublicKey
private struct FfiConverterSequenceTypeHierarchicalDeterministicPublicKey: FfiConverterRustBuffer {
	typealias SwiftType = [HierarchicalDeterministicPublicKey]

	public static func write(_ value: [HierarchicalDeterministicPublicKey], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeHierarchicalDeterministicPublicKey.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HierarchicalDeterministicPublicKey] {
		let len: Int32 = try readInt(&buf)
		var seq = [HierarchicalDeterministicPublicKey]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeIdentityAddress
private struct FfiConverterSequenceTypeIdentityAddress: FfiConverterRustBuffer {
	typealias SwiftType = [IdentityAddress]

	public static func write(_ value: [IdentityAddress], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeIdentityAddress.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IdentityAddress] {
		let len: Int32 = try readInt(&buf)
		var seq = [IdentityAddress]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeIdentityAddress.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeIntentSignature
private struct FfiConverterSequenceTypeIntentSignature: FfiConverterRustBuffer {
	typealias SwiftType = [IntentSignature]

	public static func write(_ value: [IntentSignature], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeIntentSignature.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IntentSignature] {
		let len: Int32 = try readInt(&buf)
		var seq = [IntentSignature]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeIntentSignature.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeNonFungibleGlobalId
private struct FfiConverterSequenceTypeNonFungibleGlobalId: FfiConverterRustBuffer {
	typealias SwiftType = [NonFungibleGlobalId]

	public static func write(_ value: [NonFungibleGlobalId], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeNonFungibleGlobalId.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId] {
		let len: Int32 = try readInt(&buf)
		var seq = [NonFungibleGlobalId]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeNonFungibleGlobalId.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeP2PLink
private struct FfiConverterSequenceTypeP2PLink: FfiConverterRustBuffer {
	typealias SwiftType = [P2pLink]

	public static func write(_ value: [P2pLink], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeP2PLink.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [P2pLink] {
		let len: Int32 = try readInt(&buf)
		var seq = [P2pLink]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeP2PLink.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePerAssetFungibleTransfer
private struct FfiConverterSequenceTypePerAssetFungibleTransfer: FfiConverterRustBuffer {
	typealias SwiftType = [PerAssetFungibleTransfer]

	public static func write(_ value: [PerAssetFungibleTransfer], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePerAssetFungibleTransfer.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetFungibleTransfer] {
		let len: Int32 = try readInt(&buf)
		var seq = [PerAssetFungibleTransfer]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePerAssetFungibleTransfer.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePerAssetNonFungibleTransfer
private struct FfiConverterSequenceTypePerAssetNonFungibleTransfer: FfiConverterRustBuffer {
	typealias SwiftType = [PerAssetNonFungibleTransfer]

	public static func write(_ value: [PerAssetNonFungibleTransfer], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePerAssetNonFungibleTransfer.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetNonFungibleTransfer] {
		let len: Int32 = try readInt(&buf)
		var seq = [PerAssetNonFungibleTransfer]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePerAssetNonFungibleTransfer.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePerAssetTransfersOfFungibleResource
private struct FfiConverterSequenceTypePerAssetTransfersOfFungibleResource: FfiConverterRustBuffer {
	typealias SwiftType = [PerAssetTransfersOfFungibleResource]

	public static func write(_ value: [PerAssetTransfersOfFungibleResource], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePerAssetTransfersOfFungibleResource.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetTransfersOfFungibleResource] {
		let len: Int32 = try readInt(&buf)
		var seq = [PerAssetTransfersOfFungibleResource]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePerAssetTransfersOfFungibleResource.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource
private struct FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource: FfiConverterRustBuffer {
	typealias SwiftType = [PerAssetTransfersOfNonFungibleResource]

	public static func write(_ value: [PerAssetTransfersOfNonFungibleResource], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePerAssetTransfersOfNonFungibleResource.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetTransfersOfNonFungibleResource] {
		let len: Int32 = try readInt(&buf)
		var seq = [PerAssetTransfersOfNonFungibleResource]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePerAssetTransfersOfNonFungibleResource.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePerRecipientAssetTransfer
private struct FfiConverterSequenceTypePerRecipientAssetTransfer: FfiConverterRustBuffer {
	typealias SwiftType = [PerRecipientAssetTransfer]

	public static func write(_ value: [PerRecipientAssetTransfer], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePerRecipientAssetTransfer.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientAssetTransfer] {
		let len: Int32 = try readInt(&buf)
		var seq = [PerRecipientAssetTransfer]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePerRecipientAssetTransfer.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePerRecipientFungibleTransfer
private struct FfiConverterSequenceTypePerRecipientFungibleTransfer: FfiConverterRustBuffer {
	typealias SwiftType = [PerRecipientFungibleTransfer]

	public static func write(_ value: [PerRecipientFungibleTransfer], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePerRecipientFungibleTransfer.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientFungibleTransfer] {
		let len: Int32 = try readInt(&buf)
		var seq = [PerRecipientFungibleTransfer]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePerRecipientFungibleTransfer.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePerRecipientNonFungibleTransfer
private struct FfiConverterSequenceTypePerRecipientNonFungibleTransfer: FfiConverterRustBuffer {
	typealias SwiftType = [PerRecipientNonFungibleTransfer]

	public static func write(_ value: [PerRecipientNonFungibleTransfer], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePerRecipientNonFungibleTransfer.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientNonFungibleTransfer] {
		let len: Int32 = try readInt(&buf)
		var seq = [PerRecipientNonFungibleTransfer]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePerRecipientNonFungibleTransfer.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePersona
private struct FfiConverterSequenceTypePersona: FfiConverterRustBuffer {
	typealias SwiftType = [Persona]

	public static func write(_ value: [Persona], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePersona.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Persona] {
		let len: Int32 = try readInt(&buf)
		var seq = [Persona]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePersona.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePersonaDataEntryPhoneNumber
private struct FfiConverterSequenceTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
	typealias SwiftType = [PersonaDataEntryPhoneNumber]

	public static func write(_ value: [PersonaDataEntryPhoneNumber], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePersonaDataEntryPhoneNumber.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataEntryPhoneNumber] {
		let len: Int32 = try readInt(&buf)
		var seq = [PersonaDataEntryPhoneNumber]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePersonaDataEntryPhoneNumber.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress
private struct FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress: FfiConverterRustBuffer {
	typealias SwiftType = [PersonaDataIdentifiedEmailAddress]

	public static func write(_ value: [PersonaDataIdentifiedEmailAddress], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePersonaDataIdentifiedEmailAddress.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataIdentifiedEmailAddress] {
		let len: Int32 = try readInt(&buf)
		var seq = [PersonaDataIdentifiedEmailAddress]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePersonaDataIdentifiedEmailAddress.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber
private struct FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber: FfiConverterRustBuffer {
	typealias SwiftType = [PersonaDataIdentifiedPhoneNumber]

	public static func write(_ value: [PersonaDataIdentifiedPhoneNumber], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePersonaDataIdentifiedPhoneNumber.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataIdentifiedPhoneNumber] {
		let len: Int32 = try readInt(&buf)
		var seq = [PersonaDataIdentifiedPhoneNumber]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePersonaDataIdentifiedPhoneNumber.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePoolAddress
private struct FfiConverterSequenceTypePoolAddress: FfiConverterRustBuffer {
	typealias SwiftType = [PoolAddress]

	public static func write(_ value: [PoolAddress], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePoolAddress.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PoolAddress] {
		let len: Int32 = try readInt(&buf)
		var seq = [PoolAddress]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePoolAddress.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeProfileNetwork
private struct FfiConverterSequenceTypeProfileNetwork: FfiConverterRustBuffer {
	typealias SwiftType = [ProfileNetwork]

	public static func write(_ value: [ProfileNetwork], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeProfileNetwork.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ProfileNetwork] {
		let len: Int32 = try readInt(&buf)
		var seq = [ProfileNetwork]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeProfileNetwork.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeResourceAddress
private struct FfiConverterSequenceTypeResourceAddress: FfiConverterRustBuffer {
	typealias SwiftType = [ResourceAddress]

	public static func write(_ value: [ResourceAddress], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeResourceAddress.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress] {
		let len: Int32 = try readInt(&buf)
		var seq = [ResourceAddress]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeResourceAddress.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeResourceAppPreference
private struct FfiConverterSequenceTypeResourceAppPreference: FfiConverterRustBuffer {
	typealias SwiftType = [ResourceAppPreference]

	public static func write(_ value: [ResourceAppPreference], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeResourceAppPreference.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAppPreference] {
		let len: Int32 = try readInt(&buf)
		var seq = [ResourceAppPreference]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeResourceAppPreference.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs
private struct FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs: FfiConverterRustBuffer {
	typealias SwiftType = [SecurityStructureOfFactorSourceIDs]

	public static func write(_ value: [SecurityStructureOfFactorSourceIDs], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeSecurityStructureOfFactorSourceIDs.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityStructureOfFactorSourceIDs] {
		let len: Int32 = try readInt(&buf)
		var seq = [SecurityStructureOfFactorSourceIDs]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeSecurityStructureOfFactorSourceIDs.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeSecurityStructureOfFactorSources
private struct FfiConverterSequenceTypeSecurityStructureOfFactorSources: FfiConverterRustBuffer {
	typealias SwiftType = [SecurityStructureOfFactorSources]

	public static func write(_ value: [SecurityStructureOfFactorSources], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeSecurityStructureOfFactorSources.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityStructureOfFactorSources] {
		let len: Int32 = try readInt(&buf)
		var seq = [SecurityStructureOfFactorSources]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeSecurityStructureOfFactorSources.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question
private struct FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question: FfiConverterRustBuffer {
	typealias SwiftType = [SecurityNotProductionReadyQuestion]

	public static func write(_ value: [SecurityNotProductionReadyQuestion], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityNotProductionReadyQuestion] {
		let len: Int32 = try readInt(&buf)
		var seq = [SecurityNotProductionReadyQuestion]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer
private struct FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer: FfiConverterRustBuffer {
	typealias SwiftType = [SecurityNotProductionReadyQuestionAndAnswer]

	public static func write(_ value: [SecurityNotProductionReadyQuestionAndAnswer], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityNotProductionReadyQuestionAndAnswer] {
		let len: Int32 = try readInt(&buf)
		var seq = [SecurityNotProductionReadyQuestionAndAnswer]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeStakeClaim
private struct FfiConverterSequenceTypeStakeClaim: FfiConverterRustBuffer {
	typealias SwiftType = [StakeClaim]

	public static func write(_ value: [StakeClaim], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeStakeClaim.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [StakeClaim] {
		let len: Int32 = try readInt(&buf)
		var seq = [StakeClaim]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeStakeClaim.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeTrackedPoolContribution
private struct FfiConverterSequenceTypeTrackedPoolContribution: FfiConverterRustBuffer {
	typealias SwiftType = [TrackedPoolContribution]

	public static func write(_ value: [TrackedPoolContribution], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeTrackedPoolContribution.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedPoolContribution] {
		let len: Int32 = try readInt(&buf)
		var seq = [TrackedPoolContribution]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeTrackedPoolContribution.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeTrackedPoolRedemption
private struct FfiConverterSequenceTypeTrackedPoolRedemption: FfiConverterRustBuffer {
	typealias SwiftType = [TrackedPoolRedemption]

	public static func write(_ value: [TrackedPoolRedemption], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeTrackedPoolRedemption.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedPoolRedemption] {
		let len: Int32 = try readInt(&buf)
		var seq = [TrackedPoolRedemption]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeTrackedPoolRedemption.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeTrackedValidatorClaim
private struct FfiConverterSequenceTypeTrackedValidatorClaim: FfiConverterRustBuffer {
	typealias SwiftType = [TrackedValidatorClaim]

	public static func write(_ value: [TrackedValidatorClaim], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeTrackedValidatorClaim.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorClaim] {
		let len: Int32 = try readInt(&buf)
		var seq = [TrackedValidatorClaim]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeTrackedValidatorClaim.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeTrackedValidatorStake
private struct FfiConverterSequenceTypeTrackedValidatorStake: FfiConverterRustBuffer {
	typealias SwiftType = [TrackedValidatorStake]

	public static func write(_ value: [TrackedValidatorStake], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeTrackedValidatorStake.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorStake] {
		let len: Int32 = try readInt(&buf)
		var seq = [TrackedValidatorStake]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeTrackedValidatorStake.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeTransactionGuarantee
private struct FfiConverterSequenceTypeTransactionGuarantee: FfiConverterRustBuffer {
	typealias SwiftType = [TransactionGuarantee]

	public static func write(_ value: [TransactionGuarantee], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeTransactionGuarantee.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionGuarantee] {
		let len: Int32 = try readInt(&buf)
		var seq = [TransactionGuarantee]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeTransactionGuarantee.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeValidatorAddress
private struct FfiConverterSequenceTypeValidatorAddress: FfiConverterRustBuffer {
	typealias SwiftType = [ValidatorAddress]

	public static func write(_ value: [ValidatorAddress], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeValidatorAddress.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ValidatorAddress] {
		let len: Int32 = try readInt(&buf)
		var seq = [ValidatorAddress]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeValidatorAddress.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeWalletInteractionWalletAccount
private struct FfiConverterSequenceTypeWalletInteractionWalletAccount: FfiConverterRustBuffer {
	typealias SwiftType = [WalletInteractionWalletAccount]

	public static func write(_ value: [WalletInteractionWalletAccount], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeWalletInteractionWalletAccount.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletInteractionWalletAccount] {
		let len: Int32 = try readInt(&buf)
		var seq = [WalletInteractionWalletAccount]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeWalletInteractionWalletAccount.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeWalletToDappInteractionAccountProof
private struct FfiConverterSequenceTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
	typealias SwiftType = [WalletToDappInteractionAccountProof]

	public static func write(_ value: [WalletToDappInteractionAccountProof], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeWalletToDappInteractionAccountProof.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletToDappInteractionAccountProof] {
		let len: Int32 = try readInt(&buf)
		var seq = [WalletToDappInteractionAccountProof]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeWalletToDappInteractionAccountProof.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAccountLockerClaimableResource
private struct FfiConverterSequenceTypeAccountLockerClaimableResource: FfiConverterRustBuffer {
	typealias SwiftType = [AccountLockerClaimableResource]

	public static func write(_ value: [AccountLockerClaimableResource], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAccountLockerClaimableResource.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountLockerClaimableResource] {
		let len: Int32 = try readInt(&buf)
		var seq = [AccountLockerClaimableResource]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAccountLockerClaimableResource.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAccountOrPersona
private struct FfiConverterSequenceTypeAccountOrPersona: FfiConverterRustBuffer {
	typealias SwiftType = [AccountOrPersona]

	public static func write(_ value: [AccountOrPersona], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAccountOrPersona.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountOrPersona] {
		let len: Int32 = try readInt(&buf)
		var seq = [AccountOrPersona]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAccountOrPersona.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAccountWithdraw
private struct FfiConverterSequenceTypeAccountWithdraw: FfiConverterRustBuffer {
	typealias SwiftType = [AccountWithdraw]

	public static func write(_ value: [AccountWithdraw], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAccountWithdraw.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountWithdraw] {
		let len: Int32 = try readInt(&buf)
		var seq = [AccountWithdraw]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAccountWithdraw.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAddress
private struct FfiConverterSequenceTypeAddress: FfiConverterRustBuffer {
	typealias SwiftType = [Address]

	public static func write(_ value: [Address], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAddress.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Address] {
		let len: Int32 = try readInt(&buf)
		var seq = [Address]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAddress.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeAddressOfAccountOrPersona
private struct FfiConverterSequenceTypeAddressOfAccountOrPersona: FfiConverterRustBuffer {
	typealias SwiftType = [AddressOfAccountOrPersona]

	public static func write(_ value: [AddressOfAccountOrPersona], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeAddressOfAccountOrPersona.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AddressOfAccountOrPersona] {
		let len: Int32 = try readInt(&buf)
		var seq = [AddressOfAccountOrPersona]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeAddressOfAccountOrPersona.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeBIP39WordCount
private struct FfiConverterSequenceTypeBIP39WordCount: FfiConverterRustBuffer {
	typealias SwiftType = [Bip39WordCount]

	public static func write(_ value: [Bip39WordCount], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeBIP39WordCount.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip39WordCount] {
		let len: Int32 = try readInt(&buf)
		var seq = [Bip39WordCount]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeBIP39WordCount.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeDerivationPath
private struct FfiConverterSequenceTypeDerivationPath: FfiConverterRustBuffer {
	typealias SwiftType = [DerivationPath]

	public static func write(_ value: [DerivationPath], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeDerivationPath.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationPath] {
		let len: Int32 = try readInt(&buf)
		var seq = [DerivationPath]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeDerivationPath.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeDerivationPathScheme
private struct FfiConverterSequenceTypeDerivationPathScheme: FfiConverterRustBuffer {
	typealias SwiftType = [DerivationPathScheme]

	public static func write(_ value: [DerivationPathScheme], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeDerivationPathScheme.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationPathScheme] {
		let len: Int32 = try readInt(&buf)
		var seq = [DerivationPathScheme]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeDerivationPathScheme.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeDetailedManifestClass
private struct FfiConverterSequenceTypeDetailedManifestClass: FfiConverterRustBuffer {
	typealias SwiftType = [DetailedManifestClass]

	public static func write(_ value: [DetailedManifestClass], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeDetailedManifestClass.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DetailedManifestClass] {
		let len: Int32 = try readInt(&buf)
		var seq = [DetailedManifestClass]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeDetailedManifestClass.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeEntityFlag
private struct FfiConverterSequenceTypeEntityFlag: FfiConverterRustBuffer {
	typealias SwiftType = [EntityFlag]

	public static func write(_ value: [EntityFlag], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeEntityFlag.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityFlag] {
		let len: Int32 = try readInt(&buf)
		var seq = [EntityFlag]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeEntityFlag.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeEventKind
private struct FfiConverterSequenceTypeEventKind: FfiConverterRustBuffer {
	typealias SwiftType = [EventKind]

	public static func write(_ value: [EventKind], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeEventKind.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EventKind] {
		let len: Int32 = try readInt(&buf)
		var seq = [EventKind]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeEventKind.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeFactorSource
private struct FfiConverterSequenceTypeFactorSource: FfiConverterRustBuffer {
	typealias SwiftType = [FactorSource]

	public static func write(_ value: [FactorSource], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeFactorSource.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSource] {
		let len: Int32 = try readInt(&buf)
		var seq = [FactorSource]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeFactorSource.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeFactorSourceFlag
private struct FfiConverterSequenceTypeFactorSourceFlag: FfiConverterRustBuffer {
	typealias SwiftType = [FactorSourceFlag]

	public static func write(_ value: [FactorSourceFlag], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeFactorSourceFlag.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceFlag] {
		let len: Int32 = try readInt(&buf)
		var seq = [FactorSourceFlag]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeFactorSourceFlag.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeFactorSourceID
private struct FfiConverterSequenceTypeFactorSourceID: FfiConverterRustBuffer {
	typealias SwiftType = [FactorSourceId]

	public static func write(_ value: [FactorSourceId], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeFactorSourceID.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceId] {
		let len: Int32 = try readInt(&buf)
		var seq = [FactorSourceId]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeFactorSourceID.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeHDPathComponent
private struct FfiConverterSequenceTypeHDPathComponent: FfiConverterRustBuffer {
	typealias SwiftType = [HdPathComponent]

	public static func write(_ value: [HdPathComponent], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeHDPathComponent.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HdPathComponent] {
		let len: Int32 = try readInt(&buf)
		var seq = [HdPathComponent]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeHDPathComponent.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeHomeCard
private struct FfiConverterSequenceTypeHomeCard: FfiConverterRustBuffer {
	typealias SwiftType = [HomeCard]

	public static func write(_ value: [HomeCard], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeHomeCard.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HomeCard] {
		let len: Int32 = try readInt(&buf)
		var seq = [HomeCard]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeHomeCard.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeLogFilter
private struct FfiConverterSequenceTypeLogFilter: FfiConverterRustBuffer {
	typealias SwiftType = [LogFilter]

	public static func write(_ value: [LogFilter], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeLogFilter.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LogFilter] {
		let len: Int32 = try readInt(&buf)
		var seq = [LogFilter]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeLogFilter.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeLogLevel
private struct FfiConverterSequenceTypeLogLevel: FfiConverterRustBuffer {
	typealias SwiftType = [LogLevel]

	public static func write(_ value: [LogLevel], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeLogLevel.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LogLevel] {
		let len: Int32 = try readInt(&buf)
		var seq = [LogLevel]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeLogLevel.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeManifestEncounteredComponentAddress
private struct FfiConverterSequenceTypeManifestEncounteredComponentAddress: FfiConverterRustBuffer {
	typealias SwiftType = [ManifestEncounteredComponentAddress]

	public static func write(_ value: [ManifestEncounteredComponentAddress], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeManifestEncounteredComponentAddress.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestEncounteredComponentAddress] {
		let len: Int32 = try readInt(&buf)
		var seq = [ManifestEncounteredComponentAddress]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeManifestEncounteredComponentAddress.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeNetworkID
private struct FfiConverterSequenceTypeNetworkID: FfiConverterRustBuffer {
	typealias SwiftType = [NetworkId]

	public static func write(_ value: [NetworkId], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeNetworkID.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NetworkId] {
		let len: Int32 = try readInt(&buf)
		var seq = [NetworkId]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeNetworkID.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeNonFungibleLocalId
private struct FfiConverterSequenceTypeNonFungibleLocalId: FfiConverterRustBuffer {
	typealias SwiftType = [NonFungibleLocalId]

	public static func write(_ value: [NonFungibleLocalId], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeNonFungibleLocalId.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleLocalId] {
		let len: Int32 = try readInt(&buf)
		var seq = [NonFungibleLocalId]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeNonFungibleLocalId.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePublicKeyHash
private struct FfiConverterSequenceTypePublicKeyHash: FfiConverterRustBuffer {
	typealias SwiftType = [PublicKeyHash]

	public static func write(_ value: [PublicKeyHash], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePublicKeyHash.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKeyHash] {
		let len: Int32 = try readInt(&buf)
		var seq = [PublicKeyHash]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePublicKeyHash.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeReservedInstruction
private struct FfiConverterSequenceTypeReservedInstruction: FfiConverterRustBuffer {
	typealias SwiftType = [ReservedInstruction]

	public static func write(_ value: [ReservedInstruction], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeReservedInstruction.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReservedInstruction] {
		let len: Int32 = try readInt(&buf)
		var seq = [ReservedInstruction]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeReservedInstruction.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeResourceIdentifier
private struct FfiConverterSequenceTypeResourceIdentifier: FfiConverterRustBuffer {
	typealias SwiftType = [ResourceIdentifier]

	public static func write(_ value: [ResourceIdentifier], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeResourceIdentifier.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceIdentifier] {
		let len: Int32 = try readInt(&buf)
		var seq = [ResourceIdentifier]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeResourceIdentifier.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeResourceIndicator
private struct FfiConverterSequenceTypeResourceIndicator: FfiConverterRustBuffer {
	typealias SwiftType = [ResourceIndicator]

	public static func write(_ value: [ResourceIndicator], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeResourceIndicator.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceIndicator] {
		let len: Int32 = try readInt(&buf)
		var seq = [ResourceIndicator]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeResourceIndicator.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeResourceOrNonFungible
private struct FfiConverterSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
	typealias SwiftType = [ResourceOrNonFungible]

	public static func write(_ value: [ResourceOrNonFungible], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeResourceOrNonFungible.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceOrNonFungible] {
		let len: Int32 = try readInt(&buf)
		var seq = [ResourceOrNonFungible]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeResourceOrNonFungible.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeResourceSpecifier
private struct FfiConverterSequenceTypeResourceSpecifier: FfiConverterRustBuffer {
	typealias SwiftType = [ResourceSpecifier]

	public static func write(_ value: [ResourceSpecifier], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeResourceSpecifier.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceSpecifier] {
		let len: Int32 = try readInt(&buf)
		var seq = [ResourceSpecifier]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeResourceSpecifier.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeSLIP10Curve
private struct FfiConverterSequenceTypeSLIP10Curve: FfiConverterRustBuffer {
	typealias SwiftType = [Slip10Curve]

	public static func write(_ value: [Slip10Curve], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeSLIP10Curve.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Slip10Curve] {
		let len: Int32 = try readInt(&buf)
		var seq = [Slip10Curve]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeSLIP10Curve.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeSimpleResourceBounds
private struct FfiConverterSequenceTypeSimpleResourceBounds: FfiConverterRustBuffer {
	typealias SwiftType = [SimpleResourceBounds]

	public static func write(_ value: [SimpleResourceBounds], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeSimpleResourceBounds.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SimpleResourceBounds] {
		let len: Int32 = try readInt(&buf)
		var seq = [SimpleResourceBounds]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeSimpleResourceBounds.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypeWalletToDappInteractionProofOfOwnership
private struct FfiConverterSequenceTypeWalletToDappInteractionProofOfOwnership: FfiConverterRustBuffer {
	typealias SwiftType = [WalletToDappInteractionProofOfOwnership]

	public static func write(_ value: [WalletToDappInteractionProofOfOwnership], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypeWalletToDappInteractionProofOfOwnership.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletToDappInteractionProofOfOwnership] {
		let len: Int32 = try readInt(&buf)
		var seq = [WalletToDappInteractionProofOfOwnership]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypeWalletToDappInteractionProofOfOwnership.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceSequenceTypeFactorInstanceForDebugPurposes
private struct FfiConverterSequenceSequenceTypeFactorInstanceForDebugPurposes: FfiConverterRustBuffer {
	typealias SwiftType = [[FactorInstanceForDebugPurposes]]

	public static func write(_ value: [[FactorInstanceForDebugPurposes]], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterSequenceTypeFactorInstanceForDebugPurposes.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[FactorInstanceForDebugPurposes]] {
		let len: Int32 = try readInt(&buf)
		var seq = [[FactorInstanceForDebugPurposes]]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterSequenceTypeFactorInstanceForDebugPurposes.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterSequenceTypePersonaDataEntryID
private struct FfiConverterSequenceTypePersonaDataEntryID: FfiConverterRustBuffer {
	typealias SwiftType = [PersonaDataEntryId]

	public static func write(_ value: [PersonaDataEntryId], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for item in value {
			FfiConverterTypePersonaDataEntryID.write(item, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataEntryId] {
		let len: Int32 = try readInt(&buf)
		var seq = [PersonaDataEntryId]()
		seq.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			try seq.append(FfiConverterTypePersonaDataEntryID.read(from: &buf))
		}
		return seq
	}
}

// MARK: - FfiConverterDictionaryStringString
private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
	public static func write(_ value: [String: String], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterString.write(key, into: &buf)
			FfiConverterString.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
		let len: Int32 = try readInt(&buf)
		var dict = [String: String]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterString.read(from: &buf)
			let value = try FfiConverterString.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

// MARK: - FfiConverterDictionaryTypeAccountAddressBool
private struct FfiConverterDictionaryTypeAccountAddressBool: FfiConverterRustBuffer {
	public static func write(_ value: [AccountAddress: Bool], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterTypeAccountAddress.write(key, into: &buf)
			FfiConverterBool.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: Bool] {
		let len: Int32 = try readInt(&buf)
		var dict = [AccountAddress: Bool]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterTypeAccountAddress.read(from: &buf)
			let value = try FfiConverterBool.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

// MARK: - FfiConverterDictionaryTypeAccountAddressTypeAccountDeposits
private struct FfiConverterDictionaryTypeAccountAddressTypeAccountDeposits: FfiConverterRustBuffer {
	public static func write(_ value: [AccountAddress: AccountDeposits], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterTypeAccountAddress.write(key, into: &buf)
			FfiConverterTypeAccountDeposits.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: AccountDeposits] {
		let len: Int32 = try readInt(&buf)
		var dict = [AccountAddress: AccountDeposits]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterTypeAccountAddress.read(from: &buf)
			let value = try FfiConverterTypeAccountDeposits.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

// MARK: - FfiConverterDictionaryTypeAccountAddressTypeDepositRule
private struct FfiConverterDictionaryTypeAccountAddressTypeDepositRule: FfiConverterRustBuffer {
	public static func write(_ value: [AccountAddress: DepositRule], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterTypeAccountAddress.write(key, into: &buf)
			FfiConverterTypeDepositRule.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: DepositRule] {
		let len: Int32 = try readInt(&buf)
		var dict = [AccountAddress: DepositRule]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterTypeAccountAddress.read(from: &buf)
			let value = try FfiConverterTypeDepositRule.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

// MARK: - FfiConverterDictionaryTypeAccountAddressSequenceTypeAccountWithdraw
private struct FfiConverterDictionaryTypeAccountAddressSequenceTypeAccountWithdraw: FfiConverterRustBuffer {
	public static func write(_ value: [AccountAddress: [AccountWithdraw]], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterTypeAccountAddress.write(key, into: &buf)
			FfiConverterSequenceTypeAccountWithdraw.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [AccountWithdraw]] {
		let len: Int32 = try readInt(&buf)
		var dict = [AccountAddress: [AccountWithdraw]]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterTypeAccountAddress.read(from: &buf)
			let value = try FfiConverterSequenceTypeAccountWithdraw.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

// MARK: - FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator
private struct FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator: FfiConverterRustBuffer {
	public static func write(_ value: [AccountAddress: [ResourceIndicator]], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterTypeAccountAddress.write(key, into: &buf)
			FfiConverterSequenceTypeResourceIndicator.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceIndicator]] {
		let len: Int32 = try readInt(&buf)
		var dict = [AccountAddress: [ResourceIndicator]]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterTypeAccountAddress.read(from: &buf)
			let value = try FfiConverterSequenceTypeResourceIndicator.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

// MARK: - FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible
private struct FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
	public static func write(_ value: [AccountAddress: [ResourceOrNonFungible]], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterTypeAccountAddress.write(key, into: &buf)
			FfiConverterSequenceTypeResourceOrNonFungible.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceOrNonFungible]] {
		let len: Int32 = try readInt(&buf)
		var dict = [AccountAddress: [ResourceOrNonFungible]]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterTypeAccountAddress.read(from: &buf)
			let value = try FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

// MARK: - FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate
private struct FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
	public static func write(_ value: [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterTypeAccountAddress.write(key, into: &buf)
			FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]] {
		let len: Int32 = try readInt(&buf)
		var dict = [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterTypeAccountAddress.read(from: &buf)
			let value = try FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

// MARK: - FfiConverterDictionaryTypeFactorSourceIDFromHashSequenceSequenceTypeFactorInstanceForDebugPurposes
private struct FfiConverterDictionaryTypeFactorSourceIDFromHashSequenceSequenceTypeFactorInstanceForDebugPurposes: FfiConverterRustBuffer {
	public static func write(_ value: [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterTypeFactorSourceIDFromHash.write(key, into: &buf)
			FfiConverterSequenceSequenceTypeFactorInstanceForDebugPurposes.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]] {
		let len: Int32 = try readInt(&buf)
		var dict = [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
			let value = try FfiConverterSequenceSequenceTypeFactorInstanceForDebugPurposes.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

// MARK: - FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData
private struct FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData: FfiConverterRustBuffer {
	public static func write(_ value: [NonFungibleGlobalId: UnstakeData], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterTypeNonFungibleGlobalId.write(key, into: &buf)
			FfiConverterTypeUnstakeData.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId: UnstakeData] {
		let len: Int32 = try readInt(&buf)
		var dict = [NonFungibleGlobalId: UnstakeData]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
			let value = try FfiConverterTypeUnstakeData.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

// MARK: - FfiConverterDictionaryTypeResourceAddressTypeDecimal192
private struct FfiConverterDictionaryTypeResourceAddressTypeDecimal192: FfiConverterRustBuffer {
	public static func write(_ value: [ResourceAddress: Decimal192], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterTypeResourceAddress.write(key, into: &buf)
			FfiConverterTypeDecimal192.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: Decimal192] {
		let len: Int32 = try readInt(&buf)
		var dict = [ResourceAddress: Decimal192]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterTypeResourceAddress.read(from: &buf)
			let value = try FfiConverterTypeDecimal192.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

// MARK: - FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource
private struct FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource: FfiConverterRustBuffer {
	public static func write(_ value: [ResourceAddress: NewlyCreatedResource], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterTypeResourceAddress.write(key, into: &buf)
			FfiConverterTypeNewlyCreatedResource.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: NewlyCreatedResource] {
		let len: Int32 = try readInt(&buf)
		var dict = [ResourceAddress: NewlyCreatedResource]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterTypeResourceAddress.read(from: &buf)
			let value = try FfiConverterTypeNewlyCreatedResource.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

// MARK: - FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate
private struct FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
	public static func write(_ value: [ResourceAddress: ResourcePreferenceUpdate], into buf: inout [UInt8]) {
		let len = Int32(value.count)
		writeInt(&buf, len)
		for (key, value) in value {
			FfiConverterTypeResourceAddress.write(key, into: &buf)
			FfiConverterTypeResourcePreferenceUpdate.write(value, into: &buf)
		}
	}

	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: ResourcePreferenceUpdate] {
		let len: Int32 = try readInt(&buf)
		var dict = [ResourceAddress: ResourcePreferenceUpdate]()
		dict.reserveCapacity(Int(len))
		for _ in 0 ..< len {
			let key = try FfiConverterTypeResourceAddress.read(from: &buf)
			let value = try FfiConverterTypeResourcePreferenceUpdate.read(from: &buf)
			dict[key] = value
		}
		return dict
	}
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bip39Passphrase = String

// MARK: - FfiConverterTypeBIP39Passphrase
public struct FfiConverterTypeBIP39Passphrase: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Passphrase {
		try FfiConverterString.read(from: &buf)
	}

	public static func write(_ value: Bip39Passphrase, into buf: inout [UInt8]) {
		FfiConverterString.write(value, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> Bip39Passphrase {
		try FfiConverterString.lift(value)
	}

	public static func lower(_ value: Bip39Passphrase) -> RustBuffer {
		FfiConverterString.lower(value)
	}
}

public func FfiConverterTypeBIP39Passphrase_lift(_ value: RustBuffer) throws -> Bip39Passphrase {
	try FfiConverterTypeBIP39Passphrase.lift(value)
}

public func FfiConverterTypeBIP39Passphrase_lower(_ value: Bip39Passphrase) -> RustBuffer {
	FfiConverterTypeBIP39Passphrase.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BagOfBytes = Data

// MARK: - FfiConverterTypeBagOfBytes
public struct FfiConverterTypeBagOfBytes: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BagOfBytes {
		let builtinValue = try FfiConverterSequenceInt8.read(from: &buf)
		return Data(builtinValue.map { i8 in UInt8(bitPattern: i8) })
	}

	public static func write(_ value: BagOfBytes, into buf: inout [UInt8]) {
		let builtinValue = value.map { u8 in Int8(bitPattern: u8) }
		return FfiConverterSequenceInt8.write(builtinValue, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> BagOfBytes {
		let builtinValue = try FfiConverterSequenceInt8.lift(value)
		return Data(builtinValue.map { i8 in UInt8(bitPattern: i8) })
	}

	public static func lower(_ value: BagOfBytes) -> RustBuffer {
		let builtinValue = value.map { u8 in Int8(bitPattern: u8) }
		return FfiConverterSequenceInt8.lower(builtinValue)
	}
}

public func FfiConverterTypeBagOfBytes_lift(_ value: RustBuffer) throws -> BagOfBytes {
	try FfiConverterTypeBagOfBytes.lift(value)
}

public func FfiConverterTypeBagOfBytes_lower(_ value: BagOfBytes) -> RustBuffer {
	FfiConverterTypeBagOfBytes.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DappOrigin = String

// MARK: - FfiConverterTypeDappOrigin
public struct FfiConverterTypeDappOrigin: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappOrigin {
		try FfiConverterString.read(from: &buf)
	}

	public static func write(_ value: DappOrigin, into buf: inout [UInt8]) {
		FfiConverterString.write(value, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> DappOrigin {
		try FfiConverterString.lift(value)
	}

	public static func lower(_ value: DappOrigin) -> RustBuffer {
		FfiConverterString.lower(value)
	}
}

public func FfiConverterTypeDappOrigin_lift(_ value: RustBuffer) throws -> DappOrigin {
	try FfiConverterTypeDappOrigin.lift(value)
}

public func FfiConverterTypeDappOrigin_lower(_ value: DappOrigin) -> RustBuffer {
	FfiConverterTypeDappOrigin.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DappToWalletInteractionAuthChallengeNonce = Exactly32Bytes

// MARK: - FfiConverterTypeDappToWalletInteractionAuthChallengeNonce
public struct FfiConverterTypeDappToWalletInteractionAuthChallengeNonce: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthChallengeNonce {
		try FfiConverterTypeExactly32Bytes.read(from: &buf)
	}

	public static func write(_ value: DappToWalletInteractionAuthChallengeNonce, into buf: inout [UInt8]) {
		FfiConverterTypeExactly32Bytes.write(value, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> DappToWalletInteractionAuthChallengeNonce {
		try FfiConverterTypeExactly32Bytes.lift(value)
	}

	public static func lower(_ value: DappToWalletInteractionAuthChallengeNonce) -> RustBuffer {
		FfiConverterTypeExactly32Bytes.lower(value)
	}
}

public func FfiConverterTypeDappToWalletInteractionAuthChallengeNonce_lift(_ value: RustBuffer) throws -> DappToWalletInteractionAuthChallengeNonce {
	try FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.lift(value)
}

public func FfiConverterTypeDappToWalletInteractionAuthChallengeNonce_lower(_ value: DappToWalletInteractionAuthChallengeNonce) -> RustBuffer {
	FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DeviceId = Uuid

// MARK: - FfiConverterTypeDeviceID
public struct FfiConverterTypeDeviceID: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceId {
		try FfiConverterTypeUuid.read(from: &buf)
	}

	public static func write(_ value: DeviceId, into buf: inout [UInt8]) {
		FfiConverterTypeUuid.write(value, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> DeviceId {
		try FfiConverterTypeUuid.lift(value)
	}

	public static func lower(_ value: DeviceId) -> RustBuffer {
		FfiConverterTypeUuid.lower(value)
	}
}

public func FfiConverterTypeDeviceID_lift(_ value: RustBuffer) throws -> DeviceId {
	try FfiConverterTypeDeviceID.lift(value)
}

public func FfiConverterTypeDeviceID_lower(_ value: DeviceId) -> RustBuffer {
	FfiConverterTypeDeviceID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Epoch = UInt64

// MARK: - FfiConverterTypeEpoch
public struct FfiConverterTypeEpoch: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Epoch {
		try FfiConverterUInt64.read(from: &buf)
	}

	public static func write(_ value: Epoch, into buf: inout [UInt8]) {
		FfiConverterUInt64.write(value, into: &buf)
	}

	public static func lift(_ value: UInt64) throws -> Epoch {
		try FfiConverterUInt64.lift(value)
	}

	public static func lower(_ value: Epoch) -> UInt64 {
		FfiConverterUInt64.lower(value)
	}
}

public func FfiConverterTypeEpoch_lift(_ value: UInt64) throws -> Epoch {
	try FfiConverterTypeEpoch.lift(value)
}

public func FfiConverterTypeEpoch_lower(_ value: Epoch) -> UInt64 {
	FfiConverterTypeEpoch.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PersonaDataEntryId = Uuid

// MARK: - FfiConverterTypePersonaDataEntryID
public struct FfiConverterTypePersonaDataEntryID: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryId {
		try FfiConverterTypeUuid.read(from: &buf)
	}

	public static func write(_ value: PersonaDataEntryId, into buf: inout [UInt8]) {
		FfiConverterTypeUuid.write(value, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> PersonaDataEntryId {
		try FfiConverterTypeUuid.lift(value)
	}

	public static func lower(_ value: PersonaDataEntryId) -> RustBuffer {
		FfiConverterTypeUuid.lower(value)
	}
}

public func FfiConverterTypePersonaDataEntryID_lift(_ value: RustBuffer) throws -> PersonaDataEntryId {
	try FfiConverterTypePersonaDataEntryID.lift(value)
}

public func FfiConverterTypePersonaDataEntryID_lower(_ value: PersonaDataEntryId) -> RustBuffer {
	FfiConverterTypePersonaDataEntryID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ProfileId = Uuid

// MARK: - FfiConverterTypeProfileID
public struct FfiConverterTypeProfileID: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileId {
		try FfiConverterTypeUuid.read(from: &buf)
	}

	public static func write(_ value: ProfileId, into buf: inout [UInt8]) {
		FfiConverterTypeUuid.write(value, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> ProfileId {
		try FfiConverterTypeUuid.lift(value)
	}

	public static func lower(_ value: ProfileId) -> RustBuffer {
		FfiConverterTypeUuid.lower(value)
	}
}

public func FfiConverterTypeProfileID_lift(_ value: RustBuffer) throws -> ProfileId {
	try FfiConverterTypeProfileID.lift(value)
}

public func FfiConverterTypeProfileID_lower(_ value: ProfileId) -> RustBuffer {
	FfiConverterTypeProfileID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SecurityStructureId = Uuid

// MARK: - FfiConverterTypeSecurityStructureID
public struct FfiConverterTypeSecurityStructureID: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureId {
		try FfiConverterTypeUuid.read(from: &buf)
	}

	public static func write(_ value: SecurityStructureId, into buf: inout [UInt8]) {
		FfiConverterTypeUuid.write(value, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> SecurityStructureId {
		try FfiConverterTypeUuid.lift(value)
	}

	public static func lower(_ value: SecurityStructureId) -> RustBuffer {
		FfiConverterTypeUuid.lower(value)
	}
}

public func FfiConverterTypeSecurityStructureID_lift(_ value: RustBuffer) throws -> SecurityStructureId {
	try FfiConverterTypeSecurityStructureID.lift(value)
}

public func FfiConverterTypeSecurityStructureID_lower(_ value: SecurityStructureId) -> RustBuffer {
	FfiConverterTypeSecurityStructureID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SessionId = Uuid

// MARK: - FfiConverterTypeSessionID
public struct FfiConverterTypeSessionID: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionId {
		try FfiConverterTypeUuid.read(from: &buf)
	}

	public static func write(_ value: SessionId, into buf: inout [UInt8]) {
		FfiConverterTypeUuid.write(value, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> SessionId {
		try FfiConverterTypeUuid.lift(value)
	}

	public static func lower(_ value: SessionId) -> RustBuffer {
		FfiConverterTypeUuid.lower(value)
	}
}

public func FfiConverterTypeSessionID_lift(_ value: RustBuffer) throws -> SessionId {
	try FfiConverterTypeSessionID.lift(value)
}

public func FfiConverterTypeSessionID_lower(_ value: SessionId) -> RustBuffer {
	FfiConverterTypeSessionID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SubintentVersion = UInt64

// MARK: - FfiConverterTypeSubintentVersion
public struct FfiConverterTypeSubintentVersion: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubintentVersion {
		try FfiConverterUInt64.read(from: &buf)
	}

	public static func write(_ value: SubintentVersion, into buf: inout [UInt8]) {
		FfiConverterUInt64.write(value, into: &buf)
	}

	public static func lift(_ value: UInt64) throws -> SubintentVersion {
		try FfiConverterUInt64.lift(value)
	}

	public static func lower(_ value: SubintentVersion) -> UInt64 {
		FfiConverterUInt64.lower(value)
	}
}

public func FfiConverterTypeSubintentVersion_lift(_ value: UInt64) throws -> SubintentVersion {
	try FfiConverterTypeSubintentVersion.lift(value)
}

public func FfiConverterTypeSubintentVersion_lower(_ value: SubintentVersion) -> UInt64 {
	FfiConverterTypeSubintentVersion.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TxVersion = UInt64

// MARK: - FfiConverterTypeTXVersion
public struct FfiConverterTypeTXVersion: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxVersion {
		try FfiConverterUInt64.read(from: &buf)
	}

	public static func write(_ value: TxVersion, into buf: inout [UInt8]) {
		FfiConverterUInt64.write(value, into: &buf)
	}

	public static func lift(_ value: UInt64) throws -> TxVersion {
		try FfiConverterUInt64.lift(value)
	}

	public static func lower(_ value: TxVersion) -> UInt64 {
		FfiConverterUInt64.lower(value)
	}
}

public func FfiConverterTypeTXVersion_lift(_ value: UInt64) throws -> TxVersion {
	try FfiConverterTypeTXVersion.lift(value)
}

public func FfiConverterTypeTXVersion_lower(_ value: TxVersion) -> UInt64 {
	FfiConverterTypeTXVersion.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Timestamp = Date

// MARK: - FfiConverterTypeTimestamp
public struct FfiConverterTypeTimestamp: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timestamp {
		let builtinValue = try FfiConverterString.read(from: &buf)
		return {
			let stringToDeserialize = builtinValue // this is UniFFIs counterpart to `$0`
			let formatter = ISO8601DateFormatter()
			let formatOptionMS = ISO8601DateFormatter.Options.withFractionalSeconds
			formatter.formatOptions.insert(formatOptionMS)

			func format() -> Date? {
				formatter.date(from: stringToDeserialize)
			}

			if let date = format() {
				return date
			}

			// try without fractional seconds
			formatter.formatOptions.remove(formatOptionMS)
			return format()!
		}()
	}

	public static func write(_ value: Timestamp, into buf: inout [UInt8]) {
		let builtinValue = {
			let dateToSerialize = value // this is UniFFIs counterpart to `$0`
			let formatter = ISO8601DateFormatter()
			formatter.formatOptions.insert(.withFractionalSeconds)
			return formatter.string(from: dateToSerialize)
		}()

		return FfiConverterString.write(builtinValue, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> Timestamp {
		let builtinValue = try FfiConverterString.lift(value)
		return {
			let stringToDeserialize = builtinValue // this is UniFFIs counterpart to `$0`
			let formatter = ISO8601DateFormatter()
			let formatOptionMS = ISO8601DateFormatter.Options.withFractionalSeconds
			formatter.formatOptions.insert(formatOptionMS)

			func format() -> Date? {
				formatter.date(from: stringToDeserialize)
			}

			if let date = format() {
				return date
			}

			// try without fractional seconds
			formatter.formatOptions.remove(formatOptionMS)
			return format()!
		}()
	}

	public static func lower(_ value: Timestamp) -> RustBuffer {
		let builtinValue = {
			let dateToSerialize = value // this is UniFFIs counterpart to `$0`
			let formatter = ISO8601DateFormatter()
			formatter.formatOptions.insert(.withFractionalSeconds)
			return formatter.string(from: dateToSerialize)
		}()

		return FfiConverterString.lower(builtinValue)
	}
}

public func FfiConverterTypeTimestamp_lift(_ value: RustBuffer) throws -> Timestamp {
	try FfiConverterTypeTimestamp.lift(value)
}

public func FfiConverterTypeTimestamp_lower(_ value: Timestamp) -> RustBuffer {
	FfiConverterTypeTimestamp.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Url = URL

// MARK: - FfiConverterTypeUrl
public struct FfiConverterTypeUrl: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Url {
		let builtinValue = try FfiConverterString.read(from: &buf)
		return URL(string: builtinValue)!
	}

	public static func write(_ value: Url, into buf: inout [UInt8]) {
		let builtinValue = String(describing: value)
		return FfiConverterString.write(builtinValue, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> Url {
		let builtinValue = try FfiConverterString.lift(value)
		return URL(string: builtinValue)!
	}

	public static func lower(_ value: Url) -> RustBuffer {
		let builtinValue = String(describing: value)
		return FfiConverterString.lower(builtinValue)
	}
}

public func FfiConverterTypeUrl_lift(_ value: RustBuffer) throws -> Url {
	try FfiConverterTypeUrl.lift(value)
}

public func FfiConverterTypeUrl_lower(_ value: Url) -> RustBuffer {
	FfiConverterTypeUrl.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Uuid = UUID

// MARK: - FfiConverterTypeUuid
public struct FfiConverterTypeUuid: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
		let builtinValue = try FfiConverterString.read(from: &buf)
		return UUID(uuidString: builtinValue)!
	}

	public static func write(_ value: Uuid, into buf: inout [UInt8]) {
		let builtinValue = value.uuidString
		return FfiConverterString.write(builtinValue, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> Uuid {
		let builtinValue = try FfiConverterString.lift(value)
		return UUID(uuidString: builtinValue)!
	}

	public static func lower(_ value: Uuid) -> RustBuffer {
		let builtinValue = value.uuidString
		return FfiConverterString.lower(builtinValue)
	}
}

public func FfiConverterTypeUuid_lift(_ value: RustBuffer) throws -> Uuid {
	try FfiConverterTypeUuid.lift(value)
}

public func FfiConverterTypeUuid_lower(_ value: Uuid) -> RustBuffer {
	FfiConverterTypeUuid.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletInteractionId = String

// MARK: - FfiConverterTypeWalletInteractionId
public struct FfiConverterTypeWalletInteractionId: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionId {
		try FfiConverterString.read(from: &buf)
	}

	public static func write(_ value: WalletInteractionId, into buf: inout [UInt8]) {
		FfiConverterString.write(value, into: &buf)
	}

	public static func lift(_ value: RustBuffer) throws -> WalletInteractionId {
		try FfiConverterString.lift(value)
	}

	public static func lower(_ value: WalletInteractionId) -> RustBuffer {
		FfiConverterString.lower(value)
	}
}

public func FfiConverterTypeWalletInteractionId_lift(_ value: RustBuffer) throws -> WalletInteractionId {
	try FfiConverterTypeWalletInteractionId.lift(value)
}

public func FfiConverterTypeWalletInteractionId_lower(_ value: WalletInteractionId) -> RustBuffer {
	FfiConverterTypeWalletInteractionId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletInteractionVersion = UInt64

// MARK: - FfiConverterTypeWalletInteractionVersion
public struct FfiConverterTypeWalletInteractionVersion: FfiConverter {
	public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionVersion {
		try FfiConverterUInt64.read(from: &buf)
	}

	public static func write(_ value: WalletInteractionVersion, into buf: inout [UInt8]) {
		FfiConverterUInt64.write(value, into: &buf)
	}

	public static func lift(_ value: UInt64) throws -> WalletInteractionVersion {
		try FfiConverterUInt64.lift(value)
	}

	public static func lower(_ value: WalletInteractionVersion) -> UInt64 {
		FfiConverterUInt64.lower(value)
	}
}

public func FfiConverterTypeWalletInteractionVersion_lift(_ value: UInt64) throws -> WalletInteractionVersion {
	try FfiConverterTypeWalletInteractionVersion.lift(value)
}

public func FfiConverterTypeWalletInteractionVersion_lower(_ value: WalletInteractionVersion) -> UInt64 {
	FfiConverterTypeWalletInteractionVersion.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

private func uniffiRustCallAsync<F, T>(
	rustFutureFunc: () -> UInt64,
	pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> Void,
	completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
	freeFunc: (UInt64) -> Void,
	liftFunc: (F) throws -> T,
	errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
	// Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
	// RustCallStatus param, so doesn't use makeRustCall()
	uniffiEnsureInitialized()
	let rustFuture = rustFutureFunc()
	defer {
		freeFunc(rustFuture)
	}
	var pollResult: Int8
	repeat {
		pollResult = await withUnsafeContinuation {
			pollFunc(
				rustFuture,
				uniffiFutureContinuationCallback,
				uniffiContinuationHandleMap.insert(obj: $0)
			)
		}
	} while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

	return try liftFunc(makeRustCall(
		{ completeFunc(rustFuture, $0) },
		errorHandler: errorHandler
	))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
	if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
		continuation.resume(returning: pollResult)
	} else {
		print("uniffiFutureContinuationCallback invalid handle")
	}
}

private func uniffiTraitInterfaceCallAsync<T>(
	makeCall: @escaping () async throws -> T,
	handleSuccess: @escaping (T) -> Void,
	handleError: @escaping (Int8, RustBuffer) -> Void
) -> UniffiForeignFuture {
	let task = Task {
		do {
			try await handleSuccess(makeCall())
		} catch {
			handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
		}
	}
	let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
	return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
	makeCall: @escaping () async throws -> T,
	handleSuccess: @escaping (T) -> Void,
	handleError: @escaping (Int8, RustBuffer) -> Void,
	lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
	let task = Task {
		do {
			try await handleSuccess(makeCall())
		} catch let error as E {
			handleError(CALL_ERROR, lowerError(error))
		} catch {
			handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
		}
	}
	let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
	return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
private var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// MARK: - UniffiForeignFutureTask
// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
	func cancel()
}

// MARK: - Task + UniffiForeignFutureTask
extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
	do {
		let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
		// Set the cancellation flag on the task.  If it's still running, the code can check the
		// cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
		// a no-op.
		task.cancel()
	} catch {
		print("uniffiForeignFutureFree: handle missing from handlemap")
	}
}

// For testing
public func uniffiForeignFutureHandleCountSargon() -> Int {
	UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}

public func accessControllerAddressBech32Address(address: AccessControllerAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_access_controller_address_bech32_address(
			FfiConverterTypeAccessControllerAddress.lower(address), $0
		)
	})
}

public func accessControllerAddressFormatted(address: AccessControllerAddress, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_access_controller_address_formatted(
			FfiConverterTypeAccessControllerAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func accessControllerAddressMapToNetwork(address: AccessControllerAddress, networkId: NetworkId) -> AccessControllerAddress {
	try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_access_controller_address_map_to_network(
			FfiConverterTypeAccessControllerAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func accessControllerAddressNetworkId(address: AccessControllerAddress) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_access_controller_address_network_id(
			FfiConverterTypeAccessControllerAddress.lower(address), $0
		)
	})
}

public func accountAddressBech32Address(address: AccountAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_account_address_bech32_address(
			FfiConverterTypeAccountAddress.lower(address), $0
		)
	})
}

public func accountAddressFormatted(address: AccountAddress, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_account_address_formatted(
			FfiConverterTypeAccountAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

/**
 * Returns `false` for all addresses created with `Ed25519PublicKey`s, i.e.
 * for all accounts created by the Babylon Radix Wallets.
 * Returns `true` for all addresses created with `Secp256k1PublicKey`s, i.e.
 * imported from the legacy Olympia desktop application.
 */
public func accountAddressIsLegacy(address: AccountAddress) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_account_address_is_legacy(
			FfiConverterTypeAccountAddress.lower(address), $0
		)
	})
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func accountAddressMapToNetwork(address: AccountAddress, networkId: NetworkId) -> AccountAddress {
	try! FfiConverterTypeAccountAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_account_address_map_to_network(
			FfiConverterTypeAccountAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func accountAddressNetworkId(address: AccountAddress) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_account_address_network_id(
			FfiConverterTypeAccountAddress.lower(address), $0
		)
	})
}

public func accountOrAddressOfAccountAddress(recipient: AccountOrAddressOf) -> AccountAddress {
	try! FfiConverterTypeAccountAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_account_or_address_of_account_address(
			FfiConverterTypeAccountOrAddressOf.lower(recipient), $0
		)
	})
}

public func accountOrPersonaGetId(entity: AccountOrPersona) -> AddressOfAccountOrPersona {
	try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_account_or_persona_get_id(
			FfiConverterTypeAccountOrPersona.lower(entity), $0
		)
	})
}

public func addressFormatted(address: Address, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_address_formatted(
			FfiConverterTypeAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

public func addressMapToNetwork(address: Address, networkId: NetworkId) -> Address {
	try! FfiConverterTypeAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_address_map_to_network(
			FfiConverterTypeAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func addressNetworkId(address: Address) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_address_network_id(
			FfiConverterTypeAddress.lower(address), $0
		)
	})
}

public func addressOfAccountOrPersonaFormatted(address: AddressOfAccountOrPersona, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_formatted(
			FfiConverterTypeAddressOfAccountOrPersona.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

public func addressOfAccountOrPersonaMapToNetwork(address: AddressOfAccountOrPersona, networkId: NetworkId) -> AddressOfAccountOrPersona {
	try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_map_to_network(
			FfiConverterTypeAddressOfAccountOrPersona.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func addressOfAccountOrPersonaNetworkId(address: AddressOfAccountOrPersona) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_network_id(
			FfiConverterTypeAddressOfAccountOrPersona.lower(address), $0
		)
	})
}

public func addressOfAccountOrPersonaSampleValuesAll() -> [AddressOfAccountOrPersona] {
	try! FfiConverterSequenceTypeAddressOfAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_sample_values_all($0
		)
	})
}

public func addressOfAccountOrPersonaToString(address: AddressOfAccountOrPersona) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_to_string(
			FfiConverterTypeAddressOfAccountOrPersona.lower(address), $0
		)
	})
}

public func addressSampleValuesAll() -> [Address] {
	try! FfiConverterSequenceTypeAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_address_sample_values_all($0
		)
	})
}

public func addressToString(address: Address) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_address_to_string(
			FfiConverterTypeAddress.lower(address), $0
		)
	})
}

public func androidNotarizeHashWithPrivateKeyBytes(privateKeyBytes: Exactly32Bytes, signedIntentHash: SignedTransactionIntentHash) throws -> NotarySignature {
	try FfiConverterTypeNotarySignature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_android_notarize_hash_with_private_key_bytes(
			FfiConverterTypeExactly32Bytes.lower(privateKeyBytes),
			FfiConverterTypeSignedTransactionIntentHash.lower(signedIntentHash), $0
		)
	})
}

public func androidSecretKeyGetPublicKeyFromPrivateKeyBytes(privateKeyBytes: Exactly32Bytes) throws -> Ed25519PublicKey {
	try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_android_secret_key_get_public_key_from_private_key_bytes(
			FfiConverterTypeExactly32Bytes.lower(privateKeyBytes), $0
		)
	})
}

public func androidSignHashWithPrivateKeyBytes(privateKeyBytes: Exactly32Bytes, hash: Hash) throws -> Ed25519Signature {
	try FfiConverterTypeEd25519Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_android_sign_hash_with_private_key_bytes(
			FfiConverterTypeExactly32Bytes.lower(privateKeyBytes),
			FfiConverterTypeHash.lower(hash), $0
		)
	})
}

public func appPreferencesHasGatewayWithUrl(appPreferences: AppPreferences, url: FfiUrl) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_app_preferences_has_gateway_with_url(
			FfiConverterTypeAppPreferences.lower(appPreferences),
			FfiConverterTypeFfiUrl.lower(url), $0
		)
	})
}

public func appearanceIdsAll() -> [AppearanceId] {
	try! FfiConverterSequenceTypeAppearanceID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_appearance_ids_all($0
		)
	})
}

public func arculusCardModelToString(model: ArculusCardModel) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_arculus_card_model_to_string(
			FfiConverterTypeArculusCardModel.lower(model), $0
		)
	})
}

public func authorizedDappToJsonBytes(authorizedDapp: AuthorizedDapp) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_authorized_dapp_to_json_bytes(
			FfiConverterTypeAuthorizedDapp.lower(authorizedDapp), $0
		)
	})
}

public func bIP39SeedToBytes(bytes: Bip39Seed) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_b_i_p39_seed_to_bytes(
			FfiConverterTypeBIP39Seed.lower(bytes), $0
		)
	})
}

public func bagOfBytesAppendCafe(to: BagOfBytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_bag_of_bytes_append_cafe(
			FfiConverterTypeBagOfBytes.lower(to), $0
		)
	})
}

public func bagOfBytesAppendDeadbeef(to: BagOfBytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_bag_of_bytes_append_deadbeef(
			FfiConverterTypeBagOfBytes.lower(to), $0
		)
	})
}

public func bagOfBytesPrependCafe(inFrontOf: BagOfBytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_bag_of_bytes_prepend_cafe(
			FfiConverterTypeBagOfBytes.lower(inFrontOf), $0
		)
	})
}

public func bagOfBytesPrependDeadbeef(inFrontOf: BagOfBytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_bag_of_bytes_prepend_deadbeef(
			FfiConverterTypeBagOfBytes.lower(inFrontOf), $0
		)
	})
}

public func bip32ConstantGlobalOffsetHardened() -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_bip32_constant_global_offset_hardened($0
		)
	})
}

public func bip32ConstantGlobalOffsetSecurified() -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_bip32_constant_global_offset_securified($0
		)
	})
}

public func bip39LanguageWordlist(language: Bip39Language) -> [Bip39Word] {
	try! FfiConverterSequenceTypeBIP39Word.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_bip39_language_wordlist(
			FfiConverterTypeBIP39Language.lower(language), $0
		)
	})
}

public func bip39WordCountAll() -> [Bip39WordCount] {
	try! FfiConverterSequenceTypeBIP39WordCount.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_bip39_word_count_all($0
		)
	})
}

public func bip44LikePathGetAddressIndex(path: Bip44LikePath) -> HdPathComponent {
	try! FfiConverterTypeHDPathComponent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_bip44_like_path_get_address_index(
			FfiConverterTypeBIP44LikePath.lower(path), $0
		)
	})
}

public func bip44LikePathToString(path: Bip44LikePath) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_bip44_like_path_to_string(
			FfiConverterTypeBIP44LikePath.lower(path), $0
		)
	})
}

public func blobToBytes(blob: Blob) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_blob_to_bytes(
			FfiConverterTypeBlob.lower(blob), $0
		)
	})
}

public func blobToString(blob: Blob) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_blob_to_string(
			FfiConverterTypeBlob.lower(blob), $0
		)
	})
}

public func blobsListOfBlobs(blobs: Blobs) -> [Blob] {
	try! FfiConverterSequenceTypeBlob.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_blobs_list_of_blobs(
			FfiConverterTypeBlobs.lower(blobs), $0
		)
	})
}

public func buildInformation() -> SargonBuildInformation {
	try! FfiConverterTypeSargonBuildInformation.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_build_information($0
		)
	})
}

public func checkIfEncryptedProfileJsonContainsLegacyP2pLinks(jsonStr: String, password: String) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_check_if_encrypted_profile_json_contains_legacy_p2p_links(
			FfiConverterString.lower(jsonStr),
			FfiConverterString.lower(password), $0
		)
	})
}

public func checkIfProfileJsonContainsLegacyP2pLinks(jsonStr: String) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_check_if_profile_json_contains_legacy_p2p_links(
			FfiConverterString.lower(jsonStr), $0
		)
	})
}

public func compiledNotarizedIntentGetBytes(compiledNotarizedIntent: CompiledNotarizedIntent) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_compiled_notarized_intent_get_bytes(
			FfiConverterTypeCompiledNotarizedIntent.lower(compiledNotarizedIntent), $0
		)
	})
}

public func compiledSubintentBytes(compiledIntent: CompiledSubintent) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_compiled_subintent_bytes(
			FfiConverterTypeCompiledSubintent.lower(compiledIntent), $0
		)
	})
}

public func compiledSubintentDecompile(compiledIntent: CompiledSubintent) -> Subintent {
	try! FfiConverterTypeSubintent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_compiled_subintent_decompile(
			FfiConverterTypeCompiledSubintent.lower(compiledIntent), $0
		)
	})
}

public func compiledTransactionIntentBytes(compiledIntent: CompiledTransactionIntent) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_compiled_transaction_intent_bytes(
			FfiConverterTypeCompiledTransactionIntent.lower(compiledIntent), $0
		)
	})
}

public func compiledTransactionIntentDecompile(compiledIntent: CompiledTransactionIntent) -> TransactionIntent {
	try! FfiConverterTypeTransactionIntent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_compiled_transaction_intent_decompile(
			FfiConverterTypeCompiledTransactionIntent.lower(compiledIntent), $0
		)
	})
}

public func componentAddressBech32Address(address: ComponentAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_component_address_bech32_address(
			FfiConverterTypeComponentAddress.lower(address), $0
		)
	})
}

public func componentAddressFormatted(address: ComponentAddress, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_component_address_formatted(
			FfiConverterTypeComponentAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

/**
 * Returns `true` if the ComponentAddress is `global` (i.e. not `internal`)
 */
public func componentAddressIsGlobal(address: ComponentAddress) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_component_address_is_global(
			FfiConverterTypeComponentAddress.lower(address), $0
		)
	})
}

/**
 * Returns `true` if the ComponentAddress is `internal` (i.e. not `global`)
 */
public func componentAddressIsInternal(address: ComponentAddress) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_component_address_is_internal(
			FfiConverterTypeComponentAddress.lower(address), $0
		)
	})
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func componentAddressMapToNetwork(address: ComponentAddress, networkId: NetworkId) -> ComponentAddress {
	try! FfiConverterTypeComponentAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_component_address_map_to_network(
			FfiConverterTypeComponentAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func componentAddressNetworkId(address: ComponentAddress) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_component_address_network_id(
			FfiConverterTypeComponentAddress.lower(address), $0
		)
	})
}

public func constantEntityNameMaxLength() -> UInt64 {
	try! FfiConverterUInt64.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_constant_entity_name_max_length($0
		)
	})
}

public func constantMinRequiredXrdForAccountDeletion() -> Double {
	try! FfiConverterDouble.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_constant_min_required_xrd_for_account_deletion($0
		)
	})
}

public func dappToWalletInteractionUnvalidatedToJsonBytes(dappToWalletInteractionUnvalidated: DappToWalletInteractionUnvalidated) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_dapp_to_wallet_interaction_unvalidated_to_json_bytes(
			FfiConverterTypeDappToWalletInteractionUnvalidated.lower(dappToWalletInteractionUnvalidated), $0
		)
	})
}

public func dappToWalletInteractionUnvalidatedToJsonString(interactionUnvalidated: DappToWalletInteractionUnvalidated) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_dapp_to_wallet_interaction_unvalidated_to_json_string(
			FfiConverterTypeDappToWalletInteractionUnvalidated.lower(interactionUnvalidated), $0
		)
	})
}

public func debugPrintCompiledNotarizedIntent(compiled: CompiledNotarizedIntent) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_debug_print_compiled_notarized_intent(
			FfiConverterTypeCompiledNotarizedIntent.lower(compiled), $0
		)
	})
}

/**
 * Returns `decimal.abs()`, panics if `decimal` is `Decimal192::MIN`
 */
public func decimalAbs(decimal: Decimal192) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_abs(
			FfiConverterTypeDecimal192.lower(decimal), $0
		)
	})
}

/**
 * `lhs + rhs``
 */
public func decimalAdd(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_add(
			FfiConverterTypeDecimal192.lower(lhs),
			FfiConverterTypeDecimal192.lower(rhs), $0
		)
	})
}

/**
 * Clamps `decimal` to zero, i.e. `max(decimal, 0)`
 */
public func decimalClampedToZero(decimal: Decimal192) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_clamped_to_zero(
			FfiConverterTypeDecimal192.lower(decimal), $0
		)
	})
}

/**
 * `lhs / rhs``
 */
public func decimalDiv(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_div(
			FfiConverterTypeDecimal192.lower(lhs),
			FfiConverterTypeDecimal192.lower(rhs), $0
		)
	})
}

public func decimalFormatted(decimal: Decimal192, locale: LocaleConfig, totalPlaces: UInt8, useGroupingSeparator: Bool) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_formatted(
			FfiConverterTypeDecimal192.lower(decimal),
			FfiConverterTypeLocaleConfig.lower(locale),
			FfiConverterUInt8.lower(totalPlaces),
			FfiConverterBool.lower(useGroupingSeparator), $0
		)
	})
}

/**
 * A human readable, locale respecting string. Does not perform any rounding or truncation.
 */
public func decimalFormattedPlain(decimal: Decimal192, locale: LocaleConfig, useGroupingSeparator: Bool) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_formatted_plain(
			FfiConverterTypeDecimal192.lower(decimal),
			FfiConverterTypeLocaleConfig.lower(locale),
			FfiConverterBool.lower(useGroupingSeparator), $0
		)
	})
}

/**
 * `lhs > rhs`
 */
public func decimalGreaterThan(lhs: Decimal192, rhs: Decimal192) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_greater_than(
			FfiConverterTypeDecimal192.lower(lhs),
			FfiConverterTypeDecimal192.lower(rhs), $0
		)
	})
}

/**
 * `lhs >= rhs`
 */
public func decimalGreaterThanOrEqual(lhs: Decimal192, rhs: Decimal192) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_greater_than_or_equal(
			FfiConverterTypeDecimal192.lower(lhs),
			FfiConverterTypeDecimal192.lower(rhs), $0
		)
	})
}

/**
 * Whether this decimal is negative.
 */
public func decimalIsNegative(decimal: Decimal192) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_is_negative(
			FfiConverterTypeDecimal192.lower(decimal), $0
		)
	})
}

/**
 * Whether this decimal is positive.
 */
public func decimalIsPositive(decimal: Decimal192) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_is_positive(
			FfiConverterTypeDecimal192.lower(decimal), $0
		)
	})
}

/**
 * Whether this decimal is zero.
 */
public func decimalIsZero(decimal: Decimal192) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_is_zero(
			FfiConverterTypeDecimal192.lower(decimal), $0
		)
	})
}

/**
 * `lhs < rhs`
 */
public func decimalLessThan(lhs: Decimal192, rhs: Decimal192) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_less_than(
			FfiConverterTypeDecimal192.lower(lhs),
			FfiConverterTypeDecimal192.lower(rhs), $0
		)
	})
}

/**
 * `lhs <= rhs`
 */
public func decimalLessThanOrEqual(lhs: Decimal192, rhs: Decimal192) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_less_than_or_equal(
			FfiConverterTypeDecimal192.lower(lhs),
			FfiConverterTypeDecimal192.lower(rhs), $0
		)
	})
}

/**
 * The maximum possible value of `Decimal192`, being:
 * `3138550867693340381917894711603833208051.177722232017256447`
 */
public func decimalMax() -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_max($0
		)
	})
}

/**
 * The minimum possible value of `Decimal192`, being:
 * `-3138550867693340381917894711603833208051.177722232017256448`
 */
public func decimalMin() -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_min($0
		)
	})
}

/**
 * `lhs * rhs``
 */
public func decimalMul(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_mul(
			FfiConverterTypeDecimal192.lower(lhs),
			FfiConverterTypeDecimal192.lower(rhs), $0
		)
	})
}

/**
 * Negates the `decimal`
 */
public func decimalNeg(decimal: Decimal192) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_neg(
			FfiConverterTypeDecimal192.lower(decimal), $0
		)
	})
}

/**
 * Rounds this number to the specified decimal places.
 *
 * # Panics
 * - Panic if the number of decimal places is not within [0..SCALE(=18)]
 */
public func decimalRound(decimal: Decimal192, decimalPlaces: UInt8, roundingMode: RoundingMode) throws -> Decimal192 {
	try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_decimal_round(
			FfiConverterTypeDecimal192.lower(decimal),
			FfiConverterUInt8.lower(decimalPlaces),
			FfiConverterTypeRoundingMode.lower(roundingMode), $0
		)
	})
}

/**
 * `lhs - rhs``
 */
public func decimalSub(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_sub(
			FfiConverterTypeDecimal192.lower(lhs),
			FfiConverterTypeDecimal192.lower(rhs), $0
		)
	})
}

/**
 * `decimal.to_string()`
 */
public func decimalToString(decimal: Decimal192) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_decimal_to_string(
			FfiConverterTypeDecimal192.lower(decimal), $0
		)
	})
}

public func dependencyInformationToString(info: DependencyInformation) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_dependency_information_to_string(
			FfiConverterTypeDependencyInformation.lower(info), $0
		)
	})
}

public func depositRuleToJsonString(depositRule: DepositRule) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_deposit_rule_to_json_string(
			FfiConverterTypeDepositRule.lower(depositRule), $0
		)
	})
}

public func derivationPathToHdPath(path: DerivationPath) -> HdPath {
	try! FfiConverterTypeHDPath.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_derivation_path_to_hd_path(
			FfiConverterTypeDerivationPath.lower(path), $0
		)
	})
}

public func derivationPathToString(path: DerivationPath) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_derivation_path_to_string(
			FfiConverterTypeDerivationPath.lower(path), $0
		)
	})
}

public func deviceFactorSourceIsMainBdfs(deviceFactorSource: DeviceFactorSource) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_device_factor_source_is_main_bdfs(
			FfiConverterTypeDeviceFactorSource.lower(deviceFactorSource), $0
		)
	})
}

public func deviceInfoDescriptionToString(deviceInfoDescription: DeviceInfoDescription) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_device_info_description_to_string(
			FfiConverterTypeDeviceInfoDescription.lower(deviceInfoDescription), $0
		)
	})
}

public func deviceInfoToJsonBytes(deviceInfo: DeviceInfo) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_device_info_to_json_bytes(
			FfiConverterTypeDeviceInfo.lower(deviceInfo), $0
		)
	})
}

public func displayNameToJsonString(displayName: DisplayName) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_display_name_to_json_string(
			FfiConverterTypeDisplayName.lower(displayName), $0
		)
	})
}

public func ed25519PublicKeyToBytes(publicKey: Ed25519PublicKey) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_ed25519_public_key_to_bytes(
			FfiConverterTypeEd25519PublicKey.lower(publicKey), $0
		)
	})
}

/**
 * Encodes the `Ed25519PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"b7a3c12dc0c8c748ab07525b701122b88bd78f600c76342d27f25e5f92444cde"`
 */
public func ed25519PublicKeyToHex(publicKey: Ed25519PublicKey) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_ed25519_public_key_to_hex(
			FfiConverterTypeEd25519PublicKey.lower(publicKey), $0
		)
	})
}

public func ed25519PublicKeyToJsonString(ed25519PublicKey: Ed25519PublicKey) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_ed25519_public_key_to_json_string(
			FfiConverterTypeEd25519PublicKey.lower(ed25519PublicKey), $0
		)
	})
}

public func ed25519SignatureToJsonString(ed25519Signature: Ed25519Signature) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_ed25519_signature_to_json_string(
			FfiConverterTypeEd25519Signature.lower(ed25519Signature), $0
		)
	})
}

public func ed25519SignatureToString(signature: Ed25519Signature) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_ed25519_signature_to_string(
			FfiConverterTypeEd25519Signature.lower(signature), $0
		)
	})
}

public func entropy16BytesToBytes(bytes: Entropy16Bytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_entropy16_bytes_to_bytes(
			FfiConverterTypeEntropy16Bytes.lower(bytes), $0
		)
	})
}

public func entropy20BytesToBytes(bytes: Entropy20Bytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_entropy20_bytes_to_bytes(
			FfiConverterTypeEntropy20Bytes.lower(bytes), $0
		)
	})
}

public func entropy24BytesToBytes(bytes: Entropy24Bytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_entropy24_bytes_to_bytes(
			FfiConverterTypeEntropy24Bytes.lower(bytes), $0
		)
	})
}

public func entropy28BytesToBytes(bytes: Entropy28Bytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_entropy28_bytes_to_bytes(
			FfiConverterTypeEntropy28Bytes.lower(bytes), $0
		)
	})
}

public func entropy32BytesToBytes(bytes: Entropy32Bytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_entropy32_bytes_to_bytes(
			FfiConverterTypeEntropy32Bytes.lower(bytes), $0
		)
	})
}

public func errorCodeFromError(error: CommonError) -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_error_code_from_error(
			FfiConverterTypeCommonError.lower(error), $0
		)
	})
}

public func errorMessageFromError(error: CommonError) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_error_message_from_error(
			FfiConverterTypeCommonError.lower(error), $0
		)
	})
}

public func eventKind(event: Event) -> EventKind {
	try! FfiConverterTypeEventKind.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_event_kind(
			FfiConverterTypeEvent.lower(event), $0
		)
	})
}

public func eventKindAffectsCurrentAccounts(eventKind: EventKind) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_event_kind_affects_current_accounts(
			FfiConverterTypeEventKind.lower(eventKind), $0
		)
	})
}

public func eventKindAffectsCurrentNetwork(eventKind: EventKind) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_event_kind_affects_current_network(
			FfiConverterTypeEventKind.lower(eventKind), $0
		)
	})
}

public func eventKindAffectsFactorSources(eventKind: EventKind) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_event_kind_affects_factor_sources(
			FfiConverterTypeEventKind.lower(eventKind), $0
		)
	})
}

public func eventKindAffectsSavedGateways(eventKind: EventKind) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_event_kind_affects_saved_gateways(
			FfiConverterTypeEventKind.lower(eventKind), $0
		)
	})
}

public func eventKindAffectsSecurityStructures(eventKind: EventKind) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_event_kind_affects_security_structures(
			FfiConverterTypeEventKind.lower(eventKind), $0
		)
	})
}

public func eventKindAll() -> [EventKind] {
	try! FfiConverterSequenceTypeEventKind.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_event_kind_all($0
		)
	})
}

public func exactly12BytesToJsonString(exactly12Bytes: Exactly12Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly12_bytes_to_json_string(
			FfiConverterTypeExactly12Bytes.lower(exactly12Bytes), $0
		)
	})
}

public func exactly29BytesToJsonString(exactly29Bytes: Exactly29Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly29_bytes_to_json_string(
			FfiConverterTypeExactly29Bytes.lower(exactly29Bytes), $0
		)
	})
}

public func exactly32BytesToJsonString(exactly32Bytes: Exactly32Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly32_bytes_to_json_string(
			FfiConverterTypeExactly32Bytes.lower(exactly32Bytes), $0
		)
	})
}

public func exactly33BytesToJsonString(exactly33Bytes: Exactly33Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly33_bytes_to_json_string(
			FfiConverterTypeExactly33Bytes.lower(exactly33Bytes), $0
		)
	})
}

public func exactly60BytesToJsonString(exactly60Bytes: Exactly60Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly60_bytes_to_json_string(
			FfiConverterTypeExactly60Bytes.lower(exactly60Bytes), $0
		)
	})
}

public func exactly64BytesToJsonString(exactly64Bytes: Exactly64Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly64_bytes_to_json_string(
			FfiConverterTypeExactly64Bytes.lower(exactly64Bytes), $0
		)
	})
}

public func exactly65BytesToJsonString(exactly65Bytes: Exactly65Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly65_bytes_to_json_string(
			FfiConverterTypeExactly65Bytes.lower(exactly65Bytes), $0
		)
	})
}

public func exactly12BytesToBytes(bytes: Exactly12Bytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_12_bytes_to_bytes(
			FfiConverterTypeExactly12Bytes.lower(bytes), $0
		)
	})
}

public func exactly12BytesToHex(bytes: Exactly12Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_12_bytes_to_hex(
			FfiConverterTypeExactly12Bytes.lower(bytes), $0
		)
	})
}

public func exactly29BytesToBytes(bytes: Exactly29Bytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_29_bytes_to_bytes(
			FfiConverterTypeExactly29Bytes.lower(bytes), $0
		)
	})
}

public func exactly29BytesToHex(bytes: Exactly29Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_29_bytes_to_hex(
			FfiConverterTypeExactly29Bytes.lower(bytes), $0
		)
	})
}

public func exactly32BytesToBytes(bytes: Exactly32Bytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_32_bytes_to_bytes(
			FfiConverterTypeExactly32Bytes.lower(bytes), $0
		)
	})
}

public func exactly32BytesToHex(bytes: Exactly32Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_32_bytes_to_hex(
			FfiConverterTypeExactly32Bytes.lower(bytes), $0
		)
	})
}

public func exactly33BytesToBytes(bytes: Exactly33Bytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_33_bytes_to_bytes(
			FfiConverterTypeExactly33Bytes.lower(bytes), $0
		)
	})
}

public func exactly33BytesToHex(bytes: Exactly33Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_33_bytes_to_hex(
			FfiConverterTypeExactly33Bytes.lower(bytes), $0
		)
	})
}

public func exactly60BytesToBytes(bytes: Exactly60Bytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_60_bytes_to_bytes(
			FfiConverterTypeExactly60Bytes.lower(bytes), $0
		)
	})
}

public func exactly60BytesToHex(bytes: Exactly60Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_60_bytes_to_hex(
			FfiConverterTypeExactly60Bytes.lower(bytes), $0
		)
	})
}

public func exactly64BytesToBytes(bytes: Exactly64Bytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_64_bytes_to_bytes(
			FfiConverterTypeExactly64Bytes.lower(bytes), $0
		)
	})
}

public func exactly64BytesToHex(bytes: Exactly64Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_64_bytes_to_hex(
			FfiConverterTypeExactly64Bytes.lower(bytes), $0
		)
	})
}

public func exactly65BytesToBytes(bytes: Exactly65Bytes) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_65_bytes_to_bytes(
			FfiConverterTypeExactly65Bytes.lower(bytes), $0
		)
	})
}

public func exactly65BytesToHex(bytes: Exactly65Bytes) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_exactly_65_bytes_to_hex(
			FfiConverterTypeExactly65Bytes.lower(bytes), $0
		)
	})
}

public func factorSourceCryptoParametersSupportsBabylon(parameters: FactorSourceCryptoParameters) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_factor_source_crypto_parameters_supports_babylon(
			FfiConverterTypeFactorSourceCryptoParameters.lower(parameters), $0
		)
	})
}

public func factorSourceCryptoParametersSupportsOlympia(parameters: FactorSourceCryptoParameters) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_factor_source_crypto_parameters_supports_olympia(
			FfiConverterTypeFactorSourceCryptoParameters.lower(parameters), $0
		)
	})
}

public func factorSourceIDFromAddressToJsonBytes(factorSourceIDFromAddress: FactorSourceIdFromAddress) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_factor_source_i_d_from_address_to_json_bytes(
			FfiConverterTypeFactorSourceIDFromAddress.lower(factorSourceIDFromAddress), $0
		)
	})
}

public func factorSourceIDFromHashToJsonBytes(factorSourceIDFromHash: FactorSourceIdFromHash) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_factor_source_i_d_from_hash_to_json_bytes(
			FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceIDFromHash), $0
		)
	})
}

public func factorSourceIdFromAddressToString(factorSourceId: FactorSourceIdFromAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_factor_source_id_from_address_to_string(
			FfiConverterTypeFactorSourceIDFromAddress.lower(factorSourceId), $0
		)
	})
}

public func factorSourceIdFromHashToString(factorSourceId: FactorSourceIdFromHash) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_factor_source_id_from_hash_to_string(
			FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceId), $0
		)
	})
}

public func factorSourceIdToString(factorSourceId: FactorSourceId) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_factor_source_id_to_string(
			FfiConverterTypeFactorSourceID.lower(factorSourceId), $0
		)
	})
}

public func factorSourceKindToString(kind: FactorSourceKind) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_factor_source_kind_to_string(
			FfiConverterTypeFactorSourceKind.lower(kind), $0
		)
	})
}

public func factorSourceSupportsBabylon(factorSource: FactorSource) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_factor_source_supports_babylon(
			FfiConverterTypeFactorSource.lower(factorSource), $0
		)
	})
}

public func factorSourceSupportsOlympia(factorSource: FactorSource) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_factor_source_supports_olympia(
			FfiConverterTypeFactorSource.lower(factorSource), $0
		)
	})
}

public func factorSourceToString(factorSource: FactorSource) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_factor_source_to_string(
			FfiConverterTypeFactorSource.lower(factorSource), $0
		)
	})
}

public func factorSourcesAllSampleValues() -> [FactorSource] {
	try! FfiConverterSequenceTypeFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_factor_sources_all_sample_values($0
		)
	})
}

public func ffiUrlGetUrl(ffiUrl: FfiUrl) -> Url {
	try! FfiConverterTypeUrl.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_ffi_url_get_url(
			FfiConverterTypeFfiUrl.lower(ffiUrl), $0
		)
	})
}

public func fiatCurrencyToJsonString(fiatCurrency: FiatCurrency) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_fiat_currency_to_json_string(
			FfiConverterTypeFiatCurrency.lower(fiatCurrency), $0
		)
	})
}

public func fungibleResourceIndicatorGetAmount(indicator: FungibleResourceIndicator) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_fungible_resource_indicator_get_amount(
			FfiConverterTypeFungibleResourceIndicator.lower(indicator), $0
		)
	})
}

public func gatewayId(gateway: Gateway) -> Url {
	try! FfiConverterTypeUrl.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_gateway_id(
			FfiConverterTypeGateway.lower(gateway), $0
		)
	})
}

public func gatewayIsWellknown(gateway: Gateway) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_gateway_is_wellknown(
			FfiConverterTypeGateway.lower(gateway), $0
		)
	})
}

public func gatewayMainnet() -> Gateway {
	try! FfiConverterTypeGateway.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_gateway_mainnet($0
		)
	})
}

public func gatewayStokenet() -> Gateway {
	try! FfiConverterTypeGateway.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_gateway_stokenet($0
		)
	})
}

public func gatewayToString(gateway: Gateway) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_gateway_to_string(
			FfiConverterTypeGateway.lower(gateway), $0
		)
	})
}

public func gatewayWellknownGateways() -> [Gateway] {
	try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_gateway_wellknown_gateways($0
		)
	})
}

public func getSubintentExpirationStatus(expiration: DappToWalletInteractionSubintentExpiration) -> DappToWalletInteractionSubintentExpirationStatus {
	try! FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_get_subintent_expiration_status(
			FfiConverterTypeDappToWalletInteractionSubintentExpiration.lower(expiration), $0
		)
	})
}

public func hash(data: BagOfBytes) -> Hash {
	try! FfiConverterTypeHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_hash(
			FfiConverterTypeBagOfBytes.lower(data), $0
		)
	})
}

public func hashGetBytes(hash: Hash) -> Exactly32Bytes {
	try! FfiConverterTypeExactly32Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_hash_get_bytes(
			FfiConverterTypeHash.lower(hash), $0
		)
	})
}

public func hdPathComponentGetKeySpace(component: HdPathComponent) -> KeySpace {
	try! FfiConverterTypeKeySpace.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_hd_path_component_get_key_space(
			FfiConverterTypeHDPathComponent.lower(component), $0
		)
	})
}

public func hdPathComponentIndexInGlobalKeySpace(component: HdPathComponent) -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_hd_path_component_index_in_global_key_space(
			FfiConverterTypeHDPathComponent.lower(component), $0
		)
	})
}

public func hdPathComponentIndexInLocalKeySpace(component: HdPathComponent) -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_hd_path_component_index_in_local_key_space(
			FfiConverterTypeHDPathComponent.lower(component), $0
		)
	})
}

public func hdPathComponentToBip32String(component: HdPathComponent) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_hd_path_component_to_bip32_string(
			FfiConverterTypeHDPathComponent.lower(component), $0
		)
	})
}

public func hdPathComponentToBip32StringDebug(component: HdPathComponent) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_hd_path_component_to_bip32_string_debug(
			FfiConverterTypeHDPathComponent.lower(component), $0
		)
	})
}

public func hdPathComponentToHardened(component: HdPathComponent) throws -> Hardened {
	try FfiConverterTypeHardened.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_hd_path_component_to_hardened(
			FfiConverterTypeHDPathComponent.lower(component), $0
		)
	})
}

public func headerToJsonBytes(header: Header) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_header_to_json_bytes(
			FfiConverterTypeHeader.lower(header), $0
		)
	})
}

public func hierarchicalDeterministicPublicKeyIsValidSignatureForHash(key: HierarchicalDeterministicPublicKey, signature: Signature, hash: Hash) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_hierarchical_deterministic_public_key_is_valid_signature_for_hash(
			FfiConverterTypeHierarchicalDeterministicPublicKey.lower(key),
			FfiConverterTypeSignature.lower(signature),
			FfiConverterTypeHash.lower(hash), $0
		)
	})
}

public func hostIdToJsonBytes(hostId: HostId) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_host_id_to_json_bytes(
			FfiConverterTypeHostId.lower(hostId), $0
		)
	})
}

public func hostOsGetName(hostOs: HostOs) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_host_os_get_name(
			FfiConverterTypeHostOS.lower(hostOs), $0
		)
	})
}

public func hostOsGetVendor(hostOs: HostOs) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_host_os_get_vendor(
			FfiConverterTypeHostOS.lower(hostOs), $0
		)
	})
}

public func hostOsGetVersion(hostOs: HostOs) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_host_os_get_version(
			FfiConverterTypeHostOS.lower(hostOs), $0
		)
	})
}

public func identityAddressBech32Address(address: IdentityAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_identity_address_bech32_address(
			FfiConverterTypeIdentityAddress.lower(address), $0
		)
	})
}

public func identityAddressFormatted(address: IdentityAddress, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_identity_address_formatted(
			FfiConverterTypeIdentityAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func identityAddressMapToNetwork(address: IdentityAddress, networkId: NetworkId) -> IdentityAddress {
	try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_identity_address_map_to_network(
			FfiConverterTypeIdentityAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func identityAddressNetworkId(address: IdentityAddress) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_identity_address_network_id(
			FfiConverterTypeIdentityAddress.lower(address), $0
		)
	})
}

public func imageUrlUtilsIsVectorImage(url: String, imageType: VectorImageType) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_image_url_utils_is_vector_image(
			FfiConverterString.lower(url),
			FfiConverterTypeVectorImageType.lower(imageType), $0
		)
	})
}

public func imageUrlUtilsMakeImageUrl(url: String, imageServiceUrl: String, width: UInt32, height: UInt32) throws -> Url {
	try FfiConverterTypeUrl.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_image_url_utils_make_image_url(
			FfiConverterString.lower(url),
			FfiConverterString.lower(imageServiceUrl),
			FfiConverterUInt32.lower(width),
			FfiConverterUInt32.lower(height), $0
		)
	})
}

public func intentDiscriminatorGetValue(intentDiscriminator: IntentDiscriminator) -> UInt64 {
	try! FfiConverterUInt64.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_intent_discriminator_get_value(
			FfiConverterTypeIntentDiscriminator.lower(intentDiscriminator), $0
		)
	})
}

public func intentSignatureGetSignatureWithPublicKey(intentSignature: IntentSignature) -> SignatureWithPublicKey {
	try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_intent_signature_get_signature_with_public_key(
			FfiConverterTypeIntentSignature.lower(intentSignature), $0
		)
	})
}

public func isSafeToShowErrorMessageFromError(error: CommonError) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_is_safe_to_show_error_message_from_error(
			FfiConverterTypeCommonError.lower(error), $0
		)
	})
}

/**
 * Returns the public key on **compressed** form (33 bytes)
 */
public func keyAgreementPublicKeyToBytes(publicKey: KeyAgreementPublicKey) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_key_agreement_public_key_to_bytes(
			FfiConverterTypeKeyAgreementPublicKey.lower(publicKey), $0
		)
	})
}

/**
 * Encodes the compressed form (33 bytes) of a `Secp256k1PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"033083620d1596d3f8988ff3270e42970dd2a031e2b9b6488052a4170ff999f3e8"`
 */
public func keyAgreementPublicKeyToHex(publicKey: KeyAgreementPublicKey) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_key_agreement_public_key_to_hex(
			FfiConverterTypeKeyAgreementPublicKey.lower(publicKey), $0
		)
	})
}

public func ledgerHwWalletModelToString(model: LedgerHardwareWalletModel) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_ledger_hw_wallet_model_to_string(
			FfiConverterTypeLedgerHardwareWalletModel.lower(model), $0
		)
	})
}

public func legacyOlympiaAccountAddressFormatted(address: LegacyOlympiaAccountAddress, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_legacy_olympia_account_address_formatted(
			FfiConverterTypeLegacyOlympiaAccountAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

public func legacyOlympiaAccountAddressIsLegacyOfBabylon(legacyOlympiaAddress: LegacyOlympiaAccountAddress, babylonAccountAddress: AccountAddress) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_legacy_olympia_account_address_is_legacy_of_babylon(
			FfiConverterTypeLegacyOlympiaAccountAddress.lower(legacyOlympiaAddress),
			FfiConverterTypeAccountAddress.lower(babylonAccountAddress), $0
		)
	})
}

public func legacyOlympiaAccountAddressToBabylonAccountAddress(address: LegacyOlympiaAccountAddress) -> AccountAddress {
	try! FfiConverterTypeAccountAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_legacy_olympia_account_address_to_babylon_account_address(
			FfiConverterTypeLegacyOlympiaAccountAddress.lower(address), $0
		)
	})
}

public func legacyOlympiaAccountAddressToString(address: LegacyOlympiaAccountAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_legacy_olympia_account_address_to_string(
			FfiConverterTypeLegacyOlympiaAccountAddress.lower(address), $0
		)
	})
}

public func linkConnectionQRDataToJsonBytes(linkConnectionQRData: LinkConnectionQrData) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_link_connection_q_r_data_to_json_bytes(
			FfiConverterTypeLinkConnectionQRData.lower(linkConnectionQRData), $0
		)
	})
}

public func lockerAddressBech32Address(address: LockerAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_locker_address_bech32_address(
			FfiConverterTypeLockerAddress.lower(address), $0
		)
	})
}

public func lockerAddressFormatted(address: LockerAddress, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_locker_address_formatted(
			FfiConverterTypeLockerAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func lockerAddressMapToNetwork(address: LockerAddress, networkId: NetworkId) -> LockerAddress {
	try! FfiConverterTypeLockerAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_locker_address_map_to_network(
			FfiConverterTypeLockerAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func lockerAddressNetworkId(address: LockerAddress) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_locker_address_network_id(
			FfiConverterTypeLockerAddress.lower(address), $0
		)
	})
}

public func manifestAccountLockerClaim(lockerAddress: LockerAddress, claimant: AccountAddress, claimableResources: [AccountLockerClaimableResource]) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_account_locker_claim(
			FfiConverterTypeLockerAddress.lower(lockerAddress),
			FfiConverterTypeAccountAddress.lower(claimant),
			FfiConverterSequenceTypeAccountLockerClaimableResource.lower(claimableResources), $0
		)
	})
}

public func manifestCreateFungibleToken(addressOfOwner: AccountAddress) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_create_fungible_token(
			FfiConverterTypeAccountAddress.lower(addressOfOwner), $0
		)
	})
}

public func manifestCreateFungibleTokenWithMetadata(addressOfOwner: AccountAddress, initialSupply: Decimal192, metadata: TokenDefinitionMetadata) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_create_fungible_token_with_metadata(
			FfiConverterTypeAccountAddress.lower(addressOfOwner),
			FfiConverterTypeDecimal192.lower(initialSupply),
			FfiConverterTypeTokenDefinitionMetadata.lower(metadata), $0
		)
	})
}

/**
 * Creates many fungible tokens, with initial supply, to be owned by `address_of_owner`.
 *
 * # Panics
 * Panics if `address_of_owner` is on `Mainnet`, use a testnet instead.
 * Panics if `count` is zero or is greater than the number of token metadata defined in `sample_resource_definition_metadata` (25)
 */
public func manifestCreateMultipleFungibleTokens(addressOfOwner: AccountAddress, count: UInt8?) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_create_multiple_fungible_tokens(
			FfiConverterTypeAccountAddress.lower(addressOfOwner),
			FfiConverterOptionUInt8.lower(count), $0
		)
	})
}

public func manifestCreateMultipleNonFungibleTokens(addressOfOwner: AccountAddress, collectionCount: UInt8?, nftsPerCollection: UInt8?) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_create_multiple_non_fungible_tokens(
			FfiConverterTypeAccountAddress.lower(addressOfOwner),
			FfiConverterOptionUInt8.lower(collectionCount),
			FfiConverterOptionUInt8.lower(nftsPerCollection), $0
		)
	})
}

public func manifestCreateNonFungibleToken(addressOfOwner: AccountAddress, nftsPerCollection: UInt8?) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_create_non_fungible_token(
			FfiConverterTypeAccountAddress.lower(addressOfOwner),
			FfiConverterOptionUInt8.lower(nftsPerCollection), $0
		)
	})
}

public func manifestEncounteredComponentAddressFormatted(address: ManifestEncounteredComponentAddress, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_formatted(
			FfiConverterTypeManifestEncounteredComponentAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

public func manifestEncounteredComponentAddressMapToNetwork(address: ManifestEncounteredComponentAddress, networkId: NetworkId) -> ManifestEncounteredComponentAddress {
	try! FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_map_to_network(
			FfiConverterTypeManifestEncounteredComponentAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func manifestEncounteredComponentAddressNetworkId(address: ManifestEncounteredComponentAddress) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_network_id(
			FfiConverterTypeManifestEncounteredComponentAddress.lower(address), $0
		)
	})
}

public func manifestEncounteredComponentAddressSampleValuesAll() -> [ManifestEncounteredComponentAddress] {
	try! FfiConverterSequenceTypeManifestEncounteredComponentAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_sample_values_all($0
		)
	})
}

public func manifestEncounteredComponentAddressToString(address: ManifestEncounteredComponentAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_to_string(
			FfiConverterTypeManifestEncounteredComponentAddress.lower(address), $0
		)
	})
}

public func manifestForFaucet(includeLockFeeInstruction: Bool, addressOfReceivingAccount: AccountAddress) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_for_faucet(
			FfiConverterBool.lower(includeLockFeeInstruction),
			FfiConverterTypeAccountAddress.lower(addressOfReceivingAccount), $0
		)
	})
}

public func manifestMarkingAccountAsDappDefinitionType(accountAddress: AccountAddress) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_marking_account_as_dapp_definition_type(
			FfiConverterTypeAccountAddress.lower(accountAddress), $0
		)
	})
}

public func manifestPerAssetTransfers(transfers: PerAssetTransfers) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_per_asset_transfers(
			FfiConverterTypePerAssetTransfers.lower(transfers), $0
		)
	})
}

/**
 * Uses `per_asset_transfers` after having transposed the `PerRecipientAssetTransfers`
 * into `PerAssetTransfers`. We always use `PerAssetTransfers` when building the manifest
 * since it is more efficient (allows a single withdraw per resource) => fewer instruction =>
 * cheaper TX fee for user.
 */
public func manifestPerRecipientTransfers(transfers: PerRecipientAssetTransfers) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_per_recipient_transfers(
			FfiConverterTypePerRecipientAssetTransfers.lower(transfers), $0
		)
	})
}

public func manifestSetOwnerKeysHashes(addressOfAccountOrPersona: AddressOfAccountOrPersona, ownerKeyHashes: [PublicKeyHash]) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_set_owner_keys_hashes(
			FfiConverterTypeAddressOfAccountOrPersona.lower(addressOfAccountOrPersona),
			FfiConverterSequenceTypePublicKeyHash.lower(ownerKeyHashes), $0
		)
	})
}

public func manifestStakesClaim(accountAddress: AccountAddress, stakeClaims: [StakeClaim]) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_stakes_claim(
			FfiConverterTypeAccountAddress.lower(accountAddress),
			FfiConverterSequenceTypeStakeClaim.lower(stakeClaims), $0
		)
	})
}

public func manifestThirdPartyDepositUpdate(accountAddress: AccountAddress, from: ThirdPartyDeposits, to: ThirdPartyDeposits) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_manifest_third_party_deposit_update(
			FfiConverterTypeAccountAddress.lower(accountAddress),
			FfiConverterTypeThirdPartyDeposits.lower(from),
			FfiConverterTypeThirdPartyDeposits.lower(to), $0
		)
	})
}

public func messageAsPlaintext(message: Message) -> String? {
	try! FfiConverterOptionString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_message_as_plaintext(
			FfiConverterTypeMessage.lower(message), $0
		)
	})
}

public func messageV2AsPlaintext(message: MessageV2) -> String? {
	try! FfiConverterOptionString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_message_v2_as_plaintext(
			FfiConverterTypeMessageV2.lower(message), $0
		)
	})
}

/**
 * Returns the words of a mnemonic as a String joined by spaces, e.g. "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong"
 */
public func mnemonicPhrase(from: Mnemonic) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_mnemonic_phrase(
			FfiConverterTypeMnemonic.lower(from), $0
		)
	})
}

public func mnemonicWithPassphraseDerivePublicKeys(mnemonicWithPassphrase: MnemonicWithPassphrase, derivationPaths: [DerivationPath]) -> [HierarchicalDeterministicPublicKey] {
	try! FfiConverterSequenceTypeHierarchicalDeterministicPublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_mnemonic_with_passphrase_derive_public_keys(
			FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
			FfiConverterSequenceTypeDerivationPath.lower(derivationPaths), $0
		)
	})
}

public func mnemonicWithPassphraseSign(mnemonicWithPassphrase: MnemonicWithPassphrase, derivationPath: DerivationPath, hashToSign: Hash) -> SignatureWithPublicKey {
	try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_mnemonic_with_passphrase_sign(
			FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
			FfiConverterTypeDerivationPath.lower(derivationPath),
			FfiConverterTypeHash.lower(hashToSign), $0
		)
	})
}

public func mnemonicWithPassphraseToJsonBytes(mnemonicWithPassphrase: MnemonicWithPassphrase) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_mnemonic_with_passphrase_to_json_bytes(
			FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase), $0
		)
	})
}

/**
 * Returns `true` if this MnemonicWithPassphrase successfully validates all `hd_keys`, that is to say,
 * that all the HierarchicalDeterministicPublicKey were indeed crated by this MnemonicWithPassphrase.
 */
public func mnemonicWithPassphraseValidatePublicKeys(mnemonicWithPassphrase: MnemonicWithPassphrase, hdKeys: [HierarchicalDeterministicPublicKey]) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_mnemonic_with_passphrase_validate_public_keys(
			FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
			FfiConverterSequenceTypeHierarchicalDeterministicPublicKey.lower(hdKeys), $0
		)
	})
}

/**
 * Modifies `manifest` by inserting transaction "guarantees", which is the wallet
 * term for `assert_worktop_contains`.
 */
public func modifyManifestAddGuarantees(manifest: TransactionManifest, guarantees: [TransactionGuarantee]) throws -> TransactionManifest {
	try FfiConverterTypeTransactionManifest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_modify_manifest_add_guarantees(
			FfiConverterTypeTransactionManifest.lower(manifest),
			FfiConverterSequenceTypeTransactionGuarantee.lower(guarantees), $0
		)
	})
}

public func modifyManifestLockFee(manifest: TransactionManifest, addressOfFeePayer: AccountAddress, fee: Decimal192?) -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_modify_manifest_lock_fee(
			FfiConverterTypeTransactionManifest.lower(manifest),
			FfiConverterTypeAccountAddress.lower(addressOfFeePayer),
			FfiConverterOptionTypeDecimal192.lower(fee), $0
		)
	})
}

public func networkIdDiscriminant(id: NetworkId) -> UInt8 {
	try! FfiConverterUInt8.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_network_id_discriminant(
			FfiConverterTypeNetworkID.lower(id), $0
		)
	})
}

public func networkIdToString(id: NetworkId) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_network_id_to_string(
			FfiConverterTypeNetworkID.lower(id), $0
		)
	})
}

public func networkIdsAll() -> [NetworkId] {
	try! FfiConverterSequenceTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_network_ids_all($0
		)
	})
}

public func networkMethodToString(method: NetworkMethod) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_network_method_to_string(
			FfiConverterTypeNetworkMethod.lower(method), $0
		)
	})
}

public func newAccessControllerAddress(bech32: String) throws -> AccessControllerAddress {
	try FfiConverterTypeAccessControllerAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_access_controller_address(
			FfiConverterString.lower(bech32), $0
		)
	})
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newAccessControllerAddressRandom(networkId: NetworkId) -> AccessControllerAddress {
	try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_access_controller_address_random(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func newAccessControllerAddressSampleMainnet() -> AccessControllerAddress {
	try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_access_controller_address_sample_mainnet($0
		)
	})
}

public func newAccessControllerAddressSampleMainnetOther() -> AccessControllerAddress {
	try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_access_controller_address_sample_mainnet_other($0
		)
	})
}

public func newAccessControllerAddressSampleStokenet() -> AccessControllerAddress {
	try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_access_controller_address_sample_stokenet($0
		)
	})
}

public func newAccessControllerAddressSampleStokenetOther() -> AccessControllerAddress {
	try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_access_controller_address_sample_stokenet_other($0
		)
	})
}

public func newAccountAddress(bech32: String) throws -> AccountAddress {
	try FfiConverterTypeAccountAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_account_address(
			FfiConverterString.lower(bech32), $0
		)
	})
}

public func newAccountAddressFrom(publicKey: PublicKey, networkId: NetworkId) -> AccountAddress {
	try! FfiConverterTypeAccountAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_address_from(
			FfiConverterTypePublicKey.lower(publicKey),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newAccountAddressRandom(networkId: NetworkId) -> AccountAddress {
	try! FfiConverterTypeAccountAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_address_random(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func newAccountAddressSampleMainnet() -> AccountAddress {
	try! FfiConverterTypeAccountAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_address_sample_mainnet($0
		)
	})
}

public func newAccountAddressSampleMainnetOther() -> AccountAddress {
	try! FfiConverterTypeAccountAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_address_sample_mainnet_other($0
		)
	})
}

public func newAccountAddressSampleStokenet() -> AccountAddress {
	try! FfiConverterTypeAccountAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_address_sample_stokenet($0
		)
	})
}

public func newAccountAddressSampleStokenetOther() -> AccountAddress {
	try! FfiConverterTypeAccountAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_address_sample_stokenet_other($0
		)
	})
}

public func newAccountForDisplayFromAccount(account: Account) -> AccountForDisplay {
	try! FfiConverterTypeAccountForDisplay.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_for_display_from_account(
			FfiConverterTypeAccount.lower(account), $0
		)
	})
}

public func newAccountForDisplaySample() -> AccountForDisplay {
	try! FfiConverterTypeAccountForDisplay.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_for_display_sample($0
		)
	})
}

public func newAccountForDisplaySampleOther() -> AccountForDisplay {
	try! FfiConverterTypeAccountForDisplay.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_for_display_sample_other($0
		)
	})
}

public func newAccountLockerClaimableResourceSample() -> AccountLockerClaimableResource {
	try! FfiConverterTypeAccountLockerClaimableResource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_locker_claimable_resource_sample($0
		)
	})
}

public func newAccountLockerClaimableResourceSampleOther() -> AccountLockerClaimableResource {
	try! FfiConverterTypeAccountLockerClaimableResource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_locker_claimable_resource_sample_other($0
		)
	})
}

public func newAccountOrAddressOfSample() -> AccountOrAddressOf {
	try! FfiConverterTypeAccountOrAddressOf.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_or_address_of_sample($0
		)
	})
}

public func newAccountOrAddressOfSampleOther() -> AccountOrAddressOf {
	try! FfiConverterTypeAccountOrAddressOf.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_or_address_of_sample_other($0
		)
	})
}

public func newAccountOrPersonaSampleMainnet() -> AccountOrPersona {
	try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_mainnet($0
		)
	})
}

public func newAccountOrPersonaSampleMainnetOther() -> AccountOrPersona {
	try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_mainnet_other($0
		)
	})
}

public func newAccountOrPersonaSampleMainnetThird() -> AccountOrPersona {
	try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_mainnet_third($0
		)
	})
}

public func newAccountOrPersonaSampleStokenet() -> AccountOrPersona {
	try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_stokenet($0
		)
	})
}

public func newAccountOrPersonaSampleStokenetOther() -> AccountOrPersona {
	try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_stokenet_other($0
		)
	})
}

public func newAccountOrPersonaSampleStokenetThird() -> AccountOrPersona {
	try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_stokenet_third($0
		)
	})
}

public func newAccountPath(networkId: NetworkId, keyKind: Cap26KeyKind, index: Hardened) -> AccountPath {
	try! FfiConverterTypeAccountPath.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_path(
			FfiConverterTypeNetworkID.lower(networkId),
			FfiConverterTypeCAP26KeyKind.lower(keyKind),
			FfiConverterTypeHardened.lower(index), $0
		)
	})
}

public func newAccountPathSample() -> AccountPath {
	try! FfiConverterTypeAccountPath.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_path_sample($0
		)
	})
}

public func newAccountPathSampleOther() -> AccountPath {
	try! FfiConverterTypeAccountPath.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_path_sample_other($0
		)
	})
}

public func newAccountSampleMainnetAlice() -> Account {
	try! FfiConverterTypeAccount.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_sample_mainnet_alice($0
		)
	})
}

public func newAccountSampleMainnetBob() -> Account {
	try! FfiConverterTypeAccount.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_sample_mainnet_bob($0
		)
	})
}

public func newAccountSampleMainnetCarol() -> Account {
	try! FfiConverterTypeAccount.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_sample_mainnet_carol($0
		)
	})
}

public func newAccountSampleMainnetDiana() -> Account {
	try! FfiConverterTypeAccount.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_sample_mainnet_diana($0
		)
	})
}

public func newAccountSampleStokenetNadia() -> Account {
	try! FfiConverterTypeAccount.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_sample_stokenet_nadia($0
		)
	})
}

public func newAccountSampleStokenetOlivia() -> Account {
	try! FfiConverterTypeAccount.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_sample_stokenet_olivia($0
		)
	})
}

public func newAccountSampleStokenetPaige() -> Account {
	try! FfiConverterTypeAccount.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_account_sample_stokenet_paige($0
		)
	})
}

public func newAccountsForDisplaySample() -> [AccountForDisplay] {
	try! FfiConverterSequenceTypeAccountForDisplay.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_accounts_for_display_sample($0
		)
	})
}

public func newAccountsForDisplaySampleOther() -> [AccountForDisplay] {
	try! FfiConverterSequenceTypeAccountForDisplay.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_accounts_for_display_sample_other($0
		)
	})
}

public func newAccountsOrPersonasSample() -> [AccountOrPersona] {
	try! FfiConverterSequenceTypeAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_accounts_or_personas_sample($0
		)
	})
}

public func newAccountsOrPersonasSampleOther() -> [AccountOrPersona] {
	try! FfiConverterSequenceTypeAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_accounts_or_personas_sample_other($0
		)
	})
}

public func newAccountsSample() -> [Account] {
	try! FfiConverterSequenceTypeAccount.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_accounts_sample($0
		)
	})
}

public func newAccountsSampleOther() -> [Account] {
	try! FfiConverterSequenceTypeAccount.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_accounts_sample_other($0
		)
	})
}

public func newAddressFromBech32(string: String) throws -> Address {
	try FfiConverterTypeAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_address_from_bech32(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newAddressOfAccountOrPersonaFromBech32(string: String) throws -> AddressOfAccountOrPersona {
	try FfiConverterTypeAddressOfAccountOrPersona.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_from_bech32(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newAddressOfAccountOrPersonaSampleMainnet() -> AddressOfAccountOrPersona {
	try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_sample_mainnet($0
		)
	})
}

public func newAddressOfAccountOrPersonaSampleMainnetOther() -> AddressOfAccountOrPersona {
	try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_sample_mainnet_other($0
		)
	})
}

public func newAddressOfAccountOrPersonaSampleStokenet() -> AddressOfAccountOrPersona {
	try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_sample_stokenet($0
		)
	})
}

public func newAddressOfAccountOrPersonaSampleStokenetOther() -> AddressOfAccountOrPersona {
	try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_sample_stokenet_other($0
		)
	})
}

public func newAddressSampleMainnet() -> Address {
	try! FfiConverterTypeAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_address_sample_mainnet($0
		)
	})
}

public func newAddressSampleMainnetOther() -> Address {
	try! FfiConverterTypeAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_address_sample_mainnet_other($0
		)
	})
}

public func newAddressSampleStokenet() -> Address {
	try! FfiConverterTypeAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_address_sample_stokenet($0
		)
	})
}

public func newAddressSampleStokenetOther() -> Address {
	try! FfiConverterTypeAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_address_sample_stokenet_other($0
		)
	})
}

public func newAppPreferencesDefault() -> AppPreferences {
	try! FfiConverterTypeAppPreferences.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_app_preferences_default($0
		)
	})
}

public func newAppPreferencesSample() -> AppPreferences {
	try! FfiConverterTypeAppPreferences.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_app_preferences_sample($0
		)
	})
}

public func newAppPreferencesSampleOther() -> AppPreferences {
	try! FfiConverterTypeAppPreferences.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_app_preferences_sample_other($0
		)
	})
}

public func newAppearanceId(validating: UInt8) throws -> AppearanceId {
	try FfiConverterTypeAppearanceID.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_appearance_id(
			FfiConverterUInt8.lower(validating), $0
		)
	})
}

public func newAppearanceIdFromNumberOfAccountsOnNetwork(count: UInt64) -> AppearanceId {
	try! FfiConverterTypeAppearanceID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_appearance_id_from_number_of_accounts_on_network(
			FfiConverterUInt64.lower(count), $0
		)
	})
}

public func newAppearanceIdSample() -> AppearanceId {
	try! FfiConverterTypeAppearanceID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_appearance_id_sample($0
		)
	})
}

public func newAppearanceIdSampleOther() -> AppearanceId {
	try! FfiConverterTypeAppearanceID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_appearance_id_sample_other($0
		)
	})
}

public func newArculusCardFactorSourceFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: ArculusCardHint) -> ArculusCardFactorSource {
	try! FfiConverterTypeArculusCardFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_arculus_card_factor_source_from_mnemonic_with_passphrase(
			FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
			FfiConverterTypeArculusCardHint.lower(hint), $0
		)
	})
}

public func newArculusCardFactorSourceSample() -> ArculusCardFactorSource {
	try! FfiConverterTypeArculusCardFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_arculus_card_factor_source_sample($0
		)
	})
}

public func newArculusCardFactorSourceSampleOther() -> ArculusCardFactorSource {
	try! FfiConverterTypeArculusCardFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_arculus_card_factor_source_sample_other($0
		)
	})
}

public func newAssetExceptionSample() -> AssetException {
	try! FfiConverterTypeAssetException.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_asset_exception_sample($0
		)
	})
}

public func newAssetExceptionSampleOther() -> AssetException {
	try! FfiConverterTypeAssetException.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_asset_exception_sample_other($0
		)
	})
}

public func newAssetsExceptionListSample() -> [AssetException] {
	try! FfiConverterSequenceTypeAssetException.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_assets_exception_list_sample($0
		)
	})
}

public func newAssetsExceptionListSampleOther() -> [AssetException] {
	try! FfiConverterSequenceTypeAssetException.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_assets_exception_list_sample_other($0
		)
	})
}

public func newAuthorizedDappDetailedSample() -> AuthorizedDappDetailed {
	try! FfiConverterTypeAuthorizedDappDetailed.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_dapp_detailed_sample($0
		)
	})
}

public func newAuthorizedDappDetailedSampleOther() -> AuthorizedDappDetailed {
	try! FfiConverterTypeAuthorizedDappDetailed.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_dapp_detailed_sample_other($0
		)
	})
}

public func newAuthorizedDappFromJsonBytes(jsonBytes: BagOfBytes) throws -> AuthorizedDapp {
	try FfiConverterTypeAuthorizedDapp.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_authorized_dapp_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newAuthorizedDappSampleMainnetDashboard() -> AuthorizedDapp {
	try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_dapp_sample_mainnet_dashboard($0
		)
	})
}

public func newAuthorizedDappSampleMainnetGumballclub() -> AuthorizedDapp {
	try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_dapp_sample_mainnet_gumballclub($0
		)
	})
}

public func newAuthorizedDappSampleStokenetDevconsole() -> AuthorizedDapp {
	try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_dapp_sample_stokenet_devconsole($0
		)
	})
}

public func newAuthorizedDappSampleStokenetSandbox() -> AuthorizedDapp {
	try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_dapp_sample_stokenet_sandbox($0
		)
	})
}

public func newAuthorizedDappsSample() -> [AuthorizedDapp] {
	try! FfiConverterSequenceTypeAuthorizedDapp.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_dapps_sample($0
		)
	})
}

public func newAuthorizedDappsSampleOther() -> [AuthorizedDapp] {
	try! FfiConverterSequenceTypeAuthorizedDapp.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_dapps_sample_other($0
		)
	})
}

public func newAuthorizedPersonaDetailedSample() -> AuthorizedPersonaDetailed {
	try! FfiConverterTypeAuthorizedPersonaDetailed.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_persona_detailed_sample($0
		)
	})
}

public func newAuthorizedPersonaDetailedSampleOther() -> AuthorizedPersonaDetailed {
	try! FfiConverterTypeAuthorizedPersonaDetailed.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_persona_detailed_sample_other($0
		)
	})
}

public func newAuthorizedPersonaSimpleSampleMainnet() -> AuthorizedPersonaSimple {
	try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_persona_simple_sample_mainnet($0
		)
	})
}

public func newAuthorizedPersonaSimpleSampleMainnetOther() -> AuthorizedPersonaSimple {
	try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_persona_simple_sample_mainnet_other($0
		)
	})
}

public func newAuthorizedPersonaSimpleSampleStokenet() -> AuthorizedPersonaSimple {
	try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_persona_simple_sample_stokenet($0
		)
	})
}

public func newAuthorizedPersonaSimpleSampleStokenetOther() -> AuthorizedPersonaSimple {
	try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_authorized_persona_simple_sample_stokenet_other($0
		)
	})
}

public func newBIP39SeedFromBytes(bytes: BagOfBytes) throws -> Bip39Seed {
	try FfiConverterTypeBIP39Seed.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_b_i_p39_seed_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newBIP39SeedSample() -> Bip39Seed {
	try! FfiConverterTypeBIP39Seed.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_b_i_p39_seed_sample($0
		)
	})
}

public func newBIP39SeedSampleOther() -> Bip39Seed {
	try! FfiConverterTypeBIP39Seed.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_b_i_p39_seed_sample_other($0
		)
	})
}

public func newBagOfBytesFrom(bytes: Data) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_from(
			FfiConverterData.lower(bytes), $0
		)
	})
}

public func newBagOfBytesSampleAced() -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_aced($0
		)
	})
}

public func newBagOfBytesSampleBabe() -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_babe($0
		)
	})
}

public func newBagOfBytesSampleCafe() -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_cafe($0
		)
	})
}

public func newBagOfBytesSampleDead() -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_dead($0
		)
	})
}

public func newBagOfBytesSampleEcad() -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_ecad($0
		)
	})
}

public func newBagOfBytesSampleFade() -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_fade($0
		)
	})
}

public func newBip39LanguageSample() -> Bip39Language {
	try! FfiConverterTypeBIP39Language.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bip39_language_sample($0
		)
	})
}

public func newBip39LanguageSampleOther() -> Bip39Language {
	try! FfiConverterTypeBIP39Language.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bip39_language_sample_other($0
		)
	})
}

public func newBip39WordSample() -> Bip39Word {
	try! FfiConverterTypeBIP39Word.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bip39_word_sample($0
		)
	})
}

public func newBip39WordSampleOther() -> Bip39Word {
	try! FfiConverterTypeBIP39Word.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bip39_word_sample_other($0
		)
	})
}

public func newBip44LikePathFromIndex(index: HdPathComponent) -> Bip44LikePath {
	try! FfiConverterTypeBIP44LikePath.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bip44_like_path_from_index(
			FfiConverterTypeHDPathComponent.lower(index), $0
		)
	})
}

public func newBip44LikePathFromString(string: String) throws -> Bip44LikePath {
	try FfiConverterTypeBIP44LikePath.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_bip44_like_path_from_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newBip44LikePathSample() -> Bip44LikePath {
	try! FfiConverterTypeBIP44LikePath.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bip44_like_path_sample($0
		)
	})
}

public func newBip44LikePathSampleOther() -> Bip44LikePath {
	try! FfiConverterTypeBIP44LikePath.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_bip44_like_path_sample_other($0
		)
	})
}

public func newBlobFromBytes(bytes: BagOfBytes) -> Blob {
	try! FfiConverterTypeBlob.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_blob_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newBlobsFromBlobList(blobs: [Blob]) -> Blobs {
	try! FfiConverterTypeBlobs.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_blobs_from_blob_list(
			FfiConverterSequenceTypeBlob.lower(blobs), $0
		)
	})
}

public func newBlobsSample() -> Blobs {
	try! FfiConverterTypeBlobs.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_blobs_sample($0
		)
	})
}

public func newBlobsSampleOther() -> Blobs {
	try! FfiConverterTypeBlobs.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_blobs_sample_other($0
		)
	})
}

public func newCompiledNotarizedIntentSample() -> CompiledNotarizedIntent {
	try! FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_compiled_notarized_intent_sample($0
		)
	})
}

public func newCompiledNotarizedIntentSampleOther() -> CompiledNotarizedIntent {
	try! FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_compiled_notarized_intent_sample_other($0
		)
	})
}

public func newCompiledSubintentSample() -> CompiledSubintent {
	try! FfiConverterTypeCompiledSubintent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_compiled_subintent_sample($0
		)
	})
}

public func newCompiledSubintentSampleOther() -> CompiledSubintent {
	try! FfiConverterTypeCompiledSubintent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_compiled_subintent_sample_other($0
		)
	})
}

public func newCompiledTransactionIntentSample() -> CompiledTransactionIntent {
	try! FfiConverterTypeCompiledTransactionIntent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_compiled_transaction_intent_sample($0
		)
	})
}

public func newCompiledTransactionIntentSampleOther() -> CompiledTransactionIntent {
	try! FfiConverterTypeCompiledTransactionIntent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_compiled_transaction_intent_sample_other($0
		)
	})
}

public func newComponentAddress(bech32: String) throws -> ComponentAddress {
	try FfiConverterTypeComponentAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_component_address(
			FfiConverterString.lower(bech32), $0
		)
	})
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newComponentAddressRandom(networkId: NetworkId) -> ComponentAddress {
	try! FfiConverterTypeComponentAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_component_address_random(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

/**
 * Sample to a mainnet ComponentAddress (global)
 */
public func newComponentAddressSampleMainnetGlobal() -> ComponentAddress {
	try! FfiConverterTypeComponentAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_component_address_sample_mainnet_global($0
		)
	})
}

/**
 * Sample to a mainnet ComponentAddress (internal)
 */
public func newComponentAddressSampleMainnetInternal() -> ComponentAddress {
	try! FfiConverterTypeComponentAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_component_address_sample_mainnet_internal($0
		)
	})
}

/**
 * Sample to a stokenet ComponentAddress (global)
 */
public func newComponentAddressSampleStokenetGlobal() -> ComponentAddress {
	try! FfiConverterTypeComponentAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_component_address_sample_stokenet_global($0
		)
	})
}

/**
 * Sample to a stokenet ComponentAddress (internal)
 */
public func newComponentAddressSampleStokenetInternal() -> ComponentAddress {
	try! FfiConverterTypeComponentAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_component_address_sample_stokenet_internal($0
		)
	})
}

public func newDappToWalletInteractionUnvalidatedFromJsonBytes(jsonBytes: BagOfBytes) throws -> DappToWalletInteractionUnvalidated {
	try FfiConverterTypeDappToWalletInteractionUnvalidated.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_unvalidated_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newDappToWalletInteractionUnvalidatedFromJsonString(jsonStr: String) throws -> DappToWalletInteractionUnvalidated {
	try FfiConverterTypeDappToWalletInteractionUnvalidated.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_unvalidated_from_json_string(
			FfiConverterString.lower(jsonStr), $0
		)
	})
}

public func newDappToWalletInteractionUnvalidatedSample() -> DappToWalletInteractionUnvalidated {
	try! FfiConverterTypeDappToWalletInteractionUnvalidated.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_unvalidated_sample($0
		)
	})
}

public func newDappToWalletInteractionUnvalidatedSampleOther() -> DappToWalletInteractionUnvalidated {
	try! FfiConverterTypeDappToWalletInteractionUnvalidated.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_unvalidated_sample_other($0
		)
	})
}

/**
 * Creates the Decimal192 `10^exponent`
 */
public func newDecimalExponent(exponent: UInt8) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_decimal_exponent(
			FfiConverterUInt8.lower(exponent), $0
		)
	})
}

/**
 * Creates a new `Decimal192` from a f32 float. Will
 * fail if the f32 cannot be losslessly represented
 * by the underlying Decimal from Scrypto.
 *
 * ```
 * extern crate sargon_uniffi;
 * use sargon_uniffi::prelude::*;
 *
 * assert!(new_decimal_from_f32(208050.17).to_string() == "208050.17");
 *
 * assert!(new_decimal_from_f32(f32::MIN_POSITIVE).to_string() == "0");
 * ```
 */
public func newDecimalFromF32(value: Float) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_decimal_from_f32(
			FfiConverterFloat.lower(value), $0
		)
	})
}

/**
 * Creates a new `Decimal192` from a f64 float. Will
 * fail if the f64 cannot be losslessly represented
 * by the underlying Decimal from Scrypto.
 *
 * ```
 * extern crate sargon_uniffi;
 * use sargon_uniffi::prelude::*;
 *
 * assert!(new_decimal_from_f64(208050.17).is_ok());
 *
 * assert!(new_decimal_from_f64(f64::MIN_POSITIVE).is_ok());
 * ```
 */
public func newDecimalFromF64(value: Double) throws -> Decimal192 {
	try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_decimal_from_f64(
			FfiConverterDouble.lower(value), $0
		)
	})
}

/**
 * Tries to creates a new `Decimal192` from a formatted String for
 * a specific locale.
 */
public func newDecimalFromFormattedString(formattedString: String, locale: LocaleConfig) throws -> Decimal192 {
	try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_decimal_from_formatted_string(
			FfiConverterString.lower(formattedString),
			FfiConverterTypeLocaleConfig.lower(locale), $0
		)
	})
}

/**
 * Creates a new `Decimal192` from a i32 integer.
 */
public func newDecimalFromI32(value: Int32) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_decimal_from_i32(
			FfiConverterInt32.lower(value), $0
		)
	})
}

/**
 * Creates a new `Decimal192` from a i64 integer.
 */
public func newDecimalFromI64(value: Int64) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_decimal_from_i64(
			FfiConverterInt64.lower(value), $0
		)
	})
}

/**
 * Tries to creates a new `Decimal192` from a String, throws a `CommonError`
 * if the `string` was not a valid Decimal192.
 */
public func newDecimalFromString(string: String) throws -> Decimal192 {
	try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_decimal_from_string(
			FfiConverterString.lower(string), $0
		)
	})
}

/**
 * Creates a new `Decimal192` from a u32 integer.
 */
public func newDecimalFromU32(value: UInt32) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_decimal_from_u32(
			FfiConverterUInt32.lower(value), $0
		)
	})
}

/**
 * Creates a new `Decimal192` from a u64 integer.
 */
public func newDecimalFromU64(value: UInt64) -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_decimal_from_u64(
			FfiConverterUInt64.lower(value), $0
		)
	})
}

public func newDependencyInformationSample() -> DependencyInformation {
	try! FfiConverterTypeDependencyInformation.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_dependency_information_sample($0
		)
	})
}

public func newDependencyInformationSampleOther() -> DependencyInformation {
	try! FfiConverterTypeDependencyInformation.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_dependency_information_sample_other($0
		)
	})
}

public func newDepositRuleFromJsonString(jsonString: String) throws -> DepositRule {
	try FfiConverterTypeDepositRule.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_deposit_rule_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newDepositRuleSample() -> DepositRule {
	try! FfiConverterTypeDepositRule.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_deposit_rule_sample($0
		)
	})
}

public func newDepositRuleSampleOther() -> DepositRule {
	try! FfiConverterTypeDepositRule.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_deposit_rule_sample_other($0
		)
	})
}

public func newDepositorsAllowListSample() -> [ResourceOrNonFungible] {
	try! FfiConverterSequenceTypeResourceOrNonFungible.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_depositors_allow_list_sample($0
		)
	})
}

public func newDepositorsAllowListSampleOther() -> [ResourceOrNonFungible] {
	try! FfiConverterSequenceTypeResourceOrNonFungible.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_depositors_allow_list_sample_other($0
		)
	})
}

public func newDerivationPathFromString(string: String) throws -> DerivationPath {
	try FfiConverterTypeDerivationPath.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_derivation_path_from_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newDerivationPathSample() -> DerivationPath {
	try! FfiConverterTypeDerivationPath.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_derivation_path_sample($0
		)
	})
}

public func newDerivationPathSampleOther() -> DerivationPath {
	try! FfiConverterTypeDerivationPath.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_derivation_path_sample_other($0
		)
	})
}

public func newDetailedAuthorizedPersonasSample() -> [AuthorizedPersonaDetailed] {
	try! FfiConverterSequenceTypeAuthorizedPersonaDetailed.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_detailed_authorized_personas_sample($0
		)
	})
}

public func newDetailedAuthorizedPersonasSampleOther() -> [AuthorizedPersonaDetailed] {
	try! FfiConverterSequenceTypeAuthorizedPersonaDetailed.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_detailed_authorized_personas_sample_other($0
		)
	})
}

public func newDeviceFactorSourceBabylon(isMain: Bool, mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> DeviceFactorSource {
	try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_device_factor_source_babylon(
			FfiConverterBool.lower(isMain),
			FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
			FfiConverterTypeHostInfo.lower(hostInfo), $0
		)
	})
}

public func newDeviceFactorSourceOlympia(mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> DeviceFactorSource {
	try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_device_factor_source_olympia(
			FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
			FfiConverterTypeHostInfo.lower(hostInfo), $0
		)
	})
}

public func newDeviceFactorSourceSample() -> DeviceFactorSource {
	try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_device_factor_source_sample($0
		)
	})
}

public func newDeviceFactorSourceSampleOther() -> DeviceFactorSource {
	try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_device_factor_source_sample_other($0
		)
	})
}

public func newDeviceInfoDescriptionSample() -> DeviceInfoDescription {
	try! FfiConverterTypeDeviceInfoDescription.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_device_info_description_sample($0
		)
	})
}

public func newDeviceInfoDescriptionSampleOther() -> DeviceInfoDescription {
	try! FfiConverterTypeDeviceInfoDescription.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_device_info_description_sample_other($0
		)
	})
}

public func newDeviceInfoFromHostInfo(hostId: HostId, hostInfo: HostInfo) -> DeviceInfo {
	try! FfiConverterTypeDeviceInfo.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_device_info_from_host_info(
			FfiConverterTypeHostId.lower(hostId),
			FfiConverterTypeHostInfo.lower(hostInfo), $0
		)
	})
}

public func newDeviceInfoFromJsonBytes(jsonBytes: BagOfBytes) throws -> DeviceInfo {
	try FfiConverterTypeDeviceInfo.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_device_info_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newDeviceInfoSample() -> DeviceInfo {
	try! FfiConverterTypeDeviceInfo.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_device_info_sample($0
		)
	})
}

public func newDeviceInfoSampleOther() -> DeviceInfo {
	try! FfiConverterTypeDeviceInfo.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_device_info_sample_other($0
		)
	})
}

public func newDisplayName(name: String) throws -> DisplayName {
	try FfiConverterTypeDisplayName.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_display_name(
			FfiConverterString.lower(name), $0
		)
	})
}

public func newDisplayNameFromJsonString(jsonString: String) throws -> DisplayName {
	try FfiConverterTypeDisplayName.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_display_name_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newDisplayNameSample() -> DisplayName {
	try! FfiConverterTypeDisplayName.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_display_name_sample($0
		)
	})
}

public func newDisplayNameSampleOther() -> DisplayName {
	try! FfiConverterTypeDisplayName.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_display_name_sample_other($0
		)
	})
}

public func newEd25519PublicKeyFromBytes(bytes: BagOfBytes) throws -> Ed25519PublicKey {
	try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newEd25519PublicKeyFromHex(hex: String) throws -> Ed25519PublicKey {
	try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_from_hex(
			FfiConverterString.lower(hex), $0
		)
	})
}

public func newEd25519PublicKeyFromJsonString(jsonString: String) throws -> Ed25519PublicKey {
	try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newEd25519PublicKeySample() -> Ed25519PublicKey {
	try! FfiConverterTypeEd25519PublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_sample($0
		)
	})
}

public func newEd25519PublicKeySampleOther() -> Ed25519PublicKey {
	try! FfiConverterTypeEd25519PublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_sample_other($0
		)
	})
}

public func newEd25519SignatureFromBytes(bytes: BagOfBytes) throws -> Ed25519Signature {
	try FfiConverterTypeEd25519Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_ed25519_signature_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newEd25519SignatureFromExactly64Bytes(bytes: Exactly64Bytes) -> Ed25519Signature {
	try! FfiConverterTypeEd25519Signature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_ed25519_signature_from_exactly_64_bytes(
			FfiConverterTypeExactly64Bytes.lower(bytes), $0
		)
	})
}

public func newEd25519SignatureFromJsonString(jsonString: String) throws -> Ed25519Signature {
	try FfiConverterTypeEd25519Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_ed25519_signature_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newEd25519SignatureSample() -> Ed25519Signature {
	try! FfiConverterTypeEd25519Signature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_ed25519_signature_sample($0
		)
	})
}

public func newEd25519SignatureSampleOther() -> Ed25519Signature {
	try! FfiConverterTypeEd25519Signature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_ed25519_signature_sample_other($0
		)
	})
}

public func newEmailAddressSample() -> EmailAddress {
	try! FfiConverterTypeEmailAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_email_address_sample($0
		)
	})
}

public func newEmailAddressSampleOther() -> EmailAddress {
	try! FfiConverterTypeEmailAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_email_address_sample_other($0
		)
	})
}

public func newEntityFlagSample() -> EntityFlag {
	try! FfiConverterTypeEntityFlag.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entity_flag_sample($0
		)
	})
}

public func newEntityFlagSampleOther() -> EntityFlag {
	try! FfiConverterTypeEntityFlag.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entity_flag_sample_other($0
		)
	})
}

public func newEntityFlagsSample() -> [EntityFlag] {
	try! FfiConverterSequenceTypeEntityFlag.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entity_flags_sample($0
		)
	})
}

public func newEntityFlagsSampleOther() -> [EntityFlag] {
	try! FfiConverterSequenceTypeEntityFlag.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entity_flags_sample_other($0
		)
	})
}

public func newEntitySecurityStateSample() -> EntitySecurityState {
	try! FfiConverterTypeEntitySecurityState.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entity_security_state_sample($0
		)
	})
}

public func newEntitySecurityStateSampleOther() -> EntitySecurityState {
	try! FfiConverterTypeEntitySecurityState.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entity_security_state_sample_other($0
		)
	})
}

public func newEntropy16BytesFromBytes(bytes: BagOfBytes) throws -> Entropy16Bytes {
	try FfiConverterTypeEntropy16Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_entropy16_bytes_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newEntropy16BytesSample() -> Entropy16Bytes {
	try! FfiConverterTypeEntropy16Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entropy16_bytes_sample($0
		)
	})
}

public func newEntropy16BytesSampleOther() -> Entropy16Bytes {
	try! FfiConverterTypeEntropy16Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entropy16_bytes_sample_other($0
		)
	})
}

public func newEntropy20BytesFromBytes(bytes: BagOfBytes) throws -> Entropy20Bytes {
	try FfiConverterTypeEntropy20Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_entropy20_bytes_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newEntropy20BytesSample() -> Entropy20Bytes {
	try! FfiConverterTypeEntropy20Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entropy20_bytes_sample($0
		)
	})
}

public func newEntropy20BytesSampleOther() -> Entropy20Bytes {
	try! FfiConverterTypeEntropy20Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entropy20_bytes_sample_other($0
		)
	})
}

public func newEntropy24BytesFromBytes(bytes: BagOfBytes) throws -> Entropy24Bytes {
	try FfiConverterTypeEntropy24Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_entropy24_bytes_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newEntropy24BytesSample() -> Entropy24Bytes {
	try! FfiConverterTypeEntropy24Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entropy24_bytes_sample($0
		)
	})
}

public func newEntropy24BytesSampleOther() -> Entropy24Bytes {
	try! FfiConverterTypeEntropy24Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entropy24_bytes_sample_other($0
		)
	})
}

public func newEntropy28BytesFromBytes(bytes: BagOfBytes) throws -> Entropy28Bytes {
	try FfiConverterTypeEntropy28Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_entropy28_bytes_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newEntropy28BytesSample() -> Entropy28Bytes {
	try! FfiConverterTypeEntropy28Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entropy28_bytes_sample($0
		)
	})
}

public func newEntropy28BytesSampleOther() -> Entropy28Bytes {
	try! FfiConverterTypeEntropy28Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entropy28_bytes_sample_other($0
		)
	})
}

public func newEntropy32BytesFromBytes(bytes: BagOfBytes) throws -> Entropy32Bytes {
	try FfiConverterTypeEntropy32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_entropy32_bytes_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newEntropy32BytesSample() -> Entropy32Bytes {
	try! FfiConverterTypeEntropy32Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entropy32_bytes_sample($0
		)
	})
}

public func newEntropy32BytesSampleOther() -> Entropy32Bytes {
	try! FfiConverterTypeEntropy32Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_entropy32_bytes_sample_other($0
		)
	})
}

public func newExactly12BytesFromJsonString(jsonString: String) throws -> Exactly12Bytes {
	try FfiConverterTypeExactly12Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly12_bytes_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newExactly29BytesFromJsonString(jsonString: String) throws -> Exactly29Bytes {
	try FfiConverterTypeExactly29Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly29_bytes_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newExactly32BytesFromJsonString(jsonString: String) throws -> Exactly32Bytes {
	try FfiConverterTypeExactly32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly32_bytes_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newExactly33BytesFromJsonString(jsonString: String) throws -> Exactly33Bytes {
	try FfiConverterTypeExactly33Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly33_bytes_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newExactly60BytesFromJsonString(jsonString: String) throws -> Exactly60Bytes {
	try FfiConverterTypeExactly60Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly60_bytes_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newExactly64BytesFromJsonString(jsonString: String) throws -> Exactly64Bytes {
	try FfiConverterTypeExactly64Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly64_bytes_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newExactly65BytesFromJsonString(jsonString: String) throws -> Exactly65Bytes {
	try FfiConverterTypeExactly65Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly65_bytes_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newExactly12Bytes(bytes: BagOfBytes) throws -> Exactly12Bytes {
	try FfiConverterTypeExactly12Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly_12_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newExactly12BytesSample() -> Exactly12Bytes {
	try! FfiConverterTypeExactly12Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_12_bytes_sample($0
		)
	})
}

public func newExactly12BytesSampleOther() -> Exactly12Bytes {
	try! FfiConverterTypeExactly12Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_12_bytes_sample_other($0
		)
	})
}

public func newExactly29Bytes(bytes: BagOfBytes) throws -> Exactly29Bytes {
	try FfiConverterTypeExactly29Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly_29_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newExactly29BytesSample() -> Exactly29Bytes {
	try! FfiConverterTypeExactly29Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_29_bytes_sample($0
		)
	})
}

public func newExactly29BytesSampleOther() -> Exactly29Bytes {
	try! FfiConverterTypeExactly29Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_29_bytes_sample_other($0
		)
	})
}

public func newExactly32Bytes(bytes: BagOfBytes) throws -> Exactly32Bytes {
	try FfiConverterTypeExactly32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly_32_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newExactly32BytesSample() -> Exactly32Bytes {
	try! FfiConverterTypeExactly32Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_32_bytes_sample($0
		)
	})
}

public func newExactly32BytesSampleOther() -> Exactly32Bytes {
	try! FfiConverterTypeExactly32Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_32_bytes_sample_other($0
		)
	})
}

public func newExactly33Bytes(bytes: BagOfBytes) throws -> Exactly33Bytes {
	try FfiConverterTypeExactly33Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly_33_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newExactly33BytesSample() -> Exactly33Bytes {
	try! FfiConverterTypeExactly33Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_33_bytes_sample($0
		)
	})
}

public func newExactly33BytesSampleOther() -> Exactly33Bytes {
	try! FfiConverterTypeExactly33Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_33_bytes_sample_other($0
		)
	})
}

public func newExactly60Bytes(bytes: BagOfBytes) throws -> Exactly60Bytes {
	try FfiConverterTypeExactly60Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly_60_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newExactly60BytesSample() -> Exactly60Bytes {
	try! FfiConverterTypeExactly60Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_60_bytes_sample($0
		)
	})
}

public func newExactly60BytesSampleOther() -> Exactly60Bytes {
	try! FfiConverterTypeExactly60Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_60_bytes_sample_other($0
		)
	})
}

public func newExactly64Bytes(bytes: BagOfBytes) throws -> Exactly64Bytes {
	try FfiConverterTypeExactly64Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly_64_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newExactly64BytesSample() -> Exactly64Bytes {
	try! FfiConverterTypeExactly64Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_64_bytes_sample($0
		)
	})
}

public func newExactly64BytesSampleOther() -> Exactly64Bytes {
	try! FfiConverterTypeExactly64Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_64_bytes_sample_other($0
		)
	})
}

public func newExactly65Bytes(bytes: BagOfBytes) throws -> Exactly65Bytes {
	try FfiConverterTypeExactly65Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_exactly_65_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newExactly65BytesSample() -> Exactly65Bytes {
	try! FfiConverterTypeExactly65Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_65_bytes_sample($0
		)
	})
}

public func newExactly65BytesSampleOther() -> Exactly65Bytes {
	try! FfiConverterTypeExactly65Bytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_exactly_65_bytes_sample_other($0
		)
	})
}

public func newFactorSourceCommonBabylon() -> FactorSourceCommon {
	try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_common_babylon($0
		)
	})
}

public func newFactorSourceCommonBdfs(isMain: Bool) -> FactorSourceCommon {
	try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_common_bdfs(
			FfiConverterBool.lower(isMain), $0
		)
	})
}

public func newFactorSourceCommonOlympia() -> FactorSourceCommon {
	try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_common_olympia($0
		)
	})
}

public func newFactorSourceCommonSample() -> FactorSourceCommon {
	try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_common_sample($0
		)
	})
}

public func newFactorSourceCommonSampleOther() -> FactorSourceCommon {
	try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_common_sample_other($0
		)
	})
}

public func newFactorSourceCryptoParametersPresetBabylonOlympiaCompatible() -> FactorSourceCryptoParameters {
	try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_preset_babylon_olympia_compatible($0
		)
	})
}

public func newFactorSourceCryptoParametersPresetBabylonOnly() -> FactorSourceCryptoParameters {
	try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_preset_babylon_only($0
		)
	})
}

public func newFactorSourceCryptoParametersPresetOlympiaOnly() -> FactorSourceCryptoParameters {
	try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_preset_olympia_only($0
		)
	})
}

public func newFactorSourceCryptoParametersSample() -> FactorSourceCryptoParameters {
	try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_sample($0
		)
	})
}

public func newFactorSourceCryptoParametersSampleOther() -> FactorSourceCryptoParameters {
	try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_sample_other($0
		)
	})
}

public func newFactorSourceIDFromAddressFromJsonBytes(jsonBytes: BagOfBytes) throws -> FactorSourceIdFromAddress {
	try FfiConverterTypeFactorSourceIDFromAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_factor_source_i_d_from_address_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newFactorSourceIDFromHashFromJsonBytes(jsonBytes: BagOfBytes) throws -> FactorSourceIdFromHash {
	try FfiConverterTypeFactorSourceIDFromHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_factor_source_i_d_from_hash_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newFactorSourceIdFromAddressSample() -> FactorSourceIdFromAddress {
	try! FfiConverterTypeFactorSourceIDFromAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_address_sample($0
		)
	})
}

public func newFactorSourceIdFromAddressSampleOther() -> FactorSourceIdFromAddress {
	try! FfiConverterTypeFactorSourceIDFromAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_address_sample_other($0
		)
	})
}

public func newFactorSourceIdFromHashFromMnemonicWithPassphrase(factorSourceKind: FactorSourceKind, mnemonicWithPassphrase: MnemonicWithPassphrase) -> FactorSourceIdFromHash {
	try! FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_hash_from_mnemonic_with_passphrase(
			FfiConverterTypeFactorSourceKind.lower(factorSourceKind),
			FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase), $0
		)
	})
}

public func newFactorSourceIdFromHashSample() -> FactorSourceIdFromHash {
	try! FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_hash_sample($0
		)
	})
}

public func newFactorSourceIdFromHashSampleOther() -> FactorSourceIdFromHash {
	try! FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_hash_sample_other($0
		)
	})
}

public func newFactorSourceIdSample() -> FactorSourceId {
	try! FfiConverterTypeFactorSourceID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_id_sample($0
		)
	})
}

public func newFactorSourceIdSampleOther() -> FactorSourceId {
	try! FfiConverterTypeFactorSourceID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_id_sample_other($0
		)
	})
}

public func newFactorSourceKindFromString(string: String) throws -> FactorSourceKind {
	try FfiConverterTypeFactorSourceKind.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_factor_source_kind_from_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newFactorSourceKindSample() -> FactorSourceKind {
	try! FfiConverterTypeFactorSourceKind.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_kind_sample($0
		)
	})
}

public func newFactorSourceKindSampleOther() -> FactorSourceKind {
	try! FfiConverterTypeFactorSourceKind.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_kind_sample_other($0
		)
	})
}

public func newFactorSourceSample() -> FactorSource {
	try! FfiConverterTypeFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_sample($0
		)
	})
}

public func newFactorSourceSampleOther() -> FactorSource {
	try! FfiConverterTypeFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_source_sample_other($0
		)
	})
}

public func newFactorSourcesSample() -> [FactorSource] {
	try! FfiConverterSequenceTypeFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_sources_sample($0
		)
	})
}

public func newFactorSourcesSampleOther() -> [FactorSource] {
	try! FfiConverterSequenceTypeFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_factor_sources_sample_other($0
		)
	})
}

public func newFiatCurrencyFromJsonString(jsonString: String) throws -> FiatCurrency {
	try FfiConverterTypeFiatCurrency.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_fiat_currency_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newFiatCurrencySample() -> FiatCurrency {
	try! FfiConverterTypeFiatCurrency.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_fiat_currency_sample($0
		)
	})
}

public func newFiatCurrencySampleOther() -> FiatCurrency {
	try! FfiConverterTypeFiatCurrency.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_fiat_currency_sample_other($0
		)
	})
}

public func newFungibleResourceIndicatorSample() -> FungibleResourceIndicator {
	try! FfiConverterTypeFungibleResourceIndicator.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_fungible_resource_indicator_sample($0
		)
	})
}

public func newFungibleResourceIndicatorSampleOther() -> FungibleResourceIndicator {
	try! FfiConverterTypeFungibleResourceIndicator.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_fungible_resource_indicator_sample_other($0
		)
	})
}

public func newGatewayForNetworkId(networkId: NetworkId) -> Gateway {
	try! FfiConverterTypeGateway.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_gateway_for_network_id(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func newGatewaySample() -> Gateway {
	try! FfiConverterTypeGateway.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_gateway_sample($0
		)
	})
}

public func newGatewaySampleOther() -> Gateway {
	try! FfiConverterTypeGateway.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_gateway_sample_other($0
		)
	})
}

public func newGatewayWithUrlOnNetwork(url: String, networkId: NetworkId) throws -> Gateway {
	try FfiConverterTypeGateway.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_gateway_with_url_on_network(
			FfiConverterString.lower(url),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func newGatewaysSample() -> [Gateway] {
	try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_gateways_sample($0
		)
	})
}

public func newGatewaysSampleOther() -> [Gateway] {
	try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_gateways_sample_other($0
		)
	})
}

public func newHardenedSample() -> Hardened {
	try! FfiConverterTypeHardened.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hardened_sample($0
		)
	})
}

public func newHardenedSampleOther() -> Hardened {
	try! FfiConverterTypeHardened.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hardened_sample_other($0
		)
	})
}

public func newHashFromBytes(bytes: Exactly32Bytes) -> Hash {
	try! FfiConverterTypeHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hash_from_bytes(
			FfiConverterTypeExactly32Bytes.lower(bytes), $0
		)
	})
}

public func newHashFromString(string: String) throws -> Hash {
	try FfiConverterTypeHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_hash_from_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newHashSample() -> Hash {
	try! FfiConverterTypeHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hash_sample($0
		)
	})
}

public func newHashSampleOther() -> Hash {
	try! FfiConverterTypeHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hash_sample_other($0
		)
	})
}

public func newHdPathComponentFromGlobalKeySpace(value: UInt32) -> HdPathComponent {
	try! FfiConverterTypeHDPathComponent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hd_path_component_from_global_key_space(
			FfiConverterUInt32.lower(value), $0
		)
	})
}

public func newHdPathComponentFromLocalKeySpace(value: UInt32, keySpace: KeySpace) throws -> HdPathComponent {
	try FfiConverterTypeHDPathComponent.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_hd_path_component_from_local_key_space(
			FfiConverterUInt32.lower(value),
			FfiConverterTypeKeySpace.lower(keySpace), $0
		)
	})
}

public func newHdPathComponentSample() -> HdPathComponent {
	try! FfiConverterTypeHDPathComponent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hd_path_component_sample($0
		)
	})
}

public func newHdPathComponentSampleOther() -> HdPathComponent {
	try! FfiConverterTypeHDPathComponent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hd_path_component_sample_other($0
		)
	})
}

public func newHeaderFromJsonBytes(jsonBytes: BagOfBytes) throws -> Header {
	try FfiConverterTypeHeader.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_header_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newHeaderSample() -> Header {
	try! FfiConverterTypeHeader.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_header_sample($0
		)
	})
}

public func newHeaderSampleOther() -> Header {
	try! FfiConverterTypeHeader.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_header_sample_other($0
		)
	})
}

/**
 * Instantiates a new `Header` with creating and last used on `DeviceInfo` with
 * "Unknown device" as description, and empty content hint
 */
public func newHeaderWithCreatingDevice(creatingDevice: DeviceInfo) -> Header {
	try! FfiConverterTypeHeader.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_header_with_creating_device(
			FfiConverterTypeDeviceInfo.lower(creatingDevice), $0
		)
	})
}

public func newHiddenResourcesSample() -> [ResourceIdentifier] {
	try! FfiConverterSequenceTypeResourceIdentifier.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hidden_resources_sample($0
		)
	})
}

public func newHiddenResourcesSampleOther() -> [ResourceIdentifier] {
	try! FfiConverterSequenceTypeResourceIdentifier.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hidden_resources_sample_other($0
		)
	})
}

public func newHierarchicalDeterministicFactorInstanceSample() -> HierarchicalDeterministicFactorInstance {
	try! FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hierarchical_deterministic_factor_instance_sample($0
		)
	})
}

public func newHierarchicalDeterministicFactorInstanceSampleOther() -> HierarchicalDeterministicFactorInstance {
	try! FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hierarchical_deterministic_factor_instance_sample_other($0
		)
	})
}

public func newHierarchicalDeterministicPublicKeySample() -> HierarchicalDeterministicPublicKey {
	try! FfiConverterTypeHierarchicalDeterministicPublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hierarchical_deterministic_public_key_sample($0
		)
	})
}

public func newHierarchicalDeterministicPublicKeySampleOther() -> HierarchicalDeterministicPublicKey {
	try! FfiConverterTypeHierarchicalDeterministicPublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_hierarchical_deterministic_public_key_sample_other($0
		)
	})
}

public func newHostIdFromJsonBytes(jsonBytes: BagOfBytes) throws -> HostId {
	try FfiConverterTypeHostId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_host_id_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newHostIdSample() -> HostId {
	try! FfiConverterTypeHostId.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_host_id_sample($0
		)
	})
}

public func newHostIdSampleOther() -> HostId {
	try! FfiConverterTypeHostId.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_host_id_sample_other($0
		)
	})
}

public func newHostInfoSample() -> HostInfo {
	try! FfiConverterTypeHostInfo.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_host_info_sample($0
		)
	})
}

public func newHostInfoSampleOther() -> HostInfo {
	try! FfiConverterTypeHostInfo.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_host_info_sample_other($0
		)
	})
}

public func newHostOsAndroid(vendor: String, version: String) -> HostOs {
	try! FfiConverterTypeHostOS.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_host_os_android(
			FfiConverterString.lower(vendor),
			FfiConverterString.lower(version), $0
		)
	})
}

public func newHostOsIos(version: String) -> HostOs {
	try! FfiConverterTypeHostOS.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_host_os_ios(
			FfiConverterString.lower(version), $0
		)
	})
}

public func newHostOsOther(name: String, vendor: String, version: String) -> HostOs {
	try! FfiConverterTypeHostOS.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_host_os_other(
			FfiConverterString.lower(name),
			FfiConverterString.lower(vendor),
			FfiConverterString.lower(version), $0
		)
	})
}

public func newHostOsSample() -> HostOs {
	try! FfiConverterTypeHostOS.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_host_os_sample($0
		)
	})
}

public func newHostOsSampleOther() -> HostOs {
	try! FfiConverterTypeHostOS.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_host_os_sample_other($0
		)
	})
}

public func newIdentityAddress(bech32: String) throws -> IdentityAddress {
	try FfiConverterTypeIdentityAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_identity_address(
			FfiConverterString.lower(bech32), $0
		)
	})
}

public func newIdentityAddressFrom(publicKey: PublicKey, networkId: NetworkId) -> IdentityAddress {
	try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_identity_address_from(
			FfiConverterTypePublicKey.lower(publicKey),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newIdentityAddressRandom(networkId: NetworkId) -> IdentityAddress {
	try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_identity_address_random(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func newIdentityAddressSampleMainnet() -> IdentityAddress {
	try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_identity_address_sample_mainnet($0
		)
	})
}

public func newIdentityAddressSampleMainnetOther() -> IdentityAddress {
	try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_identity_address_sample_mainnet_other($0
		)
	})
}

public func newIdentityAddressSampleStokenet() -> IdentityAddress {
	try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_identity_address_sample_stokenet($0
		)
	})
}

public func newIdentityAddressSampleStokenetOther() -> IdentityAddress {
	try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_identity_address_sample_stokenet_other($0
		)
	})
}

public func newIdentityPath(networkId: NetworkId, keyKind: Cap26KeyKind, index: Hardened) -> IdentityPath {
	try! FfiConverterTypeIdentityPath.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_identity_path(
			FfiConverterTypeNetworkID.lower(networkId),
			FfiConverterTypeCAP26KeyKind.lower(keyKind),
			FfiConverterTypeHardened.lower(index), $0
		)
	})
}

public func newIdentityPathSample() -> IdentityPath {
	try! FfiConverterTypeIdentityPath.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_identity_path_sample($0
		)
	})
}

public func newIdentityPathSampleOther() -> IdentityPath {
	try! FfiConverterTypeIdentityPath.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_identity_path_sample_other($0
		)
	})
}

public func newIntentDiscriminatorFromU64(value: UInt64) -> IntentDiscriminator {
	try! FfiConverterTypeIntentDiscriminator.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_intent_discriminator_from_u64(
			FfiConverterUInt64.lower(value), $0
		)
	})
}

public func newIntentDiscriminatorRandom() -> IntentDiscriminator {
	try! FfiConverterTypeIntentDiscriminator.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_intent_discriminator_random($0
		)
	})
}

public func newIntentDiscriminatorSample() -> IntentDiscriminator {
	try! FfiConverterTypeIntentDiscriminator.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_intent_discriminator_sample($0
		)
	})
}

public func newIntentDiscriminatorSampleOther() -> IntentDiscriminator {
	try! FfiConverterTypeIntentDiscriminator.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_intent_discriminator_sample_other($0
		)
	})
}

public func newIntentHeaderV2Sample() -> IntentHeaderV2 {
	try! FfiConverterTypeIntentHeaderV2.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_intent_header_v2_sample($0
		)
	})
}

public func newIntentHeaderV2SampleOther() -> IntentHeaderV2 {
	try! FfiConverterTypeIntentHeaderV2.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_intent_header_v2_sample_other($0
		)
	})
}

public func newIntentSignatureFromSignatureWithPublicKey(signatureWithPublicKey: SignatureWithPublicKey) -> IntentSignature {
	try! FfiConverterTypeIntentSignature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_intent_signature_from_signature_with_public_key(
			FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey), $0
		)
	})
}

public func newIntentSignatureSample() -> IntentSignature {
	try! FfiConverterTypeIntentSignature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_intent_signature_sample($0
		)
	})
}

public func newIntentSignatureSampleOther() -> IntentSignature {
	try! FfiConverterTypeIntentSignature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_intent_signature_sample_other($0
		)
	})
}

/**
 * Creates a Secp256k1PublicKey from either compressed form (33 bytes) or
 * from uncompressed form (65 bytes).
 */
public func newKeyAgreementPublicKeyFromBytes(bytes: BagOfBytes) throws -> KeyAgreementPublicKey {
	try FfiConverterTypeKeyAgreementPublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_key_agreement_public_key_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newKeyAgreementPublicKeyFromHex(hex: String) throws -> KeyAgreementPublicKey {
	try FfiConverterTypeKeyAgreementPublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_key_agreement_public_key_from_hex(
			FfiConverterString.lower(hex), $0
		)
	})
}

public func newKeyAgreementPublicKeySample() -> KeyAgreementPublicKey {
	try! FfiConverterTypeKeyAgreementPublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_key_agreement_public_key_sample($0
		)
	})
}

public func newKeyAgreementPublicKeySampleOther() -> KeyAgreementPublicKey {
	try! FfiConverterTypeKeyAgreementPublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_key_agreement_public_key_sample_other($0
		)
	})
}

public func newKeySpaceSample() -> KeySpace {
	try! FfiConverterTypeKeySpace.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_key_space_sample($0
		)
	})
}

public func newKeySpaceSampleOther() -> KeySpace {
	try! FfiConverterTypeKeySpace.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_key_space_sample_other($0
		)
	})
}

public func newLedgerHardwareWalletFactorSourceSample() -> LedgerHardwareWalletFactorSource {
	try! FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_ledger_hardware_wallet_factor_source_sample($0
		)
	})
}

public func newLedgerHardwareWalletFactorSourceSampleOther() -> LedgerHardwareWalletFactorSource {
	try! FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_ledger_hardware_wallet_factor_source_sample_other($0
		)
	})
}

public func newLedgerHardwareWalletFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: LedgerHardwareWalletHint, common: FactorSourceCommon) -> LedgerHardwareWalletFactorSource {
	try! FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_ledger_hardware_wallet_from_mnemonic_with_passphrase(
			FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
			FfiConverterTypeLedgerHardwareWalletHint.lower(hint),
			FfiConverterTypeFactorSourceCommon.lower(common), $0
		)
	})
}

public func newLedgerHwWalletModelFromString(string: String) throws -> LedgerHardwareWalletModel {
	try FfiConverterTypeLedgerHardwareWalletModel.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_ledger_hw_wallet_model_from_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newLedgerHwWalletModelSample() -> LedgerHardwareWalletModel {
	try! FfiConverterTypeLedgerHardwareWalletModel.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_ledger_hw_wallet_model_sample($0
		)
	})
}

public func newLedgerHwWalletModelSampleOther() -> LedgerHardwareWalletModel {
	try! FfiConverterTypeLedgerHardwareWalletModel.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_ledger_hw_wallet_model_sample_other($0
		)
	})
}

public func newLegacyOlympiaAccountAddressFromPublicKey(publicKey: Secp256k1PublicKey) -> LegacyOlympiaAccountAddress {
	try! FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_legacy_olympia_account_address_from_public_key(
			FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
		)
	})
}

public func newLegacyOlympiaAccountAddressFromString(string: String) throws -> LegacyOlympiaAccountAddress {
	try FfiConverterTypeLegacyOlympiaAccountAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_legacy_olympia_account_address_from_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newLegacyOlympiaAccountAddressSample() -> LegacyOlympiaAccountAddress {
	try! FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_legacy_olympia_account_address_sample($0
		)
	})
}

public func newLegacyOlympiaAccountAddressSampleOther() -> LegacyOlympiaAccountAddress {
	try! FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_legacy_olympia_account_address_sample_other($0
		)
	})
}

public func newLinkConnectionQRDataFromJsonBytes(jsonBytes: BagOfBytes) throws -> LinkConnectionQrData {
	try FfiConverterTypeLinkConnectionQRData.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_link_connection_q_r_data_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newLinkConnectionQrDataSample() -> LinkConnectionQrData {
	try! FfiConverterTypeLinkConnectionQRData.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_link_connection_qr_data_sample($0
		)
	})
}

public func newLinkConnectionQrDataSampleOther() -> LinkConnectionQrData {
	try! FfiConverterTypeLinkConnectionQRData.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_link_connection_qr_data_sample_other($0
		)
	})
}

public func newLockerAddress(bech32: String) throws -> LockerAddress {
	try FfiConverterTypeLockerAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_locker_address(
			FfiConverterString.lower(bech32), $0
		)
	})
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newLockerAddressRandom(networkId: NetworkId) -> LockerAddress {
	try! FfiConverterTypeLockerAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_locker_address_random(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func newLockerAddressSampleMainnet() -> LockerAddress {
	try! FfiConverterTypeLockerAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_locker_address_sample_mainnet($0
		)
	})
}

public func newLockerAddressSampleMainnetOther() -> LockerAddress {
	try! FfiConverterTypeLockerAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_locker_address_sample_mainnet_other($0
		)
	})
}

public func newLockerAddressSampleStokenet() -> LockerAddress {
	try! FfiConverterTypeLockerAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_locker_address_sample_stokenet($0
		)
	})
}

public func newLockerAddressSampleStokenetOther() -> LockerAddress {
	try! FfiConverterTypeLockerAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_locker_address_sample_stokenet_other($0
		)
	})
}

public func newManifestEncounteredComponentAddressFromBech32(string: String) throws -> ManifestEncounteredComponentAddress {
	try FfiConverterTypeManifestEncounteredComponentAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_from_bech32(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newManifestEncounteredComponentAddressSampleMainnet() -> ManifestEncounteredComponentAddress {
	try! FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_sample_mainnet($0
		)
	})
}

public func newManifestEncounteredComponentAddressSampleMainnetOther() -> ManifestEncounteredComponentAddress {
	try! FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_sample_mainnet_other($0
		)
	})
}

public func newManifestEncounteredComponentAddressSampleStokenet() -> ManifestEncounteredComponentAddress {
	try! FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_sample_stokenet($0
		)
	})
}

public func newManifestEncounteredComponentAddressSampleStokenetOther() -> ManifestEncounteredComponentAddress {
	try! FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_sample_stokenet_other($0
		)
	})
}

public func newMatrixOfFactorSourcesSample() -> MatrixOfFactorSources {
	try! FfiConverterTypeMatrixOfFactorSources.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_matrix_of_factor_sources_sample($0
		)
	})
}

public func newMatrixOfFactorSourcesSampleOther() -> MatrixOfFactorSources {
	try! FfiConverterTypeMatrixOfFactorSources.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_matrix_of_factor_sources_sample_other($0
		)
	})
}

public func newMessagePlaintextSample() -> Message {
	try! FfiConverterTypeMessage.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_message_plaintext_sample($0
		)
	})
}

public func newMessagePlaintextSampleOther() -> Message {
	try! FfiConverterTypeMessage.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_message_plaintext_sample_other($0
		)
	})
}

public func newMessagePlaintextString(string: String) -> Message {
	try! FfiConverterTypeMessage.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_message_plaintext_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newMessageV2PlaintextSample() -> MessageV2 {
	try! FfiConverterTypeMessageV2.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_message_v2_plaintext_sample($0
		)
	})
}

public func newMessageV2PlaintextSampleOther() -> MessageV2 {
	try! FfiConverterTypeMessageV2.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_message_v2_plaintext_sample_other($0
		)
	})
}

public func newMessageV2PlaintextString(string: String) -> MessageV2 {
	try! FfiConverterTypeMessageV2.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_message_v2_plaintext_string(
			FfiConverterString.lower(string), $0
		)
	})
}

/**
 * Returns new mnemonic from a string of words
 */
public func newMnemonicFromPhrase(phrase: String) throws -> Mnemonic {
	try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_from_phrase(
			FfiConverterString.lower(phrase), $0
		)
	})
}

public func newMnemonicFromPhraseLanguage(phrase: String, language: Bip39Language) throws -> Mnemonic {
	try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_from_phrase_language(
			FfiConverterString.lower(phrase),
			FfiConverterTypeBIP39Language.lower(language), $0
		)
	})
}

public func newMnemonicFromWords(words: [Bip39Word]) throws -> Mnemonic {
	try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_from_words(
			FfiConverterSequenceTypeBIP39Word.lower(words), $0
		)
	})
}

public func newMnemonicGenerateWithEntropy(entropy: Bip39Entropy, language: Bip39Language) -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_generate_with_entropy(
			FfiConverterTypeBIP39Entropy.lower(entropy),
			FfiConverterTypeBIP39Language.lower(language), $0
		)
	})
}

public func newMnemonicSample() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample($0
		)
	})
}

public func newMnemonicSampleArculus() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_arculus($0
		)
	})
}

public func newMnemonicSampleArculusOther() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_arculus_other($0
		)
	})
}

public func newMnemonicSampleDevice() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_device($0
		)
	})
}

public func newMnemonicSampleDevice12Words() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_device_12_words($0
		)
	})
}

public func newMnemonicSampleDevice12WordsOther() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_device_12_words_other($0
		)
	})
}

public func newMnemonicSampleDeviceOther() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_device_other($0
		)
	})
}

public func newMnemonicSampleLedger() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_ledger($0
		)
	})
}

public func newMnemonicSampleLedgerOther() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_ledger_other($0
		)
	})
}

public func newMnemonicSampleOffDevice() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_off_device($0
		)
	})
}

public func newMnemonicSampleOffDeviceOther() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_off_device_other($0
		)
	})
}

public func newMnemonicSampleOther() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_other($0
		)
	})
}

public func newMnemonicSamplePassphrase() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_passphrase($0
		)
	})
}

public func newMnemonicSamplePassphraseOther() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_passphrase_other($0
		)
	})
}

public func newMnemonicSampleSecurityQuestions() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_security_questions($0
		)
	})
}

public func newMnemonicSampleSecurityQuestionsOther() -> Mnemonic {
	try! FfiConverterTypeMnemonic.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_security_questions_other($0
		)
	})
}

public func newMnemonicWithPassphraseFromJsonBytes(jsonBytes: BagOfBytes) throws -> MnemonicWithPassphrase {
	try FfiConverterTypeMnemonicWithPassphrase.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_with_passphrase_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newMnemonicWithPassphraseSample() -> MnemonicWithPassphrase {
	try! FfiConverterTypeMnemonicWithPassphrase.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_with_passphrase_sample($0
		)
	})
}

public func newMnemonicWithPassphraseSampleOther() -> MnemonicWithPassphrase {
	try! FfiConverterTypeMnemonicWithPassphrase.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_mnemonic_with_passphrase_sample_other($0
		)
	})
}

public func newNetworkDefinitionLookupByName(logicalName: String) throws -> NetworkDefinition {
	try FfiConverterTypeNetworkDefinition.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_network_definition_lookup_by_name(
			FfiConverterString.lower(logicalName), $0
		)
	})
}

public func newNetworkDefinitionSample() -> NetworkDefinition {
	try! FfiConverterTypeNetworkDefinition.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_network_definition_sample($0
		)
	})
}

public func newNetworkDefinitionSampleOther() -> NetworkDefinition {
	try! FfiConverterTypeNetworkDefinition.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_network_definition_sample_other($0
		)
	})
}

public func newNetworkIdFromDiscriminant(discriminant: UInt8) throws -> NetworkId {
	try FfiConverterTypeNetworkID.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_network_id_from_discriminant(
			FfiConverterUInt8.lower(discriminant), $0
		)
	})
}

public func newNetworkMethodSample() -> NetworkMethod {
	try! FfiConverterTypeNetworkMethod.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_network_method_sample($0
		)
	})
}

public func newNetworkMethodSampleOther() -> NetworkMethod {
	try! FfiConverterTypeNetworkMethod.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_network_method_sample_other($0
		)
	})
}

public func newNetworkRequestSample() -> NetworkRequest {
	try! FfiConverterTypeNetworkRequest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_network_request_sample($0
		)
	})
}

public func newNetworkRequestSampleOther() -> NetworkRequest {
	try! FfiConverterTypeNetworkRequest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_network_request_sample_other($0
		)
	})
}

public func newNonEmptyMax32Bytes(bagOfBytes: BagOfBytes) throws -> NonEmptyMax32Bytes {
	try FfiConverterTypeNonEmptyMax32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_non_empty_max_32_bytes(
			FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
		)
	})
}

public func newNonEmptyMax64Bytes(bagOfBytes: BagOfBytes) throws -> NonEmptyMax64Bytes {
	try FfiConverterTypeNonEmptyMax64Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_non_empty_max_64_bytes(
			FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
		)
	})
}

public func newNonFungibleGlobalIdFromString(string: String) throws -> NonFungibleGlobalId {
	try FfiConverterTypeNonFungibleGlobalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_global_id_from_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newNonFungibleGlobalIdSample() -> NonFungibleGlobalId {
	try! FfiConverterTypeNonFungibleGlobalId.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_global_id_sample($0
		)
	})
}

public func newNonFungibleGlobalIdSampleOther() -> NonFungibleGlobalId {
	try! FfiConverterTypeNonFungibleGlobalId.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_global_id_sample_other($0
		)
	})
}

public func newNonFungibleLocalIdBytes(bytes: BagOfBytes) throws -> NonFungibleLocalId {
	try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newNonFungibleLocalIdFromString(localId: String) throws -> NonFungibleLocalId {
	try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_from_string(
			FfiConverterString.lower(localId), $0
		)
	})
}

public func newNonFungibleLocalIdInt(value: UInt64) -> NonFungibleLocalId {
	try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_int(
			FfiConverterUInt64.lower(value), $0
		)
	})
}

public func newNonFungibleLocalIdRandom() -> NonFungibleLocalId {
	try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_random($0
		)
	})
}

public func newNonFungibleLocalIdRuid(bytes: BagOfBytes) throws -> NonFungibleLocalId {
	try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_ruid(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newNonFungibleLocalIdSample() -> NonFungibleLocalId {
	try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_sample($0
		)
	})
}

public func newNonFungibleLocalIdSampleOther() -> NonFungibleLocalId {
	try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_sample_other($0
		)
	})
}

public func newNonFungibleLocalIdString(string: String) throws -> NonFungibleLocalId {
	try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newNonFungibleLocalIdStringFromStr(string: String) throws -> NonFungibleLocalIdString {
	try FfiConverterTypeNonFungibleLocalIdString.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_string_from_str(
			FfiConverterString.lower(string), $0
		)
	})
}

/**
 * Tries to bech32 decode the string into a specialized address.
 */
public func newNonFungibleResourceAddress(bech32: String) throws -> NonFungibleResourceAddress {
	try FfiConverterTypeNonFungibleResourceAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address(
			FfiConverterString.lower(bech32), $0
		)
	})
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newNonFungibleResourceAddressRandom(networkId: NetworkId) -> NonFungibleResourceAddress {
	try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_random(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func newNonFungibleResourceAddressSampleMainnet() -> NonFungibleResourceAddress {
	try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_sample_mainnet($0
		)
	})
}

public func newNonFungibleResourceAddressSampleMainnetOther() -> NonFungibleResourceAddress {
	try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_sample_mainnet_other($0
		)
	})
}

public func newNonFungibleResourceAddressSampleStokenet() -> NonFungibleResourceAddress {
	try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_sample_stokenet($0
		)
	})
}

public func newNonFungibleResourceAddressSampleStokenetOther() -> NonFungibleResourceAddress {
	try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_sample_stokenet_other($0
		)
	})
}

public func newNonFungibleResourceIndicatorSample() -> NonFungibleResourceIndicator {
	try! FfiConverterTypeNonFungibleResourceIndicator.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_indicator_sample($0
		)
	})
}

public func newNonFungibleResourceIndicatorSampleOther() -> NonFungibleResourceIndicator {
	try! FfiConverterTypeNonFungibleResourceIndicator.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_indicator_sample_other($0
		)
	})
}

public func newNonceFromU32(value: UInt32) -> Nonce {
	try! FfiConverterTypeNonce.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_nonce_from_u32(
			FfiConverterUInt32.lower(value), $0
		)
	})
}

public func newNonceRandom() -> Nonce {
	try! FfiConverterTypeNonce.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_nonce_random($0
		)
	})
}

public func newNonceSample() -> Nonce {
	try! FfiConverterTypeNonce.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_nonce_sample($0
		)
	})
}

public func newNonceSampleOther() -> Nonce {
	try! FfiConverterTypeNonce.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_nonce_sample_other($0
		)
	})
}

public func newNotarizedTransactionSample() -> NotarizedTransaction {
	try! FfiConverterTypeNotarizedTransaction.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_notarized_transaction_sample($0
		)
	})
}

public func newNotarizedTransactionSampleOther() -> NotarizedTransaction {
	try! FfiConverterTypeNotarizedTransaction.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_notarized_transaction_sample_other($0
		)
	})
}

public func newNotarySignature(signature: Signature) -> NotarySignature {
	try! FfiConverterTypeNotarySignature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_notary_signature(
			FfiConverterTypeSignature.lower(signature), $0
		)
	})
}

public func newNotarySignatureSample() -> NotarySignature {
	try! FfiConverterTypeNotarySignature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_notary_signature_sample($0
		)
	})
}

public func newNotarySignatureSampleOther() -> NotarySignature {
	try! FfiConverterTypeNotarySignature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_notary_signature_sample_other($0
		)
	})
}

public func newOffDeviceMnemonicFactorSourceFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: OffDeviceMnemonicHint) -> OffDeviceMnemonicFactorSource {
	try! FfiConverterTypeOffDeviceMnemonicFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_off_device_mnemonic_factor_source_from_mnemonic_with_passphrase(
			FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
			FfiConverterTypeOffDeviceMnemonicHint.lower(hint), $0
		)
	})
}

public func newOffDeviceMnemonicFactorSourceSample() -> OffDeviceMnemonicFactorSource {
	try! FfiConverterTypeOffDeviceMnemonicFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_off_device_mnemonic_factor_source_sample($0
		)
	})
}

public func newOffDeviceMnemonicFactorSourceSampleOther() -> OffDeviceMnemonicFactorSource {
	try! FfiConverterTypeOffDeviceMnemonicFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_off_device_mnemonic_factor_source_sample_other($0
		)
	})
}

public func newOnLedgerSettingsDefault() -> OnLedgerSettings {
	try! FfiConverterTypeOnLedgerSettings.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_on_ledger_settings_default($0
		)
	})
}

public func newOnLedgerSettingsSample() -> OnLedgerSettings {
	try! FfiConverterTypeOnLedgerSettings.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_on_ledger_settings_sample($0
		)
	})
}

public func newOnLedgerSettingsSampleOther() -> OnLedgerSettings {
	try! FfiConverterTypeOnLedgerSettings.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_on_ledger_settings_sample_other($0
		)
	})
}

public func newP2PLinkFromJsonBytes(jsonBytes: BagOfBytes) throws -> P2pLink {
	try FfiConverterTypeP2PLink.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_p2_p_link_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newP2PLinksSample() -> [P2pLink] {
	try! FfiConverterSequenceTypeP2PLink.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_p2_p_links_sample($0
		)
	})
}

public func newP2PLinksSampleOther() -> [P2pLink] {
	try! FfiConverterSequenceTypeP2PLink.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_p2_p_links_sample_other($0
		)
	})
}

public func newP2pLinkSample() -> P2pLink {
	try! FfiConverterTypeP2PLink.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_p2p_link_sample($0
		)
	})
}

public func newP2pLinkSampleOther() -> P2pLink {
	try! FfiConverterTypeP2PLink.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_p2p_link_sample_other($0
		)
	})
}

public func newP2pLinksFromJsonBytes(jsonBytes: BagOfBytes) throws -> [P2pLink] {
	try FfiConverterSequenceTypeP2PLink.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_p2p_links_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newPackageAddress(bech32: String) throws -> PackageAddress {
	try FfiConverterTypePackageAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_package_address(
			FfiConverterString.lower(bech32), $0
		)
	})
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newPackageAddressRandom(networkId: NetworkId) -> PackageAddress {
	try! FfiConverterTypePackageAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_package_address_random(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func newPackageAddressSampleMainnet() -> PackageAddress {
	try! FfiConverterTypePackageAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_package_address_sample_mainnet($0
		)
	})
}

public func newPackageAddressSampleMainnetOther() -> PackageAddress {
	try! FfiConverterTypePackageAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_package_address_sample_mainnet_other($0
		)
	})
}

public func newPackageAddressSampleStokenet() -> PackageAddress {
	try! FfiConverterTypePackageAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_package_address_sample_stokenet($0
		)
	})
}

public func newPackageAddressSampleStokenetOther() -> PackageAddress {
	try! FfiConverterTypePackageAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_package_address_sample_stokenet_other($0
		)
	})
}

public func newPassphraseFactorSourceFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase) -> PassphraseFactorSource {
	try! FfiConverterTypePassphraseFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_passphrase_factor_source_from_mnemonic_with_passphrase(
			FfiConverterTypeMnemonicWithPassphrase.lower(mwp), $0
		)
	})
}

public func newPassphraseFactorSourceSample() -> PassphraseFactorSource {
	try! FfiConverterTypePassphraseFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_passphrase_factor_source_sample($0
		)
	})
}

public func newPassphraseFactorSourceSampleOther() -> PassphraseFactorSource {
	try! FfiConverterTypePassphraseFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_passphrase_factor_source_sample_other($0
		)
	})
}

public func newPerAssetTransfersSample() -> PerAssetTransfers {
	try! FfiConverterTypePerAssetTransfers.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_per_asset_transfers_sample($0
		)
	})
}

public func newPerAssetTransfersSampleOther() -> PerAssetTransfers {
	try! FfiConverterTypePerAssetTransfers.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_per_asset_transfers_sample_other($0
		)
	})
}

public func newPersonaDataEntryEmailAddressFromJsonString(jsonString: String) throws -> EmailAddress {
	try FfiConverterTypeEmailAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_persona_data_entry_email_address_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newPersonaDataEntryEmailAddressSample() -> EmailAddress {
	try! FfiConverterTypeEmailAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_data_entry_email_address_sample($0
		)
	})
}

public func newPersonaDataEntryEmailAddressSampleOther() -> EmailAddress {
	try! FfiConverterTypeEmailAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_data_entry_email_address_sample_other($0
		)
	})
}

public func newPersonaDataEntryNameFromJsonBytes(jsonBytes: BagOfBytes) throws -> PersonaDataEntryName {
	try FfiConverterTypePersonaDataEntryName.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_persona_data_entry_name_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newPersonaDataEntryNameSample() -> PersonaDataEntryName {
	try! FfiConverterTypePersonaDataEntryName.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_data_entry_name_sample($0
		)
	})
}

public func newPersonaDataEntryNameSampleOther() -> PersonaDataEntryName {
	try! FfiConverterTypePersonaDataEntryName.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_data_entry_name_sample_other($0
		)
	})
}

public func newPersonaDataEntryPhoneNumberFromJsonString(jsonString: String) throws -> PersonaDataEntryPhoneNumber {
	try FfiConverterTypePersonaDataEntryPhoneNumber.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_persona_data_entry_phone_number_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newPersonaDataEntryPhoneNumberSample() -> PersonaDataEntryPhoneNumber {
	try! FfiConverterTypePersonaDataEntryPhoneNumber.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_data_entry_phone_number_sample($0
		)
	})
}

public func newPersonaDataEntryPhoneNumberSampleOther() -> PersonaDataEntryPhoneNumber {
	try! FfiConverterTypePersonaDataEntryPhoneNumber.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_data_entry_phone_number_sample_other($0
		)
	})
}

public func newPersonaDataSample() -> PersonaData {
	try! FfiConverterTypePersonaData.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_data_sample($0
		)
	})
}

public func newPersonaDataSampleOther() -> PersonaData {
	try! FfiConverterTypePersonaData.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_data_sample_other($0
		)
	})
}

public func newPersonaSample() -> Persona {
	try! FfiConverterTypePersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_sample($0
		)
	})
}

public func newPersonaSampleMainnetBatman() -> Persona {
	try! FfiConverterTypePersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_sample_mainnet_batman($0
		)
	})
}

public func newPersonaSampleMainnetRipley() -> Persona {
	try! FfiConverterTypePersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_sample_mainnet_ripley($0
		)
	})
}

public func newPersonaSampleMainnetSatoshi() -> Persona {
	try! FfiConverterTypePersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_sample_mainnet_satoshi($0
		)
	})
}

public func newPersonaSampleMainnetTuring() -> Persona {
	try! FfiConverterTypePersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_sample_mainnet_turing($0
		)
	})
}

public func newPersonaSampleOther() -> Persona {
	try! FfiConverterTypePersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_sample_other($0
		)
	})
}

public func newPersonaSampleStokenetConnor() -> Persona {
	try! FfiConverterTypePersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_sample_stokenet_connor($0
		)
	})
}

public func newPersonaSampleStokenetHermione() -> Persona {
	try! FfiConverterTypePersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_sample_stokenet_hermione($0
		)
	})
}

public func newPersonaSampleStokenetLeiaSkywalker() -> Persona {
	try! FfiConverterTypePersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_persona_sample_stokenet_leia_skywalker($0
		)
	})
}

public func newPersonasSample() -> [Persona] {
	try! FfiConverterSequenceTypePersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_personas_sample($0
		)
	})
}

public func newPersonasSampleOther() -> [Persona] {
	try! FfiConverterSequenceTypePersona.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_personas_sample_other($0
		)
	})
}

public func newPoolAddress(bech32: String) throws -> PoolAddress {
	try FfiConverterTypePoolAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_pool_address(
			FfiConverterString.lower(bech32), $0
		)
	})
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newPoolAddressRandom(networkId: NetworkId) -> PoolAddress {
	try! FfiConverterTypePoolAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_pool_address_random(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

/**
 * Sample to a mainnet PoolAddress with three resources.
 */
public func newPoolAddressSampleMainnetMulti() -> PoolAddress {
	try! FfiConverterTypePoolAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_pool_address_sample_mainnet_multi($0
		)
	})
}

/**
 * Sample to a mainnet PoolAddress with single resource.
 */
public func newPoolAddressSampleMainnetSingle() -> PoolAddress {
	try! FfiConverterTypePoolAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_pool_address_sample_mainnet_single($0
		)
	})
}

/**
 * Sample to a mainnet PoolAddress with two resources.
 */
public func newPoolAddressSampleMainnetTwo() -> PoolAddress {
	try! FfiConverterTypePoolAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_pool_address_sample_mainnet_two($0
		)
	})
}

/**
 * Sample to a stokenet PoolAddress with three resources.
 */
public func newPoolAddressSampleStokenetMulti() -> PoolAddress {
	try! FfiConverterTypePoolAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_pool_address_sample_stokenet_multi($0
		)
	})
}

/**
 * Sample to a stokenet PoolAddress with single resource.
 */
public func newPoolAddressSampleStokenetSingle() -> PoolAddress {
	try! FfiConverterTypePoolAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_pool_address_sample_stokenet_single($0
		)
	})
}

/**
 * Sample to a stokenet PoolAddress with two resources.
 */
public func newPoolAddressSampleStokenetTwo() -> PoolAddress {
	try! FfiConverterTypePoolAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_pool_address_sample_stokenet_two($0
		)
	})
}

public func newPrivateHdFactorSourceBabylon(isMain: Bool, entropy: NonEmptyMax32Bytes, hostInfo: HostInfo) throws -> PrivateHierarchicalDeterministicFactorSource {
	try FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_babylon(
			FfiConverterBool.lower(isMain),
			FfiConverterTypeNonEmptyMax32Bytes.lower(entropy),
			FfiConverterTypeHostInfo.lower(hostInfo), $0
		)
	})
}

public func newPrivateHdFactorSourceBabylonFromMnemonicWithPassphrase(isMain: Bool, mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> PrivateHierarchicalDeterministicFactorSource {
	try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_babylon_from_mnemonic_with_passphrase(
			FfiConverterBool.lower(isMain),
			FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
			FfiConverterTypeHostInfo.lower(hostInfo), $0
		)
	})
}

public func newPrivateHdFactorSourceOlympiaFromMnemonicWithPassphrase(mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> PrivateHierarchicalDeterministicFactorSource {
	try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_olympia_from_mnemonic_with_passphrase(
			FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
			FfiConverterTypeHostInfo.lower(hostInfo), $0
		)
	})
}

public func newPrivateHdFactorSourceSample() -> PrivateHierarchicalDeterministicFactorSource {
	try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_sample($0
		)
	})
}

public func newPrivateHdFactorSourceSampleOther() -> PrivateHierarchicalDeterministicFactorSource {
	try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_sample_other($0
		)
	})
}

/**
 * # Panics
 * Panics if `device_factor_source` is not a main BDFS.
 */
public func newProfile(deviceFactorSource: DeviceFactorSource, hostId: HostId, hostInfo: HostInfo) -> Profile {
	try! FfiConverterTypeProfile.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_profile(
			FfiConverterTypeDeviceFactorSource.lower(deviceFactorSource),
			FfiConverterTypeHostId.lower(hostId),
			FfiConverterTypeHostInfo.lower(hostInfo), $0
		)
	})
}

public func newProfileFileContentsSample() -> ProfileFileContents {
	try! FfiConverterTypeProfileFileContents.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_profile_file_contents_sample($0
		)
	})
}

public func newProfileFileContentsSampleOther() -> ProfileFileContents {
	try! FfiConverterTypeProfileFileContents.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_profile_file_contents_sample_other($0
		)
	})
}

public func newProfileFromEncryptionBytes(jsonString: String, decryptionPassword: String) throws -> Profile {
	try FfiConverterTypeProfile.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_profile_from_encryption_bytes(
			FfiConverterString.lower(jsonString),
			FfiConverterString.lower(decryptionPassword), $0
		)
	})
}

public func newProfileFromJsonString(jsonStr: String) throws -> Profile {
	try FfiConverterTypeProfile.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_profile_from_json_string(
			FfiConverterString.lower(jsonStr), $0
		)
	})
}

public func newProfileIdSample() -> ProfileId {
	try! FfiConverterTypeProfileID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_profile_id_sample($0
		)
	})
}

public func newProfileIdSampleOther() -> ProfileId {
	try! FfiConverterTypeProfileID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_profile_id_sample_other($0
		)
	})
}

public func newProfileNetworkSample() -> ProfileNetwork {
	try! FfiConverterTypeProfileNetwork.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_profile_network_sample($0
		)
	})
}

public func newProfileNetworkSampleOther() -> ProfileNetwork {
	try! FfiConverterTypeProfileNetwork.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_profile_network_sample_other($0
		)
	})
}

public func newProfileNetworksSample() -> [ProfileNetwork] {
	try! FfiConverterSequenceTypeProfileNetwork.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_profile_networks_sample($0
		)
	})
}

public func newProfileNetworksSampleOther() -> [ProfileNetwork] {
	try! FfiConverterSequenceTypeProfileNetwork.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_profile_networks_sample_other($0
		)
	})
}

public func newProfileSample() -> Profile {
	try! FfiConverterTypeProfile.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_profile_sample($0
		)
	})
}

public func newProfileSampleOther() -> Profile {
	try! FfiConverterTypeProfile.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_profile_sample_other($0
		)
	})
}

public func newProfileWithMnemonic(mnemonic: Mnemonic, hostId: HostId, hostInfo: HostInfo) -> Profile {
	try! FfiConverterTypeProfile.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_profile_with_mnemonic(
			FfiConverterTypeMnemonic.lower(mnemonic),
			FfiConverterTypeHostId.lower(hostId),
			FfiConverterTypeHostInfo.lower(hostInfo), $0
		)
	})
}

/**
 * Tries to create a PublicKey from the bytes
 */
public func newPublicKeyFromBytes(bagOfBytes: BagOfBytes) throws -> PublicKey {
	try FfiConverterTypePublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_public_key_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
		)
	})
}

/**
 * Tries to create a PublicKey from the hex string
 */
public func newPublicKeyFromHex(hex: String) throws -> PublicKey {
	try FfiConverterTypePublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_public_key_from_hex(
			FfiConverterString.lower(hex), $0
		)
	})
}

public func newPublicKeyHashOfKey(publicKey: PublicKey) -> PublicKeyHash {
	try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_public_key_hash_of_key(
			FfiConverterTypePublicKey.lower(publicKey), $0
		)
	})
}

public func newPublicKeyHashSample() -> PublicKeyHash {
	try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_public_key_hash_sample($0
		)
	})
}

public func newPublicKeyHashSampleOther() -> PublicKeyHash {
	try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_public_key_hash_sample_other($0
		)
	})
}

public func newPublicKeySample() -> PublicKey {
	try! FfiConverterTypePublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_public_key_sample($0
		)
	})
}

public func newPublicKeySampleOther() -> PublicKey {
	try! FfiConverterTypePublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_public_key_sample_other($0
		)
	})
}

public func newRadixConnectMobileSessionRequestFromJsonBytes(jsonBytes: BagOfBytes) throws -> RadixConnectMobileSessionRequest {
	try FfiConverterTypeRadixConnectMobileSessionRequest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_radix_connect_mobile_session_request_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newRadixConnectMobileSessionRequestSample() -> RadixConnectMobileSessionRequest {
	try! FfiConverterTypeRadixConnectMobileSessionRequest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_radix_connect_mobile_session_request_sample($0
		)
	})
}

public func newRadixConnectMobileSessionRequestSampleOther() -> RadixConnectMobileSessionRequest {
	try! FfiConverterTypeRadixConnectMobileSessionRequest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_radix_connect_mobile_session_request_sample_other($0
		)
	})
}

public func newRadixConnectPassword(bytes: Exactly32Bytes) -> RadixConnectPassword {
	try! FfiConverterTypeRadixConnectPassword.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_radix_connect_password(
			FfiConverterTypeExactly32Bytes.lower(bytes), $0
		)
	})
}

public func newRadixConnectPasswordFromJsonString(jsonString: String) throws -> RadixConnectPassword {
	try FfiConverterTypeRadixConnectPassword.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_radix_connect_password_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newRadixConnectPasswordSample() -> RadixConnectPassword {
	try! FfiConverterTypeRadixConnectPassword.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_radix_connect_password_sample($0
		)
	})
}

public func newRadixConnectPasswordSampleOther() -> RadixConnectPassword {
	try! FfiConverterTypeRadixConnectPassword.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_radix_connect_password_sample_other($0
		)
	})
}

public func newRadixConnectPurposeFromJsonString(jsonString: String) throws -> RadixConnectPurpose {
	try FfiConverterTypeRadixConnectPurpose.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_radix_connect_purpose_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newRadixConnectPurposeFromString(string: String) -> RadixConnectPurpose {
	try! FfiConverterTypeRadixConnectPurpose.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_radix_connect_purpose_from_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newRadixConnectPurposeSample() -> RadixConnectPurpose {
	try! FfiConverterTypeRadixConnectPurpose.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_radix_connect_purpose_sample($0
		)
	})
}

public func newRadixConnectPurposeSampleOther() -> RadixConnectPurpose {
	try! FfiConverterTypeRadixConnectPurpose.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_radix_connect_purpose_sample_other($0
		)
	})
}

public func newReferencesToAuthorizedPersonasSample() -> [AuthorizedPersonaSimple] {
	try! FfiConverterSequenceTypeAuthorizedPersonaSimple.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_references_to_authorized_personas_sample($0
		)
	})
}

public func newReferencesToAuthorizedPersonasSampleOther() -> [AuthorizedPersonaSimple] {
	try! FfiConverterSequenceTypeAuthorizedPersonaSimple.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_references_to_authorized_personas_sample_other($0
		)
	})
}

public func newRequestedQuantityFromJsonBytes(jsonBytes: BagOfBytes) throws -> RequestedQuantity {
	try FfiConverterTypeRequestedQuantity.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_requested_quantity_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newRequestedQuantitySample() -> RequestedQuantity {
	try! FfiConverterTypeRequestedQuantity.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_requested_quantity_sample($0
		)
	})
}

public func newRequestedQuantitySampleOther() -> RequestedQuantity {
	try! FfiConverterTypeRequestedQuantity.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_requested_quantity_sample_other($0
		)
	})
}

public func newResourceAddress(bech32: String) throws -> ResourceAddress {
	try FfiConverterTypeResourceAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_resource_address(
			FfiConverterString.lower(bech32), $0
		)
	})
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newResourceAddressRandom(networkId: NetworkId) -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_address_random(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func newResourceAddressSampleMainnetCandy() -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_address_sample_mainnet_candy($0
		)
	})
}

public func newResourceAddressSampleMainnetNftGcMembership() -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_address_sample_mainnet_nft_gc_membership($0
		)
	})
}

public func newResourceAddressSampleMainnetXrd() -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_address_sample_mainnet_xrd($0
		)
	})
}

public func newResourceAddressSampleStokenetCandy() -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_address_sample_stokenet_candy($0
		)
	})
}

public func newResourceAddressSampleStokenetGcTokens() -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_address_sample_stokenet_gc_tokens($0
		)
	})
}

public func newResourceAddressSampleStokenetGum() -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_address_sample_stokenet_gum($0
		)
	})
}

public func newResourceAddressSampleStokenetXrd() -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_address_sample_stokenet_xrd($0
		)
	})
}

public func newResourceIndicatorSample() -> ResourceIndicator {
	try! FfiConverterTypeResourceIndicator.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_indicator_sample($0
		)
	})
}

public func newResourceIndicatorSampleOther() -> ResourceIndicator {
	try! FfiConverterTypeResourceIndicator.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_indicator_sample_other($0
		)
	})
}

public func newResourceOrNonFungibleSample() -> ResourceOrNonFungible {
	try! FfiConverterTypeResourceOrNonFungible.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_or_non_fungible_sample($0
		)
	})
}

public func newResourceOrNonFungibleSampleOther() -> ResourceOrNonFungible {
	try! FfiConverterTypeResourceOrNonFungible.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_or_non_fungible_sample_other($0
		)
	})
}

public func newResourcePreferencesSample() -> [ResourceAppPreference] {
	try! FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_preferences_sample($0
		)
	})
}

public func newResourcePreferencesSampleOther() -> [ResourceAppPreference] {
	try! FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_preferences_sample_other($0
		)
	})
}

public func newResourceSpecifierSample() -> ResourceSpecifier {
	try! FfiConverterTypeResourceSpecifier.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_specifier_sample($0
		)
	})
}

public func newResourceSpecifierSampleOther() -> ResourceSpecifier {
	try! FfiConverterTypeResourceSpecifier.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_resource_specifier_sample_other($0
		)
	})
}

public func newSLIP10CurveFromJsonString(jsonString: String) throws -> Slip10Curve {
	try FfiConverterTypeSLIP10Curve.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_s_l_i_p10_curve_from_json_string(
			FfiConverterString.lower(jsonString), $0
		)
	})
}

public func newSargonBuildInformationSample() -> SargonBuildInformation {
	try! FfiConverterTypeSargonBuildInformation.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_sargon_build_information_sample($0
		)
	})
}

public func newSargonBuildInformationSampleOther() -> SargonBuildInformation {
	try! FfiConverterTypeSargonBuildInformation.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_sargon_build_information_sample_other($0
		)
	})
}

/**
 * Constructs `Gateways` with `current` set as active Gateway.
 */
public func newSavedGateways(current: Gateway) -> SavedGateways {
	try! FfiConverterTypeSavedGateways.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_saved_gateways(
			FfiConverterTypeGateway.lower(current), $0
		)
	})
}

public func newSavedGatewaysChangingCurrent(to: Gateway, gateways: SavedGateways) throws -> SavedGateways {
	try FfiConverterTypeSavedGateways.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_saved_gateways_changing_current(
			FfiConverterTypeGateway.lower(to),
			FfiConverterTypeSavedGateways.lower(gateways), $0
		)
	})
}

/**
 * Constructs `Gateways` with default preset values.
 */
public func newSavedGatewaysDefault() -> SavedGateways {
	try! FfiConverterTypeSavedGateways.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_saved_gateways_default($0
		)
	})
}

/**
 * A sample value useful for tests and previews.
 */
public func newSavedGatewaysSample() -> SavedGateways {
	try! FfiConverterTypeSavedGateways.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_saved_gateways_sample($0
		)
	})
}

/**
 * A sample value useful for tests and previews.
 */
public func newSavedGatewaysSampleOther() -> SavedGateways {
	try! FfiConverterTypeSavedGateways.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_saved_gateways_sample_other($0
		)
	})
}

/**
 * Creates a Secp256k1PublicKey from either compressed form (33 bytes) or
 * from uncompressed form (65 bytes).
 */
public func newSecp256k1PublicKeyFromBytes(bytes: BagOfBytes) throws -> Secp256k1PublicKey {
	try FfiConverterTypeSecp256k1PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_secp256k1_public_key_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newSecp256k1PublicKeyFromHex(hex: String) throws -> Secp256k1PublicKey {
	try FfiConverterTypeSecp256k1PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_secp256k1_public_key_from_hex(
			FfiConverterString.lower(hex), $0
		)
	})
}

public func newSecp256k1PublicKeySample() -> Secp256k1PublicKey {
	try! FfiConverterTypeSecp256k1PublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_secp256k1_public_key_sample($0
		)
	})
}

public func newSecp256k1PublicKeySampleOther() -> Secp256k1PublicKey {
	try! FfiConverterTypeSecp256k1PublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_secp256k1_public_key_sample_other($0
		)
	})
}

public func newSecp256k1SignatureFromBytes(bytes: BagOfBytes) throws -> Secp256k1Signature {
	try FfiConverterTypeSecp256k1Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_secp256k1_signature_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newSecp256k1SignatureFromExactly65Bytes(bytes: Exactly65Bytes) -> Secp256k1Signature {
	try! FfiConverterTypeSecp256k1Signature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_secp256k1_signature_from_exactly_65_bytes(
			FfiConverterTypeExactly65Bytes.lower(bytes), $0
		)
	})
}

public func newSecp256k1SignatureSample() -> Secp256k1Signature {
	try! FfiConverterTypeSecp256k1Signature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_secp256k1_signature_sample($0
		)
	})
}

public func newSecp256k1SignatureSampleOther() -> Secp256k1Signature {
	try! FfiConverterTypeSecp256k1Signature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_secp256k1_signature_sample_other($0
		)
	})
}

public func newSecurified(u30: U30) -> SecurifiedU30 {
	try! FfiConverterTypeSecurifiedU30.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_securified(
			FfiConverterTypeU30.lower(u30), $0
		)
	})
}

public func newSecurifiedFromGlobalKeySpace(value: UInt32) throws -> SecurifiedU30 {
	try FfiConverterTypeSecurifiedU30.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_securified_from_global_key_space(
			FfiConverterUInt32.lower(value), $0
		)
	})
}

public func newSecurifiedFromLocalKeySpace(value: UInt32) throws -> SecurifiedU30 {
	try FfiConverterTypeSecurifiedU30.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_securified_from_local_key_space(
			FfiConverterUInt32.lower(value), $0
		)
	})
}

public func newSecurifiedSample() -> SecurifiedU30 {
	try! FfiConverterTypeSecurifiedU30.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_securified_sample($0
		)
	})
}

public func newSecurifiedSampleOther() -> SecurifiedU30 {
	try! FfiConverterTypeSecurifiedU30.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_securified_sample_other($0
		)
	})
}

public func newSecurityNOTPRODUCTIONREADYQuestionsAndAnswersSample() -> [SecurityNotProductionReadyQuestionAndAnswer] {
	try! FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_and_answers_sample($0
		)
	})
}

public func newSecurityNOTPRODUCTIONREADYQuestionsAndAnswersSampleOther() -> [SecurityNotProductionReadyQuestionAndAnswer] {
	try! FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_and_answers_sample_other($0
		)
	})
}

public func newSecurityQuestionsFactorSourceByEncryptingMnemonic(mnemonic: Mnemonic, with: [SecurityNotProductionReadyQuestionAndAnswer]) throws -> SecurityQuestionsNotProductionReadyFactorSource {
	try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_security_questions_factor_source_by_encrypting_mnemonic(
			FfiConverterTypeMnemonic.lower(mnemonic),
			FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lower(with), $0
		)
	})
}

public func newSecurityQuestionsFactorSourceSample() -> SecurityQuestionsNotProductionReadyFactorSource {
	try! FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_questions_factor_source_sample($0
		)
	})
}

public func newSecurityQuestionsFactorSourceSampleOther() -> SecurityQuestionsNotProductionReadyFactorSource {
	try! FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_questions_factor_source_sample_other($0
		)
	})
}

public func newSecurityStructureMetadataNamed(name: DisplayName) -> SecurityStructureMetadata {
	try! FfiConverterTypeSecurityStructureMetadata.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_structure_metadata_named(
			FfiConverterTypeDisplayName.lower(name), $0
		)
	})
}

public func newSecurityStructureMetadataSample() -> SecurityStructureMetadata {
	try! FfiConverterTypeSecurityStructureMetadata.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_structure_metadata_sample($0
		)
	})
}

public func newSecurityStructureMetadataSampleOther() -> SecurityStructureMetadata {
	try! FfiConverterTypeSecurityStructureMetadata.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_structure_metadata_sample_other($0
		)
	})
}

public func newSecurityStructureOfFactorSourceIdsSample() -> SecurityStructureOfFactorSourceIDs {
	try! FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_source_ids_sample($0
		)
	})
}

public func newSecurityStructureOfFactorSourceIdsSampleOther() -> SecurityStructureOfFactorSourceIDs {
	try! FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_source_ids_sample_other($0
		)
	})
}

public func newSecurityStructureOfFactorSourcesAutoInDays(metadata: SecurityStructureMetadata, numberOfDaysUntilAutoConfirmation: UInt16, matrixOfFactors: MatrixOfFactorSources) -> SecurityStructureOfFactorSources {
	try! FfiConverterTypeSecurityStructureOfFactorSources.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_sources_auto_in_days(
			FfiConverterTypeSecurityStructureMetadata.lower(metadata),
			FfiConverterUInt16.lower(numberOfDaysUntilAutoConfirmation),
			FfiConverterTypeMatrixOfFactorSources.lower(matrixOfFactors), $0
		)
	})
}

public func newSecurityStructureOfFactorSourcesSample() -> SecurityStructureOfFactorSources {
	try! FfiConverterTypeSecurityStructureOfFactorSources.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_sources_sample($0
		)
	})
}

public func newSecurityStructureOfFactorSourcesSampleOther() -> SecurityStructureOfFactorSources {
	try! FfiConverterTypeSecurityStructureOfFactorSources.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_sources_sample_other($0
		)
	})
}

public func newSecurityStructuresOfFactorSourceIDsSample() -> [SecurityStructureOfFactorSourceIDs] {
	try! FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_structures_of_factor_source_i_ds_sample($0
		)
	})
}

public func newSecurityStructuresOfFactorSourceIDsSampleOther() -> [SecurityStructureOfFactorSourceIDs] {
	try! FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_security_structures_of_factor_source_i_ds_sample_other($0
		)
	})
}

public func newSharedPersonaDataSample() -> SharedPersonaData {
	try! FfiConverterTypeSharedPersonaData.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_shared_persona_data_sample($0
		)
	})
}

public func newSharedPersonaDataSampleOther() -> SharedPersonaData {
	try! FfiConverterTypeSharedPersonaData.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_shared_persona_data_sample_other($0
		)
	})
}

public func newSignatureFromBytes(bytes: BagOfBytes) throws -> Signature {
	try FfiConverterTypeSignature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_signature_from_bytes(
			FfiConverterTypeBagOfBytes.lower(bytes), $0
		)
	})
}

public func newSignatureSample() -> Signature {
	try! FfiConverterTypeSignature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_signature_sample($0
		)
	})
}

public func newSignatureSampleOther() -> Signature {
	try! FfiConverterTypeSignature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_signature_sample_other($0
		)
	})
}

public func newSignatureWithPublicKeySample() -> SignatureWithPublicKey {
	try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_signature_with_public_key_sample($0
		)
	})
}

public func newSignatureWithPublicKeySampleOther() -> SignatureWithPublicKey {
	try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_signature_with_public_key_sample_other($0
		)
	})
}

public func newSignedIntentHashSample() -> SignedTransactionIntentHash {
	try! FfiConverterTypeSignedTransactionIntentHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_signed_intent_hash_sample($0
		)
	})
}

public func newSignedIntentHashSampleOther() -> SignedTransactionIntentHash {
	try! FfiConverterTypeSignedTransactionIntentHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_signed_intent_hash_sample_other($0
		)
	})
}

public func newSignedIntentSample() -> SignedIntent {
	try! FfiConverterTypeSignedIntent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_signed_intent_sample($0
		)
	})
}

public func newSignedIntentSampleOther() -> SignedIntent {
	try! FfiConverterTypeSignedIntent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_signed_intent_sample_other($0
		)
	})
}

public func newSignedTransactionIntentHashFromString(string: String) throws -> SignedTransactionIntentHash {
	try FfiConverterTypeSignedTransactionIntentHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_signed_transaction_intent_hash_from_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newSlip10CurveFromString(curve: String) throws -> Slip10Curve {
	try FfiConverterTypeSLIP10Curve.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_slip10_curve_from_string(
			FfiConverterString.lower(curve), $0
		)
	})
}

public func newStakeClaimSample() -> StakeClaim {
	try! FfiConverterTypeStakeClaim.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_stake_claim_sample($0
		)
	})
}

public func newStakeClaimSampleOther() -> StakeClaim {
	try! FfiConverterTypeStakeClaim.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_stake_claim_sample_other($0
		)
	})
}

public func newSubintent(header: IntentHeaderV2, manifest: SubintentManifest, message: MessageV2) throws -> Subintent {
	try FfiConverterTypeSubintent.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_subintent(
			FfiConverterTypeIntentHeaderV2.lower(header),
			FfiConverterTypeSubintentManifest.lower(manifest),
			FfiConverterTypeMessageV2.lower(message), $0
		)
	})
}

public func newSubintentHashFromString(string: String) throws -> SubintentHash {
	try FfiConverterTypeSubintentHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_subintent_hash_from_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newSubintentHashSample() -> SubintentHash {
	try! FfiConverterTypeSubintentHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_subintent_hash_sample($0
		)
	})
}

public func newSubintentHashSampleOther() -> SubintentHash {
	try! FfiConverterTypeSubintentHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_subintent_hash_sample_other($0
		)
	})
}

public func newSubintentManifestSample() -> SubintentManifest {
	try! FfiConverterTypeSubintentManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_subintent_manifest_sample($0
		)
	})
}

public func newSubintentManifestSampleOther() -> SubintentManifest {
	try! FfiConverterTypeSubintentManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_subintent_manifest_sample_other($0
		)
	})
}

public func newSubintentSample() -> Subintent {
	try! FfiConverterTypeSubintent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_subintent_sample($0
		)
	})
}

public func newSubintentSampleOther() -> Subintent {
	try! FfiConverterTypeSubintent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_subintent_sample_other($0
		)
	})
}

public func newSupportedCurvesSample() -> [Slip10Curve] {
	try! FfiConverterSequenceTypeSLIP10Curve.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_supported_curves_sample($0
		)
	})
}

public func newSupportedCurvesSampleOther() -> [Slip10Curve] {
	try! FfiConverterSequenceTypeSLIP10Curve.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_supported_curves_sample_other($0
		)
	})
}

public func newThirdPartyDepositsDefault() -> ThirdPartyDeposits {
	try! FfiConverterTypeThirdPartyDeposits.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_third_party_deposits_default($0
		)
	})
}

public func newThirdPartyDepositsSample() -> ThirdPartyDeposits {
	try! FfiConverterTypeThirdPartyDeposits.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_third_party_deposits_sample($0
		)
	})
}

public func newThirdPartyDepositsSampleOther() -> ThirdPartyDeposits {
	try! FfiConverterTypeThirdPartyDeposits.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_third_party_deposits_sample_other($0
		)
	})
}

public func newTransactionHeaderSample() -> TransactionHeader {
	try! FfiConverterTypeTransactionHeader.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_transaction_header_sample($0
		)
	})
}

public func newTransactionHeaderSampleOther() -> TransactionHeader {
	try! FfiConverterTypeTransactionHeader.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_transaction_header_sample_other($0
		)
	})
}

public func newTransactionIntentHashFromString(string: String) throws -> TransactionIntentHash {
	try FfiConverterTypeTransactionIntentHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_transaction_intent_hash_from_string(
			FfiConverterString.lower(string), $0
		)
	})
}

public func newTransactionIntentHashSample() -> TransactionIntentHash {
	try! FfiConverterTypeTransactionIntentHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_transaction_intent_hash_sample($0
		)
	})
}

public func newTransactionIntentHashSampleOther() -> TransactionIntentHash {
	try! FfiConverterTypeTransactionIntentHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_transaction_intent_hash_sample_other($0
		)
	})
}

public func newTransactionIntentSample() -> TransactionIntent {
	try! FfiConverterTypeTransactionIntent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_transaction_intent_sample($0
		)
	})
}

public func newTransactionIntentSampleOther() -> TransactionIntent {
	try! FfiConverterTypeTransactionIntent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_transaction_intent_sample_other($0
		)
	})
}

public func newTransactionManifestFromInstructionsStringAndBlobs(instructionsString: String, networkId: NetworkId, blobs: Blobs) throws -> TransactionManifest {
	try FfiConverterTypeTransactionManifest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_transaction_manifest_from_instructions_string_and_blobs(
			FfiConverterString.lower(instructionsString),
			FfiConverterTypeNetworkID.lower(networkId),
			FfiConverterTypeBlobs.lower(blobs), $0
		)
	})
}

public func newTransactionManifestFromUnvalidatedTransactionManifest(unvalidatedTransactionManifest: UnvalidatedTransactionManifest, networkId: NetworkId) throws -> TransactionManifest {
	try FfiConverterTypeTransactionManifest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_transaction_manifest_from_unvalidated_transaction_manifest(
			FfiConverterTypeUnvalidatedTransactionManifest.lower(unvalidatedTransactionManifest),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func newTransactionManifestSample() -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_transaction_manifest_sample($0
		)
	})
}

public func newTransactionManifestSampleOther() -> TransactionManifest {
	try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_transaction_manifest_sample_other($0
		)
	})
}

public func newTransactionManifestV2Sample() -> TransactionManifestV2 {
	try! FfiConverterTypeTransactionManifestV2.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_transaction_manifest_v2_sample($0
		)
	})
}

public func newTransactionManifestV2SampleOther() -> TransactionManifestV2 {
	try! FfiConverterTypeTransactionManifestV2.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_transaction_manifest_v2_sample_other($0
		)
	})
}

public func newTrustedContactFactorSourceContactSample() -> TrustedContactFactorSourceContact {
	try! FfiConverterTypeTrustedContactFactorSourceContact.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_trusted_contact_factor_source_contact_sample($0
		)
	})
}

public func newTrustedContactFactorSourceContactSampleOther() -> TrustedContactFactorSourceContact {
	try! FfiConverterTypeTrustedContactFactorSourceContact.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_trusted_contact_factor_source_contact_sample_other($0
		)
	})
}

public func newTrustedContactFactorSourceFromAddressAndContact(accountAddress: AccountAddress, contact: TrustedContactFactorSourceContact) -> TrustedContactFactorSource {
	try! FfiConverterTypeTrustedContactFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_trusted_contact_factor_source_from_address_and_contact(
			FfiConverterTypeAccountAddress.lower(accountAddress),
			FfiConverterTypeTrustedContactFactorSourceContact.lower(contact), $0
		)
	})
}

public func newTrustedContactFactorSourceSample() -> TrustedContactFactorSource {
	try! FfiConverterTypeTrustedContactFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_trusted_contact_factor_source_sample($0
		)
	})
}

public func newTrustedContactFactorSourceSampleOther() -> TrustedContactFactorSource {
	try! FfiConverterTypeTrustedContactFactorSource.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_trusted_contact_factor_source_sample_other($0
		)
	})
}

public func newU30(value: UInt32) throws -> U30 {
	try FfiConverterTypeU30.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_u30(
			FfiConverterUInt32.lower(value), $0
		)
	})
}

public func newU30Sample() -> U30 {
	try! FfiConverterTypeU30.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_u30_sample($0
		)
	})
}

public func newU30SampleOther() -> U30 {
	try! FfiConverterTypeU30.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_u30_sample_other($0
		)
	})
}

public func newU31(value: UInt32) throws -> U31 {
	try FfiConverterTypeU31.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_u31(
			FfiConverterUInt32.lower(value), $0
		)
	})
}

public func newU31Sample() -> U31 {
	try! FfiConverterTypeU31.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_u31_sample($0
		)
	})
}

public func newU31SampleOther() -> U31 {
	try! FfiConverterTypeU31.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_u31_sample_other($0
		)
	})
}

public func newUnhardened(u31: U31) -> Unhardened {
	try! FfiConverterTypeUnhardened.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unhardened(
			FfiConverterTypeU31.lower(u31), $0
		)
	})
}

public func newUnhardenedFromGlobalKeySpace(value: UInt32) throws -> Unhardened {
	try FfiConverterTypeUnhardened.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_unhardened_from_global_key_space(
			FfiConverterUInt32.lower(value), $0
		)
	})
}

public func newUnhardenedFromLocalKeySpace(value: UInt32) throws -> Unhardened {
	try FfiConverterTypeUnhardened.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_unhardened_from_local_key_space(
			FfiConverterUInt32.lower(value), $0
		)
	})
}

public func newUnhardenedSample() -> Unhardened {
	try! FfiConverterTypeUnhardened.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unhardened_sample($0
		)
	})
}

public func newUnhardenedSampleOther() -> Unhardened {
	try! FfiConverterTypeUnhardened.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unhardened_sample_other($0
		)
	})
}

public func newUnsecuredEntityControlSample() -> UnsecuredEntityControl {
	try! FfiConverterTypeUnsecuredEntityControl.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unsecured_entity_control_sample($0
		)
	})
}

public func newUnsecuredEntityControlSampleOther() -> UnsecuredEntityControl {
	try! FfiConverterTypeUnsecuredEntityControl.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unsecured_entity_control_sample_other($0
		)
	})
}

public func newUnsecurifiedHardened(u30: U30) -> UnsecurifiedHardened {
	try! FfiConverterTypeUnsecurifiedHardened.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened(
			FfiConverterTypeU30.lower(u30), $0
		)
	})
}

public func newUnsecurifiedHardenedFromGlobalKeySpace(value: UInt32) throws -> UnsecurifiedHardened {
	try FfiConverterTypeUnsecurifiedHardened.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened_from_global_key_space(
			FfiConverterUInt32.lower(value), $0
		)
	})
}

public func newUnsecurifiedHardenedFromLocalKeySpace(value: UInt32) throws -> UnsecurifiedHardened {
	try FfiConverterTypeUnsecurifiedHardened.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened_from_local_key_space(
			FfiConverterUInt32.lower(value), $0
		)
	})
}

public func newUnsecurifiedHardenedSample() -> UnsecurifiedHardened {
	try! FfiConverterTypeUnsecurifiedHardened.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened_sample($0
		)
	})
}

public func newUnsecurifiedHardenedSampleOther() -> UnsecurifiedHardened {
	try! FfiConverterTypeUnsecurifiedHardened.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened_sample_other($0
		)
	})
}

public func newUnsecurifiedSample() -> Unsecurified {
	try! FfiConverterTypeUnsecurified.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unsecurified_sample($0
		)
	})
}

public func newUnsecurifiedSampleOther() -> Unsecurified {
	try! FfiConverterTypeUnsecurified.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unsecurified_sample_other($0
		)
	})
}

public func newUnvalidatedSubintentManifestFromSubintentManifest(subintentManifest: SubintentManifest) -> UnvalidatedSubintentManifest {
	try! FfiConverterTypeUnvalidatedSubintentManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unvalidated_subintent_manifest_from_subintent_manifest(
			FfiConverterTypeSubintentManifest.lower(subintentManifest), $0
		)
	})
}

public func newUnvalidatedSubintentManifestSample() -> UnvalidatedSubintentManifest {
	try! FfiConverterTypeUnvalidatedSubintentManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unvalidated_subintent_manifest_sample($0
		)
	})
}

public func newUnvalidatedSubintentManifestSampleOther() -> UnvalidatedSubintentManifest {
	try! FfiConverterTypeUnvalidatedSubintentManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unvalidated_subintent_manifest_sample_other($0
		)
	})
}

public func newUnvalidatedTransactionManifestFromTransactionManifest(transactionManifest: TransactionManifest) -> UnvalidatedTransactionManifest {
	try! FfiConverterTypeUnvalidatedTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unvalidated_transaction_manifest_from_transaction_manifest(
			FfiConverterTypeTransactionManifest.lower(transactionManifest), $0
		)
	})
}

public func newUnvalidatedTransactionManifestSample() -> UnvalidatedTransactionManifest {
	try! FfiConverterTypeUnvalidatedTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unvalidated_transaction_manifest_sample($0
		)
	})
}

public func newUnvalidatedTransactionManifestSampleOther() -> UnvalidatedTransactionManifest {
	try! FfiConverterTypeUnvalidatedTransactionManifest.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_unvalidated_transaction_manifest_sample_other($0
		)
	})
}

public func newValidatorAddress(bech32: String) throws -> ValidatorAddress {
	try FfiConverterTypeValidatorAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_validator_address(
			FfiConverterString.lower(bech32), $0
		)
	})
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newValidatorAddressRandom(networkId: NetworkId) -> ValidatorAddress {
	try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_validator_address_random(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func newValidatorAddressSampleMainnet() -> ValidatorAddress {
	try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_validator_address_sample_mainnet($0
		)
	})
}

public func newValidatorAddressSampleMainnetOther() -> ValidatorAddress {
	try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_validator_address_sample_mainnet_other($0
		)
	})
}

public func newValidatorAddressSampleStokenet() -> ValidatorAddress {
	try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_validator_address_sample_stokenet($0
		)
	})
}

public func newValidatorAddressSampleStokenetOther() -> ValidatorAddress {
	try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_validator_address_sample_stokenet_other($0
		)
	})
}

public func newVaultAddress(bech32: String) throws -> VaultAddress {
	try FfiConverterTypeVaultAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_vault_address(
			FfiConverterString.lower(bech32), $0
		)
	})
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newVaultAddressRandom(networkId: NetworkId) -> VaultAddress {
	try! FfiConverterTypeVaultAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_vault_address_random(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func newVaultAddressSampleMainnetFungible() -> VaultAddress {
	try! FfiConverterTypeVaultAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_vault_address_sample_mainnet_fungible($0
		)
	})
}

public func newVaultAddressSampleMainnetNonFungible() -> VaultAddress {
	try! FfiConverterTypeVaultAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_vault_address_sample_mainnet_non_fungible($0
		)
	})
}

public func newVaultAddressSampleStokenetFungible() -> VaultAddress {
	try! FfiConverterTypeVaultAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_vault_address_sample_stokenet_fungible($0
		)
	})
}

public func newVaultAddressSampleStokenetNonFungible() -> VaultAddress {
	try! FfiConverterTypeVaultAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_vault_address_sample_stokenet_non_fungible($0
		)
	})
}

public func newVectorImageTypeSample() -> VectorImageType {
	try! FfiConverterTypeVectorImageType.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_vector_image_type_sample($0
		)
	})
}

public func newVectorImageTypeSampleOther() -> VectorImageType {
	try! FfiConverterTypeVectorImageType.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_vector_image_type_sample_other($0
		)
	})
}

public func newWalletInteractionVersionCurrent() -> WalletInteractionVersion {
	try! FfiConverterTypeWalletInteractionVersion.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_wallet_interaction_version_current($0
		)
	})
}

public func newWalletInteractionWalletAccountFromJsonBytes(jsonBytes: BagOfBytes) throws -> WalletInteractionWalletAccount {
	try FfiConverterTypeWalletInteractionWalletAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_wallet_interaction_wallet_account_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newWalletInteractionWalletAccountSample() -> WalletInteractionWalletAccount {
	try! FfiConverterTypeWalletInteractionWalletAccount.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_wallet_interaction_wallet_account_sample($0
		)
	})
}

public func newWalletInteractionWalletAccountSampleOther() -> WalletInteractionWalletAccount {
	try! FfiConverterTypeWalletInteractionWalletAccount.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_wallet_interaction_wallet_account_sample_other($0
		)
	})
}

public func newWalletToDappInteractionPreAuthorizationResponseItems(signedSubintent: SignedSubintent) -> WalletToDappInteractionPreAuthorizationResponseItems {
	try! FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_pre_authorization_response_items(
			FfiConverterTypeSignedSubintent.lower(signedSubintent), $0
		)
	})
}

public func newWalletToDappInteractionResponseFromJsonBytes(jsonBytes: BagOfBytes) throws -> WalletToDappInteractionResponse {
	try FfiConverterTypeWalletToDappInteractionResponse.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_response_from_json_bytes(
			FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
		)
	})
}

public func newWalletToDappInteractionResponseSample() -> WalletToDappInteractionResponse {
	try! FfiConverterTypeWalletToDappInteractionResponse.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_response_sample($0
		)
	})
}

public func newWalletToDappInteractionResponseSampleOther() -> WalletToDappInteractionResponse {
	try! FfiConverterTypeWalletToDappInteractionResponse.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_response_sample_other($0
		)
	})
}

public func nonFungibleGlobalIdFormatted(globalId: NonFungibleGlobalId, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_non_fungible_global_id_formatted(
			FfiConverterTypeNonFungibleGlobalId.lower(globalId),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

public func nonFungibleGlobalIdToString(globalId: NonFungibleGlobalId) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_non_fungible_global_id_to_string(
			FfiConverterTypeNonFungibleGlobalId.lower(globalId), $0
		)
	})
}

public func nonFungibleLocalIdAsStr(id: NonFungibleLocalId) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_non_fungible_local_id_as_str(
			FfiConverterTypeNonFungibleLocalId.lower(id), $0
		)
	})
}

public func nonFungibleLocalIdFormatted(id: NonFungibleLocalId, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_non_fungible_local_id_formatted(
			FfiConverterTypeNonFungibleLocalId.lower(id),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

public func nonFungibleLocalIdToUserFacingString(id: NonFungibleLocalId) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_non_fungible_local_id_to_user_facing_string(
			FfiConverterTypeNonFungibleLocalId.lower(id), $0
		)
	})
}

/**
 * Returns the base address of this specialized address.
 */
public func nonFungibleResourceAddressAsResourceAddress(address: NonFungibleResourceAddress) -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_non_fungible_resource_address_as_resource_address(
			FfiConverterTypeNonFungibleResourceAddress.lower(address), $0
		)
	})
}

/**
 * Returns the bech32 encoding of this address
 */
public func nonFungibleResourceAddressBech32Address(address: NonFungibleResourceAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_non_fungible_resource_address_bech32_address(
			FfiConverterTypeNonFungibleResourceAddress.lower(address), $0
		)
	})
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func nonFungibleResourceAddressMapToNetwork(address: NonFungibleResourceAddress, networkId: NetworkId) -> NonFungibleResourceAddress {
	try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_non_fungible_resource_address_map_to_network(
			FfiConverterTypeNonFungibleResourceAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

/**
 * Returns the network id this address
 */
public func nonFungibleResourceAddressNetworkId(address: NonFungibleResourceAddress) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_non_fungible_resource_address_network_id(
			FfiConverterTypeNonFungibleResourceAddress.lower(address), $0
		)
	})
}

public func nonFungibleResourceIndicatorGetIds(indicator: NonFungibleResourceIndicator) -> [NonFungibleLocalId] {
	try! FfiConverterSequenceTypeNonFungibleLocalId.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_non_fungible_resource_indicator_get_ids(
			FfiConverterTypeNonFungibleResourceIndicator.lower(indicator), $0
		)
	})
}

public func nonceGetValue(nonce: Nonce) -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_nonce_get_value(
			FfiConverterTypeNonce.lower(nonce), $0
		)
	})
}

public func notarizedTransactionCompile(notarizedTransaction: NotarizedTransaction) -> CompiledNotarizedIntent {
	try! FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_notarized_transaction_compile(
			FfiConverterTypeNotarizedTransaction.lower(notarizedTransaction), $0
		)
	})
}

public func notarySignatureGetSignature(notarySignature: NotarySignature) -> Signature {
	try! FfiConverterTypeSignature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_notary_signature_get_signature(
			FfiConverterTypeNotarySignature.lower(notarySignature), $0
		)
	})
}

public func p2PLinkToJsonBytes(p2PLink: P2pLink) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_p2_p_link_to_json_bytes(
			FfiConverterTypeP2PLink.lower(p2PLink), $0
		)
	})
}

public func p2pLinkId(link: P2pLink) -> PublicKeyHash {
	try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_p2p_link_id(
			FfiConverterTypeP2PLink.lower(link), $0
		)
	})
}

public func p2pLinksToJsonBytes(p2pLinks: [P2pLink]) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_p2p_links_to_json_bytes(
			FfiConverterSequenceTypeP2PLink.lower(p2pLinks), $0
		)
	})
}

public func packageAddressBech32Address(address: PackageAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_package_address_bech32_address(
			FfiConverterTypePackageAddress.lower(address), $0
		)
	})
}

public func packageAddressFormatted(address: PackageAddress, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_package_address_formatted(
			FfiConverterTypePackageAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func packageAddressMapToNetwork(address: PackageAddress, networkId: NetworkId) -> PackageAddress {
	try! FfiConverterTypePackageAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_package_address_map_to_network(
			FfiConverterTypePackageAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func packageAddressNetworkId(address: PackageAddress) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_package_address_network_id(
			FfiConverterTypePackageAddress.lower(address), $0
		)
	})
}

public func personaDataEntryEmailAddressToJsonString(personaDataEntryEmailAddress: EmailAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_persona_data_entry_email_address_to_json_string(
			FfiConverterTypeEmailAddress.lower(personaDataEntryEmailAddress), $0
		)
	})
}

public func personaDataEntryNameToJsonBytes(personaDataEntryName: PersonaDataEntryName) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_persona_data_entry_name_to_json_bytes(
			FfiConverterTypePersonaDataEntryName.lower(personaDataEntryName), $0
		)
	})
}

public func personaDataEntryPhoneNumberToJsonString(personaDataEntryPhoneNumber: PersonaDataEntryPhoneNumber) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_persona_data_entry_phone_number_to_json_string(
			FfiConverterTypePersonaDataEntryPhoneNumber.lower(personaDataEntryPhoneNumber), $0
		)
	})
}

public func personaDataIdentifiedEmailAddressSample() -> PersonaDataIdentifiedEmailAddress {
	try! FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_persona_data_identified_email_address_sample($0
		)
	})
}

public func personaDataIdentifiedEmailAddressSampleOther() -> PersonaDataIdentifiedEmailAddress {
	try! FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_persona_data_identified_email_address_sample_other($0
		)
	})
}

public func personaDataIdentifiedNameSample() -> PersonaDataIdentifiedName {
	try! FfiConverterTypePersonaDataIdentifiedName.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_persona_data_identified_name_sample($0
		)
	})
}

public func personaDataIdentifiedNameSampleOther() -> PersonaDataIdentifiedName {
	try! FfiConverterTypePersonaDataIdentifiedName.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_persona_data_identified_name_sample_other($0
		)
	})
}

public func personaDataIdentifiedPhoneNumberSample() -> PersonaDataIdentifiedPhoneNumber {
	try! FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_persona_data_identified_phone_number_sample($0
		)
	})
}

public func personaDataIdentifiedPhoneNumberSampleOther() -> PersonaDataIdentifiedPhoneNumber {
	try! FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_persona_data_identified_phone_number_sample_other($0
		)
	})
}

public func poolAddressBech32Address(address: PoolAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_pool_address_bech32_address(
			FfiConverterTypePoolAddress.lower(address), $0
		)
	})
}

public func poolAddressFormatted(address: PoolAddress, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_pool_address_formatted(
			FfiConverterTypePoolAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

/**
 * Returns the kind of pool, either 1, 2 or Multi resources.
 */
public func poolAddressKind(address: PoolAddress) -> PoolKind {
	try! FfiConverterTypePoolKind.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_pool_address_kind(
			FfiConverterTypePoolAddress.lower(address), $0
		)
	})
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func poolAddressMapToNetwork(address: PoolAddress, networkId: NetworkId) -> PoolAddress {
	try! FfiConverterTypePoolAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_pool_address_map_to_network(
			FfiConverterTypePoolAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func poolAddressNetworkId(address: PoolAddress) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_pool_address_network_id(
			FfiConverterTypePoolAddress.lower(address), $0
		)
	})
}

public func profileAnalyzeContentsOfFile(contents: String) -> ProfileFileContents {
	try! FfiConverterTypeProfileFileContents.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_profile_analyze_contents_of_file(
			FfiConverterString.lower(contents), $0
		)
	})
}

public func profileEncryptWithPassword(profile: Profile, encryptionPassword: String) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_profile_encrypt_with_password(
			FfiConverterTypeProfile.lower(profile),
			FfiConverterString.lower(encryptionPassword), $0
		)
	})
}

public func profileNetworkDetailsForAuthorizedDapp(profileNetwork: ProfileNetwork, dapp: AuthorizedDapp) throws -> AuthorizedDappDetailed {
	try FfiConverterTypeAuthorizedDappDetailed.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_profile_network_details_for_authorized_dapp(
			FfiConverterTypeProfileNetwork.lower(profileNetwork),
			FfiConverterTypeAuthorizedDapp.lower(dapp), $0
		)
	})
}

public func profileToDebugString(profile: Profile) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_profile_to_debug_string(
			FfiConverterTypeProfile.lower(profile), $0
		)
	})
}

public func profileToJsonString(profile: Profile, prettyPrinted: Bool) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_profile_to_json_string(
			FfiConverterTypeProfile.lower(profile),
			FfiConverterBool.lower(prettyPrinted), $0
		)
	})
}

public func profileToString(profile: Profile) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_profile_to_string(
			FfiConverterTypeProfile.lower(profile), $0
		)
	})
}

/**
 * Verifies an Elliptic Curve signature over either Curve25519 or Secp256k1
 */
public func publicKeyIsValidSignatureForHash(publicKey: PublicKey, signature: Signature, hash: Hash) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_public_key_is_valid_signature_for_hash(
			FfiConverterTypePublicKey.lower(publicKey),
			FfiConverterTypeSignature.lower(signature),
			FfiConverterTypeHash.lower(hash), $0
		)
	})
}

public func publicKeyToBytes(publicKey: PublicKey) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_public_key_to_bytes(
			FfiConverterTypePublicKey.lower(publicKey), $0
		)
	})
}

public func publicKeyToHex(publicKey: PublicKey) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_public_key_to_hex(
			FfiConverterTypePublicKey.lower(publicKey), $0
		)
	})
}

public func radixConnectMobileSessionRequestToJsonBytes(radixConnectMobileSessionRequest: RadixConnectMobileSessionRequest) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_radix_connect_mobile_session_request_to_json_bytes(
			FfiConverterTypeRadixConnectMobileSessionRequest.lower(radixConnectMobileSessionRequest), $0
		)
	})
}

public func radixConnectPasswordMessageHash(password: RadixConnectPassword) -> Hash {
	try! FfiConverterTypeHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_radix_connect_password_message_hash(
			FfiConverterTypeRadixConnectPassword.lower(password), $0
		)
	})
}

public func radixConnectPasswordToJsonString(radixConnectPassword: RadixConnectPassword) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_radix_connect_password_to_json_string(
			FfiConverterTypeRadixConnectPassword.lower(radixConnectPassword), $0
		)
	})
}

public func radixConnectPurposeToJsonString(radixConnectPurpose: RadixConnectPurpose) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_radix_connect_purpose_to_json_string(
			FfiConverterTypeRadixConnectPurpose.lower(radixConnectPurpose), $0
		)
	})
}

/**
 * Checks `number_of_ids` can fulfill the [`RequestedQuantity`] (self), `number_of_ids` is
 * considered to be fulfilling the requested quantity:
 * * if: quantifier == ::Exactly && number_of_ids == quantity //  fulfills
 * * else if: quantifier == ::AtLeast && number_of_ids >= quantity //  fulfills
 * * else false //  does NOT fulfill
 */
public func requestedQuantityIsFulfilledByIds(requestedQuantity: RequestedQuantity, numberOfIds: UInt64) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_requested_quantity_is_fulfilled_by_ids(
			FfiConverterTypeRequestedQuantity.lower(requestedQuantity),
			FfiConverterUInt64.lower(numberOfIds), $0
		)
	})
}

public func requestedQuantityIsValid(requestedQuantity: RequestedQuantity) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_requested_quantity_is_valid(
			FfiConverterTypeRequestedQuantity.lower(requestedQuantity), $0
		)
	})
}

public func requestedQuantityToJsonBytes(requestedQuantity: RequestedQuantity) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_requested_quantity_to_json_bytes(
			FfiConverterTypeRequestedQuantity.lower(requestedQuantity), $0
		)
	})
}

public func resourceAddressBech32Address(address: ResourceAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_resource_address_bech32_address(
			FfiConverterTypeResourceAddress.lower(address), $0
		)
	})
}

public func resourceAddressFormatted(address: ResourceAddress, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_resource_address_formatted(
			FfiConverterTypeResourceAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

public func resourceAddressIsFungible(address: ResourceAddress) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_resource_address_is_fungible(
			FfiConverterTypeResourceAddress.lower(address), $0
		)
	})
}

public func resourceAddressIsNonFungible(address: ResourceAddress) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_resource_address_is_non_fungible(
			FfiConverterTypeResourceAddress.lower(address), $0
		)
	})
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func resourceAddressMapToNetwork(address: ResourceAddress, networkId: NetworkId) -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_resource_address_map_to_network(
			FfiConverterTypeResourceAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func resourceAddressNetworkId(address: ResourceAddress) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_resource_address_network_id(
			FfiConverterTypeResourceAddress.lower(address), $0
		)
	})
}

public func resourceIndicatorGetAddress(indicator: ResourceIndicator) -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_resource_indicator_get_address(
			FfiConverterTypeResourceIndicator.lower(indicator), $0
		)
	})
}

public func resourcePreferencesGetHiddenResources(resourcePreferences: [ResourceAppPreference]) -> [ResourceIdentifier] {
	try! FfiConverterSequenceTypeResourceIdentifier.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_resource_preferences_get_hidden_resources(
			FfiConverterSequenceTypeResourceAppPreference.lower(resourcePreferences), $0
		)
	})
}

public func resourcePreferencesHideResource(resourcePreferences: [ResourceAppPreference], resource: ResourceIdentifier) -> [ResourceAppPreference] {
	try! FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_resource_preferences_hide_resource(
			FfiConverterSequenceTypeResourceAppPreference.lower(resourcePreferences),
			FfiConverterTypeResourceIdentifier.lower(resource), $0
		)
	})
}

public func resourcePreferencesUnhideResource(resourcePreferences: [ResourceAppPreference], resource: ResourceIdentifier) -> [ResourceAppPreference] {
	try! FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_resource_preferences_unhide_resource(
			FfiConverterSequenceTypeResourceAppPreference.lower(resourcePreferences),
			FfiConverterTypeResourceIdentifier.lower(resource), $0
		)
	})
}

public func resourceSpecifierGetAddress(specifier: ResourceSpecifier) -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_resource_specifier_get_address(
			FfiConverterTypeResourceSpecifier.lower(specifier), $0
		)
	})
}

/**
 * Returns every supported LogFilter
 */
public func rustLoggerGetAllFilters() -> [LogFilter] {
	try! FfiConverterSequenceTypeLogFilter.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_rust_logger_get_all_filters($0
		)
	})
}

/**
 * Returns every supported LogLevel
 */
public func rustLoggerGetAllLevels() -> [LogLevel] {
	try! FfiConverterSequenceTypeLogLevel.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_rust_logger_get_all_levels($0
		)
	})
}

public func rustLoggerGetLevel() -> LogFilter {
	try! FfiConverterTypeLogFilter.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_rust_logger_get_level($0
		)
	})
}

public func rustLoggerLogAtEveryLevel() { try! rustCall {
	uniffi_sargon_uniffi_fn_func_rust_logger_log_at_every_level($0
	)
}
}

public func rustLoggerSetLevel(level: LogFilter) { try! rustCall {
	uniffi_sargon_uniffi_fn_func_rust_logger_set_level(
		FfiConverterTypeLogFilter.lower(level), $0
	)
}
}

public func sLIP10CurveToJsonString(sLIP10Curve: Slip10Curve) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_s_l_i_p10_curve_to_json_string(
			FfiConverterTypeSLIP10Curve.lower(sLIP10Curve), $0
		)
	})
}

/**
 * Returns the current and the other gateways of `gateways`.
 */
public func savedGatewaysGetAllElements(gateways: SavedGateways) -> [Gateway] {
	try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_saved_gateways_get_all_elements(
			FfiConverterTypeSavedGateways.lower(gateways), $0
		)
	})
}

/**
 * Returns the public key on **compressed** form (33 bytes)
 */
public func secp256k1PublicKeyToBytes(publicKey: Secp256k1PublicKey) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_secp256k1_public_key_to_bytes(
			FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
		)
	})
}

/**
 * Returns the public key on **uncompressed** form (65 bytes)
 */
public func secp256k1PublicKeyToBytesUncompressed(publicKey: Secp256k1PublicKey) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_secp256k1_public_key_to_bytes_uncompressed(
			FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
		)
	})
}

/**
 * Encodes the compressed form (33 bytes) of a `Secp256k1PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"033083620d1596d3f8988ff3270e42970dd2a031e2b9b6488052a4170ff999f3e8"`
 */
public func secp256k1PublicKeyToHex(publicKey: Secp256k1PublicKey) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_secp256k1_public_key_to_hex(
			FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
		)
	})
}

public func secp256k1SignatureToString(signature: Secp256k1Signature) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_secp256k1_signature_to_string(
			FfiConverterTypeSecp256k1Signature.lower(signature), $0
		)
	})
}

public func secureStorageAccessErrorKindIsManualCancellation(kind: SecureStorageAccessErrorKind) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_secure_storage_access_error_kind_is_manual_cancellation(
			FfiConverterTypeSecureStorageAccessErrorKind.lower(kind), $0
		)
	})
}

public func secureStorageKeyIdentifier(key: SecureStorageKey) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_secure_storage_key_identifier(
			FfiConverterTypeSecureStorageKey.lower(key), $0
		)
	})
}

public func securifiedIndexInGlobalKeySpace(securified: SecurifiedU30) -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_securified_index_in_global_key_space(
			FfiConverterTypeSecurifiedU30.lower(securified), $0
		)
	})
}

public func securifiedIndexInLocalKeySpace(securified: SecurifiedU30) -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_securified_index_in_local_key_space(
			FfiConverterTypeSecurifiedU30.lower(securified), $0
		)
	})
}

public func securityQuestionsAll() -> [SecurityNotProductionReadyQuestion] {
	try! FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_security_questions_all($0
		)
	})
}

public func securityQuestionsFactorSourceDecrypt(factorSource: SecurityQuestionsNotProductionReadyFactorSource, with: [SecurityNotProductionReadyQuestionAndAnswer]) throws -> Mnemonic {
	try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_security_questions_factor_source_decrypt(
			FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lower(factorSource),
			FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lower(with), $0
		)
	})
}

public func signatureToBytes(signature: Signature) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_signature_to_bytes(
			FfiConverterTypeSignature.lower(signature), $0
		)
	})
}

public func signatureToString(signature: Signature) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_signature_to_string(
			FfiConverterTypeSignature.lower(signature), $0
		)
	})
}

public func signatureWithPublicKeyGetPublicKey(signatureWithPublicKey: SignatureWithPublicKey) -> PublicKey {
	try! FfiConverterTypePublicKey.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_signature_with_public_key_get_public_key(
			FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey), $0
		)
	})
}

public func signatureWithPublicKeyGetSignature(signatureWithPublicKey: SignatureWithPublicKey) -> Signature {
	try! FfiConverterTypeSignature.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_signature_with_public_key_get_signature(
			FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey), $0
		)
	})
}

public func signatureWithPublicKeyIsValid(signatureWithPublicKey: SignatureWithPublicKey, forHash: Hash) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_signature_with_public_key_is_valid(
			FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey),
			FfiConverterTypeHash.lower(forHash), $0
		)
	})
}

public func signedIntentHash(signedIntent: SignedIntent) -> SignedTransactionIntentHash {
	try! FfiConverterTypeSignedTransactionIntentHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_signed_intent_hash(
			FfiConverterTypeSignedIntent.lower(signedIntent), $0
		)
	})
}

public func signedTransactionIntentHashFormatted(address: SignedTransactionIntentHash, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_signed_transaction_intent_hash_formatted(
			FfiConverterTypeSignedTransactionIntentHash.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

public func slip10CurveToString(curve: Slip10Curve) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_slip10_curve_to_string(
			FfiConverterTypeSLIP10Curve.lower(curve), $0
		)
	})
}

public func subintentCompile(subintent: Subintent) -> CompiledSubintent {
	try! FfiConverterTypeCompiledSubintent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_subintent_compile(
			FfiConverterTypeSubintent.lower(subintent), $0
		)
	})
}

public func subintentHash(subintent: Subintent) -> SubintentHash {
	try! FfiConverterTypeSubintentHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_subintent_hash(
			FfiConverterTypeSubintent.lower(subintent), $0
		)
	})
}

public func subintentHashFormatted(address: SubintentHash, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_subintent_hash_formatted(
			FfiConverterTypeSubintentHash.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

public func subintentManifestBlobs(manifest: SubintentManifest) -> Blobs {
	try! FfiConverterTypeBlobs.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_subintent_manifest_blobs(
			FfiConverterTypeSubintentManifest.lower(manifest), $0
		)
	})
}

public func subintentManifestInvolvedPoolAddresses(manifest: SubintentManifest) -> [PoolAddress] {
	try! FfiConverterSequenceTypePoolAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_subintent_manifest_involved_pool_addresses(
			FfiConverterTypeSubintentManifest.lower(manifest), $0
		)
	})
}

public func subintentManifestInvolvedResourceAddresses(manifest: SubintentManifest) -> [ResourceAddress] {
	try! FfiConverterSequenceTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_subintent_manifest_involved_resource_addresses(
			FfiConverterTypeSubintentManifest.lower(manifest), $0
		)
	})
}

public func subintentManifestNetworkId(manifest: SubintentManifest) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_subintent_manifest_network_id(
			FfiConverterTypeSubintentManifest.lower(manifest), $0
		)
	})
}

public func subintentManifestString(manifest: SubintentManifest) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_subintent_manifest_string(
			FfiConverterTypeSubintentManifest.lower(manifest), $0
		)
	})
}

public func subintentManifestSummary(manifest: SubintentManifest) -> ManifestSummary {
	try! FfiConverterTypeManifestSummary.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_subintent_manifest_summary(
			FfiConverterTypeSubintentManifest.lower(manifest), $0
		)
	})
}

/**
 * The standard transaction fee
 */
public func transactionFeePreset() -> Decimal192 {
	try! FfiConverterTypeDecimal192.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_fee_preset($0
		)
	})
}

public func transactionIntentCompile(intent: TransactionIntent) -> CompiledTransactionIntent {
	try! FfiConverterTypeCompiledTransactionIntent.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_intent_compile(
			FfiConverterTypeTransactionIntent.lower(intent), $0
		)
	})
}

public func transactionIntentHash(intent: TransactionIntent) -> TransactionIntentHash {
	try! FfiConverterTypeTransactionIntentHash.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_intent_hash(
			FfiConverterTypeTransactionIntent.lower(intent), $0
		)
	})
}

public func transactionIntentHashFormatted(address: TransactionIntentHash, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_intent_hash_formatted(
			FfiConverterTypeTransactionIntentHash.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

public func transactionManifestBlobs(manifest: TransactionManifest) -> Blobs {
	try! FfiConverterTypeBlobs.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_blobs(
			FfiConverterTypeTransactionManifest.lower(manifest), $0
		)
	})
}

public func transactionManifestBlobsV2(manifest: TransactionManifestV2) -> Blobs {
	try! FfiConverterTypeBlobs.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_blobs_v2(
			FfiConverterTypeTransactionManifestV2.lower(manifest), $0
		)
	})
}

public func transactionManifestInstructionsString(manifest: TransactionManifest) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_instructions_string(
			FfiConverterTypeTransactionManifest.lower(manifest), $0
		)
	})
}

public func transactionManifestInvolvedPoolAddresses(manifest: TransactionManifest) -> [PoolAddress] {
	try! FfiConverterSequenceTypePoolAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_involved_pool_addresses(
			FfiConverterTypeTransactionManifest.lower(manifest), $0
		)
	})
}

public func transactionManifestInvolvedPoolAddressesV2(manifest: TransactionManifestV2) -> [PoolAddress] {
	try! FfiConverterSequenceTypePoolAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_involved_pool_addresses_v2(
			FfiConverterTypeTransactionManifestV2.lower(manifest), $0
		)
	})
}

public func transactionManifestInvolvedResourceAddresses(manifest: TransactionManifest) -> [ResourceAddress] {
	try! FfiConverterSequenceTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_involved_resource_addresses(
			FfiConverterTypeTransactionManifest.lower(manifest), $0
		)
	})
}

public func transactionManifestInvolvedResourceAddressesV2(manifest: TransactionManifestV2) -> [ResourceAddress] {
	try! FfiConverterSequenceTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_involved_resource_addresses_v2(
			FfiConverterTypeTransactionManifestV2.lower(manifest), $0
		)
	})
}

public func transactionManifestNetworkId(manifest: TransactionManifest) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_network_id(
			FfiConverterTypeTransactionManifest.lower(manifest), $0
		)
	})
}

public func transactionManifestNetworkIdV2(manifest: TransactionManifestV2) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_network_id_v2(
			FfiConverterTypeTransactionManifestV2.lower(manifest), $0
		)
	})
}

public func transactionManifestString(manifest: TransactionManifest) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_string(
			FfiConverterTypeTransactionManifest.lower(manifest), $0
		)
	})
}

public func transactionManifestStringV2(manifest: TransactionManifestV2) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_string_v2(
			FfiConverterTypeTransactionManifestV2.lower(manifest), $0
		)
	})
}

public func transactionManifestSummary(manifest: TransactionManifest) -> ManifestSummary {
	try! FfiConverterTypeManifestSummary.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_summary(
			FfiConverterTypeTransactionManifest.lower(manifest), $0
		)
	})
}

public func transactionManifestSummaryV2(manifest: TransactionManifestV2) throws -> ManifestSummary {
	try FfiConverterTypeManifestSummary.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
		uniffi_sargon_uniffi_fn_func_transaction_manifest_summary_v2(
			FfiConverterTypeTransactionManifestV2.lower(manifest), $0
		)
	})
}

public func trimSecurityQuestionsAnswer(answer: String) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_trim_security_questions_answer(
			FfiConverterString.lower(answer), $0
		)
	})
}

public func u30GetValue(u30: U30) -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_u30_get_value(
			FfiConverterTypeU30.lower(u30), $0
		)
	})
}

public func u31GetValue(u31: U31) -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_u31_get_value(
			FfiConverterTypeU31.lower(u31), $0
		)
	})
}

public func unhardenedIndexInGlobalKeySpace(unhardened: Unhardened) -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_unhardened_index_in_global_key_space(
			FfiConverterTypeUnhardened.lower(unhardened), $0
		)
	})
}

public func unhardenedIndexInLocalKeySpace(unhardened: Unhardened) -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_unhardened_index_in_local_key_space(
			FfiConverterTypeUnhardened.lower(unhardened), $0
		)
	})
}

public func unsafeStorageKeyIdentifier(key: UnsafeStorageKey) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_unsafe_storage_key_identifier(
			FfiConverterTypeUnsafeStorageKey.lower(key), $0
		)
	})
}

public func unsecurifiedHardenedIndexInGlobalKeySpace(unsecurifiedHardened: UnsecurifiedHardened) -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_unsecurified_hardened_index_in_global_key_space(
			FfiConverterTypeUnsecurifiedHardened.lower(unsecurifiedHardened), $0
		)
	})
}

public func unsecurifiedHardenedIndexInLocalKeySpace(unsecurifiedHardened: UnsecurifiedHardened) -> UInt32 {
	try! FfiConverterUInt32.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_unsecurified_hardened_index_in_local_key_space(
			FfiConverterTypeUnsecurifiedHardened.lower(unsecurifiedHardened), $0
		)
	})
}

public func validatorAddressBech32Address(address: ValidatorAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_validator_address_bech32_address(
			FfiConverterTypeValidatorAddress.lower(address), $0
		)
	})
}

public func validatorAddressFormatted(address: ValidatorAddress, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_validator_address_formatted(
			FfiConverterTypeValidatorAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func validatorAddressMapToNetwork(address: ValidatorAddress, networkId: NetworkId) -> ValidatorAddress {
	try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_validator_address_map_to_network(
			FfiConverterTypeValidatorAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func validatorAddressNetworkId(address: ValidatorAddress) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_validator_address_network_id(
			FfiConverterTypeValidatorAddress.lower(address), $0
		)
	})
}

public func vaultAddressBech32Address(address: VaultAddress) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_vault_address_bech32_address(
			FfiConverterTypeVaultAddress.lower(address), $0
		)
	})
}

public func vaultAddressFormatted(address: VaultAddress, format: AddressFormat) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_vault_address_formatted(
			FfiConverterTypeVaultAddress.lower(address),
			FfiConverterTypeAddressFormat.lower(format), $0
		)
	})
}

public func vaultAddressIsFungible(address: VaultAddress) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_vault_address_is_fungible(
			FfiConverterTypeVaultAddress.lower(address), $0
		)
	})
}

public func vaultAddressIsNonFungible(address: VaultAddress) -> Bool {
	try! FfiConverterBool.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_vault_address_is_non_fungible(
			FfiConverterTypeVaultAddress.lower(address), $0
		)
	})
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func vaultAddressMapToNetwork(address: VaultAddress, networkId: NetworkId) -> VaultAddress {
	try! FfiConverterTypeVaultAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_vault_address_map_to_network(
			FfiConverterTypeVaultAddress.lower(address),
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

public func vaultAddressNetworkId(address: VaultAddress) -> NetworkId {
	try! FfiConverterTypeNetworkID.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_vault_address_network_id(
			FfiConverterTypeVaultAddress.lower(address), $0
		)
	})
}

public func vectorImageTypeDataUrlType(imageType: VectorImageType) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_vector_image_type_data_url_type(
			FfiConverterTypeVectorImageType.lower(imageType), $0
		)
	})
}

public func vectorImageTypeUrlExtension(imageType: VectorImageType) -> String {
	try! FfiConverterString.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_vector_image_type_url_extension(
			FfiConverterTypeVectorImageType.lower(imageType), $0
		)
	})
}

public func walletInteractionWalletAccountToJsonBytes(walletInteractionWalletAccount: WalletInteractionWalletAccount) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_wallet_interaction_wallet_account_to_json_bytes(
			FfiConverterTypeWalletInteractionWalletAccount.lower(walletInteractionWalletAccount), $0
		)
	})
}

public func walletToDappInteractionResponseToJsonBytes(walletToDappInteractionResponse: WalletToDappInteractionResponse) -> BagOfBytes {
	try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_wallet_to_dapp_interaction_response_to_json_bytes(
			FfiConverterTypeWalletToDappInteractionResponse.lower(walletToDappInteractionResponse), $0
		)
	})
}

public func xrdAddressOfNetwork(networkId: NetworkId) -> ResourceAddress {
	try! FfiConverterTypeResourceAddress.lift(try! rustCall {
		uniffi_sargon_uniffi_fn_func_xrd_address_of_network(
			FfiConverterTypeNetworkID.lower(networkId), $0
		)
	})
}

// MARK: - InitializationResult
private enum InitializationResult {
	case ok
	case contractVersionMismatch
	case apiChecksumMismatch
}

// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
	// Get the bindings contract version from our ComponentInterface
	let bindings_contract_version = 26
	// Get the scaffolding contract version by calling the into the dylib
	let scaffolding_contract_version = ffi_sargon_uniffi_uniffi_contract_version()
	if bindings_contract_version != scaffolding_contract_version {
		return InitializationResult.contractVersionMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_access_controller_address_bech32_address() != 16739 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_access_controller_address_formatted() != 5192 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_access_controller_address_map_to_network() != 7986 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_access_controller_address_network_id() != 20657 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_account_address_bech32_address() != 41480 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_account_address_formatted() != 36270 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_account_address_is_legacy() != 9809 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_account_address_map_to_network() != 36939 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_account_address_network_id() != 25986 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_account_or_address_of_account_address() != 5968 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_account_or_persona_get_id() != 53085 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_address_formatted() != 51517 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_address_map_to_network() != 36071 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_address_network_id() != 58584 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_formatted() != 44847 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_map_to_network() != 5970 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_network_id() != 33299 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_sample_values_all() != 42804 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_to_string() != 54683 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_address_sample_values_all() != 26979 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_address_to_string() != 39924 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_android_notarize_hash_with_private_key_bytes() != 11907 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_android_secret_key_get_public_key_from_private_key_bytes() != 5694 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_android_sign_hash_with_private_key_bytes() != 43322 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_app_preferences_has_gateway_with_url() != 26937 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_appearance_ids_all() != 47723 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_arculus_card_model_to_string() != 6670 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_authorized_dapp_to_json_bytes() != 4956 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_b_i_p39_seed_to_bytes() != 31312 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_bag_of_bytes_append_cafe() != 7653 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_bag_of_bytes_append_deadbeef() != 18671 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_bag_of_bytes_prepend_cafe() != 12603 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_bag_of_bytes_prepend_deadbeef() != 11612 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_bip32_constant_global_offset_hardened() != 56838 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_bip32_constant_global_offset_securified() != 26205 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_bip39_language_wordlist() != 53356 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_bip39_word_count_all() != 21883 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_bip44_like_path_get_address_index() != 14802 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_bip44_like_path_to_string() != 64740 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_blob_to_bytes() != 2709 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_blob_to_string() != 56091 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_blobs_list_of_blobs() != 58647 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_build_information() != 25206 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_check_if_encrypted_profile_json_contains_legacy_p2p_links() != 56950 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_check_if_profile_json_contains_legacy_p2p_links() != 13443 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_compiled_notarized_intent_get_bytes() != 35568 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_compiled_subintent_bytes() != 55048 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_compiled_subintent_decompile() != 22909 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_compiled_transaction_intent_bytes() != 5074 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_compiled_transaction_intent_decompile() != 5413 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_component_address_bech32_address() != 19756 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_component_address_formatted() != 14442 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_component_address_is_global() != 49734 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_component_address_is_internal() != 48259 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_component_address_map_to_network() != 27675 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_component_address_network_id() != 51835 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_constant_entity_name_max_length() != 19522 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_constant_min_required_xrd_for_account_deletion() != 45958 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_dapp_to_wallet_interaction_unvalidated_to_json_bytes() != 61820 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_dapp_to_wallet_interaction_unvalidated_to_json_string() != 63502 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_debug_print_compiled_notarized_intent() != 16677 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_abs() != 29764 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_add() != 32856 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_clamped_to_zero() != 27082 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_div() != 51913 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_formatted() != 34425 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_formatted_plain() != 59743 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_greater_than() != 8443 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_greater_than_or_equal() != 20591 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_is_negative() != 12023 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_is_positive() != 31461 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_is_zero() != 7222 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_less_than() != 3979 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_less_than_or_equal() != 14807 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_max() != 18055 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_min() != 41483 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_mul() != 7996 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_neg() != 25523 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_round() != 34421 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_sub() != 16671 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_decimal_to_string() != 36217 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_dependency_information_to_string() != 39562 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_deposit_rule_to_json_string() != 9778 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_derivation_path_to_hd_path() != 40437 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_derivation_path_to_string() != 62433 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_device_factor_source_is_main_bdfs() != 29295 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_device_info_description_to_string() != 41352 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_device_info_to_json_bytes() != 65074 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_display_name_to_json_string() != 21695 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_ed25519_public_key_to_bytes() != 32366 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_ed25519_public_key_to_hex() != 56150 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_ed25519_public_key_to_json_string() != 45791 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_ed25519_signature_to_json_string() != 34112 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_ed25519_signature_to_string() != 3491 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_entropy16_bytes_to_bytes() != 10147 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_entropy20_bytes_to_bytes() != 6787 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_entropy24_bytes_to_bytes() != 2461 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_entropy28_bytes_to_bytes() != 261 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_entropy32_bytes_to_bytes() != 52294 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_error_code_from_error() != 29726 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_error_message_from_error() != 21055 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_event_kind() != 60428 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_event_kind_affects_current_accounts() != 42399 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_event_kind_affects_current_network() != 33132 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_event_kind_affects_factor_sources() != 48330 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_event_kind_affects_saved_gateways() != 55144 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_event_kind_affects_security_structures() != 29273 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_event_kind_all() != 41590 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly12_bytes_to_json_string() != 53379 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly29_bytes_to_json_string() != 40034 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly32_bytes_to_json_string() != 25695 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly33_bytes_to_json_string() != 49844 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly60_bytes_to_json_string() != 61148 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly64_bytes_to_json_string() != 15251 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly65_bytes_to_json_string() != 35639 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_12_bytes_to_bytes() != 1500 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_12_bytes_to_hex() != 46640 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_29_bytes_to_bytes() != 43740 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_29_bytes_to_hex() != 11033 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_32_bytes_to_bytes() != 30445 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_32_bytes_to_hex() != 21548 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_33_bytes_to_bytes() != 32587 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_33_bytes_to_hex() != 35227 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_60_bytes_to_bytes() != 21333 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_60_bytes_to_hex() != 34978 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_64_bytes_to_bytes() != 41324 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_64_bytes_to_hex() != 4596 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_65_bytes_to_bytes() != 38987 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_exactly_65_bytes_to_hex() != 59590 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_factor_source_crypto_parameters_supports_babylon() != 19739 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_factor_source_crypto_parameters_supports_olympia() != 46978 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_factor_source_i_d_from_address_to_json_bytes() != 28180 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_factor_source_i_d_from_hash_to_json_bytes() != 50855 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_factor_source_id_from_address_to_string() != 15403 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_factor_source_id_from_hash_to_string() != 2950 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_factor_source_id_to_string() != 26529 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_factor_source_kind_to_string() != 30143 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_factor_source_supports_babylon() != 5064 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_factor_source_supports_olympia() != 44230 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_factor_source_to_string() != 23127 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_factor_sources_all_sample_values() != 29519 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_ffi_url_get_url() != 13501 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_fiat_currency_to_json_string() != 29262 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_fungible_resource_indicator_get_amount() != 57502 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_gateway_id() != 62787 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_gateway_is_wellknown() != 12190 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_gateway_mainnet() != 50357 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_gateway_stokenet() != 60555 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_gateway_to_string() != 45466 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_gateway_wellknown_gateways() != 24662 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_get_subintent_expiration_status() != 706 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_hash() != 40399 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_hash_get_bytes() != 17430 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_hd_path_component_get_key_space() != 16341 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_hd_path_component_index_in_global_key_space() != 2568 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_hd_path_component_index_in_local_key_space() != 1876 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_hd_path_component_to_bip32_string() != 11237 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_hd_path_component_to_bip32_string_debug() != 39488 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_hd_path_component_to_hardened() != 60319 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_header_to_json_bytes() != 30120 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_hierarchical_deterministic_public_key_is_valid_signature_for_hash() != 44394 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_host_id_to_json_bytes() != 46400 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_host_os_get_name() != 65043 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_host_os_get_vendor() != 52670 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_host_os_get_version() != 50713 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_identity_address_bech32_address() != 6747 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_identity_address_formatted() != 57900 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_identity_address_map_to_network() != 21479 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_identity_address_network_id() != 22178 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_image_url_utils_is_vector_image() != 7296 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_image_url_utils_make_image_url() != 11016 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_intent_discriminator_get_value() != 49816 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_intent_signature_get_signature_with_public_key() != 55591 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_is_safe_to_show_error_message_from_error() != 48490 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_key_agreement_public_key_to_bytes() != 27363 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_key_agreement_public_key_to_hex() != 57749 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_ledger_hw_wallet_model_to_string() != 6623 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_legacy_olympia_account_address_formatted() != 37355 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_legacy_olympia_account_address_is_legacy_of_babylon() != 12089 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_legacy_olympia_account_address_to_babylon_account_address() != 64098 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_legacy_olympia_account_address_to_string() != 586 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_link_connection_q_r_data_to_json_bytes() != 19222 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_locker_address_bech32_address() != 37513 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_locker_address_formatted() != 24320 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_locker_address_map_to_network() != 24957 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_locker_address_network_id() != 17185 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_account_locker_claim() != 51896 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_create_fungible_token() != 53492 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_create_fungible_token_with_metadata() != 24893 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_create_multiple_fungible_tokens() != 21380 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_create_multiple_non_fungible_tokens() != 43838 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_create_non_fungible_token() != 3479 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_formatted() != 23567 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_map_to_network() != 58015 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_network_id() != 10681 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_sample_values_all() != 52471 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_to_string() != 44296 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_for_faucet() != 39443 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_marking_account_as_dapp_definition_type() != 54702 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_per_asset_transfers() != 20320 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_per_recipient_transfers() != 29446 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_set_owner_keys_hashes() != 19176 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_stakes_claim() != 28927 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_manifest_third_party_deposit_update() != 44888 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_message_as_plaintext() != 37029 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_message_v2_as_plaintext() != 5171 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_mnemonic_phrase() != 26344 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_mnemonic_with_passphrase_derive_public_keys() != 51123 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_mnemonic_with_passphrase_sign() != 60558 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_mnemonic_with_passphrase_to_json_bytes() != 43384 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_mnemonic_with_passphrase_validate_public_keys() != 42595 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_modify_manifest_add_guarantees() != 54480 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_modify_manifest_lock_fee() != 37364 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_network_id_discriminant() != 60399 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_network_id_to_string() != 9901 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_network_ids_all() != 12196 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_network_method_to_string() != 56251 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_access_controller_address() != 43372 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_access_controller_address_random() != 53067 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_access_controller_address_sample_mainnet() != 55321 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_access_controller_address_sample_mainnet_other() != 53259 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_access_controller_address_sample_stokenet() != 62042 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_access_controller_address_sample_stokenet_other() != 48145 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_address() != 65018 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_address_from() != 13571 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_address_random() != 62190 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_address_sample_mainnet() != 22922 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_address_sample_mainnet_other() != 53879 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_address_sample_stokenet() != 13145 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_address_sample_stokenet_other() != 3741 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_for_display_from_account() != 54146 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_for_display_sample() != 46449 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_for_display_sample_other() != 25799 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_locker_claimable_resource_sample() != 44473 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_locker_claimable_resource_sample_other() != 49877 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_or_address_of_sample() != 40406 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_or_address_of_sample_other() != 58713 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_mainnet() != 20540 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_mainnet_other() != 19137 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_mainnet_third() != 55355 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_stokenet() != 30858 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_stokenet_other() != 22043 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_stokenet_third() != 61696 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_path() != 60462 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_path_sample() != 54597 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_path_sample_other() != 39697 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_sample_mainnet_alice() != 25345 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_sample_mainnet_bob() != 29866 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_sample_mainnet_carol() != 42248 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_sample_mainnet_diana() != 36079 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_sample_stokenet_nadia() != 30043 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_sample_stokenet_olivia() != 27591 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_account_sample_stokenet_paige() != 5383 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_accounts_for_display_sample() != 58677 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_accounts_for_display_sample_other() != 27502 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_accounts_or_personas_sample() != 12183 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_accounts_or_personas_sample_other() != 58257 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_accounts_sample() != 56236 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_accounts_sample_other() != 6814 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_address_from_bech32() != 21331 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_from_bech32() != 21850 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_sample_mainnet() != 33734 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_sample_mainnet_other() != 6476 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_sample_stokenet() != 64912 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_sample_stokenet_other() != 51988 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_address_sample_mainnet() != 7887 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_address_sample_mainnet_other() != 61417 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_address_sample_stokenet() != 19240 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_address_sample_stokenet_other() != 6756 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_app_preferences_default() != 14693 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_app_preferences_sample() != 54060 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_app_preferences_sample_other() != 4957 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_appearance_id() != 45858 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_appearance_id_from_number_of_accounts_on_network() != 17795 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_appearance_id_sample() != 30621 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_appearance_id_sample_other() != 52854 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_arculus_card_factor_source_from_mnemonic_with_passphrase() != 63140 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_arculus_card_factor_source_sample() != 59637 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_arculus_card_factor_source_sample_other() != 30228 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_asset_exception_sample() != 55301 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_asset_exception_sample_other() != 55082 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_assets_exception_list_sample() != 47074 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_assets_exception_list_sample_other() != 39085 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_detailed_sample() != 38954 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_detailed_sample_other() != 11486 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_from_json_bytes() != 10178 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_sample_mainnet_dashboard() != 54023 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_sample_mainnet_gumballclub() != 62709 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_sample_stokenet_devconsole() != 45066 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_sample_stokenet_sandbox() != 14923 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_dapps_sample() != 40678 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_dapps_sample_other() != 44743 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_persona_detailed_sample() != 22358 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_persona_detailed_sample_other() != 16247 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_persona_simple_sample_mainnet() != 5111 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_persona_simple_sample_mainnet_other() != 4841 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_persona_simple_sample_stokenet() != 17795 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_authorized_persona_simple_sample_stokenet_other() != 33729 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_b_i_p39_seed_from_bytes() != 22381 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_b_i_p39_seed_sample() != 61518 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_b_i_p39_seed_sample_other() != 21682 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_from() != 2776 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_aced() != 16822 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_babe() != 63067 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_cafe() != 19146 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_dead() != 30477 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_ecad() != 8414 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_fade() != 25865 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bip39_language_sample() != 35094 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bip39_language_sample_other() != 12099 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bip39_word_sample() != 36954 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bip39_word_sample_other() != 21194 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bip44_like_path_from_index() != 41704 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bip44_like_path_from_string() != 38941 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bip44_like_path_sample() != 62302 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_bip44_like_path_sample_other() != 53938 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_blob_from_bytes() != 4046 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_blobs_from_blob_list() != 47310 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_blobs_sample() != 51393 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_blobs_sample_other() != 1358 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_compiled_notarized_intent_sample() != 351 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_compiled_notarized_intent_sample_other() != 30738 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_compiled_subintent_sample() != 50175 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_compiled_subintent_sample_other() != 29258 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_compiled_transaction_intent_sample() != 25544 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_compiled_transaction_intent_sample_other() != 35639 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_component_address() != 6748 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_component_address_random() != 166 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_component_address_sample_mainnet_global() != 62491 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_component_address_sample_mainnet_internal() != 12637 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_component_address_sample_stokenet_global() != 18747 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_component_address_sample_stokenet_internal() != 50419 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_unvalidated_from_json_bytes() != 30691 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_unvalidated_from_json_string() != 6002 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_unvalidated_sample() != 7739 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_unvalidated_sample_other() != 25552 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_decimal_exponent() != 12846 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_decimal_from_f32() != 53578 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_decimal_from_f64() != 53652 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_decimal_from_formatted_string() != 42489 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_decimal_from_i32() != 16943 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_decimal_from_i64() != 31040 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_decimal_from_string() != 33537 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_decimal_from_u32() != 19405 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_decimal_from_u64() != 36062 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_dependency_information_sample() != 49066 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_dependency_information_sample_other() != 43626 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_deposit_rule_from_json_string() != 25423 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_deposit_rule_sample() != 8201 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_deposit_rule_sample_other() != 54410 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_depositors_allow_list_sample() != 8727 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_depositors_allow_list_sample_other() != 7481 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_derivation_path_from_string() != 11067 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_derivation_path_sample() != 60817 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_derivation_path_sample_other() != 4393 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_detailed_authorized_personas_sample() != 46157 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_detailed_authorized_personas_sample_other() != 58210 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_device_factor_source_babylon() != 27263 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_device_factor_source_olympia() != 17238 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_device_factor_source_sample() != 7799 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_device_factor_source_sample_other() != 21308 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_device_info_description_sample() != 45889 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_device_info_description_sample_other() != 48984 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_device_info_from_host_info() != 29629 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_device_info_from_json_bytes() != 20094 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_device_info_sample() != 39892 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_device_info_sample_other() != 57142 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_display_name() != 39164 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_display_name_from_json_string() != 65092 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_display_name_sample() != 29614 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_display_name_sample_other() != 43371 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_from_bytes() != 14056 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_from_hex() != 48187 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_from_json_string() != 53635 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_sample() != 8979 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_sample_other() != 31532 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_from_bytes() != 14357 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_from_exactly_64_bytes() != 61100 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_from_json_string() != 47403 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_sample() != 35097 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_sample_other() != 29669 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_email_address_sample() != 52899 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_email_address_sample_other() != 53375 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entity_flag_sample() != 53250 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entity_flag_sample_other() != 46309 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entity_flags_sample() != 40234 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entity_flags_sample_other() != 6490 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entity_security_state_sample() != 1724 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entity_security_state_sample_other() != 54559 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy16_bytes_from_bytes() != 3405 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy16_bytes_sample() != 63418 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy16_bytes_sample_other() != 10505 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy20_bytes_from_bytes() != 56880 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy20_bytes_sample() != 15341 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy20_bytes_sample_other() != 44987 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy24_bytes_from_bytes() != 13630 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy24_bytes_sample() != 56974 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy24_bytes_sample_other() != 27016 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy28_bytes_from_bytes() != 47298 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy28_bytes_sample() != 22081 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy28_bytes_sample_other() != 56854 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy32_bytes_from_bytes() != 23680 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy32_bytes_sample() != 42841 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_entropy32_bytes_sample_other() != 48183 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly12_bytes_from_json_string() != 39752 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly29_bytes_from_json_string() != 52829 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly32_bytes_from_json_string() != 24841 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly33_bytes_from_json_string() != 46155 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly60_bytes_from_json_string() != 41288 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly64_bytes_from_json_string() != 62020 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly65_bytes_from_json_string() != 64582 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_12_bytes() != 53376 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_12_bytes_sample() != 12822 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_12_bytes_sample_other() != 28820 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_29_bytes() != 51192 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_29_bytes_sample() != 53557 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_29_bytes_sample_other() != 47703 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_32_bytes() != 64310 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_32_bytes_sample() != 45472 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_32_bytes_sample_other() != 18845 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_33_bytes() != 52850 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_33_bytes_sample() != 2208 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_33_bytes_sample_other() != 63205 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_60_bytes() != 6398 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_60_bytes_sample() != 9877 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_60_bytes_sample_other() != 65036 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_64_bytes() != 45996 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_64_bytes_sample() != 33155 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_64_bytes_sample_other() != 39984 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_65_bytes() != 61939 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_65_bytes_sample() != 36105 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_exactly_65_bytes_sample_other() != 14805 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_common_babylon() != 60986 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_common_bdfs() != 23312 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_common_olympia() != 55674 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_common_sample() != 18551 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_common_sample_other() != 15753 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_preset_babylon_olympia_compatible() != 46508 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_preset_babylon_only() != 34472 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_preset_olympia_only() != 15990 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_sample() != 7491 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_sample_other() != 4781 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_i_d_from_address_from_json_bytes() != 28530 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_i_d_from_hash_from_json_bytes() != 30633 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_address_sample() != 21401 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_address_sample_other() != 31544 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_hash_from_mnemonic_with_passphrase() != 21191 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_hash_sample() != 11669 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_hash_sample_other() != 60302 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_sample() != 22280 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_sample_other() != 40497 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_kind_from_string() != 5930 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_kind_sample() != 29958 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_kind_sample_other() != 57561 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_sample() != 48469 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_source_sample_other() != 42128 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_sources_sample() != 54455 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_factor_sources_sample_other() != 15671 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_fiat_currency_from_json_string() != 31917 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_fiat_currency_sample() != 44623 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_fiat_currency_sample_other() != 47859 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_fungible_resource_indicator_sample() != 32253 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_fungible_resource_indicator_sample_other() != 1830 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_gateway_for_network_id() != 2039 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_gateway_sample() != 65248 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_gateway_sample_other() != 19812 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_gateway_with_url_on_network() != 34352 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_gateways_sample() != 26136 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_gateways_sample_other() != 14701 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hardened_sample() != 23609 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hardened_sample_other() != 12456 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hash_from_bytes() != 53909 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hash_from_string() != 29142 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hash_sample() != 14961 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hash_sample_other() != 44845 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hd_path_component_from_global_key_space() != 15222 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hd_path_component_from_local_key_space() != 37980 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hd_path_component_sample() != 35319 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hd_path_component_sample_other() != 21010 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_header_from_json_bytes() != 60561 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_header_sample() != 26875 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_header_sample_other() != 21914 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_header_with_creating_device() != 23900 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hidden_resources_sample() != 13060 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hidden_resources_sample_other() != 27518 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hierarchical_deterministic_factor_instance_sample() != 19729 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hierarchical_deterministic_factor_instance_sample_other() != 59419 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hierarchical_deterministic_public_key_sample() != 17515 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_hierarchical_deterministic_public_key_sample_other() != 45174 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_host_id_from_json_bytes() != 50705 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_host_id_sample() != 14792 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_host_id_sample_other() != 15608 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_host_info_sample() != 55060 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_host_info_sample_other() != 32825 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_host_os_android() != 64596 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_host_os_ios() != 47748 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_host_os_other() != 18747 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_host_os_sample() != 43842 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_host_os_sample_other() != 49140 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_identity_address() != 37512 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_identity_address_from() != 6311 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_identity_address_random() != 3026 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_identity_address_sample_mainnet() != 10751 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_identity_address_sample_mainnet_other() != 52448 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_identity_address_sample_stokenet() != 20666 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_identity_address_sample_stokenet_other() != 29131 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_identity_path() != 34862 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_identity_path_sample() != 10679 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_identity_path_sample_other() != 9827 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_intent_discriminator_from_u64() != 53541 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_intent_discriminator_random() != 38983 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_intent_discriminator_sample() != 36765 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_intent_discriminator_sample_other() != 27108 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_intent_header_v2_sample() != 62553 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_intent_header_v2_sample_other() != 52012 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_intent_signature_from_signature_with_public_key() != 17724 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_intent_signature_sample() != 32994 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_intent_signature_sample_other() != 32199 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_key_agreement_public_key_from_bytes() != 57828 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_key_agreement_public_key_from_hex() != 26295 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_key_agreement_public_key_sample() != 28131 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_key_agreement_public_key_sample_other() != 3360 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_key_space_sample() != 47298 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_key_space_sample_other() != 16330 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ledger_hardware_wallet_factor_source_sample() != 48515 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ledger_hardware_wallet_factor_source_sample_other() != 51985 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ledger_hardware_wallet_from_mnemonic_with_passphrase() != 44413 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ledger_hw_wallet_model_from_string() != 37370 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ledger_hw_wallet_model_sample() != 17004 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_ledger_hw_wallet_model_sample_other() != 18014 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_legacy_olympia_account_address_from_public_key() != 49238 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_legacy_olympia_account_address_from_string() != 51151 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_legacy_olympia_account_address_sample() != 51720 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_legacy_olympia_account_address_sample_other() != 2909 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_link_connection_q_r_data_from_json_bytes() != 63075 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_link_connection_qr_data_sample() != 390 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_link_connection_qr_data_sample_other() != 48462 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_locker_address() != 41694 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_locker_address_random() != 47028 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_locker_address_sample_mainnet() != 41128 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_locker_address_sample_mainnet_other() != 15582 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_locker_address_sample_stokenet() != 22220 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_locker_address_sample_stokenet_other() != 49931 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_from_bech32() != 20959 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_sample_mainnet() != 18081 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_sample_mainnet_other() != 42631 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_sample_stokenet() != 16081 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_sample_stokenet_other() != 59943 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_matrix_of_factor_sources_sample() != 44278 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_matrix_of_factor_sources_sample_other() != 20016 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_message_plaintext_sample() != 5016 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_message_plaintext_sample_other() != 22181 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_message_plaintext_string() != 61136 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_message_v2_plaintext_sample() != 23768 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_message_v2_plaintext_sample_other() != 16 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_message_v2_plaintext_string() != 27580 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_from_phrase() != 56600 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_from_phrase_language() != 4694 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_from_words() != 65034 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_generate_with_entropy() != 60360 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample() != 488 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_arculus() != 22101 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_arculus_other() != 16183 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_device() != 9748 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_device_12_words() != 400 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_device_12_words_other() != 11940 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_device_other() != 18760 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_ledger() != 29417 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_ledger_other() != 44988 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_off_device() != 58644 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_off_device_other() != 36452 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_other() != 10990 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_passphrase() != 57688 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_passphrase_other() != 55603 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_security_questions() != 29566 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_security_questions_other() != 40755 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_with_passphrase_from_json_bytes() != 33065 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_with_passphrase_sample() != 13986 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_mnemonic_with_passphrase_sample_other() != 44196 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_network_definition_lookup_by_name() != 20559 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_network_definition_sample() != 6748 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_network_definition_sample_other() != 20321 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_network_id_from_discriminant() != 40833 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_network_method_sample() != 61115 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_network_method_sample_other() != 7620 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_network_request_sample() != 44220 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_network_request_sample_other() != 35449 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_empty_max_32_bytes() != 10326 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_empty_max_64_bytes() != 6712 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_global_id_from_string() != 8625 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_global_id_sample() != 14915 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_global_id_sample_other() != 31589 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_bytes() != 7239 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_from_string() != 17202 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_int() != 24222 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_random() != 7654 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_ruid() != 28939 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_sample() != 56159 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_sample_other() != 35518 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_string() != 14957 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_string_from_str() != 8847 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address() != 8188 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_random() != 56930 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_sample_mainnet() != 1509 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_sample_mainnet_other() != 61508 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_sample_stokenet() != 32156 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_sample_stokenet_other() != 50028 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_indicator_sample() != 20517 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_indicator_sample_other() != 15310 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_nonce_from_u32() != 6600 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_nonce_random() != 3824 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_nonce_sample() != 50716 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_nonce_sample_other() != 11696 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_notarized_transaction_sample() != 3580 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_notarized_transaction_sample_other() != 8227 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_notary_signature() != 8639 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_notary_signature_sample() != 25191 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_notary_signature_sample_other() != 9617 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_off_device_mnemonic_factor_source_from_mnemonic_with_passphrase() != 53315 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_off_device_mnemonic_factor_source_sample() != 7141 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_off_device_mnemonic_factor_source_sample_other() != 60614 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_on_ledger_settings_default() != 27043 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_on_ledger_settings_sample() != 61885 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_on_ledger_settings_sample_other() != 12898 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_p2_p_link_from_json_bytes() != 16669 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_p2_p_links_sample() != 37944 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_p2_p_links_sample_other() != 23031 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_p2p_link_sample() != 51168 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_p2p_link_sample_other() != 60728 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_p2p_links_from_json_bytes() != 5830 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_package_address() != 28930 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_package_address_random() != 41825 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_package_address_sample_mainnet() != 37012 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_package_address_sample_mainnet_other() != 13811 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_package_address_sample_stokenet() != 49912 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_package_address_sample_stokenet_other() != 2264 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_passphrase_factor_source_from_mnemonic_with_passphrase() != 20208 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_passphrase_factor_source_sample() != 63822 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_passphrase_factor_source_sample_other() != 44302 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_per_asset_transfers_sample() != 57477 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_per_asset_transfers_sample_other() != 54472 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_email_address_from_json_string() != 17266 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_email_address_sample() != 16240 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_email_address_sample_other() != 31225 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_name_from_json_bytes() != 48047 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_name_sample() != 31330 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_name_sample_other() != 45091 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_phone_number_from_json_string() != 63307 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_phone_number_sample() != 23998 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_phone_number_sample_other() != 64155 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_data_sample() != 15395 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_data_sample_other() != 17421 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_sample() != 11862 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_sample_mainnet_batman() != 60447 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_sample_mainnet_ripley() != 15174 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_sample_mainnet_satoshi() != 57136 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_sample_mainnet_turing() != 64235 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_sample_other() != 52731 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_sample_stokenet_connor() != 12681 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_sample_stokenet_hermione() != 43143 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_persona_sample_stokenet_leia_skywalker() != 32626 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_personas_sample() != 41264 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_personas_sample_other() != 59167 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_pool_address() != 37194 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_pool_address_random() != 2609 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_mainnet_multi() != 60014 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_mainnet_single() != 56079 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_mainnet_two() != 49886 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_stokenet_multi() != 13647 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_stokenet_single() != 22732 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_stokenet_two() != 26088 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_babylon() != 2417 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_babylon_from_mnemonic_with_passphrase() != 30453 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_olympia_from_mnemonic_with_passphrase() != 18078 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_sample() != 32540 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_sample_other() != 12390 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile() != 58363 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_file_contents_sample() != 61888 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_file_contents_sample_other() != 16774 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_from_encryption_bytes() != 50411 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_from_json_string() != 61261 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_id_sample() != 20711 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_id_sample_other() != 44986 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_network_sample() != 47064 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_network_sample_other() != 25587 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_networks_sample() != 59335 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_networks_sample_other() != 2779 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_sample() != 23215 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_sample_other() != 52859 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_profile_with_mnemonic() != 25823 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_public_key_from_bytes() != 13924 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_public_key_from_hex() != 37374 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_public_key_hash_of_key() != 59602 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_public_key_hash_sample() != 42850 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_public_key_hash_sample_other() != 38629 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_public_key_sample() != 31874 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_public_key_sample_other() != 61084 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_radix_connect_mobile_session_request_from_json_bytes() != 572 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_radix_connect_mobile_session_request_sample() != 10993 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_radix_connect_mobile_session_request_sample_other() != 14869 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_radix_connect_password() != 20733 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_radix_connect_password_from_json_string() != 12504 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_radix_connect_password_sample() != 48289 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_radix_connect_password_sample_other() != 55376 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_radix_connect_purpose_from_json_string() != 6704 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_radix_connect_purpose_from_string() != 53702 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_radix_connect_purpose_sample() != 40644 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_radix_connect_purpose_sample_other() != 6326 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_references_to_authorized_personas_sample() != 64338 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_references_to_authorized_personas_sample_other() != 58733 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_requested_quantity_from_json_bytes() != 63420 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_requested_quantity_sample() != 4279 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_requested_quantity_sample_other() != 8374 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_address() != 38401 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_address_random() != 16846 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_mainnet_candy() != 21546 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_mainnet_nft_gc_membership() != 41107 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_mainnet_xrd() != 19705 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_stokenet_candy() != 20717 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_stokenet_gc_tokens() != 62696 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_stokenet_gum() != 7006 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_stokenet_xrd() != 6601 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_indicator_sample() != 45770 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_indicator_sample_other() != 28357 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_or_non_fungible_sample() != 62731 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_or_non_fungible_sample_other() != 60028 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_preferences_sample() != 782 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_preferences_sample_other() != 39619 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_specifier_sample() != 58427 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_resource_specifier_sample_other() != 8185 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_s_l_i_p10_curve_from_json_string() != 20445 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_sargon_build_information_sample() != 41647 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_sargon_build_information_sample_other() != 25347 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_saved_gateways() != 44618 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_saved_gateways_changing_current() != 3541 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_saved_gateways_default() != 14470 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_saved_gateways_sample() != 46435 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_saved_gateways_sample_other() != 36343 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_secp256k1_public_key_from_bytes() != 56517 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_secp256k1_public_key_from_hex() != 19768 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_secp256k1_public_key_sample() != 32902 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_secp256k1_public_key_sample_other() != 15984 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_secp256k1_signature_from_bytes() != 14670 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_secp256k1_signature_from_exactly_65_bytes() != 49202 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_secp256k1_signature_sample() != 25467 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_secp256k1_signature_sample_other() != 17125 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_securified() != 35174 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_securified_from_global_key_space() != 4183 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_securified_from_local_key_space() != 19115 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_securified_sample() != 29424 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_securified_sample_other() != 29224 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_and_answers_sample() != 39363 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_and_answers_sample_other() != 57147 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_questions_factor_source_by_encrypting_mnemonic() != 63012 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_questions_factor_source_sample() != 15654 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_questions_factor_source_sample_other() != 20505 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_structure_metadata_named() != 59028 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_structure_metadata_sample() != 45001 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_structure_metadata_sample_other() != 16304 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_source_ids_sample() != 15528 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_source_ids_sample_other() != 9760 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_sources_auto_in_days() != 61082 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_sources_sample() != 11104 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_sources_sample_other() != 49794 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_structures_of_factor_source_i_ds_sample() != 8648 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_security_structures_of_factor_source_i_ds_sample_other() != 52262 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_shared_persona_data_sample() != 52679 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_shared_persona_data_sample_other() != 27739 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_signature_from_bytes() != 61714 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_signature_sample() != 41998 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_signature_sample_other() != 19832 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_signature_with_public_key_sample() != 50602 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_signature_with_public_key_sample_other() != 24400 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_signed_intent_hash_sample() != 33808 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_signed_intent_hash_sample_other() != 11367 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_signed_intent_sample() != 52370 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_signed_intent_sample_other() != 19689 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_signed_transaction_intent_hash_from_string() != 52650 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_slip10_curve_from_string() != 17182 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_stake_claim_sample() != 50908 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_stake_claim_sample_other() != 20345 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_subintent() != 21688 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_subintent_hash_from_string() != 27930 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_subintent_hash_sample() != 20745 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_subintent_hash_sample_other() != 42752 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_subintent_manifest_sample() != 40795 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_subintent_manifest_sample_other() != 21745 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_subintent_sample() != 41412 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_subintent_sample_other() != 56550 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_supported_curves_sample() != 27270 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_supported_curves_sample_other() != 38978 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_third_party_deposits_default() != 64655 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_third_party_deposits_sample() != 43880 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_third_party_deposits_sample_other() != 8564 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_header_sample() != 8723 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_header_sample_other() != 30841 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_intent_hash_from_string() != 22744 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_intent_hash_sample() != 57397 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_intent_hash_sample_other() != 46815 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_intent_sample() != 10516 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_intent_sample_other() != 3301 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_from_instructions_string_and_blobs() != 47709 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_from_unvalidated_transaction_manifest() != 17099 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_sample() != 45718 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_sample_other() != 25709 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_v2_sample() != 55947 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_v2_sample_other() != 20151 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_trusted_contact_factor_source_contact_sample() != 60450 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_trusted_contact_factor_source_contact_sample_other() != 42014 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_trusted_contact_factor_source_from_address_and_contact() != 53920 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_trusted_contact_factor_source_sample() != 42422 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_trusted_contact_factor_source_sample_other() != 55827 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_u30() != 20628 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_u30_sample() != 63676 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_u30_sample_other() != 28749 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_u31() != 39523 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_u31_sample() != 46555 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_u31_sample_other() != 18620 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unhardened() != 42441 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unhardened_from_global_key_space() != 17468 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unhardened_from_local_key_space() != 50711 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unhardened_sample() != 4452 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unhardened_sample_other() != 27835 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unsecured_entity_control_sample() != 42906 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unsecured_entity_control_sample_other() != 44199 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened() != 9613 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened_from_global_key_space() != 34523 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened_from_local_key_space() != 30021 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened_sample() != 22376 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened_sample_other() != 47742 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unsecurified_sample() != 15554 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unsecurified_sample_other() != 42044 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unvalidated_subintent_manifest_from_subintent_manifest() != 11045 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unvalidated_subintent_manifest_sample() != 19014 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unvalidated_subintent_manifest_sample_other() != 53324 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unvalidated_transaction_manifest_from_transaction_manifest() != 60621 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unvalidated_transaction_manifest_sample() != 3220 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_unvalidated_transaction_manifest_sample_other() != 19780 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_validator_address() != 7330 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_validator_address_random() != 17013 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_validator_address_sample_mainnet() != 1396 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_validator_address_sample_mainnet_other() != 60189 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_validator_address_sample_stokenet() != 6182 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_validator_address_sample_stokenet_other() != 59150 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_vault_address() != 46722 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_vault_address_random() != 5168 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_vault_address_sample_mainnet_fungible() != 59977 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_vault_address_sample_mainnet_non_fungible() != 3625 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_vault_address_sample_stokenet_fungible() != 35213 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_vault_address_sample_stokenet_non_fungible() != 40105 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_vector_image_type_sample() != 35643 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_vector_image_type_sample_other() != 15343 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_wallet_interaction_version_current() != 1306 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_wallet_interaction_wallet_account_from_json_bytes() != 8284 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_wallet_interaction_wallet_account_sample() != 28027 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_wallet_interaction_wallet_account_sample_other() != 51107 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_pre_authorization_response_items() != 17346 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_response_from_json_bytes() != 18042 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_response_sample() != 43665 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_response_sample_other() != 7044 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_non_fungible_global_id_formatted() != 44995 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_non_fungible_global_id_to_string() != 65080 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_non_fungible_local_id_as_str() != 50881 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_non_fungible_local_id_formatted() != 4044 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_non_fungible_local_id_to_user_facing_string() != 11431 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_non_fungible_resource_address_as_resource_address() != 12948 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_non_fungible_resource_address_bech32_address() != 2811 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_non_fungible_resource_address_map_to_network() != 21266 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_non_fungible_resource_address_network_id() != 64552 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_non_fungible_resource_indicator_get_ids() != 31374 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_nonce_get_value() != 20204 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_notarized_transaction_compile() != 55244 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_notary_signature_get_signature() != 60673 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_p2_p_link_to_json_bytes() != 41559 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_p2p_link_id() != 17801 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_p2p_links_to_json_bytes() != 51949 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_package_address_bech32_address() != 48492 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_package_address_formatted() != 56063 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_package_address_map_to_network() != 54791 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_package_address_network_id() != 60577 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_persona_data_entry_email_address_to_json_string() != 24703 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_persona_data_entry_name_to_json_bytes() != 805 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_persona_data_entry_phone_number_to_json_string() != 38100 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_persona_data_identified_email_address_sample() != 27809 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_persona_data_identified_email_address_sample_other() != 10133 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_persona_data_identified_name_sample() != 41542 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_persona_data_identified_name_sample_other() != 34961 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_persona_data_identified_phone_number_sample() != 42681 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_persona_data_identified_phone_number_sample_other() != 35376 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_pool_address_bech32_address() != 21761 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_pool_address_formatted() != 34929 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_pool_address_kind() != 51942 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_pool_address_map_to_network() != 48099 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_pool_address_network_id() != 15737 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_profile_analyze_contents_of_file() != 20322 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_profile_encrypt_with_password() != 56521 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_profile_network_details_for_authorized_dapp() != 61437 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_profile_to_debug_string() != 61571 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_profile_to_json_string() != 5512 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_profile_to_string() != 33764 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_public_key_is_valid_signature_for_hash() != 41618 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_public_key_to_bytes() != 19143 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_public_key_to_hex() != 1275 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_radix_connect_mobile_session_request_to_json_bytes() != 26170 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_radix_connect_password_message_hash() != 9189 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_radix_connect_password_to_json_string() != 43380 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_radix_connect_purpose_to_json_string() != 38744 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_requested_quantity_is_fulfilled_by_ids() != 17442 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_requested_quantity_is_valid() != 38263 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_requested_quantity_to_json_bytes() != 42575 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_resource_address_bech32_address() != 38422 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_resource_address_formatted() != 46367 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_resource_address_is_fungible() != 43471 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_resource_address_is_non_fungible() != 12360 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_resource_address_map_to_network() != 45971 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_resource_address_network_id() != 50531 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_resource_indicator_get_address() != 46615 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_resource_preferences_get_hidden_resources() != 50458 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_resource_preferences_hide_resource() != 58708 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_resource_preferences_unhide_resource() != 26953 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_resource_specifier_get_address() != 40064 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_rust_logger_get_all_filters() != 59506 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_rust_logger_get_all_levels() != 43258 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_rust_logger_get_level() != 10949 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_rust_logger_log_at_every_level() != 22900 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_rust_logger_set_level() != 59954 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_s_l_i_p10_curve_to_json_string() != 1233 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_saved_gateways_get_all_elements() != 41603 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_secp256k1_public_key_to_bytes() != 2554 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_secp256k1_public_key_to_bytes_uncompressed() != 53526 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_secp256k1_public_key_to_hex() != 38671 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_secp256k1_signature_to_string() != 25123 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_secure_storage_access_error_kind_is_manual_cancellation() != 13245 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_secure_storage_key_identifier() != 23785 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_securified_index_in_global_key_space() != 28299 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_securified_index_in_local_key_space() != 30746 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_security_questions_all() != 28899 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_security_questions_factor_source_decrypt() != 46069 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_signature_to_bytes() != 49339 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_signature_to_string() != 22537 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_signature_with_public_key_get_public_key() != 61540 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_signature_with_public_key_get_signature() != 9548 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_signature_with_public_key_is_valid() != 107 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_signed_intent_hash() != 57483 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_signed_transaction_intent_hash_formatted() != 46686 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_slip10_curve_to_string() != 16528 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_subintent_compile() != 36589 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_subintent_hash() != 30194 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_subintent_hash_formatted() != 8825 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_subintent_manifest_blobs() != 54689 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_subintent_manifest_involved_pool_addresses() != 17290 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_subintent_manifest_involved_resource_addresses() != 4954 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_subintent_manifest_network_id() != 60401 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_subintent_manifest_string() != 25812 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_subintent_manifest_summary() != 62264 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_fee_preset() != 28642 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_intent_compile() != 55102 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_intent_hash() != 16628 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_intent_hash_formatted() != 35303 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_blobs() != 28370 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_blobs_v2() != 40013 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_instructions_string() != 59187 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_involved_pool_addresses() != 8119 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_involved_pool_addresses_v2() != 10052 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_involved_resource_addresses() != 33205 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_involved_resource_addresses_v2() != 44106 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_network_id() != 55152 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_network_id_v2() != 22658 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_string() != 62178 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_string_v2() != 20762 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_summary() != 11082 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_transaction_manifest_summary_v2() != 46195 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_trim_security_questions_answer() != 42711 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_u30_get_value() != 3367 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_u31_get_value() != 47596 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_unhardened_index_in_global_key_space() != 4106 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_unhardened_index_in_local_key_space() != 2650 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_unsafe_storage_key_identifier() != 18953 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_unsecurified_hardened_index_in_global_key_space() != 33739 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_unsecurified_hardened_index_in_local_key_space() != 42716 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_validator_address_bech32_address() != 3797 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_validator_address_formatted() != 45882 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_validator_address_map_to_network() != 18403 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_validator_address_network_id() != 28726 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_vault_address_bech32_address() != 3749 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_vault_address_formatted() != 13985 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_vault_address_is_fungible() != 5264 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_vault_address_is_non_fungible() != 49838 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_vault_address_map_to_network() != 13880 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_vault_address_network_id() != 60554 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_vector_image_type_data_url_type() != 50668 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_vector_image_type_url_extension() != 62035 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_wallet_interaction_wallet_account_to_json_bytes() != 29015 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_wallet_to_dapp_interaction_response_to_json_bytes() != 1762 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_func_xrd_address_of_network() != 54555 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_entropyproviderdriver_generate_secure_random_bytes() != 51230 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_eventbusdriver_handle_event_notification() != 37374 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_filesystemdriver_writable_app_dir_path() != 57918 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_filesystemdriver_load_from_file() != 11291 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_filesystemdriver_save_to_file() != 18612 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_filesystemdriver_delete_file() != 25840 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_homecardsmanager_bootstrap() != 47142 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_homecardsmanager_card_dismissed() != 31707 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_homecardsmanager_deferred_deep_link_received() != 22766 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_homecardsmanager_wallet_created() != 15111 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_homecardsmanager_wallet_reset() != 17223 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_homecardsmanager_wallet_restored() != 49189 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_homecardsobserver_handle_cards_update() != 48356 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_homecardsstorage_save_cards() != 64998 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_homecardsstorage_load_cards() != 44873 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_hostinfodriver_host_os() != 34576 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_hostinfodriver_host_device_name() != 1219 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_hostinfodriver_host_app_version() != 51009 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_hostinfodriver_host_device_model() != 4852 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_loggingdriver_log() != 28387 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_networkingdriver_execute_network_request() != 8345 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_profilestatechangedriver_handle_profile_state_change() != 36142 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_radixconnectmobile_handle_deep_link() != 23213 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_radixconnectmobile_send_dapp_interaction_response() != 58808 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_radixconnectmobilesessionstorage_save_session() != 63828 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_radixconnectmobilesessionstorage_load_session() != 30386 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos___debug_factor_instances_in_cache() != 37483 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_account_by_address() != 619 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_accounts_for_display_on_current_network() != 24966 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_accounts_on_current_network() != 29433 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_add_account() != 33935 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_add_accounts() != 9567 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_add_factor_source() != 9597 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_add_factor_sources() != 28512 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_add_security_structure_of_factor_sources() != 33450 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_analyse_pre_auth_preview() != 17171 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_analyse_transaction_preview() != 50307 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_batch_create_many_accounts_then_save_once() != 21395 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_batch_create_unsaved_accounts() != 5785 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_bdfs() != 58200 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_change_current_gateway() != 14313 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_check_accounts_deleted_on_ledger() != 10981 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_create_and_save_new_account() != 32186 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_create_and_save_new_mainnet_account() != 59433 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_create_and_save_new_unnamed_mainnet_account() != 24175 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_create_delete_account_manifest() != 35129 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_create_device_factor_source() != 46144 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_create_subintent() != 23952 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_create_unsaved_account() != 49171 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_create_unsaved_mainnet_account() != 18380 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_create_unsaved_unnamed_mainnet_account() != 43992 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_current_gateway() != 45208 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_current_network() != 40067 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_current_network_id() != 22921 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_debug_add_all_sample_factors() != 44243 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_delete_wallet() != 60762 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_factor_sources() != 27882 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_gateways() != 28077 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_has_any_account_on_any_network() != 7423 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_has_any_network() != 24883 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_import_profile() != 20464 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_import_wallet() != 47395 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_load_private_device_factor_source_by_id() != 39798 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_mark_account_as_hidden() != 1751 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_mark_account_as_tombstoned() != 45283 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_new_wallet() != 14573 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_new_wallet_with_derived_bdfs() != 32247 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_poll_pre_authorization_status() != 9304 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_poll_transaction_status() != 29304 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_profile() != 35851 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_resolve_host_id() != 28341 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_resolve_host_info() != 9680 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_security_structure_of_factor_sources_from_security_structure_of_factor_source_ids() != 60940 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_security_structures_of_factor_source_ids() != 9607 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_security_structures_of_factor_sources() != 63952 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_set_profile() != 55953 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_submit_transaction() != 2200 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_sync_accounts_deleted_on_ledger() != 59978 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_update_account() != 47089 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_sargonos_update_factor_source() != 2367 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_securestoragedriver_load_data() != 39397 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_securestoragedriver_save_data() != 9973 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_securestoragedriver_delete_data_for_key() != 20787 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_unsafestoragedriver_load_data() != 30438 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_unsafestoragedriver_save_data() != 2167 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_method_unsafestoragedriver_delete_data_for_key() != 25005 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_constructor_bios_new() != 55108 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_constructor_drivers_new() != 24202 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_constructor_ffiurl_new() != 15814 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_constructor_homecardsmanager_new() != 28682 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_constructor_radixconnectmobile_new() != 51477 {
		return InitializationResult.apiChecksumMismatch
	}
	if uniffi_sargon_uniffi_checksum_constructor_sargonos_boot() != 21616 {
		return InitializationResult.apiChecksumMismatch
	}

	uniffiCallbackInitEntropyProviderDriver()
	uniffiCallbackInitEventBusDriver()
	uniffiCallbackInitFileSystemDriver()
	uniffiCallbackInitHomeCardsObserver()
	uniffiCallbackInitHomeCardsStorage()
	uniffiCallbackInitHostInfoDriver()
	uniffiCallbackInitLoggingDriver()
	uniffiCallbackInitNetworkingDriver()
	uniffiCallbackInitProfileStateChangeDriver()
	uniffiCallbackInitRadixConnectMobileSessionStorage()
	uniffiCallbackInitSecureStorageDriver()
	uniffiCallbackInitUnsafeStorageDriver()
	return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
	switch initializationResult {
	case .ok:
		break
	case .contractVersionMismatch:
		fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
	case .apiChecksumMismatch:
		fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
	}
}

// swiftlint:enable all
