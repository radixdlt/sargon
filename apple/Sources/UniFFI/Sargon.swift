// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(SargonFFI)
    import SargonFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len: 0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_sargon_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_sargon_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_UNEXPECTED_ERROR:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void
) {
    do {
        try writeReturn(makeCall())
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void,
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

    func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        map.count
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

private struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

private struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return try Data(readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

public protocol BiosProtocol: AnyObject {}

open class Bios:
    BiosProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_bios(self.pointer, $0) }
    }

    public convenience init(drivers: Drivers) {
        let pointer =
            try! rustCall {
                uniffi_sargon_fn_constructor_bios_new(
                    FfiConverterTypeDrivers.lower(drivers), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_bios(pointer, $0) }
    }
}

public struct FfiConverterTypeBios: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bios

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bios {
        return Bios(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bios) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bios {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bios, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeBios_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bios {
    return try FfiConverterTypeBios.lift(pointer)
}

public func FfiConverterTypeBios_lower(_ value: Bios) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBios.lower(value)
}

public protocol DriversProtocol: AnyObject {}

open class Drivers:
    DriversProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_drivers(self.pointer, $0) }
    }

    public convenience init(networking: NetworkingDriver, secureStorage: SecureStorageDriver, entropyProvider: EntropyProviderDriver, hostInfo: HostInfoDriver, logging: LoggingDriver, eventBus: EventBusDriver, fileSystem: FileSystemDriver, unsafeStorage: UnsafeStorageDriver, profileStateChangeDriver: ProfileStateChangeDriver) {
        let pointer =
            try! rustCall {
                uniffi_sargon_fn_constructor_drivers_new(
                    FfiConverterTypeNetworkingDriver.lower(networking),
                    FfiConverterTypeSecureStorageDriver.lower(secureStorage),
                    FfiConverterTypeEntropyProviderDriver.lower(entropyProvider),
                    FfiConverterTypeHostInfoDriver.lower(hostInfo),
                    FfiConverterTypeLoggingDriver.lower(logging),
                    FfiConverterTypeEventBusDriver.lower(eventBus),
                    FfiConverterTypeFileSystemDriver.lower(fileSystem),
                    FfiConverterTypeUnsafeStorageDriver.lower(unsafeStorage),
                    FfiConverterTypeProfileStateChangeDriver.lower(profileStateChangeDriver), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_drivers(pointer, $0) }
    }
}

public struct FfiConverterTypeDrivers: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Drivers

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Drivers {
        return Drivers(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Drivers) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Drivers {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Drivers, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeDrivers_lift(_ pointer: UnsafeMutableRawPointer) throws -> Drivers {
    return try FfiConverterTypeDrivers.lift(pointer)
}

public func FfiConverterTypeDrivers_lower(_ value: Drivers) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDrivers.lower(value)
}

public protocol EntropyProviderDriver: AnyObject {
    func generateSecureRandomBytes() -> Entropy32Bytes
}

open class EntropyProviderDriverImpl:
    EntropyProviderDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_entropyproviderdriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_entropyproviderdriver(pointer, $0) }
    }

    open func generateSecureRandomBytes() -> Entropy32Bytes {
        return try! FfiConverterTypeEntropy32Bytes.lift(try! rustCall {
            uniffi_sargon_fn_method_entropyproviderdriver_generate_secure_random_bytes(self.uniffiClonePointer(), $0)
        })
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceEntropyProviderDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceEntropyProviderDriver = .init(
        generateSecureRandomBytes: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Entropy32Bytes in
                guard let uniffiObj = try? FfiConverterTypeEntropyProviderDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.generateSecureRandomBytes(
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeEntropy32Bytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeEntropyProviderDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EntropyProviderDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitEntropyProviderDriver() {
    uniffi_sargon_fn_init_callback_vtable_entropyproviderdriver(&UniffiCallbackInterfaceEntropyProviderDriver.vtable)
}

public struct FfiConverterTypeEntropyProviderDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<EntropyProviderDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EntropyProviderDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EntropyProviderDriver {
        return EntropyProviderDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EntropyProviderDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntropyProviderDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EntropyProviderDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeEntropyProviderDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> EntropyProviderDriver {
    return try FfiConverterTypeEntropyProviderDriver.lift(pointer)
}

public func FfiConverterTypeEntropyProviderDriver_lower(_ value: EntropyProviderDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEntropyProviderDriver.lower(value)
}

/**
 * A driver which received and asynchronously *handles* event notifications
 * emitted by the `SargonOS`. Letting the method be async allows for Rust side
 * to wait for host clients to complete something which might require user
 * attention. E.g. presentation of an alert and await user input.
 *
 * Due to limitations in UniFFI and lack of first class citizen support of
 * async sequences (like we have in Swift) we cannot export an accessor of the
 * received events here. Instead implementing types on the FFI side SHOULD
 * create the driver as a singleton object they can reference later and build
 * async streams in that implementing type.
 *
 * See Swifts EventBus implementation for more details.
 */
public protocol EventBusDriver: AnyObject {
    /**
     * Asynchronously *handles* event notifications
     * emitted by the `SargonOS`. Letting the method be async allows for Rust side
     * to wait for host clients to complete something which might require user
     * attention. E.g. presentation of an alert and await user input.
     */
    func handleEventNotification(eventNotification: EventNotification) async
}

/**
 * A driver which received and asynchronously *handles* event notifications
 * emitted by the `SargonOS`. Letting the method be async allows for Rust side
 * to wait for host clients to complete something which might require user
 * attention. E.g. presentation of an alert and await user input.
 *
 * Due to limitations in UniFFI and lack of first class citizen support of
 * async sequences (like we have in Swift) we cannot export an accessor of the
 * received events here. Instead implementing types on the FFI side SHOULD
 * create the driver as a singleton object they can reference later and build
 * async streams in that implementing type.
 *
 * See Swifts EventBus implementation for more details.
 */
open class EventBusDriverImpl:
    EventBusDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_eventbusdriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_eventbusdriver(pointer, $0) }
    }

    /**
     * Asynchronously *handles* event notifications
     * emitted by the `SargonOS`. Letting the method be async allows for Rust side
     * to wait for host clients to complete something which might require user
     * attention. E.g. presentation of an alert and await user input.
     */
    open func handleEventNotification(eventNotification: EventNotification) async {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_eventbusdriver_handle_event_notification(
                        self.uniffiClonePointer(),
                        FfiConverterTypeEventNotification.lower(eventNotification)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: nil
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceEventBusDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceEventBusDriver = .init(
        handleEventNotification: { (
            uniffiHandle: UInt64,
            eventNotification: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeEventBusDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.handleEventNotification(
                    eventNotification: FfiConverterTypeEventNotification.lift(eventNotification)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeEventBusDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EventBusDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitEventBusDriver() {
    uniffi_sargon_fn_init_callback_vtable_eventbusdriver(&UniffiCallbackInterfaceEventBusDriver.vtable)
}

public struct FfiConverterTypeEventBusDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<EventBusDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventBusDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBusDriver {
        return EventBusDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventBusDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventBusDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventBusDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeEventBusDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBusDriver {
    return try FfiConverterTypeEventBusDriver.lift(pointer)
}

public func FfiConverterTypeEventBusDriver_lower(_ value: EventBusDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventBusDriver.lower(value)
}

/**
 * A wrapper around `Url` that allows us to safely deal with Urls generated on hosts.
 *
 * Context: We have defined a custom type conversion between Rust's `Url` and the hosts analogues.
 * However, a Url could be considered valid on host but not on Rust. For example, Swift allows to build a Url
 * from string `"invalid input"`, while Rust doesn't.
 *
 * Therefore, if a given Rust function expects a `Url` as param and is sent one from host side which is invalid,
 * the code will panic. However, if we send the wrapper instead, we make sure the conversion is safely done on the
 * host side, dealing with the failing conversion properly rather than panicking.
 */
public protocol FfiUrlProtocol: AnyObject {}

/**
 * A wrapper around `Url` that allows us to safely deal with Urls generated on hosts.
 *
 * Context: We have defined a custom type conversion between Rust's `Url` and the hosts analogues.
 * However, a Url could be considered valid on host but not on Rust. For example, Swift allows to build a Url
 * from string `"invalid input"`, while Rust doesn't.
 *
 * Therefore, if a given Rust function expects a `Url` as param and is sent one from host side which is invalid,
 * the code will panic. However, if we send the wrapper instead, we make sure the conversion is safely done on the
 * host side, dealing with the failing conversion properly rather than panicking.
 */
open class FfiUrl:
    CustomDebugStringConvertible,
    CustomStringConvertible,
    Equatable,
    Hashable,
    FfiUrlProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_ffiurl(self.pointer, $0) }
    }

    public convenience init(urlPath: String) throws {
        let pointer =
            try rustCallWithError(FfiConverterTypeCommonError.lift) {
                uniffi_sargon_fn_constructor_ffiurl_new(
                    FfiConverterString.lower(urlPath), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_ffiurl(pointer, $0) }
    }

    open var debugDescription: String {
        return try! FfiConverterString.lift(
            try! rustCall {
                uniffi_sargon_fn_method_ffiurl_uniffi_trait_debug(self.uniffiClonePointer(), $0)
            }
        )
    }

    open var description: String {
        return try! FfiConverterString.lift(
            try! rustCall {
                uniffi_sargon_fn_method_ffiurl_uniffi_trait_display(self.uniffiClonePointer(), $0)
            }
        )
    }

    public static func == (self: FfiUrl, other: FfiUrl) -> Bool {
        return try! FfiConverterBool.lift(
            try! rustCall {
                uniffi_sargon_fn_method_ffiurl_uniffi_trait_eq_eq(self.uniffiClonePointer(),
                                                                  FfiConverterTypeFfiUrl.lower(other), $0)
            }
        )
    }

    open func hash(into hasher: inout Hasher) {
        let val = try! FfiConverterUInt64.lift(
            try! rustCall {
                uniffi_sargon_fn_method_ffiurl_uniffi_trait_hash(self.uniffiClonePointer(), $0)
            }
        )
        hasher.combine(val)
    }
}

public struct FfiConverterTypeFfiUrl: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiUrl

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUrl {
        return FfiUrl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiUrl) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUrl {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiUrl, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiUrl_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUrl {
    return try FfiConverterTypeFfiUrl.lift(pointer)
}

public func FfiConverterTypeFfiUrl_lower(_ value: FfiUrl) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiUrl.lower(value)
}

public protocol FileSystemDriver: AnyObject {
    func loadFromFile(path: String) async throws -> BagOfBytes?

    func saveToFile(path: String, data: BagOfBytes) async throws

    func deleteFile(path: String) async throws
}

open class FileSystemDriverImpl:
    FileSystemDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_filesystemdriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_filesystemdriver(pointer, $0) }
    }

    open func loadFromFile(path: String) async throws -> BagOfBytes? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_filesystemdriver_load_from_file(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(path)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func saveToFile(path: String, data: BagOfBytes) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_filesystemdriver_save_to_file(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(path), FfiConverterTypeBagOfBytes.lower(data)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func deleteFile(path: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_filesystemdriver_delete_file(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(path)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceFileSystemDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFileSystemDriver = .init(
        loadFromFile: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadFromFile(
                    path: FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        saveToFile: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            data: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveToFile(
                    path: FfiConverterString.lift(path),
                    data: FfiConverterTypeBagOfBytes.lift(data)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteFile: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteFile(
                    path: FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeFileSystemDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FileSystemDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFileSystemDriver() {
    uniffi_sargon_fn_init_callback_vtable_filesystemdriver(&UniffiCallbackInterfaceFileSystemDriver.vtable)
}

public struct FfiConverterTypeFileSystemDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<FileSystemDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FileSystemDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FileSystemDriver {
        return FileSystemDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FileSystemDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileSystemDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FileSystemDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFileSystemDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> FileSystemDriver {
    return try FfiConverterTypeFileSystemDriver.lift(pointer)
}

public func FfiConverterTypeFileSystemDriver_lower(_ value: FileSystemDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFileSystemDriver.lower(value)
}

/**
 * An HTTP client for consuming the Radix  Gateway API ([docs]).
 *
 * The implementing FFI clients can then consume the Radix Gateway API to e.g.
 * fetch the XRD balance of an account address or submit a signed transaction.
 *
 * [docs]: https://radix-babylon-gateway-api.redoc.ly/
 */
public protocol GatewayClientProtocol: AnyObject {
    /**
     * Returns the current `Epoch` of the Radix Network of the provided gateway.
     */
    func currentEpoch() async throws -> Epoch

    /**
     * Returns the "EncodedReceipt" by running a "dry run" of a
     * transaction - a preview of the transaction. The "EncodedReceipt" is
     * required by the [`execution_summary` method](TransactionManifest::execution_summary)
     * on [`TransactionManifest`].
     */
    func dryRunTransaction(intent: TransactionIntent, signerPublicKeys: [PublicKey]) async throws -> BagOfBytes

    /**
     * Submits a signed transaction payload to the network.
     *
     * Returns `Ok(IntentHash)` if the transaction was submitted and not a duplicate.
     */
    func submitNotarizedTransaction(notarizedTransaction: NotarizedTransaction) async throws -> IntentHash

    /**
     * Fetched the XRD balance of account of `address`, returns `None` if
     * it has no balance.
     */
    func xrdBalanceOfAccount(address: AccountAddress) async throws -> Decimal192?

    /**
     * Fetched the XRD balance of account of `address`, returns `0` if
     * it has no balance.
     */
    func xrdBalanceOfAccountOrZero(address: AccountAddress) async throws -> Decimal192
}

/**
 * An HTTP client for consuming the Radix  Gateway API ([docs]).
 *
 * The implementing FFI clients can then consume the Radix Gateway API to e.g.
 * fetch the XRD balance of an account address or submit a signed transaction.
 *
 * [docs]: https://radix-babylon-gateway-api.redoc.ly/
 */
open class GatewayClient:
    GatewayClientProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_gatewayclient(self.pointer, $0) }
    }

    /**
     * Constructs a new `GatewayClient` with a NetworkingDriver for a specified
     * network, by looking up an Radix DLT provided Gateway on that network.
     *
     * # Panics
     * Panics if Radix DLT does not provide a Gateway for the specified
     * `network_id` - e.g. will panic if you specify `NetworkID::Simulator` (duh).
     */
    public convenience init(networkingDriver: NetworkingDriver, networkId: NetworkId) {
        let pointer =
            try! rustCall {
                uniffi_sargon_fn_constructor_gatewayclient_new(
                    FfiConverterTypeNetworkingDriver.lower(networkingDriver),
                    FfiConverterTypeNetworkID.lower(networkId), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_gatewayclient(pointer, $0) }
    }

    /**
     * Constructs a new `GatewayClient` with a NetworkingDriver for a specified
     * `Gateway`.
     */
    public static func withGateway(networkingDriver: NetworkingDriver, gateway: Gateway) -> GatewayClient {
        return try! FfiConverterTypeGatewayClient.lift(try! rustCall {
            uniffi_sargon_fn_constructor_gatewayclient_with_gateway(
                FfiConverterTypeNetworkingDriver.lower(networkingDriver),
                FfiConverterTypeGateway.lower(gateway), $0
            )
        })
    }

    /**
     * Returns the current `Epoch` of the Radix Network of the provided gateway.
     */
    open func currentEpoch() async throws -> Epoch {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_gatewayclient_current_epoch(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_u64,
                completeFunc: ffi_sargon_rust_future_complete_u64,
                freeFunc: ffi_sargon_rust_future_free_u64,
                liftFunc: FfiConverterTypeEpoch.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Returns the "EncodedReceipt" by running a "dry run" of a
     * transaction - a preview of the transaction. The "EncodedReceipt" is
     * required by the [`execution_summary` method](TransactionManifest::execution_summary)
     * on [`TransactionManifest`].
     */
    open func dryRunTransaction(intent: TransactionIntent, signerPublicKeys: [PublicKey]) async throws -> BagOfBytes {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_gatewayclient_dry_run_transaction(
                        self.uniffiClonePointer(),
                        FfiConverterTypeTransactionIntent.lower(intent), FfiConverterSequenceTypePublicKey.lower(signerPublicKeys)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeBagOfBytes.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Submits a signed transaction payload to the network.
     *
     * Returns `Ok(IntentHash)` if the transaction was submitted and not a duplicate.
     */
    open func submitNotarizedTransaction(notarizedTransaction: NotarizedTransaction) async throws -> IntentHash {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_gatewayclient_submit_notarized_transaction(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNotarizedTransaction.lower(notarizedTransaction)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeIntentHash.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Fetched the XRD balance of account of `address`, returns `None` if
     * it has no balance.
     */
    open func xrdBalanceOfAccount(address: AccountAddress) async throws -> Decimal192? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_gatewayclient_xrd_balance_of_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeAccountAddress.lower(address)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionTypeDecimal192.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Fetched the XRD balance of account of `address`, returns `0` if
     * it has no balance.
     */
    open func xrdBalanceOfAccountOrZero(address: AccountAddress) async throws -> Decimal192 {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_gatewayclient_xrd_balance_of_account_or_zero(
                        self.uniffiClonePointer(),
                        FfiConverterTypeAccountAddress.lower(address)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeDecimal192.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

public struct FfiConverterTypeGatewayClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GatewayClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GatewayClient {
        return GatewayClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GatewayClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GatewayClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GatewayClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeGatewayClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> GatewayClient {
    return try FfiConverterTypeGatewayClient.lift(pointer)
}

public func FfiConverterTypeGatewayClient_lower(_ value: GatewayClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGatewayClient.lower(value)
}

/**
 * Manages the home cards by handling storage, parsing, and updating operations.
 * Call `bootstrap` before invoking any other public functions.
 */
public protocol HomeCardsManagerProtocol: AnyObject {
    /**
     * Initializes `HomeCards` by loading from storage.
     * This function should be called before invoking any other public functions.
     * Notifies `HomeCardsObserver`.
     */
    func bootstrap() async throws

    /**
     * Dismisses a specified `HomeCard` by removing it from `HomeCardsStorage`.
     * Notifies `HomeCardsObserver`.
     */
    func cardDismissed(card: HomeCard) async throws

    /**
     * Handles a deferred deep link by parsing it and saving the generated `HomeCards` to `HomeCardsStorage`.
     * `HomeCard::ContinueRadQuest` if found in the link parsing result, replaces `HomeCard::StartRadQuest`.
     * Notifies `HomeCardsObserver`.
     */
    func deferredDeepLinkReceived(encodedValue: String) async throws

    /**
     * Initializes and saves to storage default `HomeCards`.
     * Marks the wallet creation and populates the set of cards required for a new wallet.
     * Notifies `HomeCardsObserver`.
     */
    func walletCreated() async throws

    /**
     * Clears the home cards from the `HomeCardsStorage`.
     * Notifies `HomeCardsObserver`.
     */
    func walletReset() async throws

    /**
     * Marks the wallet restoration.
     * Ensures only the expected `HomeCards` remain in `HomeCardsStorage` - currently none.
     * Notifies `HomeCardsObserver`.
     */
    func walletRestored() async throws
}

/**
 * Manages the home cards by handling storage, parsing, and updating operations.
 * Call `bootstrap` before invoking any other public functions.
 */
open class HomeCardsManager:
    HomeCardsManagerProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_homecardsmanager(self.pointer, $0) }
    }

    public convenience init(networkingDriver: NetworkingDriver, networkId: NetworkId, cardsStorage: HomeCardsStorage, observer: HomeCardsObserver) {
        let pointer =
            try! rustCall {
                uniffi_sargon_fn_constructor_homecardsmanager_new(
                    FfiConverterTypeNetworkingDriver.lower(networkingDriver),
                    FfiConverterTypeNetworkID.lower(networkId),
                    FfiConverterTypeHomeCardsStorage.lower(cardsStorage),
                    FfiConverterTypeHomeCardsObserver.lower(observer), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_homecardsmanager(pointer, $0) }
    }

    /**
     * Initializes `HomeCards` by loading from storage.
     * This function should be called before invoking any other public functions.
     * Notifies `HomeCardsObserver`.
     */
    open func bootstrap() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_homecardsmanager_bootstrap(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Dismisses a specified `HomeCard` by removing it from `HomeCardsStorage`.
     * Notifies `HomeCardsObserver`.
     */
    open func cardDismissed(card: HomeCard) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_homecardsmanager_card_dismissed(
                        self.uniffiClonePointer(),
                        FfiConverterTypeHomeCard.lower(card)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Handles a deferred deep link by parsing it and saving the generated `HomeCards` to `HomeCardsStorage`.
     * `HomeCard::ContinueRadQuest` if found in the link parsing result, replaces `HomeCard::StartRadQuest`.
     * Notifies `HomeCardsObserver`.
     */
    open func deferredDeepLinkReceived(encodedValue: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_homecardsmanager_deferred_deep_link_received(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(encodedValue)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Initializes and saves to storage default `HomeCards`.
     * Marks the wallet creation and populates the set of cards required for a new wallet.
     * Notifies `HomeCardsObserver`.
     */
    open func walletCreated() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_homecardsmanager_wallet_created(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Clears the home cards from the `HomeCardsStorage`.
     * Notifies `HomeCardsObserver`.
     */
    open func walletReset() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_homecardsmanager_wallet_reset(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Marks the wallet restoration.
     * Ensures only the expected `HomeCards` remain in `HomeCardsStorage` - currently none.
     * Notifies `HomeCardsObserver`.
     */
    open func walletRestored() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_homecardsmanager_wallet_restored(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

public struct FfiConverterTypeHomeCardsManager: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeCardsManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsManager {
        return HomeCardsManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeCardsManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCardsManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeCardsManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeHomeCardsManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsManager {
    return try FfiConverterTypeHomeCardsManager.lift(pointer)
}

public func FfiConverterTypeHomeCardsManager_lower(_ value: HomeCardsManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeCardsManager.lower(value)
}

/**
 * Trait for observing home cards updates.
 * Defines a method for handling updates to home cards.
 */
public protocol HomeCardsObserver: AnyObject {
    /**
     * Handles updates to the home cards.
     */
    func handleCardsUpdate(cards: [HomeCard])
}

/**
 * Trait for observing home cards updates.
 * Defines a method for handling updates to home cards.
 */
open class HomeCardsObserverImpl:
    HomeCardsObserver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_homecardsobserver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_homecardsobserver(pointer, $0) }
    }

    /**
     * Handles updates to the home cards.
     */
    open func handleCardsUpdate(cards: [HomeCard]) { try! rustCall {
        uniffi_sargon_fn_method_homecardsobserver_handle_cards_update(self.uniffiClonePointer(),
                                                                      FfiConverterSequenceTypeHomeCard.lower(cards), $0)
    }
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceHomeCardsObserver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceHomeCardsObserver = .init(
        handleCardsUpdate: { (
            uniffiHandle: UInt64,
            cards: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterTypeHomeCardsObserver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.handleCardsUpdate(
                    cards: FfiConverterSequenceTypeHomeCard.lift(cards)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeHomeCardsObserver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HomeCardsObserver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitHomeCardsObserver() {
    uniffi_sargon_fn_init_callback_vtable_homecardsobserver(&UniffiCallbackInterfaceHomeCardsObserver.vtable)
}

public struct FfiConverterTypeHomeCardsObserver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<HomeCardsObserver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeCardsObserver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsObserver {
        return HomeCardsObserverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeCardsObserver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCardsObserver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeCardsObserver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeHomeCardsObserver_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsObserver {
    return try FfiConverterTypeHomeCardsObserver.lift(pointer)
}

public func FfiConverterTypeHomeCardsObserver_lower(_ value: HomeCardsObserver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeCardsObserver.lower(value)
}

/**
 * A trait for storing and loading home cards.
 * Defines asynchronous methods for saving and loading encoded home cards.
 */
public protocol HomeCardsStorage: AnyObject {
    /**
     * Saves the encoded home cards to the storage.
     */
    func saveCards(encodedCards: BagOfBytes) async throws

    /**
     * Loads the encoded home cards from the storage.
     */
    func loadCards() async throws -> BagOfBytes?
}

/**
 * A trait for storing and loading home cards.
 * Defines asynchronous methods for saving and loading encoded home cards.
 */
open class HomeCardsStorageImpl:
    HomeCardsStorage
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_homecardsstorage(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_homecardsstorage(pointer, $0) }
    }

    /**
     * Saves the encoded home cards to the storage.
     */
    open func saveCards(encodedCards: BagOfBytes) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_homecardsstorage_save_cards(
                        self.uniffiClonePointer(),
                        FfiConverterTypeBagOfBytes.lower(encodedCards)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Loads the encoded home cards from the storage.
     */
    open func loadCards() async throws -> BagOfBytes? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_homecardsstorage_load_cards(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceHomeCardsStorage {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceHomeCardsStorage = .init(
        saveCards: { (
            uniffiHandle: UInt64,
            encodedCards: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeHomeCardsStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveCards(
                    encodedCards: FfiConverterTypeBagOfBytes.lift(encodedCards)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        loadCards: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeHomeCardsStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadCards(
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeHomeCardsStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HomeCardsStorage: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitHomeCardsStorage() {
    uniffi_sargon_fn_init_callback_vtable_homecardsstorage(&UniffiCallbackInterfaceHomeCardsStorage.vtable)
}

public struct FfiConverterTypeHomeCardsStorage: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<HomeCardsStorage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeCardsStorage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsStorage {
        return HomeCardsStorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeCardsStorage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCardsStorage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeCardsStorage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeHomeCardsStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsStorage {
    return try FfiConverterTypeHomeCardsStorage.lift(pointer)
}

public func FfiConverterTypeHomeCardsStorage_lower(_ value: HomeCardsStorage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeCardsStorage.lower(value)
}

public protocol HostInfoDriver: AnyObject {
    /**
     * The **current** device's operating system, e.g. "iOS 17.4.1"
     */
    func hostOs() async -> HostOs

    /**
     * The name of the host device (iPhone/Android), e.g. "My Red iPhone"
     */
    func hostDeviceName() async -> String

    /**
     * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1".
     */
    func hostAppVersion() async -> String

    /**
     * The model of the host device (iPhone/Android), .e.g. "iPhone SE 2nd Gen"
     */
    func hostDeviceModel() async -> String
}

open class HostInfoDriverImpl:
    HostInfoDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_hostinfodriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_hostinfodriver(pointer, $0) }
    }

    /**
     * The **current** device's operating system, e.g. "iOS 17.4.1"
     */
    open func hostOs() async -> HostOs {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_hostinfodriver_host_os(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeHostOS.lift,
                errorHandler: nil
            )
    }

    /**
     * The name of the host device (iPhone/Android), e.g. "My Red iPhone"
     */
    open func hostDeviceName() async -> String {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_hostinfodriver_host_device_name(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterString.lift,
                errorHandler: nil
            )
    }

    /**
     * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1".
     */
    open func hostAppVersion() async -> String {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_hostinfodriver_host_app_version(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterString.lift,
                errorHandler: nil
            )
    }

    /**
     * The model of the host device (iPhone/Android), .e.g. "iPhone SE 2nd Gen"
     */
    open func hostDeviceModel() async -> String {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_hostinfodriver_host_device_model(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterString.lift,
                errorHandler: nil
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceHostInfoDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceHostInfoDriver = .init(
        hostOs: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> HostOs in
                guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hostOs(
                )
            }

            let uniffiHandleSuccess = { (returnValue: HostOs) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeHostOS.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        hostDeviceName: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hostDeviceName(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        hostAppVersion: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hostAppVersion(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        hostDeviceModel: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hostDeviceModel(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeHostInfoDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HostInfoDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitHostInfoDriver() {
    uniffi_sargon_fn_init_callback_vtable_hostinfodriver(&UniffiCallbackInterfaceHostInfoDriver.vtable)
}

public struct FfiConverterTypeHostInfoDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<HostInfoDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HostInfoDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HostInfoDriver {
        return HostInfoDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HostInfoDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostInfoDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HostInfoDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeHostInfoDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> HostInfoDriver {
    return try FfiConverterTypeHostInfoDriver.lift(pointer)
}

public func FfiConverterTypeHostInfoDriver_lower(_ value: HostInfoDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHostInfoDriver.lower(value)
}

/**
 * * Trace
 * * Debug
 * * Info
 * * Warning
 * * Error
 */
public protocol LoggingDriver: AnyObject {
    func log(level: LogLevel, msg: String)
}

/**
 * * Trace
 * * Debug
 * * Info
 * * Warning
 * * Error
 */
open class LoggingDriverImpl:
    LoggingDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_loggingdriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_loggingdriver(pointer, $0) }
    }

    open func log(level: LogLevel, msg: String) { try! rustCall {
        uniffi_sargon_fn_method_loggingdriver_log(self.uniffiClonePointer(),
                                                  FfiConverterTypeLogLevel.lower(level),
                                                  FfiConverterString.lower(msg), $0)
    }
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceLoggingDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceLoggingDriver = .init(
        log: { (
            uniffiHandle: UInt64,
            level: RustBuffer,
            msg: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterTypeLoggingDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.log(
                    level: FfiConverterTypeLogLevel.lift(level),
                    msg: FfiConverterString.lift(msg)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeLoggingDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface LoggingDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitLoggingDriver() {
    uniffi_sargon_fn_init_callback_vtable_loggingdriver(&UniffiCallbackInterfaceLoggingDriver.vtable)
}

public struct FfiConverterTypeLoggingDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<LoggingDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LoggingDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LoggingDriver {
        return LoggingDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LoggingDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoggingDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LoggingDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeLoggingDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> LoggingDriver {
    return try FfiConverterTypeLoggingDriver.lift(pointer)
}

public func FfiConverterTypeLoggingDriver_lower(_ value: LoggingDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLoggingDriver.lower(value)
}

/**
 * Trait for executing network requests, to be implemented by hosts, so that
 * Sargon can make network requests with some HTTP client.
 */
public protocol NetworkingDriver: AnyObject {
    /**
     * Method invoked by Sargon Rust side, telling an implementing type to
     * execute a `NetworkRequest` and pass the Result back to Sargon Rust side.
     *
     * Either: `Err` or `Ok(NetworkResponse)`.
     */
    func executeNetworkRequest(request: NetworkRequest) async throws -> NetworkResponse
}

/**
 * Trait for executing network requests, to be implemented by hosts, so that
 * Sargon can make network requests with some HTTP client.
 */
open class NetworkingDriverImpl:
    NetworkingDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_networkingdriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_networkingdriver(pointer, $0) }
    }

    /**
     * Method invoked by Sargon Rust side, telling an implementing type to
     * execute a `NetworkRequest` and pass the Result back to Sargon Rust side.
     *
     * Either: `Err` or `Ok(NetworkResponse)`.
     */
    open func executeNetworkRequest(request: NetworkRequest) async throws -> NetworkResponse {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_networkingdriver_execute_network_request(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNetworkRequest.lower(request)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeNetworkResponse.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceNetworkingDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceNetworkingDriver = .init(
        executeNetworkRequest: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> NetworkResponse in
                guard let uniffiObj = try? FfiConverterTypeNetworkingDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.executeNetworkRequest(
                    request: FfiConverterTypeNetworkRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: NetworkResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeNetworkResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeNetworkingDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface NetworkingDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitNetworkingDriver() {
    uniffi_sargon_fn_init_callback_vtable_networkingdriver(&UniffiCallbackInterfaceNetworkingDriver.vtable)
}

public struct FfiConverterTypeNetworkingDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<NetworkingDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NetworkingDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkingDriver {
        return NetworkingDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NetworkingDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkingDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NetworkingDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeNetworkingDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkingDriver {
    return try FfiConverterTypeNetworkingDriver.lift(pointer)
}

public func FfiConverterTypeNetworkingDriver_lower(_ value: NetworkingDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNetworkingDriver.lower(value)
}

public protocol ProfileStateChangeDriver: AnyObject {
    func handleProfileStateChange(changedProfileState: ProfileState) async
}

open class ProfileStateChangeDriverImpl:
    ProfileStateChangeDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_profilestatechangedriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_profilestatechangedriver(pointer, $0) }
    }

    open func handleProfileStateChange(changedProfileState: ProfileState) async {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_profilestatechangedriver_handle_profile_state_change(
                        self.uniffiClonePointer(),
                        FfiConverterTypeProfileState.lower(changedProfileState)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: nil
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceProfileStateChangeDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceProfileStateChangeDriver = .init(
        handleProfileStateChange: { (
            uniffiHandle: UInt64,
            changedProfileState: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeProfileStateChangeDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.handleProfileStateChange(
                    changedProfileState: FfiConverterTypeProfileState.lift(changedProfileState)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeProfileStateChangeDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ProfileStateChangeDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitProfileStateChangeDriver() {
    uniffi_sargon_fn_init_callback_vtable_profilestatechangedriver(&UniffiCallbackInterfaceProfileStateChangeDriver.vtable)
}

public struct FfiConverterTypeProfileStateChangeDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<ProfileStateChangeDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ProfileStateChangeDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ProfileStateChangeDriver {
        return ProfileStateChangeDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ProfileStateChangeDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileStateChangeDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ProfileStateChangeDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeProfileStateChangeDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> ProfileStateChangeDriver {
    return try FfiConverterTypeProfileStateChangeDriver.lift(pointer)
}

public func FfiConverterTypeProfileStateChangeDriver_lower(_ value: ProfileStateChangeDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeProfileStateChangeDriver.lower(value)
}

public protocol ProfileStateHolderProtocol: AnyObject {}

open class ProfileStateHolder:
    ProfileStateHolderProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_profilestateholder(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_profilestateholder(pointer, $0) }
    }
}

public struct FfiConverterTypeProfileStateHolder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ProfileStateHolder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ProfileStateHolder {
        return ProfileStateHolder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ProfileStateHolder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileStateHolder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ProfileStateHolder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeProfileStateHolder_lift(_ pointer: UnsafeMutableRawPointer) throws -> ProfileStateHolder {
    return try FfiConverterTypeProfileStateHolder.lift(pointer)
}

public func FfiConverterTypeProfileStateHolder_lower(_ value: ProfileStateHolder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeProfileStateHolder.lower(value)
}

/**
 * The Radix Connect Mobile client that handles the interaction with dApps on mobile through deepLinks.
 */
public protocol RadixConnectMobileProtocol: AnyObject {
    /**
     * Try to parse the deep link and create a RadixConnectMobileDappRequest.
     * This is a stateful operation as it will create an in flight session, that needs to be validated by the user.
     */
    func handleDeepLink(url: String) async throws -> RadixConnectMobileSessionRequest

    /**
     * Send the Host's response to the dApp.
     * This is a stateful operation as it will save the session in the secure storage if the user validated the session.
     */
    func sendDappInteractionResponse(walletResponse: RadixConnectMobileWalletResponse) async throws
}

/**
 * The Radix Connect Mobile client that handles the interaction with dApps on mobile through deepLinks.
 */
open class RadixConnectMobile:
    RadixConnectMobileProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_radixconnectmobile(self.pointer, $0) }
    }

    public convenience init(networkingDriver: NetworkingDriver, sessionStorage: RadixConnectMobileSessionStorage) {
        let pointer =
            try! rustCall {
                uniffi_sargon_fn_constructor_radixconnectmobile_new(
                    FfiConverterTypeNetworkingDriver.lower(networkingDriver),
                    FfiConverterTypeRadixConnectMobileSessionStorage.lower(sessionStorage), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_radixconnectmobile(pointer, $0) }
    }

    /**
     * Try to parse the deep link and create a RadixConnectMobileDappRequest.
     * This is a stateful operation as it will create an in flight session, that needs to be validated by the user.
     */
    open func handleDeepLink(url: String) async throws -> RadixConnectMobileSessionRequest {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_radixconnectmobile_handle_deep_link(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(url)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeRadixConnectMobileSessionRequest.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Send the Host's response to the dApp.
     * This is a stateful operation as it will save the session in the secure storage if the user validated the session.
     */
    open func sendDappInteractionResponse(walletResponse: RadixConnectMobileWalletResponse) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_radixconnectmobile_send_dapp_interaction_response(
                        self.uniffiClonePointer(),
                        FfiConverterTypeRadixConnectMobileWalletResponse.lower(walletResponse)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

public struct FfiConverterTypeRadixConnectMobile: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RadixConnectMobile

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobile {
        return RadixConnectMobile(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RadixConnectMobile) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobile {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RadixConnectMobile, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeRadixConnectMobile_lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobile {
    return try FfiConverterTypeRadixConnectMobile.lift(pointer)
}

public func FfiConverterTypeRadixConnectMobile_lower(_ value: RadixConnectMobile) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRadixConnectMobile.lower(value)
}

/**
 * A trait for storing and loading Radix Connect Mobile sessions.
 */
public protocol RadixConnectMobileSessionStorage: AnyObject {
    /**
     * Saves the session to the storage identified by the session id.
     */
    func saveSession(sessionId: SessionId, encodedSession: BagOfBytes) async throws

    /**
     * Loads the session from the storage identified by the session id.
     */
    func loadSession(sessionId: SessionId) async throws -> BagOfBytes?
}

/**
 * A trait for storing and loading Radix Connect Mobile sessions.
 */
open class RadixConnectMobileSessionStorageImpl:
    RadixConnectMobileSessionStorage
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_radixconnectmobilesessionstorage(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_radixconnectmobilesessionstorage(pointer, $0) }
    }

    /**
     * Saves the session to the storage identified by the session id.
     */
    open func saveSession(sessionId: SessionId, encodedSession: BagOfBytes) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_radixconnectmobilesessionstorage_save_session(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSessionID.lower(sessionId), FfiConverterTypeBagOfBytes.lower(encodedSession)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Loads the session from the storage identified by the session id.
     */
    open func loadSession(sessionId: SessionId) async throws -> BagOfBytes? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_radixconnectmobilesessionstorage_load_session(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSessionID.lower(sessionId)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceRadixConnectMobileSessionStorage {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRadixConnectMobileSessionStorage = .init(
        saveSession: { (
            uniffiHandle: UInt64,
            sessionId: RustBuffer,
            encodedSession: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeRadixConnectMobileSessionStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveSession(
                    sessionId: FfiConverterTypeSessionID.lift(sessionId),
                    encodedSession: FfiConverterTypeBagOfBytes.lift(encodedSession)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        loadSession: { (
            uniffiHandle: UInt64,
            sessionId: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeRadixConnectMobileSessionStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadSession(
                    sessionId: FfiConverterTypeSessionID.lift(sessionId)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeRadixConnectMobileSessionStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RadixConnectMobileSessionStorage: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRadixConnectMobileSessionStorage() {
    uniffi_sargon_fn_init_callback_vtable_radixconnectmobilesessionstorage(&UniffiCallbackInterfaceRadixConnectMobileSessionStorage.vtable)
}

public struct FfiConverterTypeRadixConnectMobileSessionStorage: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<RadixConnectMobileSessionStorage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RadixConnectMobileSessionStorage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobileSessionStorage {
        return RadixConnectMobileSessionStorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RadixConnectMobileSessionStorage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileSessionStorage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RadixConnectMobileSessionStorage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeRadixConnectMobileSessionStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobileSessionStorage {
    return try FfiConverterTypeRadixConnectMobileSessionStorage.lift(pointer)
}

public func FfiConverterTypeRadixConnectMobileSessionStorage_lower(_ value: RadixConnectMobileSessionStorage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRadixConnectMobileSessionStorage.lower(value)
}

/**
 * The Sargon "Operating System" is the root "manager" of the Sargon library
 * which holds an in-memory Profile and a collection of "clients" which are
 * created from "drivers" which the hosts (iOS/Android wallets) "installs"
 * during app launch, enabling the  Sargon "Operating System" to e.g read/write
 * to secure storage and make use of the network connection of the iPhone/Android
 * phone.
 */
public protocol SargonOsProtocol: AnyObject {
    /**
     * Looks up the account by account address, returns Err if the account is
     * unknown, will return a hidden account if queried for.
     */
    func accountByAddress(address: AccountAddress) throws -> Account

    /**
     * Returns the non-hidden accounts on the current network as `AccountForDisplay`
     */
    func accountsForDisplayOnCurrentNetwork() throws -> [AccountForDisplay]

    /**
     * Returns the non-hidden accounts on the current network, empty if no accounts
     * on the network
     */
    func accountsOnCurrentNetwork() throws -> [Account]

    /**
     * Add the `account` to active profile and **saves** the updated profile to
     * secure storage.
     *
     * Returns `Ok(())` if the `account` was new and successfully added. If
     * saving failed or if the account was already present in Profile, an
     * error is returned.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
     */
    func addAccount(account: Account) async throws

    /**
     * Adds the `accounts` to active profile and **saves** the updated profile to
     * secure storage.
     *
     * Returns `Ok(())` if the `accounts` were new and successfully added. If
     * saving failed or if the accounts were already present in Profile, an
     * error is returned.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
     */
    func addAccounts(accounts: [Account]) async throws

    /**
     * Returns `Ok(false)` if the Profile already contained a factor source with the
     * same id (Profile unchanged occurred).
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceAdded }`
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
     * if the newly added FactorSource is a new **main** flag, then we remove the
     * main flag from the old BDFS.
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    func addFactorSource(factorSource: FactorSource) async throws -> Bool

    /**
     * Adds all of the provided `factor_sources` to Profile in one single go.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourcesAdded }`
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
     * if the newly added FactorSource is a new **main** flag, then we remove the
     * main flag from the old BDFS.
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    func addFactorSources(factorSources: [FactorSource]) async throws -> [FactorSourceId]

    /**
     * Adds the security structureof factor sources to Profile if none with the
     * same ID already exists, and if all factors it references are found in Profile.
     *
     * If `structure` references a FactorSource by ID which is unknown to Profile,
     * `Err(CommonError::StructureReferencesUnknownFactorSource)` is returned.
     *
     * If Profile already contains a structure with the same ID, `Ok(false)` is
     * returned **without** modifying the existing one.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::SecurityStructureAdded { id } }`
     */
    func addSecurityStructureOfFactorSources(structure: SecurityStructureOfFactorSources) async throws -> Bool

    /**
     * The account names will be `<name_prefix> <index>`
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    func batchCreateManyAccountsThenSaveOnce(count: UInt16, networkId: NetworkId, namePrefix: String) async throws

    /**
     * Creates many new non securified accounts **WITHOUT** add them to Profile, using the *main* "Babylon"
     * `DeviceFactorSource` and the "next" indices for this FactorSource as derivation paths.
     *
     * If you want to add them to Profile, call `add_accounts(accounts)`
     *
     * # Emits Event
     * Emits `Event::FactorSourceUpdated { id: FactorSourceID }` since the date in
     * `factor_source.common.last_used` is updated.
     */
    func batchCreateUnsavedAccounts(networkId: NetworkId, count: UInt16, namePrefix: String) async throws -> [Account]

    /**
     * Returns the "main Babylon" `DeviceFactorSource` of the current account as
     * a `DeviceFactorSource`.
     */
    func bdfs() throws -> DeviceFactorSource

    /**
     * Changes the current Gateway to `to`, if it is not already the current.
     * Returns the outcome of the change, if we did in fact switch (current != to),
     * and if we switched then if `to` is new.
     *
     * If we did in fact change current, an `EventNotification` is emitted.
     *
     * # Emits Event
     * Emits `Event::GatewayChangedCurrent` if we changed the gateway.
     */
    func changeCurrentGateway(to: Gateway) async throws -> ChangeGatewayOutcome

    /**
     * Create a new Account and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    func createAndSaveNewAccount(networkId: NetworkId, name: DisplayName) async throws -> Account

    /**
     * Create a new mainnet Account and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    func createAndSaveNewMainnetAccount(name: DisplayName) async throws -> Account

    /**
     * Create a new mainnet Account named "Unnamed" and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    func createAndSaveNewUnnamedMainnetAccount() async throws -> Account

    /**
     * Creates a new unsaved DeviceFactorSource from the provided `mnemonic_with_passphrase`,
     * either a "BDFS" or an "Olympia" one.
     */
    func createDeviceFactorSource(mnemonicWithPassphrase: MnemonicWithPassphrase, factorType: DeviceFactorSourceType) async throws -> DeviceFactorSource

    /**
     * Creates a new non securified account **WITHOUT** adding it to Profile,
     * using the *main* "Babylon" `DeviceFactorSource` and the "next" index for
     * this FactorSource as derivation path.
     *
     * If you want to add it to Profile, call `os.add_account(account)`.
     *
     * # Emits Event
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage, since the `last_used_on` date
     * of the factor source has been updated.
     *
     * Also emits `EventNotification::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
     */
    func createUnsavedAccount(networkId: NetworkId, name: DisplayName) async throws -> Account

    /**
     * Uses `create_unsaved_account` specifying `NetworkID::Mainnet`.
     */
    func createUnsavedMainnetAccount(name: DisplayName) async throws -> Account

    /**
     * Creates a new unsaved mainnet account named "Unnamed {N}", where `N` is the
     * index of the next account for the BDFS.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`
     */
    func createUnsavedUnnamedMainnetAccount() async throws -> Account

    /**
     * The current gateway host client is using, which affects `current_network_id`.
     * All Network Requests reading from Radix ledger and submission of new
     * transactions will go the the Radix Network of the current Gateway.
     */
    func currentGateway() throws -> Gateway

    /**
     * Returns the `ProfileNetwork` corresponding to the network ID set by the
     * current gateway.
     */
    func currentNetwork() throws -> ProfileNetwork

    /**
     * Returns the id of the Network of the current Gateway set in AppPreferences
     * of the active Profile. This is the canonical value of "current network",
     * which affects which accounts host clients display to end user and to
     * which network transactions are submitted, amongst other behaviors.
     */
    func currentNetworkId() throws -> NetworkId

    func debugAddAllSampleFactors() async throws -> [FactorSourceId]

    func deleteWallet() async throws

    /**
     * Returns all the factor sources
     */
    func factorSources() throws -> [FactorSource]

    /**
     * Returns the `gateways` values of the current Profile.
     */
    func gateways() throws -> SavedGateways

    /**
     * Has **any** account, at all, including hidden, on any network.
     */
    func hasAnyAccountOnAnyNetwork() throws -> Bool

    /**
     * Checks if current Profile contains any `ProfileNetwork`s.
     */
    func hasAnyNetwork() throws -> Bool

    /**
     * Imports the `profile`, claims it, set it as active (current) one and
     * saves it into secure storage (with the claim modification).
     *
     * # Emits Event
     * Emits `EventNotification::new(Event::ProfileImported))` event if successful.
     */
    func importProfile(profile: Profile) async throws

    func importWallet(profile: Profile, bdfsSkipped: Bool) async throws

    /**
     * Loads a `MnemonicWithPassphrase` with the `id` of `device_factor_source`,
     * from SecureStorage, and returns a `PrivateHierarchicalDeterministicFactorSource`
     * built from both.
     *
     * Useful for when you will want to sign transactions or derive public keys for
     * creation of new entities.
     *
     * Returns `Err` if loading or decoding of `MnemonicWithPassphrase` from
     * SecureStorage fails.
     */
    func loadPrivateDeviceFactorSourceById(id: FactorSourceIdFromHash) async throws -> PrivateHierarchicalDeterministicFactorSource

    func newWallet() async throws

    func profile() throws -> Profile

    func resolveHostId() async throws -> HostId

    func resolveHostInfo() async -> HostInfo

    /**
     * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
     * in profile.
     */
    func securityStructureOfFactorSourcesFromSecurityStructureOfFactorSourceIds(structureOfIds: SecurityStructureOfFactorSourceIDs) throws -> SecurityStructureOfFactorSources

    /**
     * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
     * in profile.
     */
    func securityStructuresOfFactorSourceIds() throws -> [SecurityStructureOfFactorSourceIDs]

    /**
     * Returns all the SecurityStructuresOfFactorSources,
     * by trying to map FactorSourceID level -> FactorSource Level
     */
    func securityStructuresOfFactorSources() throws -> [SecurityStructureOfFactorSources]

    func setProfile(profile: Profile) async throws

    /**
     * Updates the account `updated` by mutating current profile and persisting
     * the change to secure storage. Throws `UnknownAccount` error if the account
     * is not found.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountUpdated { address } }`
     */
    func updateAccount(updated: Account) async throws

    /**
     * Updates the factor source `updated` by mutating current profile and persisting
     * the change to secure storage. Throws `UpdateFactorSourceMutateFailed` error if the
     * factor source is not found.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
     */
    func updateFactorSource(updated: FactorSource) async throws
}

/**
 * The Sargon "Operating System" is the root "manager" of the Sargon library
 * which holds an in-memory Profile and a collection of "clients" which are
 * created from "drivers" which the hosts (iOS/Android wallets) "installs"
 * during app launch, enabling the  Sargon "Operating System" to e.g read/write
 * to secure storage and make use of the network connection of the iPhone/Android
 * phone.
 */
open class SargonOs:
    SargonOsProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_sargonos(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_sargonos(pointer, $0) }
    }

    public static func boot(bios: Bios) async -> SargonOs {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_constructor_sargonos_boot(FfiConverterTypeBios.lower(bios)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_pointer,
                completeFunc: ffi_sargon_rust_future_complete_pointer,
                freeFunc: ffi_sargon_rust_future_free_pointer,
                liftFunc: FfiConverterTypeSargonOS.lift,
                errorHandler: nil
            )
    }

    /**
     * Looks up the account by account address, returns Err if the account is
     * unknown, will return a hidden account if queried for.
     */
    open func accountByAddress(address: AccountAddress) throws -> Account {
        return try FfiConverterTypeAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_account_by_address(self.uniffiClonePointer(),
                                                                FfiConverterTypeAccountAddress.lower(address), $0)
        })
    }

    /**
     * Returns the non-hidden accounts on the current network as `AccountForDisplay`
     */
    open func accountsForDisplayOnCurrentNetwork() throws -> [AccountForDisplay] {
        return try FfiConverterSequenceTypeAccountForDisplay.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_accounts_for_display_on_current_network(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the non-hidden accounts on the current network, empty if no accounts
     * on the network
     */
    open func accountsOnCurrentNetwork() throws -> [Account] {
        return try FfiConverterSequenceTypeAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_accounts_on_current_network(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Add the `account` to active profile and **saves** the updated profile to
     * secure storage.
     *
     * Returns `Ok(())` if the `account` was new and successfully added. If
     * saving failed or if the account was already present in Profile, an
     * error is returned.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
     */
    open func addAccount(account: Account) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_add_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeAccount.lower(account)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Adds the `accounts` to active profile and **saves** the updated profile to
     * secure storage.
     *
     * Returns `Ok(())` if the `accounts` were new and successfully added. If
     * saving failed or if the accounts were already present in Profile, an
     * error is returned.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
     */
    open func addAccounts(accounts: [Account]) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_add_accounts(
                        self.uniffiClonePointer(),
                        FfiConverterSequenceTypeAccount.lower(accounts)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Returns `Ok(false)` if the Profile already contained a factor source with the
     * same id (Profile unchanged occurred).
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceAdded }`
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
     * if the newly added FactorSource is a new **main** flag, then we remove the
     * main flag from the old BDFS.
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    open func addFactorSource(factorSource: FactorSource) async throws -> Bool {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_add_factor_source(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFactorSource.lower(factorSource)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_i8,
                completeFunc: ffi_sargon_rust_future_complete_i8,
                freeFunc: ffi_sargon_rust_future_free_i8,
                liftFunc: FfiConverterBool.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Adds all of the provided `factor_sources` to Profile in one single go.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourcesAdded }`
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
     * if the newly added FactorSource is a new **main** flag, then we remove the
     * main flag from the old BDFS.
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    open func addFactorSources(factorSources: [FactorSource]) async throws -> [FactorSourceId] {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_add_factor_sources(
                        self.uniffiClonePointer(),
                        FfiConverterSequenceTypeFactorSource.lower(factorSources)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterSequenceTypeFactorSourceID.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Adds the security structureof factor sources to Profile if none with the
     * same ID already exists, and if all factors it references are found in Profile.
     *
     * If `structure` references a FactorSource by ID which is unknown to Profile,
     * `Err(CommonError::StructureReferencesUnknownFactorSource)` is returned.
     *
     * If Profile already contains a structure with the same ID, `Ok(false)` is
     * returned **without** modifying the existing one.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::SecurityStructureAdded { id } }`
     */
    open func addSecurityStructureOfFactorSources(structure: SecurityStructureOfFactorSources) async throws -> Bool {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_add_security_structure_of_factor_sources(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSecurityStructureOfFactorSources.lower(structure)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_i8,
                completeFunc: ffi_sargon_rust_future_complete_i8,
                freeFunc: ffi_sargon_rust_future_free_i8,
                liftFunc: FfiConverterBool.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * The account names will be `<name_prefix> <index>`
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    open func batchCreateManyAccountsThenSaveOnce(count: UInt16, networkId: NetworkId, namePrefix: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_batch_create_many_accounts_then_save_once(
                        self.uniffiClonePointer(),
                        FfiConverterUInt16.lower(count), FfiConverterTypeNetworkID.lower(networkId), FfiConverterString.lower(namePrefix)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Creates many new non securified accounts **WITHOUT** add them to Profile, using the *main* "Babylon"
     * `DeviceFactorSource` and the "next" indices for this FactorSource as derivation paths.
     *
     * If you want to add them to Profile, call `add_accounts(accounts)`
     *
     * # Emits Event
     * Emits `Event::FactorSourceUpdated { id: FactorSourceID }` since the date in
     * `factor_source.common.last_used` is updated.
     */
    open func batchCreateUnsavedAccounts(networkId: NetworkId, count: UInt16, namePrefix: String) async throws -> [Account] {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_batch_create_unsaved_accounts(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNetworkID.lower(networkId), FfiConverterUInt16.lower(count), FfiConverterString.lower(namePrefix)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterSequenceTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Returns the "main Babylon" `DeviceFactorSource` of the current account as
     * a `DeviceFactorSource`.
     */
    open func bdfs() throws -> DeviceFactorSource {
        return try FfiConverterTypeDeviceFactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_bdfs(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Changes the current Gateway to `to`, if it is not already the current.
     * Returns the outcome of the change, if we did in fact switch (current != to),
     * and if we switched then if `to` is new.
     *
     * If we did in fact change current, an `EventNotification` is emitted.
     *
     * # Emits Event
     * Emits `Event::GatewayChangedCurrent` if we changed the gateway.
     */
    open func changeCurrentGateway(to: Gateway) async throws -> ChangeGatewayOutcome {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_change_current_gateway(
                        self.uniffiClonePointer(),
                        FfiConverterTypeGateway.lower(to)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeChangeGatewayOutcome.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Create a new Account and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    open func createAndSaveNewAccount(networkId: NetworkId, name: DisplayName) async throws -> Account {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_create_and_save_new_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNetworkID.lower(networkId), FfiConverterTypeDisplayName.lower(name)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Create a new mainnet Account and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    open func createAndSaveNewMainnetAccount(name: DisplayName) async throws -> Account {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_create_and_save_new_mainnet_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeDisplayName.lower(name)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Create a new mainnet Account named "Unnamed" and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    open func createAndSaveNewUnnamedMainnetAccount() async throws -> Account {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_create_and_save_new_unnamed_mainnet_account(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Creates a new unsaved DeviceFactorSource from the provided `mnemonic_with_passphrase`,
     * either a "BDFS" or an "Olympia" one.
     */
    open func createDeviceFactorSource(mnemonicWithPassphrase: MnemonicWithPassphrase, factorType: DeviceFactorSourceType) async throws -> DeviceFactorSource {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_create_device_factor_source(
                        self.uniffiClonePointer(),
                        FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase), FfiConverterTypeDeviceFactorSourceType.lower(factorType)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeDeviceFactorSource.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Creates a new non securified account **WITHOUT** adding it to Profile,
     * using the *main* "Babylon" `DeviceFactorSource` and the "next" index for
     * this FactorSource as derivation path.
     *
     * If you want to add it to Profile, call `os.add_account(account)`.
     *
     * # Emits Event
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage, since the `last_used_on` date
     * of the factor source has been updated.
     *
     * Also emits `EventNotification::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
     */
    open func createUnsavedAccount(networkId: NetworkId, name: DisplayName) async throws -> Account {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_create_unsaved_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNetworkID.lower(networkId), FfiConverterTypeDisplayName.lower(name)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Uses `create_unsaved_account` specifying `NetworkID::Mainnet`.
     */
    open func createUnsavedMainnetAccount(name: DisplayName) async throws -> Account {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_create_unsaved_mainnet_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeDisplayName.lower(name)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Creates a new unsaved mainnet account named "Unnamed {N}", where `N` is the
     * index of the next account for the BDFS.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`
     */
    open func createUnsavedUnnamedMainnetAccount() async throws -> Account {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_create_unsaved_unnamed_mainnet_account(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * The current gateway host client is using, which affects `current_network_id`.
     * All Network Requests reading from Radix ledger and submission of new
     * transactions will go the the Radix Network of the current Gateway.
     */
    open func currentGateway() throws -> Gateway {
        return try FfiConverterTypeGateway.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_current_gateway(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the `ProfileNetwork` corresponding to the network ID set by the
     * current gateway.
     */
    open func currentNetwork() throws -> ProfileNetwork {
        return try FfiConverterTypeProfileNetwork.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_current_network(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the id of the Network of the current Gateway set in AppPreferences
     * of the active Profile. This is the canonical value of "current network",
     * which affects which accounts host clients display to end user and to
     * which network transactions are submitted, amongst other behaviors.
     */
    open func currentNetworkId() throws -> NetworkId {
        return try FfiConverterTypeNetworkID.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_current_network_id(self.uniffiClonePointer(), $0)
        })
    }

    open func debugAddAllSampleFactors() async throws -> [FactorSourceId] {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_debug_add_all_sample_factors(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterSequenceTypeFactorSourceID.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func deleteWallet() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_delete_wallet(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Returns all the factor sources
     */
    open func factorSources() throws -> [FactorSource] {
        return try FfiConverterSequenceTypeFactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_factor_sources(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the `gateways` values of the current Profile.
     */
    open func gateways() throws -> SavedGateways {
        return try FfiConverterTypeSavedGateways.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_gateways(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Has **any** account, at all, including hidden, on any network.
     */
    open func hasAnyAccountOnAnyNetwork() throws -> Bool {
        return try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_has_any_account_on_any_network(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Checks if current Profile contains any `ProfileNetwork`s.
     */
    open func hasAnyNetwork() throws -> Bool {
        return try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_has_any_network(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Imports the `profile`, claims it, set it as active (current) one and
     * saves it into secure storage (with the claim modification).
     *
     * # Emits Event
     * Emits `EventNotification::new(Event::ProfileImported))` event if successful.
     */
    open func importProfile(profile: Profile) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_import_profile(
                        self.uniffiClonePointer(),
                        FfiConverterTypeProfile.lower(profile)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func importWallet(profile: Profile, bdfsSkipped: Bool) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_import_wallet(
                        self.uniffiClonePointer(),
                        FfiConverterTypeProfile.lower(profile), FfiConverterBool.lower(bdfsSkipped)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Loads a `MnemonicWithPassphrase` with the `id` of `device_factor_source`,
     * from SecureStorage, and returns a `PrivateHierarchicalDeterministicFactorSource`
     * built from both.
     *
     * Useful for when you will want to sign transactions or derive public keys for
     * creation of new entities.
     *
     * Returns `Err` if loading or decoding of `MnemonicWithPassphrase` from
     * SecureStorage fails.
     */
    open func loadPrivateDeviceFactorSourceById(id: FactorSourceIdFromHash) async throws -> PrivateHierarchicalDeterministicFactorSource {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_load_private_device_factor_source_by_id(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFactorSourceIDFromHash.lower(id)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func newWallet() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_new_wallet(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func profile() throws -> Profile {
        return try FfiConverterTypeProfile.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_profile(self.uniffiClonePointer(), $0)
        })
    }

    open func resolveHostId() async throws -> HostId {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_resolve_host_id(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeHostId.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func resolveHostInfo() async -> HostInfo {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_resolve_host_info(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeHostInfo.lift,
                errorHandler: nil
            )
    }

    /**
     * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
     * in profile.
     */
    open func securityStructureOfFactorSourcesFromSecurityStructureOfFactorSourceIds(structureOfIds: SecurityStructureOfFactorSourceIDs) throws -> SecurityStructureOfFactorSources {
        return try FfiConverterTypeSecurityStructureOfFactorSources.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_security_structure_of_factor_sources_from_security_structure_of_factor_source_ids(self.uniffiClonePointer(),
                                                                                                                               FfiConverterTypeSecurityStructureOfFactorSourceIDs.lower(structureOfIds), $0)
        })
    }

    /**
     * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
     * in profile.
     */
    open func securityStructuresOfFactorSourceIds() throws -> [SecurityStructureOfFactorSourceIDs] {
        return try FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_security_structures_of_factor_source_ids(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns all the SecurityStructuresOfFactorSources,
     * by trying to map FactorSourceID level -> FactorSource Level
     */
    open func securityStructuresOfFactorSources() throws -> [SecurityStructureOfFactorSources] {
        return try FfiConverterSequenceTypeSecurityStructureOfFactorSources.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_fn_method_sargonos_security_structures_of_factor_sources(self.uniffiClonePointer(), $0)
        })
    }

    open func setProfile(profile: Profile) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_set_profile(
                        self.uniffiClonePointer(),
                        FfiConverterTypeProfile.lower(profile)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Updates the account `updated` by mutating current profile and persisting
     * the change to secure storage. Throws `UnknownAccount` error if the account
     * is not found.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountUpdated { address } }`
     */
    open func updateAccount(updated: Account) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_update_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeAccount.lower(updated)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Updates the factor source `updated` by mutating current profile and persisting
     * the change to secure storage. Throws `UpdateFactorSourceMutateFailed` error if the
     * factor source is not found.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
     */
    open func updateFactorSource(updated: FactorSource) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_sargonos_update_factor_source(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFactorSource.lower(updated)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

public struct FfiConverterTypeSargonOS: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SargonOs

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SargonOs {
        return SargonOs(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SargonOs) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonOs {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SargonOs, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeSargonOS_lift(_ pointer: UnsafeMutableRawPointer) throws -> SargonOs {
    return try FfiConverterTypeSargonOS.lift(pointer)
}

public func FfiConverterTypeSargonOS_lower(_ value: SargonOs) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSargonOS.lower(value)
}

public protocol SecureStorageDriver: AnyObject {
    func loadData(key: SecureStorageKey) async throws -> BagOfBytes?

    func saveData(key: SecureStorageKey, data: BagOfBytes) async throws

    func deleteDataForKey(key: SecureStorageKey) async throws
}

open class SecureStorageDriverImpl:
    SecureStorageDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_securestoragedriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_securestoragedriver(pointer, $0) }
    }

    open func loadData(key: SecureStorageKey) async throws -> BagOfBytes? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_securestoragedriver_load_data(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSecureStorageKey.lower(key)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func saveData(key: SecureStorageKey, data: BagOfBytes) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_securestoragedriver_save_data(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSecureStorageKey.lower(key), FfiConverterTypeBagOfBytes.lower(data)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func deleteDataForKey(key: SecureStorageKey) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_securestoragedriver_delete_data_for_key(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSecureStorageKey.lower(key)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceSecureStorageDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSecureStorageDriver = .init(
        loadData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadData(
                    key: FfiConverterTypeSecureStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        saveData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            data: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveData(
                    key: FfiConverterTypeSecureStorageKey.lift(key),
                    data: FfiConverterTypeBagOfBytes.lift(data)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteDataForKey: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteDataForKey(
                    key: FfiConverterTypeSecureStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeSecureStorageDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SecureStorageDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSecureStorageDriver() {
    uniffi_sargon_fn_init_callback_vtable_securestoragedriver(&UniffiCallbackInterfaceSecureStorageDriver.vtable)
}

public struct FfiConverterTypeSecureStorageDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<SecureStorageDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SecureStorageDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecureStorageDriver {
        return SecureStorageDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SecureStorageDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SecureStorageDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeSecureStorageDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecureStorageDriver {
    return try FfiConverterTypeSecureStorageDriver.lift(pointer)
}

public func FfiConverterTypeSecureStorageDriver_lower(_ value: SecureStorageDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSecureStorageDriver.lower(value)
}

public protocol UnsafeStorageDriver: AnyObject {
    func loadData(key: UnsafeStorageKey) async throws -> BagOfBytes?

    func saveData(key: UnsafeStorageKey, data: BagOfBytes) async throws

    func deleteDataForKey(key: UnsafeStorageKey) async throws
}

open class UnsafeStorageDriverImpl:
    UnsafeStorageDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_fn_clone_unsafestoragedriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_fn_free_unsafestoragedriver(pointer, $0) }
    }

    open func loadData(key: UnsafeStorageKey) async throws -> BagOfBytes? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_unsafestoragedriver_load_data(
                        self.uniffiClonePointer(),
                        FfiConverterTypeUnsafeStorageKey.lower(key)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func saveData(key: UnsafeStorageKey, data: BagOfBytes) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_unsafestoragedriver_save_data(
                        self.uniffiClonePointer(),
                        FfiConverterTypeUnsafeStorageKey.lower(key), FfiConverterTypeBagOfBytes.lower(data)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func deleteDataForKey(key: UnsafeStorageKey) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_fn_method_unsafestoragedriver_delete_data_for_key(
                        self.uniffiClonePointer(),
                        FfiConverterTypeUnsafeStorageKey.lower(key)
                    )
                },
                pollFunc: ffi_sargon_rust_future_poll_void,
                completeFunc: ffi_sargon_rust_future_complete_void,
                freeFunc: ffi_sargon_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceUnsafeStorageDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceUnsafeStorageDriver = .init(
        loadData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeUnsafeStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadData(
                    key: FfiConverterTypeUnsafeStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        saveData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            data: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeUnsafeStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveData(
                    key: FfiConverterTypeUnsafeStorageKey.lift(key),
                    data: FfiConverterTypeBagOfBytes.lift(data)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteDataForKey: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeUnsafeStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteDataForKey(
                    key: FfiConverterTypeUnsafeStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeUnsafeStorageDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface UnsafeStorageDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitUnsafeStorageDriver() {
    uniffi_sargon_fn_init_callback_vtable_unsafestoragedriver(&UniffiCallbackInterfaceUnsafeStorageDriver.vtable)
}

public struct FfiConverterTypeUnsafeStorageDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<UnsafeStorageDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnsafeStorageDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsafeStorageDriver {
        return UnsafeStorageDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnsafeStorageDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsafeStorageDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnsafeStorageDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeUnsafeStorageDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsafeStorageDriver {
    return try FfiConverterTypeUnsafeStorageDriver.lift(pointer)
}

public func FfiConverterTypeUnsafeStorageDriver_lower(_ value: UnsafeStorageDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnsafeStorageDriver.lower(value)
}

/**
 * Address to an AccessController that controls an Account or Identity (Persona),
 * it said entity has been "securified", e.g.:
 * `"accesscontroller_rdx1c0duj4lq0dc3cpl8qd420fpn5eckh8ljeysvjm894lyl5ja5yq6y5a"`
 *
 * When a user applies a SecurityStructureConfiguration for the first time on a
 * non-securified entity (and signs and submit the resulting TX) said entity is
 * "assigned" an AccessControllerAddress by the network.
 *
 * An `AccessControllerAddress` has the [Scrypto's `EntityType`][entt] `GlobalAccessController`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalAccessControllerAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L247-L248
 */
public struct AccessControllerAddress {
    fileprivate let secretMagic: RetAccessControllerAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetAccessControllerAddress) {
        self.secretMagic = secretMagic
    }
}

extension AccessControllerAddress: Sendable {}
extension AccessControllerAddress: Equatable, Hashable {
    public static func == (lhs: AccessControllerAddress, rhs: AccessControllerAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeAccessControllerAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccessControllerAddress {
        return
            try AccessControllerAddress(
                secretMagic: FfiConverterTypeRetAccessControllerAddress.read(from: &buf)
            )
    }

    public static func write(_ value: AccessControllerAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetAccessControllerAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeAccessControllerAddress_lift(_ buf: RustBuffer) throws -> AccessControllerAddress {
    return try FfiConverterTypeAccessControllerAddress.lift(buf)
}

public func FfiConverterTypeAccessControllerAddress_lower(_ value: AccessControllerAddress) -> RustBuffer {
    return FfiConverterTypeAccessControllerAddress.lower(value)
}

/**
 * A network unique account with a unique public address and a set of cryptographic
 * factors used to control it.
 *
 * Used to own and control assets on the radix network. Uniquely identified by an
 * account address, e.g.
 *
 * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
 *
 * But most commonly users see the address on its abbreviated form:
 *
 * `acco...nvjdwr`
 *
 * Accounts have a display name and an appearance id.
 *
 * An account can be either controlled by a "Babylon" DeviceFactorSource or a
 * Legacy one imported from Olympia, or a Ledger hardware wallet, which too might
 * have been imported from Olympia.
 */
public struct Account {
    /**
     * The ID of the network this account can be used with.
     */
    public var networkId: NetworkId
    /**
     * A globally unique identifier of this account, being a human readable
     * address of an account. Always starts with `"account_"``, for example:
     *
     * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
     *
     * Most commonly the user will see this address in its abbreviated
     * form which is:
     *
     * `acco...nvjdwr`
     *
     * No two addresses will ever be the same even for the same factor source
     * but on different networks, since the public keys controlling the
     * accounts depend on the network id.
     */
    public var address: AccountAddress
    /**
     * An off-ledger display name or description chosen by the user when she
     * created this account.
     */
    public var displayName: DisplayName
    /**
     * Security state of this account, either "securified" or not.
     */
    public var securityState: EntitySecurityState
    /**
     * The visual cue user learns to associated this account with, typically
     * a beautiful colorful gradient.
     */
    public var appearanceId: AppearanceId
    /**
     * An order set of `EntityFlag`s used to describe certain Off-ledger
     * user state about Accounts or Personas, such as if an entity is
     * marked as hidden or not.
     */
    public var flags: [EntityFlag]
    /**
     * The on ledger synced settings for this account, contains e.g.
     * ThirdPartyDeposit settings, with deposit rules for assets.
     */
    public var onLedgerSettings: OnLedgerSettings

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network this account can be used with.
         */ networkId: NetworkId,
        /**
            * A globally unique identifier of this account, being a human readable
            * address of an account. Always starts with `"account_"``, for example:
            *
            * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
            *
            * Most commonly the user will see this address in its abbreviated
            * form which is:
            *
            * `acco...nvjdwr`
            *
            * No two addresses will ever be the same even for the same factor source
            * but on different networks, since the public keys controlling the
            * accounts depend on the network id.
            */ address: AccountAddress,
        /**
            * An off-ledger display name or description chosen by the user when she
            * created this account.
            */ displayName: DisplayName,
        /**
            * Security state of this account, either "securified" or not.
            */ securityState: EntitySecurityState,
        /**
            * The visual cue user learns to associated this account with, typically
            * a beautiful colorful gradient.
            */ appearanceId: AppearanceId,
        /**
            * An order set of `EntityFlag`s used to describe certain Off-ledger
            * user state about Accounts or Personas, such as if an entity is
            * marked as hidden or not.
            */ flags: [EntityFlag],
        /**
            * The on ledger synced settings for this account, contains e.g.
            * ThirdPartyDeposit settings, with deposit rules for assets.
            */ onLedgerSettings: OnLedgerSettings
    ) {
        self.networkId = networkId
        self.address = address
        self.displayName = displayName
        self.securityState = securityState
        self.appearanceId = appearanceId
        self.flags = flags
        self.onLedgerSettings = onLedgerSettings
    }
}

extension Account: Sendable {}
extension Account: Equatable, Hashable {
    public static func == (lhs: Account, rhs: Account) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.securityState != rhs.securityState {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        if lhs.onLedgerSettings != rhs.onLedgerSettings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(securityState)
        hasher.combine(appearanceId)
        hasher.combine(flags)
        hasher.combine(onLedgerSettings)
    }
}

public struct FfiConverterTypeAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Account {
        return
            try Account(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                address: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                securityState: FfiConverterTypeEntitySecurityState.read(from: &buf),
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf),
                flags: FfiConverterSequenceTypeEntityFlag.read(from: &buf),
                onLedgerSettings: FfiConverterTypeOnLedgerSettings.read(from: &buf)
            )
    }

    public static func write(_ value: Account, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeEntitySecurityState.write(value.securityState, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
        FfiConverterSequenceTypeEntityFlag.write(value.flags, into: &buf)
        FfiConverterTypeOnLedgerSettings.write(value.onLedgerSettings, into: &buf)
    }
}

public func FfiConverterTypeAccount_lift(_ buf: RustBuffer) throws -> Account {
    return try FfiConverterTypeAccount.lift(buf)
}

public func FfiConverterTypeAccount_lower(_ value: Account) -> RustBuffer {
    return FfiConverterTypeAccount.lower(value)
}

/**
 * Human readable address of an account. Always starts with `"account_"``, for example:
 *
 * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
 *
 * Most commonly the user will see this address in its abbreviated
 * form which is:
 *
 * `acco...nvjdwr`
 *
 * Addresses are checksummed, as per Bech32. **Only** *Account* addresses starts with
 * the prefix `account_`.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of AccountAddresses:
 * * GlobalAccount
 * * GlobalVirtualSecp256k1Account
 * * GlobalVirtualEd25519Account
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalAccountAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L224-L228
 */
public struct AccountAddress {
    fileprivate let secretMagic: RetAccountAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetAccountAddress) {
        self.secretMagic = secretMagic
    }
}

extension AccountAddress: Sendable {}
extension AccountAddress: Equatable, Hashable {
    public static func == (lhs: AccountAddress, rhs: AccountAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeAccountAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountAddress {
        return
            try AccountAddress(
                secretMagic: FfiConverterTypeRetAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: AccountAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetAccountAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeAccountAddress_lift(_ buf: RustBuffer) throws -> AccountAddress {
    return try FfiConverterTypeAccountAddress.lift(buf)
}

public func FfiConverterTypeAccountAddress_lower(_ value: AccountAddress) -> RustBuffer {
    return FfiConverterTypeAccountAddress.lower(value)
}

/**
 * A minimal version of an [`Account`] meant for
 * display purposes within wallet
 */
public struct AccountForDisplay {
    public var address: AccountAddress
    public var displayName: DisplayName
    public var appearanceId: AppearanceId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: AccountAddress, displayName: DisplayName, appearanceId: AppearanceId) {
        self.address = address
        self.displayName = displayName
        self.appearanceId = appearanceId
    }
}

extension AccountForDisplay: Sendable {}
extension AccountForDisplay: Equatable, Hashable {
    public static func == (lhs: AccountForDisplay, rhs: AccountForDisplay) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(appearanceId)
    }
}

public struct FfiConverterTypeAccountForDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountForDisplay {
        return
            try AccountForDisplay(
                address: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf)
            )
    }

    public static func write(_ value: AccountForDisplay, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
    }
}

public func FfiConverterTypeAccountForDisplay_lift(_ buf: RustBuffer) throws -> AccountForDisplay {
    return try FfiConverterTypeAccountForDisplay.lift(buf)
}

public func FfiConverterTypeAccountForDisplay_lower(_ value: AccountForDisplay) -> RustBuffer {
    return FfiConverterTypeAccountForDisplay.lower(value)
}

public struct AccountPath {
    public var path: HdPath
    public var networkId: NetworkId
    public var entityKind: Cap26EntityKind
    public var keyKind: Cap26KeyKind
    public var index: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: HdPath, networkId: NetworkId, entityKind: Cap26EntityKind, keyKind: Cap26KeyKind, index: UInt32) {
        self.path = path
        self.networkId = networkId
        self.entityKind = entityKind
        self.keyKind = keyKind
        self.index = index
    }
}

extension AccountPath: Sendable {}
extension AccountPath: Equatable, Hashable {
    public static func == (lhs: AccountPath, rhs: AccountPath) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.entityKind != rhs.entityKind {
            return false
        }
        if lhs.keyKind != rhs.keyKind {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(networkId)
        hasher.combine(entityKind)
        hasher.combine(keyKind)
        hasher.combine(index)
    }
}

public struct FfiConverterTypeAccountPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountPath {
        return
            try AccountPath(
                path: FfiConverterTypeHDPath.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                entityKind: FfiConverterTypeCAP26EntityKind.read(from: &buf),
                keyKind: FfiConverterTypeCAP26KeyKind.read(from: &buf),
                index: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: AccountPath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPath.write(value.path, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeCAP26EntityKind.write(value.entityKind, into: &buf)
        FfiConverterTypeCAP26KeyKind.write(value.keyKind, into: &buf)
        FfiConverterUInt32.write(value.index, into: &buf)
    }
}

public func FfiConverterTypeAccountPath_lift(_ buf: RustBuffer) throws -> AccountPath {
    return try FfiConverterTypeAccountPath.lift(buf)
}

public func FfiConverterTypeAccountPath_lower(_ value: AccountPath) -> RustBuffer {
    return FfiConverterTypeAccountPath.lower(value)
}

/**
 * AES GCM 256 encryption
 */
public struct AesGcm256 {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension AesGcm256: Sendable {}
extension AesGcm256: Equatable, Hashable {
    public static func == (_: AesGcm256, _: AesGcm256) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeAesGcm256: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> AesGcm256 {
        return
            AesGcm256()
    }

    public static func write(_: AesGcm256, into _: inout [UInt8]) {}
}

public func FfiConverterTypeAesGcm256_lift(_ buf: RustBuffer) throws -> AesGcm256 {
    return try FfiConverterTypeAesGcm256.lift(buf)
}

public func FfiConverterTypeAesGcm256_lower(_ value: AesGcm256) -> RustBuffer {
    return FfiConverterTypeAesGcm256.lower(value)
}

/**
 * Settings related to displaying of information to the user inside the app.
 *
 * **N.B. neither of these settings are in fact not yet used by clients.**
 */
public struct AppDisplay {
    /**
     * If we should show the aggregate value of users portfolio in fiat currency
     * of hide it.
     */
    public var isCurrencyAmountVisible: Bool
    /**
     * Which fiat currency the prices are measured in.
     */
    public var fiatCurrencyPriceTarget: FiatCurrency

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If we should show the aggregate value of users portfolio in fiat currency
         * of hide it.
         */ isCurrencyAmountVisible: Bool,
        /**
            * Which fiat currency the prices are measured in.
            */ fiatCurrencyPriceTarget: FiatCurrency
    ) {
        self.isCurrencyAmountVisible = isCurrencyAmountVisible
        self.fiatCurrencyPriceTarget = fiatCurrencyPriceTarget
    }
}

extension AppDisplay: Sendable {}
extension AppDisplay: Equatable, Hashable {
    public static func == (lhs: AppDisplay, rhs: AppDisplay) -> Bool {
        if lhs.isCurrencyAmountVisible != rhs.isCurrencyAmountVisible {
            return false
        }
        if lhs.fiatCurrencyPriceTarget != rhs.fiatCurrencyPriceTarget {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCurrencyAmountVisible)
        hasher.combine(fiatCurrencyPriceTarget)
    }
}

public struct FfiConverterTypeAppDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppDisplay {
        return
            try AppDisplay(
                isCurrencyAmountVisible: FfiConverterBool.read(from: &buf),
                fiatCurrencyPriceTarget: FfiConverterTypeFiatCurrency.read(from: &buf)
            )
    }

    public static func write(_ value: AppDisplay, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCurrencyAmountVisible, into: &buf)
        FfiConverterTypeFiatCurrency.write(value.fiatCurrencyPriceTarget, into: &buf)
    }
}

public func FfiConverterTypeAppDisplay_lift(_ buf: RustBuffer) throws -> AppDisplay {
    return try FfiConverterTypeAppDisplay.lift(buf)
}

public func FfiConverterTypeAppDisplay_lower(_ value: AppDisplay) -> RustBuffer {
    return FfiConverterTypeAppDisplay.lower(value)
}

/**
 * Collection of all settings, preferences and configuration related to how the wallet
 * behaves and looks.
 *
 * Current and other saved Gateways, security settings,
 * App Display settings and preferences for transaction.
 */
public struct AppPreferences {
    /**
     * Display settings in the wallet app, such as appearances, currency etc.
     */
    public var display: AppDisplay
    /**
     * The gateway of the active network and collection of other saved gateways.
     */
    public var gateways: SavedGateways
    /**
     * Controls e.g. if Profile Snapshot gets synced to iCloud/Google backup or not.
     */
    public var security: Security
    /**
     * Default config related to making of transactions
     */
    public var transaction: TransactionPreferences
    /**
     * Configuration related to resources
     */
    public var resources: [ResourceAppPreference]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Display settings in the wallet app, such as appearances, currency etc.
         */ display: AppDisplay,
        /**
            * The gateway of the active network and collection of other saved gateways.
            */ gateways: SavedGateways,
        /**
            * Controls e.g. if Profile Snapshot gets synced to iCloud/Google backup or not.
            */ security: Security,
        /**
            * Default config related to making of transactions
            */ transaction: TransactionPreferences,
        /**
            * Configuration related to resources
            */ resources: [ResourceAppPreference]
    ) {
        self.display = display
        self.gateways = gateways
        self.security = security
        self.transaction = transaction
        self.resources = resources
    }
}

extension AppPreferences: Sendable {}
extension AppPreferences: Equatable, Hashable {
    public static func == (lhs: AppPreferences, rhs: AppPreferences) -> Bool {
        if lhs.display != rhs.display {
            return false
        }
        if lhs.gateways != rhs.gateways {
            return false
        }
        if lhs.security != rhs.security {
            return false
        }
        if lhs.transaction != rhs.transaction {
            return false
        }
        if lhs.resources != rhs.resources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(display)
        hasher.combine(gateways)
        hasher.combine(security)
        hasher.combine(transaction)
        hasher.combine(resources)
    }
}

public struct FfiConverterTypeAppPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppPreferences {
        return
            try AppPreferences(
                display: FfiConverterTypeAppDisplay.read(from: &buf),
                gateways: FfiConverterTypeSavedGateways.read(from: &buf),
                security: FfiConverterTypeSecurity.read(from: &buf),
                transaction: FfiConverterTypeTransactionPreferences.read(from: &buf),
                resources: FfiConverterSequenceTypeResourceAppPreference.read(from: &buf)
            )
    }

    public static func write(_ value: AppPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeAppDisplay.write(value.display, into: &buf)
        FfiConverterTypeSavedGateways.write(value.gateways, into: &buf)
        FfiConverterTypeSecurity.write(value.security, into: &buf)
        FfiConverterTypeTransactionPreferences.write(value.transaction, into: &buf)
        FfiConverterSequenceTypeResourceAppPreference.write(value.resources, into: &buf)
    }
}

public func FfiConverterTypeAppPreferences_lift(_ buf: RustBuffer) throws -> AppPreferences {
    return try FfiConverterTypeAppPreferences.lift(buf)
}

public func FfiConverterTypeAppPreferences_lower(_ value: AppPreferences) -> RustBuffer {
    return FfiConverterTypeAppPreferences.lower(value)
}

public struct AppearanceId {
    public var value: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt8) {
        self.value = value
    }
}

extension AppearanceId: Sendable {}
extension AppearanceId: Equatable, Hashable {
    public static func == (lhs: AppearanceId, rhs: AppearanceId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeAppearanceID: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppearanceId {
        return
            try AppearanceId(
                value: FfiConverterUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: AppearanceId, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeAppearanceID_lift(_ buf: RustBuffer) throws -> AppearanceId {
    return try FfiConverterTypeAppearanceID.lift(buf)
}

public func FfiConverterTypeAppearanceID_lower(_ value: AppearanceId) -> RustBuffer {
    return FfiConverterTypeAppearanceID.lower(value)
}

/**
 * An Arculus card, a hierarchal deterministic wallet capable of CAP26 derivation
 * which users interact with by placing it near their host device, which
 * communicates with the card over NFC.
 */
public struct ArculusCardFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic,
     * that is secured by the Arculus Card.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a ArculusCardFactorSource to help user disambiguate
     * between it and another one.
     */
    public var hint: ArculusCardHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic,
         * that is secured by the Arculus Card.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon,
        /**
            * Properties describing a ArculusCardFactorSource to help user disambiguate
            * between it and another one.
            */ hint: ArculusCardHint
    ) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}

extension ArculusCardFactorSource: Sendable {}
extension ArculusCardFactorSource: Equatable, Hashable {
    public static func == (lhs: ArculusCardFactorSource, rhs: ArculusCardFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}

public struct FfiConverterTypeArculusCardFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCardFactorSource {
        return
            try ArculusCardFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                hint: FfiConverterTypeArculusCardHint.read(from: &buf)
            )
    }

    public static func write(_ value: ArculusCardFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeArculusCardHint.write(value.hint, into: &buf)
    }
}

public func FfiConverterTypeArculusCardFactorSource_lift(_ buf: RustBuffer) throws -> ArculusCardFactorSource {
    return try FfiConverterTypeArculusCardFactorSource.lift(buf)
}

public func FfiConverterTypeArculusCardFactorSource_lower(_ value: ArculusCardFactorSource) -> RustBuffer {
    return FfiConverterTypeArculusCardFactorSource.lower(value)
}

public struct ArculusCardHint {
    /**
     * E.g. "Black" or "Silver"
     */
    public var name: String
    public var model: ArculusCardModel

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * E.g. "Black" or "Silver"
         */ name: String, model: ArculusCardModel
    ) {
        self.name = name
        self.model = model
    }
}

extension ArculusCardHint: Sendable {}
extension ArculusCardHint: Equatable, Hashable {
    public static func == (lhs: ArculusCardHint, rhs: ArculusCardHint) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
    }
}

public struct FfiConverterTypeArculusCardHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCardHint {
        return
            try ArculusCardHint(
                name: FfiConverterString.read(from: &buf),
                model: FfiConverterTypeArculusCardModel.read(from: &buf)
            )
    }

    public static func write(_ value: ArculusCardHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeArculusCardModel.write(value.model, into: &buf)
    }
}

public func FfiConverterTypeArculusCardHint_lift(_ buf: RustBuffer) throws -> ArculusCardHint {
    return try FfiConverterTypeArculusCardHint.lift(buf)
}

public func FfiConverterTypeArculusCardHint_lower(_ value: ArculusCardHint) -> RustBuffer {
    return FfiConverterTypeArculusCardHint.lower(value)
}

/**
 * The specific Asset exception rule, which overrides the general
 * `deposit_rule` of a `ThirdPartyDeposits` settings.
 */
public struct AssetException {
    /**
     * Address of an asset to either deny or allow, as an exception overriding the `ThirdPartyDeposits`'s general `deposit_rule`.
     */
    public var address: ResourceAddress
    /**
     * Either deny or allow the `address`.
     */
    public var exceptionRule: DepositAddressExceptionRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Address of an asset to either deny or allow, as an exception overriding the `ThirdPartyDeposits`'s general `deposit_rule`.
         */ address: ResourceAddress,
        /**
            * Either deny or allow the `address`.
            */ exceptionRule: DepositAddressExceptionRule
    ) {
        self.address = address
        self.exceptionRule = exceptionRule
    }
}

extension AssetException: Sendable {}
extension AssetException: Equatable, Hashable {
    public static func == (lhs: AssetException, rhs: AssetException) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.exceptionRule != rhs.exceptionRule {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(exceptionRule)
    }
}

public struct FfiConverterTypeAssetException: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetException {
        return
            try AssetException(
                address: FfiConverterTypeResourceAddress.read(from: &buf),
                exceptionRule: FfiConverterTypeDepositAddressExceptionRule.read(from: &buf)
            )
    }

    public static func write(_ value: AssetException, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.address, into: &buf)
        FfiConverterTypeDepositAddressExceptionRule.write(value.exceptionRule, into: &buf)
    }
}

public func FfiConverterTypeAssetException_lift(_ buf: RustBuffer) throws -> AssetException {
    return try FfiConverterTypeAssetException.lift(buf)
}

public func FfiConverterTypeAssetException_lower(_ value: AssetException) -> RustBuffer {
    return FfiConverterTypeAssetException.lower(value)
}

/**
 * A connection made between a Radix Dapp and the user.
 */
public struct AuthorizedDapp {
    /**
     * The ID of the network the authorized Dapp is on.
     */
    public var networkId: NetworkId
    /**
     * A `DappDefinitionAddress` is in fact just an alias for
     * [`AccountAddress`], it is the address of the account
     * which owns controls the Dapp.
     */
    public var dappDefinitionAddress: AccountAddress
    /**
     * The Display name as sent by the Dapp in any interaction
     * request (CAP21), e.g. "Radix Dashboard".
     */
    public var displayName: String?
    /**
     * An order set of `AuthorizedPersonaSimple`s, which is a collection of all
     * the Personas the user has used to interact with this Dapp, it is called
     * "references to", since the Personas are not stored in full, that would be
     * bad duplication of data (which might go stale), instead we refer to the
     * necessary data by IDs.
     */
    public var referencesToAuthorizedPersonas: [AuthorizedPersonaSimple]
    /**
     * The preferences the user has configured for this Dapp.
     */
    public var preferences: AuthorizedDappPreferences

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network the authorized Dapp is on.
         */ networkId: NetworkId,
        /**
            * A `DappDefinitionAddress` is in fact just an alias for
            * [`AccountAddress`], it is the address of the account
            * which owns controls the Dapp.
            */ dappDefinitionAddress: AccountAddress,
        /**
            * The Display name as sent by the Dapp in any interaction
            * request (CAP21), e.g. "Radix Dashboard".
            */ displayName: String?,
        /**
            * An order set of `AuthorizedPersonaSimple`s, which is a collection of all
            * the Personas the user has used to interact with this Dapp, it is called
            * "references to", since the Personas are not stored in full, that would be
            * bad duplication of data (which might go stale), instead we refer to the
            * necessary data by IDs.
            */ referencesToAuthorizedPersonas: [AuthorizedPersonaSimple],
        /**
            * The preferences the user has configured for this Dapp.
            */ preferences: AuthorizedDappPreferences
    ) {
        self.networkId = networkId
        self.dappDefinitionAddress = dappDefinitionAddress
        self.displayName = displayName
        self.referencesToAuthorizedPersonas = referencesToAuthorizedPersonas
        self.preferences = preferences
    }
}

extension AuthorizedDapp: Sendable {}
extension AuthorizedDapp: Equatable, Hashable {
    public static func == (lhs: AuthorizedDapp, rhs: AuthorizedDapp) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.referencesToAuthorizedPersonas != rhs.referencesToAuthorizedPersonas {
            return false
        }
        if lhs.preferences != rhs.preferences {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(dappDefinitionAddress)
        hasher.combine(displayName)
        hasher.combine(referencesToAuthorizedPersonas)
        hasher.combine(preferences)
    }
}

public struct FfiConverterTypeAuthorizedDapp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDapp {
        return
            try AuthorizedDapp(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterOptionString.read(from: &buf),
                referencesToAuthorizedPersonas: FfiConverterSequenceTypeAuthorizedPersonaSimple.read(from: &buf),
                preferences: FfiConverterTypeAuthorizedDappPreferences.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedDapp, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterSequenceTypeAuthorizedPersonaSimple.write(value.referencesToAuthorizedPersonas, into: &buf)
        FfiConverterTypeAuthorizedDappPreferences.write(value.preferences, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedDapp_lift(_ buf: RustBuffer) throws -> AuthorizedDapp {
    return try FfiConverterTypeAuthorizedDapp.lift(buf)
}

public func FfiConverterTypeAuthorizedDapp_lower(_ value: AuthorizedDapp) -> RustBuffer {
    return FfiConverterTypeAuthorizedDapp.lower(value)
}

public struct AuthorizedDappDetailed {
    public var networkId: NetworkId
    public var dappDefinitionAddress: AccountAddress
    public var displayName: DisplayName?
    public var detailedAuthorizedPersonas: [AuthorizedPersonaDetailed]
    public var preferences: AuthorizedDappPreferences

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, dappDefinitionAddress: AccountAddress, displayName: DisplayName?, detailedAuthorizedPersonas: [AuthorizedPersonaDetailed], preferences: AuthorizedDappPreferences) {
        self.networkId = networkId
        self.dappDefinitionAddress = dappDefinitionAddress
        self.displayName = displayName
        self.detailedAuthorizedPersonas = detailedAuthorizedPersonas
        self.preferences = preferences
    }
}

extension AuthorizedDappDetailed: Sendable {}
extension AuthorizedDappDetailed: Equatable, Hashable {
    public static func == (lhs: AuthorizedDappDetailed, rhs: AuthorizedDappDetailed) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.detailedAuthorizedPersonas != rhs.detailedAuthorizedPersonas {
            return false
        }
        if lhs.preferences != rhs.preferences {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(dappDefinitionAddress)
        hasher.combine(displayName)
        hasher.combine(detailedAuthorizedPersonas)
        hasher.combine(preferences)
    }
}

public struct FfiConverterTypeAuthorizedDappDetailed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappDetailed {
        return
            try AuthorizedDappDetailed(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterOptionTypeDisplayName.read(from: &buf),
                detailedAuthorizedPersonas: FfiConverterSequenceTypeAuthorizedPersonaDetailed.read(from: &buf),
                preferences: FfiConverterTypeAuthorizedDappPreferences.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedDappDetailed, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
        FfiConverterOptionTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterSequenceTypeAuthorizedPersonaDetailed.write(value.detailedAuthorizedPersonas, into: &buf)
        FfiConverterTypeAuthorizedDappPreferences.write(value.preferences, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedDappDetailed_lift(_ buf: RustBuffer) throws -> AuthorizedDappDetailed {
    return try FfiConverterTypeAuthorizedDappDetailed.lift(buf)
}

public func FfiConverterTypeAuthorizedDappDetailed_lower(_ value: AuthorizedDappDetailed) -> RustBuffer {
    return FfiConverterTypeAuthorizedDappDetailed.lower(value)
}

/**
 * The preferences the user has configured off-ledger for a given `AuthorizedDapp`.
 * Allows users, for example, to hide direct deposit claims for a given Dapp.
 */
public struct AuthorizedDappPreferences {
    public var deposits: AuthorizedDappPreferenceDeposits

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deposits: AuthorizedDappPreferenceDeposits) {
        self.deposits = deposits
    }
}

extension AuthorizedDappPreferences: Sendable {}
extension AuthorizedDappPreferences: Equatable, Hashable {
    public static func == (lhs: AuthorizedDappPreferences, rhs: AuthorizedDappPreferences) -> Bool {
        if lhs.deposits != rhs.deposits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deposits)
    }
}

public struct FfiConverterTypeAuthorizedDappPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappPreferences {
        return
            try AuthorizedDappPreferences(
                deposits: FfiConverterTypeAuthorizedDappPreferenceDeposits.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedDappPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeAuthorizedDappPreferenceDeposits.write(value.deposits, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedDappPreferences_lift(_ buf: RustBuffer) throws -> AuthorizedDappPreferences {
    return try FfiConverterTypeAuthorizedDappPreferences.lift(buf)
}

public func FfiConverterTypeAuthorizedDappPreferences_lower(_ value: AuthorizedDappPreferences) -> RustBuffer {
    return FfiConverterTypeAuthorizedDappPreferences.lower(value)
}

public struct AuthorizedPersonaDetailed {
    /**
     * Address that globally and uniquely identifies this Persona.
     */
    public var identityAddress: IdentityAddress
    /**
     * The display name of the Persona, as stored in `Persona`
     */
    public var displayName: DisplayName
    /**
     * Information of accounts the user has given the Dapp access to,
     * being the triple `(accountAddress, displayName, appearanceID)`
     */
    public var simpleAccounts: [AccountForDisplay]?
    /**
     * The persona data that the user has given the Dapp access to
     */
    public var sharedPersonaData: PersonaData
    /**
     * If this persona has an auth sign key created
     */
    public var hasAuthenticationSigningKey: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Address that globally and uniquely identifies this Persona.
         */ identityAddress: IdentityAddress,
        /**
            * The display name of the Persona, as stored in `Persona`
            */ displayName: DisplayName,
        /**
            * Information of accounts the user has given the Dapp access to,
            * being the triple `(accountAddress, displayName, appearanceID)`
            */ simpleAccounts: [AccountForDisplay]?,
        /**
            * The persona data that the user has given the Dapp access to
            */ sharedPersonaData: PersonaData,
        /**
            * If this persona has an auth sign key created
            */ hasAuthenticationSigningKey: Bool
    ) {
        self.identityAddress = identityAddress
        self.displayName = displayName
        self.simpleAccounts = simpleAccounts
        self.sharedPersonaData = sharedPersonaData
        self.hasAuthenticationSigningKey = hasAuthenticationSigningKey
    }
}

extension AuthorizedPersonaDetailed: Sendable {}
extension AuthorizedPersonaDetailed: Equatable, Hashable {
    public static func == (lhs: AuthorizedPersonaDetailed, rhs: AuthorizedPersonaDetailed) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.simpleAccounts != rhs.simpleAccounts {
            return false
        }
        if lhs.sharedPersonaData != rhs.sharedPersonaData {
            return false
        }
        if lhs.hasAuthenticationSigningKey != rhs.hasAuthenticationSigningKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(displayName)
        hasher.combine(simpleAccounts)
        hasher.combine(sharedPersonaData)
        hasher.combine(hasAuthenticationSigningKey)
    }
}

public struct FfiConverterTypeAuthorizedPersonaDetailed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedPersonaDetailed {
        return
            try AuthorizedPersonaDetailed(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                simpleAccounts: FfiConverterOptionSequenceTypeAccountForDisplay.read(from: &buf),
                sharedPersonaData: FfiConverterTypePersonaData.read(from: &buf),
                hasAuthenticationSigningKey: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedPersonaDetailed, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterOptionSequenceTypeAccountForDisplay.write(value.simpleAccounts, into: &buf)
        FfiConverterTypePersonaData.write(value.sharedPersonaData, into: &buf)
        FfiConverterBool.write(value.hasAuthenticationSigningKey, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedPersonaDetailed_lift(_ buf: RustBuffer) throws -> AuthorizedPersonaDetailed {
    return try FfiConverterTypeAuthorizedPersonaDetailed.lift(buf)
}

public func FfiConverterTypeAuthorizedPersonaDetailed_lower(_ value: AuthorizedPersonaDetailed) -> RustBuffer {
    return FfiConverterTypeAuthorizedPersonaDetailed.lower(value)
}

/**
 * Simple data representation of a Persona the user has shared with a Dapp.
 * Simple meaning "the bare minimum amount of data" that enabled `Sargon` to
 * be able to reconstruct a `AuthorizedPersonaDetailed` value, used to populate
 * views.
 *
 * N.B. as of 2024-01-31 of `Sargon` we have not yet implemented the struct
 * `AuthorizedPersonaDetailed` since it is not JSON, but logic, and we have yet
 * to migrate `Sargon` into iOS/Android clients, thus we will defer the work
 * of mapping `AuthorizedPersonaSimple` -> `AuthorizedPersonaDetailed`.
 */
public struct AuthorizedPersonaSimple {
    /**
     * The globally unique identifier of a Persona is its address, used
     * to lookup persona
     */
    public var identityAddress: IdentityAddress
    /**
     * Date of last login for this persona.
     */
    public var lastLogin: Timestamp
    /**
     * List of "ongoing accountAddresses" that user given the dApp access to.
     */
    public var sharedAccounts: SharedToDappWithPersonaAccountAddresses?
    /**
     * ID to PersonaData entries to user has shared with a Dapp.
     */
    public var sharedPersonaData: SharedPersonaData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The globally unique identifier of a Persona is its address, used
         * to lookup persona
         */ identityAddress: IdentityAddress,
        /**
            * Date of last login for this persona.
            */ lastLogin: Timestamp,
        /**
            * List of "ongoing accountAddresses" that user given the dApp access to.
            */ sharedAccounts: SharedToDappWithPersonaAccountAddresses?,
        /**
            * ID to PersonaData entries to user has shared with a Dapp.
            */ sharedPersonaData: SharedPersonaData
    ) {
        self.identityAddress = identityAddress
        self.lastLogin = lastLogin
        self.sharedAccounts = sharedAccounts
        self.sharedPersonaData = sharedPersonaData
    }
}

extension AuthorizedPersonaSimple: Sendable {}
extension AuthorizedPersonaSimple: Equatable, Hashable {
    public static func == (lhs: AuthorizedPersonaSimple, rhs: AuthorizedPersonaSimple) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.lastLogin != rhs.lastLogin {
            return false
        }
        if lhs.sharedAccounts != rhs.sharedAccounts {
            return false
        }
        if lhs.sharedPersonaData != rhs.sharedPersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(lastLogin)
        hasher.combine(sharedAccounts)
        hasher.combine(sharedPersonaData)
    }
}

public struct FfiConverterTypeAuthorizedPersonaSimple: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedPersonaSimple {
        return
            try AuthorizedPersonaSimple(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
                lastLogin: FfiConverterTypeTimestamp.read(from: &buf),
                sharedAccounts: FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses.read(from: &buf),
                sharedPersonaData: FfiConverterTypeSharedPersonaData.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedPersonaSimple, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastLogin, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses.write(value.sharedAccounts, into: &buf)
        FfiConverterTypeSharedPersonaData.write(value.sharedPersonaData, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedPersonaSimple_lift(_ buf: RustBuffer) throws -> AuthorizedPersonaSimple {
    return try FfiConverterTypeAuthorizedPersonaSimple.lift(buf)
}

public func FfiConverterTypeAuthorizedPersonaSimple_lower(_ value: AuthorizedPersonaSimple) -> RustBuffer {
    return FfiConverterTypeAuthorizedPersonaSimple.lower(value)
}

/**
 * A BIP39 seed for hierarchal deterministic wallets, as per the [BIP39 standard][doc].
 *
 * We typically obtain this by calling [`to_seed` on `MnemonicWithPassphrase`][MnemonicWithPassphrase::to_seed].
 *
 * [doc]: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#user-content-From_mnemonic_to_seed
 */
public struct Bip39Seed {
    fileprivate let secretMagic: Bip39SeedSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Bip39SeedSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Bip39Seed: Sendable {}
extension Bip39Seed: Equatable, Hashable {
    public static func == (lhs: Bip39Seed, rhs: Bip39Seed) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeBIP39Seed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Seed {
        return
            try Bip39Seed(
                secretMagic: FfiConverterTypeBIP39SeedSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Bip39Seed, into buf: inout [UInt8]) {
        FfiConverterTypeBIP39SeedSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeBIP39Seed_lift(_ buf: RustBuffer) throws -> Bip39Seed {
    return try FfiConverterTypeBIP39Seed.lift(buf)
}

public func FfiConverterTypeBIP39Seed_lower(_ value: Bip39Seed) -> RustBuffer {
    return FfiConverterTypeBIP39Seed.lower(value)
}

/**
 * A word in the BIP39 word list of `language` at known `index` (0-2047).
 */
public struct Bip39Word {
    public var word: String
    public var index: U11
    public var language: Bip39Language

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(word: String, index: U11, language: Bip39Language) {
        self.word = word
        self.index = index
        self.language = language
    }
}

extension Bip39Word: Sendable {}
extension Bip39Word: Equatable, Hashable {
    public static func == (lhs: Bip39Word, rhs: Bip39Word) -> Bool {
        if lhs.word != rhs.word {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(word)
        hasher.combine(index)
        hasher.combine(language)
    }
}

public struct FfiConverterTypeBIP39Word: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Word {
        return
            try Bip39Word(
                word: FfiConverterString.read(from: &buf),
                index: FfiConverterTypeU11.read(from: &buf),
                language: FfiConverterTypeBIP39Language.read(from: &buf)
            )
    }

    public static func write(_ value: Bip39Word, into buf: inout [UInt8]) {
        FfiConverterString.write(value.word, into: &buf)
        FfiConverterTypeU11.write(value.index, into: &buf)
        FfiConverterTypeBIP39Language.write(value.language, into: &buf)
    }
}

public func FfiConverterTypeBIP39Word_lift(_ buf: RustBuffer) throws -> Bip39Word {
    return try FfiConverterTypeBIP39Word.lift(buf)
}

public func FfiConverterTypeBIP39Word_lower(_ value: Bip39Word) -> RustBuffer {
    return FfiConverterTypeBIP39Word.lower(value)
}

/**
 * Either a canonical BIP44 derivation path like so:
 *
 * `m / purpose' / coin_type' / account' / change / address_index`
 *
 * Or an Radix Olympia BIP44 "like" path, where the `address_index` accidentally
 * was made hardened, i.e.:
 *
 * `m / purpose' / coin_type' / account' / change / address_index'`
 *
 * This was a mistake made during implementation of Radix Olympia.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * fn parse(s: &str) -> Result<BIP44LikePath> {
 * s.parse::<BIP44LikePath>()
 * }
 *
 * assert!(parse("m/44'/1022'/0'/0/0").is_ok()); // Canonical BIP44
 * assert!(parse("m/44'/1022'/0'/0/0'").is_ok()); // BIP44 like
 *
 * assert_eq!(parse("m/44'/1022'/0'/0'/0"), Err(CommonError::InvalidBIP44LikePathChangeWasUnexpectedlyHardened));
 * assert_eq!(parse("m/44'/1022'/0'/0'/0'"), Err(CommonError::InvalidBIP44LikePathChangeWasUnexpectedlyHardened));
 * assert_eq!(parse("m/44'/0'/0'/0/0'"), Err(CommonError::CoinTypeNotFound { bad_value: 0 }));
 * ```
 */
public struct Bip44LikePath {
    public var path: HdPath

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: HdPath) {
        self.path = path
    }
}

extension Bip44LikePath: Sendable {}
extension Bip44LikePath: Equatable, Hashable {
    public static func == (lhs: Bip44LikePath, rhs: Bip44LikePath) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
    }
}

public struct FfiConverterTypeBIP44LikePath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip44LikePath {
        return
            try Bip44LikePath(
                path: FfiConverterTypeHDPath.read(from: &buf)
            )
    }

    public static func write(_ value: Bip44LikePath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPath.write(value.path, into: &buf)
    }
}

public func FfiConverterTypeBIP44LikePath_lift(_ buf: RustBuffer) throws -> Bip44LikePath {
    return try FfiConverterTypeBIP44LikePath.lift(buf)
}

public func FfiConverterTypeBIP44LikePath_lower(_ value: Bip44LikePath) -> RustBuffer {
    return FfiConverterTypeBIP44LikePath.lower(value)
}

/**
 * Blob is a wrapper a bag of bytes
 */
public struct Blob {
    fileprivate let secretMagic: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BagOfBytes) {
        self.secretMagic = secretMagic
    }
}

extension Blob: Sendable {}
extension Blob: Equatable, Hashable {
    public static func == (lhs: Blob, rhs: Blob) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeBlob: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Blob {
        return
            try Blob(
                secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Blob, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeBlob_lift(_ buf: RustBuffer) throws -> Blob {
    return try FfiConverterTypeBlob.lift(buf)
}

public func FfiConverterTypeBlob_lower(_ value: Blob) -> RustBuffer {
    return FfiConverterTypeBlob.lower(value)
}

/**
 * Vec of Blobs
 */
public struct Blobs {
    fileprivate let secretMagic: BlobsSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BlobsSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Blobs: Sendable {}
extension Blobs: Equatable, Hashable {
    public static func == (lhs: Blobs, rhs: Blobs) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeBlobs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Blobs {
        return
            try Blobs(
                secretMagic: FfiConverterTypeBlobsSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Blobs, into buf: inout [UInt8]) {
        FfiConverterTypeBlobsSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeBlobs_lift(_ buf: RustBuffer) throws -> Blobs {
    return try FfiConverterTypeBlobs.lift(buf)
}

public func FfiConverterTypeBlobs_lower(_ value: Blobs) -> RustBuffer {
    return FfiConverterTypeBlobs.lower(value)
}

/**
 * Vec of Blobs
 */
public struct BlobsSecretMagic {
    fileprivate let secretMagic: [Blob]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: [Blob]) {
        self.secretMagic = secretMagic
    }
}

extension BlobsSecretMagic: Sendable {}
extension BlobsSecretMagic: Equatable, Hashable {
    public static func == (lhs: BlobsSecretMagic, rhs: BlobsSecretMagic) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeBlobsSecretMagic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlobsSecretMagic {
        return
            try BlobsSecretMagic(
                secretMagic: FfiConverterSequenceTypeBlob.read(from: &buf)
            )
    }

    public static func write(_ value: BlobsSecretMagic, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBlob.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeBlobsSecretMagic_lift(_ buf: RustBuffer) throws -> BlobsSecretMagic {
    return try FfiConverterTypeBlobsSecretMagic.lift(buf)
}

public func FfiConverterTypeBlobsSecretMagic_lower(_ value: BlobsSecretMagic) -> RustBuffer {
    return FfiConverterTypeBlobsSecretMagic.lower(value)
}

/**
 * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
 * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
 * contain elements with the same value, but under different IDs.
 */
public struct CollectionOfEmailAddresses {
    public var collection: [PersonaDataIdentifiedEmailAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(collection: [PersonaDataIdentifiedEmailAddress]) {
        self.collection = collection
    }
}

extension CollectionOfEmailAddresses: Sendable {}
extension CollectionOfEmailAddresses: Equatable, Hashable {
    public static func == (lhs: CollectionOfEmailAddresses, rhs: CollectionOfEmailAddresses) -> Bool {
        if lhs.collection != rhs.collection {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(collection)
    }
}

public struct FfiConverterTypeCollectionOfEmailAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionOfEmailAddresses {
        return
            try CollectionOfEmailAddresses(
                collection: FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress.read(from: &buf)
            )
    }

    public static func write(_ value: CollectionOfEmailAddresses, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress.write(value.collection, into: &buf)
    }
}

public func FfiConverterTypeCollectionOfEmailAddresses_lift(_ buf: RustBuffer) throws -> CollectionOfEmailAddresses {
    return try FfiConverterTypeCollectionOfEmailAddresses.lift(buf)
}

public func FfiConverterTypeCollectionOfEmailAddresses_lower(_ value: CollectionOfEmailAddresses) -> RustBuffer {
    return FfiConverterTypeCollectionOfEmailAddresses.lower(value)
}

/**
 * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
 * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
 * contain elements with the same value, but under different IDs.
 */
public struct CollectionOfPhoneNumbers {
    public var collection: [PersonaDataIdentifiedPhoneNumber]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(collection: [PersonaDataIdentifiedPhoneNumber]) {
        self.collection = collection
    }
}

extension CollectionOfPhoneNumbers: Sendable {}
extension CollectionOfPhoneNumbers: Equatable, Hashable {
    public static func == (lhs: CollectionOfPhoneNumbers, rhs: CollectionOfPhoneNumbers) -> Bool {
        if lhs.collection != rhs.collection {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(collection)
    }
}

public struct FfiConverterTypeCollectionOfPhoneNumbers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionOfPhoneNumbers {
        return
            try CollectionOfPhoneNumbers(
                collection: FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber.read(from: &buf)
            )
    }

    public static func write(_ value: CollectionOfPhoneNumbers, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber.write(value.collection, into: &buf)
    }
}

public func FfiConverterTypeCollectionOfPhoneNumbers_lift(_ buf: RustBuffer) throws -> CollectionOfPhoneNumbers {
    return try FfiConverterTypeCollectionOfPhoneNumbers.lift(buf)
}

public func FfiConverterTypeCollectionOfPhoneNumbers_lower(_ value: CollectionOfPhoneNumbers) -> RustBuffer {
    return FfiConverterTypeCollectionOfPhoneNumbers.lower(value)
}

public struct CompiledNotarizedIntent {
    fileprivate let secretMagic: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BagOfBytes) {
        self.secretMagic = secretMagic
    }
}

extension CompiledNotarizedIntent: Sendable {}
extension CompiledNotarizedIntent: Equatable, Hashable {
    public static func == (lhs: CompiledNotarizedIntent, rhs: CompiledNotarizedIntent) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeCompiledNotarizedIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompiledNotarizedIntent {
        return
            try CompiledNotarizedIntent(
                secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: CompiledNotarizedIntent, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeCompiledNotarizedIntent_lift(_ buf: RustBuffer) throws -> CompiledNotarizedIntent {
    return try FfiConverterTypeCompiledNotarizedIntent.lift(buf)
}

public func FfiConverterTypeCompiledNotarizedIntent_lower(_ value: CompiledNotarizedIntent) -> RustBuffer {
    return FfiConverterTypeCompiledNotarizedIntent.lower(value)
}

/**
 * An address to some On-Ledger (OnNetwork) component, e.g. a Dapp, being an instantiation
 * of some Scrypto blueprint, e.g:
 * `"component_rdx1cptxxxxxxxxxfaucetxxxxxxxxx000527798379xxxxxxxxxfaucet"`
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of ComponentAddress:
 * * GlobalGenericComponent
 * * InternalGenericComponent
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalComponentAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L243-L246
 */
public struct ComponentAddress {
    fileprivate let secretMagic: RetComponentAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetComponentAddress) {
        self.secretMagic = secretMagic
    }
}

extension ComponentAddress: Sendable {}
extension ComponentAddress: Equatable, Hashable {
    public static func == (lhs: ComponentAddress, rhs: ComponentAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeComponentAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComponentAddress {
        return
            try ComponentAddress(
                secretMagic: FfiConverterTypeRetComponentAddress.read(from: &buf)
            )
    }

    public static func write(_ value: ComponentAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetComponentAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeComponentAddress_lift(_ buf: RustBuffer) throws -> ComponentAddress {
    return try FfiConverterTypeComponentAddress.lift(buf)
}

public func FfiConverterTypeComponentAddress_lower(_ value: ComponentAddress) -> RustBuffer {
    return FfiConverterTypeComponentAddress.lower(value)
}

/**
 * ConfirmationRole is used to confirm recovery.
 */
public struct ConfirmationRoleWithFactorInstances {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorInstance]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorInstance],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorInstance]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension ConfirmationRoleWithFactorInstances: Sendable {}
extension ConfirmationRoleWithFactorInstances: Equatable, Hashable {
    public static func == (lhs: ConfirmationRoleWithFactorInstances, rhs: ConfirmationRoleWithFactorInstances) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypeConfirmationRoleWithFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationRoleWithFactorInstances {
        return
            try ConfirmationRoleWithFactorInstances(
                thresholdFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf)
            )
    }

    public static func write(_ value: ConfirmationRoleWithFactorInstances, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorInstance.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorInstance.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypeConfirmationRoleWithFactorInstances_lift(_ buf: RustBuffer) throws -> ConfirmationRoleWithFactorInstances {
    return try FfiConverterTypeConfirmationRoleWithFactorInstances.lift(buf)
}

public func FfiConverterTypeConfirmationRoleWithFactorInstances_lower(_ value: ConfirmationRoleWithFactorInstances) -> RustBuffer {
    return FfiConverterTypeConfirmationRoleWithFactorInstances.lower(value)
}

/**
 * ConfirmationRole is used to confirm recovery.
 */
public struct ConfirmationRoleWithFactorSourceIDs {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorSourceId]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSourceId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorSourceId],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorSourceId]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension ConfirmationRoleWithFactorSourceIDs: Sendable {}
extension ConfirmationRoleWithFactorSourceIDs: Equatable, Hashable {
    public static func == (lhs: ConfirmationRoleWithFactorSourceIDs, rhs: ConfirmationRoleWithFactorSourceIDs) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypeConfirmationRoleWithFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationRoleWithFactorSourceIDs {
        return
            try ConfirmationRoleWithFactorSourceIDs(
                thresholdFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
            )
    }

    public static func write(_ value: ConfirmationRoleWithFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorSourceID.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSourceID.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypeConfirmationRoleWithFactorSourceIDs_lift(_ buf: RustBuffer) throws -> ConfirmationRoleWithFactorSourceIDs {
    return try FfiConverterTypeConfirmationRoleWithFactorSourceIDs.lift(buf)
}

public func FfiConverterTypeConfirmationRoleWithFactorSourceIDs_lower(_ value: ConfirmationRoleWithFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypeConfirmationRoleWithFactorSourceIDs.lower(value)
}

/**
 * ConfirmationRole is used to confirm recovery.
 */
public struct ConfirmationRoleWithFactorSources {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorSource]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorSource],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorSource]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension ConfirmationRoleWithFactorSources: Sendable {}
extension ConfirmationRoleWithFactorSources: Equatable, Hashable {
    public static func == (lhs: ConfirmationRoleWithFactorSources, rhs: ConfirmationRoleWithFactorSources) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypeConfirmationRoleWithFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationRoleWithFactorSources {
        return
            try ConfirmationRoleWithFactorSources(
                thresholdFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf)
            )
    }

    public static func write(_ value: ConfirmationRoleWithFactorSources, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorSource.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypeConfirmationRoleWithFactorSources_lift(_ buf: RustBuffer) throws -> ConfirmationRoleWithFactorSources {
    return try FfiConverterTypeConfirmationRoleWithFactorSources.lift(buf)
}

public func FfiConverterTypeConfirmationRoleWithFactorSources_lower(_ value: ConfirmationRoleWithFactorSources) -> RustBuffer {
    return FfiConverterTypeConfirmationRoleWithFactorSources.lower(value)
}

/**
 * A hint describing the contents of a Profile, acting as a
 * summary of a Profile used by a ProfileSnapshot Header.
 *
 * Important to know that this is just a **hint**, the values
 * SHOULD be kept up to date, might might not be, since they
 * are stored values which must be kept in sync.
 */
public struct ContentHint {
    /**
     * The total number of accounts on all networks.
     *
     * Important to remember that this is a counter inside a
     * content **hint**. This counter SHOULD be update when
     * new accounts are created, but failing to do is of no
     * real consequence.
     *
     * This counter includes any by user hidden accounts.
     */
    public var numberOfAccountsOnAllNetworksInTotal: UInt16
    /**
     * The total number of personas on all networks.
     *
     * Important to remember that this is a counter inside a
     * content **hint**. This counter SHOULD be update when
     * new accounts are created, but failing to do is of no
     * real consequence.
     *
     * This counter includes any by user hidden personas.
     */
    public var numberOfPersonasOnAllNetworksInTotal: UInt16
    /**
     * The total number of networks that the user has used, i.e.
     * on which she has any accounts or personas.
     */
    public var numberOfNetworks: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The total number of accounts on all networks.
         *
         * Important to remember that this is a counter inside a
         * content **hint**. This counter SHOULD be update when
         * new accounts are created, but failing to do is of no
         * real consequence.
         *
         * This counter includes any by user hidden accounts.
         */ numberOfAccountsOnAllNetworksInTotal: UInt16,
        /**
            * The total number of personas on all networks.
            *
            * Important to remember that this is a counter inside a
            * content **hint**. This counter SHOULD be update when
            * new accounts are created, but failing to do is of no
            * real consequence.
            *
            * This counter includes any by user hidden personas.
            */ numberOfPersonasOnAllNetworksInTotal: UInt16,
        /**
            * The total number of networks that the user has used, i.e.
            * on which she has any accounts or personas.
            */ numberOfNetworks: UInt16
    ) {
        self.numberOfAccountsOnAllNetworksInTotal = numberOfAccountsOnAllNetworksInTotal
        self.numberOfPersonasOnAllNetworksInTotal = numberOfPersonasOnAllNetworksInTotal
        self.numberOfNetworks = numberOfNetworks
    }
}

extension ContentHint: Sendable {}
extension ContentHint: Equatable, Hashable {
    public static func == (lhs: ContentHint, rhs: ContentHint) -> Bool {
        if lhs.numberOfAccountsOnAllNetworksInTotal != rhs.numberOfAccountsOnAllNetworksInTotal {
            return false
        }
        if lhs.numberOfPersonasOnAllNetworksInTotal != rhs.numberOfPersonasOnAllNetworksInTotal {
            return false
        }
        if lhs.numberOfNetworks != rhs.numberOfNetworks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numberOfAccountsOnAllNetworksInTotal)
        hasher.combine(numberOfPersonasOnAllNetworksInTotal)
        hasher.combine(numberOfNetworks)
    }
}

public struct FfiConverterTypeContentHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContentHint {
        return
            try ContentHint(
                numberOfAccountsOnAllNetworksInTotal: FfiConverterUInt16.read(from: &buf),
                numberOfPersonasOnAllNetworksInTotal: FfiConverterUInt16.read(from: &buf),
                numberOfNetworks: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: ContentHint, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.numberOfAccountsOnAllNetworksInTotal, into: &buf)
        FfiConverterUInt16.write(value.numberOfPersonasOnAllNetworksInTotal, into: &buf)
        FfiConverterUInt16.write(value.numberOfNetworks, into: &buf)
    }
}

public func FfiConverterTypeContentHint_lift(_ buf: RustBuffer) throws -> ContentHint {
    return try FfiConverterTypeContentHint.lift(buf)
}

public func FfiConverterTypeContentHint_lower(_ value: ContentHint) -> RustBuffer {
    return FfiConverterTypeContentHint.lower(value)
}

public struct DappToWalletInteraction {
    public var interactionId: WalletInteractionId
    public var items: DappToWalletInteractionItems
    public var metadata: DappToWalletInteractionMetadata

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, items: DappToWalletInteractionItems, metadata: DappToWalletInteractionMetadata) {
        self.interactionId = interactionId
        self.items = items
        self.metadata = metadata
    }
}

extension DappToWalletInteraction: Sendable {}
extension DappToWalletInteraction: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteraction, rhs: DappToWalletInteraction) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(items)
        hasher.combine(metadata)
    }
}

public struct FfiConverterTypeDappToWalletInteraction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteraction {
        return
            try DappToWalletInteraction(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                items: FfiConverterTypeDappToWalletInteractionItems.read(from: &buf),
                metadata: FfiConverterTypeDappToWalletInteractionMetadata.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteraction, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeDappToWalletInteractionItems.write(value.items, into: &buf)
        FfiConverterTypeDappToWalletInteractionMetadata.write(value.metadata, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteraction_lift(_ buf: RustBuffer) throws -> DappToWalletInteraction {
    return try FfiConverterTypeDappToWalletInteraction.lift(buf)
}

public func FfiConverterTypeDappToWalletInteraction_lower(_ value: DappToWalletInteraction) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteraction.lower(value)
}

public struct DappToWalletInteractionAccountsRequestItem {
    public var numberOfAccounts: RequestedQuantity
    public var challenge: DappToWalletInteractionAuthChallengeNonce?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(numberOfAccounts: RequestedQuantity, challenge: DappToWalletInteractionAuthChallengeNonce?) {
        self.numberOfAccounts = numberOfAccounts
        self.challenge = challenge
    }
}

extension DappToWalletInteractionAccountsRequestItem: Sendable {}
extension DappToWalletInteractionAccountsRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionAccountsRequestItem, rhs: DappToWalletInteractionAccountsRequestItem) -> Bool {
        if lhs.numberOfAccounts != rhs.numberOfAccounts {
            return false
        }
        if lhs.challenge != rhs.challenge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numberOfAccounts)
        hasher.combine(challenge)
    }
}

public struct FfiConverterTypeDappToWalletInteractionAccountsRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAccountsRequestItem {
        return
            try DappToWalletInteractionAccountsRequestItem(
                numberOfAccounts: FfiConverterTypeRequestedQuantity.read(from: &buf),
                challenge: FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionAccountsRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.numberOfAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionAccountsRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAccountsRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAccountsRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAccountsRequestItem_lower(_ value: DappToWalletInteractionAccountsRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAccountsRequestItem.lower(value)
}

public struct DappToWalletInteractionAuthLoginWithChallengeRequestItem {
    public var challenge: DappToWalletInteractionAuthChallengeNonce

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(challenge: DappToWalletInteractionAuthChallengeNonce) {
        self.challenge = challenge
    }
}

extension DappToWalletInteractionAuthLoginWithChallengeRequestItem: Sendable {}
extension DappToWalletInteractionAuthLoginWithChallengeRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionAuthLoginWithChallengeRequestItem, rhs: DappToWalletInteractionAuthLoginWithChallengeRequestItem) -> Bool {
        if lhs.challenge != rhs.challenge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challenge)
    }
}

public struct FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthLoginWithChallengeRequestItem {
        return
            try DappToWalletInteractionAuthLoginWithChallengeRequestItem(
                challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionAuthLoginWithChallengeRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthLoginWithChallengeRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem_lower(_ value: DappToWalletInteractionAuthLoginWithChallengeRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.lower(value)
}

public struct DappToWalletInteractionAuthUsePersonaRequestItem {
    public var identityAddress: IdentityAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityAddress: IdentityAddress) {
        self.identityAddress = identityAddress
    }
}

extension DappToWalletInteractionAuthUsePersonaRequestItem: Sendable {}
extension DappToWalletInteractionAuthUsePersonaRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionAuthUsePersonaRequestItem, rhs: DappToWalletInteractionAuthUsePersonaRequestItem) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
    }
}

public struct FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthUsePersonaRequestItem {
        return
            try DappToWalletInteractionAuthUsePersonaRequestItem(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionAuthUsePersonaRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthUsePersonaRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem_lower(_ value: DappToWalletInteractionAuthUsePersonaRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.lower(value)
}

public struct DappToWalletInteractionAuthorizedRequestItems {
    public var auth: DappToWalletInteractionAuthRequestItem
    public var reset: DappToWalletInteractionResetRequestItem?
    public var ongoingAccounts: DappToWalletInteractionAccountsRequestItem?
    public var ongoingPersonaData: DappToWalletInteractionPersonaDataRequestItem?
    public var oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?
    public var oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(auth: DappToWalletInteractionAuthRequestItem, reset: DappToWalletInteractionResetRequestItem?, ongoingAccounts: DappToWalletInteractionAccountsRequestItem?, ongoingPersonaData: DappToWalletInteractionPersonaDataRequestItem?, oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?, oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?) {
        self.auth = auth
        self.reset = reset
        self.ongoingAccounts = ongoingAccounts
        self.ongoingPersonaData = ongoingPersonaData
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
    }
}

extension DappToWalletInteractionAuthorizedRequestItems: Sendable {}
extension DappToWalletInteractionAuthorizedRequestItems: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionAuthorizedRequestItems, rhs: DappToWalletInteractionAuthorizedRequestItems) -> Bool {
        if lhs.auth != rhs.auth {
            return false
        }
        if lhs.reset != rhs.reset {
            return false
        }
        if lhs.ongoingAccounts != rhs.ongoingAccounts {
            return false
        }
        if lhs.ongoingPersonaData != rhs.ongoingPersonaData {
            return false
        }
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(auth)
        hasher.combine(reset)
        hasher.combine(ongoingAccounts)
        hasher.combine(ongoingPersonaData)
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
    }
}

public struct FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthorizedRequestItems {
        return
            try DappToWalletInteractionAuthorizedRequestItems(
                auth: FfiConverterTypeDappToWalletInteractionAuthRequestItem.read(from: &buf),
                reset: FfiConverterOptionTypeDappToWalletInteractionResetRequestItem.read(from: &buf),
                ongoingAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf),
                ongoingPersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf),
                oneTimeAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf),
                oneTimePersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionAuthorizedRequestItems, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionAuthRequestItem.write(value.auth, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionResetRequestItem.write(value.reset, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.ongoingAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.ongoingPersonaData, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.oneTimePersonaData, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthorizedRequestItems {
    return try FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems_lower(_ value: DappToWalletInteractionAuthorizedRequestItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.lower(value)
}

public struct DappToWalletInteractionMetadata {
    public var version: WalletInteractionVersion
    public var networkId: NetworkId
    public var origin: DappOrigin
    public var dappDefinitionAddress: AccountAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: WalletInteractionVersion, networkId: NetworkId, origin: DappOrigin, dappDefinitionAddress: AccountAddress) {
        self.version = version
        self.networkId = networkId
        self.origin = origin
        self.dappDefinitionAddress = dappDefinitionAddress
    }
}

extension DappToWalletInteractionMetadata: Sendable {}
extension DappToWalletInteractionMetadata: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionMetadata, rhs: DappToWalletInteractionMetadata) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(networkId)
        hasher.combine(origin)
        hasher.combine(dappDefinitionAddress)
    }
}

public struct FfiConverterTypeDappToWalletInteractionMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionMetadata {
        return
            try DappToWalletInteractionMetadata(
                version: FfiConverterTypeWalletInteractionVersion.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                origin: FfiConverterTypeDappOrigin.read(from: &buf),
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionVersion.write(value.version, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionMetadata_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionMetadata {
    return try FfiConverterTypeDappToWalletInteractionMetadata.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionMetadata_lower(_ value: DappToWalletInteractionMetadata) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionMetadata.lower(value)
}

public struct DappToWalletInteractionMetadataUnvalidated {
    public var version: WalletInteractionVersion
    public var networkId: NetworkId
    public var origin: DappOrigin
    public var dappDefinitionAddress: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: WalletInteractionVersion, networkId: NetworkId, origin: DappOrigin, dappDefinitionAddress: String) {
        self.version = version
        self.networkId = networkId
        self.origin = origin
        self.dappDefinitionAddress = dappDefinitionAddress
    }
}

extension DappToWalletInteractionMetadataUnvalidated: Sendable {}
extension DappToWalletInteractionMetadataUnvalidated: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionMetadataUnvalidated, rhs: DappToWalletInteractionMetadataUnvalidated) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(networkId)
        hasher.combine(origin)
        hasher.combine(dappDefinitionAddress)
    }
}

public struct FfiConverterTypeDappToWalletInteractionMetadataUnvalidated: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionMetadataUnvalidated {
        return
            try DappToWalletInteractionMetadataUnvalidated(
                version: FfiConverterTypeWalletInteractionVersion.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                origin: FfiConverterTypeDappOrigin.read(from: &buf),
                dappDefinitionAddress: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionMetadataUnvalidated, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionVersion.write(value.version, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
        FfiConverterString.write(value.dappDefinitionAddress, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionMetadataUnvalidated_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionMetadataUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionMetadataUnvalidated_lower(_ value: DappToWalletInteractionMetadataUnvalidated) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.lower(value)
}

public struct DappToWalletInteractionPersonaDataRequestItem {
    public var isRequestingName: Bool?
    public var numberOfRequestedEmailAddresses: RequestedQuantity?
    public var numberOfRequestedPhoneNumbers: RequestedQuantity?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isRequestingName: Bool?, numberOfRequestedEmailAddresses: RequestedQuantity?, numberOfRequestedPhoneNumbers: RequestedQuantity?) {
        self.isRequestingName = isRequestingName
        self.numberOfRequestedEmailAddresses = numberOfRequestedEmailAddresses
        self.numberOfRequestedPhoneNumbers = numberOfRequestedPhoneNumbers
    }
}

extension DappToWalletInteractionPersonaDataRequestItem: Sendable {}
extension DappToWalletInteractionPersonaDataRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionPersonaDataRequestItem, rhs: DappToWalletInteractionPersonaDataRequestItem) -> Bool {
        if lhs.isRequestingName != rhs.isRequestingName {
            return false
        }
        if lhs.numberOfRequestedEmailAddresses != rhs.numberOfRequestedEmailAddresses {
            return false
        }
        if lhs.numberOfRequestedPhoneNumbers != rhs.numberOfRequestedPhoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isRequestingName)
        hasher.combine(numberOfRequestedEmailAddresses)
        hasher.combine(numberOfRequestedPhoneNumbers)
    }
}

public struct FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionPersonaDataRequestItem {
        return
            try DappToWalletInteractionPersonaDataRequestItem(
                isRequestingName: FfiConverterOptionBool.read(from: &buf),
                numberOfRequestedEmailAddresses: FfiConverterOptionTypeRequestedQuantity.read(from: &buf),
                numberOfRequestedPhoneNumbers: FfiConverterOptionTypeRequestedQuantity.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionPersonaDataRequestItem, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.isRequestingName, into: &buf)
        FfiConverterOptionTypeRequestedQuantity.write(value.numberOfRequestedEmailAddresses, into: &buf)
        FfiConverterOptionTypeRequestedQuantity.write(value.numberOfRequestedPhoneNumbers, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionPersonaDataRequestItem {
    return try FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem_lower(_ value: DappToWalletInteractionPersonaDataRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.lower(value)
}

public struct DappToWalletInteractionResetRequestItem {
    public var accounts: Bool
    public var personaData: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accounts: Bool, personaData: Bool) {
        self.accounts = accounts
        self.personaData = personaData
    }
}

extension DappToWalletInteractionResetRequestItem: Sendable {}
extension DappToWalletInteractionResetRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionResetRequestItem, rhs: DappToWalletInteractionResetRequestItem) -> Bool {
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.personaData != rhs.personaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accounts)
        hasher.combine(personaData)
    }
}

public struct FfiConverterTypeDappToWalletInteractionResetRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionResetRequestItem {
        return
            try DappToWalletInteractionResetRequestItem(
                accounts: FfiConverterBool.read(from: &buf),
                personaData: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionResetRequestItem, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.accounts, into: &buf)
        FfiConverterBool.write(value.personaData, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionResetRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionResetRequestItem {
    return try FfiConverterTypeDappToWalletInteractionResetRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionResetRequestItem_lower(_ value: DappToWalletInteractionResetRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionResetRequestItem.lower(value)
}

public struct DappToWalletInteractionSendTransactionItem {
    public var unvalidatedManifest: UnvalidatedTransactionManifest
    public var version: TxVersion
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(unvalidatedManifest: UnvalidatedTransactionManifest, version: TxVersion, message: String?) {
        self.unvalidatedManifest = unvalidatedManifest
        self.version = version
        self.message = message
    }
}

extension DappToWalletInteractionSendTransactionItem: Sendable {}
extension DappToWalletInteractionSendTransactionItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionSendTransactionItem, rhs: DappToWalletInteractionSendTransactionItem) -> Bool {
        if lhs.unvalidatedManifest != rhs.unvalidatedManifest {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(unvalidatedManifest)
        hasher.combine(version)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeDappToWalletInteractionSendTransactionItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSendTransactionItem {
        return
            try DappToWalletInteractionSendTransactionItem(
                unvalidatedManifest: FfiConverterTypeUnvalidatedTransactionManifest.read(from: &buf),
                version: FfiConverterTypeTXVersion.read(from: &buf),
                message: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionSendTransactionItem, into buf: inout [UInt8]) {
        FfiConverterTypeUnvalidatedTransactionManifest.write(value.unvalidatedManifest, into: &buf)
        FfiConverterTypeTXVersion.write(value.version, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionSendTransactionItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSendTransactionItem {
    return try FfiConverterTypeDappToWalletInteractionSendTransactionItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSendTransactionItem_lower(_ value: DappToWalletInteractionSendTransactionItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSendTransactionItem.lower(value)
}

public struct DappToWalletInteractionTransactionItems {
    public var send: DappToWalletInteractionSendTransactionItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(send: DappToWalletInteractionSendTransactionItem) {
        self.send = send
    }
}

extension DappToWalletInteractionTransactionItems: Sendable {}
extension DappToWalletInteractionTransactionItems: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionTransactionItems, rhs: DappToWalletInteractionTransactionItems) -> Bool {
        if lhs.send != rhs.send {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(send)
    }
}

public struct FfiConverterTypeDappToWalletInteractionTransactionItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionTransactionItems {
        return
            try DappToWalletInteractionTransactionItems(
                send: FfiConverterTypeDappToWalletInteractionSendTransactionItem.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionTransactionItems, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionSendTransactionItem.write(value.send, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionTransactionItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionTransactionItems {
    return try FfiConverterTypeDappToWalletInteractionTransactionItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionTransactionItems_lower(_ value: DappToWalletInteractionTransactionItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionTransactionItems.lower(value)
}

public struct DappToWalletInteractionUnauthorizedRequestItems {
    public var oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?
    public var oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?, oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?) {
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
    }
}

extension DappToWalletInteractionUnauthorizedRequestItems: Sendable {}
extension DappToWalletInteractionUnauthorizedRequestItems: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionUnauthorizedRequestItems, rhs: DappToWalletInteractionUnauthorizedRequestItems) -> Bool {
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
    }
}

public struct FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionUnauthorizedRequestItems {
        return
            try DappToWalletInteractionUnauthorizedRequestItems(
                oneTimeAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf),
                oneTimePersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionUnauthorizedRequestItems, into buf: inout [UInt8]) {
        FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.oneTimePersonaData, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionUnauthorizedRequestItems {
    return try FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems_lower(_ value: DappToWalletInteractionUnauthorizedRequestItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.lower(value)
}

public struct DappToWalletInteractionUnvalidated {
    public var interactionId: WalletInteractionId
    public var items: DappToWalletInteractionItems
    public var metadata: DappToWalletInteractionMetadataUnvalidated

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, items: DappToWalletInteractionItems, metadata: DappToWalletInteractionMetadataUnvalidated) {
        self.interactionId = interactionId
        self.items = items
        self.metadata = metadata
    }
}

extension DappToWalletInteractionUnvalidated: Sendable {}
extension DappToWalletInteractionUnvalidated: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionUnvalidated, rhs: DappToWalletInteractionUnvalidated) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(items)
        hasher.combine(metadata)
    }
}

public struct FfiConverterTypeDappToWalletInteractionUnvalidated: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionUnvalidated {
        return
            try DappToWalletInteractionUnvalidated(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                items: FfiConverterTypeDappToWalletInteractionItems.read(from: &buf),
                metadata: FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionUnvalidated, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeDappToWalletInteractionItems.write(value.items, into: &buf)
        FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.write(value.metadata, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionUnvalidated_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionUnvalidated.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionUnvalidated_lower(_ value: DappToWalletInteractionUnvalidated) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionUnvalidated.lower(value)
}

public struct DappWalletInteractionPersona {
    public var identityAddress: IdentityAddress
    public var label: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityAddress: IdentityAddress, label: String) {
        self.identityAddress = identityAddress
        self.label = label
    }
}

extension DappWalletInteractionPersona: Sendable {}
extension DappWalletInteractionPersona: Equatable, Hashable {
    public static func == (lhs: DappWalletInteractionPersona, rhs: DappWalletInteractionPersona) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(label)
    }
}

public struct FfiConverterTypeDappWalletInteractionPersona: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappWalletInteractionPersona {
        return
            try DappWalletInteractionPersona(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
                label: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DappWalletInteractionPersona, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
    }
}

public func FfiConverterTypeDappWalletInteractionPersona_lift(_ buf: RustBuffer) throws -> DappWalletInteractionPersona {
    return try FfiConverterTypeDappWalletInteractionPersona.lift(buf)
}

public func FfiConverterTypeDappWalletInteractionPersona_lower(_ value: DappWalletInteractionPersona) -> RustBuffer {
    return FfiConverterTypeDappWalletInteractionPersona.lower(value)
}

/**
 * `Decimal192` represents a 192 bit representation of a fixed-scale decimal number.
 *
 * The finite set of values are of the form `m / 10^18`, where `m` is
 * an integer such that `-2^(192 - 1) <= m < 2^(192 - 1)`.
 *
 * Fractional part: ~60 bits/18 digits
 * Integer part   : 132 bits /40 digits
 * Max            :  3138550867693340381917894711603833208051.177722232017256447
 * Min            : -3138550867693340381917894711603833208051.177722232017256448
 *
 * Unless otherwise specified, all operations will panic if underflow/overflow.
 *
 * Powering it is the [Scrypto Decimal type, see docs][scrypto].
 *
 * Note: This type cannot be called `Decimal`, since it results in naming collision
 * in the Swift land (clash with `Foundation.Decimal`) instead we have created a
 * type alias `Decimal = Decimal192` which we use in Rust land.
 *
 * [scrypto]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/math/decimal.rs#L42
 */
public struct Decimal192 {
    fileprivate let secretMagic: ScryptoDecimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: ScryptoDecimal192) {
        self.secretMagic = secretMagic
    }
}

extension Decimal192: Sendable {}
extension Decimal192: Equatable, Hashable {
    public static func == (lhs: Decimal192, rhs: Decimal192) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeDecimal192: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Decimal192 {
        return
            try Decimal192(
                secretMagic: FfiConverterTypeScryptoDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: Decimal192, into buf: inout [UInt8]) {
        FfiConverterTypeScryptoDecimal192.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeDecimal192_lift(_ buf: RustBuffer) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(buf)
}

public func FfiConverterTypeDecimal192_lower(_ value: Decimal192) -> RustBuffer {
    return FfiConverterTypeDecimal192.lower(value)
}

/**
 * A factor source representing the host device which SargonOS runs on, typically
 * an iPhone or Android device.
 *
 * This is the initial factor source of
 * all new Accounts and Personas. Users authenticate signing by authorizing
 * the host to access a mnemonic stored in secure storage on
 * the device.
 */
public struct DeviceFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a DeviceFactorSource to help user disambiguate between it and another one.
     */
    public var hint: DeviceFactorSourceHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon,
        /**
            * Properties describing a DeviceFactorSource to help user disambiguate between it and another one.
            */ hint: DeviceFactorSourceHint
    ) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}

extension DeviceFactorSource: Sendable {}
extension DeviceFactorSource: Equatable, Hashable {
    public static func == (lhs: DeviceFactorSource, rhs: DeviceFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}

public struct FfiConverterTypeDeviceFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSource {
        return
            try DeviceFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                hint: FfiConverterTypeDeviceFactorSourceHint.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeDeviceFactorSourceHint.write(value.hint, into: &buf)
    }
}

public func FfiConverterTypeDeviceFactorSource_lift(_ buf: RustBuffer) throws -> DeviceFactorSource {
    return try FfiConverterTypeDeviceFactorSource.lift(buf)
}

public func FfiConverterTypeDeviceFactorSource_lower(_ value: DeviceFactorSource) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSource.lower(value)
}

/**
 * Properties describing a DeviceFactorSource to help user disambiguate between
 * it and another one.
 */
public struct DeviceFactorSourceHint {
    /**
     * "iPhone RED"
     */
    public var name: String
    /**
     * "iPhone SE 2nd gen"
     */
    public var model: String
    /**
     * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
     * standard, a multiple of 3, from 12 to 24 words.
     */
    public var mnemonicWordCount: Bip39WordCount
    /**
     * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
     *
     * It is possible that the host device has been updated to a new
     * version than recorded here, but Sargon or host clients might
     * just not have updated this value here.
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var systemVersion: String?
    /**
     * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
     *
     * It is possible that the host device has been updated to a new
     * version than recorded here, but Sargon or host clients might
     * just not have updated this value here.
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var hostAppVersion: String?
    /**
     * The vendor of the device host, e.g. "Apple" or "Samsung".
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var hostVendor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * "iPhone RED"
         */ name: String,
        /**
            * "iPhone SE 2nd gen"
            */ model: String,
        /**
            * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
            * standard, a multiple of 3, from 12 to 24 words.
            */ mnemonicWordCount: Bip39WordCount,
        /**
            * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
            *
            * It is possible that the host device has been updated to a new
            * version than recorded here, but Sargon or host clients might
            * just not have updated this value here.
            *
            * MUST be optional since this was added on 2024-05-03 and
            * was not present in earlier version of wallet (pre 1.6.0).
            */ systemVersion: String?,
        /**
            * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
            *
            * It is possible that the host device has been updated to a new
            * version than recorded here, but Sargon or host clients might
            * just not have updated this value here.
            *
            * MUST be optional since this was added on 2024-05-03 and
            * was not present in earlier version of wallet (pre 1.6.0).
            */ hostAppVersion: String?,
        /**
            * The vendor of the device host, e.g. "Apple" or "Samsung".
            *
            * MUST be optional since this was added on 2024-05-03 and
            * was not present in earlier version of wallet (pre 1.6.0).
            */ hostVendor: String?
    ) {
        self.name = name
        self.model = model
        self.mnemonicWordCount = mnemonicWordCount
        self.systemVersion = systemVersion
        self.hostAppVersion = hostAppVersion
        self.hostVendor = hostVendor
    }
}

extension DeviceFactorSourceHint: Sendable {}
extension DeviceFactorSourceHint: Equatable, Hashable {
    public static func == (lhs: DeviceFactorSourceHint, rhs: DeviceFactorSourceHint) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        if lhs.mnemonicWordCount != rhs.mnemonicWordCount {
            return false
        }
        if lhs.systemVersion != rhs.systemVersion {
            return false
        }
        if lhs.hostAppVersion != rhs.hostAppVersion {
            return false
        }
        if lhs.hostVendor != rhs.hostVendor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
        hasher.combine(mnemonicWordCount)
        hasher.combine(systemVersion)
        hasher.combine(hostAppVersion)
        hasher.combine(hostVendor)
    }
}

public struct FfiConverterTypeDeviceFactorSourceHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSourceHint {
        return
            try DeviceFactorSourceHint(
                name: FfiConverterString.read(from: &buf),
                model: FfiConverterString.read(from: &buf),
                mnemonicWordCount: FfiConverterTypeBIP39WordCount.read(from: &buf),
                systemVersion: FfiConverterOptionString.read(from: &buf),
                hostAppVersion: FfiConverterOptionString.read(from: &buf),
                hostVendor: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceFactorSourceHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.model, into: &buf)
        FfiConverterTypeBIP39WordCount.write(value.mnemonicWordCount, into: &buf)
        FfiConverterOptionString.write(value.systemVersion, into: &buf)
        FfiConverterOptionString.write(value.hostAppVersion, into: &buf)
        FfiConverterOptionString.write(value.hostVendor, into: &buf)
    }
}

public func FfiConverterTypeDeviceFactorSourceHint_lift(_ buf: RustBuffer) throws -> DeviceFactorSourceHint {
    return try FfiConverterTypeDeviceFactorSourceHint.lift(buf)
}

public func FfiConverterTypeDeviceFactorSourceHint_lower(_ value: DeviceFactorSourceHint) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSourceHint.lower(value)
}

/**
 * A short summary of a device the Profile is being used
 * on, typically an iPhone or an Android phone.
 */
public struct DeviceInfo {
    /**
     * A best effort stable and unique identifier of this
     * device.
     *
     * Apple has made it so that iOS devices cannot
     * query iOS for a unique identifier of the device, thus
     * the iOS team has made their own impl of a best effort
     * stable identifier.
     */
    public var id: DeviceId
    /**
     * The date this description of the device was made, might
     * be equal to when the app was first ever launched on the
     * device.
     */
    public var date: Timestamp
    /**
     * A short description of the device, we devices should
     * read the device model and a given name from the device
     * if they are able to.
     */
    public var description: String
    /**
     * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
     *
     * It is possible that the host device has been updated to a new
     * version than recorded here, but Sargon or host clients might
     * just not have updated this value here.
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var systemVersion: String?
    /**
     * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
     *
     * It is possible that the host device has been updated to a new
     * version than recorded here, but Sargon or host clients might
     * just not have updated this value here.
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var hostAppVersion: String?
    /**
     * The vendor of the host client, e.g. "Apple" for iPhone clients,
     * or "Samsung" for Android clients.
     *
     * MUST be optional since this was added on 2024-05-16 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var hostVendor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A best effort stable and unique identifier of this
         * device.
         *
         * Apple has made it so that iOS devices cannot
         * query iOS for a unique identifier of the device, thus
         * the iOS team has made their own impl of a best effort
         * stable identifier.
         */ id: DeviceId,
        /**
            * The date this description of the device was made, might
            * be equal to when the app was first ever launched on the
            * device.
            */ date: Timestamp,
        /**
            * A short description of the device, we devices should
            * read the device model and a given name from the device
            * if they are able to.
            */ description: String,
        /**
            * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
            *
            * It is possible that the host device has been updated to a new
            * version than recorded here, but Sargon or host clients might
            * just not have updated this value here.
            *
            * MUST be optional since this was added on 2024-05-03 and
            * was not present in earlier version of wallet (pre 1.6.0).
            */ systemVersion: String?,
        /**
            * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
            *
            * It is possible that the host device has been updated to a new
            * version than recorded here, but Sargon or host clients might
            * just not have updated this value here.
            *
            * MUST be optional since this was added on 2024-05-03 and
            * was not present in earlier version of wallet (pre 1.6.0).
            */ hostAppVersion: String?,
        /**
            * The vendor of the host client, e.g. "Apple" for iPhone clients,
            * or "Samsung" for Android clients.
            *
            * MUST be optional since this was added on 2024-05-16 and
            * was not present in earlier version of wallet (pre 1.6.0).
            */ hostVendor: String?
    ) {
        self.id = id
        self.date = date
        self.description = description
        self.systemVersion = systemVersion
        self.hostAppVersion = hostAppVersion
        self.hostVendor = hostVendor
    }
}

extension DeviceInfo: Sendable {}
extension DeviceInfo: Equatable, Hashable {
    public static func == (lhs: DeviceInfo, rhs: DeviceInfo) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.date != rhs.date {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.systemVersion != rhs.systemVersion {
            return false
        }
        if lhs.hostAppVersion != rhs.hostAppVersion {
            return false
        }
        if lhs.hostVendor != rhs.hostVendor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(date)
        hasher.combine(description)
        hasher.combine(systemVersion)
        hasher.combine(hostAppVersion)
        hasher.combine(hostVendor)
    }
}

public struct FfiConverterTypeDeviceInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceInfo {
        return
            try DeviceInfo(
                id: FfiConverterTypeDeviceID.read(from: &buf),
                date: FfiConverterTypeTimestamp.read(from: &buf),
                description: FfiConverterString.read(from: &buf),
                systemVersion: FfiConverterOptionString.read(from: &buf),
                hostAppVersion: FfiConverterOptionString.read(from: &buf),
                hostVendor: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceInfo, into buf: inout [UInt8]) {
        FfiConverterTypeDeviceID.write(value.id, into: &buf)
        FfiConverterTypeTimestamp.write(value.date, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.systemVersion, into: &buf)
        FfiConverterOptionString.write(value.hostAppVersion, into: &buf)
        FfiConverterOptionString.write(value.hostVendor, into: &buf)
    }
}

public func FfiConverterTypeDeviceInfo_lift(_ buf: RustBuffer) throws -> DeviceInfo {
    return try FfiConverterTypeDeviceInfo.lift(buf)
}

public func FfiConverterTypeDeviceInfo_lower(_ value: DeviceInfo) -> RustBuffer {
    return FfiConverterTypeDeviceInfo.lower(value)
}

/**
 * A name and model of a host device.
 *
 * This used to be a String only in Pre 1.6.0 wallets, so
 * we have a custom Deserialize impl of it.
 */
public struct DeviceInfoDescription {
    /**
     * Host device name, e.g. "My Precious"
     */
    public var name: String
    /**
     * Host device model, e.g. "iPhone 15 Pro"
     */
    public var model: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Host device name, e.g. "My Precious"
         */ name: String,
        /**
            * Host device model, e.g. "iPhone 15 Pro"
            */ model: String
    ) {
        self.name = name
        self.model = model
    }
}

extension DeviceInfoDescription: Sendable {}
extension DeviceInfoDescription: Equatable, Hashable {
    public static func == (lhs: DeviceInfoDescription, rhs: DeviceInfoDescription) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
    }
}

public struct FfiConverterTypeDeviceInfoDescription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceInfoDescription {
        return
            try DeviceInfoDescription(
                name: FfiConverterString.read(from: &buf),
                model: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceInfoDescription, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.model, into: &buf)
    }
}

public func FfiConverterTypeDeviceInfoDescription_lift(_ buf: RustBuffer) throws -> DeviceInfoDescription {
    return try FfiConverterTypeDeviceInfoDescription.lift(buf)
}

public func FfiConverterTypeDeviceInfoDescription_lower(_ value: DeviceInfoDescription) -> RustBuffer {
    return FfiConverterTypeDeviceInfoDescription.lower(value)
}

/**
 * A max 30 chars long string used for display purposes, e.g.
 * the name of an Account or Persona.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 * #[allow(clippy::upper_case_acronyms)]
 * type SUT = DisplayName;
 *
 * assert_eq!(SUT::MAX_LEN, 30);
 * assert_eq!("Satoshi".parse::<SUT>().unwrap().to_string(), "Satoshi");
 * ```
 *
 * Names with longer than 30 chars are trimmed.
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 * #[allow(clippy::upper_case_acronyms)]
 * type SUT = DisplayName;
 * assert_eq!("A very big name that is over than 30 characters long".parse::<SUT>().unwrap().to_string(), "A very big name that is over t");
 * ```

 */
public struct DisplayName {
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: String) {
        self.value = value
    }
}

extension DisplayName: Sendable {}
extension DisplayName: Equatable, Hashable {
    public static func == (lhs: DisplayName, rhs: DisplayName) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeDisplayName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DisplayName {
        return
            try DisplayName(
                value: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DisplayName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeDisplayName_lift(_ buf: RustBuffer) throws -> DisplayName {
    return try FfiConverterTypeDisplayName.lift(buf)
}

public func FfiConverterTypeDisplayName_lower(_ value: DisplayName) -> RustBuffer {
    return FfiConverterTypeDisplayName.lower(value)
}

/**
 * An Ed25519 public key used to verify cryptographic signatures (EdDSA signatures).
 */
public struct Ed25519PublicKey {
    fileprivate let secretMagic: ScryptoEd25519PublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: ScryptoEd25519PublicKey) {
        self.secretMagic = secretMagic
    }
}

extension Ed25519PublicKey: Sendable {}
extension Ed25519PublicKey: Equatable, Hashable {
    public static func == (lhs: Ed25519PublicKey, rhs: Ed25519PublicKey) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEd25519PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519PublicKey {
        return
            try Ed25519PublicKey(
                secretMagic: FfiConverterTypeScryptoEd25519PublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: Ed25519PublicKey, into buf: inout [UInt8]) {
        FfiConverterTypeScryptoEd25519PublicKey.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEd25519PublicKey_lift(_ buf: RustBuffer) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(buf)
}

public func FfiConverterTypeEd25519PublicKey_lower(_ value: Ed25519PublicKey) -> RustBuffer {
    return FfiConverterTypeEd25519PublicKey.lower(value)
}

/**
 * Represents an ED25519 signature.
 */
public struct Ed25519Signature {
    public var bytes: Exactly64Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Exactly64Bytes) {
        self.bytes = bytes
    }
}

extension Ed25519Signature: Sendable {}
extension Ed25519Signature: Equatable, Hashable {
    public static func == (lhs: Ed25519Signature, rhs: Ed25519Signature) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}

public struct FfiConverterTypeEd25519Signature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519Signature {
        return
            try Ed25519Signature(
                bytes: FfiConverterTypeExactly64Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: Ed25519Signature, into buf: inout [UInt8]) {
        FfiConverterTypeExactly64Bytes.write(value.bytes, into: &buf)
    }
}

public func FfiConverterTypeEd25519Signature_lift(_ buf: RustBuffer) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(buf)
}

public func FfiConverterTypeEd25519Signature_lower(_ value: Ed25519Signature) -> RustBuffer {
    return FfiConverterTypeEd25519Signature.lower(value)
}

/**
 * An email address.
 *
 * Current implementation does not validate the email address other than it
 * cannot be empty (in the future we might add some simple validation).
 */
public struct EmailAddress {
    public var email: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(email: String) {
        self.email = email
    }
}

extension EmailAddress: Sendable {}
extension EmailAddress: Equatable, Hashable {
    public static func == (lhs: EmailAddress, rhs: EmailAddress) -> Bool {
        if lhs.email != rhs.email {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(email)
    }
}

public struct FfiConverterTypeEmailAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmailAddress {
        return
            try EmailAddress(
                email: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: EmailAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.email, into: &buf)
    }
}

public func FfiConverterTypeEmailAddress_lift(_ buf: RustBuffer) throws -> EmailAddress {
    return try FfiConverterTypeEmailAddress.lift(buf)
}

public func FfiConverterTypeEmailAddress_lower(_ value: EmailAddress) -> RustBuffer {
    return FfiConverterTypeEmailAddress.lower(value)
}

public struct EntityMetadataCollection {
    public var items: [EntityMetadataItem]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [EntityMetadataItem]) {
        self.items = items
    }
}

extension EntityMetadataCollection: Sendable {}
extension EntityMetadataCollection: Equatable, Hashable {
    public static func == (lhs: EntityMetadataCollection, rhs: EntityMetadataCollection) -> Bool {
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(items)
    }
}

public struct FfiConverterTypeEntityMetadataCollection: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityMetadataCollection {
        return
            try EntityMetadataCollection(
                items: FfiConverterSequenceTypeEntityMetadataItem.read(from: &buf)
            )
    }

    public static func write(_ value: EntityMetadataCollection, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeEntityMetadataItem.write(value.items, into: &buf)
    }
}

public func FfiConverterTypeEntityMetadataCollection_lift(_ buf: RustBuffer) throws -> EntityMetadataCollection {
    return try FfiConverterTypeEntityMetadataCollection.lift(buf)
}

public func FfiConverterTypeEntityMetadataCollection_lower(_ value: EntityMetadataCollection) -> RustBuffer {
    return FfiConverterTypeEntityMetadataCollection.lower(value)
}

public struct EntityMetadataItem {
    public var key: String
    public var value: EntityMetadataItemValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, value: EntityMetadataItemValue) {
        self.key = key
        self.value = value
    }
}

extension EntityMetadataItem: Sendable {}
extension EntityMetadataItem: Equatable, Hashable {
    public static func == (lhs: EntityMetadataItem, rhs: EntityMetadataItem) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(value)
    }
}

public struct FfiConverterTypeEntityMetadataItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityMetadataItem {
        return
            try EntityMetadataItem(
                key: FfiConverterString.read(from: &buf),
                value: FfiConverterTypeEntityMetadataItemValue.read(from: &buf)
            )
    }

    public static func write(_ value: EntityMetadataItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterTypeEntityMetadataItemValue.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeEntityMetadataItem_lift(_ buf: RustBuffer) throws -> EntityMetadataItem {
    return try FfiConverterTypeEntityMetadataItem.lift(buf)
}

public func FfiConverterTypeEntityMetadataItem_lower(_ value: EntityMetadataItem) -> RustBuffer {
    return FfiConverterTypeEntityMetadataItem.lower(value)
}

public struct EntityMetadataItemValue {
    public var typed: MetadataTypedValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typed: MetadataTypedValue) {
        self.typed = typed
    }
}

extension EntityMetadataItemValue: Sendable {}
extension EntityMetadataItemValue: Equatable, Hashable {
    public static func == (lhs: EntityMetadataItemValue, rhs: EntityMetadataItemValue) -> Bool {
        if lhs.typed != rhs.typed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typed)
    }
}

public struct FfiConverterTypeEntityMetadataItemValue: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityMetadataItemValue {
        return
            try EntityMetadataItemValue(
                typed: FfiConverterTypeMetadataTypedValue.read(from: &buf)
            )
    }

    public static func write(_ value: EntityMetadataItemValue, into buf: inout [UInt8]) {
        FfiConverterTypeMetadataTypedValue.write(value.typed, into: &buf)
    }
}

public func FfiConverterTypeEntityMetadataItemValue_lift(_ buf: RustBuffer) throws -> EntityMetadataItemValue {
    return try FfiConverterTypeEntityMetadataItemValue.lift(buf)
}

public func FfiConverterTypeEntityMetadataItemValue_lower(_ value: EntityMetadataItemValue) -> RustBuffer {
    return FfiConverterTypeEntityMetadataItemValue.lower(value)
}

public struct Entropy16Bytes {
    fileprivate let secretMagic: Entropy16BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Entropy16BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Entropy16Bytes: Sendable {}
extension Entropy16Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy16Bytes, rhs: Entropy16Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEntropy16Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy16Bytes {
        return
            try Entropy16Bytes(
                secretMagic: FfiConverterTypeEntropy16BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy16Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeEntropy16BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEntropy16Bytes_lift(_ buf: RustBuffer) throws -> Entropy16Bytes {
    return try FfiConverterTypeEntropy16Bytes.lift(buf)
}

public func FfiConverterTypeEntropy16Bytes_lower(_ value: Entropy16Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy16Bytes.lower(value)
}

public struct Entropy20Bytes {
    fileprivate let secretMagic: Entropy20BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Entropy20BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Entropy20Bytes: Sendable {}
extension Entropy20Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy20Bytes, rhs: Entropy20Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEntropy20Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy20Bytes {
        return
            try Entropy20Bytes(
                secretMagic: FfiConverterTypeEntropy20BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy20Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeEntropy20BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEntropy20Bytes_lift(_ buf: RustBuffer) throws -> Entropy20Bytes {
    return try FfiConverterTypeEntropy20Bytes.lift(buf)
}

public func FfiConverterTypeEntropy20Bytes_lower(_ value: Entropy20Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy20Bytes.lower(value)
}

public struct Entropy24Bytes {
    fileprivate let secretMagic: Entropy24BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Entropy24BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Entropy24Bytes: Sendable {}
extension Entropy24Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy24Bytes, rhs: Entropy24Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEntropy24Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy24Bytes {
        return
            try Entropy24Bytes(
                secretMagic: FfiConverterTypeEntropy24BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy24Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeEntropy24BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEntropy24Bytes_lift(_ buf: RustBuffer) throws -> Entropy24Bytes {
    return try FfiConverterTypeEntropy24Bytes.lift(buf)
}

public func FfiConverterTypeEntropy24Bytes_lower(_ value: Entropy24Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy24Bytes.lower(value)
}

public struct Entropy28Bytes {
    fileprivate let secretMagic: Entropy28BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Entropy28BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Entropy28Bytes: Sendable {}
extension Entropy28Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy28Bytes, rhs: Entropy28Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEntropy28Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy28Bytes {
        return
            try Entropy28Bytes(
                secretMagic: FfiConverterTypeEntropy28BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy28Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeEntropy28BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEntropy28Bytes_lift(_ buf: RustBuffer) throws -> Entropy28Bytes {
    return try FfiConverterTypeEntropy28Bytes.lift(buf)
}

public func FfiConverterTypeEntropy28Bytes_lower(_ value: Entropy28Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy28Bytes.lower(value)
}

public struct Entropy32Bytes {
    fileprivate let secretMagic: Entropy32BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Entropy32BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Entropy32Bytes: Sendable {}
extension Entropy32Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy32Bytes, rhs: Entropy32Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEntropy32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy32Bytes {
        return
            try Entropy32Bytes(
                secretMagic: FfiConverterTypeEntropy32BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeEntropy32BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEntropy32Bytes_lift(_ buf: RustBuffer) throws -> Entropy32Bytes {
    return try FfiConverterTypeEntropy32Bytes.lift(buf)
}

public func FfiConverterTypeEntropy32Bytes_lower(_ value: Entropy32Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy32Bytes.lower(value)
}

/**
 * A notification containing a timestamped and unique `event`, host client
 * can subscribe to these notifications by using the EventBusDriver.
 */
public struct EventNotification {
    public var id: Uuid
    public var event: Event
    public var timestamp: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Uuid, event: Event, timestamp: Timestamp) {
        self.id = id
        self.event = event
        self.timestamp = timestamp
    }
}

extension EventNotification: Sendable {}
extension EventNotification: Equatable, Hashable {
    public static func == (lhs: EventNotification, rhs: EventNotification) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.event != rhs.event {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(event)
        hasher.combine(timestamp)
    }
}

public struct FfiConverterTypeEventNotification: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventNotification {
        return
            try EventNotification(
                id: FfiConverterTypeUuid.read(from: &buf),
                event: FfiConverterTypeEvent.read(from: &buf),
                timestamp: FfiConverterTypeTimestamp.read(from: &buf)
            )
    }

    public static func write(_ value: EventNotification, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeEvent.write(value.event, into: &buf)
        FfiConverterTypeTimestamp.write(value.timestamp, into: &buf)
    }
}

public func FfiConverterTypeEventNotification_lift(_ buf: RustBuffer) throws -> EventNotification {
    return try FfiConverterTypeEventNotification.lift(buf)
}

public func FfiConverterTypeEventNotification_lower(_ value: EventNotification) -> RustBuffer {
    return FfiConverterTypeEventNotification.lower(value)
}

/**
 * 12 bytes, used by AES encryption, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly12Bytes {
    fileprivate let secretMagic: Exactly12BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly12BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly12Bytes: Sendable {}
extension Exactly12Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly12Bytes, rhs: Exactly12Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly12Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly12Bytes {
        return
            try Exactly12Bytes(
                secretMagic: FfiConverterTypeExactly12BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly12Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly12BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly12Bytes_lift(_ buf: RustBuffer) throws -> Exactly12Bytes {
    return try FfiConverterTypeExactly12Bytes.lift(buf)
}

public func FfiConverterTypeExactly12Bytes_lower(_ value: Exactly12Bytes) -> RustBuffer {
    return FfiConverterTypeExactly12Bytes.lower(value)
}

/**
 * 29 bytes, typically used as PublicKeyHash, or otherwise NodeId payload,
 * implementation wise those bytes are stored inside a `BagOfBytes`
 * (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly29Bytes {
    fileprivate let secretMagic: Exactly29BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly29BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly29Bytes: Sendable {}
extension Exactly29Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly29Bytes, rhs: Exactly29Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly29Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly29Bytes {
        return
            try Exactly29Bytes(
                secretMagic: FfiConverterTypeExactly29BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly29Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly29BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly29Bytes_lift(_ buf: RustBuffer) throws -> Exactly29Bytes {
    return try FfiConverterTypeExactly29Bytes.lift(buf)
}

public func FfiConverterTypeExactly29Bytes_lower(_ value: Exactly29Bytes) -> RustBuffer {
    return FfiConverterTypeExactly29Bytes.lower(value)
}

/**
 * 32 bytes, most commonly used fixed length bytes, used by PrivateKeys,
 * Ed25519PublicKey, and BIP39 entropy, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly32Bytes {
    fileprivate let secretMagic: Exactly32BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly32BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly32Bytes: Sendable {}
extension Exactly32Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly32Bytes, rhs: Exactly32Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly32Bytes {
        return
            try Exactly32Bytes(
                secretMagic: FfiConverterTypeExactly32BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly32BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly32Bytes_lift(_ buf: RustBuffer) throws -> Exactly32Bytes {
    return try FfiConverterTypeExactly32Bytes.lift(buf)
}

public func FfiConverterTypeExactly32Bytes_lower(_ value: Exactly32Bytes) -> RustBuffer {
    return FfiConverterTypeExactly32Bytes.lower(value)
}

/**
 * 33 bytes, used by Secp256k1PublicKeys, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly33Bytes {
    fileprivate let secretMagic: Exactly33BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly33BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly33Bytes: Sendable {}
extension Exactly33Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly33Bytes, rhs: Exactly33Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly33Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly33Bytes {
        return
            try Exactly33Bytes(
                secretMagic: FfiConverterTypeExactly33BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly33Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly33BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly33Bytes_lift(_ buf: RustBuffer) throws -> Exactly33Bytes {
    return try FfiConverterTypeExactly33Bytes.lift(buf)
}

public func FfiConverterTypeExactly33Bytes_lower(_ value: Exactly33Bytes) -> RustBuffer {
    return FfiConverterTypeExactly33Bytes.lower(value)
}

/**
 * 60 bytes, used as encrypted mnemonic for security questions factor
 * source. 32 bytes mnemonic when encrypted results in exactly this length.
 */
public struct Exactly60Bytes {
    fileprivate let secretMagic: Exactly60BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly60BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly60Bytes: Sendable {}
extension Exactly60Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly60Bytes, rhs: Exactly60Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly60Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly60Bytes {
        return
            try Exactly60Bytes(
                secretMagic: FfiConverterTypeExactly60BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly60Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly60BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly60Bytes_lift(_ buf: RustBuffer) throws -> Exactly60Bytes {
    return try FfiConverterTypeExactly60Bytes.lift(buf)
}

public func FfiConverterTypeExactly60Bytes_lower(_ value: Exactly60Bytes) -> RustBuffer {
    return FfiConverterTypeExactly60Bytes.lower(value)
}

/**
 * 64 bytes, used by Ed25519Signatures, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly64Bytes {
    fileprivate let secretMagic: Exactly64BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly64BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly64Bytes: Sendable {}
extension Exactly64Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly64Bytes, rhs: Exactly64Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly64Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly64Bytes {
        return
            try Exactly64Bytes(
                secretMagic: FfiConverterTypeExactly64BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly64Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly64BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly64Bytes_lift(_ buf: RustBuffer) throws -> Exactly64Bytes {
    return try FfiConverterTypeExactly64Bytes.lift(buf)
}

public func FfiConverterTypeExactly64Bytes_lower(_ value: Exactly64Bytes) -> RustBuffer {
    return FfiConverterTypeExactly64Bytes.lower(value)
}

/**
 * 65 bytes, used by Secp256k1Signatures, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly65Bytes {
    fileprivate let secretMagic: Exactly65BytesSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Exactly65BytesSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Exactly65Bytes: Sendable {}
extension Exactly65Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly65Bytes, rhs: Exactly65Bytes) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeExactly65Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly65Bytes {
        return
            try Exactly65Bytes(
                secretMagic: FfiConverterTypeExactly65BytesSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly65Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeExactly65BytesSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeExactly65Bytes_lift(_ buf: RustBuffer) throws -> Exactly65Bytes {
    return try FfiConverterTypeExactly65Bytes.lift(buf)
}

public func FfiConverterTypeExactly65Bytes_lower(_ value: Exactly65Bytes) -> RustBuffer {
    return FfiConverterTypeExactly65Bytes.lower(value)
}

/**
 * A summary of the execution of the manifest and the information that helps
 * wallets present the contents of a transaction.
 */
public struct ExecutionSummary {
    /**
     * Per account, a list of all token balances that has been withdrawn from that account.
     */
    public var withdrawals: [AccountAddress: [ResourceIndicator]]
    /**
     * Per account, a list of all token balances that has been deposited into that account.
     */
    public var deposits: [AccountAddress: [ResourceIndicator]]
    /**
     * Addresses of accounts encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the accounts of all those addresses, which might be multiple
     * signatures per Account, if MFA has been setup.
     */
    public var addressesOfAccountsRequiringAuth: [AccountAddress]
    /**
     * Addresses of identities (Personas) encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the identities of all those addresses, which might be multiple
     * signatures per Persona, if MFA has been setup.
     */
    public var addressesOfIdentitiesRequiringAuth: [IdentityAddress]
    /**
     * Information on the global entities created in the transaction.
     */
    public var newEntities: NewEntities
    /**
     * The various classifications that this manifest matched against. Note
     * that an empty set means that the manifest is non-conforming.
     */
    public var detailedClassification: [DetailedManifestClass]
    /**
     * List of newly created Non-Fungibles during this transaction.
     */
    public var newlyCreatedNonFungibles: [NonFungibleGlobalId]
    /**
     * The set of instructions encountered in the manifest that are reserved
     * and can only be included in the manifest by the wallet itself.
     */
    public var reservedInstructions: [ReservedInstruction]
    /**
     * The list of the resources of proofs that were presented in the manifest.
     */
    public var presentedProofs: [ResourceSpecifier]
    /**
     * The set of all the encountered `ComponentAddress`es` in the manifest. This is
     * to be primarily used for the "using dApps" section of the wallet's tx
     * review screen.
     */
    public var encounteredComponentAddresses: [ComponentAddress]
    /**
     * Information on how much fees were contingent and how much were not.
     */
    public var feeLocks: FeeLocks
    /**
     * Detailed information on the amount of cost units consumed.
     */
    public var feeSummary: FeeSummary

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Per account, a list of all token balances that has been withdrawn from that account.
         */ withdrawals: [AccountAddress: [ResourceIndicator]],
        /**
            * Per account, a list of all token balances that has been deposited into that account.
            */ deposits: [AccountAddress: [ResourceIndicator]],
        /**
            * Addresses of accounts encountered in the manifest where privileged
            * methods were called. The wallets will need to collect signatures
            * of the accounts of all those addresses, which might be multiple
            * signatures per Account, if MFA has been setup.
            */ addressesOfAccountsRequiringAuth: [AccountAddress],
        /**
            * Addresses of identities (Personas) encountered in the manifest where privileged
            * methods were called. The wallets will need to collect signatures
            * of the identities of all those addresses, which might be multiple
            * signatures per Persona, if MFA has been setup.
            */ addressesOfIdentitiesRequiringAuth: [IdentityAddress],
        /**
            * Information on the global entities created in the transaction.
            */ newEntities: NewEntities,
        /**
            * The various classifications that this manifest matched against. Note
            * that an empty set means that the manifest is non-conforming.
            */ detailedClassification: [DetailedManifestClass],
        /**
            * List of newly created Non-Fungibles during this transaction.
            */ newlyCreatedNonFungibles: [NonFungibleGlobalId],
        /**
            * The set of instructions encountered in the manifest that are reserved
            * and can only be included in the manifest by the wallet itself.
            */ reservedInstructions: [ReservedInstruction],
        /**
            * The list of the resources of proofs that were presented in the manifest.
            */ presentedProofs: [ResourceSpecifier],
        /**
            * The set of all the encountered `ComponentAddress`es` in the manifest. This is
            * to be primarily used for the "using dApps" section of the wallet's tx
            * review screen.
            */ encounteredComponentAddresses: [ComponentAddress],
        /**
            * Information on how much fees were contingent and how much were not.
            */ feeLocks: FeeLocks,
        /**
            * Detailed information on the amount of cost units consumed.
            */ feeSummary: FeeSummary
    ) {
        self.withdrawals = withdrawals
        self.deposits = deposits
        self.addressesOfAccountsRequiringAuth = addressesOfAccountsRequiringAuth
        self.addressesOfIdentitiesRequiringAuth = addressesOfIdentitiesRequiringAuth
        self.newEntities = newEntities
        self.detailedClassification = detailedClassification
        self.newlyCreatedNonFungibles = newlyCreatedNonFungibles
        self.reservedInstructions = reservedInstructions
        self.presentedProofs = presentedProofs
        self.encounteredComponentAddresses = encounteredComponentAddresses
        self.feeLocks = feeLocks
        self.feeSummary = feeSummary
    }
}

extension ExecutionSummary: Sendable {}
extension ExecutionSummary: Equatable, Hashable {
    public static func == (lhs: ExecutionSummary, rhs: ExecutionSummary) -> Bool {
        if lhs.withdrawals != rhs.withdrawals {
            return false
        }
        if lhs.deposits != rhs.deposits {
            return false
        }
        if lhs.addressesOfAccountsRequiringAuth != rhs.addressesOfAccountsRequiringAuth {
            return false
        }
        if lhs.addressesOfIdentitiesRequiringAuth != rhs.addressesOfIdentitiesRequiringAuth {
            return false
        }
        if lhs.newEntities != rhs.newEntities {
            return false
        }
        if lhs.detailedClassification != rhs.detailedClassification {
            return false
        }
        if lhs.newlyCreatedNonFungibles != rhs.newlyCreatedNonFungibles {
            return false
        }
        if lhs.reservedInstructions != rhs.reservedInstructions {
            return false
        }
        if lhs.presentedProofs != rhs.presentedProofs {
            return false
        }
        if lhs.encounteredComponentAddresses != rhs.encounteredComponentAddresses {
            return false
        }
        if lhs.feeLocks != rhs.feeLocks {
            return false
        }
        if lhs.feeSummary != rhs.feeSummary {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(withdrawals)
        hasher.combine(deposits)
        hasher.combine(addressesOfAccountsRequiringAuth)
        hasher.combine(addressesOfIdentitiesRequiringAuth)
        hasher.combine(newEntities)
        hasher.combine(detailedClassification)
        hasher.combine(newlyCreatedNonFungibles)
        hasher.combine(reservedInstructions)
        hasher.combine(presentedProofs)
        hasher.combine(encounteredComponentAddresses)
        hasher.combine(feeLocks)
        hasher.combine(feeSummary)
    }
}

public struct FfiConverterTypeExecutionSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExecutionSummary {
        return
            try ExecutionSummary(
                withdrawals: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.read(from: &buf),
                deposits: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.read(from: &buf),
                addressesOfAccountsRequiringAuth: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
                addressesOfIdentitiesRequiringAuth: FfiConverterSequenceTypeIdentityAddress.read(from: &buf),
                newEntities: FfiConverterTypeNewEntities.read(from: &buf),
                detailedClassification: FfiConverterSequenceTypeDetailedManifestClass.read(from: &buf),
                newlyCreatedNonFungibles: FfiConverterSequenceTypeNonFungibleGlobalId.read(from: &buf),
                reservedInstructions: FfiConverterSequenceTypeReservedInstruction.read(from: &buf),
                presentedProofs: FfiConverterSequenceTypeResourceSpecifier.read(from: &buf),
                encounteredComponentAddresses: FfiConverterSequenceTypeComponentAddress.read(from: &buf),
                feeLocks: FfiConverterTypeFeeLocks.read(from: &buf),
                feeSummary: FfiConverterTypeFeeSummary.read(from: &buf)
            )
    }

    public static func write(_ value: ExecutionSummary, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.write(value.withdrawals, into: &buf)
        FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.write(value.deposits, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsRequiringAuth, into: &buf)
        FfiConverterSequenceTypeIdentityAddress.write(value.addressesOfIdentitiesRequiringAuth, into: &buf)
        FfiConverterTypeNewEntities.write(value.newEntities, into: &buf)
        FfiConverterSequenceTypeDetailedManifestClass.write(value.detailedClassification, into: &buf)
        FfiConverterSequenceTypeNonFungibleGlobalId.write(value.newlyCreatedNonFungibles, into: &buf)
        FfiConverterSequenceTypeReservedInstruction.write(value.reservedInstructions, into: &buf)
        FfiConverterSequenceTypeResourceSpecifier.write(value.presentedProofs, into: &buf)
        FfiConverterSequenceTypeComponentAddress.write(value.encounteredComponentAddresses, into: &buf)
        FfiConverterTypeFeeLocks.write(value.feeLocks, into: &buf)
        FfiConverterTypeFeeSummary.write(value.feeSummary, into: &buf)
    }
}

public func FfiConverterTypeExecutionSummary_lift(_ buf: RustBuffer) throws -> ExecutionSummary {
    return try FfiConverterTypeExecutionSummary.lift(buf)
}

public func FfiConverterTypeExecutionSummary_lower(_ value: ExecutionSummary) -> RustBuffer {
    return FfiConverterTypeExecutionSummary.lower(value)
}

public struct FactorInstance {
    /**
     * The ID of the `FactorSource` that was used to produce this
     * factor instance. We will lookup the `FactorSource` in the
     * `Profile` and can present user with instruction to re-access
     * this factor source in order control the `badge`.
     */
    public var factorSourceId: FactorSourceId
    /**
     * Either a "physical" badge (NFT) or some source for recreation of a producer
     * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
     * is derived which produces virtual badges (signatures).
     */
    public var badge: FactorInstanceBadge

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the `FactorSource` that was used to produce this
         * factor instance. We will lookup the `FactorSource` in the
         * `Profile` and can present user with instruction to re-access
         * this factor source in order control the `badge`.
         */ factorSourceId: FactorSourceId,
        /**
            * Either a "physical" badge (NFT) or some source for recreation of a producer
            * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
            * is derived which produces virtual badges (signatures).
            */ badge: FactorInstanceBadge
    ) {
        self.factorSourceId = factorSourceId
        self.badge = badge
    }
}

extension FactorInstance: Sendable {}
extension FactorInstance: Equatable, Hashable {
    public static func == (lhs: FactorInstance, rhs: FactorInstance) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.badge != rhs.badge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(badge)
    }
}

public struct FfiConverterTypeFactorInstance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstance {
        return
            try FactorInstance(
                factorSourceId: FfiConverterTypeFactorSourceID.read(from: &buf),
                badge: FfiConverterTypeFactorInstanceBadge.read(from: &buf)
            )
    }

    public static func write(_ value: FactorInstance, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceID.write(value.factorSourceId, into: &buf)
        FfiConverterTypeFactorInstanceBadge.write(value.badge, into: &buf)
    }
}

public func FfiConverterTypeFactorInstance_lift(_ buf: RustBuffer) throws -> FactorInstance {
    return try FfiConverterTypeFactorInstance.lift(buf)
}

public func FfiConverterTypeFactorInstance_lower(_ value: FactorInstance) -> RustBuffer {
    return FfiConverterTypeFactorInstance.lower(value)
}

/**
 * Common properties shared between FactorSources of different kinds, describing
 * its state, when added, and supported cryptographic parameters.
 */
public struct FactorSourceCommon {
    /**
     * Cryptographic parameters a certain FactorSource supports, e.g. Elliptic Curves.
     *
     * Since Radix Wallet App version 1.3.0, it is possible to add crypto
     * parameters to a FactorSource, e.g. when a user with a DeviceFactorSource
     * with babylon crypto parameters, lets call it `B`, with mnemonic `M` adds
     * `M` again but as an "Olympia" factor source, then the olympia crypto
     * parameters are added to `B`.
     */
    public var cryptoParameters: FactorSourceCryptoParameters
    /**
     * When this factor source for originally added by the user.
     */
    public var addedOn: Timestamp
    /**
     * Date of last usage of this factor source
     *
     * This is the only mutable property, it is mutable
     * since we will update it every time this FactorSource
     * is used.
     */
    public var lastUsedOn: Timestamp
    /**
     * Flags which describe a certain state a FactorSource might be in, e.g. `Main` (BDFS).
     */
    public var flags: [FactorSourceFlag]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Cryptographic parameters a certain FactorSource supports, e.g. Elliptic Curves.
         *
         * Since Radix Wallet App version 1.3.0, it is possible to add crypto
         * parameters to a FactorSource, e.g. when a user with a DeviceFactorSource
         * with babylon crypto parameters, lets call it `B`, with mnemonic `M` adds
         * `M` again but as an "Olympia" factor source, then the olympia crypto
         * parameters are added to `B`.
         */ cryptoParameters: FactorSourceCryptoParameters,
        /**
            * When this factor source for originally added by the user.
            */ addedOn: Timestamp,
        /**
            * Date of last usage of this factor source
            *
            * This is the only mutable property, it is mutable
            * since we will update it every time this FactorSource
            * is used.
            */ lastUsedOn: Timestamp,
        /**
            * Flags which describe a certain state a FactorSource might be in, e.g. `Main` (BDFS).
            */ flags: [FactorSourceFlag]
    ) {
        self.cryptoParameters = cryptoParameters
        self.addedOn = addedOn
        self.lastUsedOn = lastUsedOn
        self.flags = flags
    }
}

extension FactorSourceCommon: Sendable {}
extension FactorSourceCommon: Equatable, Hashable {
    public static func == (lhs: FactorSourceCommon, rhs: FactorSourceCommon) -> Bool {
        if lhs.cryptoParameters != rhs.cryptoParameters {
            return false
        }
        if lhs.addedOn != rhs.addedOn {
            return false
        }
        if lhs.lastUsedOn != rhs.lastUsedOn {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cryptoParameters)
        hasher.combine(addedOn)
        hasher.combine(lastUsedOn)
        hasher.combine(flags)
    }
}

public struct FfiConverterTypeFactorSourceCommon: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceCommon {
        return
            try FactorSourceCommon(
                cryptoParameters: FfiConverterTypeFactorSourceCryptoParameters.read(from: &buf),
                addedOn: FfiConverterTypeTimestamp.read(from: &buf),
                lastUsedOn: FfiConverterTypeTimestamp.read(from: &buf),
                flags: FfiConverterSequenceTypeFactorSourceFlag.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceCommon, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceCryptoParameters.write(value.cryptoParameters, into: &buf)
        FfiConverterTypeTimestamp.write(value.addedOn, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastUsedOn, into: &buf)
        FfiConverterSequenceTypeFactorSourceFlag.write(value.flags, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceCommon_lift(_ buf: RustBuffer) throws -> FactorSourceCommon {
    return try FfiConverterTypeFactorSourceCommon.lift(buf)
}

public func FfiConverterTypeFactorSourceCommon_lower(_ value: FactorSourceCommon) -> RustBuffer {
    return FfiConverterTypeFactorSourceCommon.lower(value)
}

/**
 * Cryptographic parameters a certain FactorSource supports, e.g. which Elliptic Curves
 * it supports and which Hierarchical Deterministic (HD) derivations schemes it supports,
 * if any.
 */
public struct FactorSourceCryptoParameters {
    /**
     * Describes with which Elliptic Curves a Factor Source can be used, e.g. a
     * "Babylon" `DeviceFactorSource` is not capable of deriving keys on the curve
     * `secp256k1` - only Olympia imported FactorSources can do that.
     *
     * Either `[curve25519]` or `[secp256k1, curve25519]`
     *
     * Must not be empty.
     */
    public var supportedCurves: [Slip10Curve]
    /**
     * If not empty: Describes which kind of Hierarchical Deterministic (HD)
     * derivations a FactorSource is capable of doing - if empty: the
     * FactorSource does not support HD derivation.
     *
     * Either BIP44 or CAP26 (SLIP10)
     */
    public var supportedDerivationPathSchemes: [DerivationPathScheme]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Describes with which Elliptic Curves a Factor Source can be used, e.g. a
         * "Babylon" `DeviceFactorSource` is not capable of deriving keys on the curve
         * `secp256k1` - only Olympia imported FactorSources can do that.
         *
         * Either `[curve25519]` or `[secp256k1, curve25519]`
         *
         * Must not be empty.
         */ supportedCurves: [Slip10Curve],
        /**
            * If not empty: Describes which kind of Hierarchical Deterministic (HD)
            * derivations a FactorSource is capable of doing - if empty: the
            * FactorSource does not support HD derivation.
            *
            * Either BIP44 or CAP26 (SLIP10)
            */ supportedDerivationPathSchemes: [DerivationPathScheme]
    ) {
        self.supportedCurves = supportedCurves
        self.supportedDerivationPathSchemes = supportedDerivationPathSchemes
    }
}

extension FactorSourceCryptoParameters: Sendable {}
extension FactorSourceCryptoParameters: Equatable, Hashable {
    public static func == (lhs: FactorSourceCryptoParameters, rhs: FactorSourceCryptoParameters) -> Bool {
        if lhs.supportedCurves != rhs.supportedCurves {
            return false
        }
        if lhs.supportedDerivationPathSchemes != rhs.supportedDerivationPathSchemes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(supportedCurves)
        hasher.combine(supportedDerivationPathSchemes)
    }
}

public struct FfiConverterTypeFactorSourceCryptoParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceCryptoParameters {
        return
            try FactorSourceCryptoParameters(
                supportedCurves: FfiConverterSequenceTypeSLIP10Curve.read(from: &buf),
                supportedDerivationPathSchemes: FfiConverterSequenceTypeDerivationPathScheme.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceCryptoParameters, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeSLIP10Curve.write(value.supportedCurves, into: &buf)
        FfiConverterSequenceTypeDerivationPathScheme.write(value.supportedDerivationPathSchemes, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceCryptoParameters_lift(_ buf: RustBuffer) throws -> FactorSourceCryptoParameters {
    return try FfiConverterTypeFactorSourceCryptoParameters.lift(buf)
}

public func FfiConverterTypeFactorSourceCryptoParameters_lower(_ value: FactorSourceCryptoParameters) -> RustBuffer {
    return FfiConverterTypeFactorSourceCryptoParameters.lower(value)
}

/**
 * FactorSourceID from an AccountAddress, typically used by `trustedContact` FactorSource.
 */
public struct FactorSourceIdFromAddress {
    /**
     * The kind of the FactorSource this ID refers to, typically `trustedContact`.
     */
    public var kind: FactorSourceKind
    /**
     * An account address which the FactorSource this ID refers uses/needs.
     */
    public var body: AccountAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The kind of the FactorSource this ID refers to, typically `trustedContact`.
         */ kind: FactorSourceKind,
        /**
            * An account address which the FactorSource this ID refers uses/needs.
            */ body: AccountAddress
    ) {
        self.kind = kind
        self.body = body
    }
}

extension FactorSourceIdFromAddress: Sendable {}
extension FactorSourceIdFromAddress: Equatable, Hashable {
    public static func == (lhs: FactorSourceIdFromAddress, rhs: FactorSourceIdFromAddress) -> Bool {
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kind)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeFactorSourceIDFromAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIdFromAddress {
        return
            try FactorSourceIdFromAddress(
                kind: FfiConverterTypeFactorSourceKind.read(from: &buf),
                body: FfiConverterTypeAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceIdFromAddress, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.kind, into: &buf)
        FfiConverterTypeAccountAddress.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceIDFromAddress_lift(_ buf: RustBuffer) throws -> FactorSourceIdFromAddress {
    return try FfiConverterTypeFactorSourceIDFromAddress.lift(buf)
}

public func FfiConverterTypeFactorSourceIDFromAddress_lower(_ value: FactorSourceIdFromAddress) -> RustBuffer {
    return FfiConverterTypeFactorSourceIDFromAddress.lower(value)
}

/**
 * FactorSourceID from the blake2b hash of the special HD public key derived at `CAP26::GetID`,
 * for a certain `FactorSourceKind`
 */
public struct FactorSourceIdFromHash {
    /**
     * The kind of the FactorSource this ID refers to, typically `device` or `ledger`.
     */
    public var kind: FactorSourceKind
    /**
     * The blake2b hash of the special HD public key derived at `CAP26::GetID`.
     */
    public var body: Exactly32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The kind of the FactorSource this ID refers to, typically `device` or `ledger`.
         */ kind: FactorSourceKind,
        /**
            * The blake2b hash of the special HD public key derived at `CAP26::GetID`.
            */ body: Exactly32Bytes
    ) {
        self.kind = kind
        self.body = body
    }
}

extension FactorSourceIdFromHash: Sendable {}
extension FactorSourceIdFromHash: Equatable, Hashable {
    public static func == (lhs: FactorSourceIdFromHash, rhs: FactorSourceIdFromHash) -> Bool {
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kind)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeFactorSourceIDFromHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIdFromHash {
        return
            try FactorSourceIdFromHash(
                kind: FfiConverterTypeFactorSourceKind.read(from: &buf),
                body: FfiConverterTypeExactly32Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceIdFromHash, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.kind, into: &buf)
        FfiConverterTypeExactly32Bytes.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceIDFromHash_lift(_ buf: RustBuffer) throws -> FactorSourceIdFromHash {
    return try FfiConverterTypeFactorSourceIDFromHash.lift(buf)
}

public func FfiConverterTypeFactorSourceIDFromHash_lower(_ value: FactorSourceIdFromHash) -> RustBuffer {
    return FfiConverterTypeFactorSourceIDFromHash.lower(value)
}

/**
 * Information on how much fees were contingent and how much were not.
 */
public struct FeeLocks {
    public var lock: Decimal192
    public var contingentLock: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lock: Decimal192, contingentLock: Decimal192) {
        self.lock = lock
        self.contingentLock = contingentLock
    }
}

extension FeeLocks: Sendable {}
extension FeeLocks: Equatable, Hashable {
    public static func == (lhs: FeeLocks, rhs: FeeLocks) -> Bool {
        if lhs.lock != rhs.lock {
            return false
        }
        if lhs.contingentLock != rhs.contingentLock {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lock)
        hasher.combine(contingentLock)
    }
}

public struct FfiConverterTypeFeeLocks: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeLocks {
        return
            try FeeLocks(
                lock: FfiConverterTypeDecimal192.read(from: &buf),
                contingentLock: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: FeeLocks, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.lock, into: &buf)
        FfiConverterTypeDecimal192.write(value.contingentLock, into: &buf)
    }
}

public func FfiConverterTypeFeeLocks_lift(_ buf: RustBuffer) throws -> FeeLocks {
    return try FfiConverterTypeFeeLocks.lift(buf)
}

public func FfiConverterTypeFeeLocks_lower(_ value: FeeLocks) -> RustBuffer {
    return FfiConverterTypeFeeLocks.lower(value)
}

/**
 * Detailed information on the amount of cost units consumed.
 */
public struct FeeSummary {
    public var executionCost: Decimal192
    public var finalizationCost: Decimal192
    public var royaltyCost: Decimal192
    public var storageExpansionCost: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(executionCost: Decimal192, finalizationCost: Decimal192, royaltyCost: Decimal192, storageExpansionCost: Decimal192) {
        self.executionCost = executionCost
        self.finalizationCost = finalizationCost
        self.royaltyCost = royaltyCost
        self.storageExpansionCost = storageExpansionCost
    }
}

extension FeeSummary: Sendable {}
extension FeeSummary: Equatable, Hashable {
    public static func == (lhs: FeeSummary, rhs: FeeSummary) -> Bool {
        if lhs.executionCost != rhs.executionCost {
            return false
        }
        if lhs.finalizationCost != rhs.finalizationCost {
            return false
        }
        if lhs.royaltyCost != rhs.royaltyCost {
            return false
        }
        if lhs.storageExpansionCost != rhs.storageExpansionCost {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(executionCost)
        hasher.combine(finalizationCost)
        hasher.combine(royaltyCost)
        hasher.combine(storageExpansionCost)
    }
}

public struct FfiConverterTypeFeeSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSummary {
        return
            try FeeSummary(
                executionCost: FfiConverterTypeDecimal192.read(from: &buf),
                finalizationCost: FfiConverterTypeDecimal192.read(from: &buf),
                royaltyCost: FfiConverterTypeDecimal192.read(from: &buf),
                storageExpansionCost: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: FeeSummary, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.executionCost, into: &buf)
        FfiConverterTypeDecimal192.write(value.finalizationCost, into: &buf)
        FfiConverterTypeDecimal192.write(value.royaltyCost, into: &buf)
        FfiConverterTypeDecimal192.write(value.storageExpansionCost, into: &buf)
    }
}

public func FfiConverterTypeFeeSummary_lift(_ buf: RustBuffer) throws -> FeeSummary {
    return try FfiConverterTypeFeeSummary.lift(buf)
}

public func FfiConverterTypeFeeSummary_lower(_ value: FeeSummary) -> RustBuffer {
    return FfiConverterTypeFeeSummary.lower(value)
}

public struct FungibleResourcesCollection {
    public var items: [FungibleResourcesCollectionItem]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [FungibleResourcesCollectionItem]) {
        self.items = items
    }
}

extension FungibleResourcesCollection: Sendable {}
extension FungibleResourcesCollection: Equatable, Hashable {
    public static func == (lhs: FungibleResourcesCollection, rhs: FungibleResourcesCollection) -> Bool {
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(items)
    }
}

public struct FfiConverterTypeFungibleResourcesCollection: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourcesCollection {
        return
            try FungibleResourcesCollection(
                items: FfiConverterSequenceTypeFungibleResourcesCollectionItem.read(from: &buf)
            )
    }

    public static func write(_ value: FungibleResourcesCollection, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFungibleResourcesCollectionItem.write(value.items, into: &buf)
    }
}

public func FfiConverterTypeFungibleResourcesCollection_lift(_ buf: RustBuffer) throws -> FungibleResourcesCollection {
    return try FfiConverterTypeFungibleResourcesCollection.lift(buf)
}

public func FfiConverterTypeFungibleResourcesCollection_lower(_ value: FungibleResourcesCollection) -> RustBuffer {
    return FfiConverterTypeFungibleResourcesCollection.lower(value)
}

public struct FungibleResourcesCollectionItemGloballyAggregated {
    public var amount: Decimal192
    public var resourceAddress: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: Decimal192, resourceAddress: ResourceAddress) {
        self.amount = amount
        self.resourceAddress = resourceAddress
    }
}

extension FungibleResourcesCollectionItemGloballyAggregated: Sendable {}
extension FungibleResourcesCollectionItemGloballyAggregated: Equatable, Hashable {
    public static func == (lhs: FungibleResourcesCollectionItemGloballyAggregated, rhs: FungibleResourcesCollectionItemGloballyAggregated) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(resourceAddress)
    }
}

public struct FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourcesCollectionItemGloballyAggregated {
        return
            try FungibleResourcesCollectionItemGloballyAggregated(
                amount: FfiConverterTypeDecimal192.read(from: &buf),
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: FungibleResourcesCollectionItemGloballyAggregated, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
    }
}

public func FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated_lift(_ buf: RustBuffer) throws -> FungibleResourcesCollectionItemGloballyAggregated {
    return try FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated.lift(buf)
}

public func FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated_lower(_ value: FungibleResourcesCollectionItemGloballyAggregated) -> RustBuffer {
    return FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated.lower(value)
}

/**
 * A gateway to some Radix Network, which is a high level REST API which clients (wallets) can
 * consume in order to query asset balances and submit transactions.
 */
public struct Gateway {
    /**
     * The Radix network the API is a Gateway to.
     */
    public var network: NetworkDefinition
    /**
     * The URL to the gateways API endpoint
     */
    public var url: Url

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The Radix network the API is a Gateway to.
         */ network: NetworkDefinition,
        /**
            * The URL to the gateways API endpoint
            */ url: Url
    ) {
        self.network = network
        self.url = url
    }
}

extension Gateway: Sendable {}
extension Gateway: Equatable, Hashable {
    public static func == (lhs: Gateway, rhs: Gateway) -> Bool {
        if lhs.network != rhs.network {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(network)
        hasher.combine(url)
    }
}

public struct FfiConverterTypeGateway: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Gateway {
        return
            try Gateway(
                network: FfiConverterTypeNetworkDefinition.read(from: &buf),
                url: FfiConverterTypeUrl.read(from: &buf)
            )
    }

    public static func write(_ value: Gateway, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkDefinition.write(value.network, into: &buf)
        FfiConverterTypeUrl.write(value.url, into: &buf)
    }
}

public func FfiConverterTypeGateway_lift(_ buf: RustBuffer) throws -> Gateway {
    return try FfiConverterTypeGateway.lift(buf)
}

public func FfiConverterTypeGateway_lower(_ value: Gateway) -> RustBuffer {
    return FfiConverterTypeGateway.lower(value)
}

/**
 * Use it with `GetIDPath::default()` to create the path `m/44'/1022'/365'`
 * which is used by all hierarchal deterministic factor sources to derive
 * the special root key which we hash to form the `FactorSourceIDFromHash`
 */
public struct GetIdPath {
    public var path: HdPath

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: HdPath) {
        self.path = path
    }
}

extension GetIdPath: Sendable {}
extension GetIdPath: Equatable, Hashable {
    public static func == (lhs: GetIdPath, rhs: GetIdPath) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
    }
}

public struct FfiConverterTypeGetIDPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetIdPath {
        return
            try GetIdPath(
                path: FfiConverterTypeHDPath.read(from: &buf)
            )
    }

    public static func write(_ value: GetIdPath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPath.write(value.path, into: &buf)
    }
}

public func FfiConverterTypeGetIDPath_lift(_ buf: RustBuffer) throws -> GetIdPath {
    return try FfiConverterTypeGetIDPath.lift(buf)
}

public func FfiConverterTypeGetIDPath_lower(_ value: GetIdPath) -> RustBuffer {
    return FfiConverterTypeGetIDPath.lower(value)
}

public struct HdPath {
    public var components: [HdPathComponent]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(components: [HdPathComponent]) {
        self.components = components
    }
}

extension HdPath: Sendable {}
extension HdPath: Equatable, Hashable {
    public static func == (lhs: HdPath, rhs: HdPath) -> Bool {
        if lhs.components != rhs.components {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(components)
    }
}

public struct FfiConverterTypeHDPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdPath {
        return
            try HdPath(
                components: FfiConverterSequenceTypeHDPathComponent.read(from: &buf)
            )
    }

    public static func write(_ value: HdPath, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeHDPathComponent.write(value.components, into: &buf)
    }
}

public func FfiConverterTypeHDPath_lift(_ buf: RustBuffer) throws -> HdPath {
    return try FfiConverterTypeHDPath.lift(buf)
}

public func FfiConverterTypeHDPath_lower(_ value: HdPath) -> RustBuffer {
    return FfiConverterTypeHDPath.lower(value)
}

public struct HdPathComponent {
    public var value: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt32) {
        self.value = value
    }
}

extension HdPathComponent: Sendable {}
extension HdPathComponent: Equatable, Hashable {
    public static func == (lhs: HdPathComponent, rhs: HdPathComponent) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeHDPathComponent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdPathComponent {
        return
            try HdPathComponent(
                value: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: HdPathComponent, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeHDPathComponent_lift(_ buf: RustBuffer) throws -> HdPathComponent {
    return try FfiConverterTypeHDPathComponent.lift(buf)
}

public func FfiConverterTypeHDPathComponent_lower(_ value: HdPathComponent) -> RustBuffer {
    return FfiConverterTypeHDPathComponent.lower(value)
}

/**
 * Represents a 32-byte hash digest.
 *
 * Made UniFFI convertible via HashSecretMagic,
 * exposed in Swift/Kotlin as its own struct/data class, with
 * hidden secret magic.
 */
public struct Hash {
    fileprivate let secretMagic: HashSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: HashSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Hash: Sendable {}
extension Hash: Equatable, Hashable {
    public static func == (lhs: Hash, rhs: Hash) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hash {
        return
            try Hash(
                secretMagic: FfiConverterTypeHashSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Hash, into buf: inout [UInt8]) {
        FfiConverterTypeHashSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeHash_lift(_ buf: RustBuffer) throws -> Hash {
    return try FfiConverterTypeHash.lift(buf)
}

public func FfiConverterTypeHash_lower(_ value: Hash) -> RustBuffer {
    return FfiConverterTypeHash.lower(value)
}

/**
 * The header of a Profile(Snapshot) contains crucial metadata
 * about this Profile, such as which JSON data format it is
 * compatible with and which device was used to create it and
 * a hint about its contents.
 */
public struct Header {
    /**
     * A versioning number that is increased when breaking
     * changes is made to ProfileSnapshot JSON data format.
     */
    public var snapshotVersion: ProfileSnapshotVersion
    /**
     * An immutable and unique identifier of a Profile.
     */
    public var id: ProfileId
    /**
     * The device which was used to create the Profile.
     */
    public var creatingDevice: DeviceInfo
    /**
     * The device on which the profile was last used.
     */
    public var lastUsedOnDevice: DeviceInfo
    /**
     * When the Profile was last modified.
     */
    public var lastModified: Timestamp
    /**
     * Hint about the contents of the profile, e.g. number of Accounts and Personas.
     */
    public var contentHint: ContentHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A versioning number that is increased when breaking
         * changes is made to ProfileSnapshot JSON data format.
         */ snapshotVersion: ProfileSnapshotVersion,
        /**
            * An immutable and unique identifier of a Profile.
            */ id: ProfileId,
        /**
            * The device which was used to create the Profile.
            */ creatingDevice: DeviceInfo,
        /**
            * The device on which the profile was last used.
            */ lastUsedOnDevice: DeviceInfo,
        /**
            * When the Profile was last modified.
            */ lastModified: Timestamp,
        /**
            * Hint about the contents of the profile, e.g. number of Accounts and Personas.
            */ contentHint: ContentHint
    ) {
        self.snapshotVersion = snapshotVersion
        self.id = id
        self.creatingDevice = creatingDevice
        self.lastUsedOnDevice = lastUsedOnDevice
        self.lastModified = lastModified
        self.contentHint = contentHint
    }
}

extension Header: Sendable {}
extension Header: Equatable, Hashable {
    public static func == (lhs: Header, rhs: Header) -> Bool {
        if lhs.snapshotVersion != rhs.snapshotVersion {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.creatingDevice != rhs.creatingDevice {
            return false
        }
        if lhs.lastUsedOnDevice != rhs.lastUsedOnDevice {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.contentHint != rhs.contentHint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(snapshotVersion)
        hasher.combine(id)
        hasher.combine(creatingDevice)
        hasher.combine(lastUsedOnDevice)
        hasher.combine(lastModified)
        hasher.combine(contentHint)
    }
}

public struct FfiConverterTypeHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Header {
        return
            try Header(
                snapshotVersion: FfiConverterTypeProfileSnapshotVersion.read(from: &buf),
                id: FfiConverterTypeProfileID.read(from: &buf),
                creatingDevice: FfiConverterTypeDeviceInfo.read(from: &buf),
                lastUsedOnDevice: FfiConverterTypeDeviceInfo.read(from: &buf),
                lastModified: FfiConverterTypeTimestamp.read(from: &buf),
                contentHint: FfiConverterTypeContentHint.read(from: &buf)
            )
    }

    public static func write(_ value: Header, into buf: inout [UInt8]) {
        FfiConverterTypeProfileSnapshotVersion.write(value.snapshotVersion, into: &buf)
        FfiConverterTypeProfileID.write(value.id, into: &buf)
        FfiConverterTypeDeviceInfo.write(value.creatingDevice, into: &buf)
        FfiConverterTypeDeviceInfo.write(value.lastUsedOnDevice, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastModified, into: &buf)
        FfiConverterTypeContentHint.write(value.contentHint, into: &buf)
    }
}

public func FfiConverterTypeHeader_lift(_ buf: RustBuffer) throws -> Header {
    return try FfiConverterTypeHeader.lift(buf)
}

public func FfiConverterTypeHeader_lower(_ value: Header) -> RustBuffer {
    return FfiConverterTypeHeader.lower(value)
}

/**
 * A virtual hierarchical deterministic `FactorInstance`
 */
public struct HierarchicalDeterministicFactorInstance {
    public var factorSourceId: FactorSourceIdFromHash
    public var publicKey: HierarchicalDeterministicPublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceId: FactorSourceIdFromHash, publicKey: HierarchicalDeterministicPublicKey) {
        self.factorSourceId = factorSourceId
        self.publicKey = publicKey
    }
}

extension HierarchicalDeterministicFactorInstance: Sendable {}
extension HierarchicalDeterministicFactorInstance: Equatable, Hashable {
    public static func == (lhs: HierarchicalDeterministicFactorInstance, rhs: HierarchicalDeterministicFactorInstance) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(publicKey)
    }
}

public struct FfiConverterTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HierarchicalDeterministicFactorInstance {
        return
            try HierarchicalDeterministicFactorInstance(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                publicKey: FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: HierarchicalDeterministicFactorInstance, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterTypeHierarchicalDeterministicPublicKey.write(value.publicKey, into: &buf)
    }
}

public func FfiConverterTypeHierarchicalDeterministicFactorInstance_lift(_ buf: RustBuffer) throws -> HierarchicalDeterministicFactorInstance {
    return try FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(buf)
}

public func FfiConverterTypeHierarchicalDeterministicFactorInstance_lower(_ value: HierarchicalDeterministicFactorInstance) -> RustBuffer {
    return FfiConverterTypeHierarchicalDeterministicFactorInstance.lower(value)
}

/**
 * The **source** of a virtual hierarchical deterministic badge, contains a
 * derivation path and public key, from which a private key is derived which
 * produces virtual badges (signatures).
 *
 * The `.device` `FactorSource` produces `FactorInstance`s with this kind if badge source.
 */
public struct HierarchicalDeterministicPublicKey {
    /**
     * The expected public key of the private key derived at `derivationPath`
     */
    public var publicKey: PublicKey
    /**
     * The HD derivation path for the key pair which produces virtual badges (signatures).
     */
    public var derivationPath: DerivationPath

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The expected public key of the private key derived at `derivationPath`
         */ publicKey: PublicKey,
        /**
            * The HD derivation path for the key pair which produces virtual badges (signatures).
            */ derivationPath: DerivationPath
    ) {
        self.publicKey = publicKey
        self.derivationPath = derivationPath
    }
}

extension HierarchicalDeterministicPublicKey: Sendable {}
extension HierarchicalDeterministicPublicKey: Equatable, Hashable {
    public static func == (lhs: HierarchicalDeterministicPublicKey, rhs: HierarchicalDeterministicPublicKey) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.derivationPath != rhs.derivationPath {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(derivationPath)
    }
}

public struct FfiConverterTypeHierarchicalDeterministicPublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HierarchicalDeterministicPublicKey {
        return
            try HierarchicalDeterministicPublicKey(
                publicKey: FfiConverterTypePublicKey.read(from: &buf),
                derivationPath: FfiConverterTypeDerivationPath.read(from: &buf)
            )
    }

    public static func write(_ value: HierarchicalDeterministicPublicKey, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterTypeDerivationPath.write(value.derivationPath, into: &buf)
    }
}

public func FfiConverterTypeHierarchicalDeterministicPublicKey_lift(_ buf: RustBuffer) throws -> HierarchicalDeterministicPublicKey {
    return try FfiConverterTypeHierarchicalDeterministicPublicKey.lift(buf)
}

public func FfiConverterTypeHierarchicalDeterministicPublicKey_lower(_ value: HierarchicalDeterministicPublicKey) -> RustBuffer {
    return FfiConverterTypeHierarchicalDeterministicPublicKey.lower(value)
}

public struct HostId {
    /**
     * A best effort stable and unique identifier of this
     * host's device.
     */
    public var id: DeviceId
    /**
     * The date this id of the device was generated, might
     * be equal to when the app was first ever launched on the
     * device.
     */
    public var generatedAt: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A best effort stable and unique identifier of this
         * host's device.
         */ id: DeviceId,
        /**
            * The date this id of the device was generated, might
            * be equal to when the app was first ever launched on the
            * device.
            */ generatedAt: Timestamp
    ) {
        self.id = id
        self.generatedAt = generatedAt
    }
}

extension HostId: Sendable {}
extension HostId: Equatable, Hashable {
    public static func == (lhs: HostId, rhs: HostId) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.generatedAt != rhs.generatedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(generatedAt)
    }
}

public struct FfiConverterTypeHostId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostId {
        return
            try HostId(
                id: FfiConverterTypeDeviceID.read(from: &buf),
                generatedAt: FfiConverterTypeTimestamp.read(from: &buf)
            )
    }

    public static func write(_ value: HostId, into buf: inout [UInt8]) {
        FfiConverterTypeDeviceID.write(value.id, into: &buf)
        FfiConverterTypeTimestamp.write(value.generatedAt, into: &buf)
    }
}

public func FfiConverterTypeHostId_lift(_ buf: RustBuffer) throws -> HostId {
    return try FfiConverterTypeHostId.lift(buf)
}

public func FfiConverterTypeHostId_lower(_ value: HostId) -> RustBuffer {
    return FfiConverterTypeHostId.lower(value)
}

public struct HostInfo {
    /**
     * A short description of the device. The host should
     * read the device model and a given name from the device
     * if they are able to.
     */
    public var description: DeviceInfoDescription
    /**
     * The **current** os and version of the device's operating system, e.g. "iOS 17.4.1".
     */
    public var hostOs: HostOs
    /**
     * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
     */
    public var hostAppVersion: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A short description of the device. The host should
         * read the device model and a given name from the device
         * if they are able to.
         */ description: DeviceInfoDescription,
        /**
            * The **current** os and version of the device's operating system, e.g. "iOS 17.4.1".
            */ hostOs: HostOs,
        /**
            * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
            */ hostAppVersion: String
    ) {
        self.description = description
        self.hostOs = hostOs
        self.hostAppVersion = hostAppVersion
    }
}

extension HostInfo: Sendable {}
extension HostInfo: Equatable, Hashable {
    public static func == (lhs: HostInfo, rhs: HostInfo) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.hostOs != rhs.hostOs {
            return false
        }
        if lhs.hostAppVersion != rhs.hostAppVersion {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(hostOs)
        hasher.combine(hostAppVersion)
    }
}

public struct FfiConverterTypeHostInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostInfo {
        return
            try HostInfo(
                description: FfiConverterTypeDeviceInfoDescription.read(from: &buf),
                hostOs: FfiConverterTypeHostOS.read(from: &buf),
                hostAppVersion: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: HostInfo, into buf: inout [UInt8]) {
        FfiConverterTypeDeviceInfoDescription.write(value.description, into: &buf)
        FfiConverterTypeHostOS.write(value.hostOs, into: &buf)
        FfiConverterString.write(value.hostAppVersion, into: &buf)
    }
}

public func FfiConverterTypeHostInfo_lift(_ buf: RustBuffer) throws -> HostInfo {
    return try FfiConverterTypeHostInfo.lift(buf)
}

public func FfiConverterTypeHostInfo_lower(_ value: HostInfo) -> RustBuffer {
    return FfiConverterTypeHostInfo.lower(value)
}

/**
 * Human readable address of an identity, which are used by Personas. Always starts with
 * the prefix `"identity_"`, for example:
 *
 * `identity_rdx12tgzjrz9u0xz4l28vf04hz87eguclmfaq4d2p8f8lv7zg9ssnzku8j`
 *
 * Addresses are checksummed, as per Bech32. **Only** *Identity* addresses starts with
 * the prefix `"identity_"`.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of IdentityAddresses:
 * * GlobalIdentity,
 * * GlobalVirtualSecp256k1Identity,
 * * GlobalVirtualEd25519Identity
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert_eq!(
 * "identity_rdx12tgzjrz9u0xz4l28vf04hz87eguclmfaq4d2p8f8lv7zg9ssnzku8j".parse::<IdentityAddress>().unwrap().network_id(),
 * NetworkID::Mainnet
 * );
 * ```
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalIdentityAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L229-L234
 */
public struct IdentityAddress {
    fileprivate let secretMagic: RetIdentityAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetIdentityAddress) {
        self.secretMagic = secretMagic
    }
}

extension IdentityAddress: Sendable {}
extension IdentityAddress: Equatable, Hashable {
    public static func == (lhs: IdentityAddress, rhs: IdentityAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeIdentityAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityAddress {
        return
            try IdentityAddress(
                secretMagic: FfiConverterTypeRetIdentityAddress.read(from: &buf)
            )
    }

    public static func write(_ value: IdentityAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetIdentityAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeIdentityAddress_lift(_ buf: RustBuffer) throws -> IdentityAddress {
    return try FfiConverterTypeIdentityAddress.lift(buf)
}

public func FfiConverterTypeIdentityAddress_lower(_ value: IdentityAddress) -> RustBuffer {
    return FfiConverterTypeIdentityAddress.lower(value)
}

public struct IdentityPath {
    public var path: HdPath
    public var networkId: NetworkId
    public var entityKind: Cap26EntityKind
    public var keyKind: Cap26KeyKind
    public var index: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: HdPath, networkId: NetworkId, entityKind: Cap26EntityKind, keyKind: Cap26KeyKind, index: UInt32) {
        self.path = path
        self.networkId = networkId
        self.entityKind = entityKind
        self.keyKind = keyKind
        self.index = index
    }
}

extension IdentityPath: Sendable {}
extension IdentityPath: Equatable, Hashable {
    public static func == (lhs: IdentityPath, rhs: IdentityPath) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.entityKind != rhs.entityKind {
            return false
        }
        if lhs.keyKind != rhs.keyKind {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(networkId)
        hasher.combine(entityKind)
        hasher.combine(keyKind)
        hasher.combine(index)
    }
}

public struct FfiConverterTypeIdentityPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityPath {
        return
            try IdentityPath(
                path: FfiConverterTypeHDPath.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                entityKind: FfiConverterTypeCAP26EntityKind.read(from: &buf),
                keyKind: FfiConverterTypeCAP26KeyKind.read(from: &buf),
                index: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: IdentityPath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPath.write(value.path, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeCAP26EntityKind.write(value.entityKind, into: &buf)
        FfiConverterTypeCAP26KeyKind.write(value.keyKind, into: &buf)
        FfiConverterUInt32.write(value.index, into: &buf)
    }
}

public func FfiConverterTypeIdentityPath_lift(_ buf: RustBuffer) throws -> IdentityPath {
    return try FfiConverterTypeIdentityPath.lift(buf)
}

public func FfiConverterTypeIdentityPath_lower(_ value: IdentityPath) -> RustBuffer {
    return FfiConverterTypeIdentityPath.lower(value)
}

public struct Instructions {
    fileprivate let secretMagic: InstructionsSecretMagic
    public var networkId: NetworkId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: InstructionsSecretMagic, networkId: NetworkId) {
        self.secretMagic = secretMagic
        self.networkId = networkId
    }
}

extension Instructions: Sendable {}
extension Instructions: Equatable, Hashable {
    public static func == (lhs: Instructions, rhs: Instructions) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
        hasher.combine(networkId)
    }
}

public struct FfiConverterTypeInstructions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Instructions {
        return
            try Instructions(
                secretMagic: FfiConverterTypeInstructionsSecretMagic.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
            )
    }

    public static func write(_ value: Instructions, into buf: inout [UInt8]) {
        FfiConverterTypeInstructionsSecretMagic.write(value.secretMagic, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
    }
}

public func FfiConverterTypeInstructions_lift(_ buf: RustBuffer) throws -> Instructions {
    return try FfiConverterTypeInstructions.lift(buf)
}

public func FfiConverterTypeInstructions_lower(_ value: Instructions) -> RustBuffer {
    return FfiConverterTypeInstructions.lower(value)
}

/**
 * `IntentHash` used to identify transactions.
 * Representation is bech32 encoded string starting with `txid_` e.g.:
 * `"txid_rdx19rpveua6xuhvz0axu0mwpqk8fywr83atv8mkrugchvw6uuslgppqh9cnj4"`
 */
public struct IntentHash {
    /**
     * Which network this transaction hash is used on
     */
    public var networkId: NetworkId
    /**
     * the hash of the intent
     */
    public var hash: Hash
    /**
     * Bech32 encoded TX id
     */
    public var bech32EncodedTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Which network this transaction hash is used on
         */ networkId: NetworkId,
        /**
            * the hash of the intent
            */ hash: Hash,
        /**
            * Bech32 encoded TX id
            */ bech32EncodedTxId: String
    ) {
        self.networkId = networkId
        self.hash = hash
        self.bech32EncodedTxId = bech32EncodedTxId
    }
}

extension IntentHash: Sendable {}
extension IntentHash: Equatable, Hashable {
    public static func == (lhs: IntentHash, rhs: IntentHash) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(hash)
        hasher.combine(bech32EncodedTxId)
    }
}

public struct FfiConverterTypeIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentHash {
        return
            try IntentHash(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                hash: FfiConverterTypeHash.read(from: &buf),
                bech32EncodedTxId: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: IntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeHash.write(value.hash, into: &buf)
        FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
    }
}

public func FfiConverterTypeIntentHash_lift(_ buf: RustBuffer) throws -> IntentHash {
    return try FfiConverterTypeIntentHash.lift(buf)
}

public func FfiConverterTypeIntentHash_lower(_ value: IntentHash) -> RustBuffer {
    return FfiConverterTypeIntentHash.lower(value)
}

public struct IntentSignature {
    fileprivate let secretMagic: SignatureWithPublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: SignatureWithPublicKey) {
        self.secretMagic = secretMagic
    }
}

extension IntentSignature: Sendable {}
extension IntentSignature: Equatable, Hashable {
    public static func == (lhs: IntentSignature, rhs: IntentSignature) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeIntentSignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentSignature {
        return
            try IntentSignature(
                secretMagic: FfiConverterTypeSignatureWithPublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: IntentSignature, into buf: inout [UInt8]) {
        FfiConverterTypeSignatureWithPublicKey.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeIntentSignature_lift(_ buf: RustBuffer) throws -> IntentSignature {
    return try FfiConverterTypeIntentSignature.lift(buf)
}

public func FfiConverterTypeIntentSignature_lower(_ value: IntentSignature) -> RustBuffer {
    return FfiConverterTypeIntentSignature.lower(value)
}

public struct IntentSignatures {
    public var signatures: [IntentSignature]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signatures: [IntentSignature]) {
        self.signatures = signatures
    }
}

extension IntentSignatures: Sendable {}
extension IntentSignatures: Equatable, Hashable {
    public static func == (lhs: IntentSignatures, rhs: IntentSignatures) -> Bool {
        if lhs.signatures != rhs.signatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signatures)
    }
}

public struct FfiConverterTypeIntentSignatures: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentSignatures {
        return
            try IntentSignatures(
                signatures: FfiConverterSequenceTypeIntentSignature.read(from: &buf)
            )
    }

    public static func write(_ value: IntentSignatures, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeIntentSignature.write(value.signatures, into: &buf)
    }
}

public func FfiConverterTypeIntentSignatures_lift(_ buf: RustBuffer) throws -> IntentSignatures {
    return try FfiConverterTypeIntentSignatures.lift(buf)
}

public func FfiConverterTypeIntentSignatures_lower(_ value: IntentSignatures) -> RustBuffer {
    return FfiConverterTypeIntentSignatures.lower(value)
}

public struct LedgerHardwareWalletFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic,
     * that is secured by the Ledger Hardware Wallet device.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a LedgerHardwareWalletFactorSource to help user disambiguate between it and another one.
     */
    public var hint: LedgerHardwareWalletHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic,
         * that is secured by the Ledger Hardware Wallet device.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon,
        /**
            * Properties describing a LedgerHardwareWalletFactorSource to help user disambiguate between it and another one.
            */ hint: LedgerHardwareWalletHint
    ) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}

extension LedgerHardwareWalletFactorSource: Sendable {}
extension LedgerHardwareWalletFactorSource: Equatable, Hashable {
    public static func == (lhs: LedgerHardwareWalletFactorSource, rhs: LedgerHardwareWalletFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}

public struct FfiConverterTypeLedgerHardwareWalletFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletFactorSource {
        return
            try LedgerHardwareWalletFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                hint: FfiConverterTypeLedgerHardwareWalletHint.read(from: &buf)
            )
    }

    public static func write(_ value: LedgerHardwareWalletFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeLedgerHardwareWalletHint.write(value.hint, into: &buf)
    }
}

public func FfiConverterTypeLedgerHardwareWalletFactorSource_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletFactorSource {
    return try FfiConverterTypeLedgerHardwareWalletFactorSource.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletFactorSource_lower(_ value: LedgerHardwareWalletFactorSource) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletFactorSource.lower(value)
}

public struct LedgerHardwareWalletHint {
    /**
     * "Orange, scratched"
     */
    public var name: String
    /**
     * E.g. `nanoS+`
     */
    public var model: LedgerHardwareWalletModel

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * "Orange, scratched"
         */ name: String,
        /**
            * E.g. `nanoS+`
            */ model: LedgerHardwareWalletModel
    ) {
        self.name = name
        self.model = model
    }
}

extension LedgerHardwareWalletHint: Sendable {}
extension LedgerHardwareWalletHint: Equatable, Hashable {
    public static func == (lhs: LedgerHardwareWalletHint, rhs: LedgerHardwareWalletHint) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
    }
}

public struct FfiConverterTypeLedgerHardwareWalletHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletHint {
        return
            try LedgerHardwareWalletHint(
                name: FfiConverterString.read(from: &buf),
                model: FfiConverterTypeLedgerHardwareWalletModel.read(from: &buf)
            )
    }

    public static func write(_ value: LedgerHardwareWalletHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeLedgerHardwareWalletModel.write(value.model, into: &buf)
    }
}

public func FfiConverterTypeLedgerHardwareWalletHint_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletHint {
    return try FfiConverterTypeLedgerHardwareWalletHint.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletHint_lower(_ value: LedgerHardwareWalletHint) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletHint.lower(value)
}

/**
 * The ledger state against which the response was generated. Can be used to detect if the Network Gateway is returning up-to-date information.
 */
public struct LedgerState {
    /**
     * The logical name of the network
     */
    public var network: String
    /**
     * The state version of the ledger. Each transaction increments the state version by 1.
     */
    public var stateVersion: UInt64
    /**
     * The proposer round timestamp of the consensus round when this transaction was committed to ledger. This is not guaranteed to be strictly increasing, as it is computed as an average across the validator set. If this is significantly behind the current timestamp, the Network Gateway is likely reporting out-dated information, or the network has stalled.
     */
    public var proposerRoundTimestamp: String
    /**
     * The epoch number of the ledger at this state version.
     */
    public var epoch: UInt64
    /**
     * The consensus round in the epoch that this state version was committed in.
     */
    public var round: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The logical name of the network
         */ network: String,
        /**
            * The state version of the ledger. Each transaction increments the state version by 1.
            */ stateVersion: UInt64,
        /**
            * The proposer round timestamp of the consensus round when this transaction was committed to ledger. This is not guaranteed to be strictly increasing, as it is computed as an average across the validator set. If this is significantly behind the current timestamp, the Network Gateway is likely reporting out-dated information, or the network has stalled.
            */ proposerRoundTimestamp: String,
        /**
            * The epoch number of the ledger at this state version.
            */ epoch: UInt64,
        /**
            * The consensus round in the epoch that this state version was committed in.
            */ round: UInt64
    ) {
        self.network = network
        self.stateVersion = stateVersion
        self.proposerRoundTimestamp = proposerRoundTimestamp
        self.epoch = epoch
        self.round = round
    }
}

extension LedgerState: Sendable {}
extension LedgerState: Equatable, Hashable {
    public static func == (lhs: LedgerState, rhs: LedgerState) -> Bool {
        if lhs.network != rhs.network {
            return false
        }
        if lhs.stateVersion != rhs.stateVersion {
            return false
        }
        if lhs.proposerRoundTimestamp != rhs.proposerRoundTimestamp {
            return false
        }
        if lhs.epoch != rhs.epoch {
            return false
        }
        if lhs.round != rhs.round {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(network)
        hasher.combine(stateVersion)
        hasher.combine(proposerRoundTimestamp)
        hasher.combine(epoch)
        hasher.combine(round)
    }
}

public struct FfiConverterTypeLedgerState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerState {
        return
            try LedgerState(
                network: FfiConverterString.read(from: &buf),
                stateVersion: FfiConverterUInt64.read(from: &buf),
                proposerRoundTimestamp: FfiConverterString.read(from: &buf),
                epoch: FfiConverterUInt64.read(from: &buf),
                round: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: LedgerState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.network, into: &buf)
        FfiConverterUInt64.write(value.stateVersion, into: &buf)
        FfiConverterString.write(value.proposerRoundTimestamp, into: &buf)
        FfiConverterUInt64.write(value.epoch, into: &buf)
        FfiConverterUInt64.write(value.round, into: &buf)
    }
}

public func FfiConverterTypeLedgerState_lift(_ buf: RustBuffer) throws -> LedgerState {
    return try FfiConverterTypeLedgerState.lift(buf)
}

public func FfiConverterTypeLedgerState_lower(_ value: LedgerState) -> RustBuffer {
    return FfiConverterTypeLedgerState.lower(value)
}

public struct LegacyOlympiaAccountAddress {
    fileprivate let secretMagic: LegacyOlympiaAccountAddressSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: LegacyOlympiaAccountAddressSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension LegacyOlympiaAccountAddress: Sendable {}
extension LegacyOlympiaAccountAddress: Equatable, Hashable {
    public static func == (lhs: LegacyOlympiaAccountAddress, rhs: LegacyOlympiaAccountAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeLegacyOlympiaAccountAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyOlympiaAccountAddress {
        return
            try LegacyOlympiaAccountAddress(
                secretMagic: FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: LegacyOlympiaAccountAddress, into buf: inout [UInt8]) {
        FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeLegacyOlympiaAccountAddress_lift(_ buf: RustBuffer) throws -> LegacyOlympiaAccountAddress {
    return try FfiConverterTypeLegacyOlympiaAccountAddress.lift(buf)
}

public func FfiConverterTypeLegacyOlympiaAccountAddress_lower(_ value: LegacyOlympiaAccountAddress) -> RustBuffer {
    return FfiConverterTypeLegacyOlympiaAccountAddress.lower(value)
}

/**
 * The QR code data scanned from the Connector Extension
 */
public struct LinkConnectionQrData {
    /**
     * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
     * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
     * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
     */
    public var purpose: RadixConnectPurpose
    /**
     * Used to be able to re-establish the P2P connection
     */
    public var password: RadixConnectPassword
    /**
     * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
     * Each client keeps a record of linked clients' public keys to prevent duplicate links.
     * This is the public key of the other client and it also serves as the seed for the link `ID`.
     */
    public var publicKeyOfOtherParty: Ed25519PublicKey
    /**
     * Represents a signature produced by Connector Extension by signing the hash of the `password`
     * with the private key of the `public_key_of_other_party`.
     */
    public var signature: Ed25519Signature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
         * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
         * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
         */ purpose: RadixConnectPurpose,
        /**
            * Used to be able to re-establish the P2P connection
            */ password: RadixConnectPassword,
        /**
            * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
            * Each client keeps a record of linked clients' public keys to prevent duplicate links.
            * This is the public key of the other client and it also serves as the seed for the link `ID`.
            */ publicKeyOfOtherParty: Ed25519PublicKey,
        /**
            * Represents a signature produced by Connector Extension by signing the hash of the `password`
            * with the private key of the `public_key_of_other_party`.
            */ signature: Ed25519Signature
    ) {
        self.purpose = purpose
        self.password = password
        self.publicKeyOfOtherParty = publicKeyOfOtherParty
        self.signature = signature
    }
}

extension LinkConnectionQrData: Sendable {}
extension LinkConnectionQrData: Equatable, Hashable {
    public static func == (lhs: LinkConnectionQrData, rhs: LinkConnectionQrData) -> Bool {
        if lhs.purpose != rhs.purpose {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.publicKeyOfOtherParty != rhs.publicKeyOfOtherParty {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(purpose)
        hasher.combine(password)
        hasher.combine(publicKeyOfOtherParty)
        hasher.combine(signature)
    }
}

public struct FfiConverterTypeLinkConnectionQRData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LinkConnectionQrData {
        return
            try LinkConnectionQrData(
                purpose: FfiConverterTypeRadixConnectPurpose.read(from: &buf),
                password: FfiConverterTypeRadixConnectPassword.read(from: &buf),
                publicKeyOfOtherParty: FfiConverterTypeEd25519PublicKey.read(from: &buf),
                signature: FfiConverterTypeEd25519Signature.read(from: &buf)
            )
    }

    public static func write(_ value: LinkConnectionQrData, into buf: inout [UInt8]) {
        FfiConverterTypeRadixConnectPurpose.write(value.purpose, into: &buf)
        FfiConverterTypeRadixConnectPassword.write(value.password, into: &buf)
        FfiConverterTypeEd25519PublicKey.write(value.publicKeyOfOtherParty, into: &buf)
        FfiConverterTypeEd25519Signature.write(value.signature, into: &buf)
    }
}

public func FfiConverterTypeLinkConnectionQRData_lift(_ buf: RustBuffer) throws -> LinkConnectionQrData {
    return try FfiConverterTypeLinkConnectionQRData.lift(buf)
}

public func FfiConverterTypeLinkConnectionQRData_lower(_ value: LinkConnectionQrData) -> RustBuffer {
    return FfiConverterTypeLinkConnectionQRData.lower(value)
}

public struct LocaleConfig {
    public var decimalSeparator: String?
    public var groupingSeparator: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(decimalSeparator: String?, groupingSeparator: String?) {
        self.decimalSeparator = decimalSeparator
        self.groupingSeparator = groupingSeparator
    }
}

extension LocaleConfig: Sendable {}
extension LocaleConfig: Equatable, Hashable {
    public static func == (lhs: LocaleConfig, rhs: LocaleConfig) -> Bool {
        if lhs.decimalSeparator != rhs.decimalSeparator {
            return false
        }
        if lhs.groupingSeparator != rhs.groupingSeparator {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(decimalSeparator)
        hasher.combine(groupingSeparator)
    }
}

public struct FfiConverterTypeLocaleConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocaleConfig {
        return
            try LocaleConfig(
                decimalSeparator: FfiConverterOptionString.read(from: &buf),
                groupingSeparator: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: LocaleConfig, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.decimalSeparator, into: &buf)
        FfiConverterOptionString.write(value.groupingSeparator, into: &buf)
    }
}

public func FfiConverterTypeLocaleConfig_lift(_ buf: RustBuffer) throws -> LocaleConfig {
    return try FfiConverterTypeLocaleConfig.lift(buf)
}

public func FfiConverterTypeLocaleConfig_lower(_ value: LocaleConfig) -> RustBuffer {
    return FfiConverterTypeLocaleConfig.lower(value)
}

/**
 * A summary of the manifest
 */
public struct ManifestSummary {
    /**
     * Addresses of accounts withdrawn from in the manifest.
     */
    public var addressesOfAccountsWithdrawnFrom: [AccountAddress]
    /**
     * Addresses of accounts deposited into in the manifest.
     */
    public var addressesOfAccountsDepositedInto: [AccountAddress]
    /**
     * Addresses of accounts encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the accounts of all those addresses, which might be multiple
     * signatures per Account, if MFA has been setup.
     */
    public var addressesOfAccountsRequiringAuth: [AccountAddress]
    /**
     * Addresses of identities (Personas) encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the identities of all those addresses, which might be multiple
     * signatures per Persona, if MFA has been setup.
     */
    public var addressesOfPersonasRequiringAuth: [IdentityAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Addresses of accounts withdrawn from in the manifest.
         */ addressesOfAccountsWithdrawnFrom: [AccountAddress],
        /**
            * Addresses of accounts deposited into in the manifest.
            */ addressesOfAccountsDepositedInto: [AccountAddress],
        /**
            * Addresses of accounts encountered in the manifest where privileged
            * methods were called. The wallets will need to collect signatures
            * of the accounts of all those addresses, which might be multiple
            * signatures per Account, if MFA has been setup.
            */ addressesOfAccountsRequiringAuth: [AccountAddress],
        /**
            * Addresses of identities (Personas) encountered in the manifest where privileged
            * methods were called. The wallets will need to collect signatures
            * of the identities of all those addresses, which might be multiple
            * signatures per Persona, if MFA has been setup.
            */ addressesOfPersonasRequiringAuth: [IdentityAddress]
    ) {
        self.addressesOfAccountsWithdrawnFrom = addressesOfAccountsWithdrawnFrom
        self.addressesOfAccountsDepositedInto = addressesOfAccountsDepositedInto
        self.addressesOfAccountsRequiringAuth = addressesOfAccountsRequiringAuth
        self.addressesOfPersonasRequiringAuth = addressesOfPersonasRequiringAuth
    }
}

extension ManifestSummary: Sendable {}
extension ManifestSummary: Equatable, Hashable {
    public static func == (lhs: ManifestSummary, rhs: ManifestSummary) -> Bool {
        if lhs.addressesOfAccountsWithdrawnFrom != rhs.addressesOfAccountsWithdrawnFrom {
            return false
        }
        if lhs.addressesOfAccountsDepositedInto != rhs.addressesOfAccountsDepositedInto {
            return false
        }
        if lhs.addressesOfAccountsRequiringAuth != rhs.addressesOfAccountsRequiringAuth {
            return false
        }
        if lhs.addressesOfPersonasRequiringAuth != rhs.addressesOfPersonasRequiringAuth {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addressesOfAccountsWithdrawnFrom)
        hasher.combine(addressesOfAccountsDepositedInto)
        hasher.combine(addressesOfAccountsRequiringAuth)
        hasher.combine(addressesOfPersonasRequiringAuth)
    }
}

public struct FfiConverterTypeManifestSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestSummary {
        return
            try ManifestSummary(
                addressesOfAccountsWithdrawnFrom: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
                addressesOfAccountsDepositedInto: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
                addressesOfAccountsRequiringAuth: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
                addressesOfPersonasRequiringAuth: FfiConverterSequenceTypeIdentityAddress.read(from: &buf)
            )
    }

    public static func write(_ value: ManifestSummary, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsWithdrawnFrom, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsDepositedInto, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsRequiringAuth, into: &buf)
        FfiConverterSequenceTypeIdentityAddress.write(value.addressesOfPersonasRequiringAuth, into: &buf)
    }
}

public func FfiConverterTypeManifestSummary_lift(_ buf: RustBuffer) throws -> ManifestSummary {
    return try FfiConverterTypeManifestSummary.lift(buf)
}

public func FfiConverterTypeManifestSummary_lower(_ value: ManifestSummary) -> RustBuffer {
    return FfiConverterTypeManifestSummary.lower(value)
}

/**
 * A matrix of FactorInstances
 */
public struct MatrixOfFactorInstances {
    /**
     * Used for Signing transactions
     */
    public var primaryRole: PrimaryRoleWithFactorInstances
    /**
     * Used to initiate recovery - resetting the used Security Shield
     * of an entity.
     */
    public var recoveryRole: RecoveryRoleWithFactorInstances
    /**
     * To confirm recovery.
     */
    public var confirmationRole: ConfirmationRoleWithFactorInstances

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Used for Signing transactions
         */ primaryRole: PrimaryRoleWithFactorInstances,
        /**
            * Used to initiate recovery - resetting the used Security Shield
            * of an entity.
            */ recoveryRole: RecoveryRoleWithFactorInstances,
        /**
            * To confirm recovery.
            */ confirmationRole: ConfirmationRoleWithFactorInstances
    ) {
        self.primaryRole = primaryRole
        self.recoveryRole = recoveryRole
        self.confirmationRole = confirmationRole
    }
}

extension MatrixOfFactorInstances: Sendable {}
extension MatrixOfFactorInstances: Equatable, Hashable {
    public static func == (lhs: MatrixOfFactorInstances, rhs: MatrixOfFactorInstances) -> Bool {
        if lhs.primaryRole != rhs.primaryRole {
            return false
        }
        if lhs.recoveryRole != rhs.recoveryRole {
            return false
        }
        if lhs.confirmationRole != rhs.confirmationRole {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(primaryRole)
        hasher.combine(recoveryRole)
        hasher.combine(confirmationRole)
    }
}

public struct FfiConverterTypeMatrixOfFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixOfFactorInstances {
        return
            try MatrixOfFactorInstances(
                primaryRole: FfiConverterTypePrimaryRoleWithFactorInstances.read(from: &buf),
                recoveryRole: FfiConverterTypeRecoveryRoleWithFactorInstances.read(from: &buf),
                confirmationRole: FfiConverterTypeConfirmationRoleWithFactorInstances.read(from: &buf)
            )
    }

    public static func write(_ value: MatrixOfFactorInstances, into buf: inout [UInt8]) {
        FfiConverterTypePrimaryRoleWithFactorInstances.write(value.primaryRole, into: &buf)
        FfiConverterTypeRecoveryRoleWithFactorInstances.write(value.recoveryRole, into: &buf)
        FfiConverterTypeConfirmationRoleWithFactorInstances.write(value.confirmationRole, into: &buf)
    }
}

public func FfiConverterTypeMatrixOfFactorInstances_lift(_ buf: RustBuffer) throws -> MatrixOfFactorInstances {
    return try FfiConverterTypeMatrixOfFactorInstances.lift(buf)
}

public func FfiConverterTypeMatrixOfFactorInstances_lower(_ value: MatrixOfFactorInstances) -> RustBuffer {
    return FfiConverterTypeMatrixOfFactorInstances.lower(value)
}

public struct MatrixOfFactorSourceIDs {
    /**
     * Used for Signing transactions
     */
    public var primaryRole: PrimaryRoleWithFactorSourceIDs
    /**
     * Used to initiate recovery - resetting the used Security Shield
     * of an entity.
     */
    public var recoveryRole: RecoveryRoleWithFactorSourceIDs
    /**
     * To confirm recovery.
     */
    public var confirmationRole: ConfirmationRoleWithFactorSourceIDs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Used for Signing transactions
         */ primaryRole: PrimaryRoleWithFactorSourceIDs,
        /**
            * Used to initiate recovery - resetting the used Security Shield
            * of an entity.
            */ recoveryRole: RecoveryRoleWithFactorSourceIDs,
        /**
            * To confirm recovery.
            */ confirmationRole: ConfirmationRoleWithFactorSourceIDs
    ) {
        self.primaryRole = primaryRole
        self.recoveryRole = recoveryRole
        self.confirmationRole = confirmationRole
    }
}

extension MatrixOfFactorSourceIDs: Sendable {}
extension MatrixOfFactorSourceIDs: Equatable, Hashable {
    public static func == (lhs: MatrixOfFactorSourceIDs, rhs: MatrixOfFactorSourceIDs) -> Bool {
        if lhs.primaryRole != rhs.primaryRole {
            return false
        }
        if lhs.recoveryRole != rhs.recoveryRole {
            return false
        }
        if lhs.confirmationRole != rhs.confirmationRole {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(primaryRole)
        hasher.combine(recoveryRole)
        hasher.combine(confirmationRole)
    }
}

public struct FfiConverterTypeMatrixOfFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixOfFactorSourceIDs {
        return
            try MatrixOfFactorSourceIDs(
                primaryRole: FfiConverterTypePrimaryRoleWithFactorSourceIDs.read(from: &buf),
                recoveryRole: FfiConverterTypeRecoveryRoleWithFactorSourceIDs.read(from: &buf),
                confirmationRole: FfiConverterTypeConfirmationRoleWithFactorSourceIDs.read(from: &buf)
            )
    }

    public static func write(_ value: MatrixOfFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterTypePrimaryRoleWithFactorSourceIDs.write(value.primaryRole, into: &buf)
        FfiConverterTypeRecoveryRoleWithFactorSourceIDs.write(value.recoveryRole, into: &buf)
        FfiConverterTypeConfirmationRoleWithFactorSourceIDs.write(value.confirmationRole, into: &buf)
    }
}

public func FfiConverterTypeMatrixOfFactorSourceIDs_lift(_ buf: RustBuffer) throws -> MatrixOfFactorSourceIDs {
    return try FfiConverterTypeMatrixOfFactorSourceIDs.lift(buf)
}

public func FfiConverterTypeMatrixOfFactorSourceIDs_lower(_ value: MatrixOfFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypeMatrixOfFactorSourceIDs.lower(value)
}

public struct MatrixOfFactorSources {
    /**
     * Used for Signing transactions
     */
    public var primaryRole: PrimaryRoleWithFactorSources
    /**
     * Used to initiate recovery - resetting the used Security Shield
     * of an entity.
     */
    public var recoveryRole: RecoveryRoleWithFactorSources
    /**
     * To confirm recovery.
     */
    public var confirmationRole: ConfirmationRoleWithFactorSources

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Used for Signing transactions
         */ primaryRole: PrimaryRoleWithFactorSources,
        /**
            * Used to initiate recovery - resetting the used Security Shield
            * of an entity.
            */ recoveryRole: RecoveryRoleWithFactorSources,
        /**
            * To confirm recovery.
            */ confirmationRole: ConfirmationRoleWithFactorSources
    ) {
        self.primaryRole = primaryRole
        self.recoveryRole = recoveryRole
        self.confirmationRole = confirmationRole
    }
}

extension MatrixOfFactorSources: Sendable {}
extension MatrixOfFactorSources: Equatable, Hashable {
    public static func == (lhs: MatrixOfFactorSources, rhs: MatrixOfFactorSources) -> Bool {
        if lhs.primaryRole != rhs.primaryRole {
            return false
        }
        if lhs.recoveryRole != rhs.recoveryRole {
            return false
        }
        if lhs.confirmationRole != rhs.confirmationRole {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(primaryRole)
        hasher.combine(recoveryRole)
        hasher.combine(confirmationRole)
    }
}

public struct FfiConverterTypeMatrixOfFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixOfFactorSources {
        return
            try MatrixOfFactorSources(
                primaryRole: FfiConverterTypePrimaryRoleWithFactorSources.read(from: &buf),
                recoveryRole: FfiConverterTypeRecoveryRoleWithFactorSources.read(from: &buf),
                confirmationRole: FfiConverterTypeConfirmationRoleWithFactorSources.read(from: &buf)
            )
    }

    public static func write(_ value: MatrixOfFactorSources, into buf: inout [UInt8]) {
        FfiConverterTypePrimaryRoleWithFactorSources.write(value.primaryRole, into: &buf)
        FfiConverterTypeRecoveryRoleWithFactorSources.write(value.recoveryRole, into: &buf)
        FfiConverterTypeConfirmationRoleWithFactorSources.write(value.confirmationRole, into: &buf)
    }
}

public func FfiConverterTypeMatrixOfFactorSources_lift(_ buf: RustBuffer) throws -> MatrixOfFactorSources {
    return try FfiConverterTypeMatrixOfFactorSources.lift(buf)
}

public func FfiConverterTypeMatrixOfFactorSources_lower(_ value: MatrixOfFactorSources) -> RustBuffer {
    return FfiConverterTypeMatrixOfFactorSources.lower(value)
}

public struct Mnemonic {
    public var words: [Bip39Word]
    public var wordCount: Bip39WordCount
    public var language: Bip39Language

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(words: [Bip39Word], wordCount: Bip39WordCount, language: Bip39Language) {
        self.words = words
        self.wordCount = wordCount
        self.language = language
    }
}

extension Mnemonic: Sendable {}
extension Mnemonic: Equatable, Hashable {
    public static func == (lhs: Mnemonic, rhs: Mnemonic) -> Bool {
        if lhs.words != rhs.words {
            return false
        }
        if lhs.wordCount != rhs.wordCount {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(words)
        hasher.combine(wordCount)
        hasher.combine(language)
    }
}

public struct FfiConverterTypeMnemonic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        return
            try Mnemonic(
                words: FfiConverterSequenceTypeBIP39Word.read(from: &buf),
                wordCount: FfiConverterTypeBIP39WordCount.read(from: &buf),
                language: FfiConverterTypeBIP39Language.read(from: &buf)
            )
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBIP39Word.write(value.words, into: &buf)
        FfiConverterTypeBIP39WordCount.write(value.wordCount, into: &buf)
        FfiConverterTypeBIP39Language.write(value.language, into: &buf)
    }
}

public func FfiConverterTypeMnemonic_lift(_ buf: RustBuffer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(buf)
}

public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> RustBuffer {
    return FfiConverterTypeMnemonic.lower(value)
}

/**
 * A BIP39 Mnemonic and BIP39 passphrase - aka "25th word" tuple,
 * from which we can derive a HD Root used for derivation.
 */
public struct MnemonicWithPassphrase {
    public var mnemonic: Mnemonic
    public var passphrase: Bip39Passphrase

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonic: Mnemonic, passphrase: Bip39Passphrase) {
        self.mnemonic = mnemonic
        self.passphrase = passphrase
    }
}

extension MnemonicWithPassphrase: Sendable {}
extension MnemonicWithPassphrase: Equatable, Hashable {
    public static func == (lhs: MnemonicWithPassphrase, rhs: MnemonicWithPassphrase) -> Bool {
        if lhs.mnemonic != rhs.mnemonic {
            return false
        }
        if lhs.passphrase != rhs.passphrase {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonic)
        hasher.combine(passphrase)
    }
}

public struct FfiConverterTypeMnemonicWithPassphrase: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicWithPassphrase {
        return
            try MnemonicWithPassphrase(
                mnemonic: FfiConverterTypeMnemonic.read(from: &buf),
                passphrase: FfiConverterTypeBIP39Passphrase.read(from: &buf)
            )
    }

    public static func write(_ value: MnemonicWithPassphrase, into buf: inout [UInt8]) {
        FfiConverterTypeMnemonic.write(value.mnemonic, into: &buf)
        FfiConverterTypeBIP39Passphrase.write(value.passphrase, into: &buf)
    }
}

public func FfiConverterTypeMnemonicWithPassphrase_lift(_ buf: RustBuffer) throws -> MnemonicWithPassphrase {
    return try FfiConverterTypeMnemonicWithPassphrase.lift(buf)
}

public func FfiConverterTypeMnemonicWithPassphrase_lower(_ value: MnemonicWithPassphrase) -> RustBuffer {
    return FfiConverterTypeMnemonicWithPassphrase.lower(value)
}

/**
 * A version of the Radix Network, for a NetworkID with an identifier (name) and display description (display name)
 */
public struct NetworkDefinition {
    /**
     * A String identifier (always lowercase) with the name of the Network that MUST match what Gateway returns.
     */
    public var logicalName: String
    /**
     * The canonical identifier of this network.
     */
    public var id: NetworkId
    /**
     * A name of the network intended for display purposes only.
     */
    public var displayDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A String identifier (always lowercase) with the name of the Network that MUST match what Gateway returns.
         */ logicalName: String,
        /**
            * The canonical identifier of this network.
            */ id: NetworkId,
        /**
            * A name of the network intended for display purposes only.
            */ displayDescription: String
    ) {
        self.logicalName = logicalName
        self.id = id
        self.displayDescription = displayDescription
    }
}

extension NetworkDefinition: Sendable {}
extension NetworkDefinition: Equatable, Hashable {
    public static func == (lhs: NetworkDefinition, rhs: NetworkDefinition) -> Bool {
        if lhs.logicalName != rhs.logicalName {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.displayDescription != rhs.displayDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(logicalName)
        hasher.combine(id)
        hasher.combine(displayDescription)
    }
}

public struct FfiConverterTypeNetworkDefinition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkDefinition {
        return
            try NetworkDefinition(
                logicalName: FfiConverterString.read(from: &buf),
                id: FfiConverterTypeNetworkID.read(from: &buf),
                displayDescription: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: NetworkDefinition, into buf: inout [UInt8]) {
        FfiConverterString.write(value.logicalName, into: &buf)
        FfiConverterTypeNetworkID.write(value.id, into: &buf)
        FfiConverterString.write(value.displayDescription, into: &buf)
    }
}

public func FfiConverterTypeNetworkDefinition_lift(_ buf: RustBuffer) throws -> NetworkDefinition {
    return try FfiConverterTypeNetworkDefinition.lift(buf)
}

public func FfiConverterTypeNetworkDefinition_lower(_ value: NetworkDefinition) -> RustBuffer {
    return FfiConverterTypeNetworkDefinition.lower(value)
}

public struct NetworkRequest {
    public var url: Url
    public var method: NetworkMethod
    public var headers: [String: String]
    public var body: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: Url, method: NetworkMethod, headers: [String: String], body: BagOfBytes) {
        self.url = url
        self.method = method
        self.headers = headers
        self.body = body
    }
}

extension NetworkRequest: Sendable {}
extension NetworkRequest: Equatable, Hashable {
    public static func == (lhs: NetworkRequest, rhs: NetworkRequest) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(method)
        hasher.combine(headers)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeNetworkRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkRequest {
        return
            try NetworkRequest(
                url: FfiConverterTypeUrl.read(from: &buf),
                method: FfiConverterTypeNetworkMethod.read(from: &buf),
                headers: FfiConverterDictionaryStringString.read(from: &buf),
                body: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: NetworkRequest, into buf: inout [UInt8]) {
        FfiConverterTypeUrl.write(value.url, into: &buf)
        FfiConverterTypeNetworkMethod.write(value.method, into: &buf)
        FfiConverterDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterTypeBagOfBytes.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeNetworkRequest_lift(_ buf: RustBuffer) throws -> NetworkRequest {
    return try FfiConverterTypeNetworkRequest.lift(buf)
}

public func FfiConverterTypeNetworkRequest_lower(_ value: NetworkRequest) -> RustBuffer {
    return FfiConverterTypeNetworkRequest.lower(value)
}

public struct NetworkResponse {
    public var statusCode: UInt16
    /**
     * Can be empty.
     */
    public var body: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(statusCode: UInt16,
                /**
                    * Can be empty.
                    */ body: BagOfBytes)
    {
        self.statusCode = statusCode
        self.body = body
    }
}

extension NetworkResponse: Sendable {}
extension NetworkResponse: Equatable, Hashable {
    public static func == (lhs: NetworkResponse, rhs: NetworkResponse) -> Bool {
        if lhs.statusCode != rhs.statusCode {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(statusCode)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeNetworkResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkResponse {
        return
            try NetworkResponse(
                statusCode: FfiConverterUInt16.read(from: &buf),
                body: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: NetworkResponse, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.statusCode, into: &buf)
        FfiConverterTypeBagOfBytes.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeNetworkResponse_lift(_ buf: RustBuffer) throws -> NetworkResponse {
    return try FfiConverterTypeNetworkResponse.lift(buf)
}

public func FfiConverterTypeNetworkResponse_lower(_ value: NetworkResponse) -> RustBuffer {
    return FfiConverterTypeNetworkResponse.lower(value)
}

/**
 * Information on the global entities created in the transaction.
 */
public struct NewEntities {
    public var metadata: [ResourceAddress: NewlyCreatedResource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(metadata: [ResourceAddress: NewlyCreatedResource]) {
        self.metadata = metadata
    }
}

extension NewEntities: Sendable {}
extension NewEntities: Equatable, Hashable {
    public static func == (lhs: NewEntities, rhs: NewEntities) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
    }
}

public struct FfiConverterTypeNewEntities: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewEntities {
        return
            try NewEntities(
                metadata: FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource.read(from: &buf)
            )
    }

    public static func write(_ value: NewEntities, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource.write(value.metadata, into: &buf)
    }
}

public func FfiConverterTypeNewEntities_lift(_ buf: RustBuffer) throws -> NewEntities {
    return try FfiConverterTypeNewEntities.lift(buf)
}

public func FfiConverterTypeNewEntities_lower(_ value: NewEntities) -> RustBuffer {
    return FfiConverterTypeNewEntities.lower(value)
}

/**
 * Metadata about a newly created Resource
 */
public struct NewlyCreatedResource {
    public var name: String?
    public var symbol: String?
    public var description: String?
    public var iconUrl: String?
    public var tags: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String?, symbol: String?, description: String?, iconUrl: String?, tags: [String]) {
        self.name = name
        self.symbol = symbol
        self.description = description
        self.iconUrl = iconUrl
        self.tags = tags
    }
}

extension NewlyCreatedResource: Sendable {}
extension NewlyCreatedResource: Equatable, Hashable {
    public static func == (lhs: NewlyCreatedResource, rhs: NewlyCreatedResource) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.iconUrl != rhs.iconUrl {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(symbol)
        hasher.combine(description)
        hasher.combine(iconUrl)
        hasher.combine(tags)
    }
}

public struct FfiConverterTypeNewlyCreatedResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewlyCreatedResource {
        return
            try NewlyCreatedResource(
                name: FfiConverterOptionString.read(from: &buf),
                symbol: FfiConverterOptionString.read(from: &buf),
                description: FfiConverterOptionString.read(from: &buf),
                iconUrl: FfiConverterOptionString.read(from: &buf),
                tags: FfiConverterSequenceString.read(from: &buf)
            )
    }

    public static func write(_ value: NewlyCreatedResource, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.symbol, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.iconUrl, into: &buf)
        FfiConverterSequenceString.write(value.tags, into: &buf)
    }
}

public func FfiConverterTypeNewlyCreatedResource_lift(_ buf: RustBuffer) throws -> NewlyCreatedResource {
    return try FfiConverterTypeNewlyCreatedResource.lift(buf)
}

public func FfiConverterTypeNewlyCreatedResource_lower(_ value: NewlyCreatedResource) -> RustBuffer {
    return FfiConverterTypeNewlyCreatedResource.lower(value)
}

/**
 * 32 bytes, typically used as entropy for Mnemonics.
 */
public struct NonEmptyMax32Bytes {
    public var bagOfBytes: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bagOfBytes: BagOfBytes) {
        self.bagOfBytes = bagOfBytes
    }
}

extension NonEmptyMax32Bytes: Sendable {}
extension NonEmptyMax32Bytes: Equatable, Hashable {
    public static func == (lhs: NonEmptyMax32Bytes, rhs: NonEmptyMax32Bytes) -> Bool {
        if lhs.bagOfBytes != rhs.bagOfBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bagOfBytes)
    }
}

public struct FfiConverterTypeNonEmptyMax32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonEmptyMax32Bytes {
        return
            try NonEmptyMax32Bytes(
                bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: NonEmptyMax32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
    }
}

public func FfiConverterTypeNonEmptyMax32Bytes_lift(_ buf: RustBuffer) throws -> NonEmptyMax32Bytes {
    return try FfiConverterTypeNonEmptyMax32Bytes.lift(buf)
}

public func FfiConverterTypeNonEmptyMax32Bytes_lower(_ value: NonEmptyMax32Bytes) -> RustBuffer {
    return FfiConverterTypeNonEmptyMax32Bytes.lower(value)
}

/**
 * 64 bytes, typically used by NonFungibleLocalId::Bytes
 */
public struct NonEmptyMax64Bytes {
    public var bagOfBytes: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bagOfBytes: BagOfBytes) {
        self.bagOfBytes = bagOfBytes
    }
}

extension NonEmptyMax64Bytes: Sendable {}
extension NonEmptyMax64Bytes: Equatable, Hashable {
    public static func == (lhs: NonEmptyMax64Bytes, rhs: NonEmptyMax64Bytes) -> Bool {
        if lhs.bagOfBytes != rhs.bagOfBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bagOfBytes)
    }
}

public struct FfiConverterTypeNonEmptyMax64Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonEmptyMax64Bytes {
        return
            try NonEmptyMax64Bytes(
                bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: NonEmptyMax64Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
    }
}

public func FfiConverterTypeNonEmptyMax64Bytes_lift(_ buf: RustBuffer) throws -> NonEmptyMax64Bytes {
    return try FfiConverterTypeNonEmptyMax64Bytes.lift(buf)
}

public func FfiConverterTypeNonEmptyMax64Bytes_lower(_ value: NonEmptyMax64Bytes) -> RustBuffer {
    return FfiConverterTypeNonEmptyMax64Bytes.lower(value)
}

public struct NonFungibleGlobalId {
    public var resourceAddress: ResourceAddress
    public var nonFungibleLocalId: NonFungibleLocalId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: ResourceAddress, nonFungibleLocalId: NonFungibleLocalId) {
        self.resourceAddress = resourceAddress
        self.nonFungibleLocalId = nonFungibleLocalId
    }
}

extension NonFungibleGlobalId: Sendable {}
extension NonFungibleGlobalId: Equatable, Hashable {
    public static func == (lhs: NonFungibleGlobalId, rhs: NonFungibleGlobalId) -> Bool {
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.nonFungibleLocalId != rhs.nonFungibleLocalId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resourceAddress)
        hasher.combine(nonFungibleLocalId)
    }
}

public struct FfiConverterTypeNonFungibleGlobalId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleGlobalId {
        return
            try NonFungibleGlobalId(
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                nonFungibleLocalId: FfiConverterTypeNonFungibleLocalId.read(from: &buf)
            )
    }

    public static func write(_ value: NonFungibleGlobalId, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeNonFungibleLocalId.write(value.nonFungibleLocalId, into: &buf)
    }
}

public func FfiConverterTypeNonFungibleGlobalId_lift(_ buf: RustBuffer) throws -> NonFungibleGlobalId {
    return try FfiConverterTypeNonFungibleGlobalId.lift(buf)
}

public func FfiConverterTypeNonFungibleGlobalId_lower(_ value: NonFungibleGlobalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleGlobalId.lower(value)
}

/**
 * A string matching `[_0-9a-zA-Z]{1,64}`.
 *
 * This is an internal wrapping of Scrypto's `StringNonFungibleLocalId`
 * with a UniFFI custom converter using `String` as `Builtin`.
 *
 * Using this type instead of `String` directly in `NonFungibleLocalId::Str`,
 * allows us to do impl `From<NonFungibleLocalId> for NonFungibleLocalId` instead
 * of `TryFrom<NonFungibleLocalId>`.
 */
public struct NonFungibleLocalIdString {
    fileprivate let secretMagic: ScryptoStringNonFungibleLocalId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: ScryptoStringNonFungibleLocalId) {
        self.secretMagic = secretMagic
    }
}

extension NonFungibleLocalIdString: Sendable {}
extension NonFungibleLocalIdString: Equatable, Hashable {
    public static func == (lhs: NonFungibleLocalIdString, rhs: NonFungibleLocalIdString) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeNonFungibleLocalIdString: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalIdString {
        return
            try NonFungibleLocalIdString(
                secretMagic: FfiConverterTypeScryptoStringNonFungibleLocalId.read(from: &buf)
            )
    }

    public static func write(_ value: NonFungibleLocalIdString, into buf: inout [UInt8]) {
        FfiConverterTypeScryptoStringNonFungibleLocalId.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeNonFungibleLocalIdString_lift(_ buf: RustBuffer) throws -> NonFungibleLocalIdString {
    return try FfiConverterTypeNonFungibleLocalIdString.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalIdString_lower(_ value: NonFungibleLocalIdString) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalIdString.lower(value)
}

/**
 * NonFungibleResourceAddress is a specialized ResourceAddress for resources
 * which are non fungible, it ALWAYS has an `'n'` after bech32 separator `'1'`, e.g.:
 * `"resource_rdx1nfyg2f68jw7hfdlg5hzvd8ylsa7e0kjl68t5t62v3ttamtejc9wlxa"`.
 *
 * As opposed to a fungible resource address, e.g. that of XRD which has `'t'`
 * after bech32 separator `'1'`, see:
 * `"resource_rdx1tknxxxxxxxxxradxrdxxxxxxxxx009923554798xxxxxxxxxradxrd"`
 *
 * This means that given an instance of `NonFungibleResourceAddress`, it is
 * guaranteed that its entity type is [`::GlobalNonFungibleResourceManager`],
 * and not `::GlobalFungibleResourceManager`.
 *
 * This type can safely be used with [`StakeClaim`]s, unfortunately since Radix Engine
 * and/or network does not validate the resource address of a `NonFungibleGlobalId`,
 * we cannot use this for that type.
 */
public struct NonFungibleResourceAddress {
    fileprivate let secretMagic: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: ResourceAddress) {
        self.secretMagic = secretMagic
    }
}

extension NonFungibleResourceAddress: Sendable {}
extension NonFungibleResourceAddress: Equatable, Hashable {
    public static func == (lhs: NonFungibleResourceAddress, rhs: NonFungibleResourceAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeNonFungibleResourceAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleResourceAddress {
        return
            try NonFungibleResourceAddress(
                secretMagic: FfiConverterTypeResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: NonFungibleResourceAddress, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeNonFungibleResourceAddress_lift(_ buf: RustBuffer) throws -> NonFungibleResourceAddress {
    return try FfiConverterTypeNonFungibleResourceAddress.lift(buf)
}

public func FfiConverterTypeNonFungibleResourceAddress_lower(_ value: NonFungibleResourceAddress) -> RustBuffer {
    return FfiConverterTypeNonFungibleResourceAddress.lower(value)
}

/**
 * A random number generated part of a transaction header,
 * ensuring every transaction os unique even though its
 * transaction manifest might be equal. This nonce is
 * generated by wallets for incoming transactions.
 */
public struct Nonce {
    fileprivate let secretMagic: NonceSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: NonceSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension Nonce: Sendable {}
extension Nonce: Equatable, Hashable {
    public static func == (lhs: Nonce, rhs: Nonce) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeNonce: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nonce {
        return
            try Nonce(
                secretMagic: FfiConverterTypeNonceSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: Nonce, into buf: inout [UInt8]) {
        FfiConverterTypeNonceSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeNonce_lift(_ buf: RustBuffer) throws -> Nonce {
    return try FfiConverterTypeNonce.lift(buf)
}

public func FfiConverterTypeNonce_lower(_ value: Nonce) -> RustBuffer {
    return FfiConverterTypeNonce.lower(value)
}

public struct NotarizedTransaction {
    public var signedIntent: SignedIntent
    public var notarySignature: NotarySignature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signedIntent: SignedIntent, notarySignature: NotarySignature) {
        self.signedIntent = signedIntent
        self.notarySignature = notarySignature
    }
}

extension NotarizedTransaction: Sendable {}
extension NotarizedTransaction: Equatable, Hashable {
    public static func == (lhs: NotarizedTransaction, rhs: NotarizedTransaction) -> Bool {
        if lhs.signedIntent != rhs.signedIntent {
            return false
        }
        if lhs.notarySignature != rhs.notarySignature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signedIntent)
        hasher.combine(notarySignature)
    }
}

public struct FfiConverterTypeNotarizedTransaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarizedTransaction {
        return
            try NotarizedTransaction(
                signedIntent: FfiConverterTypeSignedIntent.read(from: &buf),
                notarySignature: FfiConverterTypeNotarySignature.read(from: &buf)
            )
    }

    public static func write(_ value: NotarizedTransaction, into buf: inout [UInt8]) {
        FfiConverterTypeSignedIntent.write(value.signedIntent, into: &buf)
        FfiConverterTypeNotarySignature.write(value.notarySignature, into: &buf)
    }
}

public func FfiConverterTypeNotarizedTransaction_lift(_ buf: RustBuffer) throws -> NotarizedTransaction {
    return try FfiConverterTypeNotarizedTransaction.lift(buf)
}

public func FfiConverterTypeNotarizedTransaction_lower(_ value: NotarizedTransaction) -> RustBuffer {
    return FfiConverterTypeNotarizedTransaction.lower(value)
}

public struct NotarySignature {
    fileprivate let secretMagic: Signature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Signature) {
        self.secretMagic = secretMagic
    }
}

extension NotarySignature: Sendable {}
extension NotarySignature: Equatable, Hashable {
    public static func == (lhs: NotarySignature, rhs: NotarySignature) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeNotarySignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarySignature {
        return
            try NotarySignature(
                secretMagic: FfiConverterTypeSignature.read(from: &buf)
            )
    }

    public static func write(_ value: NotarySignature, into buf: inout [UInt8]) {
        FfiConverterTypeSignature.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeNotarySignature_lift(_ buf: RustBuffer) throws -> NotarySignature {
    return try FfiConverterTypeNotarySignature.lift(buf)
}

public func FfiConverterTypeNotarySignature_lower(_ value: NotarySignature) -> RustBuffer {
    return FfiConverterTypeNotarySignature.lower(value)
}

/**
 * A factor source representing a Mnemonic the user has to input every time
 * the use the factor source, since it is not saved on the device, it is said
 * to be "off device".
 */
public struct OffDeviceMnemonicFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a OffDeviceMnemonicFactorSource to help user
     * disambiguate between it and another one.
     */
    public var hint: OffDeviceMnemonicHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon,
        /**
            * Properties describing a OffDeviceMnemonicFactorSource to help user
            * disambiguate between it and another one.
            */ hint: OffDeviceMnemonicHint
    ) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}

extension OffDeviceMnemonicFactorSource: Sendable {}
extension OffDeviceMnemonicFactorSource: Equatable, Hashable {
    public static func == (lhs: OffDeviceMnemonicFactorSource, rhs: OffDeviceMnemonicFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}

public struct FfiConverterTypeOffDeviceMnemonicFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OffDeviceMnemonicFactorSource {
        return
            try OffDeviceMnemonicFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                hint: FfiConverterTypeOffDeviceMnemonicHint.read(from: &buf)
            )
    }

    public static func write(_ value: OffDeviceMnemonicFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeOffDeviceMnemonicHint.write(value.hint, into: &buf)
    }
}

public func FfiConverterTypeOffDeviceMnemonicFactorSource_lift(_ buf: RustBuffer) throws -> OffDeviceMnemonicFactorSource {
    return try FfiConverterTypeOffDeviceMnemonicFactorSource.lift(buf)
}

public func FfiConverterTypeOffDeviceMnemonicFactorSource_lower(_ value: OffDeviceMnemonicFactorSource) -> RustBuffer {
    return FfiConverterTypeOffDeviceMnemonicFactorSource.lower(value)
}

/**
 * Properties describing a DeviceFactorSource to help user disambiguate between
 * it and another one.
 */
public struct OffDeviceMnemonicHint {
    public var displayName: DisplayName

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(displayName: DisplayName) {
        self.displayName = displayName
    }
}

extension OffDeviceMnemonicHint: Sendable {}
extension OffDeviceMnemonicHint: Equatable, Hashable {
    public static func == (lhs: OffDeviceMnemonicHint, rhs: OffDeviceMnemonicHint) -> Bool {
        if lhs.displayName != rhs.displayName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(displayName)
    }
}

public struct FfiConverterTypeOffDeviceMnemonicHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OffDeviceMnemonicHint {
        return
            try OffDeviceMnemonicHint(
                displayName: FfiConverterTypeDisplayName.read(from: &buf)
            )
    }

    public static func write(_ value: OffDeviceMnemonicHint, into buf: inout [UInt8]) {
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
    }
}

public func FfiConverterTypeOffDeviceMnemonicHint_lift(_ buf: RustBuffer) throws -> OffDeviceMnemonicHint {
    return try FfiConverterTypeOffDeviceMnemonicHint.lift(buf)
}

public func FfiConverterTypeOffDeviceMnemonicHint_lower(_ value: OffDeviceMnemonicHint) -> RustBuffer {
    return FfiConverterTypeOffDeviceMnemonicHint.lower(value)
}

/**
 * Account settings that user has set on the account component
 * On-Ledger, that is set via a transaction mutating the state
 * on the network.
 *
 * This settings include third-party deposits, controlling who
 * can send which assets to this account.
 *
 * These settings SHOULD be kept in sync between local state
 * (in Profile) and On-Ledger.
 */
public struct OnLedgerSettings {
    /**
     * Controls the ability of third-parties to deposit into this account
     */
    public var thirdPartyDeposits: ThirdPartyDeposits

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Controls the ability of third-parties to deposit into this account
         */ thirdPartyDeposits: ThirdPartyDeposits
    ) {
        self.thirdPartyDeposits = thirdPartyDeposits
    }
}

extension OnLedgerSettings: Sendable {}
extension OnLedgerSettings: Equatable, Hashable {
    public static func == (lhs: OnLedgerSettings, rhs: OnLedgerSettings) -> Bool {
        if lhs.thirdPartyDeposits != rhs.thirdPartyDeposits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thirdPartyDeposits)
    }
}

public struct FfiConverterTypeOnLedgerSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnLedgerSettings {
        return
            try OnLedgerSettings(
                thirdPartyDeposits: FfiConverterTypeThirdPartyDeposits.read(from: &buf)
            )
    }

    public static func write(_ value: OnLedgerSettings, into buf: inout [UInt8]) {
        FfiConverterTypeThirdPartyDeposits.write(value.thirdPartyDeposits, into: &buf)
    }
}

public func FfiConverterTypeOnLedgerSettings_lift(_ buf: RustBuffer) throws -> OnLedgerSettings {
    return try FfiConverterTypeOnLedgerSettings.lift(buf)
}

public func FfiConverterTypeOnLedgerSettings_lower(_ value: OnLedgerSettings) -> RustBuffer {
    return FfiConverterTypeOnLedgerSettings.lower(value)
}

/**
 * A client the user have connected P2P with, typically a WebRTC connection with the dApp or Connector Extension.
 * Each client generates a curve25119 keypair. The public key is used as an identifier for the client.
 * The hash of the connection password is used to establish the P2P connection.
 * There can be multiple types of links (trusted vs untrusted) differentiated by `RadixConnectPurpose`.
 * Here are the [CAP-36][doc] requirements.
 *
 * [doc]: https://radixdlt.atlassian.net/wiki/spaces/AT/pages/3251863610/CAP-36+WebRTC+Clients+Protocol
 */
public struct P2pLink {
    /**
     * The most important property of this struct, the `RadixConnectPassword`,
     * is used to be able to re-establish the P2P connection
     */
    public var connectionPassword: RadixConnectPassword
    /**
     * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
     * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
     * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
     */
    public var connectionPurpose: RadixConnectPurpose
    /**
     * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
     * Each client keeps a record of linked clients' public keys to prevent duplicate links.
     * This is the public key of the other client and it also serves as the seed for the link `ID`.
     */
    public var publicKey: Ed25519PublicKey
    /**
     * Client name, e.g. "Chrome on Macbook" or "My work Android" or "My wifes iPhone SE".
     */
    public var displayName: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The most important property of this struct, the `RadixConnectPassword`,
         * is used to be able to re-establish the P2P connection
         */ connectionPassword: RadixConnectPassword,
        /**
            * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
            * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
            * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
            */ connectionPurpose: RadixConnectPurpose,
        /**
            * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
            * Each client keeps a record of linked clients' public keys to prevent duplicate links.
            * This is the public key of the other client and it also serves as the seed for the link `ID`.
            */ publicKey: Ed25519PublicKey,
        /**
            * Client name, e.g. "Chrome on Macbook" or "My work Android" or "My wifes iPhone SE".
            */ displayName: String
    ) {
        self.connectionPassword = connectionPassword
        self.connectionPurpose = connectionPurpose
        self.publicKey = publicKey
        self.displayName = displayName
    }
}

extension P2pLink: Sendable {}
extension P2pLink: Equatable, Hashable {
    public static func == (lhs: P2pLink, rhs: P2pLink) -> Bool {
        if lhs.connectionPassword != rhs.connectionPassword {
            return false
        }
        if lhs.connectionPurpose != rhs.connectionPurpose {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(connectionPassword)
        hasher.combine(connectionPurpose)
        hasher.combine(publicKey)
        hasher.combine(displayName)
    }
}

public struct FfiConverterTypeP2PLink: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> P2pLink {
        return
            try P2pLink(
                connectionPassword: FfiConverterTypeRadixConnectPassword.read(from: &buf),
                connectionPurpose: FfiConverterTypeRadixConnectPurpose.read(from: &buf),
                publicKey: FfiConverterTypeEd25519PublicKey.read(from: &buf),
                displayName: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: P2pLink, into buf: inout [UInt8]) {
        FfiConverterTypeRadixConnectPassword.write(value.connectionPassword, into: &buf)
        FfiConverterTypeRadixConnectPurpose.write(value.connectionPurpose, into: &buf)
        FfiConverterTypeEd25519PublicKey.write(value.publicKey, into: &buf)
        FfiConverterString.write(value.displayName, into: &buf)
    }
}

public func FfiConverterTypeP2PLink_lift(_ buf: RustBuffer) throws -> P2pLink {
    return try FfiConverterTypeP2PLink.lift(buf)
}

public func FfiConverterTypeP2PLink_lower(_ value: P2pLink) -> RustBuffer {
    return FfiConverterTypeP2PLink.lower(value)
}

/**
 * The unique address identifying a package - which is a collection of blueprints on Ledger, e.g.:
 * `"package_rdx1pkgxxxxxxxxxfaucetxxxxxxxxx000034355863xxxxxxxxxfaucet"`
 *
 * PackageAddress has [Scrypto's `EntityType`][entt] type `GlobalPackage`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalPackageAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L241C29-L241C42
 */
public struct PackageAddress {
    fileprivate let secretMagic: RetPackageAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetPackageAddress) {
        self.secretMagic = secretMagic
    }
}

extension PackageAddress: Sendable {}
extension PackageAddress: Equatable, Hashable {
    public static func == (lhs: PackageAddress, rhs: PackageAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypePackageAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PackageAddress {
        return
            try PackageAddress(
                secretMagic: FfiConverterTypeRetPackageAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PackageAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetPackageAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypePackageAddress_lift(_ buf: RustBuffer) throws -> PackageAddress {
    return try FfiConverterTypePackageAddress.lift(buf)
}

public func FfiConverterTypePackageAddress_lower(_ value: PackageAddress) -> RustBuffer {
    return FfiConverterTypePackageAddress.lower(value)
}

public struct PerAssetFungibleResource {
    public var resourceAddress: ResourceAddress
    public var divisibility: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: ResourceAddress, divisibility: UInt8?) {
        self.resourceAddress = resourceAddress
        self.divisibility = divisibility
    }
}

extension PerAssetFungibleResource: Sendable {}
extension PerAssetFungibleResource: Equatable, Hashable {
    public static func == (lhs: PerAssetFungibleResource, rhs: PerAssetFungibleResource) -> Bool {
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.divisibility != rhs.divisibility {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resourceAddress)
        hasher.combine(divisibility)
    }
}

public struct FfiConverterTypePerAssetFungibleResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetFungibleResource {
        return
            try PerAssetFungibleResource(
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                divisibility: FfiConverterOptionUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetFungibleResource, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterOptionUInt8.write(value.divisibility, into: &buf)
    }
}

public func FfiConverterTypePerAssetFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetFungibleResource {
    return try FfiConverterTypePerAssetFungibleResource.lift(buf)
}

public func FfiConverterTypePerAssetFungibleResource_lower(_ value: PerAssetFungibleResource) -> RustBuffer {
    return FfiConverterTypePerAssetFungibleResource.lower(value)
}

/**
 * A fungible transfer to `recipient`, with a specified amount of tokens to send.
 */
public struct PerAssetFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * Amount
     */
    public var amount: Decimal192
    /**
     * The account or account address to send the tokens to.
     */
    public var recipient: AccountOrAddressOf

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */ useTryDepositOrAbort: Bool,
        /**
            * Amount
            */ amount: Decimal192,
        /**
            * The account or account address to send the tokens to.
            */ recipient: AccountOrAddressOf
    ) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.amount = amount
        self.recipient = recipient
    }
}

extension PerAssetFungibleTransfer: Sendable {}
extension PerAssetFungibleTransfer: Equatable, Hashable {
    public static func == (lhs: PerAssetFungibleTransfer, rhs: PerAssetFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.recipient != rhs.recipient {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(amount)
        hasher.combine(recipient)
    }
}

public struct FfiConverterTypePerAssetFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetFungibleTransfer {
        return
            try PerAssetFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
                amount: FfiConverterTypeDecimal192.read(from: &buf),
                recipient: FfiConverterTypeAccountOrAddressOf.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterTypeAccountOrAddressOf.write(value.recipient, into: &buf)
    }
}

public func FfiConverterTypePerAssetFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerAssetFungibleTransfer {
    return try FfiConverterTypePerAssetFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerAssetFungibleTransfer_lower(_ value: PerAssetFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerAssetFungibleTransfer.lower(value)
}

/**
 * A non fungible transfer to `recipient`, with specified Local IDs to send.
 */
public struct PerAssetNonFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * Amount
     */
    public var nonFungibleLocalIds: [NonFungibleLocalId]
    /**
     * The account or account address to send the tokens to.
     */
    public var recipient: AccountOrAddressOf

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */ useTryDepositOrAbort: Bool,
        /**
            * Amount
            */ nonFungibleLocalIds: [NonFungibleLocalId],
        /**
            * The account or account address to send the tokens to.
            */ recipient: AccountOrAddressOf
    ) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.nonFungibleLocalIds = nonFungibleLocalIds
        self.recipient = recipient
    }
}

extension PerAssetNonFungibleTransfer: Sendable {}
extension PerAssetNonFungibleTransfer: Equatable, Hashable {
    public static func == (lhs: PerAssetNonFungibleTransfer, rhs: PerAssetNonFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.nonFungibleLocalIds != rhs.nonFungibleLocalIds {
            return false
        }
        if lhs.recipient != rhs.recipient {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(nonFungibleLocalIds)
        hasher.combine(recipient)
    }
}

public struct FfiConverterTypePerAssetNonFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetNonFungibleTransfer {
        return
            try PerAssetNonFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
                nonFungibleLocalIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                recipient: FfiConverterTypeAccountOrAddressOf.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetNonFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.nonFungibleLocalIds, into: &buf)
        FfiConverterTypeAccountOrAddressOf.write(value.recipient, into: &buf)
    }
}

public func FfiConverterTypePerAssetNonFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerAssetNonFungibleTransfer {
    return try FfiConverterTypePerAssetNonFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerAssetNonFungibleTransfer_lower(_ value: PerAssetNonFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerAssetNonFungibleTransfer.lower(value)
}

public struct PerAssetTransfers {
    public var fromAccount: AccountAddress
    public var fungibleResources: [PerAssetTransfersOfFungibleResource]
    public var nonFungibleResources: [PerAssetTransfersOfNonFungibleResource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fromAccount: AccountAddress, fungibleResources: [PerAssetTransfersOfFungibleResource], nonFungibleResources: [PerAssetTransfersOfNonFungibleResource]) {
        self.fromAccount = fromAccount
        self.fungibleResources = fungibleResources
        self.nonFungibleResources = nonFungibleResources
    }
}

extension PerAssetTransfers: Sendable {}
extension PerAssetTransfers: Equatable, Hashable {
    public static func == (lhs: PerAssetTransfers, rhs: PerAssetTransfers) -> Bool {
        if lhs.fromAccount != rhs.fromAccount {
            return false
        }
        if lhs.fungibleResources != rhs.fungibleResources {
            return false
        }
        if lhs.nonFungibleResources != rhs.nonFungibleResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fromAccount)
        hasher.combine(fungibleResources)
        hasher.combine(nonFungibleResources)
    }
}

public struct FfiConverterTypePerAssetTransfers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfers {
        return
            try PerAssetTransfers(
                fromAccount: FfiConverterTypeAccountAddress.read(from: &buf),
                fungibleResources: FfiConverterSequenceTypePerAssetTransfersOfFungibleResource.read(from: &buf),
                nonFungibleResources: FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetTransfers, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.fromAccount, into: &buf)
        FfiConverterSequenceTypePerAssetTransfersOfFungibleResource.write(value.fungibleResources, into: &buf)
        FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource.write(value.nonFungibleResources, into: &buf)
    }
}

public func FfiConverterTypePerAssetTransfers_lift(_ buf: RustBuffer) throws -> PerAssetTransfers {
    return try FfiConverterTypePerAssetTransfers.lift(buf)
}

public func FfiConverterTypePerAssetTransfers_lower(_ value: PerAssetTransfers) -> RustBuffer {
    return FfiConverterTypePerAssetTransfers.lower(value)
}

public struct PerAssetTransfersOfFungibleResource {
    public var resource: PerAssetFungibleResource
    public var transfers: [PerAssetFungibleTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resource: PerAssetFungibleResource, transfers: [PerAssetFungibleTransfer]) {
        self.resource = resource
        self.transfers = transfers
    }
}

extension PerAssetTransfersOfFungibleResource: Sendable {}
extension PerAssetTransfersOfFungibleResource: Equatable, Hashable {
    public static func == (lhs: PerAssetTransfersOfFungibleResource, rhs: PerAssetTransfersOfFungibleResource) -> Bool {
        if lhs.resource != rhs.resource {
            return false
        }
        if lhs.transfers != rhs.transfers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resource)
        hasher.combine(transfers)
    }
}

public struct FfiConverterTypePerAssetTransfersOfFungibleResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfersOfFungibleResource {
        return
            try PerAssetTransfersOfFungibleResource(
                resource: FfiConverterTypePerAssetFungibleResource.read(from: &buf),
                transfers: FfiConverterSequenceTypePerAssetFungibleTransfer.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetTransfersOfFungibleResource, into buf: inout [UInt8]) {
        FfiConverterTypePerAssetFungibleResource.write(value.resource, into: &buf)
        FfiConverterSequenceTypePerAssetFungibleTransfer.write(value.transfers, into: &buf)
    }
}

public func FfiConverterTypePerAssetTransfersOfFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetTransfersOfFungibleResource {
    return try FfiConverterTypePerAssetTransfersOfFungibleResource.lift(buf)
}

public func FfiConverterTypePerAssetTransfersOfFungibleResource_lower(_ value: PerAssetTransfersOfFungibleResource) -> RustBuffer {
    return FfiConverterTypePerAssetTransfersOfFungibleResource.lower(value)
}

public struct PerAssetTransfersOfNonFungibleResource {
    public var resource: ResourceAddress
    public var transfers: [PerAssetNonFungibleTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resource: ResourceAddress, transfers: [PerAssetNonFungibleTransfer]) {
        self.resource = resource
        self.transfers = transfers
    }
}

extension PerAssetTransfersOfNonFungibleResource: Sendable {}
extension PerAssetTransfersOfNonFungibleResource: Equatable, Hashable {
    public static func == (lhs: PerAssetTransfersOfNonFungibleResource, rhs: PerAssetTransfersOfNonFungibleResource) -> Bool {
        if lhs.resource != rhs.resource {
            return false
        }
        if lhs.transfers != rhs.transfers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resource)
        hasher.combine(transfers)
    }
}

public struct FfiConverterTypePerAssetTransfersOfNonFungibleResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfersOfNonFungibleResource {
        return
            try PerAssetTransfersOfNonFungibleResource(
                resource: FfiConverterTypeResourceAddress.read(from: &buf),
                transfers: FfiConverterSequenceTypePerAssetNonFungibleTransfer.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetTransfersOfNonFungibleResource, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resource, into: &buf)
        FfiConverterSequenceTypePerAssetNonFungibleTransfer.write(value.transfers, into: &buf)
    }
}

public func FfiConverterTypePerAssetTransfersOfNonFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetTransfersOfNonFungibleResource {
    return try FfiConverterTypePerAssetTransfersOfNonFungibleResource.lift(buf)
}

public func FfiConverterTypePerAssetTransfersOfNonFungibleResource_lower(_ value: PerAssetTransfersOfNonFungibleResource) -> RustBuffer {
    return FfiConverterTypePerAssetTransfersOfNonFungibleResource.lower(value)
}

public struct PerRecipientAssetTransfer {
    public var recipient: AccountOrAddressOf
    public var fungibles: [PerRecipientFungibleTransfer]
    public var nonFungibles: [PerRecipientNonFungiblesTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(recipient: AccountOrAddressOf, fungibles: [PerRecipientFungibleTransfer], nonFungibles: [PerRecipientNonFungiblesTransfer]) {
        self.recipient = recipient
        self.fungibles = fungibles
        self.nonFungibles = nonFungibles
    }
}

extension PerRecipientAssetTransfer: Sendable {}
extension PerRecipientAssetTransfer: Equatable, Hashable {
    public static func == (lhs: PerRecipientAssetTransfer, rhs: PerRecipientAssetTransfer) -> Bool {
        if lhs.recipient != rhs.recipient {
            return false
        }
        if lhs.fungibles != rhs.fungibles {
            return false
        }
        if lhs.nonFungibles != rhs.nonFungibles {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(recipient)
        hasher.combine(fungibles)
        hasher.combine(nonFungibles)
    }
}

public struct FfiConverterTypePerRecipientAssetTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientAssetTransfer {
        return
            try PerRecipientAssetTransfer(
                recipient: FfiConverterTypeAccountOrAddressOf.read(from: &buf),
                fungibles: FfiConverterSequenceTypePerRecipientFungibleTransfer.read(from: &buf),
                nonFungibles: FfiConverterSequenceTypePerRecipientNonFungiblesTransfer.read(from: &buf)
            )
    }

    public static func write(_ value: PerRecipientAssetTransfer, into buf: inout [UInt8]) {
        FfiConverterTypeAccountOrAddressOf.write(value.recipient, into: &buf)
        FfiConverterSequenceTypePerRecipientFungibleTransfer.write(value.fungibles, into: &buf)
        FfiConverterSequenceTypePerRecipientNonFungiblesTransfer.write(value.nonFungibles, into: &buf)
    }
}

public func FfiConverterTypePerRecipientAssetTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientAssetTransfer {
    return try FfiConverterTypePerRecipientAssetTransfer.lift(buf)
}

public func FfiConverterTypePerRecipientAssetTransfer_lower(_ value: PerRecipientAssetTransfer) -> RustBuffer {
    return FfiConverterTypePerRecipientAssetTransfer.lower(value)
}

public struct PerRecipientAssetTransfers {
    public var addressOfSender: AccountAddress
    public var transfers: [PerRecipientAssetTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addressOfSender: AccountAddress, transfers: [PerRecipientAssetTransfer]) {
        self.addressOfSender = addressOfSender
        self.transfers = transfers
    }
}

extension PerRecipientAssetTransfers: Sendable {}
extension PerRecipientAssetTransfers: Equatable, Hashable {
    public static func == (lhs: PerRecipientAssetTransfers, rhs: PerRecipientAssetTransfers) -> Bool {
        if lhs.addressOfSender != rhs.addressOfSender {
            return false
        }
        if lhs.transfers != rhs.transfers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addressOfSender)
        hasher.combine(transfers)
    }
}

public struct FfiConverterTypePerRecipientAssetTransfers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientAssetTransfers {
        return
            try PerRecipientAssetTransfers(
                addressOfSender: FfiConverterTypeAccountAddress.read(from: &buf),
                transfers: FfiConverterSequenceTypePerRecipientAssetTransfer.read(from: &buf)
            )
    }

    public static func write(_ value: PerRecipientAssetTransfers, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.addressOfSender, into: &buf)
        FfiConverterSequenceTypePerRecipientAssetTransfer.write(value.transfers, into: &buf)
    }
}

public func FfiConverterTypePerRecipientAssetTransfers_lift(_ buf: RustBuffer) throws -> PerRecipientAssetTransfers {
    return try FfiConverterTypePerRecipientAssetTransfers.lift(buf)
}

public func FfiConverterTypePerRecipientAssetTransfers_lower(_ value: PerRecipientAssetTransfers) -> RustBuffer {
    return FfiConverterTypePerRecipientAssetTransfers.lower(value)
}

/**
 * A fungible transfer of `resource_address` token, with a specified amount
 * of tokens and divisibility.
 */
public struct PerRecipientFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * Amount
     */
    public var amount: Decimal192
    public var divisibility: UInt8?
    /**
     * The address of the resource being sent
     */
    public var resourceAddress: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */ useTryDepositOrAbort: Bool,
        /**
            * Amount
            */ amount: Decimal192, divisibility: UInt8?,
        /**
            * The address of the resource being sent
            */ resourceAddress: ResourceAddress
    ) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.amount = amount
        self.divisibility = divisibility
        self.resourceAddress = resourceAddress
    }
}

extension PerRecipientFungibleTransfer: Sendable {}
extension PerRecipientFungibleTransfer: Equatable, Hashable {
    public static func == (lhs: PerRecipientFungibleTransfer, rhs: PerRecipientFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.divisibility != rhs.divisibility {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(amount)
        hasher.combine(divisibility)
        hasher.combine(resourceAddress)
    }
}

public struct FfiConverterTypePerRecipientFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientFungibleTransfer {
        return
            try PerRecipientFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
                amount: FfiConverterTypeDecimal192.read(from: &buf),
                divisibility: FfiConverterOptionUInt8.read(from: &buf),
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PerRecipientFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterOptionUInt8.write(value.divisibility, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
    }
}

public func FfiConverterTypePerRecipientFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientFungibleTransfer {
    return try FfiConverterTypePerRecipientFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerRecipientFungibleTransfer_lower(_ value: PerRecipientFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerRecipientFungibleTransfer.lower(value)
}

/**
 * A non fungible transfer of `resource_address` token, with specified Local IDs to send.
 */
public struct PerRecipientNonFungiblesTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * The local IDS of the NonFungible tokens being sent
     */
    public var localIds: [NonFungibleLocalId]
    /**
     * The address of the resource being sent
     */
    public var resourceAddress: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */ useTryDepositOrAbort: Bool,
        /**
            * The local IDS of the NonFungible tokens being sent
            */ localIds: [NonFungibleLocalId],
        /**
            * The address of the resource being sent
            */ resourceAddress: ResourceAddress
    ) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.localIds = localIds
        self.resourceAddress = resourceAddress
    }
}

extension PerRecipientNonFungiblesTransfer: Sendable {}
extension PerRecipientNonFungiblesTransfer: Equatable, Hashable {
    public static func == (lhs: PerRecipientNonFungiblesTransfer, rhs: PerRecipientNonFungiblesTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.localIds != rhs.localIds {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(localIds)
        hasher.combine(resourceAddress)
    }
}

public struct FfiConverterTypePerRecipientNonFungiblesTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientNonFungiblesTransfer {
        return
            try PerRecipientNonFungiblesTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
                localIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PerRecipientNonFungiblesTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.localIds, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
    }
}

public func FfiConverterTypePerRecipientNonFungiblesTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientNonFungiblesTransfer {
    return try FfiConverterTypePerRecipientNonFungiblesTransfer.lift(buf)
}

public func FfiConverterTypePerRecipientNonFungiblesTransfer_lower(_ value: PerRecipientNonFungiblesTransfer) -> RustBuffer {
    return FfiConverterTypePerRecipientNonFungiblesTransfer.lower(value)
}

/**
 * A Persona is an identity a user chooses to login to a dApp with, using
 * RadixConnect - Radix decentralized login solution. A persona is very
 * similar to [`Account`]s, in the sense that they are On-Network/On-Ledger
 * components, with a unique network dependent address ([`IdentityAddress`])
 * and with a security state (see [`EntitySecurityState`]) knowing which
 * factor instances that control this component, but with one important
 * difference: a Persona cannot hold funds. It is impossible to transfer
 * any asset to a Persona. The On-Network component representation of
 * the Persona is called `Identity`. The concept "Persona" is a Radix
 * Wallet (Profile) *application* of an Identity.
 *
 * Personas have data (see [`PersonaData`]), which is personal information
 * a user has associated with a this Persona, of different kinds, such as name,
 * email address(es) or phone number(s). The `PersonaData` is **never** uploaded
 * to the Radix Network, i.e. it is a pure Radix Wallet (Profile) construct,
 * On-Network Identities does not know of PersonaData, and never will (well
 * technically, nothing stops a user from building their own wallet and uploading
 * personal information to the metadata of the Identity component... but `Sargon`
 * never will, nor will the Radix Wallet.).
 */
public struct Persona {
    /**
     * The ID of the network this account can be used with.
     */
    public var networkId: NetworkId
    /**
     * The address of an identity, used by Personas, a bech32 encoding of a public key hash
     * that starts with the prefix `"identity_"`, dependent on NetworkID, meaning the same
     * public key used for two IdentityAddresses on two different networks will not have
     * the same address.
     */
    public var address: IdentityAddress
    /**
     * An off-ledger display name or description chosen by the user when they
     * created this persona.
     */
    public var displayName: DisplayName
    /**
     * Describes the state this Persona is in, in regards to how
     * the user controls it, i.e. if it is controlled by a single factor (private key)
     * or an `AccessController` with a potential Multi-Factor setup.
     */
    public var securityState: EntitySecurityState
    /**
     * An order set of `EntityFlag`s used to describe certain Off-ledger
     * user state about this Persona, e.g. if it is marked as hidden or not.
     */
    public var flags: [EntityFlag]
    /**
     * Personal information a user has associated with a certain Persona, of different kinds, such as name,
     * email address(es) or phone number(s). This information is only ever stored in Profile and is never
     * uploaded to the Radix Network.
     */
    public var personaData: PersonaData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network this account can be used with.
         */ networkId: NetworkId,
        /**
            * The address of an identity, used by Personas, a bech32 encoding of a public key hash
            * that starts with the prefix `"identity_"`, dependent on NetworkID, meaning the same
            * public key used for two IdentityAddresses on two different networks will not have
            * the same address.
            */ address: IdentityAddress,
        /**
            * An off-ledger display name or description chosen by the user when they
            * created this persona.
            */ displayName: DisplayName,
        /**
            * Describes the state this Persona is in, in regards to how
            * the user controls it, i.e. if it is controlled by a single factor (private key)
            * or an `AccessController` with a potential Multi-Factor setup.
            */ securityState: EntitySecurityState,
        /**
            * An order set of `EntityFlag`s used to describe certain Off-ledger
            * user state about this Persona, e.g. if it is marked as hidden or not.
            */ flags: [EntityFlag],
        /**
            * Personal information a user has associated with a certain Persona, of different kinds, such as name,
            * email address(es) or phone number(s). This information is only ever stored in Profile and is never
            * uploaded to the Radix Network.
            */ personaData: PersonaData
    ) {
        self.networkId = networkId
        self.address = address
        self.displayName = displayName
        self.securityState = securityState
        self.flags = flags
        self.personaData = personaData
    }
}

extension Persona: Sendable {}
extension Persona: Equatable, Hashable {
    public static func == (lhs: Persona, rhs: Persona) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.securityState != rhs.securityState {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        if lhs.personaData != rhs.personaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(securityState)
        hasher.combine(flags)
        hasher.combine(personaData)
    }
}

public struct FfiConverterTypePersona: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Persona {
        return
            try Persona(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                address: FfiConverterTypeIdentityAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                securityState: FfiConverterTypeEntitySecurityState.read(from: &buf),
                flags: FfiConverterSequenceTypeEntityFlag.read(from: &buf),
                personaData: FfiConverterTypePersonaData.read(from: &buf)
            )
    }

    public static func write(_ value: Persona, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeIdentityAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeEntitySecurityState.write(value.securityState, into: &buf)
        FfiConverterSequenceTypeEntityFlag.write(value.flags, into: &buf)
        FfiConverterTypePersonaData.write(value.personaData, into: &buf)
    }
}

public func FfiConverterTypePersona_lift(_ buf: RustBuffer) throws -> Persona {
    return try FfiConverterTypePersona.lift(buf)
}

public func FfiConverterTypePersona_lower(_ value: Persona) -> RustBuffer {
    return FfiConverterTypePersona.lower(value)
}

/**
 * Personal information a user has associated with a certain Persona, of different kinds, such as name,
 * email address(es) or phone number(s). This information is only ever stored in Profile and is never
 * uploaded to the Radix Network.
 *
 * These entries of different kinds can be queried for in a request sent by a dApp, e.g.
 * Radix Dashboard might ask "Give me ongoing access to Name and 2 Email addresses for
 * a Persona" (just a silly example, Radix Dashboard would never ask for that and why 2 email addresses?).
 *
 * The Profile will then use the fact that each Persona Data Entry has a stable ID so that Profile can
 * refer the entry just by the ID, and Profile can thus record which Persona Data Entry a user has selected
 * to share with the dApp, without duplicating the value of that entry (just like how we use FactorSourceIDs).
 * Since a dApp can ask for *ongoing* access next time the user interacts with the same dApp, if user has
 * not revoked the dApps access, the wallet clients will automatically send back the Persona Data Entry values
 * even if they have been updated - the value might have changed but their IDs have not. Thus if a user
 * deletes a Persona Data Entry (e.g. a phone number), and later re-inputs the same phone number, even
 * it the exact same value is used, it will still be treated as a new entry since its ID is new, meaning
 * that the next time the user interacts with a previously authorized dApp the wallet cannot automatically
 * respond back to dApp with the PersonaData, but user will have to re-authorize the request for ongoing
 * access for the requested PersonaData entries.
 */
public struct PersonaData {
    /**
     * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
     * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
     *
     * Note that the type is Option of `PersonaDataIdentifiedName` and not of type [`PersonaDataEntryName`][name],
     * `PersonaDataIdentifiedName` is essentially a tuple of `(Uuid, PersonaDataEntryName)`.
     *
     * [name]: PersonaDataEntryName
     */
    public var name: PersonaDataIdentifiedName?
    /**
     * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
     * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
     * contain elements with the same value, but under different IDs.
     */
    public var phoneNumbers: CollectionOfPhoneNumbers
    /**
     * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
     * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
     * contain elements with the same value, but under different IDs.
     */
    public var emailAddresses: CollectionOfEmailAddresses

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
         * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
         *
         * Note that the type is Option of `PersonaDataIdentifiedName` and not of type [`PersonaDataEntryName`][name],
         * `PersonaDataIdentifiedName` is essentially a tuple of `(Uuid, PersonaDataEntryName)`.
         *
         * [name]: PersonaDataEntryName
         */ name: PersonaDataIdentifiedName?,
        /**
            * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
            * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
            * contain elements with the same value, but under different IDs.
            */ phoneNumbers: CollectionOfPhoneNumbers,
        /**
            * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
            * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
            * contain elements with the same value, but under different IDs.
            */ emailAddresses: CollectionOfEmailAddresses
    ) {
        self.name = name
        self.phoneNumbers = phoneNumbers
        self.emailAddresses = emailAddresses
    }
}

extension PersonaData: Sendable {}
extension PersonaData: Equatable, Hashable {
    public static func == (lhs: PersonaData, rhs: PersonaData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(phoneNumbers)
        hasher.combine(emailAddresses)
    }
}

public struct FfiConverterTypePersonaData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaData {
        return
            try PersonaData(
                name: FfiConverterOptionTypePersonaDataIdentifiedName.read(from: &buf),
                phoneNumbers: FfiConverterTypeCollectionOfPhoneNumbers.read(from: &buf),
                emailAddresses: FfiConverterTypeCollectionOfEmailAddresses.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaData, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataIdentifiedName.write(value.name, into: &buf)
        FfiConverterTypeCollectionOfPhoneNumbers.write(value.phoneNumbers, into: &buf)
        FfiConverterTypeCollectionOfEmailAddresses.write(value.emailAddresses, into: &buf)
    }
}

public func FfiConverterTypePersonaData_lift(_ buf: RustBuffer) throws -> PersonaData {
    return try FfiConverterTypePersonaData.lift(buf)
}

public func FfiConverterTypePersonaData_lower(_ value: PersonaData) -> RustBuffer {
    return FfiConverterTypePersonaData.lower(value)
}

/**
 * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
 * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
 *
 * Nickname is optional in the sense that it can be left blank. Family name and given names are never empty.
 *
 * If a name has multiple given names, they all go into the `given_names` String, e.g. Pippi Longstocking's real name -
 * her Swedish name - is in full: "Pippilotta Viktualia Rullgardina Krusmynta Efraimsdotter Lngstrump", where her
 * given names: "Pippilotta Viktualia Rullgardina Krusmynta Efraimsdotter" are put in the `given_names` field, and
 * "Lngstrump" (Longstocking) is her family name.
 */
public struct PersonaDataEntryName {
    public var variant: PersonaDataNameVariant
    public var familyName: String
    public var givenNames: String
    public var nickname: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(variant: PersonaDataNameVariant, familyName: String, givenNames: String, nickname: String) {
        self.variant = variant
        self.familyName = familyName
        self.givenNames = givenNames
        self.nickname = nickname
    }
}

extension PersonaDataEntryName: Sendable {}
extension PersonaDataEntryName: Equatable, Hashable {
    public static func == (lhs: PersonaDataEntryName, rhs: PersonaDataEntryName) -> Bool {
        if lhs.variant != rhs.variant {
            return false
        }
        if lhs.familyName != rhs.familyName {
            return false
        }
        if lhs.givenNames != rhs.givenNames {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(variant)
        hasher.combine(familyName)
        hasher.combine(givenNames)
        hasher.combine(nickname)
    }
}

public struct FfiConverterTypePersonaDataEntryName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryName {
        return
            try PersonaDataEntryName(
                variant: FfiConverterTypePersonaDataNameVariant.read(from: &buf),
                familyName: FfiConverterString.read(from: &buf),
                givenNames: FfiConverterString.read(from: &buf),
                nickname: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataEntryName, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataNameVariant.write(value.variant, into: &buf)
        FfiConverterString.write(value.familyName, into: &buf)
        FfiConverterString.write(value.givenNames, into: &buf)
        FfiConverterString.write(value.nickname, into: &buf)
    }
}

public func FfiConverterTypePersonaDataEntryName_lift(_ buf: RustBuffer) throws -> PersonaDataEntryName {
    return try FfiConverterTypePersonaDataEntryName.lift(buf)
}

public func FfiConverterTypePersonaDataEntryName_lower(_ value: PersonaDataEntryName) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryName.lower(value)
}

/**
 * A persons telephone number they have chosen to associated with a Persona, e.g.
 * `+46 987 654 321` (don't try calling this number, it does not exist).
 *
 * Current implementation does not validate the phone number other than it
 * cannot be empty, since telephone number validation is tricky.
 */
public struct PersonaDataEntryPhoneNumber {
    public var number: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(number: String) {
        self.number = number
    }
}

extension PersonaDataEntryPhoneNumber: Sendable {}
extension PersonaDataEntryPhoneNumber: Equatable, Hashable {
    public static func == (lhs: PersonaDataEntryPhoneNumber, rhs: PersonaDataEntryPhoneNumber) -> Bool {
        if lhs.number != rhs.number {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(number)
    }
}

public struct FfiConverterTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryPhoneNumber {
        return
            try PersonaDataEntryPhoneNumber(
                number: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataEntryPhoneNumber, into buf: inout [UInt8]) {
        FfiConverterString.write(value.number, into: &buf)
    }
}

public func FfiConverterTypePersonaDataEntryPhoneNumber_lift(_ buf: RustBuffer) throws -> PersonaDataEntryPhoneNumber {
    return try FfiConverterTypePersonaDataEntryPhoneNumber.lift(buf)
}

public func FfiConverterTypePersonaDataEntryPhoneNumber_lower(_ value: PersonaDataEntryPhoneNumber) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryPhoneNumber.lower(value)
}

/**
 * An identifiable Persona email address. Essentially it is a tuple of a
 * [`(PersonaDataEntryEmailAddress, Uuid)`].
 */
public struct PersonaDataIdentifiedEmailAddress {
    public var id: PersonaDataEntryId
    public var value: EmailAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PersonaDataEntryId, value: EmailAddress) {
        self.id = id
        self.value = value
    }
}

extension PersonaDataIdentifiedEmailAddress: Sendable {}
extension PersonaDataIdentifiedEmailAddress: Equatable, Hashable {
    public static func == (lhs: PersonaDataIdentifiedEmailAddress, rhs: PersonaDataIdentifiedEmailAddress) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}

public struct FfiConverterTypePersonaDataIdentifiedEmailAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedEmailAddress {
        return
            try PersonaDataIdentifiedEmailAddress(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
                value: FfiConverterTypeEmailAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataIdentifiedEmailAddress, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypeEmailAddress.write(value.value, into: &buf)
    }
}

public func FfiConverterTypePersonaDataIdentifiedEmailAddress_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedEmailAddress {
    return try FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedEmailAddress_lower(_ value: PersonaDataIdentifiedEmailAddress) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedEmailAddress.lower(value)
}

/**
 * An identifiable Persona name. Essentially it is a tuple of a
 * [`(PersonaDataEntryName, Uuid)`].
 */
public struct PersonaDataIdentifiedName {
    public var id: PersonaDataEntryId
    public var value: PersonaDataEntryName

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PersonaDataEntryId, value: PersonaDataEntryName) {
        self.id = id
        self.value = value
    }
}

extension PersonaDataIdentifiedName: Sendable {}
extension PersonaDataIdentifiedName: Equatable, Hashable {
    public static func == (lhs: PersonaDataIdentifiedName, rhs: PersonaDataIdentifiedName) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}

public struct FfiConverterTypePersonaDataIdentifiedName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedName {
        return
            try PersonaDataIdentifiedName(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
                value: FfiConverterTypePersonaDataEntryName.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataIdentifiedName, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypePersonaDataEntryName.write(value.value, into: &buf)
    }
}

public func FfiConverterTypePersonaDataIdentifiedName_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedName {
    return try FfiConverterTypePersonaDataIdentifiedName.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedName_lower(_ value: PersonaDataIdentifiedName) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedName.lower(value)
}

/**
 * An identifiable Persona phone number. Essentially it is a tuple of a
 * [`(PersonaDataEntryPhoneNumber, Uuid)`].
 */
public struct PersonaDataIdentifiedPhoneNumber {
    public var id: PersonaDataEntryId
    public var value: PersonaDataEntryPhoneNumber

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PersonaDataEntryId, value: PersonaDataEntryPhoneNumber) {
        self.id = id
        self.value = value
    }
}

extension PersonaDataIdentifiedPhoneNumber: Sendable {}
extension PersonaDataIdentifiedPhoneNumber: Equatable, Hashable {
    public static func == (lhs: PersonaDataIdentifiedPhoneNumber, rhs: PersonaDataIdentifiedPhoneNumber) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}

public struct FfiConverterTypePersonaDataIdentifiedPhoneNumber: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedPhoneNumber {
        return
            try PersonaDataIdentifiedPhoneNumber(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
                value: FfiConverterTypePersonaDataEntryPhoneNumber.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataIdentifiedPhoneNumber, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypePersonaDataEntryPhoneNumber.write(value.value, into: &buf)
    }
}

public func FfiConverterTypePersonaDataIdentifiedPhoneNumber_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedPhoneNumber {
    return try FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedPhoneNumber_lower(_ value: PersonaDataIdentifiedPhoneNumber) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedPhoneNumber.lower(value)
}

public struct PlaintextMessage {
    public var mimeType: String
    public var message: MessageContents

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mimeType: String, message: MessageContents) {
        self.mimeType = mimeType
        self.message = message
    }
}

extension PlaintextMessage: Sendable {}
extension PlaintextMessage: Equatable, Hashable {
    public static func == (lhs: PlaintextMessage, rhs: PlaintextMessage) -> Bool {
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mimeType)
        hasher.combine(message)
    }
}

public struct FfiConverterTypePlaintextMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlaintextMessage {
        return
            try PlaintextMessage(
                mimeType: FfiConverterString.read(from: &buf),
                message: FfiConverterTypeMessageContents.read(from: &buf)
            )
    }

    public static func write(_ value: PlaintextMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mimeType, into: &buf)
        FfiConverterTypeMessageContents.write(value.message, into: &buf)
    }
}

public func FfiConverterTypePlaintextMessage_lift(_ buf: RustBuffer) throws -> PlaintextMessage {
    return try FfiConverterTypePlaintextMessage.lift(buf)
}

public func FfiConverterTypePlaintextMessage_lower(_ value: PlaintextMessage) -> RustBuffer {
    return FfiConverterTypePlaintextMessage.lower(value)
}

/**
 * Addresses identifying an OnLedger (OnNetwork) Liquidity Pool (LP) of tokens that users can contribute
 * Liquidity too, e.g.:
 * `"pool_rdx1c325zs6dz3un8ykkjavy9fkvvyzarkaehgsl408qup6f95aup3le3w"`
 *
 * Typically users contribute to Liquidity Pools by using a Dapp and the Radix Wallet.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of PoolAddresses:
 * * GlobalOneResourcePool
 * * GlobalTwoResourcePool
 * * GlobalMultiResourcePool
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalPoolAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L256-L261
 */
public struct PoolAddress {
    fileprivate let secretMagic: RetPoolAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetPoolAddress) {
        self.secretMagic = secretMagic
    }
}

extension PoolAddress: Sendable {}
extension PoolAddress: Equatable, Hashable {
    public static func == (lhs: PoolAddress, rhs: PoolAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypePoolAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PoolAddress {
        return
            try PoolAddress(
                secretMagic: FfiConverterTypeRetPoolAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PoolAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetPoolAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypePoolAddress_lift(_ buf: RustBuffer) throws -> PoolAddress {
    return try FfiConverterTypePoolAddress.lift(buf)
}

public func FfiConverterTypePoolAddress_lower(_ value: PoolAddress) -> RustBuffer {
    return FfiConverterTypePoolAddress.lower(value)
}

/**
 * A PredictedDecimal is not a guaranteed amount, but a approximated based
 * on the contents of the transaction manifest and the state of the ledger
 * at the time of analysis (preview).
 */
public struct PredictedDecimal {
    public var value: Decimal192
    public var instructionIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Decimal192, instructionIndex: UInt64) {
        self.value = value
        self.instructionIndex = instructionIndex
    }
}

extension PredictedDecimal: Sendable {}
extension PredictedDecimal: Equatable, Hashable {
    public static func == (lhs: PredictedDecimal, rhs: PredictedDecimal) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(instructionIndex)
    }
}

public struct FfiConverterTypePredictedDecimal: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredictedDecimal {
        return
            try PredictedDecimal(
                value: FfiConverterTypeDecimal192.read(from: &buf),
                instructionIndex: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: PredictedDecimal, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
    }
}

public func FfiConverterTypePredictedDecimal_lift(_ buf: RustBuffer) throws -> PredictedDecimal {
    return try FfiConverterTypePredictedDecimal.lift(buf)
}

public func FfiConverterTypePredictedDecimal_lower(_ value: PredictedDecimal) -> RustBuffer {
    return FfiConverterTypePredictedDecimal.lower(value)
}

/**
 * A prediction of a collection of NonFungibleLocalId
 */
public struct PredictedNonFungibleLocalIds {
    public var value: [NonFungibleLocalId]
    public var instructionIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: [NonFungibleLocalId], instructionIndex: UInt64) {
        self.value = value
        self.instructionIndex = instructionIndex
    }
}

extension PredictedNonFungibleLocalIds: Sendable {}
extension PredictedNonFungibleLocalIds: Equatable, Hashable {
    public static func == (lhs: PredictedNonFungibleLocalIds, rhs: PredictedNonFungibleLocalIds) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(instructionIndex)
    }
}

public struct FfiConverterTypePredictedNonFungibleLocalIds: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredictedNonFungibleLocalIds {
        return
            try PredictedNonFungibleLocalIds(
                value: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                instructionIndex: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: PredictedNonFungibleLocalIds, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
    }
}

public func FfiConverterTypePredictedNonFungibleLocalIds_lift(_ buf: RustBuffer) throws -> PredictedNonFungibleLocalIds {
    return try FfiConverterTypePredictedNonFungibleLocalIds.lift(buf)
}

public func FfiConverterTypePredictedNonFungibleLocalIds_lower(_ value: PredictedNonFungibleLocalIds) -> RustBuffer {
    return FfiConverterTypePredictedNonFungibleLocalIds.lower(value)
}

/**
 * PrimaryRole is used for Signing Transactions.
 */
public struct PrimaryRoleWithFactorInstances {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorInstance]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorInstance],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorInstance]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension PrimaryRoleWithFactorInstances: Sendable {}
extension PrimaryRoleWithFactorInstances: Equatable, Hashable {
    public static func == (lhs: PrimaryRoleWithFactorInstances, rhs: PrimaryRoleWithFactorInstances) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypePrimaryRoleWithFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimaryRoleWithFactorInstances {
        return
            try PrimaryRoleWithFactorInstances(
                thresholdFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf)
            )
    }

    public static func write(_ value: PrimaryRoleWithFactorInstances, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorInstance.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorInstance.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypePrimaryRoleWithFactorInstances_lift(_ buf: RustBuffer) throws -> PrimaryRoleWithFactorInstances {
    return try FfiConverterTypePrimaryRoleWithFactorInstances.lift(buf)
}

public func FfiConverterTypePrimaryRoleWithFactorInstances_lower(_ value: PrimaryRoleWithFactorInstances) -> RustBuffer {
    return FfiConverterTypePrimaryRoleWithFactorInstances.lower(value)
}

/**
 * PrimaryRole is used for Signing Transactions.
 */
public struct PrimaryRoleWithFactorSourceIDs {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorSourceId]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSourceId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorSourceId],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorSourceId]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension PrimaryRoleWithFactorSourceIDs: Sendable {}
extension PrimaryRoleWithFactorSourceIDs: Equatable, Hashable {
    public static func == (lhs: PrimaryRoleWithFactorSourceIDs, rhs: PrimaryRoleWithFactorSourceIDs) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypePrimaryRoleWithFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimaryRoleWithFactorSourceIDs {
        return
            try PrimaryRoleWithFactorSourceIDs(
                thresholdFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
            )
    }

    public static func write(_ value: PrimaryRoleWithFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorSourceID.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSourceID.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypePrimaryRoleWithFactorSourceIDs_lift(_ buf: RustBuffer) throws -> PrimaryRoleWithFactorSourceIDs {
    return try FfiConverterTypePrimaryRoleWithFactorSourceIDs.lift(buf)
}

public func FfiConverterTypePrimaryRoleWithFactorSourceIDs_lower(_ value: PrimaryRoleWithFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypePrimaryRoleWithFactorSourceIDs.lower(value)
}

/**
 * PrimaryRole is used for Signing Transactions.
 */
public struct PrimaryRoleWithFactorSources {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorSource]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorSource],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorSource]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension PrimaryRoleWithFactorSources: Sendable {}
extension PrimaryRoleWithFactorSources: Equatable, Hashable {
    public static func == (lhs: PrimaryRoleWithFactorSources, rhs: PrimaryRoleWithFactorSources) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypePrimaryRoleWithFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimaryRoleWithFactorSources {
        return
            try PrimaryRoleWithFactorSources(
                thresholdFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf)
            )
    }

    public static func write(_ value: PrimaryRoleWithFactorSources, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorSource.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypePrimaryRoleWithFactorSources_lift(_ buf: RustBuffer) throws -> PrimaryRoleWithFactorSources {
    return try FfiConverterTypePrimaryRoleWithFactorSources.lift(buf)
}

public func FfiConverterTypePrimaryRoleWithFactorSources_lower(_ value: PrimaryRoleWithFactorSources) -> RustBuffer {
    return FfiConverterTypePrimaryRoleWithFactorSources.lower(value)
}

public struct PrivateHierarchicalDeterministicFactorSource {
    public var mnemonicWithPassphrase: MnemonicWithPassphrase
    public var factorSource: DeviceFactorSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonicWithPassphrase: MnemonicWithPassphrase, factorSource: DeviceFactorSource) {
        self.mnemonicWithPassphrase = mnemonicWithPassphrase
        self.factorSource = factorSource
    }
}

extension PrivateHierarchicalDeterministicFactorSource: Sendable {}
extension PrivateHierarchicalDeterministicFactorSource: Equatable, Hashable {
    public static func == (lhs: PrivateHierarchicalDeterministicFactorSource, rhs: PrivateHierarchicalDeterministicFactorSource) -> Bool {
        if lhs.mnemonicWithPassphrase != rhs.mnemonicWithPassphrase {
            return false
        }
        if lhs.factorSource != rhs.factorSource {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonicWithPassphrase)
        hasher.combine(factorSource)
    }
}

public struct FfiConverterTypePrivateHierarchicalDeterministicFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrivateHierarchicalDeterministicFactorSource {
        return
            try PrivateHierarchicalDeterministicFactorSource(
                mnemonicWithPassphrase: FfiConverterTypeMnemonicWithPassphrase.read(from: &buf),
                factorSource: FfiConverterTypeDeviceFactorSource.read(from: &buf)
            )
    }

    public static func write(_ value: PrivateHierarchicalDeterministicFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeMnemonicWithPassphrase.write(value.mnemonicWithPassphrase, into: &buf)
        FfiConverterTypeDeviceFactorSource.write(value.factorSource, into: &buf)
    }
}

public func FfiConverterTypePrivateHierarchicalDeterministicFactorSource_lift(_ buf: RustBuffer) throws -> PrivateHierarchicalDeterministicFactorSource {
    return try FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(buf)
}

public func FfiConverterTypePrivateHierarchicalDeterministicFactorSource_lower(_ value: PrivateHierarchicalDeterministicFactorSource) -> RustBuffer {
    return FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lower(value)
}

/**
 * The canonical representation of a users accounts, personas,
 * authorized dapps, security factors, settings and more.
 *
 * This large structure of values is called 'wallet backup data'
 * in user facing tests in host applications, but internally at
 * RDX Works known as "the Profile".
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert_eq!(Profile::sample(), Profile::sample())
 * ```
 */
public struct Profile {
    /**
     * The header of a Profile(Snapshot) contains crucial metadata
     * about this Profile, such as which JSON data format it is
     * compatible with and which device was used to create it and
     * a hint about its contents.
     */
    public var header: Header
    /**
     * All sources of factors, used for authorization such as spending funds, contains no
     * secrets.
     */
    public var factorSources: [FactorSource]
    /**
     * Settings for this profile in the app, contains default security configs
     * as well as display settings.
     */
    public var appPreferences: AppPreferences
    /**
     * An ordered mapping of NetworkID -> `Profile.Network`, containing
     * all the users Accounts, Personas and AuthorizedDapps the user
     * has created and interacted with on this network.
     */
    public var networks: [ProfileNetwork]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The header of a Profile(Snapshot) contains crucial metadata
         * about this Profile, such as which JSON data format it is
         * compatible with and which device was used to create it and
         * a hint about its contents.
         */ header: Header,
        /**
            * All sources of factors, used for authorization such as spending funds, contains no
            * secrets.
            */ factorSources: [FactorSource],
        /**
            * Settings for this profile in the app, contains default security configs
            * as well as display settings.
            */ appPreferences: AppPreferences,
        /**
            * An ordered mapping of NetworkID -> `Profile.Network`, containing
            * all the users Accounts, Personas and AuthorizedDapps the user
            * has created and interacted with on this network.
            */ networks: [ProfileNetwork]
    ) {
        self.header = header
        self.factorSources = factorSources
        self.appPreferences = appPreferences
        self.networks = networks
    }
}

extension Profile: Sendable {}
extension Profile: Equatable, Hashable {
    public static func == (lhs: Profile, rhs: Profile) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.factorSources != rhs.factorSources {
            return false
        }
        if lhs.appPreferences != rhs.appPreferences {
            return false
        }
        if lhs.networks != rhs.networks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(factorSources)
        hasher.combine(appPreferences)
        hasher.combine(networks)
    }
}

public struct FfiConverterTypeProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Profile {
        return
            try Profile(
                header: FfiConverterTypeHeader.read(from: &buf),
                factorSources: FfiConverterSequenceTypeFactorSource.read(from: &buf),
                appPreferences: FfiConverterTypeAppPreferences.read(from: &buf),
                networks: FfiConverterSequenceTypeProfileNetwork.read(from: &buf)
            )
    }

    public static func write(_ value: Profile, into buf: inout [UInt8]) {
        FfiConverterTypeHeader.write(value.header, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.factorSources, into: &buf)
        FfiConverterTypeAppPreferences.write(value.appPreferences, into: &buf)
        FfiConverterSequenceTypeProfileNetwork.write(value.networks, into: &buf)
    }
}

public func FfiConverterTypeProfile_lift(_ buf: RustBuffer) throws -> Profile {
    return try FfiConverterTypeProfile.lift(buf)
}

public func FfiConverterTypeProfile_lower(_ value: Profile) -> RustBuffer {
    return FfiConverterTypeProfile.lower(value)
}

/**
 * [`Accounts`], [`Personas`] and [`AuthorizedDapps`] for some [`ProfileNetwork`]
 * which user has created/interacted with, all on the same [Radix Network][`NetworkDefinition`],
 * identified by `id` ([`NetworkID`]).
 */
public struct ProfileNetwork {
    /**
     * The ID of the network that has been used to generate the `accounts` and `personas`
     * and on which the `authorizedDapps` have been deployed on.
     */
    public var id: NetworkId
    /**
     * An ordered set of [`Accounts`]` on this network, which are [`Account`]s
     * the user has created on this network.
     */
    public var accounts: [Account]
    /**
     * An ordered set of [`Personas`] on this network, which are [`Persona`]s
     * the user has created on this network.
     */
    public var personas: [Persona]
    /**
     * An ordered set of [`AuthorizedDapps`] on this network, which are
     * [`AuthorizedDapp`]s that the user has interacted with.
     */
    public var authorizedDapps: [AuthorizedDapp]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network that has been used to generate the `accounts` and `personas`
         * and on which the `authorizedDapps` have been deployed on.
         */ id: NetworkId,
        /**
            * An ordered set of [`Accounts`]` on this network, which are [`Account`]s
            * the user has created on this network.
            */ accounts: [Account],
        /**
            * An ordered set of [`Personas`] on this network, which are [`Persona`]s
            * the user has created on this network.
            */ personas: [Persona],
        /**
            * An ordered set of [`AuthorizedDapps`] on this network, which are
            * [`AuthorizedDapp`]s that the user has interacted with.
            */ authorizedDapps: [AuthorizedDapp]
    ) {
        self.id = id
        self.accounts = accounts
        self.personas = personas
        self.authorizedDapps = authorizedDapps
    }
}

extension ProfileNetwork: Sendable {}
extension ProfileNetwork: Equatable, Hashable {
    public static func == (lhs: ProfileNetwork, rhs: ProfileNetwork) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.personas != rhs.personas {
            return false
        }
        if lhs.authorizedDapps != rhs.authorizedDapps {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(accounts)
        hasher.combine(personas)
        hasher.combine(authorizedDapps)
    }
}

public struct FfiConverterTypeProfileNetwork: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileNetwork {
        return
            try ProfileNetwork(
                id: FfiConverterTypeNetworkID.read(from: &buf),
                accounts: FfiConverterSequenceTypeAccount.read(from: &buf),
                personas: FfiConverterSequenceTypePersona.read(from: &buf),
                authorizedDapps: FfiConverterSequenceTypeAuthorizedDapp.read(from: &buf)
            )
    }

    public static func write(_ value: ProfileNetwork, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.id, into: &buf)
        FfiConverterSequenceTypeAccount.write(value.accounts, into: &buf)
        FfiConverterSequenceTypePersona.write(value.personas, into: &buf)
        FfiConverterSequenceTypeAuthorizedDapp.write(value.authorizedDapps, into: &buf)
    }
}

public func FfiConverterTypeProfileNetwork_lift(_ buf: RustBuffer) throws -> ProfileNetwork {
    return try FfiConverterTypeProfileNetwork.lift(buf)
}

public func FfiConverterTypeProfileNetwork_lower(_ value: ProfileNetwork) -> RustBuffer {
    return FfiConverterTypeProfileNetwork.lower(value)
}

/**
 * The request received from the dApp that needs to be handled.
 */
public struct RadixConnectMobileSessionRequest {
    /**
     * The id of the session established with the dApp.
     * Needs to be passed back by the Host as to know which session to respond to.
     */
    public var sessionId: SessionId
    /**
     * The interaction received from the dApp.
     */
    public var interaction: DappToWalletInteractionUnvalidated
    /**
     * The origin of the dApp.
     */
    public var origin: DappOrigin
    /**
     * Whether the origin requires validation.
     */
    public var originRequiresValidation: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The id of the session established with the dApp.
         * Needs to be passed back by the Host as to know which session to respond to.
         */ sessionId: SessionId,
        /**
            * The interaction received from the dApp.
            */ interaction: DappToWalletInteractionUnvalidated,
        /**
            * The origin of the dApp.
            */ origin: DappOrigin,
        /**
            * Whether the origin requires validation.
            */ originRequiresValidation: Bool
    ) {
        self.sessionId = sessionId
        self.interaction = interaction
        self.origin = origin
        self.originRequiresValidation = originRequiresValidation
    }
}

extension RadixConnectMobileSessionRequest: Sendable {}
extension RadixConnectMobileSessionRequest: Equatable, Hashable {
    public static func == (lhs: RadixConnectMobileSessionRequest, rhs: RadixConnectMobileSessionRequest) -> Bool {
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.interaction != rhs.interaction {
            return false
        }
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.originRequiresValidation != rhs.originRequiresValidation {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sessionId)
        hasher.combine(interaction)
        hasher.combine(origin)
        hasher.combine(originRequiresValidation)
    }
}

public struct FfiConverterTypeRadixConnectMobileSessionRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileSessionRequest {
        return
            try RadixConnectMobileSessionRequest(
                sessionId: FfiConverterTypeSessionID.read(from: &buf),
                interaction: FfiConverterTypeDappToWalletInteractionUnvalidated.read(from: &buf),
                origin: FfiConverterTypeDappOrigin.read(from: &buf),
                originRequiresValidation: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: RadixConnectMobileSessionRequest, into buf: inout [UInt8]) {
        FfiConverterTypeSessionID.write(value.sessionId, into: &buf)
        FfiConverterTypeDappToWalletInteractionUnvalidated.write(value.interaction, into: &buf)
        FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
        FfiConverterBool.write(value.originRequiresValidation, into: &buf)
    }
}

public func FfiConverterTypeRadixConnectMobileSessionRequest_lift(_ buf: RustBuffer) throws -> RadixConnectMobileSessionRequest {
    return try FfiConverterTypeRadixConnectMobileSessionRequest.lift(buf)
}

public func FfiConverterTypeRadixConnectMobileSessionRequest_lower(_ value: RadixConnectMobileSessionRequest) -> RustBuffer {
    return FfiConverterTypeRadixConnectMobileSessionRequest.lower(value)
}

public struct RadixConnectMobileWalletResponse {
    public var sessionId: SessionId
    public var response: WalletToDappInteractionResponse

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sessionId: SessionId, response: WalletToDappInteractionResponse) {
        self.sessionId = sessionId
        self.response = response
    }
}

extension RadixConnectMobileWalletResponse: Sendable {}
extension RadixConnectMobileWalletResponse: Equatable, Hashable {
    public static func == (lhs: RadixConnectMobileWalletResponse, rhs: RadixConnectMobileWalletResponse) -> Bool {
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.response != rhs.response {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sessionId)
        hasher.combine(response)
    }
}

public struct FfiConverterTypeRadixConnectMobileWalletResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileWalletResponse {
        return
            try RadixConnectMobileWalletResponse(
                sessionId: FfiConverterTypeSessionID.read(from: &buf),
                response: FfiConverterTypeWalletToDappInteractionResponse.read(from: &buf)
            )
    }

    public static func write(_ value: RadixConnectMobileWalletResponse, into buf: inout [UInt8]) {
        FfiConverterTypeSessionID.write(value.sessionId, into: &buf)
        FfiConverterTypeWalletToDappInteractionResponse.write(value.response, into: &buf)
    }
}

public func FfiConverterTypeRadixConnectMobileWalletResponse_lift(_ buf: RustBuffer) throws -> RadixConnectMobileWalletResponse {
    return try FfiConverterTypeRadixConnectMobileWalletResponse.lift(buf)
}

public func FfiConverterTypeRadixConnectMobileWalletResponse_lower(_ value: RadixConnectMobileWalletResponse) -> RustBuffer {
    return FfiConverterTypeRadixConnectMobileWalletResponse.lower(value)
}

/**
 * The hash of the connection password is used to connect to the Radix Connect Signaling Server,
 * over web sockets. The actual `ConnectionPassword` is used to encrypt all messages sent via
 * the Signaling Server.
 */
public struct RadixConnectPassword {
    public var value: Exactly32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Exactly32Bytes) {
        self.value = value
    }
}

extension RadixConnectPassword: Sendable {}
extension RadixConnectPassword: Equatable, Hashable {
    public static func == (lhs: RadixConnectPassword, rhs: RadixConnectPassword) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeRadixConnectPassword: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectPassword {
        return
            try RadixConnectPassword(
                value: FfiConverterTypeExactly32Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: RadixConnectPassword, into buf: inout [UInt8]) {
        FfiConverterTypeExactly32Bytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeRadixConnectPassword_lift(_ buf: RustBuffer) throws -> RadixConnectPassword {
    return try FfiConverterTypeRadixConnectPassword.lift(buf)
}

public func FfiConverterTypeRadixConnectPassword_lower(_ value: RadixConnectPassword) -> RustBuffer {
    return FfiConverterTypeRadixConnectPassword.lower(value)
}

/**
 * RecoveryRole is used to recover lost access to an entity.
 */
public struct RecoveryRoleWithFactorInstances {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorInstance]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorInstance],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorInstance]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension RecoveryRoleWithFactorInstances: Sendable {}
extension RecoveryRoleWithFactorInstances: Equatable, Hashable {
    public static func == (lhs: RecoveryRoleWithFactorInstances, rhs: RecoveryRoleWithFactorInstances) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypeRecoveryRoleWithFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryRoleWithFactorInstances {
        return
            try RecoveryRoleWithFactorInstances(
                thresholdFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf)
            )
    }

    public static func write(_ value: RecoveryRoleWithFactorInstances, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorInstance.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorInstance.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypeRecoveryRoleWithFactorInstances_lift(_ buf: RustBuffer) throws -> RecoveryRoleWithFactorInstances {
    return try FfiConverterTypeRecoveryRoleWithFactorInstances.lift(buf)
}

public func FfiConverterTypeRecoveryRoleWithFactorInstances_lower(_ value: RecoveryRoleWithFactorInstances) -> RustBuffer {
    return FfiConverterTypeRecoveryRoleWithFactorInstances.lower(value)
}

/**
 * RecoveryRole is used to recover lost access to an entity.
 */
public struct RecoveryRoleWithFactorSourceIDs {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorSourceId]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSourceId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorSourceId],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorSourceId]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension RecoveryRoleWithFactorSourceIDs: Sendable {}
extension RecoveryRoleWithFactorSourceIDs: Equatable, Hashable {
    public static func == (lhs: RecoveryRoleWithFactorSourceIDs, rhs: RecoveryRoleWithFactorSourceIDs) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypeRecoveryRoleWithFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryRoleWithFactorSourceIDs {
        return
            try RecoveryRoleWithFactorSourceIDs(
                thresholdFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
            )
    }

    public static func write(_ value: RecoveryRoleWithFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorSourceID.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSourceID.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypeRecoveryRoleWithFactorSourceIDs_lift(_ buf: RustBuffer) throws -> RecoveryRoleWithFactorSourceIDs {
    return try FfiConverterTypeRecoveryRoleWithFactorSourceIDs.lift(buf)
}

public func FfiConverterTypeRecoveryRoleWithFactorSourceIDs_lower(_ value: RecoveryRoleWithFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypeRecoveryRoleWithFactorSourceIDs.lower(value)
}

/**
 * RecoveryRole is used to recover lost access to an entity.
 */
public struct RecoveryRoleWithFactorSources {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorSource]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorSource],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorSource]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension RecoveryRoleWithFactorSources: Sendable {}
extension RecoveryRoleWithFactorSources: Equatable, Hashable {
    public static func == (lhs: RecoveryRoleWithFactorSources, rhs: RecoveryRoleWithFactorSources) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypeRecoveryRoleWithFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryRoleWithFactorSources {
        return
            try RecoveryRoleWithFactorSources(
                thresholdFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf)
            )
    }

    public static func write(_ value: RecoveryRoleWithFactorSources, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorSource.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypeRecoveryRoleWithFactorSources_lift(_ buf: RustBuffer) throws -> RecoveryRoleWithFactorSources {
    return try FfiConverterTypeRecoveryRoleWithFactorSources.lift(buf)
}

public func FfiConverterTypeRecoveryRoleWithFactorSources_lower(_ value: RecoveryRoleWithFactorSources) -> RustBuffer {
    return FfiConverterTypeRecoveryRoleWithFactorSources.lower(value)
}

/**
 * A requested (by Dapp) quantity, e.g. "I want AT LEAST 3 account addresses" or
 * "I want EXACTLY 2 email addresses".
 */
public struct RequestedQuantity {
    public var quantifier: RequestedNumberQuantifier
    public var quantity: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(quantifier: RequestedNumberQuantifier, quantity: UInt16) {
        self.quantifier = quantifier
        self.quantity = quantity
    }
}

extension RequestedQuantity: Sendable {}
extension RequestedQuantity: Equatable, Hashable {
    public static func == (lhs: RequestedQuantity, rhs: RequestedQuantity) -> Bool {
        if lhs.quantifier != rhs.quantifier {
            return false
        }
        if lhs.quantity != rhs.quantity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(quantifier)
        hasher.combine(quantity)
    }
}

public struct FfiConverterTypeRequestedQuantity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedQuantity {
        return
            try RequestedQuantity(
                quantifier: FfiConverterTypeRequestedNumberQuantifier.read(from: &buf),
                quantity: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: RequestedQuantity, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedNumberQuantifier.write(value.quantifier, into: &buf)
        FfiConverterUInt16.write(value.quantity, into: &buf)
    }
}

public func FfiConverterTypeRequestedQuantity_lift(_ buf: RustBuffer) throws -> RequestedQuantity {
    return try FfiConverterTypeRequestedQuantity.lift(buf)
}

public func FfiConverterTypeRequestedQuantity_lower(_ value: RequestedQuantity) -> RustBuffer {
    return FfiConverterTypeRequestedQuantity.lower(value)
}

/**
 * Addresses identifying an asset, either fungible (Token) or non-fungible (NFT), on the Radix network, e.g.
 * `"resource_rdx1tknxxxxxxxxxradxrdxxxxxxxxx009923554798xxxxxxxxxradxrd"`
 * Being the unique identifier of the Radix Token, the Rad, on mainnet.
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of ResourceAddresses:
 * * GlobalFungibleResourceManager
 * * GlobalNonFungibleResourceManager
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalResourceAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L236-L239
 */
public struct ResourceAddress {
    fileprivate let secretMagic: RetResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetResourceAddress) {
        self.secretMagic = secretMagic
    }
}

extension ResourceAddress: Sendable {}
extension ResourceAddress: Equatable, Hashable {
    public static func == (lhs: ResourceAddress, rhs: ResourceAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeResourceAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAddress {
        return
            try ResourceAddress(
                secretMagic: FfiConverterTypeRetResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: ResourceAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetResourceAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeResourceAddress_lift(_ buf: RustBuffer) throws -> ResourceAddress {
    return try FfiConverterTypeResourceAddress.lift(buf)
}

public func FfiConverterTypeResourceAddress_lower(_ value: ResourceAddress) -> RustBuffer {
    return FfiConverterTypeResourceAddress.lower(value)
}

/**
 * A preference the user has configured off-ledger for a given resource.
 * Allows users, for example, to hide a given resource on their accounts.
 *
 * Named like this to differ from RET's `ResourcePreference`.
 */
public struct ResourceAppPreference {
    public var resource: ResourceIdentifier
    public var visibility: ResourceVisibility

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resource: ResourceIdentifier, visibility: ResourceVisibility) {
        self.resource = resource
        self.visibility = visibility
    }
}

extension ResourceAppPreference: Sendable {}
extension ResourceAppPreference: Equatable, Hashable {
    public static func == (lhs: ResourceAppPreference, rhs: ResourceAppPreference) -> Bool {
        if lhs.resource != rhs.resource {
            return false
        }
        if lhs.visibility != rhs.visibility {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resource)
        hasher.combine(visibility)
    }
}

public struct FfiConverterTypeResourceAppPreference: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAppPreference {
        return
            try ResourceAppPreference(
                resource: FfiConverterTypeResourceIdentifier.read(from: &buf),
                visibility: FfiConverterTypeResourceVisibility.read(from: &buf)
            )
    }

    public static func write(_ value: ResourceAppPreference, into buf: inout [UInt8]) {
        FfiConverterTypeResourceIdentifier.write(value.resource, into: &buf)
        FfiConverterTypeResourceVisibility.write(value.visibility, into: &buf)
    }
}

public func FfiConverterTypeResourceAppPreference_lift(_ buf: RustBuffer) throws -> ResourceAppPreference {
    return try FfiConverterTypeResourceAppPreference.lift(buf)
}

public func FfiConverterTypeResourceAppPreference_lower(_ value: ResourceAppPreference) -> RustBuffer {
    return FfiConverterTypeResourceAppPreference.lower(value)
}

public struct SargonBuildInformation {
    public var sargonVersion: String
    public var dependencies: SargonDependencies

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sargonVersion: String, dependencies: SargonDependencies) {
        self.sargonVersion = sargonVersion
        self.dependencies = dependencies
    }
}

extension SargonBuildInformation: Sendable {}
extension SargonBuildInformation: Equatable, Hashable {
    public static func == (lhs: SargonBuildInformation, rhs: SargonBuildInformation) -> Bool {
        if lhs.sargonVersion != rhs.sargonVersion {
            return false
        }
        if lhs.dependencies != rhs.dependencies {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sargonVersion)
        hasher.combine(dependencies)
    }
}

public struct FfiConverterTypeSargonBuildInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonBuildInformation {
        return
            try SargonBuildInformation(
                sargonVersion: FfiConverterString.read(from: &buf),
                dependencies: FfiConverterTypeSargonDependencies.read(from: &buf)
            )
    }

    public static func write(_ value: SargonBuildInformation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.sargonVersion, into: &buf)
        FfiConverterTypeSargonDependencies.write(value.dependencies, into: &buf)
    }
}

public func FfiConverterTypeSargonBuildInformation_lift(_ buf: RustBuffer) throws -> SargonBuildInformation {
    return try FfiConverterTypeSargonBuildInformation.lift(buf)
}

public func FfiConverterTypeSargonBuildInformation_lower(_ value: SargonBuildInformation) -> RustBuffer {
    return FfiConverterTypeSargonBuildInformation.lower(value)
}

public struct SargonDependencies {
    public var radixEngineToolkit: DependencyInformation
    public var scryptoRadixEngine: DependencyInformation

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(radixEngineToolkit: DependencyInformation, scryptoRadixEngine: DependencyInformation) {
        self.radixEngineToolkit = radixEngineToolkit
        self.scryptoRadixEngine = scryptoRadixEngine
    }
}

extension SargonDependencies: Sendable {}
extension SargonDependencies: Equatable, Hashable {
    public static func == (lhs: SargonDependencies, rhs: SargonDependencies) -> Bool {
        if lhs.radixEngineToolkit != rhs.radixEngineToolkit {
            return false
        }
        if lhs.scryptoRadixEngine != rhs.scryptoRadixEngine {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(radixEngineToolkit)
        hasher.combine(scryptoRadixEngine)
    }
}

public struct FfiConverterTypeSargonDependencies: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonDependencies {
        return
            try SargonDependencies(
                radixEngineToolkit: FfiConverterTypeDependencyInformation.read(from: &buf),
                scryptoRadixEngine: FfiConverterTypeDependencyInformation.read(from: &buf)
            )
    }

    public static func write(_ value: SargonDependencies, into buf: inout [UInt8]) {
        FfiConverterTypeDependencyInformation.write(value.radixEngineToolkit, into: &buf)
        FfiConverterTypeDependencyInformation.write(value.scryptoRadixEngine, into: &buf)
    }
}

public func FfiConverterTypeSargonDependencies_lift(_ buf: RustBuffer) throws -> SargonDependencies {
    return try FfiConverterTypeSargonDependencies.lift(buf)
}

public func FfiConverterTypeSargonDependencies_lower(_ value: SargonDependencies) -> RustBuffer {
    return FfiConverterTypeSargonDependencies.lower(value)
}

/**
 * The currently used Gateway and a collection of other by user added
 * or predefined Gateways the user can switch to.
 */
public struct SavedGateways {
    /**
     * The currently used Gateway, when a user query's asset balances of
     * accounts or submits transactions, this Gateway will be used.
     */
    public var current: Gateway
    /**
     * Other by user added or predefined Gateways the user can switch to.
     * It might be Gateways with different URLs on the SAME network, or
     * other networks, the identifier of a Gateway is the URL.
     */
    public var other: [Gateway]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The currently used Gateway, when a user query's asset balances of
         * accounts or submits transactions, this Gateway will be used.
         */ current: Gateway,
        /**
            * Other by user added or predefined Gateways the user can switch to.
            * It might be Gateways with different URLs on the SAME network, or
            * other networks, the identifier of a Gateway is the URL.
            */ other: [Gateway]
    ) {
        self.current = current
        self.other = other
    }
}

extension SavedGateways: Sendable {}
extension SavedGateways: Equatable, Hashable {
    public static func == (lhs: SavedGateways, rhs: SavedGateways) -> Bool {
        if lhs.current != rhs.current {
            return false
        }
        if lhs.other != rhs.other {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(current)
        hasher.combine(other)
    }
}

public struct FfiConverterTypeSavedGateways: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SavedGateways {
        return
            try SavedGateways(
                current: FfiConverterTypeGateway.read(from: &buf),
                other: FfiConverterSequenceTypeGateway.read(from: &buf)
            )
    }

    public static func write(_ value: SavedGateways, into buf: inout [UInt8]) {
        FfiConverterTypeGateway.write(value.current, into: &buf)
        FfiConverterSequenceTypeGateway.write(value.other, into: &buf)
    }
}

public func FfiConverterTypeSavedGateways_lift(_ buf: RustBuffer) throws -> SavedGateways {
    return try FfiConverterTypeSavedGateways.lift(buf)
}

public func FfiConverterTypeSavedGateways_lower(_ value: SavedGateways) -> RustBuffer {
    return FfiConverterTypeSavedGateways.lower(value)
}

/**
 * A `secp256k1` public key used to verify cryptographic signatures (ECDSA signatures).
 */
public struct Secp256k1PublicKey {
    fileprivate let secretMagic: ScryptoSecp256k1PublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: ScryptoSecp256k1PublicKey) {
        self.secretMagic = secretMagic
    }
}

extension Secp256k1PublicKey: Sendable {}
extension Secp256k1PublicKey: Equatable, Hashable {
    public static func == (lhs: Secp256k1PublicKey, rhs: Secp256k1PublicKey) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeSecp256k1PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1PublicKey {
        return
            try Secp256k1PublicKey(
                secretMagic: FfiConverterTypeScryptoSecp256k1PublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: Secp256k1PublicKey, into buf: inout [UInt8]) {
        FfiConverterTypeScryptoSecp256k1PublicKey.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeSecp256k1PublicKey_lift(_ buf: RustBuffer) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(buf)
}

public func FfiConverterTypeSecp256k1PublicKey_lower(_ value: Secp256k1PublicKey) -> RustBuffer {
    return FfiConverterTypeSecp256k1PublicKey.lower(value)
}

/**
 * Represents an Secp256k1 signature.
 */
public struct Secp256k1Signature {
    public var bytes: Exactly65Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Exactly65Bytes) {
        self.bytes = bytes
    }
}

extension Secp256k1Signature: Sendable {}
extension Secp256k1Signature: Equatable, Hashable {
    public static func == (lhs: Secp256k1Signature, rhs: Secp256k1Signature) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}

public struct FfiConverterTypeSecp256k1Signature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1Signature {
        return
            try Secp256k1Signature(
                bytes: FfiConverterTypeExactly65Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: Secp256k1Signature, into buf: inout [UInt8]) {
        FfiConverterTypeExactly65Bytes.write(value.bytes, into: &buf)
    }
}

public func FfiConverterTypeSecp256k1Signature_lift(_ buf: RustBuffer) throws -> Secp256k1Signature {
    return try FfiConverterTypeSecp256k1Signature.lift(buf)
}

public func FfiConverterTypeSecp256k1Signature_lower(_ value: Secp256k1Signature) -> RustBuffer {
    return FfiConverterTypeSecp256k1Signature.lower(value)
}

/**
 * Advanced security control of an entity which has been "securified",
 * meaning an MFA security structure (`SecurityStructureOfFactorSources`)
 * which user has created has been applied to it.
 */
public struct SecuredEntityControl {
    /**
     * The address of the access controller which controls this entity.
     *
     * Looking up the public key (hashes) set in the key-value store at
     * this address reveils the true factors (public keys) used to protect
     * this entity. It will be the same as the ones in `security_structure`
     * if we have not changed them locally, which we should not do unless
     * we are sure the Ledger corresponds to the values in `security_structure`.
     */
    public var accessControllerAddress: AccessControllerAddress
    /**
     * The believed-to-be-current security structure of FactorInstances which
     * secures this entity.
     */
    public var securityStructure: SecurityStructureOfFactorInstances

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The address of the access controller which controls this entity.
         *
         * Looking up the public key (hashes) set in the key-value store at
         * this address reveils the true factors (public keys) used to protect
         * this entity. It will be the same as the ones in `security_structure`
         * if we have not changed them locally, which we should not do unless
         * we are sure the Ledger corresponds to the values in `security_structure`.
         */ accessControllerAddress: AccessControllerAddress,
        /**
            * The believed-to-be-current security structure of FactorInstances which
            * secures this entity.
            */ securityStructure: SecurityStructureOfFactorInstances
    ) {
        self.accessControllerAddress = accessControllerAddress
        self.securityStructure = securityStructure
    }
}

extension SecuredEntityControl: Sendable {}
extension SecuredEntityControl: Equatable, Hashable {
    public static func == (lhs: SecuredEntityControl, rhs: SecuredEntityControl) -> Bool {
        if lhs.accessControllerAddress != rhs.accessControllerAddress {
            return false
        }
        if lhs.securityStructure != rhs.securityStructure {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accessControllerAddress)
        hasher.combine(securityStructure)
    }
}

public struct FfiConverterTypeSecuredEntityControl: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecuredEntityControl {
        return
            try SecuredEntityControl(
                accessControllerAddress: FfiConverterTypeAccessControllerAddress.read(from: &buf),
                securityStructure: FfiConverterTypeSecurityStructureOfFactorInstances.read(from: &buf)
            )
    }

    public static func write(_ value: SecuredEntityControl, into buf: inout [UInt8]) {
        FfiConverterTypeAccessControllerAddress.write(value.accessControllerAddress, into: &buf)
        FfiConverterTypeSecurityStructureOfFactorInstances.write(value.securityStructure, into: &buf)
    }
}

public func FfiConverterTypeSecuredEntityControl_lift(_ buf: RustBuffer) throws -> SecuredEntityControl {
    return try FfiConverterTypeSecuredEntityControl.lift(buf)
}

public func FfiConverterTypeSecuredEntityControl_lower(_ value: SecuredEntityControl) -> RustBuffer {
    return FfiConverterTypeSecuredEntityControl.lower(value)
}

/**
 * Controls e.g. if Profile Snapshot gets synced to iCloud or not, and whether
 * developer mode is enabled or not. In future (MFA) we will also save a list of
 * MFA security structure configurations.
 */
public struct Security {
    public var isCloudProfileSyncEnabled: IsCloudProfileSyncEnabled
    public var isDeveloperModeEnabled: IsDeveloperModeEnabled
    public var isAdvancedLockEnabled: IsAdvancedLockEnabled
    public var securityStructuresOfFactorSourceIds: [SecurityStructureOfFactorSourceIDs]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isCloudProfileSyncEnabled: IsCloudProfileSyncEnabled, isDeveloperModeEnabled: IsDeveloperModeEnabled, isAdvancedLockEnabled: IsAdvancedLockEnabled, securityStructuresOfFactorSourceIds: [SecurityStructureOfFactorSourceIDs]) {
        self.isCloudProfileSyncEnabled = isCloudProfileSyncEnabled
        self.isDeveloperModeEnabled = isDeveloperModeEnabled
        self.isAdvancedLockEnabled = isAdvancedLockEnabled
        self.securityStructuresOfFactorSourceIds = securityStructuresOfFactorSourceIds
    }
}

extension Security: Sendable {}
extension Security: Equatable, Hashable {
    public static func == (lhs: Security, rhs: Security) -> Bool {
        if lhs.isCloudProfileSyncEnabled != rhs.isCloudProfileSyncEnabled {
            return false
        }
        if lhs.isDeveloperModeEnabled != rhs.isDeveloperModeEnabled {
            return false
        }
        if lhs.isAdvancedLockEnabled != rhs.isAdvancedLockEnabled {
            return false
        }
        if lhs.securityStructuresOfFactorSourceIds != rhs.securityStructuresOfFactorSourceIds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCloudProfileSyncEnabled)
        hasher.combine(isDeveloperModeEnabled)
        hasher.combine(isAdvancedLockEnabled)
        hasher.combine(securityStructuresOfFactorSourceIds)
    }
}

public struct FfiConverterTypeSecurity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Security {
        return
            try Security(
                isCloudProfileSyncEnabled: FfiConverterTypeIsCloudProfileSyncEnabled.read(from: &buf),
                isDeveloperModeEnabled: FfiConverterTypeIsDeveloperModeEnabled.read(from: &buf),
                isAdvancedLockEnabled: FfiConverterTypeIsAdvancedLockEnabled.read(from: &buf),
                securityStructuresOfFactorSourceIds: FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.read(from: &buf)
            )
    }

    public static func write(_ value: Security, into buf: inout [UInt8]) {
        FfiConverterTypeIsCloudProfileSyncEnabled.write(value.isCloudProfileSyncEnabled, into: &buf)
        FfiConverterTypeIsDeveloperModeEnabled.write(value.isDeveloperModeEnabled, into: &buf)
        FfiConverterTypeIsAdvancedLockEnabled.write(value.isAdvancedLockEnabled, into: &buf)
        FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.write(value.securityStructuresOfFactorSourceIds, into: &buf)
    }
}

public func FfiConverterTypeSecurity_lift(_ buf: RustBuffer) throws -> Security {
    return try FfiConverterTypeSecurity.lift(buf)
}

public func FfiConverterTypeSecurity_lower(_ value: Security) -> RustBuffer {
    return FfiConverterTypeSecurity.lower(value)
}

/**
 *  NOT PRODUCTION READY YET 
 * A specification of expected format for an answer to a security question.
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityQuestionNotProductionReadyExpectedAnswerFormat {
    /**
     * E.g. `"<CITY>, <YEAR>"`
     */
    public var answerStructure: String
    /**
     * An example of a possible answer that matches `answer_structure`.
     * E.g. `"Berlin, 1976"`
     */
    public var exampleAnswer: String
    /**
     * If user is about to select the question:
     * `"What was the name of your first stuffed animal?"`
     *
     * Then we can discourage the user from selecting that question
     * if the answer is in `["Teddy", "Peter Rabbit", "Winnie (the Poh)"]`
     */
    public var unsafeAnswers: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * E.g. `"<CITY>, <YEAR>"`
         */ answerStructure: String,
        /**
            * An example of a possible answer that matches `answer_structure`.
            * E.g. `"Berlin, 1976"`
            */ exampleAnswer: String,
        /**
            * If user is about to select the question:
            * `"What was the name of your first stuffed animal?"`
            *
            * Then we can discourage the user from selecting that question
            * if the answer is in `["Teddy", "Peter Rabbit", "Winnie (the Poh)"]`
            */ unsafeAnswers: [String]
    ) {
        self.answerStructure = answerStructure
        self.exampleAnswer = exampleAnswer
        self.unsafeAnswers = unsafeAnswers
    }
}

extension SecurityQuestionNotProductionReadyExpectedAnswerFormat: Sendable {}
extension SecurityQuestionNotProductionReadyExpectedAnswerFormat: Equatable, Hashable {
    public static func == (lhs: SecurityQuestionNotProductionReadyExpectedAnswerFormat, rhs: SecurityQuestionNotProductionReadyExpectedAnswerFormat) -> Bool {
        if lhs.answerStructure != rhs.answerStructure {
            return false
        }
        if lhs.exampleAnswer != rhs.exampleAnswer {
            return false
        }
        if lhs.unsafeAnswers != rhs.unsafeAnswers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(answerStructure)
        hasher.combine(exampleAnswer)
        hasher.combine(unsafeAnswers)
    }
}

public struct FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionNotProductionReadyExpectedAnswerFormat {
        return
            try SecurityQuestionNotProductionReadyExpectedAnswerFormat(
                answerStructure: FfiConverterString.read(from: &buf),
                exampleAnswer: FfiConverterString.read(from: &buf),
                unsafeAnswers: FfiConverterSequenceString.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityQuestionNotProductionReadyExpectedAnswerFormat, into buf: inout [UInt8]) {
        FfiConverterString.write(value.answerStructure, into: &buf)
        FfiConverterString.write(value.exampleAnswer, into: &buf)
        FfiConverterSequenceString.write(value.unsafeAnswers, into: &buf)
    }
}

public func FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat_lift(_ buf: RustBuffer) throws -> SecurityQuestionNotProductionReadyExpectedAnswerFormat {
    return try FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat.lift(buf)
}

public func FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat_lower(_ value: SecurityQuestionNotProductionReadyExpectedAnswerFormat) -> RustBuffer {
    return FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat.lower(value)
}

/**
 *  NOT PRODUCTION READY YET 
 * A mnemonic encrypted by answers to security questions
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityQuestionsSealedNotProductionReadyMnemonic {
    public var securityQuestions: [SecurityNotProductionReadyQuestion]
    /**
     * A versioned Key Derivation Function (KDF) algorithm used to produce a set
     * of Encryption keys from a set of security questions and answers
     */
    public var kdfScheme: SecurityQuestionsNotProductionReadyKdfScheme
    /**
     * The scheme used to encrypt the Security Questions factor source
     * mnemonic using one combination of answers to questions, one of many.
     */
    public var encryptionScheme: EncryptionScheme
    /**
     * The N many encryptions of the mnemonic, where N corresponds to the number of derived keys
     * from the `keyDerivationScheme`
     */
    public var encryptions: [Exactly60Bytes]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(securityQuestions: [SecurityNotProductionReadyQuestion],
                /**
                    * A versioned Key Derivation Function (KDF) algorithm used to produce a set
                    * of Encryption keys from a set of security questions and answers
                    */ kdfScheme: SecurityQuestionsNotProductionReadyKdfScheme,
                /**
                    * The scheme used to encrypt the Security Questions factor source
                    * mnemonic using one combination of answers to questions, one of many.
                    */ encryptionScheme: EncryptionScheme,
                /**
                    * The N many encryptions of the mnemonic, where N corresponds to the number of derived keys
                    * from the `keyDerivationScheme`
                    */ encryptions: [Exactly60Bytes])
    {
        self.securityQuestions = securityQuestions
        self.kdfScheme = kdfScheme
        self.encryptionScheme = encryptionScheme
        self.encryptions = encryptions
    }
}

extension SecurityQuestionsSealedNotProductionReadyMnemonic: Sendable {}
extension SecurityQuestionsSealedNotProductionReadyMnemonic: Equatable, Hashable {
    public static func == (lhs: SecurityQuestionsSealedNotProductionReadyMnemonic, rhs: SecurityQuestionsSealedNotProductionReadyMnemonic) -> Bool {
        if lhs.securityQuestions != rhs.securityQuestions {
            return false
        }
        if lhs.kdfScheme != rhs.kdfScheme {
            return false
        }
        if lhs.encryptionScheme != rhs.encryptionScheme {
            return false
        }
        if lhs.encryptions != rhs.encryptions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(securityQuestions)
        hasher.combine(kdfScheme)
        hasher.combine(encryptionScheme)
        hasher.combine(encryptions)
    }
}

public struct FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsSealedNotProductionReadyMnemonic {
        return
            try SecurityQuestionsSealedNotProductionReadyMnemonic(
                securityQuestions: FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question.read(from: &buf),
                kdfScheme: FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme.read(from: &buf),
                encryptionScheme: FfiConverterTypeEncryptionScheme.read(from: &buf),
                encryptions: FfiConverterSequenceTypeExactly60Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityQuestionsSealedNotProductionReadyMnemonic, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question.write(value.securityQuestions, into: &buf)
        FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme.write(value.kdfScheme, into: &buf)
        FfiConverterTypeEncryptionScheme.write(value.encryptionScheme, into: &buf)
        FfiConverterSequenceTypeExactly60Bytes.write(value.encryptions, into: &buf)
    }
}

public func FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic_lift(_ buf: RustBuffer) throws -> SecurityQuestionsSealedNotProductionReadyMnemonic {
    return try FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic.lift(buf)
}

public func FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic_lower(_ value: SecurityQuestionsSealedNotProductionReadyMnemonic) -> RustBuffer {
    return FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic.lower(value)
}

/**
 *  NOT PRODUCTION READY YET 
 * A key derivation function which produces Encryption Keys from a set of
 * key exchange keys, by performing Diffie-Hellman key exchange on each
 * Key Exchange Key in a Set, by "folding" from left to right.
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold: Sendable {}
extension SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold: Equatable, Hashable {
    public static func == (_: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold, _: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold {
        return
            SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold()
    }

    public static func write(_: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold, into _: inout [UInt8]) {}
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold_lower(_ value: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold) -> RustBuffer {
    return FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.lower(value)
}

/**
 *  NOT PRODUCTION READY YET 
 * A mnemonic "sealed" by "security questions" (personal questions).
 *
 * The user select P personal questions from a set of Q predefined questions,
 * then answers them. The user will be able to "open" (decrypt) the "sealed"
 * (encrypted) mnemonic by providing at least P-1 correct answers to the P,
 * questions, that is to say, she is allowed to input one incorrect answer.
 * This is important since it makes this factor source kind more convenient
 * to use, especially if a significant time has passed between user answering
 * the questions for the first and the second time.
 *
 * In order to make it possible for user to input one incorrect answer, we need
 * to encrypt the mnemonic with many keys, keys being formed from many combinations
 * of question-answer-based input. To do this we use a function `qna2bin`
 * (question and answer to binary), to deterministically form Curve25519 key pairs,
 * P many (one per question/answer pair), and then we combine these keys using
 * ECDH (key exchange) to form composite (symmetric) encryption keys using P-1
 * many Ed25519 keys per composite encryption key.
 *
 * E.g. User selects 6 questions out of 20:
 * Q1: "What was the make and models of your first car?"
 * Q2: "In which town and which year did your parents meet?"
 * Q3: "What was the name of your first stuffed animal?"
 * Q4: "What was the name of the boy or the girl you first kissed?"
 * Q5: "What was the first exam you failed?"
 * Q6: "What is the middle name of your youngest child?"
 *
 * She answers them, forming
 * `let qa: Vec<(Questions, Answer)> = [(q_0, a_0), (q_1, a_1), .., (q_5, a_5)]`
 * question, answer pairs.
 *
 * The answers will be "normalized", trying to make it easier for user to provide
 * the same used answer later in time, we can do this by for example removing
 * whitespace, delimiters and apostrophes, and lowercase all chars.
 *
 * We form 6 binary inputs, call them `bins` using function `qna2bin` taking a
 * question/answer pair as input and outputting 32 bytes.
 * `let bins: Vec<Exactly32Bytes> = qa.iter().map(qna2bin).collect()`
 *
 * We form 6 X25519PrivateKey meant for Diffie-Hellman key exchange from `bin`
 * `let ec_keys: Vec<X25519PrivateKey> = bins.iter().map(bin2key).collect()`
 *
 * We form ["6 choose 4" ("P choose P-1")][choose] = 15 many combinations
 * (e.g. using [`combinations method from itertools`](itertools))
 *
 * ```ignore
 * let k = 4;
 * assert_eq!(ec_keys.len(), 6);
 * let key_combinations = Vec<Vec<X25519PrivateKey>> = ec_keys.combinations(k);
 * assert_eq!(key_combinations.len(), 15);
 * assert_eq!(key_combinations.iter().all(|v| v.len() == k);
 * ```
 *
 * We map the 15 `Vec<X25519PrivateKey>` into `X25519PublicKeys` using `multi_party_ecdh`:
 *
 * ```ignore
 * let ecdh_keys: Vec<X25519PublicKey> = key_combinations.iter().map(multi_party_ecdh).collect();
 * assert_eq!(sec_keys.len(), 15);
 * ```
 *
 * Where `multi_party_ecdh` is a function taking `Vec<X25519PrivateKey>` as input and
 * returning a `Key<Aes256Gcm>` by doing key exchange between all keys, like so:
 *
 * ```ignore
 * fn key_exchange_between_more_than_two_keys(
 * &self,
 * between: Vec<&X25519PrivateKey>,
 * ) -> X25519PublicKey {
 * let mut private_keys = between.clone();
 * assert!(private_keys.len() > 2);
 * let tail = private_keys.split_off(1);
 * let head = private_keys.into_iter().last().unwrap();
 *
 * tail.into_iter().fold(head.public_key(), |acc_pub, x_priv| {
 * let shared_secret = x_priv.diffie_hellman(&acc_pub);
 * X25519PublicKey::from_bytes(shared_secret.to_bytes())
 * })
 * }
 * ```
 *
 * We form 15 Symmetric Encryption keys from the 15 `X25519PublicKey` by simply
 * mapping the data of the public keys into AesGCM keys:
 *
 * ```ignore
 * let sec_keys: Vec<Key<AesGcm>> = ecdh_keys.iter().map(ec2sec).collect()
 * assert_eq!(sec_keys.len(), 15);
 * ```
 *
 * We encrypt the mnemonic 15 times, using each symmetric key in `sec_keys`:
 *
 * ```ignore
 * let encryptions: Vec<AesGcmSealedBox> = sec_keys.iter().map(|x| x.enc)
 * assert_eq!(encryptions.len(), 15);
 * ```
 *
 * Decryption is then the reverse process, trying to decrypt any of the 15
 * encrypted mnemonics with any of the 15 symmetric (de)encryption keys we
 * re-calculate from the answers user gives at this later point in time.
 *
 * Author / Inventor: Alexander Cyon (alex.cyon@gmail.com) in the year 2022.
 *
 *  NOT PRODUCTION READY YET 
 *
 * [choose]: https://en.wikipedia.org/wiki/Combination
 * [itertools]: https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.combinations

 */
public struct SecurityQuestionsNotProductionReadyFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * The sealed mnemonic containing multiple different encryptions of a
     * mnemonic encrypted by different encryptions keys, being various combinations
     * of questions and answers derived keys, allowing for only 4 out of 6 answers
     * to be correct.
     */
    public var sealedMnemonic: SecurityQuestionsSealedNotProductionReadyMnemonic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon,
        /**
            * The sealed mnemonic containing multiple different encryptions of a
            * mnemonic encrypted by different encryptions keys, being various combinations
            * of questions and answers derived keys, allowing for only 4 out of 6 answers
            * to be correct.
            */ sealedMnemonic: SecurityQuestionsSealedNotProductionReadyMnemonic
    ) {
        self.id = id
        self.common = common
        self.sealedMnemonic = sealedMnemonic
    }
}

extension SecurityQuestionsNotProductionReadyFactorSource: Sendable {}
extension SecurityQuestionsNotProductionReadyFactorSource: Equatable, Hashable {
    public static func == (lhs: SecurityQuestionsNotProductionReadyFactorSource, rhs: SecurityQuestionsNotProductionReadyFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.sealedMnemonic != rhs.sealedMnemonic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(sealedMnemonic)
    }
}

public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyFactorSource {
        return
            try SecurityQuestionsNotProductionReadyFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                sealedMnemonic: FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityQuestionsNotProductionReadyFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic.write(value.sealedMnemonic, into: &buf)
    }
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyFactorSource {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource_lower(_ value: SecurityQuestionsNotProductionReadyFactorSource) -> RustBuffer {
    return FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lower(value)
}

/**
 *  NOT PRODUCTION READY YET 
 * Version1 of SecurityQuestions KDF, derives encryption keys from security
 * questions and answers, using two "sub-KDFs".
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityQuestionsNotProductionReadyKdfSchemeVersion1 {
    public var kdfKeyExchangesKeysFromQuestionsAndAnswers: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8
    public var kdfEncryptionKeysFromKeyExchangeKeys: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(kdfKeyExchangesKeysFromQuestionsAndAnswers: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8, kdfEncryptionKeysFromKeyExchangeKeys: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold) {
        self.kdfKeyExchangesKeysFromQuestionsAndAnswers = kdfKeyExchangesKeysFromQuestionsAndAnswers
        self.kdfEncryptionKeysFromKeyExchangeKeys = kdfEncryptionKeysFromKeyExchangeKeys
    }
}

extension SecurityQuestionsNotProductionReadyKdfSchemeVersion1: Sendable {}
extension SecurityQuestionsNotProductionReadyKdfSchemeVersion1: Equatable, Hashable {
    public static func == (lhs: SecurityQuestionsNotProductionReadyKdfSchemeVersion1, rhs: SecurityQuestionsNotProductionReadyKdfSchemeVersion1) -> Bool {
        if lhs.kdfKeyExchangesKeysFromQuestionsAndAnswers != rhs.kdfKeyExchangesKeysFromQuestionsAndAnswers {
            return false
        }
        if lhs.kdfEncryptionKeysFromKeyExchangeKeys != rhs.kdfEncryptionKeysFromKeyExchangeKeys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kdfKeyExchangesKeysFromQuestionsAndAnswers)
        hasher.combine(kdfEncryptionKeysFromKeyExchangeKeys)
    }
}

public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyKdfSchemeVersion1 {
        return
            try SecurityQuestionsNotProductionReadyKdfSchemeVersion1(
                kdfKeyExchangesKeysFromQuestionsAndAnswers: FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.read(from: &buf),
                kdfEncryptionKeysFromKeyExchangeKeys: FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityQuestionsNotProductionReadyKdfSchemeVersion1, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.write(value.kdfKeyExchangesKeysFromQuestionsAndAnswers, into: &buf)
        FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.write(value.kdfEncryptionKeysFromKeyExchangeKeys, into: &buf)
    }
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyKdfSchemeVersion1 {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1_lower(_ value: SecurityQuestionsNotProductionReadyKdfSchemeVersion1) -> RustBuffer {
    return FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1.lower(value)
}

/**
 *  NOT PRODUCTION READY YET 
 * A Key Derivation Scheme which lowercases, trims and ut8f encodes answers.
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8 {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8: Sendable {}
extension SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8: Equatable, Hashable {
    public static func == (_: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8, _: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8 {
        return
            SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8()
    }

    public static func write(_: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8, into _: inout [UInt8]) {}
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8 {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8_lower(_ value: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8) -> RustBuffer {
    return FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.lower(value)
}

public struct SecurityStructureMetadata {
    public var id: SecurityStructureId
    public var displayName: DisplayName
    public var createdOn: Timestamp
    public var lastUpdatedOn: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: SecurityStructureId, displayName: DisplayName, createdOn: Timestamp, lastUpdatedOn: Timestamp) {
        self.id = id
        self.displayName = displayName
        self.createdOn = createdOn
        self.lastUpdatedOn = lastUpdatedOn
    }
}

extension SecurityStructureMetadata: Sendable {}
extension SecurityStructureMetadata: Equatable, Hashable {
    public static func == (lhs: SecurityStructureMetadata, rhs: SecurityStructureMetadata) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.createdOn != rhs.createdOn {
            return false
        }
        if lhs.lastUpdatedOn != rhs.lastUpdatedOn {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(displayName)
        hasher.combine(createdOn)
        hasher.combine(lastUpdatedOn)
    }
}

public struct FfiConverterTypeSecurityStructureMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureMetadata {
        return
            try SecurityStructureMetadata(
                id: FfiConverterTypeSecurityStructureID.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                createdOn: FfiConverterTypeTimestamp.read(from: &buf),
                lastUpdatedOn: FfiConverterTypeTimestamp.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityStructureMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureID.write(value.id, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeTimestamp.write(value.createdOn, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastUpdatedOn, into: &buf)
    }
}

public func FfiConverterTypeSecurityStructureMetadata_lift(_ buf: RustBuffer) throws -> SecurityStructureMetadata {
    return try FfiConverterTypeSecurityStructureMetadata.lift(buf)
}

public func FfiConverterTypeSecurityStructureMetadata_lower(_ value: SecurityStructureMetadata) -> RustBuffer {
    return FfiConverterTypeSecurityStructureMetadata.lower(value)
}

public struct SecurityStructureOfFactorInstances {
    /**
     * The ID of the `SecurityStructureOfFactorSourceIDs` in
     * `profile.app_preferences.security.security_structures_of_factor_source_ids`
     * which was used to derive the factor instances in this structure. Or rather:
     * The id of `SecurityStructureOfFactorSources`.
     */
    public var securityStructureId: SecurityStructureId
    /**
     * The structure of factors to use for certain roles, Primary, Recovery
     * and Confirmation role.
     */
    public var matrixOfFactors: MatrixOfFactorInstances

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the `SecurityStructureOfFactorSourceIDs` in
         * `profile.app_preferences.security.security_structures_of_factor_source_ids`
         * which was used to derive the factor instances in this structure. Or rather:
         * The id of `SecurityStructureOfFactorSources`.
         */ securityStructureId: SecurityStructureId,
        /**
            * The structure of factors to use for certain roles, Primary, Recovery
            * and Confirmation role.
            */ matrixOfFactors: MatrixOfFactorInstances
    ) {
        self.securityStructureId = securityStructureId
        self.matrixOfFactors = matrixOfFactors
    }
}

extension SecurityStructureOfFactorInstances: Sendable {}
extension SecurityStructureOfFactorInstances: Equatable, Hashable {
    public static func == (lhs: SecurityStructureOfFactorInstances, rhs: SecurityStructureOfFactorInstances) -> Bool {
        if lhs.securityStructureId != rhs.securityStructureId {
            return false
        }
        if lhs.matrixOfFactors != rhs.matrixOfFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(securityStructureId)
        hasher.combine(matrixOfFactors)
    }
}

public struct FfiConverterTypeSecurityStructureOfFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureOfFactorInstances {
        return
            try SecurityStructureOfFactorInstances(
                securityStructureId: FfiConverterTypeSecurityStructureID.read(from: &buf),
                matrixOfFactors: FfiConverterTypeMatrixOfFactorInstances.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityStructureOfFactorInstances, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureID.write(value.securityStructureId, into: &buf)
        FfiConverterTypeMatrixOfFactorInstances.write(value.matrixOfFactors, into: &buf)
    }
}

public func FfiConverterTypeSecurityStructureOfFactorInstances_lift(_ buf: RustBuffer) throws -> SecurityStructureOfFactorInstances {
    return try FfiConverterTypeSecurityStructureOfFactorInstances.lift(buf)
}

public func FfiConverterTypeSecurityStructureOfFactorInstances_lower(_ value: SecurityStructureOfFactorInstances) -> RustBuffer {
    return FfiConverterTypeSecurityStructureOfFactorInstances.lower(value)
}

/**
 * A security structure at FactorSourceID level, this is
 * what is serialized and store into Profile, we convert
 * into this structure from `SecurityStructureOfFactorSources`.
 */
public struct SecurityStructureOfFactorSourceIDs {
    /**
     * Metadata of this Security Structure, such as globally unique and
     * stable identifier, creation date and user chosen label (name).
     */
    public var metadata: SecurityStructureMetadata
    /**
     * The amount of time until Confirmation Role is automatically
     * exercised, inputted by user in Days in UI, but translate it into
     * epochs ("block time").
     */
    public var numberOfEpochsUntilAutoConfirmation: UInt64
    /**
     * The structure of factors to use for certain roles, Primary, Recovery
     * and Confirmation role.
     */
    public var matrixOfFactors: MatrixOfFactorSourceIDs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Metadata of this Security Structure, such as globally unique and
         * stable identifier, creation date and user chosen label (name).
         */ metadata: SecurityStructureMetadata,
        /**
            * The amount of time until Confirmation Role is automatically
            * exercised, inputted by user in Days in UI, but translate it into
            * epochs ("block time").
            */ numberOfEpochsUntilAutoConfirmation: UInt64,
        /**
            * The structure of factors to use for certain roles, Primary, Recovery
            * and Confirmation role.
            */ matrixOfFactors: MatrixOfFactorSourceIDs
    ) {
        self.metadata = metadata
        self.numberOfEpochsUntilAutoConfirmation = numberOfEpochsUntilAutoConfirmation
        self.matrixOfFactors = matrixOfFactors
    }
}

extension SecurityStructureOfFactorSourceIDs: Sendable {}
extension SecurityStructureOfFactorSourceIDs: Equatable, Hashable {
    public static func == (lhs: SecurityStructureOfFactorSourceIDs, rhs: SecurityStructureOfFactorSourceIDs) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.numberOfEpochsUntilAutoConfirmation != rhs.numberOfEpochsUntilAutoConfirmation {
            return false
        }
        if lhs.matrixOfFactors != rhs.matrixOfFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
        hasher.combine(numberOfEpochsUntilAutoConfirmation)
        hasher.combine(matrixOfFactors)
    }
}

public struct FfiConverterTypeSecurityStructureOfFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureOfFactorSourceIDs {
        return
            try SecurityStructureOfFactorSourceIDs(
                metadata: FfiConverterTypeSecurityStructureMetadata.read(from: &buf),
                numberOfEpochsUntilAutoConfirmation: FfiConverterUInt64.read(from: &buf),
                matrixOfFactors: FfiConverterTypeMatrixOfFactorSourceIDs.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityStructureOfFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureMetadata.write(value.metadata, into: &buf)
        FfiConverterUInt64.write(value.numberOfEpochsUntilAutoConfirmation, into: &buf)
        FfiConverterTypeMatrixOfFactorSourceIDs.write(value.matrixOfFactors, into: &buf)
    }
}

public func FfiConverterTypeSecurityStructureOfFactorSourceIDs_lift(_ buf: RustBuffer) throws -> SecurityStructureOfFactorSourceIDs {
    return try FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(buf)
}

public func FfiConverterTypeSecurityStructureOfFactorSourceIDs_lower(_ value: SecurityStructureOfFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypeSecurityStructureOfFactorSourceIDs.lower(value)
}

/**
 * Security structure at `FactorSource` level.
 * This is what user view, creates and manages.
 *
 * Before it gets saved into Profile gets converted into
 * `SecurityStructureOfFactorSourceIDs`
 */
public struct SecurityStructureOfFactorSources {
    /**
     * Metadata of this Security Structure, such as globally unique and
     * stable identifier, creation date and user chosen label (name).
     */
    public var metadata: SecurityStructureMetadata
    /**
     * The amount of time until Confirmation Role is automatically
     * exercised, inputted by user in Days in UI, but translate it into
     * epochs ("block time").
     */
    public var numberOfEpochsUntilAutoConfirmation: UInt64
    /**
     * The structure of factors to use for certain roles, Primary, Recovery
     * and Confirmation role.
     */
    public var matrixOfFactors: MatrixOfFactorSources

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Metadata of this Security Structure, such as globally unique and
         * stable identifier, creation date and user chosen label (name).
         */ metadata: SecurityStructureMetadata,
        /**
            * The amount of time until Confirmation Role is automatically
            * exercised, inputted by user in Days in UI, but translate it into
            * epochs ("block time").
            */ numberOfEpochsUntilAutoConfirmation: UInt64,
        /**
            * The structure of factors to use for certain roles, Primary, Recovery
            * and Confirmation role.
            */ matrixOfFactors: MatrixOfFactorSources
    ) {
        self.metadata = metadata
        self.numberOfEpochsUntilAutoConfirmation = numberOfEpochsUntilAutoConfirmation
        self.matrixOfFactors = matrixOfFactors
    }
}

extension SecurityStructureOfFactorSources: Sendable {}
extension SecurityStructureOfFactorSources: Equatable, Hashable {
    public static func == (lhs: SecurityStructureOfFactorSources, rhs: SecurityStructureOfFactorSources) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.numberOfEpochsUntilAutoConfirmation != rhs.numberOfEpochsUntilAutoConfirmation {
            return false
        }
        if lhs.matrixOfFactors != rhs.matrixOfFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
        hasher.combine(numberOfEpochsUntilAutoConfirmation)
        hasher.combine(matrixOfFactors)
    }
}

public struct FfiConverterTypeSecurityStructureOfFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureOfFactorSources {
        return
            try SecurityStructureOfFactorSources(
                metadata: FfiConverterTypeSecurityStructureMetadata.read(from: &buf),
                numberOfEpochsUntilAutoConfirmation: FfiConverterUInt64.read(from: &buf),
                matrixOfFactors: FfiConverterTypeMatrixOfFactorSources.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityStructureOfFactorSources, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureMetadata.write(value.metadata, into: &buf)
        FfiConverterUInt64.write(value.numberOfEpochsUntilAutoConfirmation, into: &buf)
        FfiConverterTypeMatrixOfFactorSources.write(value.matrixOfFactors, into: &buf)
    }
}

public func FfiConverterTypeSecurityStructureOfFactorSources_lift(_ buf: RustBuffer) throws -> SecurityStructureOfFactorSources {
    return try FfiConverterTypeSecurityStructureOfFactorSources.lift(buf)
}

public func FfiConverterTypeSecurityStructureOfFactorSources_lower(_ value: SecurityStructureOfFactorSources) -> RustBuffer {
    return FfiConverterTypeSecurityStructureOfFactorSources.lower(value)
}

/**
 *  NOT PRODUCTION READY YET 
 * A security question
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityNotProductionReadyQuestion {
    public var id: UInt16
    public var version: UInt8
    public var kind: SecurityQuestionKind
    public var question: String
    public var expectedAnswerFormat: SecurityQuestionNotProductionReadyExpectedAnswerFormat

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt16, version: UInt8, kind: SecurityQuestionKind, question: String, expectedAnswerFormat: SecurityQuestionNotProductionReadyExpectedAnswerFormat) {
        self.id = id
        self.version = version
        self.kind = kind
        self.question = question
        self.expectedAnswerFormat = expectedAnswerFormat
    }
}

extension SecurityNotProductionReadyQuestion: Sendable {}
extension SecurityNotProductionReadyQuestion: Equatable, Hashable {
    public static func == (lhs: SecurityNotProductionReadyQuestion, rhs: SecurityNotProductionReadyQuestion) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.question != rhs.question {
            return false
        }
        if lhs.expectedAnswerFormat != rhs.expectedAnswerFormat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(version)
        hasher.combine(kind)
        hasher.combine(question)
        hasher.combine(expectedAnswerFormat)
    }
}

public struct FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityNotProductionReadyQuestion {
        return
            try SecurityNotProductionReadyQuestion(
                id: FfiConverterUInt16.read(from: &buf),
                version: FfiConverterUInt8.read(from: &buf),
                kind: FfiConverterTypeSecurityQuestionKind.read(from: &buf),
                question: FfiConverterString.read(from: &buf),
                expectedAnswerFormat: FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityNotProductionReadyQuestion, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.id, into: &buf)
        FfiConverterUInt8.write(value.version, into: &buf)
        FfiConverterTypeSecurityQuestionKind.write(value.kind, into: &buf)
        FfiConverterString.write(value.question, into: &buf)
        FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat.write(value.expectedAnswerFormat, into: &buf)
    }
}

public func FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question_lift(_ buf: RustBuffer) throws -> SecurityNotProductionReadyQuestion {
    return try FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.lift(buf)
}

public func FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question_lower(_ value: SecurityNotProductionReadyQuestion) -> RustBuffer {
    return FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.lower(value)
}

/**
 *  NOT PRODUCTION READY YET 
 * A pair of security question and answer
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityNotProductionReadyQuestionAndAnswer {
    public var question: SecurityNotProductionReadyQuestion
    public var answer: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(question: SecurityNotProductionReadyQuestion, answer: String) {
        self.question = question
        self.answer = answer
    }
}

extension SecurityNotProductionReadyQuestionAndAnswer: Sendable {}
extension SecurityNotProductionReadyQuestionAndAnswer: Equatable, Hashable {
    public static func == (lhs: SecurityNotProductionReadyQuestionAndAnswer, rhs: SecurityNotProductionReadyQuestionAndAnswer) -> Bool {
        if lhs.question != rhs.question {
            return false
        }
        if lhs.answer != rhs.answer {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(question)
        hasher.combine(answer)
    }
}

public struct FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityNotProductionReadyQuestionAndAnswer {
        return
            try SecurityNotProductionReadyQuestionAndAnswer(
                question: FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.read(from: &buf),
                answer: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityNotProductionReadyQuestionAndAnswer, into buf: inout [UInt8]) {
        FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.write(value.question, into: &buf)
        FfiConverterString.write(value.answer, into: &buf)
    }
}

public func FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer_lift(_ buf: RustBuffer) throws -> SecurityNotProductionReadyQuestionAndAnswer {
    return try FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lift(buf)
}

public func FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer_lower(_ value: SecurityNotProductionReadyQuestionAndAnswer) -> RustBuffer {
    return FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lower(value)
}

/**
 * Identities for PersonaData entry values a user have shared with a dApp.
 */
public struct SharedPersonaData {
    /**
     * ID of a `PersonaDataEntryName` the user has shared with some dApp on some network,
     * can be `None`.
     */
    public var name: PersonaDataEntryId?
    /**
     * IDs of a `PersonaDataEntryEmailAddress`es the user has shared with some dApp on some network
     * can be `None`, or can be `Some(<EMPTY>)`.
     */
    public var emailAddresses: SharedToDappWithPersonaIDsOfPersonaDataEntries?
    /**
     * IDs of a `PersonaDataEntryPhoneNumber`s the user has shared with some dApp on some network
     * can be `None`, or can be `Some(<EMPTY>)`.
     */
    public var phoneNumbers: SharedToDappWithPersonaIDsOfPersonaDataEntries?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * ID of a `PersonaDataEntryName` the user has shared with some dApp on some network,
         * can be `None`.
         */ name: PersonaDataEntryId?,
        /**
            * IDs of a `PersonaDataEntryEmailAddress`es the user has shared with some dApp on some network
            * can be `None`, or can be `Some(<EMPTY>)`.
            */ emailAddresses: SharedToDappWithPersonaIDsOfPersonaDataEntries?,
        /**
            * IDs of a `PersonaDataEntryPhoneNumber`s the user has shared with some dApp on some network
            * can be `None`, or can be `Some(<EMPTY>)`.
            */ phoneNumbers: SharedToDappWithPersonaIDsOfPersonaDataEntries?
    ) {
        self.name = name
        self.emailAddresses = emailAddresses
        self.phoneNumbers = phoneNumbers
    }
}

extension SharedPersonaData: Sendable {}
extension SharedPersonaData: Equatable, Hashable {
    public static func == (lhs: SharedPersonaData, rhs: SharedPersonaData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(emailAddresses)
        hasher.combine(phoneNumbers)
    }
}

public struct FfiConverterTypeSharedPersonaData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedPersonaData {
        return
            try SharedPersonaData(
                name: FfiConverterOptionTypePersonaDataEntryID.read(from: &buf),
                emailAddresses: FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf),
                phoneNumbers: FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf)
            )
    }

    public static func write(_ value: SharedPersonaData, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataEntryID.write(value.name, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value.emailAddresses, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value.phoneNumbers, into: &buf)
    }
}

public func FfiConverterTypeSharedPersonaData_lift(_ buf: RustBuffer) throws -> SharedPersonaData {
    return try FfiConverterTypeSharedPersonaData.lift(buf)
}

public func FfiConverterTypeSharedPersonaData_lower(_ value: SharedPersonaData) -> RustBuffer {
    return FfiConverterTypeSharedPersonaData.lower(value)
}

/**
 * IDs that have been shared with an Dapp the user has interacted with
 * that fulfill a Dapp request's specified [`RequestedQuantity`].
 */
public struct SharedToDappWithPersonaAccountAddresses {
    /**
     * The requested quantity to be shared by user, sent by a Dapp.
     */
    public var request: RequestedQuantity
    /**
     * The by user shared IDs of data identifiable data shared with the
     * Dapp.
     */
    public var ids: [AccountAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The requested quantity to be shared by user, sent by a Dapp.
         */ request: RequestedQuantity,
        /**
            * The by user shared IDs of data identifiable data shared with the
            * Dapp.
            */ ids: [AccountAddress]
    ) {
        self.request = request
        self.ids = ids
    }
}

extension SharedToDappWithPersonaAccountAddresses: Sendable {}
extension SharedToDappWithPersonaAccountAddresses: Equatable, Hashable {
    public static func == (lhs: SharedToDappWithPersonaAccountAddresses, rhs: SharedToDappWithPersonaAccountAddresses) -> Bool {
        if lhs.request != rhs.request {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(request)
        hasher.combine(ids)
    }
}

public struct FfiConverterTypeSharedToDappWithPersonaAccountAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedToDappWithPersonaAccountAddresses {
        return
            try SharedToDappWithPersonaAccountAddresses(
                request: FfiConverterTypeRequestedQuantity.read(from: &buf),
                ids: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: SharedToDappWithPersonaAccountAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.request, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.ids, into: &buf)
    }
}

public func FfiConverterTypeSharedToDappWithPersonaAccountAddresses_lift(_ buf: RustBuffer) throws -> SharedToDappWithPersonaAccountAddresses {
    return try FfiConverterTypeSharedToDappWithPersonaAccountAddresses.lift(buf)
}

public func FfiConverterTypeSharedToDappWithPersonaAccountAddresses_lower(_ value: SharedToDappWithPersonaAccountAddresses) -> RustBuffer {
    return FfiConverterTypeSharedToDappWithPersonaAccountAddresses.lower(value)
}

/**
 * IDs that have been shared with an Dapp the user has interacted with
 * that fulfill a Dapp request's specified [`RequestedQuantity`].
 */
public struct SharedToDappWithPersonaIDsOfPersonaDataEntries {
    /**
     * The requested quantity to be shared by user, sent by a Dapp.
     */
    public var request: RequestedQuantity
    /**
     * The by user shared IDs of data identifiable data shared with the
     * Dapp.
     */
    public var ids: [PersonaDataEntryId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The requested quantity to be shared by user, sent by a Dapp.
         */ request: RequestedQuantity,
        /**
            * The by user shared IDs of data identifiable data shared with the
            * Dapp.
            */ ids: [PersonaDataEntryId]
    ) {
        self.request = request
        self.ids = ids
    }
}

extension SharedToDappWithPersonaIDsOfPersonaDataEntries: Sendable {}
extension SharedToDappWithPersonaIDsOfPersonaDataEntries: Equatable, Hashable {
    public static func == (lhs: SharedToDappWithPersonaIDsOfPersonaDataEntries, rhs: SharedToDappWithPersonaIDsOfPersonaDataEntries) -> Bool {
        if lhs.request != rhs.request {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(request)
        hasher.combine(ids)
    }
}

public struct FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedToDappWithPersonaIDsOfPersonaDataEntries {
        return
            try SharedToDappWithPersonaIDsOfPersonaDataEntries(
                request: FfiConverterTypeRequestedQuantity.read(from: &buf),
                ids: FfiConverterSequenceTypePersonaDataEntryID.read(from: &buf)
            )
    }

    public static func write(_ value: SharedToDappWithPersonaIDsOfPersonaDataEntries, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.request, into: &buf)
        FfiConverterSequenceTypePersonaDataEntryID.write(value.ids, into: &buf)
    }
}

public func FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries_lift(_ buf: RustBuffer) throws -> SharedToDappWithPersonaIDsOfPersonaDataEntries {
    return try FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.lift(buf)
}

public func FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries_lower(_ value: SharedToDappWithPersonaIDsOfPersonaDataEntries) -> RustBuffer {
    return FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.lower(value)
}

public struct SignedIntent {
    public var intent: TransactionIntent
    public var intentSignatures: IntentSignatures

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(intent: TransactionIntent, intentSignatures: IntentSignatures) {
        self.intent = intent
        self.intentSignatures = intentSignatures
    }
}

extension SignedIntent: Sendable {}
extension SignedIntent: Equatable, Hashable {
    public static func == (lhs: SignedIntent, rhs: SignedIntent) -> Bool {
        if lhs.intent != rhs.intent {
            return false
        }
        if lhs.intentSignatures != rhs.intentSignatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(intent)
        hasher.combine(intentSignatures)
    }
}

public struct FfiConverterTypeSignedIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedIntent {
        return
            try SignedIntent(
                intent: FfiConverterTypeTransactionIntent.read(from: &buf),
                intentSignatures: FfiConverterTypeIntentSignatures.read(from: &buf)
            )
    }

    public static func write(_ value: SignedIntent, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionIntent.write(value.intent, into: &buf)
        FfiConverterTypeIntentSignatures.write(value.intentSignatures, into: &buf)
    }
}

public func FfiConverterTypeSignedIntent_lift(_ buf: RustBuffer) throws -> SignedIntent {
    return try FfiConverterTypeSignedIntent.lift(buf)
}

public func FfiConverterTypeSignedIntent_lower(_ value: SignedIntent) -> RustBuffer {
    return FfiConverterTypeSignedIntent.lower(value)
}

/**
 * A Signed Intent Hash is a bech32 encoded string starting with `"signedintent_"
 */
public struct SignedIntentHash {
    /**
     * Which network this transaction hash is used on
     */
    public var networkId: NetworkId
    /**
     * the hash of the intent
     */
    public var hash: Hash
    /**
     * Bech32 encoded TX id
     */
    public var bech32EncodedTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Which network this transaction hash is used on
         */ networkId: NetworkId,
        /**
            * the hash of the intent
            */ hash: Hash,
        /**
            * Bech32 encoded TX id
            */ bech32EncodedTxId: String
    ) {
        self.networkId = networkId
        self.hash = hash
        self.bech32EncodedTxId = bech32EncodedTxId
    }
}

extension SignedIntentHash: Sendable {}
extension SignedIntentHash: Equatable, Hashable {
    public static func == (lhs: SignedIntentHash, rhs: SignedIntentHash) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(hash)
        hasher.combine(bech32EncodedTxId)
    }
}

public struct FfiConverterTypeSignedIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedIntentHash {
        return
            try SignedIntentHash(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                hash: FfiConverterTypeHash.read(from: &buf),
                bech32EncodedTxId: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: SignedIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeHash.write(value.hash, into: &buf)
        FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
    }
}

public func FfiConverterTypeSignedIntentHash_lift(_ buf: RustBuffer) throws -> SignedIntentHash {
    return try FfiConverterTypeSignedIntentHash.lift(buf)
}

public func FfiConverterTypeSignedIntentHash_lower(_ value: SignedIntentHash) -> RustBuffer {
    return FfiConverterTypeSignedIntentHash.lower(value)
}

public struct StakeClaim {
    public var validatorAddress: ValidatorAddress
    public var resourceAddress: NonFungibleResourceAddress
    public var ids: [NonFungibleLocalId]
    /**
     * The summed claim amount across ids
     */
    public var amount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: ValidatorAddress, resourceAddress: NonFungibleResourceAddress, ids: [NonFungibleLocalId],
                /**
                    * The summed claim amount across ids
                    */ amount: Decimal192)
    {
        self.validatorAddress = validatorAddress
        self.resourceAddress = resourceAddress
        self.ids = ids
        self.amount = amount
    }
}

extension StakeClaim: Sendable {}
extension StakeClaim: Equatable, Hashable {
    public static func == (lhs: StakeClaim, rhs: StakeClaim) -> Bool {
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validatorAddress)
        hasher.combine(resourceAddress)
        hasher.combine(ids)
        hasher.combine(amount)
    }
}

public struct FfiConverterTypeStakeClaim: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StakeClaim {
        return
            try StakeClaim(
                validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf),
                resourceAddress: FfiConverterTypeNonFungibleResourceAddress.read(from: &buf),
                ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                amount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: StakeClaim, into buf: inout [UInt8]) {
        FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeNonFungibleResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.ids, into: &buf)
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
    }
}

public func FfiConverterTypeStakeClaim_lift(_ buf: RustBuffer) throws -> StakeClaim {
    return try FfiConverterTypeStakeClaim.lift(buf)
}

public func FfiConverterTypeStakeClaim_lower(_ value: StakeClaim) -> RustBuffer {
    return FfiConverterTypeStakeClaim.lower(value)
}

/**
 * The response a call to the REST Endpoint:
 * `https://mainnet.radixdlt.com/state/entity/details`
 *
 * Which contains token balances of an account.
 */
public struct StateEntityDetailsResponse {
    public var items: [StateEntityDetailsResponseItem]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(items: [StateEntityDetailsResponseItem]) {
        self.items = items
    }
}

extension StateEntityDetailsResponse: Sendable {}
extension StateEntityDetailsResponse: Equatable, Hashable {
    public static func == (lhs: StateEntityDetailsResponse, rhs: StateEntityDetailsResponse) -> Bool {
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(items)
    }
}

public struct FfiConverterTypeStateEntityDetailsResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateEntityDetailsResponse {
        return
            try StateEntityDetailsResponse(
                items: FfiConverterSequenceTypeStateEntityDetailsResponseItem.read(from: &buf)
            )
    }

    public static func write(_ value: StateEntityDetailsResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeStateEntityDetailsResponseItem.write(value.items, into: &buf)
    }
}

public func FfiConverterTypeStateEntityDetailsResponse_lift(_ buf: RustBuffer) throws -> StateEntityDetailsResponse {
    return try FfiConverterTypeStateEntityDetailsResponse.lift(buf)
}

public func FfiConverterTypeStateEntityDetailsResponse_lower(_ value: StateEntityDetailsResponse) -> RustBuffer {
    return FfiConverterTypeStateEntityDetailsResponse.lower(value)
}

public struct StateEntityDetailsResponseItem {
    public var address: Address
    public var fungibleResources: FungibleResourcesCollection?
    public var metadata: EntityMetadataCollection

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: Address, fungibleResources: FungibleResourcesCollection?, metadata: EntityMetadataCollection) {
        self.address = address
        self.fungibleResources = fungibleResources
        self.metadata = metadata
    }
}

extension StateEntityDetailsResponseItem: Sendable {}
extension StateEntityDetailsResponseItem: Equatable, Hashable {
    public static func == (lhs: StateEntityDetailsResponseItem, rhs: StateEntityDetailsResponseItem) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.fungibleResources != rhs.fungibleResources {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(fungibleResources)
        hasher.combine(metadata)
    }
}

public struct FfiConverterTypeStateEntityDetailsResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateEntityDetailsResponseItem {
        return
            try StateEntityDetailsResponseItem(
                address: FfiConverterTypeAddress.read(from: &buf),
                fungibleResources: FfiConverterOptionTypeFungibleResourcesCollection.read(from: &buf),
                metadata: FfiConverterTypeEntityMetadataCollection.read(from: &buf)
            )
    }

    public static func write(_ value: StateEntityDetailsResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.address, into: &buf)
        FfiConverterOptionTypeFungibleResourcesCollection.write(value.fungibleResources, into: &buf)
        FfiConverterTypeEntityMetadataCollection.write(value.metadata, into: &buf)
    }
}

public func FfiConverterTypeStateEntityDetailsResponseItem_lift(_ buf: RustBuffer) throws -> StateEntityDetailsResponseItem {
    return try FfiConverterTypeStateEntityDetailsResponseItem.lift(buf)
}

public func FfiConverterTypeStateEntityDetailsResponseItem_lower(_ value: StateEntityDetailsResponseItem) -> RustBuffer {
    return FfiConverterTypeStateEntityDetailsResponseItem.lower(value)
}

/**
 * Controls the ability of third-parties to deposit into a certain account, this is
 * useful for users who wish to not be able to receive airdrops.
 */
public struct ThirdPartyDeposits {
    /**
     * Controls the ability of third-parties to deposit into this account
     */
    public var depositRule: DepositRule
    /**
     * Denies or allows third-party deposits of specific assets by ignoring the `depositMode`
     * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
     * thus the value is unknown.
     */
    public var assetsExceptionList: [AssetException]?
    /**
     * Allows certain third-party depositors to deposit assets freely.
     * Note: There is no `deny` counterpart for this.
     * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
     * thus the value is unknown.
     */
    public var depositorsAllowList: [ResourceOrNonFungible]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Controls the ability of third-parties to deposit into this account
         */ depositRule: DepositRule,
        /**
            * Denies or allows third-party deposits of specific assets by ignoring the `depositMode`
            * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
            * thus the value is unknown.
            */ assetsExceptionList: [AssetException]?,
        /**
            * Allows certain third-party depositors to deposit assets freely.
            * Note: There is no `deny` counterpart for this.
            * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
            * thus the value is unknown.
            */ depositorsAllowList: [ResourceOrNonFungible]?
    ) {
        self.depositRule = depositRule
        self.assetsExceptionList = assetsExceptionList
        self.depositorsAllowList = depositorsAllowList
    }
}

extension ThirdPartyDeposits: Sendable {}
extension ThirdPartyDeposits: Equatable, Hashable {
    public static func == (lhs: ThirdPartyDeposits, rhs: ThirdPartyDeposits) -> Bool {
        if lhs.depositRule != rhs.depositRule {
            return false
        }
        if lhs.assetsExceptionList != rhs.assetsExceptionList {
            return false
        }
        if lhs.depositorsAllowList != rhs.depositorsAllowList {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(depositRule)
        hasher.combine(assetsExceptionList)
        hasher.combine(depositorsAllowList)
    }
}

public struct FfiConverterTypeThirdPartyDeposits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThirdPartyDeposits {
        return
            try ThirdPartyDeposits(
                depositRule: FfiConverterTypeDepositRule.read(from: &buf),
                assetsExceptionList: FfiConverterOptionSequenceTypeAssetException.read(from: &buf),
                depositorsAllowList: FfiConverterOptionSequenceTypeResourceOrNonFungible.read(from: &buf)
            )
    }

    public static func write(_ value: ThirdPartyDeposits, into buf: inout [UInt8]) {
        FfiConverterTypeDepositRule.write(value.depositRule, into: &buf)
        FfiConverterOptionSequenceTypeAssetException.write(value.assetsExceptionList, into: &buf)
        FfiConverterOptionSequenceTypeResourceOrNonFungible.write(value.depositorsAllowList, into: &buf)
    }
}

public func FfiConverterTypeThirdPartyDeposits_lift(_ buf: RustBuffer) throws -> ThirdPartyDeposits {
    return try FfiConverterTypeThirdPartyDeposits.lift(buf)
}

public func FfiConverterTypeThirdPartyDeposits_lower(_ value: ThirdPartyDeposits) -> RustBuffer {
    return FfiConverterTypeThirdPartyDeposits.lower(value)
}

public struct TokenDefinitionMetadata {
    public var name: String
    public var description: String
    public var symbol: String
    public var iconUrl: String
    public var tags: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, description: String, symbol: String, iconUrl: String, tags: [String]) {
        self.name = name
        self.description = description
        self.symbol = symbol
        self.iconUrl = iconUrl
        self.tags = tags
    }
}

extension TokenDefinitionMetadata: Sendable {}
extension TokenDefinitionMetadata: Equatable, Hashable {
    public static func == (lhs: TokenDefinitionMetadata, rhs: TokenDefinitionMetadata) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.iconUrl != rhs.iconUrl {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(symbol)
        hasher.combine(iconUrl)
        hasher.combine(tags)
    }
}

public struct FfiConverterTypeTokenDefinitionMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenDefinitionMetadata {
        return
            try TokenDefinitionMetadata(
                name: FfiConverterString.read(from: &buf),
                description: FfiConverterString.read(from: &buf),
                symbol: FfiConverterString.read(from: &buf),
                iconUrl: FfiConverterString.read(from: &buf),
                tags: FfiConverterSequenceString.read(from: &buf)
            )
    }

    public static func write(_ value: TokenDefinitionMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.symbol, into: &buf)
        FfiConverterString.write(value.iconUrl, into: &buf)
        FfiConverterSequenceString.write(value.tags, into: &buf)
    }
}

public func FfiConverterTypeTokenDefinitionMetadata_lift(_ buf: RustBuffer) throws -> TokenDefinitionMetadata {
    return try FfiConverterTypeTokenDefinitionMetadata.lift(buf)
}

public func FfiConverterTypeTokenDefinitionMetadata_lower(_ value: TokenDefinitionMetadata) -> RustBuffer {
    return FfiConverterTypeTokenDefinitionMetadata.lower(value)
}

/**
 * A contribution to a pool observed in the transaction
 */
public struct TrackedPoolContribution {
    public var poolAddress: PoolAddress
    public var contributedResources: [ResourceAddress: Decimal192]
    public var poolUnitsResourceAddress: ResourceAddress
    public var poolUnitsAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolAddress: PoolAddress, contributedResources: [ResourceAddress: Decimal192], poolUnitsResourceAddress: ResourceAddress, poolUnitsAmount: Decimal192) {
        self.poolAddress = poolAddress
        self.contributedResources = contributedResources
        self.poolUnitsResourceAddress = poolUnitsResourceAddress
        self.poolUnitsAmount = poolUnitsAmount
    }
}

extension TrackedPoolContribution: Sendable {}
extension TrackedPoolContribution: Equatable, Hashable {
    public static func == (lhs: TrackedPoolContribution, rhs: TrackedPoolContribution) -> Bool {
        if lhs.poolAddress != rhs.poolAddress {
            return false
        }
        if lhs.contributedResources != rhs.contributedResources {
            return false
        }
        if lhs.poolUnitsResourceAddress != rhs.poolUnitsResourceAddress {
            return false
        }
        if lhs.poolUnitsAmount != rhs.poolUnitsAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(poolAddress)
        hasher.combine(contributedResources)
        hasher.combine(poolUnitsResourceAddress)
        hasher.combine(poolUnitsAmount)
    }
}

public struct FfiConverterTypeTrackedPoolContribution: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedPoolContribution {
        return
            try TrackedPoolContribution(
                poolAddress: FfiConverterTypePoolAddress.read(from: &buf),
                contributedResources: FfiConverterDictionaryTypeResourceAddressTypeDecimal192.read(from: &buf),
                poolUnitsResourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                poolUnitsAmount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TrackedPoolContribution, into buf: inout [UInt8]) {
        FfiConverterTypePoolAddress.write(value.poolAddress, into: &buf)
        FfiConverterDictionaryTypeResourceAddressTypeDecimal192.write(value.contributedResources, into: &buf)
        FfiConverterTypeResourceAddress.write(value.poolUnitsResourceAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.poolUnitsAmount, into: &buf)
    }
}

public func FfiConverterTypeTrackedPoolContribution_lift(_ buf: RustBuffer) throws -> TrackedPoolContribution {
    return try FfiConverterTypeTrackedPoolContribution.lift(buf)
}

public func FfiConverterTypeTrackedPoolContribution_lower(_ value: TrackedPoolContribution) -> RustBuffer {
    return FfiConverterTypeTrackedPoolContribution.lower(value)
}

/**
 * A pool redemptions observed in the transaction
 */
public struct TrackedPoolRedemption {
    public var poolAddress: PoolAddress
    public var poolUnitsResourceAddress: ResourceAddress
    public var poolUnitsAmount: Decimal192
    public var redeemedResources: [ResourceAddress: Decimal192]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolAddress: PoolAddress, poolUnitsResourceAddress: ResourceAddress, poolUnitsAmount: Decimal192, redeemedResources: [ResourceAddress: Decimal192]) {
        self.poolAddress = poolAddress
        self.poolUnitsResourceAddress = poolUnitsResourceAddress
        self.poolUnitsAmount = poolUnitsAmount
        self.redeemedResources = redeemedResources
    }
}

extension TrackedPoolRedemption: Sendable {}
extension TrackedPoolRedemption: Equatable, Hashable {
    public static func == (lhs: TrackedPoolRedemption, rhs: TrackedPoolRedemption) -> Bool {
        if lhs.poolAddress != rhs.poolAddress {
            return false
        }
        if lhs.poolUnitsResourceAddress != rhs.poolUnitsResourceAddress {
            return false
        }
        if lhs.poolUnitsAmount != rhs.poolUnitsAmount {
            return false
        }
        if lhs.redeemedResources != rhs.redeemedResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(poolAddress)
        hasher.combine(poolUnitsResourceAddress)
        hasher.combine(poolUnitsAmount)
        hasher.combine(redeemedResources)
    }
}

public struct FfiConverterTypeTrackedPoolRedemption: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedPoolRedemption {
        return
            try TrackedPoolRedemption(
                poolAddress: FfiConverterTypePoolAddress.read(from: &buf),
                poolUnitsResourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                poolUnitsAmount: FfiConverterTypeDecimal192.read(from: &buf),
                redeemedResources: FfiConverterDictionaryTypeResourceAddressTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TrackedPoolRedemption, into buf: inout [UInt8]) {
        FfiConverterTypePoolAddress.write(value.poolAddress, into: &buf)
        FfiConverterTypeResourceAddress.write(value.poolUnitsResourceAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.poolUnitsAmount, into: &buf)
        FfiConverterDictionaryTypeResourceAddressTypeDecimal192.write(value.redeemedResources, into: &buf)
    }
}

public func FfiConverterTypeTrackedPoolRedemption_lift(_ buf: RustBuffer) throws -> TrackedPoolRedemption {
    return try FfiConverterTypeTrackedPoolRedemption.lift(buf)
}

public func FfiConverterTypeTrackedPoolRedemption_lower(_ value: TrackedPoolRedemption) -> RustBuffer {
    return FfiConverterTypeTrackedPoolRedemption.lower(value)
}

/**
 * A validator claim observed in the transaction
 */
public struct TrackedValidatorClaim {
    public var validatorAddress: ValidatorAddress
    public var claimNftAddress: ResourceAddress
    public var claimNftIds: [NonFungibleLocalId]
    public var xrdAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: ValidatorAddress, claimNftAddress: ResourceAddress, claimNftIds: [NonFungibleLocalId], xrdAmount: Decimal192) {
        self.validatorAddress = validatorAddress
        self.claimNftAddress = claimNftAddress
        self.claimNftIds = claimNftIds
        self.xrdAmount = xrdAmount
    }
}

extension TrackedValidatorClaim: Sendable {}
extension TrackedValidatorClaim: Equatable, Hashable {
    public static func == (lhs: TrackedValidatorClaim, rhs: TrackedValidatorClaim) -> Bool {
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.claimNftAddress != rhs.claimNftAddress {
            return false
        }
        if lhs.claimNftIds != rhs.claimNftIds {
            return false
        }
        if lhs.xrdAmount != rhs.xrdAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validatorAddress)
        hasher.combine(claimNftAddress)
        hasher.combine(claimNftIds)
        hasher.combine(xrdAmount)
    }
}

public struct FfiConverterTypeTrackedValidatorClaim: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorClaim {
        return
            try TrackedValidatorClaim(
                validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf),
                claimNftAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                claimNftIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                xrdAmount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TrackedValidatorClaim, into buf: inout [UInt8]) {
        FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeResourceAddress.write(value.claimNftAddress, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.claimNftIds, into: &buf)
        FfiConverterTypeDecimal192.write(value.xrdAmount, into: &buf)
    }
}

public func FfiConverterTypeTrackedValidatorClaim_lift(_ buf: RustBuffer) throws -> TrackedValidatorClaim {
    return try FfiConverterTypeTrackedValidatorClaim.lift(buf)
}

public func FfiConverterTypeTrackedValidatorClaim_lower(_ value: TrackedValidatorClaim) -> RustBuffer {
    return FfiConverterTypeTrackedValidatorClaim.lower(value)
}

/**
 * A validator stake observed in the transaction
 */
public struct TrackedValidatorStake {
    public var validatorAddress: ValidatorAddress
    public var xrdAmount: Decimal192
    public var liquidStakeUnitAddress: ResourceAddress
    public var liquidStakeUnitAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: ValidatorAddress, xrdAmount: Decimal192, liquidStakeUnitAddress: ResourceAddress, liquidStakeUnitAmount: Decimal192) {
        self.validatorAddress = validatorAddress
        self.xrdAmount = xrdAmount
        self.liquidStakeUnitAddress = liquidStakeUnitAddress
        self.liquidStakeUnitAmount = liquidStakeUnitAmount
    }
}

extension TrackedValidatorStake: Sendable {}
extension TrackedValidatorStake: Equatable, Hashable {
    public static func == (lhs: TrackedValidatorStake, rhs: TrackedValidatorStake) -> Bool {
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.xrdAmount != rhs.xrdAmount {
            return false
        }
        if lhs.liquidStakeUnitAddress != rhs.liquidStakeUnitAddress {
            return false
        }
        if lhs.liquidStakeUnitAmount != rhs.liquidStakeUnitAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validatorAddress)
        hasher.combine(xrdAmount)
        hasher.combine(liquidStakeUnitAddress)
        hasher.combine(liquidStakeUnitAmount)
    }
}

public struct FfiConverterTypeTrackedValidatorStake: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorStake {
        return
            try TrackedValidatorStake(
                validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf),
                xrdAmount: FfiConverterTypeDecimal192.read(from: &buf),
                liquidStakeUnitAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                liquidStakeUnitAmount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TrackedValidatorStake, into buf: inout [UInt8]) {
        FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.xrdAmount, into: &buf)
        FfiConverterTypeResourceAddress.write(value.liquidStakeUnitAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.liquidStakeUnitAmount, into: &buf)
    }
}

public func FfiConverterTypeTrackedValidatorStake_lift(_ buf: RustBuffer) throws -> TrackedValidatorStake {
    return try FfiConverterTypeTrackedValidatorStake.lift(buf)
}

public func FfiConverterTypeTrackedValidatorStake_lower(_ value: TrackedValidatorStake) -> RustBuffer {
    return FfiConverterTypeTrackedValidatorStake.lower(value)
}

public struct TransactionConstructionResponse {
    public var ledgerState: LedgerState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ledgerState: LedgerState) {
        self.ledgerState = ledgerState
    }
}

extension TransactionConstructionResponse: Sendable {}
extension TransactionConstructionResponse: Equatable, Hashable {
    public static func == (lhs: TransactionConstructionResponse, rhs: TransactionConstructionResponse) -> Bool {
        if lhs.ledgerState != rhs.ledgerState {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ledgerState)
    }
}

public struct FfiConverterTypeTransactionConstructionResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionConstructionResponse {
        return
            try TransactionConstructionResponse(
                ledgerState: FfiConverterTypeLedgerState.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionConstructionResponse, into buf: inout [UInt8]) {
        FfiConverterTypeLedgerState.write(value.ledgerState, into: &buf)
    }
}

public func FfiConverterTypeTransactionConstructionResponse_lift(_ buf: RustBuffer) throws -> TransactionConstructionResponse {
    return try FfiConverterTypeTransactionConstructionResponse.lift(buf)
}

public func FfiConverterTypeTransactionConstructionResponse_lower(_ value: TransactionConstructionResponse) -> RustBuffer {
    return FfiConverterTypeTransactionConstructionResponse.lower(value)
}

public struct TransactionGuarantee {
    /**
     * The guaranteed amount to be obtained on this transaction. For manifest & display purposes.
     */
    public var amount: Decimal192
    /**
     * The percentage the user has selected, which generated the `amount`. For display purposes only.
     */
    public var percentage: Decimal192
    public var instructionIndex: UInt64
    public var resourceAddress: ResourceAddress
    public var resourceDivisibility: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The guaranteed amount to be obtained on this transaction. For manifest & display purposes.
         */ amount: Decimal192,
        /**
            * The percentage the user has selected, which generated the `amount`. For display purposes only.
            */ percentage: Decimal192, instructionIndex: UInt64, resourceAddress: ResourceAddress, resourceDivisibility: UInt8?
    ) {
        self.amount = amount
        self.percentage = percentage
        self.instructionIndex = instructionIndex
        self.resourceAddress = resourceAddress
        self.resourceDivisibility = resourceDivisibility
    }
}

extension TransactionGuarantee: Sendable {}
extension TransactionGuarantee: Equatable, Hashable {
    public static func == (lhs: TransactionGuarantee, rhs: TransactionGuarantee) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.percentage != rhs.percentage {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.resourceDivisibility != rhs.resourceDivisibility {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(percentage)
        hasher.combine(instructionIndex)
        hasher.combine(resourceAddress)
        hasher.combine(resourceDivisibility)
    }
}

public struct FfiConverterTypeTransactionGuarantee: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionGuarantee {
        return
            try TransactionGuarantee(
                amount: FfiConverterTypeDecimal192.read(from: &buf),
                percentage: FfiConverterTypeDecimal192.read(from: &buf),
                instructionIndex: FfiConverterUInt64.read(from: &buf),
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                resourceDivisibility: FfiConverterOptionUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionGuarantee, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterTypeDecimal192.write(value.percentage, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterOptionUInt8.write(value.resourceDivisibility, into: &buf)
    }
}

public func FfiConverterTypeTransactionGuarantee_lift(_ buf: RustBuffer) throws -> TransactionGuarantee {
    return try FfiConverterTypeTransactionGuarantee.lift(buf)
}

public func FfiConverterTypeTransactionGuarantee_lower(_ value: TransactionGuarantee) -> RustBuffer {
    return FfiConverterTypeTransactionGuarantee.lower(value)
}

public struct TransactionHeader {
    public var networkId: NetworkId
    public var startEpochInclusive: Epoch
    public var endEpochExclusive: Epoch
    public var nonce: Nonce
    public var notaryPublicKey: PublicKey
    public var notaryIsSignatory: Bool
    public var tipPercentage: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, startEpochInclusive: Epoch, endEpochExclusive: Epoch, nonce: Nonce, notaryPublicKey: PublicKey, notaryIsSignatory: Bool, tipPercentage: UInt16) {
        self.networkId = networkId
        self.startEpochInclusive = startEpochInclusive
        self.endEpochExclusive = endEpochExclusive
        self.nonce = nonce
        self.notaryPublicKey = notaryPublicKey
        self.notaryIsSignatory = notaryIsSignatory
        self.tipPercentage = tipPercentage
    }
}

extension TransactionHeader: Sendable {}
extension TransactionHeader: Equatable, Hashable {
    public static func == (lhs: TransactionHeader, rhs: TransactionHeader) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.startEpochInclusive != rhs.startEpochInclusive {
            return false
        }
        if lhs.endEpochExclusive != rhs.endEpochExclusive {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.notaryPublicKey != rhs.notaryPublicKey {
            return false
        }
        if lhs.notaryIsSignatory != rhs.notaryIsSignatory {
            return false
        }
        if lhs.tipPercentage != rhs.tipPercentage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(startEpochInclusive)
        hasher.combine(endEpochExclusive)
        hasher.combine(nonce)
        hasher.combine(notaryPublicKey)
        hasher.combine(notaryIsSignatory)
        hasher.combine(tipPercentage)
    }
}

public struct FfiConverterTypeTransactionHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHeader {
        return
            try TransactionHeader(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                startEpochInclusive: FfiConverterTypeEpoch.read(from: &buf),
                endEpochExclusive: FfiConverterTypeEpoch.read(from: &buf),
                nonce: FfiConverterTypeNonce.read(from: &buf),
                notaryPublicKey: FfiConverterTypePublicKey.read(from: &buf),
                notaryIsSignatory: FfiConverterBool.read(from: &buf),
                tipPercentage: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionHeader, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeEpoch.write(value.startEpochInclusive, into: &buf)
        FfiConverterTypeEpoch.write(value.endEpochExclusive, into: &buf)
        FfiConverterTypeNonce.write(value.nonce, into: &buf)
        FfiConverterTypePublicKey.write(value.notaryPublicKey, into: &buf)
        FfiConverterBool.write(value.notaryIsSignatory, into: &buf)
        FfiConverterUInt16.write(value.tipPercentage, into: &buf)
    }
}

public func FfiConverterTypeTransactionHeader_lift(_ buf: RustBuffer) throws -> TransactionHeader {
    return try FfiConverterTypeTransactionHeader.lift(buf)
}

public func FfiConverterTypeTransactionHeader_lower(_ value: TransactionHeader) -> RustBuffer {
    return FfiConverterTypeTransactionHeader.lower(value)
}

public struct TransactionIntent {
    public var header: TransactionHeader
    public var manifest: TransactionManifest
    public var message: Message

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(header: TransactionHeader, manifest: TransactionManifest, message: Message) {
        self.header = header
        self.manifest = manifest
        self.message = message
    }
}

extension TransactionIntent: Sendable {}
extension TransactionIntent: Equatable, Hashable {
    public static func == (lhs: TransactionIntent, rhs: TransactionIntent) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.manifest != rhs.manifest {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(manifest)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeTransactionIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionIntent {
        return
            try TransactionIntent(
                header: FfiConverterTypeTransactionHeader.read(from: &buf),
                manifest: FfiConverterTypeTransactionManifest.read(from: &buf),
                message: FfiConverterTypeMessage.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionIntent, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionHeader.write(value.header, into: &buf)
        FfiConverterTypeTransactionManifest.write(value.manifest, into: &buf)
        FfiConverterTypeMessage.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeTransactionIntent_lift(_ buf: RustBuffer) throws -> TransactionIntent {
    return try FfiConverterTypeTransactionIntent.lift(buf)
}

public func FfiConverterTypeTransactionIntent_lower(_ value: TransactionIntent) -> RustBuffer {
    return FfiConverterTypeTransactionIntent.lower(value)
}

public struct TransactionManifest {
    fileprivate let secretMagic: TransactionManifestSecretMagic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: TransactionManifestSecretMagic) {
        self.secretMagic = secretMagic
    }
}

extension TransactionManifest: Sendable {}
extension TransactionManifest: Equatable, Hashable {
    public static func == (lhs: TransactionManifest, rhs: TransactionManifest) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeTransactionManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifest {
        return
            try TransactionManifest(
                secretMagic: FfiConverterTypeTransactionManifestSecretMagic.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionManifest, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionManifestSecretMagic.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeTransactionManifest_lift(_ buf: RustBuffer) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(buf)
}

public func FfiConverterTypeTransactionManifest_lower(_ value: TransactionManifest) -> RustBuffer {
    return FfiConverterTypeTransactionManifest.lower(value)
}

/**
 * An internal representation of a TransactionManifest,
 * which intentions is to allow the `struct TransactionManifest`
 * to have no public initializers in Swift/Kotlin land, since it
 * can contain a single field:
 * `private let secretMagic: TransactionManifestSecretMagic`
 */
public struct TransactionManifestSecretMagic {
    public var instructions: Instructions
    public var blobs: Blobs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(instructions: Instructions, blobs: Blobs) {
        self.instructions = instructions
        self.blobs = blobs
    }
}

extension TransactionManifestSecretMagic: Sendable {}
extension TransactionManifestSecretMagic: Equatable, Hashable {
    public static func == (lhs: TransactionManifestSecretMagic, rhs: TransactionManifestSecretMagic) -> Bool {
        if lhs.instructions != rhs.instructions {
            return false
        }
        if lhs.blobs != rhs.blobs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(instructions)
        hasher.combine(blobs)
    }
}

public struct FfiConverterTypeTransactionManifestSecretMagic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifestSecretMagic {
        return
            try TransactionManifestSecretMagic(
                instructions: FfiConverterTypeInstructions.read(from: &buf),
                blobs: FfiConverterTypeBlobs.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionManifestSecretMagic, into buf: inout [UInt8]) {
        FfiConverterTypeInstructions.write(value.instructions, into: &buf)
        FfiConverterTypeBlobs.write(value.blobs, into: &buf)
    }
}

public func FfiConverterTypeTransactionManifestSecretMagic_lift(_ buf: RustBuffer) throws -> TransactionManifestSecretMagic {
    return try FfiConverterTypeTransactionManifestSecretMagic.lift(buf)
}

public func FfiConverterTypeTransactionManifestSecretMagic_lower(_ value: TransactionManifestSecretMagic) -> RustBuffer {
    return FfiConverterTypeTransactionManifestSecretMagic.lower(value)
}

/**
 * User Preferences relating to submission of transactions.
 */
public struct TransactionPreferences {
    /**
     * The deposit guarantee that will automatically be added for
     * all deposits in transactions.
     */
    public var defaultDepositGuarantee: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The deposit guarantee that will automatically be added for
         * all deposits in transactions.
         */ defaultDepositGuarantee: Decimal192
    ) {
        self.defaultDepositGuarantee = defaultDepositGuarantee
    }
}

extension TransactionPreferences: Sendable {}
extension TransactionPreferences: Equatable, Hashable {
    public static func == (lhs: TransactionPreferences, rhs: TransactionPreferences) -> Bool {
        if lhs.defaultDepositGuarantee != rhs.defaultDepositGuarantee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(defaultDepositGuarantee)
    }
}

public struct FfiConverterTypeTransactionPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionPreferences {
        return
            try TransactionPreferences(
                defaultDepositGuarantee: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.defaultDepositGuarantee, into: &buf)
    }
}

public func FfiConverterTypeTransactionPreferences_lift(_ buf: RustBuffer) throws -> TransactionPreferences {
    return try FfiConverterTypeTransactionPreferences.lift(buf)
}

public func FfiConverterTypeTransactionPreferences_lower(_ value: TransactionPreferences) -> RustBuffer {
    return FfiConverterTypeTransactionPreferences.lower(value)
}

public struct TransactionPreviewResponse {
    /**
     * Hex-encoded binary blob.
     */
    public var encodedReceipt: String
    public var logs: [TransactionPreviewResponseLogsInner]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hex-encoded binary blob.
         */ encodedReceipt: String, logs: [TransactionPreviewResponseLogsInner]
    ) {
        self.encodedReceipt = encodedReceipt
        self.logs = logs
    }
}

extension TransactionPreviewResponse: Sendable {}
extension TransactionPreviewResponse: Equatable, Hashable {
    public static func == (lhs: TransactionPreviewResponse, rhs: TransactionPreviewResponse) -> Bool {
        if lhs.encodedReceipt != rhs.encodedReceipt {
            return false
        }
        if lhs.logs != rhs.logs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encodedReceipt)
        hasher.combine(logs)
    }
}

public struct FfiConverterTypeTransactionPreviewResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionPreviewResponse {
        return
            try TransactionPreviewResponse(
                encodedReceipt: FfiConverterString.read(from: &buf),
                logs: FfiConverterSequenceTypeTransactionPreviewResponseLogsInner.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionPreviewResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.encodedReceipt, into: &buf)
        FfiConverterSequenceTypeTransactionPreviewResponseLogsInner.write(value.logs, into: &buf)
    }
}

public func FfiConverterTypeTransactionPreviewResponse_lift(_ buf: RustBuffer) throws -> TransactionPreviewResponse {
    return try FfiConverterTypeTransactionPreviewResponse.lift(buf)
}

public func FfiConverterTypeTransactionPreviewResponse_lower(_ value: TransactionPreviewResponse) -> RustBuffer {
    return FfiConverterTypeTransactionPreviewResponse.lower(value)
}

public struct TransactionPreviewResponseLogsInner {
    public var level: String
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(level: String, message: String) {
        self.level = level
        self.message = message
    }
}

extension TransactionPreviewResponseLogsInner: Sendable {}
extension TransactionPreviewResponseLogsInner: Equatable, Hashable {
    public static func == (lhs: TransactionPreviewResponseLogsInner, rhs: TransactionPreviewResponseLogsInner) -> Bool {
        if lhs.level != rhs.level {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(level)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeTransactionPreviewResponseLogsInner: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionPreviewResponseLogsInner {
        return
            try TransactionPreviewResponseLogsInner(
                level: FfiConverterString.read(from: &buf),
                message: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionPreviewResponseLogsInner, into buf: inout [UInt8]) {
        FfiConverterString.write(value.level, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeTransactionPreviewResponseLogsInner_lift(_ buf: RustBuffer) throws -> TransactionPreviewResponseLogsInner {
    return try FfiConverterTypeTransactionPreviewResponseLogsInner.lift(buf)
}

public func FfiConverterTypeTransactionPreviewResponseLogsInner_lower(_ value: TransactionPreviewResponseLogsInner) -> RustBuffer {
    return FfiConverterTypeTransactionPreviewResponseLogsInner.lower(value)
}

public struct TransactionSubmitResponse {
    /**
     * Is true if the transaction is a duplicate of an existing pending transaction.
     */
    public var duplicate: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Is true if the transaction is a duplicate of an existing pending transaction.
         */ duplicate: Bool
    ) {
        self.duplicate = duplicate
    }
}

extension TransactionSubmitResponse: Sendable {}
extension TransactionSubmitResponse: Equatable, Hashable {
    public static func == (lhs: TransactionSubmitResponse, rhs: TransactionSubmitResponse) -> Bool {
        if lhs.duplicate != rhs.duplicate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(duplicate)
    }
}

public struct FfiConverterTypeTransactionSubmitResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionSubmitResponse {
        return
            try TransactionSubmitResponse(
                duplicate: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionSubmitResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.duplicate, into: &buf)
    }
}

public func FfiConverterTypeTransactionSubmitResponse_lift(_ buf: RustBuffer) throws -> TransactionSubmitResponse {
    return try FfiConverterTypeTransactionSubmitResponse.lift(buf)
}

public func FfiConverterTypeTransactionSubmitResponse_lower(_ value: TransactionSubmitResponse) -> RustBuffer {
    return FfiConverterTypeTransactionSubmitResponse.lower(value)
}

/**
 * A factor source representing a person, company, organization or otherwise
 * entity that the user trusts to help her with recovery, if ever needed.
 */
public struct TrustedContactFactorSource {
    /**
     * Unique and stable identifier of this factor source.
     */
    public var id: FactorSourceIdFromAddress
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * The contact information about the contact that is 'trusted'.
     */
    public var contact: TrustedContactFactorSourceContact

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source.
         */ id: FactorSourceIdFromAddress,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon,
        /**
            * The contact information about the contact that is 'trusted'.
            */ contact: TrustedContactFactorSourceContact
    ) {
        self.id = id
        self.common = common
        self.contact = contact
    }
}

extension TrustedContactFactorSource: Sendable {}
extension TrustedContactFactorSource: Equatable, Hashable {
    public static func == (lhs: TrustedContactFactorSource, rhs: TrustedContactFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.contact != rhs.contact {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(contact)
    }
}

public struct FfiConverterTypeTrustedContactFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrustedContactFactorSource {
        return
            try TrustedContactFactorSource(
                id: FfiConverterTypeFactorSourceIDFromAddress.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                contact: FfiConverterTypeTrustedContactFactorSourceContact.read(from: &buf)
            )
    }

    public static func write(_ value: TrustedContactFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromAddress.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeTrustedContactFactorSourceContact.write(value.contact, into: &buf)
    }
}

public func FfiConverterTypeTrustedContactFactorSource_lift(_ buf: RustBuffer) throws -> TrustedContactFactorSource {
    return try FfiConverterTypeTrustedContactFactorSource.lift(buf)
}

public func FfiConverterTypeTrustedContactFactorSource_lower(_ value: TrustedContactFactorSource) -> RustBuffer {
    return FfiConverterTypeTrustedContactFactorSource.lower(value)
}

/**
 * Hints about the trusted contact.
 */
public struct TrustedContactFactorSourceContact {
    /**
     * The email address of the contact that the user trusts
     */
    public var emailAddress: EmailAddress
    /**
     * The name of the contact that the user trusts
     */
    public var name: DisplayName

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The email address of the contact that the user trusts
         */ emailAddress: EmailAddress,
        /**
            * The name of the contact that the user trusts
            */ name: DisplayName
    ) {
        self.emailAddress = emailAddress
        self.name = name
    }
}

extension TrustedContactFactorSourceContact: Sendable {}
extension TrustedContactFactorSourceContact: Equatable, Hashable {
    public static func == (lhs: TrustedContactFactorSourceContact, rhs: TrustedContactFactorSourceContact) -> Bool {
        if lhs.emailAddress != rhs.emailAddress {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(emailAddress)
        hasher.combine(name)
    }
}

public struct FfiConverterTypeTrustedContactFactorSourceContact: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrustedContactFactorSourceContact {
        return
            try TrustedContactFactorSourceContact(
                emailAddress: FfiConverterTypeEmailAddress.read(from: &buf),
                name: FfiConverterTypeDisplayName.read(from: &buf)
            )
    }

    public static func write(_ value: TrustedContactFactorSourceContact, into buf: inout [UInt8]) {
        FfiConverterTypeEmailAddress.write(value.emailAddress, into: &buf)
        FfiConverterTypeDisplayName.write(value.name, into: &buf)
    }
}

public func FfiConverterTypeTrustedContactFactorSourceContact_lift(_ buf: RustBuffer) throws -> TrustedContactFactorSourceContact {
    return try FfiConverterTypeTrustedContactFactorSourceContact.lift(buf)
}

public func FfiConverterTypeTrustedContactFactorSourceContact_lower(_ value: TrustedContactFactorSourceContact) -> RustBuffer {
    return FfiConverterTypeTrustedContactFactorSourceContact.lower(value)
}

public struct U11 {
    public var inner: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inner: UInt16) {
        self.inner = inner
    }
}

extension U11: Sendable {}
extension U11: Equatable, Hashable {
    public static func == (lhs: U11, rhs: U11) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeU11: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U11 {
        return
            try U11(
                inner: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: U11, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeU11_lift(_ buf: RustBuffer) throws -> U11 {
    return try FfiConverterTypeU11.lift(buf)
}

public func FfiConverterTypeU11_lower(_ value: U11) -> RustBuffer {
    return FfiConverterTypeU11.lower(value)
}

/**
 * Basic security control of an unsecured entity. When said entity
 * is "securified" it will no longer be controlled by this `UnsecuredEntityControl`
 * but rather by an `AccessControl`. It is a name space holding the
 * single factor instance which was used to create
 */
public struct UnsecuredEntityControl {
    public var transactionSigning: HierarchicalDeterministicFactorInstance
    /**
     * The factor instance which can be used for ROLA.
     */
    public var authenticationSigning: HierarchicalDeterministicFactorInstance?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionSigning: HierarchicalDeterministicFactorInstance,
                /**
                    * The factor instance which can be used for ROLA.
                    */ authenticationSigning: HierarchicalDeterministicFactorInstance?)
    {
        self.transactionSigning = transactionSigning
        self.authenticationSigning = authenticationSigning
    }
}

extension UnsecuredEntityControl: Sendable {}
extension UnsecuredEntityControl: Equatable, Hashable {
    public static func == (lhs: UnsecuredEntityControl, rhs: UnsecuredEntityControl) -> Bool {
        if lhs.transactionSigning != rhs.transactionSigning {
            return false
        }
        if lhs.authenticationSigning != rhs.authenticationSigning {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionSigning)
        hasher.combine(authenticationSigning)
    }
}

public struct FfiConverterTypeUnsecuredEntityControl: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsecuredEntityControl {
        return
            try UnsecuredEntityControl(
                transactionSigning: FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf),
                authenticationSigning: FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
            )
    }

    public static func write(_ value: UnsecuredEntityControl, into buf: inout [UInt8]) {
        FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value.transactionSigning, into: &buf)
        FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.write(value.authenticationSigning, into: &buf)
    }
}

public func FfiConverterTypeUnsecuredEntityControl_lift(_ buf: RustBuffer) throws -> UnsecuredEntityControl {
    return try FfiConverterTypeUnsecuredEntityControl.lift(buf)
}

public func FfiConverterTypeUnsecuredEntityControl_lower(_ value: UnsecuredEntityControl) -> RustBuffer {
    return FfiConverterTypeUnsecuredEntityControl.lower(value)
}

/**
 * The data associated with the various validator claim NFTs
 */
public struct UnstakeData {
    public var name: String
    /**
     * An epoch number at (or after) which the pending unstaked XRD may be claimed.
     */
    public var claimEpoch: Epoch
    /**
     * An XRD amount to be claimed.
     */
    public var claimAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String,
                /**
                    * An epoch number at (or after) which the pending unstaked XRD may be claimed.
                    */ claimEpoch: Epoch,
                /**
                    * An XRD amount to be claimed.
                    */ claimAmount: Decimal192)
    {
        self.name = name
        self.claimEpoch = claimEpoch
        self.claimAmount = claimAmount
    }
}

extension UnstakeData: Sendable {}
extension UnstakeData: Equatable, Hashable {
    public static func == (lhs: UnstakeData, rhs: UnstakeData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.claimEpoch != rhs.claimEpoch {
            return false
        }
        if lhs.claimAmount != rhs.claimAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(claimEpoch)
        hasher.combine(claimAmount)
    }
}

public struct FfiConverterTypeUnstakeData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstakeData {
        return
            try UnstakeData(
                name: FfiConverterString.read(from: &buf),
                claimEpoch: FfiConverterTypeEpoch.read(from: &buf),
                claimAmount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: UnstakeData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeEpoch.write(value.claimEpoch, into: &buf)
        FfiConverterTypeDecimal192.write(value.claimAmount, into: &buf)
    }
}

public func FfiConverterTypeUnstakeData_lift(_ buf: RustBuffer) throws -> UnstakeData {
    return try FfiConverterTypeUnstakeData.lift(buf)
}

public func FfiConverterTypeUnstakeData_lower(_ value: UnstakeData) -> RustBuffer {
    return FfiConverterTypeUnstakeData.lower(value)
}

public struct UnvalidatedTransactionManifest {
    public var transactionManifestString: String
    public var blobs: Blobs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionManifestString: String, blobs: Blobs) {
        self.transactionManifestString = transactionManifestString
        self.blobs = blobs
    }
}

extension UnvalidatedTransactionManifest: Sendable {}
extension UnvalidatedTransactionManifest: Equatable, Hashable {
    public static func == (lhs: UnvalidatedTransactionManifest, rhs: UnvalidatedTransactionManifest) -> Bool {
        if lhs.transactionManifestString != rhs.transactionManifestString {
            return false
        }
        if lhs.blobs != rhs.blobs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionManifestString)
        hasher.combine(blobs)
    }
}

public struct FfiConverterTypeUnvalidatedTransactionManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnvalidatedTransactionManifest {
        return
            try UnvalidatedTransactionManifest(
                transactionManifestString: FfiConverterString.read(from: &buf),
                blobs: FfiConverterTypeBlobs.read(from: &buf)
            )
    }

    public static func write(_ value: UnvalidatedTransactionManifest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.transactionManifestString, into: &buf)
        FfiConverterTypeBlobs.write(value.blobs, into: &buf)
    }
}

public func FfiConverterTypeUnvalidatedTransactionManifest_lift(_ buf: RustBuffer) throws -> UnvalidatedTransactionManifest {
    return try FfiConverterTypeUnvalidatedTransactionManifest.lift(buf)
}

public func FfiConverterTypeUnvalidatedTransactionManifest_lower(_ value: UnvalidatedTransactionManifest) -> RustBuffer {
    return FfiConverterTypeUnvalidatedTransactionManifest.lower(value)
}

/**
 * Address to a Validator that secures the network by validating transactions, users can stake to these
 * validators (Delegated Proof of Stake) by using the Dashboard and sending a TX to the Radix Wallet to sign;
 * e.g.:
 * `"validator_rdx1sd5368vqdmjk0y2w7ymdts02cz9c52858gpyny56xdvzuheepdeyy0"`
 *
 * A `ValidatorAddress` has the [Scrypto's `EntityType`][entt] `GlobalValidator`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalValidatorAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L249-L250
 */
public struct ValidatorAddress {
    fileprivate let secretMagic: RetValidatorAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetValidatorAddress) {
        self.secretMagic = secretMagic
    }
}

extension ValidatorAddress: Sendable {}
extension ValidatorAddress: Equatable, Hashable {
    public static func == (lhs: ValidatorAddress, rhs: ValidatorAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeValidatorAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorAddress {
        return
            try ValidatorAddress(
                secretMagic: FfiConverterTypeRetValidatorAddress.read(from: &buf)
            )
    }

    public static func write(_ value: ValidatorAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetValidatorAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeValidatorAddress_lift(_ buf: RustBuffer) throws -> ValidatorAddress {
    return try FfiConverterTypeValidatorAddress.lift(buf)
}

public func FfiConverterTypeValidatorAddress_lower(_ value: ValidatorAddress) -> RustBuffer {
    return FfiConverterTypeValidatorAddress.lower(value)
}

/**
 * Addresses to a specific vault, owned by a user, holding asset of one kind, either fungible or non-fungible.
 * Identities cannot own assets so they do not have vaults, but Accounts do, e.g.:
 * `"internal_vault_rdx1tz474x29nxxd4k2p2reete9xyz4apawv63dphxkr00qt23vyju49fq"`
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of VaultAddresses:
 * * InternalFungibleVault
 * * InternalNonFungibleVault
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalVaultAddress`][ret], and
 * give it UniFFI support, as a `uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L251-L255
 */
public struct VaultAddress {
    fileprivate let secretMagic: RetVaultAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: RetVaultAddress) {
        self.secretMagic = secretMagic
    }
}

extension VaultAddress: Sendable {}
extension VaultAddress: Equatable, Hashable {
    public static func == (lhs: VaultAddress, rhs: VaultAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeVaultAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VaultAddress {
        return
            try VaultAddress(
                secretMagic: FfiConverterTypeRetVaultAddress.read(from: &buf)
            )
    }

    public static func write(_ value: VaultAddress, into buf: inout [UInt8]) {
        FfiConverterTypeRetVaultAddress.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeVaultAddress_lift(_ buf: RustBuffer) throws -> VaultAddress {
    return try FfiConverterTypeVaultAddress.lift(buf)
}

public func FfiConverterTypeVaultAddress_lower(_ value: VaultAddress) -> RustBuffer {
    return FfiConverterTypeVaultAddress.lower(value)
}

public struct WalletInteractionWalletAccount {
    public var address: AccountAddress
    public var label: DisplayName
    public var appearanceId: AppearanceId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: AccountAddress, label: DisplayName, appearanceId: AppearanceId) {
        self.address = address
        self.label = label
        self.appearanceId = appearanceId
    }
}

extension WalletInteractionWalletAccount: Sendable {}
extension WalletInteractionWalletAccount: Equatable, Hashable {
    public static func == (lhs: WalletInteractionWalletAccount, rhs: WalletInteractionWalletAccount) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(label)
        hasher.combine(appearanceId)
    }
}

public struct FfiConverterTypeWalletInteractionWalletAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionWalletAccount {
        return
            try WalletInteractionWalletAccount(
                address: FfiConverterTypeAccountAddress.read(from: &buf),
                label: FfiConverterTypeDisplayName.read(from: &buf),
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf)
            )
    }

    public static func write(_ value: WalletInteractionWalletAccount, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.label, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
    }
}

public func FfiConverterTypeWalletInteractionWalletAccount_lift(_ buf: RustBuffer) throws -> WalletInteractionWalletAccount {
    return try FfiConverterTypeWalletInteractionWalletAccount.lift(buf)
}

public func FfiConverterTypeWalletInteractionWalletAccount_lower(_ value: WalletInteractionWalletAccount) -> RustBuffer {
    return FfiConverterTypeWalletInteractionWalletAccount.lower(value)
}

public struct WalletToDappInteractionAccountProof {
    public var accountAddress: AccountAddress
    public var proof: WalletToDappInteractionAuthProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accountAddress: AccountAddress, proof: WalletToDappInteractionAuthProof) {
        self.accountAddress = accountAddress
        self.proof = proof
    }
}

extension WalletToDappInteractionAccountProof: Sendable {}
extension WalletToDappInteractionAccountProof: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAccountProof, rhs: WalletToDappInteractionAccountProof) -> Bool {
        if lhs.accountAddress != rhs.accountAddress {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountAddress)
        hasher.combine(proof)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAccountProof {
        return
            try WalletToDappInteractionAccountProof(
                accountAddress: FfiConverterTypeAccountAddress.read(from: &buf),
                proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAccountProof, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.accountAddress, into: &buf)
        FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAccountProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAccountProof {
    return try FfiConverterTypeWalletToDappInteractionAccountProof.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAccountProof_lower(_ value: WalletToDappInteractionAccountProof) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAccountProof.lower(value)
}

public struct WalletToDappInteractionAccountsRequestResponseItem {
    public var accounts: [WalletInteractionWalletAccount]
    public var challenge: DappToWalletInteractionAuthChallengeNonce?
    public var proofs: [WalletToDappInteractionAccountProof]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accounts: [WalletInteractionWalletAccount], challenge: DappToWalletInteractionAuthChallengeNonce?, proofs: [WalletToDappInteractionAccountProof]?) {
        self.accounts = accounts
        self.challenge = challenge
        self.proofs = proofs
    }
}

extension WalletToDappInteractionAccountsRequestResponseItem: Sendable {}
extension WalletToDappInteractionAccountsRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAccountsRequestResponseItem, rhs: WalletToDappInteractionAccountsRequestResponseItem) -> Bool {
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.proofs != rhs.proofs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accounts)
        hasher.combine(challenge)
        hasher.combine(proofs)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAccountsRequestResponseItem {
        return
            try WalletToDappInteractionAccountsRequestResponseItem(
                accounts: FfiConverterSequenceTypeWalletInteractionWalletAccount.read(from: &buf),
                challenge: FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf),
                proofs: FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAccountsRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeWalletInteractionWalletAccount.write(value.accounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
        FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof.write(value.proofs, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAccountsRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem_lower(_ value: WalletToDappInteractionAccountsRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
    public var persona: DappWalletInteractionPersona
    public var challenge: DappToWalletInteractionAuthChallengeNonce
    public var proof: WalletToDappInteractionAuthProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(persona: DappWalletInteractionPersona, challenge: DappToWalletInteractionAuthChallengeNonce, proof: WalletToDappInteractionAuthProof) {
        self.persona = persona
        self.challenge = challenge
        self.proof = proof
    }
}

extension WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: Sendable {}
extension WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem, rhs: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem) -> Bool {
        if lhs.persona != rhs.persona {
            return false
        }
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(persona)
        hasher.combine(challenge)
        hasher.combine(proof)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
        return
            try WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem(
                persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf),
                challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf),
                proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
        FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem_lower(_ value: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
    public var persona: DappWalletInteractionPersona

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(persona: DappWalletInteractionPersona) {
        self.persona = persona
    }
}

extension WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: Sendable {}
extension WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem, rhs: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem) -> Bool {
        if lhs.persona != rhs.persona {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(persona)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
        return
            try WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem(
                persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem_lower(_ value: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionAuthProof {
    public var publicKey: PublicKey
    public var curve: Slip10Curve
    public var signature: Signature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: PublicKey, curve: Slip10Curve, signature: Signature) {
        self.publicKey = publicKey
        self.curve = curve
        self.signature = signature
    }
}

extension WalletToDappInteractionAuthProof: Sendable {}
extension WalletToDappInteractionAuthProof: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthProof, rhs: WalletToDappInteractionAuthProof) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.curve != rhs.curve {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(curve)
        hasher.combine(signature)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthProof {
        return
            try WalletToDappInteractionAuthProof(
                publicKey: FfiConverterTypePublicKey.read(from: &buf),
                curve: FfiConverterTypeSLIP10Curve.read(from: &buf),
                signature: FfiConverterTypeSignature.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthProof, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterTypeSLIP10Curve.write(value.curve, into: &buf)
        FfiConverterTypeSignature.write(value.signature, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthProof {
    return try FfiConverterTypeWalletToDappInteractionAuthProof.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthProof_lower(_ value: WalletToDappInteractionAuthProof) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthProof.lower(value)
}

public struct WalletToDappInteractionAuthUsePersonaRequestResponseItem {
    public var persona: DappWalletInteractionPersona

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(persona: DappWalletInteractionPersona) {
        self.persona = persona
    }
}

extension WalletToDappInteractionAuthUsePersonaRequestResponseItem: Sendable {}
extension WalletToDappInteractionAuthUsePersonaRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthUsePersonaRequestResponseItem, rhs: WalletToDappInteractionAuthUsePersonaRequestResponseItem) -> Bool {
        if lhs.persona != rhs.persona {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(persona)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthUsePersonaRequestResponseItem {
        return
            try WalletToDappInteractionAuthUsePersonaRequestResponseItem(
                persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthUsePersonaRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthUsePersonaRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem_lower(_ value: WalletToDappInteractionAuthUsePersonaRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionAuthorizedRequestResponseItems {
    public var auth: WalletToDappInteractionAuthRequestResponseItem
    public var ongoingAccounts: WalletToDappInteractionAccountsRequestResponseItem?
    public var ongoingPersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?
    public var oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?
    public var oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(auth: WalletToDappInteractionAuthRequestResponseItem, ongoingAccounts: WalletToDappInteractionAccountsRequestResponseItem?, ongoingPersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?, oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?, oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?) {
        self.auth = auth
        self.ongoingAccounts = ongoingAccounts
        self.ongoingPersonaData = ongoingPersonaData
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
    }
}

extension WalletToDappInteractionAuthorizedRequestResponseItems: Sendable {}
extension WalletToDappInteractionAuthorizedRequestResponseItems: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthorizedRequestResponseItems, rhs: WalletToDappInteractionAuthorizedRequestResponseItems) -> Bool {
        if lhs.auth != rhs.auth {
            return false
        }
        if lhs.ongoingAccounts != rhs.ongoingAccounts {
            return false
        }
        if lhs.ongoingPersonaData != rhs.ongoingPersonaData {
            return false
        }
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(auth)
        hasher.combine(ongoingAccounts)
        hasher.combine(ongoingPersonaData)
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthorizedRequestResponseItems {
        return
            try WalletToDappInteractionAuthorizedRequestResponseItems(
                auth: FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.read(from: &buf),
                ongoingAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf),
                ongoingPersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf),
                oneTimeAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf),
                oneTimePersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthorizedRequestResponseItems, into buf: inout [UInt8]) {
        FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.write(value.auth, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.ongoingAccounts, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.ongoingPersonaData, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.oneTimePersonaData, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthorizedRequestResponseItems {
    return try FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems_lower(_ value: WalletToDappInteractionAuthorizedRequestResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.lower(value)
}

public struct WalletToDappInteractionFailureResponse {
    public var interactionId: WalletInteractionId
    public var error: DappWalletInteractionErrorType
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, error: DappWalletInteractionErrorType, message: String?) {
        self.interactionId = interactionId
        self.error = error
        self.message = message
    }
}

extension WalletToDappInteractionFailureResponse: Sendable {}
extension WalletToDappInteractionFailureResponse: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionFailureResponse, rhs: WalletToDappInteractionFailureResponse) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(error)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeWalletToDappInteractionFailureResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionFailureResponse {
        return
            try WalletToDappInteractionFailureResponse(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                error: FfiConverterTypeDappWalletInteractionErrorType.read(from: &buf),
                message: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionFailureResponse, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeDappWalletInteractionErrorType.write(value.error, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionFailureResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionFailureResponse {
    return try FfiConverterTypeWalletToDappInteractionFailureResponse.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionFailureResponse_lower(_ value: WalletToDappInteractionFailureResponse) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionFailureResponse.lower(value)
}

public struct WalletToDappInteractionPersonaDataRequestResponseItem {
    public var name: PersonaDataEntryName?
    public var emailAddresses: [EmailAddress]?
    public var phoneNumbers: [PersonaDataEntryPhoneNumber]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: PersonaDataEntryName?, emailAddresses: [EmailAddress]?, phoneNumbers: [PersonaDataEntryPhoneNumber]?) {
        self.name = name
        self.emailAddresses = emailAddresses
        self.phoneNumbers = phoneNumbers
    }
}

extension WalletToDappInteractionPersonaDataRequestResponseItem: Sendable {}
extension WalletToDappInteractionPersonaDataRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionPersonaDataRequestResponseItem, rhs: WalletToDappInteractionPersonaDataRequestResponseItem) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(emailAddresses)
        hasher.combine(phoneNumbers)
    }
}

public struct FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionPersonaDataRequestResponseItem {
        return
            try WalletToDappInteractionPersonaDataRequestResponseItem(
                name: FfiConverterOptionTypePersonaDataEntryName.read(from: &buf),
                emailAddresses: FfiConverterOptionSequenceTypeEmailAddress.read(from: &buf),
                phoneNumbers: FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionPersonaDataRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataEntryName.write(value.name, into: &buf)
        FfiConverterOptionSequenceTypeEmailAddress.write(value.emailAddresses, into: &buf)
        FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber.write(value.phoneNumbers, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionPersonaDataRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem_lower(_ value: WalletToDappInteractionPersonaDataRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionSendTransactionResponseItem {
    public var transactionIntentHash: IntentHash

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionIntentHash: IntentHash) {
        self.transactionIntentHash = transactionIntentHash
    }
}

extension WalletToDappInteractionSendTransactionResponseItem: Sendable {}
extension WalletToDappInteractionSendTransactionResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionSendTransactionResponseItem, rhs: WalletToDappInteractionSendTransactionResponseItem) -> Bool {
        if lhs.transactionIntentHash != rhs.transactionIntentHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionIntentHash)
    }
}

public struct FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSendTransactionResponseItem {
        return
            try WalletToDappInteractionSendTransactionResponseItem(
                transactionIntentHash: FfiConverterTypeIntentHash.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionSendTransactionResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeIntentHash.write(value.transactionIntentHash, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSendTransactionResponseItem {
    return try FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem_lower(_ value: WalletToDappInteractionSendTransactionResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.lower(value)
}

public struct WalletToDappInteractionSuccessResponse {
    public var interactionId: WalletInteractionId
    public var items: WalletToDappInteractionResponseItems

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, items: WalletToDappInteractionResponseItems) {
        self.interactionId = interactionId
        self.items = items
    }
}

extension WalletToDappInteractionSuccessResponse: Sendable {}
extension WalletToDappInteractionSuccessResponse: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionSuccessResponse, rhs: WalletToDappInteractionSuccessResponse) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(items)
    }
}

public struct FfiConverterTypeWalletToDappInteractionSuccessResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSuccessResponse {
        return
            try WalletToDappInteractionSuccessResponse(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                items: FfiConverterTypeWalletToDappInteractionResponseItems.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionSuccessResponse, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeWalletToDappInteractionResponseItems.write(value.items, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionSuccessResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSuccessResponse {
    return try FfiConverterTypeWalletToDappInteractionSuccessResponse.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionSuccessResponse_lower(_ value: WalletToDappInteractionSuccessResponse) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionSuccessResponse.lower(value)
}

public struct WalletToDappInteractionTransactionResponseItems {
    public var send: WalletToDappInteractionSendTransactionResponseItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(send: WalletToDappInteractionSendTransactionResponseItem) {
        self.send = send
    }
}

extension WalletToDappInteractionTransactionResponseItems: Sendable {}
extension WalletToDappInteractionTransactionResponseItems: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionTransactionResponseItems, rhs: WalletToDappInteractionTransactionResponseItems) -> Bool {
        if lhs.send != rhs.send {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(send)
    }
}

public struct FfiConverterTypeWalletToDappInteractionTransactionResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionTransactionResponseItems {
        return
            try WalletToDappInteractionTransactionResponseItems(
                send: FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionTransactionResponseItems, into buf: inout [UInt8]) {
        FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.write(value.send, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionTransactionResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionTransactionResponseItems {
    return try FfiConverterTypeWalletToDappInteractionTransactionResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionTransactionResponseItems_lower(_ value: WalletToDappInteractionTransactionResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionTransactionResponseItems.lower(value)
}

public struct WalletToDappInteractionUnauthorizedRequestResponseItems {
    public var oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?
    public var oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?, oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?) {
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
    }
}

extension WalletToDappInteractionUnauthorizedRequestResponseItems: Sendable {}
extension WalletToDappInteractionUnauthorizedRequestResponseItems: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionUnauthorizedRequestResponseItems, rhs: WalletToDappInteractionUnauthorizedRequestResponseItems) -> Bool {
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
    }
}

public struct FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionUnauthorizedRequestResponseItems {
        return
            try WalletToDappInteractionUnauthorizedRequestResponseItems(
                oneTimeAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf),
                oneTimePersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionUnauthorizedRequestResponseItems, into buf: inout [UInt8]) {
        FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.oneTimePersonaData, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionUnauthorizedRequestResponseItems {
    return try FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems_lower(_ value: WalletToDappInteractionUnauthorizedRequestResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AccountOrAddressOf {
    case profileAccount(value: Account
    )
    case addressOfExternalAccount(value: AccountAddress
    )
}

public struct FfiConverterTypeAccountOrAddressOf: FfiConverterRustBuffer {
    typealias SwiftType = AccountOrAddressOf

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountOrAddressOf {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .profileAccount(value: FfiConverterTypeAccount.read(from: &buf)
            )

        case 2: return try .addressOfExternalAccount(value: FfiConverterTypeAccountAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountOrAddressOf, into buf: inout [UInt8]) {
        switch value {
        case let .profileAccount(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccount.write(value, into: &buf)

        case let .addressOfExternalAccount(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountAddress.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeAccountOrAddressOf_lift(_ buf: RustBuffer) throws -> AccountOrAddressOf {
    return try FfiConverterTypeAccountOrAddressOf.lift(buf)
}

public func FfiConverterTypeAccountOrAddressOf_lower(_ value: AccountOrAddressOf) -> RustBuffer {
    return FfiConverterTypeAccountOrAddressOf.lower(value)
}

extension AccountOrAddressOf: Sendable {}
extension AccountOrAddressOf: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either an `Account` or a `Persona`.
 */

public enum AccountOrPersona {
    /**
     * An `Account`
     *
     * Note:
     * This case/variant can not be named `account`/ `Account` due
     * to Kotlin UniFFI limitation.
     */
    case accountEntity(Account
    )
    /**
     * A `Persona`
     *
     * Note:
     * This is named `personaEntity` / `PersonaEntity` to match
     * `accountEntity` / `AccountEntity` which can not be named
     * `account`/ `Account` due to Kotlin UniFFI limitation.
     */
    case personaEntity(Persona
    )
}

public struct FfiConverterTypeAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = AccountOrPersona

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountOrPersona {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .accountEntity(FfiConverterTypeAccount.read(from: &buf)
            )

        case 2: return try .personaEntity(FfiConverterTypePersona.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountOrPersona, into buf: inout [UInt8]) {
        switch value {
        case let .accountEntity(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccount.write(v1, into: &buf)

        case let .personaEntity(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypePersona.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeAccountOrPersona_lift(_ buf: RustBuffer) throws -> AccountOrPersona {
    return try FfiConverterTypeAccountOrPersona.lift(buf)
}

public func FfiConverterTypeAccountOrPersona_lower(_ value: AccountOrPersona) -> RustBuffer {
    return FfiConverterTypeAccountOrPersona.lower(value)
}

extension AccountOrPersona: Sendable {}
extension AccountOrPersona: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of addresses.
 *
 * Does not include `LegacyOlympiaAccountAddress` nor `NonFungibleResourceAddress`
 */

public enum Address {
    case accessController(AccessControllerAddress
    )
    case account(AccountAddress
    )
    case component(ComponentAddress
    )
    case identity(IdentityAddress
    )
    case package(PackageAddress
    )
    case pool(PoolAddress
    )
    case resource(ResourceAddress
    )
    case validator(ValidatorAddress
    )
    case vault(VaultAddress
    )
}

public struct FfiConverterTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = Address

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .accessController(FfiConverterTypeAccessControllerAddress.read(from: &buf)
            )

        case 2: return try .account(FfiConverterTypeAccountAddress.read(from: &buf)
            )

        case 3: return try .component(FfiConverterTypeComponentAddress.read(from: &buf)
            )

        case 4: return try .identity(FfiConverterTypeIdentityAddress.read(from: &buf)
            )

        case 5: return try .package(FfiConverterTypePackageAddress.read(from: &buf)
            )

        case 6: return try .pool(FfiConverterTypePoolAddress.read(from: &buf)
            )

        case 7: return try .resource(FfiConverterTypeResourceAddress.read(from: &buf)
            )

        case 8: return try .validator(FfiConverterTypeValidatorAddress.read(from: &buf)
            )

        case 9: return try .vault(FfiConverterTypeVaultAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        switch value {
        case let .accessController(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccessControllerAddress.write(v1, into: &buf)

        case let .account(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountAddress.write(v1, into: &buf)

        case let .component(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeComponentAddress.write(v1, into: &buf)

        case let .identity(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeIdentityAddress.write(v1, into: &buf)

        case let .package(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypePackageAddress.write(v1, into: &buf)

        case let .pool(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypePoolAddress.write(v1, into: &buf)

        case let .resource(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeResourceAddress.write(v1, into: &buf)

        case let .validator(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeValidatorAddress.write(v1, into: &buf)

        case let .vault(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeVaultAddress.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeAddress_lift(_ buf: RustBuffer) throws -> Address {
    return try FfiConverterTypeAddress.lift(buf)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> RustBuffer {
    return FfiConverterTypeAddress.lower(value)
}

extension Address: Sendable {}
extension Address: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AddressFormat {
    case full
    case raw
    case `default`
}

public struct FfiConverterTypeAddressFormat: FfiConverterRustBuffer {
    typealias SwiftType = AddressFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .full

        case 2: return .raw

        case 3: return .default

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressFormat, into buf: inout [UInt8]) {
        switch value {
        case .full:
            writeInt(&buf, Int32(1))

        case .raw:
            writeInt(&buf, Int32(2))

        case .default:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeAddressFormat_lift(_ buf: RustBuffer) throws -> AddressFormat {
    return try FfiConverterTypeAddressFormat.lift(buf)
}

public func FfiConverterTypeAddressFormat_lower(_ value: AddressFormat) -> RustBuffer {
    return FfiConverterTypeAddressFormat.lower(value)
}

extension AddressFormat: Sendable {}
extension AddressFormat: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of addresses of either an Account or a Persona (IdentityAddress)
 */

public enum AddressOfAccountOrPersona {
    case account(AccountAddress
    )
    case identity(IdentityAddress
    )
}

public struct FfiConverterTypeAddressOfAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = AddressOfAccountOrPersona

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressOfAccountOrPersona {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .account(FfiConverterTypeAccountAddress.read(from: &buf)
            )

        case 2: return try .identity(FfiConverterTypeIdentityAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressOfAccountOrPersona, into buf: inout [UInt8]) {
        switch value {
        case let .account(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountAddress.write(v1, into: &buf)

        case let .identity(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeIdentityAddress.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeAddressOfAccountOrPersona_lift(_ buf: RustBuffer) throws -> AddressOfAccountOrPersona {
    return try FfiConverterTypeAddressOfAccountOrPersona.lift(buf)
}

public func FfiConverterTypeAddressOfAccountOrPersona_lower(_ value: AddressOfAccountOrPersona) -> RustBuffer {
    return FfiConverterTypeAddressOfAccountOrPersona.lower(value)
}

extension AddressOfAccountOrPersona: Sendable {}
extension AddressOfAccountOrPersona: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The model of a Arculus Card.
 */

public enum ArculusCardModel {
    /**
     * Arculus card model: "Arculus Cold Storage Wallet",
     * for more info [see][link].
     *
     * [link]: https://www.getarculus.com/products/arculus-cold-storage-wallet.html
     */
    case arculusColdStorageWallet
}

public struct FfiConverterTypeArculusCardModel: FfiConverterRustBuffer {
    typealias SwiftType = ArculusCardModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCardModel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .arculusColdStorageWallet

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ArculusCardModel, into buf: inout [UInt8]) {
        switch value {
        case .arculusColdStorageWallet:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeArculusCardModel_lift(_ buf: RustBuffer) throws -> ArculusCardModel {
    return try FfiConverterTypeArculusCardModel.lift(buf)
}

public func FfiConverterTypeArculusCardModel_lower(_ value: ArculusCardModel) -> RustBuffer {
    return FfiConverterTypeArculusCardModel.lower(value)
}

extension ArculusCardModel: Sendable {}
extension ArculusCardModel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Indicates whether the Wallet should show direct deposit claims for the given Dapp.
 */

public enum AuthorizedDappPreferenceDeposits {
    case hidden
    case visible
}

public struct FfiConverterTypeAuthorizedDappPreferenceDeposits: FfiConverterRustBuffer {
    typealias SwiftType = AuthorizedDappPreferenceDeposits

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappPreferenceDeposits {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .hidden

        case 2: return .visible

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthorizedDappPreferenceDeposits, into buf: inout [UInt8]) {
        switch value {
        case .hidden:
            writeInt(&buf, Int32(1))

        case .visible:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeAuthorizedDappPreferenceDeposits_lift(_ buf: RustBuffer) throws -> AuthorizedDappPreferenceDeposits {
    return try FfiConverterTypeAuthorizedDappPreferenceDeposits.lift(buf)
}

public func FfiConverterTypeAuthorizedDappPreferenceDeposits_lower(_ value: AuthorizedDappPreferenceDeposits) -> RustBuffer {
    return FfiConverterTypeAuthorizedDappPreferenceDeposits.lower(value)
}

extension AuthorizedDappPreferenceDeposits: Sendable {}
extension AuthorizedDappPreferenceDeposits: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * BIP39 entropy, ranging from 16-32 bytes with discrete values being multiples of in between the range.
 */

public enum Bip39Entropy {
    case entropyOf16Bytes(Entropy16Bytes
    )
    case entropyOf20Bytes(Entropy20Bytes
    )
    case entropyOf24Bytes(Entropy24Bytes
    )
    case entropyOf28Bytes(Entropy28Bytes
    )
    case entropyOf32Bytes(Entropy32Bytes
    )
}

public struct FfiConverterTypeBIP39Entropy: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Entropy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Entropy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .entropyOf16Bytes(FfiConverterTypeEntropy16Bytes.read(from: &buf)
            )

        case 2: return try .entropyOf20Bytes(FfiConverterTypeEntropy20Bytes.read(from: &buf)
            )

        case 3: return try .entropyOf24Bytes(FfiConverterTypeEntropy24Bytes.read(from: &buf)
            )

        case 4: return try .entropyOf28Bytes(FfiConverterTypeEntropy28Bytes.read(from: &buf)
            )

        case 5: return try .entropyOf32Bytes(FfiConverterTypeEntropy32Bytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Entropy, into buf: inout [UInt8]) {
        switch value {
        case let .entropyOf16Bytes(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEntropy16Bytes.write(v1, into: &buf)

        case let .entropyOf20Bytes(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEntropy20Bytes.write(v1, into: &buf)

        case let .entropyOf24Bytes(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEntropy24Bytes.write(v1, into: &buf)

        case let .entropyOf28Bytes(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeEntropy28Bytes.write(v1, into: &buf)

        case let .entropyOf32Bytes(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEntropy32Bytes.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeBIP39Entropy_lift(_ buf: RustBuffer) throws -> Bip39Entropy {
    return try FfiConverterTypeBIP39Entropy.lift(buf)
}

public func FfiConverterTypeBIP39Entropy_lower(_ value: Bip39Entropy) -> RustBuffer {
    return FfiConverterTypeBIP39Entropy.lower(value)
}

extension Bip39Entropy: Sendable {}
extension Bip39Entropy: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Language to be used for the mnemonic phrase.
 *
 * The English language is always available, other languages are enabled using
 * the compilation features.
 */

public enum Bip39Language {
    /**
     * The English language.
     */
    case english
    /**
     * The French language.
     */
    case french
}

public struct FfiConverterTypeBIP39Language: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Language

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Language {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .english

        case 2: return .french

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Language, into buf: inout [UInt8]) {
        switch value {
        case .english:
            writeInt(&buf, Int32(1))

        case .french:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeBIP39Language_lift(_ buf: RustBuffer) throws -> Bip39Language {
    return try FfiConverterTypeBIP39Language.lift(buf)
}

public func FfiConverterTypeBIP39Language_lower(_ value: Bip39Language) -> RustBuffer {
    return FfiConverterTypeBIP39Language.lower(value)
}

extension Bip39Language: Sendable {}
extension Bip39Language: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
 * standard, a multiple of 3, from 12 to 24 words. All "Babylon" `DeviceFactorSource`s
 * use 24 words.
 */

public enum Bip39WordCount: UInt8 {
    /**
     * 24 words, used by all "Babylon" `DeviceFactorSource`s
     */
    case twentyFour = 24
    /**
     * 21 words, potentially used by third-party Olympia wallets.
     */
    case twentyOne = 21
    /**
     * 18 words, potentially used by third-party Olympia wallets.
     */
    case eighteen = 18
    /**
     * 15 words, potentially used by third-party Olympia wallets.
     */
    case fifteen = 15
    /**
     * 12 words, used by Radix Olympia legacy wallet.
     */
    case twelve = 12
}

public struct FfiConverterTypeBIP39WordCount: FfiConverterRustBuffer {
    typealias SwiftType = Bip39WordCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39WordCount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .twentyFour

        case 2: return .twentyOne

        case 3: return .eighteen

        case 4: return .fifteen

        case 5: return .twelve

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39WordCount, into buf: inout [UInt8]) {
        switch value {
        case .twentyFour:
            writeInt(&buf, Int32(1))

        case .twentyOne:
            writeInt(&buf, Int32(2))

        case .eighteen:
            writeInt(&buf, Int32(3))

        case .fifteen:
            writeInt(&buf, Int32(4))

        case .twelve:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeBIP39WordCount_lift(_ buf: RustBuffer) throws -> Bip39WordCount {
    return try FfiConverterTypeBIP39WordCount.lift(buf)
}

public func FfiConverterTypeBIP39WordCount_lower(_ value: Bip39WordCount) -> RustBuffer {
    return FfiConverterTypeBIP39WordCount.lower(value)
}

extension Bip39WordCount: Sendable {}
extension Bip39WordCount: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Account or Identity (used by Personas) part of a CAP26 derivation
 * path.
 */

public enum Cap26EntityKind: UInt32 {
    /**
     * An Account entity type
     */
    case account = 525
    /**
     * An Identity entity type (used by Personas)
     */
    case identity = 618
}

public struct FfiConverterTypeCAP26EntityKind: FfiConverterRustBuffer {
    typealias SwiftType = Cap26EntityKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26EntityKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .account

        case 2: return .identity

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26EntityKind, into buf: inout [UInt8]) {
        switch value {
        case .account:
            writeInt(&buf, Int32(1))

        case .identity:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeCAP26EntityKind_lift(_ buf: RustBuffer) throws -> Cap26EntityKind {
    return try FfiConverterTypeCAP26EntityKind.lift(buf)
}

public func FfiConverterTypeCAP26EntityKind_lower(_ value: Cap26EntityKind) -> RustBuffer {
    return FfiConverterTypeCAP26EntityKind.lower(value)
}

extension Cap26EntityKind: Sendable {}
extension Cap26EntityKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Cap26KeyKind: UInt32 {
    /**
     * For a key to be used for signing transactions.
     * The value is the ascii sum of `"TRANSACTION_SIGNING"`
     */
    case transactionSigning = 1460
    /**
     * For a key to be used for signing authentication..
     * The value is the ascii sum of `"AUTHENTICATION_SIGNING"`
     */
    case authenticationSigning = 1678
    /**
     * For a key to be used for encrypting messages.
     * The value is the ascii sum of `"MESSAGE_ENCRYPTION"`
     */
    case messageEncryption = 1391
}

public struct FfiConverterTypeCAP26KeyKind: FfiConverterRustBuffer {
    typealias SwiftType = Cap26KeyKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26KeyKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .transactionSigning

        case 2: return .authenticationSigning

        case 3: return .messageEncryption

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26KeyKind, into buf: inout [UInt8]) {
        switch value {
        case .transactionSigning:
            writeInt(&buf, Int32(1))

        case .authenticationSigning:
            writeInt(&buf, Int32(2))

        case .messageEncryption:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeCAP26KeyKind_lift(_ buf: RustBuffer) throws -> Cap26KeyKind {
    return try FfiConverterTypeCAP26KeyKind.lift(buf)
}

public func FfiConverterTypeCAP26KeyKind_lower(_ value: Cap26KeyKind) -> RustBuffer {
    return FfiConverterTypeCAP26KeyKind.lower(value)
}

extension Cap26KeyKind: Sendable {}
extension Cap26KeyKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A derivation path design specifically for Radix Babylon wallets used by Accounts and Personas
 * to be unique per network with separate key spaces for Accounts/Identities (Personas) and key
 * kind: sign transaction or sign auth.
 */

public enum Cap26Path {
    case getId(value: GetIdPath
    )
    case account(value: AccountPath
    )
    case identity(value: IdentityPath
    )
}

public struct FfiConverterTypeCAP26Path: FfiConverterRustBuffer {
    typealias SwiftType = Cap26Path

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26Path {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .getId(value: FfiConverterTypeGetIDPath.read(from: &buf)
            )

        case 2: return try .account(value: FfiConverterTypeAccountPath.read(from: &buf)
            )

        case 3: return try .identity(value: FfiConverterTypeIdentityPath.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26Path, into buf: inout [UInt8]) {
        switch value {
        case let .getId(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeGetIDPath.write(value, into: &buf)

        case let .account(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountPath.write(value, into: &buf)

        case let .identity(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeIdentityPath.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeCAP26Path_lift(_ buf: RustBuffer) throws -> Cap26Path {
    return try FfiConverterTypeCAP26Path.lift(buf)
}

public func FfiConverterTypeCAP26Path_lower(_ value: Cap26Path) -> RustBuffer {
    return FfiConverterTypeCAP26Path.lower(value)
}

extension Cap26Path: Sendable {}
extension Cap26Path: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * When user changes `current` Gateway in AppPreferences host clients should
 * make it so that they can only change to non current gateway, this small type
 * represents the outcome of switching, e.g. if they just switched to a "new"
 * network, i.e. if the gateway was in `other` list in saved gateways, or if
 * we just added it.
 */

public enum ChangeGatewayOutcome {
    /**
     * If we did in fact change the gateway, and if the gateway was unknown
     * or known before it was added, i.e. `is_new` will be true iff the gateway
     * was unknown before changing to it.
     */
    case didChange(
        /**
         * If the Gateway we just switched to already was in the `other` list of
         * saved gateways in AppPreferences, or if it was entirely new.
         */ isNew: Bool
    )
    /**
     * We tried to change to the current gateway.
     */
    case noChange
}

public struct FfiConverterTypeChangeGatewayOutcome: FfiConverterRustBuffer {
    typealias SwiftType = ChangeGatewayOutcome

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChangeGatewayOutcome {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .didChange(isNew: FfiConverterBool.read(from: &buf)
            )

        case 2: return .noChange

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChangeGatewayOutcome, into buf: inout [UInt8]) {
        switch value {
        case let .didChange(isNew):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(isNew, into: &buf)

        case .noChange:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeChangeGatewayOutcome_lift(_ buf: RustBuffer) throws -> ChangeGatewayOutcome {
    return try FfiConverterTypeChangeGatewayOutcome.lift(buf)
}

public func FfiConverterTypeChangeGatewayOutcome_lower(_ value: ChangeGatewayOutcome) -> RustBuffer {
    return FfiConverterTypeChangeGatewayOutcome.lower(value)
}

extension ChangeGatewayOutcome: Sendable {}
extension ChangeGatewayOutcome: Equatable, Hashable {}

public enum CommonError {
    case Unknown
    case InvalidEd25519PrivateKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidEd25519PrivateKeyFromString(badValue: String
    )
    case InvalidSecp256k1PrivateKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidSecp256k1PrivateKeyFromString(badValue: String
    )
    case InvalidEd25519PublicKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidEd25519PublicKeyFromString(badValue: String
    )
    case InvalidSecp256k1PublicKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidSecp256k1PublicKeyFromString(badValue: String
    )
    case InvalidSecp256k1PublicKeyPointNotOnCurve
    case InvalidEd25519PublicKeyPointNotOnCurve
    case StringNotHex(badValue: String
    )
    case InvalidByteCount(expected: UInt64, found: UInt64)
    case InvalidBip32Path(badValue: String
    )
    case InvalidDepthOfBip44Path(expected: UInt64, found: UInt64)
    case InvalidBip44LikePathAccountWasNotHardened
    case InvalidBip44LikePathChangeWasUnexpectedlyHardened
    case InvalidDepthOfCap26Path(expected: UInt64, found: UInt64)
    case NotAllComponentsAreHardened
    case Bip44PurposeNotFound(badValue: UInt32
    )
    case CoinTypeNotFound(badValue: UInt32
    )
    case InvalidNetworkIdExceedsLimit(badValue: UInt32
    )
    case InvalidEntityKind(badValue: UInt32
    )
    case WrongEntityKind(expected: Cap26EntityKind, found: Cap26EntityKind)
    case InvalidKeyKind(badValue: UInt32
    )
    case UnsupportedNetworkId(badValue: UInt8
    )
    case InvalidGetIdPath(badValue: UInt32
    )
    case UnknownBip39Word
    case InvalidMnemonicPhrase
    case InvalidBip39WordCount(badValue: UInt64
    )
    case InvalidAppearanceId(badValue: UInt8
    )
    case InvalidAccountAddress(badValue: String
    )
    case UnsupportedEntityType
    case FailedToDecodeAddressFromBech32(badValue: String
    )
    case MismatchingEntityTypeWhileDecodingAddress
    case MismatchingHrpWhileDecodingAddress
    case UnknownNetworkId(badValue: UInt8
    )
    case InvalidNonFungibleGlobalId(badValue: String
    )
    case FactorSourceCryptoParametersSupportedCurvesInvalidSize
    case BadgeIsNotVirtualHierarchicalDeterministic
    case FactorSourceIdNotFromHash
    case ExpectedAccountPathButGotSomethingElse
    case WrongEntityKindOfInFactorInstancesPath
    case WrongKeyKindOfTransactionSigningFactorInstance
    case WrongKeyKindOfAuthenticationSigningFactorInstance
    case ExpectedDeviceFactorSourceGotSomethingElse
    case ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse
    case UnknownNetworkWithName(badValue: String
    )
    case UnknownNetworkForId(badValue: UInt8
    )
    case GatewaysDiscrepancyOtherShouldNotContainCurrent
    case InvalidGatewaysJsonCurrentNotFoundAmongstSaved
    case InvalidUrl(badValue: String
    )
    case AccountOnWrongNetwork(expected: NetworkId, found: NetworkId)
    case FactorSourcesMustNotBeEmpty
    case UpdateFactorSourceMutateFailed
    case CastFactorSourceWrongKind(expected: FactorSourceKind, found: FactorSourceKind)
    case InvalidLength(expected: UInt64, found: UInt64, data: BagOfBytes)
    case InvalidNonFungibleLocalIdString
    case InvalidNonFungibleLocalIdBytes
    case DecimalError
    case InvalidBip39Index(badValue: UInt16
    )
    case InvalidDisplayNameEmpty
    case Free
    case InvalidIso8601String(badValue: String
    )
    case UnknownAccount
    case SecureStorageReadError
    case UnableToLoadDeviceFactorSourceFromSecureStorage
    case SecureStorageWriteError
    case FailedToSerializeToJson
    case FailedToDeserializeJsonToValue(jsonByteCount: UInt64, typeName: String, serdeMessage: String)
    case InvalidProfileId(badValue: String
    )
    case FailedToLoadProfileHeadersList
    case ProfileDoesNotContainFactorSourceWithId(badValue: FactorSourceId
    )
    case AccountAlreadyPresent(badValue: AccountAddress
    )
    case UnableToAcquireWriteLockForProfile
    case UnableToSaveMnemonicToSecureStorage(badValue: FactorSourceIdFromHash
    )
    case UnableToLoadMnemonicFromSecureStorage(badValue: FactorSourceIdFromHash
    )
    case UnableToSaveFactorSourceToProfile(badValue: FactorSourceId
    )
    case ExpectedIdentityPathButGotSomethingElse
    case PersonaDataInvalidPhoneNumberEmpty
    case EmailAddressEmpty
    case PersonaDataInvalidNameFamilyNameEmpty
    case PersonaDataInvalidNameGivenNamesEmpty
    case InvalidUuiDv4(badValue: String
    )
    case UnrecognizedLocaleIdentifier(badValue: String
    )
    case FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(nodeIdAsHex: String, networkId: NetworkId)
    case InvalidOlympiaAddressString(badValue: String
    )
    case InvalidInstructionsString(underlying: String
    )
    case ExecutionSummaryFail(underlying: String
    )
    case FailedToDecodeEncodedReceipt
    case BytesEmpty
    case TooManyBytes(max: UInt64, found: UInt64)
    case InvalidInstructionsWrongNetwork(foundInInstructions: NetworkId, specifiedToInstructionsCtor: NetworkId)
    case FailedToUniFfiDecodeBytesToManifestInstructions
    case FailedToDecodeTransactionHash(badValue: String
    )
    case FailedToHashIntent
    case EncryptedMessagesAreNotYetSupported
    case FailedToBech32DecodeTransactionHashAfterHavingTestedAllNetworkId(badValue: String
    )
    case FailedToParseSignatureFromString(badValue: String
    )
    case InvalidSignaturesForIntentSomeDidNotValidateIntentHash
    case FailedToDecompileBytesIntoNotarizedTransaction
    case FailedToRecoverSecp256k1PublicKeyFromSignature
    case FungibleResourceAddressNotAcceptedInNonFungibleContext
    case DecimalOverflow(badValue: String
    )
    case InvalidAddressNotOlympiaMainnet(badValue: String
    )
    case FailedToParseSignatureFromBytes(badValue: String
    )
    case InvalidIntentFailedToEncode(underlying: String
    )
    case InvalidInstructionsFailedToDecompile(underlying: String
    )
    case InvalidTransactionMaxSborDepthExceeded(max: UInt16
    )
    case InvalidSignedIntentFailedToEncode(underlying: String
    )
    case InvalidNotarizedIntentFailedToEncode(underlying: String
    )
    case NetworkResponseBadCode
    case NetworkResponseEmptyBody
    case NetworkResponseJsonDeserialize(intoType: String
    )
    case NetworkRequestInvalidUrl(badValue: String
    )
    case NetworkRequestGenericFailure(underlying: String
    )
    case GatewaySubmitDuplicateTx(intentHash: String
    )
    case SupportedCurvesMustNotBeEmpty
    case ProfileNetworksMustNotBeEmpty
    case UnknownSlip10Curve(badValue: String
    )
    case AesDecryptionFailed
    case InvalidAesBytesTooShort(expectedAtLeast: UInt64, found: UInt64)
    case InvalidFactorSourceKind(badValue: String
    )
    case InvalidLedgerHardwareWalletModel(badValue: String
    )
    case RadixConnectMobileInvalidRequestUrl(badValue: String
    )
    case RadixConnectMobileInvalidOrigin(badValue: String
    )
    case RadixConnectMobileInvalidSessionId(badValue: String
    )
    case RadixMobileInvalidInteractionId(badValue: String
    )
    case NetworkDiscrepancy(expected: NetworkId, actual: NetworkId)
    case DiscrepancyAuthorizedDappReferencedPersonaWhichDoesNotExist(address: IdentityAddress
    )
    case DiscrepancyAuthorizedDappReferencedAccountWhichDoesNotExist(address: AccountAddress
    )
    case AuthorizedDappReferencesFieldIdThatDoesNotExist
    case ElementDoesNotExist(id: String
    )
    case IdentifiableItemAlreadyExist(id: String
    )
    case InvalidRadixConnectPurpose(badValue: String
    )
    case TxGuaranteeIndexOutOfBounds(index: UInt64, count: UInt64)
    case InvalidKeyAgreementPublicKeyFromHex(badValue: String
    )
    case InvalidKeyAgreementPublicKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidKeyAgreementPrivateKeyFromBytes(badValue: BagOfBytes
    )
    case RadixConnectMobileSessionNotFound(sessionId: SessionId
    )
    case RadixConnectMobileDappRequestNotFound(interactionId: WalletInteractionId
    )
    case RadixConnectMobileDappCallbackPathNotFound(origin: Url
    )
    case InvalidEd25519SignatureFromString(badValue: String
    )
    case RadixConnectMobileDappPublicKeyMismatch
    case RadixConnectMobileDappIdentityMismatch
    case RadixConnectMobileDappOriginMismatch
    case RadixConnectMobileInvalidDappSignature
    case RadixConnectMobileInvalidRequestFormat
    case RadixConnectMobileFailedToCreateNewSession
    case DeferredDeepLinkInvalidValueFormat(badValue: String
    )
    case FailedUpdatingHomeCards
    case EntityNotFound
    case HomeCardsNotFound
    case FailedSavingHomeCards
    case UnableToLoadProfileFromSecureStorage(profileId: ProfileId
    )
    case UnableToSaveHostIdToSecureStorage
    case UnableToAcquireReadLockForProfile
    case UnsafeStorageReadError
    case UnsafeStorageWriteError
    case FailedToCreateFilePathFromString(badValue: String
    )
    case ExpectedNonEmptyCollection
    case UnableToAddAllAccountsDuplicatesFound
    case ProfileUsedOnOtherDevice(otherDeviceId: DeviceId, thisDeviceId: DeviceId)
    case InvalidDeviceId(badValue: String
    )
    case TriedToUpdateProfileWithOneWithDifferentId
    case InvalidPath(badValue: String
    )
    case FailedToSaveFile(path: String
    )
    case FailedToLoadFile(path: String
    )
    case FailedToDeleteFile(path: String
    )
    case NotPermissionToAccessFile(path: String
    )
    case InvalidArculusCardModel(badValue: String
    )
    case ExpectedArculusCardFactorSourceGotSomethingElse
    case FailedToDeriveKeyAfterMaxAttempts
    case FailedToDecryptSealedMnemonic
    case AnswersToSecurityQuestionsCannotBeEmpty
    case IntegrityViolationMutationOfFactorSourceIsNotAllowedToMutateItsId
    case InvalidSecurityStructureId(badValue: String
    )
    case StructureReferencesUnknownFactorSource
    case InvalidQuestionsAndAnswersCount(expected: UInt16, found: UInt16)
    case ProfileStateNotLoaded(currentState: String
    )
}

public struct FfiConverterTypeCommonError: FfiConverterRustBuffer {
    typealias SwiftType = CommonError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CommonError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .Unknown
        case 2: return try .InvalidEd25519PrivateKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 3: return try .InvalidEd25519PrivateKeyFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 4: return try .InvalidSecp256k1PrivateKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 5: return try .InvalidSecp256k1PrivateKeyFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 6: return try .InvalidEd25519PublicKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 7: return try .InvalidEd25519PublicKeyFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 8: return try .InvalidSecp256k1PublicKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 9: return try .InvalidSecp256k1PublicKeyFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 10: return .InvalidSecp256k1PublicKeyPointNotOnCurve
        case 11: return .InvalidEd25519PublicKeyPointNotOnCurve
        case 12: return try .StringNotHex(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 13: return try .InvalidByteCount(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 14: return try .InvalidBip32Path(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 15: return try .InvalidDepthOfBip44Path(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 16: return .InvalidBip44LikePathAccountWasNotHardened
        case 17: return .InvalidBip44LikePathChangeWasUnexpectedlyHardened
        case 18: return try .InvalidDepthOfCap26Path(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 19: return .NotAllComponentsAreHardened
        case 20: return try .Bip44PurposeNotFound(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 21: return try .CoinTypeNotFound(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 22: return try .InvalidNetworkIdExceedsLimit(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 23: return try .InvalidEntityKind(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 24: return try .WrongEntityKind(
                expected: FfiConverterTypeCAP26EntityKind.read(from: &buf),
                found: FfiConverterTypeCAP26EntityKind.read(from: &buf)
            )
        case 25: return try .InvalidKeyKind(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 26: return try .UnsupportedNetworkId(
                badValue: FfiConverterUInt8.read(from: &buf)
            )
        case 27: return try .InvalidGetIdPath(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 28: return .UnknownBip39Word
        case 29: return .InvalidMnemonicPhrase
        case 30: return try .InvalidBip39WordCount(
                badValue: FfiConverterUInt64.read(from: &buf)
            )
        case 31: return try .InvalidAppearanceId(
                badValue: FfiConverterUInt8.read(from: &buf)
            )
        case 32: return try .InvalidAccountAddress(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 33: return .UnsupportedEntityType
        case 34: return try .FailedToDecodeAddressFromBech32(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 35: return .MismatchingEntityTypeWhileDecodingAddress
        case 36: return .MismatchingHrpWhileDecodingAddress
        case 37: return try .UnknownNetworkId(
                badValue: FfiConverterUInt8.read(from: &buf)
            )
        case 38: return try .InvalidNonFungibleGlobalId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 39: return .FactorSourceCryptoParametersSupportedCurvesInvalidSize
        case 40: return .BadgeIsNotVirtualHierarchicalDeterministic
        case 41: return .FactorSourceIdNotFromHash
        case 42: return .ExpectedAccountPathButGotSomethingElse
        case 43: return .WrongEntityKindOfInFactorInstancesPath
        case 44: return .WrongKeyKindOfTransactionSigningFactorInstance
        case 45: return .WrongKeyKindOfAuthenticationSigningFactorInstance
        case 46: return .ExpectedDeviceFactorSourceGotSomethingElse
        case 47: return .ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse
        case 48: return try .UnknownNetworkWithName(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 49: return try .UnknownNetworkForId(
                badValue: FfiConverterUInt8.read(from: &buf)
            )
        case 50: return .GatewaysDiscrepancyOtherShouldNotContainCurrent
        case 51: return .InvalidGatewaysJsonCurrentNotFoundAmongstSaved
        case 52: return try .InvalidUrl(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 53: return try .AccountOnWrongNetwork(
                expected: FfiConverterTypeNetworkID.read(from: &buf),
                found: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 54: return .FactorSourcesMustNotBeEmpty
        case 55: return .UpdateFactorSourceMutateFailed
        case 56: return try .CastFactorSourceWrongKind(
                expected: FfiConverterTypeFactorSourceKind.read(from: &buf),
                found: FfiConverterTypeFactorSourceKind.read(from: &buf)
            )
        case 57: return try .InvalidLength(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf),
                data: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 58: return .InvalidNonFungibleLocalIdString
        case 59: return .InvalidNonFungibleLocalIdBytes
        case 60: return .DecimalError
        case 61: return try .InvalidBip39Index(
                badValue: FfiConverterUInt16.read(from: &buf)
            )
        case 62: return .InvalidDisplayNameEmpty
        case 63: return .Free
        case 64: return try .InvalidIso8601String(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 65: return .UnknownAccount
        case 66: return .SecureStorageReadError
        case 67: return .UnableToLoadDeviceFactorSourceFromSecureStorage
        case 68: return .SecureStorageWriteError
        case 69: return .FailedToSerializeToJson
        case 70: return try .FailedToDeserializeJsonToValue(
                jsonByteCount: FfiConverterUInt64.read(from: &buf),
                typeName: FfiConverterString.read(from: &buf),
                serdeMessage: FfiConverterString.read(from: &buf)
            )
        case 71: return try .InvalidProfileId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 72: return .FailedToLoadProfileHeadersList
        case 73: return try .ProfileDoesNotContainFactorSourceWithId(
                badValue: FfiConverterTypeFactorSourceID.read(from: &buf)
            )
        case 74: return try .AccountAlreadyPresent(
                badValue: FfiConverterTypeAccountAddress.read(from: &buf)
            )
        case 75: return .UnableToAcquireWriteLockForProfile
        case 76: return try .UnableToSaveMnemonicToSecureStorage(
                badValue: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )
        case 77: return try .UnableToLoadMnemonicFromSecureStorage(
                badValue: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )
        case 78: return try .UnableToSaveFactorSourceToProfile(
                badValue: FfiConverterTypeFactorSourceID.read(from: &buf)
            )
        case 79: return .ExpectedIdentityPathButGotSomethingElse
        case 80: return .PersonaDataInvalidPhoneNumberEmpty
        case 81: return .EmailAddressEmpty
        case 82: return .PersonaDataInvalidNameFamilyNameEmpty
        case 83: return .PersonaDataInvalidNameGivenNamesEmpty
        case 84: return try .InvalidUuiDv4(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 85: return try .UnrecognizedLocaleIdentifier(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 86: return try .FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(
                nodeIdAsHex: FfiConverterString.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 87: return try .InvalidOlympiaAddressString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 88: return try .InvalidInstructionsString(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 89: return try .ExecutionSummaryFail(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 90: return .FailedToDecodeEncodedReceipt
        case 91: return .BytesEmpty
        case 92: return try .TooManyBytes(
                max: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 93: return try .InvalidInstructionsWrongNetwork(
                foundInInstructions: FfiConverterTypeNetworkID.read(from: &buf),
                specifiedToInstructionsCtor: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 94: return .FailedToUniFfiDecodeBytesToManifestInstructions
        case 95: return try .FailedToDecodeTransactionHash(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 96: return .FailedToHashIntent
        case 97: return .EncryptedMessagesAreNotYetSupported
        case 98: return try .FailedToBech32DecodeTransactionHashAfterHavingTestedAllNetworkId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 99: return try .FailedToParseSignatureFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 100: return .InvalidSignaturesForIntentSomeDidNotValidateIntentHash
        case 101: return .FailedToDecompileBytesIntoNotarizedTransaction
        case 102: return .FailedToRecoverSecp256k1PublicKeyFromSignature
        case 103: return .FungibleResourceAddressNotAcceptedInNonFungibleContext
        case 104: return try .DecimalOverflow(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 105: return try .InvalidAddressNotOlympiaMainnet(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 106: return try .FailedToParseSignatureFromBytes(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 107: return try .InvalidIntentFailedToEncode(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 108: return try .InvalidInstructionsFailedToDecompile(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 109: return try .InvalidTransactionMaxSborDepthExceeded(
                max: FfiConverterUInt16.read(from: &buf)
            )
        case 110: return try .InvalidSignedIntentFailedToEncode(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 111: return try .InvalidNotarizedIntentFailedToEncode(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 112: return .NetworkResponseBadCode
        case 113: return .NetworkResponseEmptyBody
        case 114: return try .NetworkResponseJsonDeserialize(
                intoType: FfiConverterString.read(from: &buf)
            )
        case 115: return try .NetworkRequestInvalidUrl(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 116: return try .NetworkRequestGenericFailure(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 117: return try .GatewaySubmitDuplicateTx(
                intentHash: FfiConverterString.read(from: &buf)
            )
        case 118: return .SupportedCurvesMustNotBeEmpty
        case 119: return .ProfileNetworksMustNotBeEmpty
        case 120: return try .UnknownSlip10Curve(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 121: return .AesDecryptionFailed
        case 122: return try .InvalidAesBytesTooShort(
                expectedAtLeast: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 123: return try .InvalidFactorSourceKind(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 124: return try .InvalidLedgerHardwareWalletModel(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 125: return try .RadixConnectMobileInvalidRequestUrl(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 126: return try .RadixConnectMobileInvalidOrigin(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 127: return try .RadixConnectMobileInvalidSessionId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 128: return try .RadixMobileInvalidInteractionId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 129: return try .NetworkDiscrepancy(
                expected: FfiConverterTypeNetworkID.read(from: &buf),
                actual: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 130: return try .DiscrepancyAuthorizedDappReferencedPersonaWhichDoesNotExist(
                address: FfiConverterTypeIdentityAddress.read(from: &buf)
            )
        case 131: return try .DiscrepancyAuthorizedDappReferencedAccountWhichDoesNotExist(
                address: FfiConverterTypeAccountAddress.read(from: &buf)
            )
        case 132: return .AuthorizedDappReferencesFieldIdThatDoesNotExist
        case 133: return try .ElementDoesNotExist(
                id: FfiConverterString.read(from: &buf)
            )
        case 134: return try .IdentifiableItemAlreadyExist(
                id: FfiConverterString.read(from: &buf)
            )
        case 135: return try .InvalidRadixConnectPurpose(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 136: return try .TxGuaranteeIndexOutOfBounds(
                index: FfiConverterUInt64.read(from: &buf),
                count: FfiConverterUInt64.read(from: &buf)
            )
        case 137: return try .InvalidKeyAgreementPublicKeyFromHex(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 138: return try .InvalidKeyAgreementPublicKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 139: return try .InvalidKeyAgreementPrivateKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 140: return try .RadixConnectMobileSessionNotFound(
                sessionId: FfiConverterTypeSessionID.read(from: &buf)
            )
        case 141: return try .RadixConnectMobileDappRequestNotFound(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf)
            )
        case 142: return try .RadixConnectMobileDappCallbackPathNotFound(
                origin: FfiConverterTypeUrl.read(from: &buf)
            )
        case 143: return try .InvalidEd25519SignatureFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 144: return .RadixConnectMobileDappPublicKeyMismatch
        case 145: return .RadixConnectMobileDappIdentityMismatch
        case 146: return .RadixConnectMobileDappOriginMismatch
        case 147: return .RadixConnectMobileInvalidDappSignature
        case 148: return .RadixConnectMobileInvalidRequestFormat
        case 149: return .RadixConnectMobileFailedToCreateNewSession
        case 150: return try .DeferredDeepLinkInvalidValueFormat(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 151: return .FailedUpdatingHomeCards
        case 152: return .EntityNotFound
        case 153: return .HomeCardsNotFound
        case 154: return .FailedSavingHomeCards
        case 155: return try .UnableToLoadProfileFromSecureStorage(
                profileId: FfiConverterTypeProfileID.read(from: &buf)
            )
        case 156: return .UnableToSaveHostIdToSecureStorage
        case 157: return .UnableToAcquireReadLockForProfile
        case 158: return .UnsafeStorageReadError
        case 159: return .UnsafeStorageWriteError
        case 160: return try .FailedToCreateFilePathFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 161: return .ExpectedNonEmptyCollection
        case 162: return .UnableToAddAllAccountsDuplicatesFound
        case 163: return try .ProfileUsedOnOtherDevice(
                otherDeviceId: FfiConverterTypeDeviceID.read(from: &buf),
                thisDeviceId: FfiConverterTypeDeviceID.read(from: &buf)
            )
        case 164: return try .InvalidDeviceId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 165: return .TriedToUpdateProfileWithOneWithDifferentId
        case 166: return try .InvalidPath(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 167: return try .FailedToSaveFile(
                path: FfiConverterString.read(from: &buf)
            )
        case 168: return try .FailedToLoadFile(
                path: FfiConverterString.read(from: &buf)
            )
        case 169: return try .FailedToDeleteFile(
                path: FfiConverterString.read(from: &buf)
            )
        case 170: return try .NotPermissionToAccessFile(
                path: FfiConverterString.read(from: &buf)
            )
        case 171: return try .InvalidArculusCardModel(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 172: return .ExpectedArculusCardFactorSourceGotSomethingElse
        case 173: return .FailedToDeriveKeyAfterMaxAttempts
        case 174: return .FailedToDecryptSealedMnemonic
        case 175: return .AnswersToSecurityQuestionsCannotBeEmpty
        case 176: return .IntegrityViolationMutationOfFactorSourceIsNotAllowedToMutateItsId
        case 177: return try .InvalidSecurityStructureId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 178: return .StructureReferencesUnknownFactorSource
        case 179: return try .InvalidQuestionsAndAnswersCount(
                expected: FfiConverterUInt16.read(from: &buf),
                found: FfiConverterUInt16.read(from: &buf)
            )
        case 180: return try .ProfileStateNotLoaded(
                currentState: FfiConverterString.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CommonError, into buf: inout [UInt8]) {
        switch value {
        case .Unknown:
            writeInt(&buf, Int32(1))

        case let .InvalidEd25519PrivateKeyFromBytes(badValue):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidEd25519PrivateKeyFromString(badValue):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidSecp256k1PrivateKeyFromBytes(badValue):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidSecp256k1PrivateKeyFromString(badValue):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidEd25519PublicKeyFromBytes(badValue):
            writeInt(&buf, Int32(6))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidEd25519PublicKeyFromString(badValue):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidSecp256k1PublicKeyFromBytes(badValue):
            writeInt(&buf, Int32(8))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidSecp256k1PublicKeyFromString(badValue):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(badValue, into: &buf)

        case .InvalidSecp256k1PublicKeyPointNotOnCurve:
            writeInt(&buf, Int32(10))

        case .InvalidEd25519PublicKeyPointNotOnCurve:
            writeInt(&buf, Int32(11))

        case let .StringNotHex(badValue):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidByteCount(expected, found):
            writeInt(&buf, Int32(13))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case let .InvalidBip32Path(badValue):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidDepthOfBip44Path(expected, found):
            writeInt(&buf, Int32(15))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case .InvalidBip44LikePathAccountWasNotHardened:
            writeInt(&buf, Int32(16))

        case .InvalidBip44LikePathChangeWasUnexpectedlyHardened:
            writeInt(&buf, Int32(17))

        case let .InvalidDepthOfCap26Path(expected, found):
            writeInt(&buf, Int32(18))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case .NotAllComponentsAreHardened:
            writeInt(&buf, Int32(19))

        case let .Bip44PurposeNotFound(badValue):
            writeInt(&buf, Int32(20))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .CoinTypeNotFound(badValue):
            writeInt(&buf, Int32(21))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .InvalidNetworkIdExceedsLimit(badValue):
            writeInt(&buf, Int32(22))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .InvalidEntityKind(badValue):
            writeInt(&buf, Int32(23))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .WrongEntityKind(expected, found):
            writeInt(&buf, Int32(24))
            FfiConverterTypeCAP26EntityKind.write(expected, into: &buf)
            FfiConverterTypeCAP26EntityKind.write(found, into: &buf)

        case let .InvalidKeyKind(badValue):
            writeInt(&buf, Int32(25))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .UnsupportedNetworkId(badValue):
            writeInt(&buf, Int32(26))
            FfiConverterUInt8.write(badValue, into: &buf)

        case let .InvalidGetIdPath(badValue):
            writeInt(&buf, Int32(27))
            FfiConverterUInt32.write(badValue, into: &buf)

        case .UnknownBip39Word:
            writeInt(&buf, Int32(28))

        case .InvalidMnemonicPhrase:
            writeInt(&buf, Int32(29))

        case let .InvalidBip39WordCount(badValue):
            writeInt(&buf, Int32(30))
            FfiConverterUInt64.write(badValue, into: &buf)

        case let .InvalidAppearanceId(badValue):
            writeInt(&buf, Int32(31))
            FfiConverterUInt8.write(badValue, into: &buf)

        case let .InvalidAccountAddress(badValue):
            writeInt(&buf, Int32(32))
            FfiConverterString.write(badValue, into: &buf)

        case .UnsupportedEntityType:
            writeInt(&buf, Int32(33))

        case let .FailedToDecodeAddressFromBech32(badValue):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(badValue, into: &buf)

        case .MismatchingEntityTypeWhileDecodingAddress:
            writeInt(&buf, Int32(35))

        case .MismatchingHrpWhileDecodingAddress:
            writeInt(&buf, Int32(36))

        case let .UnknownNetworkId(badValue):
            writeInt(&buf, Int32(37))
            FfiConverterUInt8.write(badValue, into: &buf)

        case let .InvalidNonFungibleGlobalId(badValue):
            writeInt(&buf, Int32(38))
            FfiConverterString.write(badValue, into: &buf)

        case .FactorSourceCryptoParametersSupportedCurvesInvalidSize:
            writeInt(&buf, Int32(39))

        case .BadgeIsNotVirtualHierarchicalDeterministic:
            writeInt(&buf, Int32(40))

        case .FactorSourceIdNotFromHash:
            writeInt(&buf, Int32(41))

        case .ExpectedAccountPathButGotSomethingElse:
            writeInt(&buf, Int32(42))

        case .WrongEntityKindOfInFactorInstancesPath:
            writeInt(&buf, Int32(43))

        case .WrongKeyKindOfTransactionSigningFactorInstance:
            writeInt(&buf, Int32(44))

        case .WrongKeyKindOfAuthenticationSigningFactorInstance:
            writeInt(&buf, Int32(45))

        case .ExpectedDeviceFactorSourceGotSomethingElse:
            writeInt(&buf, Int32(46))

        case .ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse:
            writeInt(&buf, Int32(47))

        case let .UnknownNetworkWithName(badValue):
            writeInt(&buf, Int32(48))
            FfiConverterString.write(badValue, into: &buf)

        case let .UnknownNetworkForId(badValue):
            writeInt(&buf, Int32(49))
            FfiConverterUInt8.write(badValue, into: &buf)

        case .GatewaysDiscrepancyOtherShouldNotContainCurrent:
            writeInt(&buf, Int32(50))

        case .InvalidGatewaysJsonCurrentNotFoundAmongstSaved:
            writeInt(&buf, Int32(51))

        case let .InvalidUrl(badValue):
            writeInt(&buf, Int32(52))
            FfiConverterString.write(badValue, into: &buf)

        case let .AccountOnWrongNetwork(expected, found):
            writeInt(&buf, Int32(53))
            FfiConverterTypeNetworkID.write(expected, into: &buf)
            FfiConverterTypeNetworkID.write(found, into: &buf)

        case .FactorSourcesMustNotBeEmpty:
            writeInt(&buf, Int32(54))

        case .UpdateFactorSourceMutateFailed:
            writeInt(&buf, Int32(55))

        case let .CastFactorSourceWrongKind(expected, found):
            writeInt(&buf, Int32(56))
            FfiConverterTypeFactorSourceKind.write(expected, into: &buf)
            FfiConverterTypeFactorSourceKind.write(found, into: &buf)

        case let .InvalidLength(expected, found, data):
            writeInt(&buf, Int32(57))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)
            FfiConverterTypeBagOfBytes.write(data, into: &buf)

        case .InvalidNonFungibleLocalIdString:
            writeInt(&buf, Int32(58))

        case .InvalidNonFungibleLocalIdBytes:
            writeInt(&buf, Int32(59))

        case .DecimalError:
            writeInt(&buf, Int32(60))

        case let .InvalidBip39Index(badValue):
            writeInt(&buf, Int32(61))
            FfiConverterUInt16.write(badValue, into: &buf)

        case .InvalidDisplayNameEmpty:
            writeInt(&buf, Int32(62))

        case .Free:
            writeInt(&buf, Int32(63))

        case let .InvalidIso8601String(badValue):
            writeInt(&buf, Int32(64))
            FfiConverterString.write(badValue, into: &buf)

        case .UnknownAccount:
            writeInt(&buf, Int32(65))

        case .SecureStorageReadError:
            writeInt(&buf, Int32(66))

        case .UnableToLoadDeviceFactorSourceFromSecureStorage:
            writeInt(&buf, Int32(67))

        case .SecureStorageWriteError:
            writeInt(&buf, Int32(68))

        case .FailedToSerializeToJson:
            writeInt(&buf, Int32(69))

        case let .FailedToDeserializeJsonToValue(jsonByteCount, typeName, serdeMessage):
            writeInt(&buf, Int32(70))
            FfiConverterUInt64.write(jsonByteCount, into: &buf)
            FfiConverterString.write(typeName, into: &buf)
            FfiConverterString.write(serdeMessage, into: &buf)

        case let .InvalidProfileId(badValue):
            writeInt(&buf, Int32(71))
            FfiConverterString.write(badValue, into: &buf)

        case .FailedToLoadProfileHeadersList:
            writeInt(&buf, Int32(72))

        case let .ProfileDoesNotContainFactorSourceWithId(badValue):
            writeInt(&buf, Int32(73))
            FfiConverterTypeFactorSourceID.write(badValue, into: &buf)

        case let .AccountAlreadyPresent(badValue):
            writeInt(&buf, Int32(74))
            FfiConverterTypeAccountAddress.write(badValue, into: &buf)

        case .UnableToAcquireWriteLockForProfile:
            writeInt(&buf, Int32(75))

        case let .UnableToSaveMnemonicToSecureStorage(badValue):
            writeInt(&buf, Int32(76))
            FfiConverterTypeFactorSourceIDFromHash.write(badValue, into: &buf)

        case let .UnableToLoadMnemonicFromSecureStorage(badValue):
            writeInt(&buf, Int32(77))
            FfiConverterTypeFactorSourceIDFromHash.write(badValue, into: &buf)

        case let .UnableToSaveFactorSourceToProfile(badValue):
            writeInt(&buf, Int32(78))
            FfiConverterTypeFactorSourceID.write(badValue, into: &buf)

        case .ExpectedIdentityPathButGotSomethingElse:
            writeInt(&buf, Int32(79))

        case .PersonaDataInvalidPhoneNumberEmpty:
            writeInt(&buf, Int32(80))

        case .EmailAddressEmpty:
            writeInt(&buf, Int32(81))

        case .PersonaDataInvalidNameFamilyNameEmpty:
            writeInt(&buf, Int32(82))

        case .PersonaDataInvalidNameGivenNamesEmpty:
            writeInt(&buf, Int32(83))

        case let .InvalidUuiDv4(badValue):
            writeInt(&buf, Int32(84))
            FfiConverterString.write(badValue, into: &buf)

        case let .UnrecognizedLocaleIdentifier(badValue):
            writeInt(&buf, Int32(85))
            FfiConverterString.write(badValue, into: &buf)

        case let .FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(nodeIdAsHex, networkId):
            writeInt(&buf, Int32(86))
            FfiConverterString.write(nodeIdAsHex, into: &buf)
            FfiConverterTypeNetworkID.write(networkId, into: &buf)

        case let .InvalidOlympiaAddressString(badValue):
            writeInt(&buf, Int32(87))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidInstructionsString(underlying):
            writeInt(&buf, Int32(88))
            FfiConverterString.write(underlying, into: &buf)

        case let .ExecutionSummaryFail(underlying):
            writeInt(&buf, Int32(89))
            FfiConverterString.write(underlying, into: &buf)

        case .FailedToDecodeEncodedReceipt:
            writeInt(&buf, Int32(90))

        case .BytesEmpty:
            writeInt(&buf, Int32(91))

        case let .TooManyBytes(max, found):
            writeInt(&buf, Int32(92))
            FfiConverterUInt64.write(max, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case let .InvalidInstructionsWrongNetwork(foundInInstructions, specifiedToInstructionsCtor):
            writeInt(&buf, Int32(93))
            FfiConverterTypeNetworkID.write(foundInInstructions, into: &buf)
            FfiConverterTypeNetworkID.write(specifiedToInstructionsCtor, into: &buf)

        case .FailedToUniFfiDecodeBytesToManifestInstructions:
            writeInt(&buf, Int32(94))

        case let .FailedToDecodeTransactionHash(badValue):
            writeInt(&buf, Int32(95))
            FfiConverterString.write(badValue, into: &buf)

        case .FailedToHashIntent:
            writeInt(&buf, Int32(96))

        case .EncryptedMessagesAreNotYetSupported:
            writeInt(&buf, Int32(97))

        case let .FailedToBech32DecodeTransactionHashAfterHavingTestedAllNetworkId(badValue):
            writeInt(&buf, Int32(98))
            FfiConverterString.write(badValue, into: &buf)

        case let .FailedToParseSignatureFromString(badValue):
            writeInt(&buf, Int32(99))
            FfiConverterString.write(badValue, into: &buf)

        case .InvalidSignaturesForIntentSomeDidNotValidateIntentHash:
            writeInt(&buf, Int32(100))

        case .FailedToDecompileBytesIntoNotarizedTransaction:
            writeInt(&buf, Int32(101))

        case .FailedToRecoverSecp256k1PublicKeyFromSignature:
            writeInt(&buf, Int32(102))

        case .FungibleResourceAddressNotAcceptedInNonFungibleContext:
            writeInt(&buf, Int32(103))

        case let .DecimalOverflow(badValue):
            writeInt(&buf, Int32(104))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidAddressNotOlympiaMainnet(badValue):
            writeInt(&buf, Int32(105))
            FfiConverterString.write(badValue, into: &buf)

        case let .FailedToParseSignatureFromBytes(badValue):
            writeInt(&buf, Int32(106))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidIntentFailedToEncode(underlying):
            writeInt(&buf, Int32(107))
            FfiConverterString.write(underlying, into: &buf)

        case let .InvalidInstructionsFailedToDecompile(underlying):
            writeInt(&buf, Int32(108))
            FfiConverterString.write(underlying, into: &buf)

        case let .InvalidTransactionMaxSborDepthExceeded(max):
            writeInt(&buf, Int32(109))
            FfiConverterUInt16.write(max, into: &buf)

        case let .InvalidSignedIntentFailedToEncode(underlying):
            writeInt(&buf, Int32(110))
            FfiConverterString.write(underlying, into: &buf)

        case let .InvalidNotarizedIntentFailedToEncode(underlying):
            writeInt(&buf, Int32(111))
            FfiConverterString.write(underlying, into: &buf)

        case .NetworkResponseBadCode:
            writeInt(&buf, Int32(112))

        case .NetworkResponseEmptyBody:
            writeInt(&buf, Int32(113))

        case let .NetworkResponseJsonDeserialize(intoType):
            writeInt(&buf, Int32(114))
            FfiConverterString.write(intoType, into: &buf)

        case let .NetworkRequestInvalidUrl(badValue):
            writeInt(&buf, Int32(115))
            FfiConverterString.write(badValue, into: &buf)

        case let .NetworkRequestGenericFailure(underlying):
            writeInt(&buf, Int32(116))
            FfiConverterString.write(underlying, into: &buf)

        case let .GatewaySubmitDuplicateTx(intentHash):
            writeInt(&buf, Int32(117))
            FfiConverterString.write(intentHash, into: &buf)

        case .SupportedCurvesMustNotBeEmpty:
            writeInt(&buf, Int32(118))

        case .ProfileNetworksMustNotBeEmpty:
            writeInt(&buf, Int32(119))

        case let .UnknownSlip10Curve(badValue):
            writeInt(&buf, Int32(120))
            FfiConverterString.write(badValue, into: &buf)

        case .AesDecryptionFailed:
            writeInt(&buf, Int32(121))

        case let .InvalidAesBytesTooShort(expectedAtLeast, found):
            writeInt(&buf, Int32(122))
            FfiConverterUInt64.write(expectedAtLeast, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case let .InvalidFactorSourceKind(badValue):
            writeInt(&buf, Int32(123))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidLedgerHardwareWalletModel(badValue):
            writeInt(&buf, Int32(124))
            FfiConverterString.write(badValue, into: &buf)

        case let .RadixConnectMobileInvalidRequestUrl(badValue):
            writeInt(&buf, Int32(125))
            FfiConverterString.write(badValue, into: &buf)

        case let .RadixConnectMobileInvalidOrigin(badValue):
            writeInt(&buf, Int32(126))
            FfiConverterString.write(badValue, into: &buf)

        case let .RadixConnectMobileInvalidSessionId(badValue):
            writeInt(&buf, Int32(127))
            FfiConverterString.write(badValue, into: &buf)

        case let .RadixMobileInvalidInteractionId(badValue):
            writeInt(&buf, Int32(128))
            FfiConverterString.write(badValue, into: &buf)

        case let .NetworkDiscrepancy(expected, actual):
            writeInt(&buf, Int32(129))
            FfiConverterTypeNetworkID.write(expected, into: &buf)
            FfiConverterTypeNetworkID.write(actual, into: &buf)

        case let .DiscrepancyAuthorizedDappReferencedPersonaWhichDoesNotExist(address):
            writeInt(&buf, Int32(130))
            FfiConverterTypeIdentityAddress.write(address, into: &buf)

        case let .DiscrepancyAuthorizedDappReferencedAccountWhichDoesNotExist(address):
            writeInt(&buf, Int32(131))
            FfiConverterTypeAccountAddress.write(address, into: &buf)

        case .AuthorizedDappReferencesFieldIdThatDoesNotExist:
            writeInt(&buf, Int32(132))

        case let .ElementDoesNotExist(id):
            writeInt(&buf, Int32(133))
            FfiConverterString.write(id, into: &buf)

        case let .IdentifiableItemAlreadyExist(id):
            writeInt(&buf, Int32(134))
            FfiConverterString.write(id, into: &buf)

        case let .InvalidRadixConnectPurpose(badValue):
            writeInt(&buf, Int32(135))
            FfiConverterString.write(badValue, into: &buf)

        case let .TxGuaranteeIndexOutOfBounds(index, count):
            writeInt(&buf, Int32(136))
            FfiConverterUInt64.write(index, into: &buf)
            FfiConverterUInt64.write(count, into: &buf)

        case let .InvalidKeyAgreementPublicKeyFromHex(badValue):
            writeInt(&buf, Int32(137))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidKeyAgreementPublicKeyFromBytes(badValue):
            writeInt(&buf, Int32(138))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidKeyAgreementPrivateKeyFromBytes(badValue):
            writeInt(&buf, Int32(139))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .RadixConnectMobileSessionNotFound(sessionId):
            writeInt(&buf, Int32(140))
            FfiConverterTypeSessionID.write(sessionId, into: &buf)

        case let .RadixConnectMobileDappRequestNotFound(interactionId):
            writeInt(&buf, Int32(141))
            FfiConverterTypeWalletInteractionId.write(interactionId, into: &buf)

        case let .RadixConnectMobileDappCallbackPathNotFound(origin):
            writeInt(&buf, Int32(142))
            FfiConverterTypeUrl.write(origin, into: &buf)

        case let .InvalidEd25519SignatureFromString(badValue):
            writeInt(&buf, Int32(143))
            FfiConverterString.write(badValue, into: &buf)

        case .RadixConnectMobileDappPublicKeyMismatch:
            writeInt(&buf, Int32(144))

        case .RadixConnectMobileDappIdentityMismatch:
            writeInt(&buf, Int32(145))

        case .RadixConnectMobileDappOriginMismatch:
            writeInt(&buf, Int32(146))

        case .RadixConnectMobileInvalidDappSignature:
            writeInt(&buf, Int32(147))

        case .RadixConnectMobileInvalidRequestFormat:
            writeInt(&buf, Int32(148))

        case .RadixConnectMobileFailedToCreateNewSession:
            writeInt(&buf, Int32(149))

        case let .DeferredDeepLinkInvalidValueFormat(badValue):
            writeInt(&buf, Int32(150))
            FfiConverterString.write(badValue, into: &buf)

        case .FailedUpdatingHomeCards:
            writeInt(&buf, Int32(151))

        case .EntityNotFound:
            writeInt(&buf, Int32(152))

        case .HomeCardsNotFound:
            writeInt(&buf, Int32(153))

        case .FailedSavingHomeCards:
            writeInt(&buf, Int32(154))

        case let .UnableToLoadProfileFromSecureStorage(profileId):
            writeInt(&buf, Int32(155))
            FfiConverterTypeProfileID.write(profileId, into: &buf)

        case .UnableToSaveHostIdToSecureStorage:
            writeInt(&buf, Int32(156))

        case .UnableToAcquireReadLockForProfile:
            writeInt(&buf, Int32(157))

        case .UnsafeStorageReadError:
            writeInt(&buf, Int32(158))

        case .UnsafeStorageWriteError:
            writeInt(&buf, Int32(159))

        case let .FailedToCreateFilePathFromString(badValue):
            writeInt(&buf, Int32(160))
            FfiConverterString.write(badValue, into: &buf)

        case .ExpectedNonEmptyCollection:
            writeInt(&buf, Int32(161))

        case .UnableToAddAllAccountsDuplicatesFound:
            writeInt(&buf, Int32(162))

        case let .ProfileUsedOnOtherDevice(otherDeviceId, thisDeviceId):
            writeInt(&buf, Int32(163))
            FfiConverterTypeDeviceID.write(otherDeviceId, into: &buf)
            FfiConverterTypeDeviceID.write(thisDeviceId, into: &buf)

        case let .InvalidDeviceId(badValue):
            writeInt(&buf, Int32(164))
            FfiConverterString.write(badValue, into: &buf)

        case .TriedToUpdateProfileWithOneWithDifferentId:
            writeInt(&buf, Int32(165))

        case let .InvalidPath(badValue):
            writeInt(&buf, Int32(166))
            FfiConverterString.write(badValue, into: &buf)

        case let .FailedToSaveFile(path):
            writeInt(&buf, Int32(167))
            FfiConverterString.write(path, into: &buf)

        case let .FailedToLoadFile(path):
            writeInt(&buf, Int32(168))
            FfiConverterString.write(path, into: &buf)

        case let .FailedToDeleteFile(path):
            writeInt(&buf, Int32(169))
            FfiConverterString.write(path, into: &buf)

        case let .NotPermissionToAccessFile(path):
            writeInt(&buf, Int32(170))
            FfiConverterString.write(path, into: &buf)

        case let .InvalidArculusCardModel(badValue):
            writeInt(&buf, Int32(171))
            FfiConverterString.write(badValue, into: &buf)

        case .ExpectedArculusCardFactorSourceGotSomethingElse:
            writeInt(&buf, Int32(172))

        case .FailedToDeriveKeyAfterMaxAttempts:
            writeInt(&buf, Int32(173))

        case .FailedToDecryptSealedMnemonic:
            writeInt(&buf, Int32(174))

        case .AnswersToSecurityQuestionsCannotBeEmpty:
            writeInt(&buf, Int32(175))

        case .IntegrityViolationMutationOfFactorSourceIsNotAllowedToMutateItsId:
            writeInt(&buf, Int32(176))

        case let .InvalidSecurityStructureId(badValue):
            writeInt(&buf, Int32(177))
            FfiConverterString.write(badValue, into: &buf)

        case .StructureReferencesUnknownFactorSource:
            writeInt(&buf, Int32(178))

        case let .InvalidQuestionsAndAnswersCount(expected, found):
            writeInt(&buf, Int32(179))
            FfiConverterUInt16.write(expected, into: &buf)
            FfiConverterUInt16.write(found, into: &buf)

        case let .ProfileStateNotLoaded(currentState):
            writeInt(&buf, Int32(180))
            FfiConverterString.write(currentState, into: &buf)
        }
    }
}

extension CommonError: Equatable, Hashable {}

extension CommonError: Swift.Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappToWalletInteractionAuthRequestItem {
    case loginWithChallenge(DappToWalletInteractionAuthLoginWithChallengeRequestItem
    )
    case loginWithoutChallenge
    case usePersona(DappToWalletInteractionAuthUsePersonaRequestItem
    )
}

public struct FfiConverterTypeDappToWalletInteractionAuthRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionAuthRequestItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthRequestItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .loginWithChallenge(FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.read(from: &buf)
            )

        case 2: return .loginWithoutChallenge

        case 3: return try .usePersona(FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappToWalletInteractionAuthRequestItem, into buf: inout [UInt8]) {
        switch value {
        case let .loginWithChallenge(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.write(v1, into: &buf)

        case .loginWithoutChallenge:
            writeInt(&buf, Int32(2))

        case let .usePersona(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAuthRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthRequestItem_lower(_ value: DappToWalletInteractionAuthRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthRequestItem.lower(value)
}

extension DappToWalletInteractionAuthRequestItem: Sendable {}
extension DappToWalletInteractionAuthRequestItem: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappToWalletInteractionItems {
    case unauthorizedRequest(DappToWalletInteractionUnauthorizedRequestItems
    )
    case authorizedRequest(DappToWalletInteractionAuthorizedRequestItems
    )
    case transaction(DappToWalletInteractionTransactionItems
    )
}

public struct FfiConverterTypeDappToWalletInteractionItems: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionItems

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionItems {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .unauthorizedRequest(FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.read(from: &buf)
            )

        case 2: return try .authorizedRequest(FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.read(from: &buf)
            )

        case 3: return try .transaction(FfiConverterTypeDappToWalletInteractionTransactionItems.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappToWalletInteractionItems, into buf: inout [UInt8]) {
        switch value {
        case let .unauthorizedRequest(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.write(v1, into: &buf)

        case let .authorizedRequest(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.write(v1, into: &buf)

        case let .transaction(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDappToWalletInteractionTransactionItems.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeDappToWalletInteractionItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionItems {
    return try FfiConverterTypeDappToWalletInteractionItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionItems_lower(_ value: DappToWalletInteractionItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionItems.lower(value)
}

extension DappToWalletInteractionItems: Sendable {}
extension DappToWalletInteractionItems: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappWalletInteractionErrorType {
    case rejectedByUser
    case wrongNetwork
    case failedToPrepareTransaction
    case failedToCompileTransaction
    case failedToSignTransaction
    case failedToSubmitTransaction
    case failedToPollSubmittedTransaction
    case failedToFindAccountWithEnoughFundsToLockFee
    case submittedTransactionWasDuplicate
    case submittedTransactionHasFailedTransactionStatus
    case submittedTransactionHasRejectedTransactionStatus
    case wrongAccountType
    case unknownWebsite
    case invalidOriginUrl
    case radixJsonNotFound
    case radixJsonUnknownFileFormat
    case unknownDappDefinitionAddress
    case invalidPersona
    case invalidRequest
    case incompatibleVersion
    case failedToSignAuthChallenge
}

public struct FfiConverterTypeDappWalletInteractionErrorType: FfiConverterRustBuffer {
    typealias SwiftType = DappWalletInteractionErrorType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappWalletInteractionErrorType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .rejectedByUser

        case 2: return .wrongNetwork

        case 3: return .failedToPrepareTransaction

        case 4: return .failedToCompileTransaction

        case 5: return .failedToSignTransaction

        case 6: return .failedToSubmitTransaction

        case 7: return .failedToPollSubmittedTransaction

        case 8: return .failedToFindAccountWithEnoughFundsToLockFee

        case 9: return .submittedTransactionWasDuplicate

        case 10: return .submittedTransactionHasFailedTransactionStatus

        case 11: return .submittedTransactionHasRejectedTransactionStatus

        case 12: return .wrongAccountType

        case 13: return .unknownWebsite

        case 14: return .invalidOriginUrl

        case 15: return .radixJsonNotFound

        case 16: return .radixJsonUnknownFileFormat

        case 17: return .unknownDappDefinitionAddress

        case 18: return .invalidPersona

        case 19: return .invalidRequest

        case 20: return .incompatibleVersion

        case 21: return .failedToSignAuthChallenge

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappWalletInteractionErrorType, into buf: inout [UInt8]) {
        switch value {
        case .rejectedByUser:
            writeInt(&buf, Int32(1))

        case .wrongNetwork:
            writeInt(&buf, Int32(2))

        case .failedToPrepareTransaction:
            writeInt(&buf, Int32(3))

        case .failedToCompileTransaction:
            writeInt(&buf, Int32(4))

        case .failedToSignTransaction:
            writeInt(&buf, Int32(5))

        case .failedToSubmitTransaction:
            writeInt(&buf, Int32(6))

        case .failedToPollSubmittedTransaction:
            writeInt(&buf, Int32(7))

        case .failedToFindAccountWithEnoughFundsToLockFee:
            writeInt(&buf, Int32(8))

        case .submittedTransactionWasDuplicate:
            writeInt(&buf, Int32(9))

        case .submittedTransactionHasFailedTransactionStatus:
            writeInt(&buf, Int32(10))

        case .submittedTransactionHasRejectedTransactionStatus:
            writeInt(&buf, Int32(11))

        case .wrongAccountType:
            writeInt(&buf, Int32(12))

        case .unknownWebsite:
            writeInt(&buf, Int32(13))

        case .invalidOriginUrl:
            writeInt(&buf, Int32(14))

        case .radixJsonNotFound:
            writeInt(&buf, Int32(15))

        case .radixJsonUnknownFileFormat:
            writeInt(&buf, Int32(16))

        case .unknownDappDefinitionAddress:
            writeInt(&buf, Int32(17))

        case .invalidPersona:
            writeInt(&buf, Int32(18))

        case .invalidRequest:
            writeInt(&buf, Int32(19))

        case .incompatibleVersion:
            writeInt(&buf, Int32(20))

        case .failedToSignAuthChallenge:
            writeInt(&buf, Int32(21))
        }
    }
}

public func FfiConverterTypeDappWalletInteractionErrorType_lift(_ buf: RustBuffer) throws -> DappWalletInteractionErrorType {
    return try FfiConverterTypeDappWalletInteractionErrorType.lift(buf)
}

public func FfiConverterTypeDappWalletInteractionErrorType_lower(_ value: DappWalletInteractionErrorType) -> RustBuffer {
    return FfiConverterTypeDappWalletInteractionErrorType.lower(value)
}

extension DappWalletInteractionErrorType: Sendable {}
extension DappWalletInteractionErrorType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DependencyInformation {
    case version(String
    )
    case tag(String
    )
    case branch(String
    )
    case rev(String
    )
}

public struct FfiConverterTypeDependencyInformation: FfiConverterRustBuffer {
    typealias SwiftType = DependencyInformation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DependencyInformation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .version(FfiConverterString.read(from: &buf)
            )

        case 2: return try .tag(FfiConverterString.read(from: &buf)
            )

        case 3: return try .branch(FfiConverterString.read(from: &buf)
            )

        case 4: return try .rev(FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DependencyInformation, into buf: inout [UInt8]) {
        switch value {
        case let .version(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .tag(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)

        case let .branch(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)

        case let .rev(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeDependencyInformation_lift(_ buf: RustBuffer) throws -> DependencyInformation {
    return try FfiConverterTypeDependencyInformation.lift(buf)
}

public func FfiConverterTypeDependencyInformation_lower(_ value: DependencyInformation) -> RustBuffer {
    return FfiConverterTypeDependencyInformation.lower(value)
}

extension DependencyInformation: Sendable {}
extension DependencyInformation: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The exception kind for deposit address
 */

public enum DepositAddressExceptionRule {
    /**
     * A resource can always be deposited in to the account by third-parties
     */
    case allow
    /**
     * A resource can never be deposited in to the account by third-parties
     */
    case deny
}

public struct FfiConverterTypeDepositAddressExceptionRule: FfiConverterRustBuffer {
    typealias SwiftType = DepositAddressExceptionRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositAddressExceptionRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .allow

        case 2: return .deny

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositAddressExceptionRule, into buf: inout [UInt8]) {
        switch value {
        case .allow:
            writeInt(&buf, Int32(1))

        case .deny:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeDepositAddressExceptionRule_lift(_ buf: RustBuffer) throws -> DepositAddressExceptionRule {
    return try FfiConverterTypeDepositAddressExceptionRule.lift(buf)
}

public func FfiConverterTypeDepositAddressExceptionRule_lower(_ value: DepositAddressExceptionRule) -> RustBuffer {
    return FfiConverterTypeDepositAddressExceptionRule.lower(value)
}

extension DepositAddressExceptionRule: Sendable {}
extension DepositAddressExceptionRule: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The general deposit rule to apply
 */

public enum DepositRule {
    /**
     * The account accepts **all** assets by default, except for exceptions (if any) which might not deposit/be deposited into this account.
     */
    case acceptKnown
    /**
     * The account accepts **known** assets by default, except for exceptions (if any) which might not deposit/be deposited into this account. By known we mean assets this account has received in the past.
     */
    case acceptAll
    /**
     * The account denies **all** assets by default, except for exceptions (if any) which might in fact deposit/be deposited into this account.
     */
    case denyAll
}

public struct FfiConverterTypeDepositRule: FfiConverterRustBuffer {
    typealias SwiftType = DepositRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .acceptKnown

        case 2: return .acceptAll

        case 3: return .denyAll

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositRule, into buf: inout [UInt8]) {
        switch value {
        case .acceptKnown:
            writeInt(&buf, Int32(1))

        case .acceptAll:
            writeInt(&buf, Int32(2))

        case .denyAll:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeDepositRule_lift(_ buf: RustBuffer) throws -> DepositRule {
    return try FfiConverterTypeDepositRule.lift(buf)
}

public func FfiConverterTypeDepositRule_lower(_ value: DepositRule) -> RustBuffer {
    return FfiConverterTypeDepositRule.lower(value)
}

extension DepositRule: Sendable {}
extension DepositRule: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A derivation path on either supported schemes, either Babylon (CAP26) or Olympia (BIP44Like).
 */

public enum DerivationPath {
    case cap26(value: Cap26Path
    )
    case bip44Like(value: Bip44LikePath
    )
}

public struct FfiConverterTypeDerivationPath: FfiConverterRustBuffer {
    typealias SwiftType = DerivationPath

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPath {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .cap26(value: FfiConverterTypeCAP26Path.read(from: &buf)
            )

        case 2: return try .bip44Like(value: FfiConverterTypeBIP44LikePath.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivationPath, into buf: inout [UInt8]) {
        switch value {
        case let .cap26(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeCAP26Path.write(value, into: &buf)

        case let .bip44Like(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBIP44LikePath.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeDerivationPath_lift(_ buf: RustBuffer) throws -> DerivationPath {
    return try FfiConverterTypeDerivationPath.lift(buf)
}

public func FfiConverterTypeDerivationPath_lower(_ value: DerivationPath) -> RustBuffer {
    return FfiConverterTypeDerivationPath.lower(value)
}

extension DerivationPath: Sendable {}
extension DerivationPath: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Which derivation path to used for some particular HD operations
 * such as signing or public key derivation. Radix Babylon introduces
 * a new scheme call Cap26 but we also need to support BIP44-like used
 * by Olympia.
 */

public enum DerivationPathScheme {
    /**
     * A BIP32 based derivation path scheme, using SLIP10.
     */
    case cap26
    /**
     * A BIP32 based similar to BIP44, but not strict BIP44 since the
     * last path component is hardened (a mistake made during Olympia),
     * used to support legacy accounts imported from Olympia wallet.
     */
    case bip44Olympia
}

public struct FfiConverterTypeDerivationPathScheme: FfiConverterRustBuffer {
    typealias SwiftType = DerivationPathScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPathScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .cap26

        case 2: return .bip44Olympia

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivationPathScheme, into buf: inout [UInt8]) {
        switch value {
        case .cap26:
            writeInt(&buf, Int32(1))

        case .bip44Olympia:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeDerivationPathScheme_lift(_ buf: RustBuffer) throws -> DerivationPathScheme {
    return try FfiConverterTypeDerivationPathScheme.lift(buf)
}

public func FfiConverterTypeDerivationPathScheme_lower(_ value: DerivationPathScheme) -> RustBuffer {
    return FfiConverterTypeDerivationPathScheme.lower(value)
}

extension DerivationPathScheme: Sendable {}
extension DerivationPathScheme: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The execution summary process not only determines the class of the manifest,
 * but also includes additional information about this class that the wallet
 * requires to display to the user.
 */

public enum DetailedManifestClass {
    /**
     * A general manifest that involves any amount of arbitrary components
     * and packages where nothing more concrete can be said about the manifest
     * and its nature.
     *
     * No additional information is required beyond what the execution summary
     * will provide.
     */
    case general
    /**
     * A manifest of a 1-to-1 transfer to a one-to-many transfer of resources.
     */
    case transfer(
        /**
         * When `true`, then this is a one-to-one transfer and the wallet can
         * regard this as a "simple transfer" and communicate this information
         * to the ledger hardware wallet. Otherwise, if `false`, then this is
         * not a one-to-one transfer.
         */ isOneToOne: Bool
    )
    /**
     * A manifest where XRD is claimed from one or more validators.
     */
    case validatorClaim(
        /**
         * The addresses of validators in the transaction
         */ validatorAddresses: [ValidatorAddress],
        /**
            * The claims observed in the transaction
            */ validatorClaims: [TrackedValidatorClaim]
    )
    /**
     * A manifest where XRD is staked to one or more validators.
     */
    case validatorStake(
        /**
         * The addresses of validators in the transaction
         */ validatorAddresses: [ValidatorAddress],
        /**
            * The stake observed in the transaction
            */ validatorStakes: [TrackedValidatorStake]
    )
    /**
     * A manifest where XRD is unstaked from one or more validators.
     */
    case validatorUnstake(
        /**
         * The addresses of validators in the transaction
         */ validatorAddresses: [ValidatorAddress],
        /**
            * The data associated with the various claim NFTs
            */ claimsNonFungibleData: [NonFungibleGlobalId: UnstakeData]
    )
    /**
     * A manifest that updated the deposit settings of the account.
     */
    case accountDepositSettingsUpdate(
        /**
         * Updates to the resource preferences of the account deposit settings.
         * account_address -> (resource_address -> Update<new_preference>)
         */ resourcePreferencesUpdates: [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]],
        /**
            * Changes to the account's deposit mode.
            * account_address -> new_default_deposit_mode
            */ depositModeUpdates: [AccountAddress: DepositRule],
        /**
            * Additions to the authorized depositors
            */ authorizedDepositorsAdded: [AccountAddress: [ResourceOrNonFungible]],
        /**
            * Removals from the authorized depositors
            */ authorizedDepositorsRemoved: [AccountAddress: [ResourceOrNonFungible]]
    )
    /**
     * A manifest that contributed some amount of resources to a liquidity
     * pool that can be a one-resource pool, two-resource pool, or a
     * multi-resource pool.
     */
    case poolContribution(
        /**
         * The addresses of the pools in the transaction
         */ poolAddresses: [PoolAddress],
        /**
            * The contribution observed in the transaction
            */ poolContributions: [TrackedPoolContribution]
    )
    /**
     * A manifest that redeemed resources from a liquidity pool. Similar to
     * contributions, this can be any of the three pool blueprints available
     * in the pool package.
     */
    case poolRedemption(
        /**
         * The addresses of the pools in the transaction
         */ poolAddresses: [PoolAddress],
        /**
            * The redemptions observed in the transaction
            */ poolRedemptions: [TrackedPoolRedemption]
    )
}

public struct FfiConverterTypeDetailedManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = DetailedManifestClass

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DetailedManifestClass {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .general

        case 2: return try .transfer(isOneToOne: FfiConverterBool.read(from: &buf)
            )

        case 3: return try .validatorClaim(validatorAddresses: FfiConverterSequenceTypeValidatorAddress.read(from: &buf), validatorClaims: FfiConverterSequenceTypeTrackedValidatorClaim.read(from: &buf))

        case 4: return try .validatorStake(validatorAddresses: FfiConverterSequenceTypeValidatorAddress.read(from: &buf), validatorStakes: FfiConverterSequenceTypeTrackedValidatorStake.read(from: &buf))

        case 5: return try .validatorUnstake(validatorAddresses: FfiConverterSequenceTypeValidatorAddress.read(from: &buf), claimsNonFungibleData: FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData.read(from: &buf))

        case 6: return try .accountDepositSettingsUpdate(resourcePreferencesUpdates: FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.read(from: &buf), depositModeUpdates: FfiConverterDictionaryTypeAccountAddressTypeDepositRule.read(from: &buf), authorizedDepositorsAdded: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.read(from: &buf), authorizedDepositorsRemoved: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.read(from: &buf))

        case 7: return try .poolContribution(poolAddresses: FfiConverterSequenceTypePoolAddress.read(from: &buf), poolContributions: FfiConverterSequenceTypeTrackedPoolContribution.read(from: &buf))

        case 8: return try .poolRedemption(poolAddresses: FfiConverterSequenceTypePoolAddress.read(from: &buf), poolRedemptions: FfiConverterSequenceTypeTrackedPoolRedemption.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DetailedManifestClass, into buf: inout [UInt8]) {
        switch value {
        case .general:
            writeInt(&buf, Int32(1))

        case let .transfer(isOneToOne):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(isOneToOne, into: &buf)

        case let .validatorClaim(validatorAddresses, validatorClaims):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedValidatorClaim.write(validatorClaims, into: &buf)

        case let .validatorStake(validatorAddresses, validatorStakes):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedValidatorStake.write(validatorStakes, into: &buf)

        case let .validatorUnstake(validatorAddresses, claimsNonFungibleData):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
            FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData.write(claimsNonFungibleData, into: &buf)

        case let .accountDepositSettingsUpdate(resourcePreferencesUpdates, depositModeUpdates, authorizedDepositorsAdded, authorizedDepositorsRemoved):
            writeInt(&buf, Int32(6))
            FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.write(resourcePreferencesUpdates, into: &buf)
            FfiConverterDictionaryTypeAccountAddressTypeDepositRule.write(depositModeUpdates, into: &buf)
            FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.write(authorizedDepositorsAdded, into: &buf)
            FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.write(authorizedDepositorsRemoved, into: &buf)

        case let .poolContribution(poolAddresses, poolContributions):
            writeInt(&buf, Int32(7))
            FfiConverterSequenceTypePoolAddress.write(poolAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedPoolContribution.write(poolContributions, into: &buf)

        case let .poolRedemption(poolAddresses, poolRedemptions):
            writeInt(&buf, Int32(8))
            FfiConverterSequenceTypePoolAddress.write(poolAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedPoolRedemption.write(poolRedemptions, into: &buf)
        }
    }
}

public func FfiConverterTypeDetailedManifestClass_lift(_ buf: RustBuffer) throws -> DetailedManifestClass {
    return try FfiConverterTypeDetailedManifestClass.lift(buf)
}

public func FfiConverterTypeDetailedManifestClass_lower(_ value: DetailedManifestClass) -> RustBuffer {
    return FfiConverterTypeDetailedManifestClass.lower(value)
}

extension DetailedManifestClass: Sendable {}
extension DetailedManifestClass: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * If we wanna create an Olympia DeviceFactorSource or
 * a Babylon one, either main or not.
 */

public enum DeviceFactorSourceType {
    case babylon(isMain: Bool
    )
    case olympia
}

public struct FfiConverterTypeDeviceFactorSourceType: FfiConverterRustBuffer {
    typealias SwiftType = DeviceFactorSourceType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSourceType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .babylon(isMain: FfiConverterBool.read(from: &buf)
            )

        case 2: return .olympia

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DeviceFactorSourceType, into buf: inout [UInt8]) {
        switch value {
        case let .babylon(isMain):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(isMain, into: &buf)

        case .olympia:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeDeviceFactorSourceType_lift(_ buf: RustBuffer) throws -> DeviceFactorSourceType {
    return try FfiConverterTypeDeviceFactorSourceType.lift(buf)
}

public func FfiConverterTypeDeviceFactorSourceType_lower(_ value: DeviceFactorSourceType) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSourceType.lower(value)
}

extension DeviceFactorSourceType: Sendable {}
extension DeviceFactorSourceType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EncryptionScheme {
    /**
     * AES GCM 256 encryption
     */
    case version1(AesGcm256
    )
}

public struct FfiConverterTypeEncryptionScheme: FfiConverterRustBuffer {
    typealias SwiftType = EncryptionScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .version1(FfiConverterTypeAesGcm256.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptionScheme, into buf: inout [UInt8]) {
        switch value {
        case let .version1(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesGcm256.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeEncryptionScheme_lift(_ buf: RustBuffer) throws -> EncryptionScheme {
    return try FfiConverterTypeEncryptionScheme.lift(buf)
}

public func FfiConverterTypeEncryptionScheme_lower(_ value: EncryptionScheme) -> RustBuffer {
    return FfiConverterTypeEncryptionScheme.lower(value)
}

extension EncryptionScheme: Sendable {}
extension EncryptionScheme: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Flags used to mark state of an Account or Persona such as whether
 * user has marked it as deleted or not.
 */

public enum EntityFlag {
    /**
     * The entity is marked as deleted by user. Entity should still be kept in Profile
     */
    case deletedByUser
    /**
     * Just a temporary placeholder value used by Sample Values.
     */
    case placeholderSampleValueFlag
}

public struct FfiConverterTypeEntityFlag: FfiConverterRustBuffer {
    typealias SwiftType = EntityFlag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityFlag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .deletedByUser

        case 2: return .placeholderSampleValueFlag

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityFlag, into buf: inout [UInt8]) {
        switch value {
        case .deletedByUser:
            writeInt(&buf, Int32(1))

        case .placeholderSampleValueFlag:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeEntityFlag_lift(_ buf: RustBuffer) throws -> EntityFlag {
    return try FfiConverterTypeEntityFlag.lift(buf)
}

public func FfiConverterTypeEntityFlag_lower(_ value: EntityFlag) -> RustBuffer {
    return FfiConverterTypeEntityFlag.lower(value)
}

extension EntityFlag: Sendable {}
extension EntityFlag: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EntityKind {
    case account
    case persona
}

public struct FfiConverterTypeEntityKind: FfiConverterRustBuffer {
    typealias SwiftType = EntityKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .account

        case 2: return .persona

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityKind, into buf: inout [UInt8]) {
        switch value {
        case .account:
            writeInt(&buf, Int32(1))

        case .persona:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeEntityKind_lift(_ buf: RustBuffer) throws -> EntityKind {
    return try FfiConverterTypeEntityKind.lift(buf)
}

public func FfiConverterTypeEntityKind_lower(_ value: EntityKind) -> RustBuffer {
    return FfiConverterTypeEntityKind.lower(value)
}

extension EntityKind: Sendable {}
extension EntityKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the state an entity - Account or Persona - is in, in regards to how
 * the user controls it, i.e. if it is controlled by a single factor (private key)
 * or an `AccessController` with a potential Multi-Factor setup.
 */

public enum EntitySecurityState {
    /**
     * The account is controlled by a single factor (private key)
     */
    case unsecured(value: UnsecuredEntityControl
    )
}

public struct FfiConverterTypeEntitySecurityState: FfiConverterRustBuffer {
    typealias SwiftType = EntitySecurityState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntitySecurityState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .unsecured(value: FfiConverterTypeUnsecuredEntityControl.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntitySecurityState, into buf: inout [UInt8]) {
        switch value {
        case let .unsecured(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUnsecuredEntityControl.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeEntitySecurityState_lift(_ buf: RustBuffer) throws -> EntitySecurityState {
    return try FfiConverterTypeEntitySecurityState.lift(buf)
}

public func FfiConverterTypeEntitySecurityState_lower(_ value: EntitySecurityState) -> RustBuffer {
    return FfiConverterTypeEntitySecurityState.lower(value)
}

extension EntitySecurityState: Sendable {}
extension EntitySecurityState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * SargonOS event contain information about something of interest that has
 * happened to the SargonOS, most prominently to the Profile. Host device
 * can subscribe to these events by use of `EventBusDriver`.
 */

public enum Event {
    /**
     * The SargonOS just booted.
     */
    case booted
    /**
     * Current Gateway changed
     */
    case gatewayChangedCurrent(to: Gateway, isNew: Bool)
    /**
     * Profile has been saved, typically it has been modified and the new
     * changed Profile got persisted into secure storage.
     */
    case profileSaved
    /**
     * A profile has been imported and has been set to active profile,
     * and saved into secure storage.
     */
    case profileImported(id: ProfileId
    )
    /**
     * The active profile has been modified (might not have been saved yet).
     */
    case profileModified(change: EventProfileModified
    )
    /**
     * The Profile was last used on another device, user ought to claim it.
     */
    case profileUsedOnOtherDevice(DeviceInfo
    )
}

public struct FfiConverterTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .booted

        case 2: return try .gatewayChangedCurrent(to: FfiConverterTypeGateway.read(from: &buf), isNew: FfiConverterBool.read(from: &buf))

        case 3: return .profileSaved

        case 4: return try .profileImported(id: FfiConverterTypeProfileID.read(from: &buf)
            )

        case 5: return try .profileModified(change: FfiConverterTypeEventProfileModified.read(from: &buf)
            )

        case 6: return try .profileUsedOnOtherDevice(FfiConverterTypeDeviceInfo.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        switch value {
        case .booted:
            writeInt(&buf, Int32(1))

        case let .gatewayChangedCurrent(to, isNew):
            writeInt(&buf, Int32(2))
            FfiConverterTypeGateway.write(to, into: &buf)
            FfiConverterBool.write(isNew, into: &buf)

        case .profileSaved:
            writeInt(&buf, Int32(3))

        case let .profileImported(id):
            writeInt(&buf, Int32(4))
            FfiConverterTypeProfileID.write(id, into: &buf)

        case let .profileModified(change):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEventProfileModified.write(change, into: &buf)

        case let .profileUsedOnOtherDevice(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeDeviceInfo.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeEvent_lift(_ buf: RustBuffer) throws -> Event {
    return try FfiConverterTypeEvent.lift(buf)
}

public func FfiConverterTypeEvent_lower(_ value: Event) -> RustBuffer {
    return FfiConverterTypeEvent.lower(value)
}

extension Event: Sendable {}
extension Event: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A discriminator identifying the kind of `Event`, this has no associated
 * values and flattens the otherwise nested `Event` enum.
 */

public enum EventKind {
    /**
     * Profile updated with a new account.
     */
    case accountAdded
    /**
     * Profile updated with new accounts.
     */
    case accountsAdded
    /**
     * An existing account has been updated
     */
    case accountUpdated
    /**
     * SargonOS did boot.
     */
    case booted
    /**
     * Current Gateway changed
     */
    case gatewayChangedCurrent
    /**
     * Profile was saved.
     */
    case profileSaved
    /**
     * A profile has been imported and has been set to active profile,
     * and saved into secure storage.
     */
    case profileImported
    /**
     * Profile was last used on another device.
     */
    case profileUsedOnOtherDevice
    /**
     * Profile updated with a new factor source.
     */
    case factorSourceAdded
    /**
     * Profile updated with multiple new factor sources.
     */
    case factorSourcesAdded
    /**
     * An existing factor source has been updated
     */
    case factorSourceUpdated
    /**
     * Profile updated with a new Security Structure.
     */
    case securityStructureAdded
}

public struct FfiConverterTypeEventKind: FfiConverterRustBuffer {
    typealias SwiftType = EventKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .accountAdded

        case 2: return .accountsAdded

        case 3: return .accountUpdated

        case 4: return .booted

        case 5: return .gatewayChangedCurrent

        case 6: return .profileSaved

        case 7: return .profileImported

        case 8: return .profileUsedOnOtherDevice

        case 9: return .factorSourceAdded

        case 10: return .factorSourcesAdded

        case 11: return .factorSourceUpdated

        case 12: return .securityStructureAdded

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventKind, into buf: inout [UInt8]) {
        switch value {
        case .accountAdded:
            writeInt(&buf, Int32(1))

        case .accountsAdded:
            writeInt(&buf, Int32(2))

        case .accountUpdated:
            writeInt(&buf, Int32(3))

        case .booted:
            writeInt(&buf, Int32(4))

        case .gatewayChangedCurrent:
            writeInt(&buf, Int32(5))

        case .profileSaved:
            writeInt(&buf, Int32(6))

        case .profileImported:
            writeInt(&buf, Int32(7))

        case .profileUsedOnOtherDevice:
            writeInt(&buf, Int32(8))

        case .factorSourceAdded:
            writeInt(&buf, Int32(9))

        case .factorSourcesAdded:
            writeInt(&buf, Int32(10))

        case .factorSourceUpdated:
            writeInt(&buf, Int32(11))

        case .securityStructureAdded:
            writeInt(&buf, Int32(12))
        }
    }
}

public func FfiConverterTypeEventKind_lift(_ buf: RustBuffer) throws -> EventKind {
    return try FfiConverterTypeEventKind.lift(buf)
}

public func FfiConverterTypeEventKind_lower(_ value: EventKind) -> RustBuffer {
    return FfiConverterTypeEventKind.lower(value)
}

extension EventKind: Sendable {}
extension EventKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The active profile has been modified (might not have been saved yet).
 */

public enum EventProfileModified {
    /**
     * A new account with `address` was inserted into the active profile
     */
    case accountAdded(address: AccountAddress
    )
    /**
     * New accounts with `addresses` were inserted into the active profile
     */
    case accountsAdded(addresses: [AccountAddress]
    )
    /**
     * An existing account has been updated
     */
    case accountUpdated(address: AccountAddress
    )
    /**
     * Profile updated with a new factor source.
     */
    case factorSourceAdded(id: FactorSourceId
    )
    /**
     * Profile updated with many new factor sources.
     */
    case factorSourcesAdded(ids: [FactorSourceId]
    )
    /**
     * An existing factor source has been updated
     */
    case factorSourceUpdated(id: FactorSourceId
    )
    /**
     * Profile updated with a new Security Structure.
     */
    case securityStructureAdded(id: SecurityStructureId
    )
}

public struct FfiConverterTypeEventProfileModified: FfiConverterRustBuffer {
    typealias SwiftType = EventProfileModified

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventProfileModified {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .accountAdded(address: FfiConverterTypeAccountAddress.read(from: &buf)
            )

        case 2: return try .accountsAdded(addresses: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
            )

        case 3: return try .accountUpdated(address: FfiConverterTypeAccountAddress.read(from: &buf)
            )

        case 4: return try .factorSourceAdded(id: FfiConverterTypeFactorSourceID.read(from: &buf)
            )

        case 5: return try .factorSourcesAdded(ids: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
            )

        case 6: return try .factorSourceUpdated(id: FfiConverterTypeFactorSourceID.read(from: &buf)
            )

        case 7: return try .securityStructureAdded(id: FfiConverterTypeSecurityStructureID.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventProfileModified, into buf: inout [UInt8]) {
        switch value {
        case let .accountAdded(address):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountAddress.write(address, into: &buf)

        case let .accountsAdded(addresses):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeAccountAddress.write(addresses, into: &buf)

        case let .accountUpdated(address):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAccountAddress.write(address, into: &buf)

        case let .factorSourceAdded(id):
            writeInt(&buf, Int32(4))
            FfiConverterTypeFactorSourceID.write(id, into: &buf)

        case let .factorSourcesAdded(ids):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeFactorSourceID.write(ids, into: &buf)

        case let .factorSourceUpdated(id):
            writeInt(&buf, Int32(6))
            FfiConverterTypeFactorSourceID.write(id, into: &buf)

        case let .securityStructureAdded(id):
            writeInt(&buf, Int32(7))
            FfiConverterTypeSecurityStructureID.write(id, into: &buf)
        }
    }
}

public func FfiConverterTypeEventProfileModified_lift(_ buf: RustBuffer) throws -> EventProfileModified {
    return try FfiConverterTypeEventProfileModified.lift(buf)
}

public func FfiConverterTypeEventProfileModified_lower(_ value: EventProfileModified) -> RustBuffer {
    return FfiConverterTypeEventProfileModified.lower(value)
}

extension EventProfileModified: Sendable {}
extension EventProfileModified: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either a "physical" badge (resource) or some source for recreation of a producer
 * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
 * is derived which produces virtual badges (signatures).
 */

public enum FactorInstanceBadge {
    case virtual(value: FactorInstanceBadgeVirtualSource
    )
    case physical(value: ResourceAddress
    )
}

public struct FfiConverterTypeFactorInstanceBadge: FfiConverterRustBuffer {
    typealias SwiftType = FactorInstanceBadge

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceBadge {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .virtual(value: FfiConverterTypeFactorInstanceBadgeVirtualSource.read(from: &buf)
            )

        case 2: return try .physical(value: FfiConverterTypeResourceAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorInstanceBadge, into buf: inout [UInt8]) {
        switch value {
        case let .virtual(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFactorInstanceBadgeVirtualSource.write(value, into: &buf)

        case let .physical(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorInstanceBadge_lift(_ buf: RustBuffer) throws -> FactorInstanceBadge {
    return try FfiConverterTypeFactorInstanceBadge.lift(buf)
}

public func FfiConverterTypeFactorInstanceBadge_lower(_ value: FactorInstanceBadge) -> RustBuffer {
    return FfiConverterTypeFactorInstanceBadge.lower(value)
}

extension FactorInstanceBadge: Sendable {}
extension FactorInstanceBadge: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FactorInstanceBadgeVirtualSource {
    case hierarchicalDeterministic(value: HierarchicalDeterministicPublicKey
    )
}

public struct FfiConverterTypeFactorInstanceBadgeVirtualSource: FfiConverterRustBuffer {
    typealias SwiftType = FactorInstanceBadgeVirtualSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceBadgeVirtualSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .hierarchicalDeterministic(value: FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorInstanceBadgeVirtualSource, into buf: inout [UInt8]) {
        switch value {
        case let .hierarchicalDeterministic(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeHierarchicalDeterministicPublicKey.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorInstanceBadgeVirtualSource_lift(_ buf: RustBuffer) throws -> FactorInstanceBadgeVirtualSource {
    return try FfiConverterTypeFactorInstanceBadgeVirtualSource.lift(buf)
}

public func FfiConverterTypeFactorInstanceBadgeVirtualSource_lower(_ value: FactorInstanceBadgeVirtualSource) -> RustBuffer {
    return FfiConverterTypeFactorInstanceBadgeVirtualSource.lower(value)
}

extension FactorInstanceBadgeVirtualSource: Sendable {}
extension FactorInstanceBadgeVirtualSource: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FactorSource {
    case device(value: DeviceFactorSource
    )
    case ledger(value: LedgerHardwareWalletFactorSource
    )
    case offDeviceMnemonic(value: OffDeviceMnemonicFactorSource
    )
    case arculusCard(value: ArculusCardFactorSource
    )
    case securityQuestions(value: SecurityQuestionsNotProductionReadyFactorSource
    )
    case trustedContact(value: TrustedContactFactorSource
    )
}

public struct FfiConverterTypeFactorSource: FfiConverterRustBuffer {
    typealias SwiftType = FactorSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .device(value: FfiConverterTypeDeviceFactorSource.read(from: &buf)
            )

        case 2: return try .ledger(value: FfiConverterTypeLedgerHardwareWalletFactorSource.read(from: &buf)
            )

        case 3: return try .offDeviceMnemonic(value: FfiConverterTypeOffDeviceMnemonicFactorSource.read(from: &buf)
            )

        case 4: return try .arculusCard(value: FfiConverterTypeArculusCardFactorSource.read(from: &buf)
            )

        case 5: return try .securityQuestions(value: FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.read(from: &buf)
            )

        case 6: return try .trustedContact(value: FfiConverterTypeTrustedContactFactorSource.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSource, into buf: inout [UInt8]) {
        switch value {
        case let .device(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDeviceFactorSource.write(value, into: &buf)

        case let .ledger(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLedgerHardwareWalletFactorSource.write(value, into: &buf)

        case let .offDeviceMnemonic(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeOffDeviceMnemonicFactorSource.write(value, into: &buf)

        case let .arculusCard(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeArculusCardFactorSource.write(value, into: &buf)

        case let .securityQuestions(value):
            writeInt(&buf, Int32(5))
            FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.write(value, into: &buf)

        case let .trustedContact(value):
            writeInt(&buf, Int32(6))
            FfiConverterTypeTrustedContactFactorSource.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorSource_lift(_ buf: RustBuffer) throws -> FactorSource {
    return try FfiConverterTypeFactorSource.lift(buf)
}

public func FfiConverterTypeFactorSource_lower(_ value: FactorSource) -> RustBuffer {
    return FfiConverterTypeFactorSource.lower(value)
}

extension FactorSource: Sendable {}
extension FactorSource: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Flags which describe a certain state a FactorSource might be in, primarily used
 * by DeviceFactorSource's to mark which "Babylon" FactorSource is the **main** one.
 */

public enum FactorSourceFlag {
    /**
     * Used to mark a "babylon" `.device` FactorSource as "main". All new accounts
     * and Personas are created using the `main` `DeviceFactorSource`.
     *
     * We can only ever have one.
     * We might have zero `main` flags across all  `DeviceFactorSource`s if and only if we have only one  `DeviceFactorSource`s. If we have two or more  `DeviceFactorSource`s one of them MUST
     * be marked with `main`.
     */
    case main
    /**
     * Until we have implemented "proper" deletion, we will "flag" a
     * FactorSource as deleted by the user and hide it, meaning e.g.
     * that in Multi-Factor Setup flows it will not show up.
     */
    case deletedByUser
}

public struct FfiConverterTypeFactorSourceFlag: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceFlag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceFlag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .main

        case 2: return .deletedByUser

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceFlag, into buf: inout [UInt8]) {
        switch value {
        case .main:
            writeInt(&buf, Int32(1))

        case .deletedByUser:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeFactorSourceFlag_lift(_ buf: RustBuffer) throws -> FactorSourceFlag {
    return try FfiConverterTypeFactorSourceFlag.lift(buf)
}

public func FfiConverterTypeFactorSourceFlag_lower(_ value: FactorSourceFlag) -> RustBuffer {
    return FfiConverterTypeFactorSourceFlag.lower(value)
}

extension FactorSourceFlag: Sendable {}
extension FactorSourceFlag: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A unique and stable identifier of a FactorSource, e.g. a
 * DeviceFactorSource being a mnemonic securely stored in a
 * device (phone), where the ID of it is the hash of a special
 * key derived near the root of it.
 */

public enum FactorSourceId {
    /**
     * FactorSourceID from the blake2b hash of the special HD public key derived at `CAP26::GetID`,
     * for a certain `FactorSourceKind`
     */
    case hash(value: FactorSourceIdFromHash
    )
    /**
     * FactorSourceID from an AccountAddress, typically used by `trustedContact` FactorSource.
     */
    case address(value: FactorSourceIdFromAddress
    )
}

public struct FfiConverterTypeFactorSourceID: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .hash(value: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )

        case 2: return try .address(value: FfiConverterTypeFactorSourceIDFromAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceId, into buf: inout [UInt8]) {
        switch value {
        case let .hash(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFactorSourceIDFromHash.write(value, into: &buf)

        case let .address(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFactorSourceIDFromAddress.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorSourceID_lift(_ buf: RustBuffer) throws -> FactorSourceId {
    return try FfiConverterTypeFactorSourceID.lift(buf)
}

public func FfiConverterTypeFactorSourceID_lower(_ value: FactorSourceId) -> RustBuffer {
    return FfiConverterTypeFactorSourceID.lower(value)
}

extension FactorSourceId: Sendable {}
extension FactorSourceId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The **kind** (or "type") of FactorSource describes how it is used.
 */

public enum FactorSourceKind {
    /**
     * A user owned unencrypted mnemonic (and optional BIP39 passphrase) stored on device,
     * thus directly usable. This kind is used as the standard factor source for all new
     * wallet users.
     *
     * Attributes:
     * * Mine
     * * On device
     * * Hierarchical deterministic (Mnemonic)
     * * Entity creating
     */
    case device
    /**
     * A user owned hardware wallet by vendor Ledger HQ, most commonly
     * a Ledger Nano S or Ledger Nano X. Less common models are Ledger Nano S Plus
     * Ledger Stax.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hardware (requires Browser Connector Extension to communicate with wallet)
     * * Hierarchical deterministic
     * * Entity creating (accounts only)
     */
    case ledgerHqHardwareWallet
    /**
     * A user owned mnemonic (and optional BIP39 passphrase) user has to input when used,
     * e.g. during signing.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic  (Mnemonic)
     */
    case offDeviceMnemonic
    /**
     * A contact, friend, company, organization or otherwise third party the user trusts enough
     * to be given a recovery token user has minted and sent the this contact.
     *
     * Attributes:
     * * **Not** mine
     * * Off device
     */
    case trustedContact
    /**
     * An encrypted user owned mnemonic (*never* any BIP39 passphrase) which can
     * be decrypted by answers to **security question**, which are personal questions
     * that should be only known to the user.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic  (**Encrypted** mnemonic)
     */
    case securityQuestions
    /**
     * An Arculus card, in credit card size, communicating with host using NFC.
     *
     * For more info see [link]
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic  (**Encrypted** mnemonic)\
     * * Hardware (communicates with host using NFC)
     *
     * [link]: https://www.getarculus.com/
     */
    case arculusCard
}

public struct FfiConverterTypeFactorSourceKind: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .device

        case 2: return .ledgerHqHardwareWallet

        case 3: return .offDeviceMnemonic

        case 4: return .trustedContact

        case 5: return .securityQuestions

        case 6: return .arculusCard

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceKind, into buf: inout [UInt8]) {
        switch value {
        case .device:
            writeInt(&buf, Int32(1))

        case .ledgerHqHardwareWallet:
            writeInt(&buf, Int32(2))

        case .offDeviceMnemonic:
            writeInt(&buf, Int32(3))

        case .trustedContact:
            writeInt(&buf, Int32(4))

        case .securityQuestions:
            writeInt(&buf, Int32(5))

        case .arculusCard:
            writeInt(&buf, Int32(6))
        }
    }
}

public func FfiConverterTypeFactorSourceKind_lift(_ buf: RustBuffer) throws -> FactorSourceKind {
    return try FfiConverterTypeFactorSourceKind.lift(buf)
}

public func FfiConverterTypeFactorSourceKind_lower(_ value: FactorSourceKind) -> RustBuffer {
    return FfiConverterTypeFactorSourceKind.lower(value)
}

extension FactorSourceKind: Sendable {}
extension FactorSourceKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Fiat currency to measure and display the value of some XRD or other Radix assets value/worth in.
 */

public enum FiatCurrency {
    /**
     * American dollars.
     */
    case usd
    /**
     * Swedish krona.
     */
    case sek
}

public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = FiatCurrency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .usd

        case 2: return .sek

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        switch value {
        case .usd:
            writeInt(&buf, Int32(1))

        case .sek:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(buf)
}

public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
    return FfiConverterTypeFiatCurrency.lower(value)
}

extension FiatCurrency: Sendable {}
extension FiatCurrency: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FungibleResourceIndicator {
    case guaranteed(decimal: Decimal192
    )
    case predicted(predictedDecimal: PredictedDecimal
    )
}

public struct FfiConverterTypeFungibleResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = FungibleResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .guaranteed(decimal: FfiConverterTypeDecimal192.read(from: &buf)
            )

        case 2: return try .predicted(predictedDecimal: FfiConverterTypePredictedDecimal.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FungibleResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        case let .guaranteed(decimal):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal192.write(decimal, into: &buf)

        case let .predicted(predictedDecimal):
            writeInt(&buf, Int32(2))
            FfiConverterTypePredictedDecimal.write(predictedDecimal, into: &buf)
        }
    }
}

public func FfiConverterTypeFungibleResourceIndicator_lift(_ buf: RustBuffer) throws -> FungibleResourceIndicator {
    return try FfiConverterTypeFungibleResourceIndicator.lift(buf)
}

public func FfiConverterTypeFungibleResourceIndicator_lower(_ value: FungibleResourceIndicator) -> RustBuffer {
    return FfiConverterTypeFungibleResourceIndicator.lower(value)
}

extension FungibleResourceIndicator: Sendable {}
extension FungibleResourceIndicator: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FungibleResourcesCollectionItem {
    case global(FungibleResourcesCollectionItemGloballyAggregated
    )
}

public struct FfiConverterTypeFungibleResourcesCollectionItem: FfiConverterRustBuffer {
    typealias SwiftType = FungibleResourcesCollectionItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourcesCollectionItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .global(FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FungibleResourcesCollectionItem, into buf: inout [UInt8]) {
        switch value {
        case let .global(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFungibleResourcesCollectionItemGloballyAggregated.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeFungibleResourcesCollectionItem_lift(_ buf: RustBuffer) throws -> FungibleResourcesCollectionItem {
    return try FfiConverterTypeFungibleResourcesCollectionItem.lift(buf)
}

public func FfiConverterTypeFungibleResourcesCollectionItem_lower(_ value: FungibleResourcesCollectionItem) -> RustBuffer {
    return FfiConverterTypeFungibleResourcesCollectionItem.lower(value)
}

extension FungibleResourcesCollectionItem: Sendable {}
extension FungibleResourcesCollectionItem: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GwPublicKey {
    case secp256k1(Secp256k1PublicKey
    )
    case ed25519(Ed25519PublicKey
    )
}

public struct FfiConverterTypeGWPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = GwPublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GwPublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
            )

        case 2: return try .ed25519(FfiConverterTypeEd25519PublicKey.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GwPublicKey, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecp256k1PublicKey.write(v1, into: &buf)

        case let .ed25519(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEd25519PublicKey.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeGWPublicKey_lift(_ buf: RustBuffer) throws -> GwPublicKey {
    return try FfiConverterTypeGWPublicKey.lift(buf)
}

public func FfiConverterTypeGWPublicKey_lower(_ value: GwPublicKey) -> RustBuffer {
    return FfiConverterTypeGWPublicKey.lower(value)
}

extension GwPublicKey: Sendable {}
extension GwPublicKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum describing the different cards that Wallet can display on home page.
 * Each card has an associated content and optional action.
 */

public enum HomeCard {
    /**
     * Content: "Start RadQuest, learn about Radix, earn XRD and collectibles."
     * Action: Redirect user to RadQuest.
     */
    case startRadQuest
    /**
     * Content: "Continue your Radix journey in your browser. Tap to dismiss."
     * Action: None.
     */
    case continueRadQuest
    /**
     * Content: "You can now connect with your Radix Wallet. Tap to dismiss."
     * Action: None.
     */
    case dapp(iconUrl: Url?
    )
    /**
     * Content: "To use Radix Wallet with desktop browsers, finish setup by visiting wallet.radixdlt.com"
     * Action: None
     */
    case connector
}

public struct FfiConverterTypeHomeCard: FfiConverterRustBuffer {
    typealias SwiftType = HomeCard

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCard {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .startRadQuest

        case 2: return .continueRadQuest

        case 3: return try .dapp(iconUrl: FfiConverterOptionTypeUrl.read(from: &buf)
            )

        case 4: return .connector

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HomeCard, into buf: inout [UInt8]) {
        switch value {
        case .startRadQuest:
            writeInt(&buf, Int32(1))

        case .continueRadQuest:
            writeInt(&buf, Int32(2))

        case let .dapp(iconUrl):
            writeInt(&buf, Int32(3))
            FfiConverterOptionTypeUrl.write(iconUrl, into: &buf)

        case .connector:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeHomeCard_lift(_ buf: RustBuffer) throws -> HomeCard {
    return try FfiConverterTypeHomeCard.lift(buf)
}

public func FfiConverterTypeHomeCard_lower(_ value: HomeCard) -> RustBuffer {
    return FfiConverterTypeHomeCard.lower(value)
}

extension HomeCard: Sendable {}
extension HomeCard: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the type of the Host machine and its version. Currently, as it stands at runtime
 * the possible values will be IOS or Android. Other is in place to facilitate unit tests
 * and to make sargon host agnostic.
 */

public enum HostOs {
    case ios(version: String
    )
    case android(vendor: String, version: String)
    case other(name: String, vendor: String, version: String)
}

public struct FfiConverterTypeHostOS: FfiConverterRustBuffer {
    typealias SwiftType = HostOs

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostOs {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .ios(version: FfiConverterString.read(from: &buf)
            )

        case 2: return try .android(vendor: FfiConverterString.read(from: &buf), version: FfiConverterString.read(from: &buf))

        case 3: return try .other(name: FfiConverterString.read(from: &buf), vendor: FfiConverterString.read(from: &buf), version: FfiConverterString.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HostOs, into buf: inout [UInt8]) {
        switch value {
        case let .ios(version):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(version, into: &buf)

        case let .android(vendor, version):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(vendor, into: &buf)
            FfiConverterString.write(version, into: &buf)

        case let .other(name, vendor, version):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(name, into: &buf)
            FfiConverterString.write(vendor, into: &buf)
            FfiConverterString.write(version, into: &buf)
        }
    }
}

public func FfiConverterTypeHostOS_lift(_ buf: RustBuffer) throws -> HostOs {
    return try FfiConverterTypeHostOS.lift(buf)
}

public func FfiConverterTypeHostOS_lower(_ value: HostOs) -> RustBuffer {
    return FfiConverterTypeHostOS.lower(value)
}

extension HostOs: Sendable {}
extension HostOs: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The model of a Ledger HQ hardware wallet NanoS, e.g.
 * *Ledger Nano S+*.
 */

public enum LedgerHardwareWalletModel {
    case nanoS
    case nanoSPlus
    case nanoX
}

public struct FfiConverterTypeLedgerHardwareWalletModel: FfiConverterRustBuffer {
    typealias SwiftType = LedgerHardwareWalletModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletModel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .nanoS

        case 2: return .nanoSPlus

        case 3: return .nanoX

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LedgerHardwareWalletModel, into buf: inout [UInt8]) {
        switch value {
        case .nanoS:
            writeInt(&buf, Int32(1))

        case .nanoSPlus:
            writeInt(&buf, Int32(2))

        case .nanoX:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeLedgerHardwareWalletModel_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletModel {
    return try FfiConverterTypeLedgerHardwareWalletModel.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletModel_lower(_ value: LedgerHardwareWalletModel) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletModel.lower(value)
}

extension LedgerHardwareWalletModel: Sendable {}
extension LedgerHardwareWalletModel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogFilter: UInt8 {
    /**
     * Logging is turned off
     */
    case off = 0
    /**
     * The "error" level.
     *
     * Designates very serious errors.
     */
    case error = 1
    /**
     * The "warn" level.
     *
     * Designates hazardous situations.
     */
    case warn = 2
    /**
     * The "info" level.
     *
     * Designates useful information.
     */
    case info = 3
    /**
     * The "debug" level.
     *
     * Designates lower priority information.
     */
    case debug = 4
    /**
     * The "trace" level.
     *
     * Designates very low priority, often extremely verbose, information.
     */
    case trace = 5
}

public struct FfiConverterTypeLogFilter: FfiConverterRustBuffer {
    typealias SwiftType = LogFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .off

        case 2: return .error

        case 3: return .warn

        case 4: return .info

        case 5: return .debug

        case 6: return .trace

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogFilter, into buf: inout [UInt8]) {
        switch value {
        case .off:
            writeInt(&buf, Int32(1))

        case .error:
            writeInt(&buf, Int32(2))

        case .warn:
            writeInt(&buf, Int32(3))

        case .info:
            writeInt(&buf, Int32(4))

        case .debug:
            writeInt(&buf, Int32(5))

        case .trace:
            writeInt(&buf, Int32(6))
        }
    }
}

public func FfiConverterTypeLogFilter_lift(_ buf: RustBuffer) throws -> LogFilter {
    return try FfiConverterTypeLogFilter.lift(buf)
}

public func FfiConverterTypeLogFilter_lower(_ value: LogFilter) -> RustBuffer {
    return FfiConverterTypeLogFilter.lower(value)
}

extension LogFilter: Sendable {}
extension LogFilter: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel: UInt8 {
    /**
     * The "error" level.
     *
     * Designates very serious errors.
     */
    case error = 1
    /**
     * The "warn" level.
     *
     * Designates hazardous situations.
     */
    case warn = 2
    /**
     * The "info" level.
     *
     * Designates useful information.
     */
    case info = 3
    /**
     * The "debug" level.
     *
     * Designates lower priority information.
     */
    case debug = 4
    /**
     * The "trace" level.
     *
     * Designates very low priority, often extremely verbose, information.
     */
    case trace = 5
}

public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .error

        case 2: return .warn

        case 3: return .info

        case 4: return .debug

        case 5: return .trace

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        case .error:
            writeInt(&buf, Int32(1))

        case .warn:
            writeInt(&buf, Int32(2))

        case .info:
            writeInt(&buf, Int32(3))

        case .debug:
            writeInt(&buf, Int32(4))

        case .trace:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}

extension LogLevel: Sendable {}
extension LogLevel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Message {
    case plainText(plaintext: PlaintextMessage
    )
    case none
}

public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .plainText(plaintext: FfiConverterTypePlaintextMessage.read(from: &buf)
            )

        case 2: return .none

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        switch value {
        case let .plainText(plaintext):
            writeInt(&buf, Int32(1))
            FfiConverterTypePlaintextMessage.write(plaintext, into: &buf)

        case .none:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}

extension Message: Sendable {}
extension Message: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * We explicitly mark content as either String or Bytes - this distinguishes (along with the mime type)
 * whether the message is intended to be displayable as text, or not.
 *
 * This data model ensures that messages intended to be displayable as text are valid unicode strings.
 */

public enum MessageContents {
    case stringMessage(string: String
    )
    case binaryMessage(bagOfBytes: BagOfBytes
    )
}

public struct FfiConverterTypeMessageContents: FfiConverterRustBuffer {
    typealias SwiftType = MessageContents

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageContents {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .stringMessage(string: FfiConverterString.read(from: &buf)
            )

        case 2: return try .binaryMessage(bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageContents, into buf: inout [UInt8]) {
        switch value {
        case let .stringMessage(string):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(string, into: &buf)

        case let .binaryMessage(bagOfBytes):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBagOfBytes.write(bagOfBytes, into: &buf)
        }
    }
}

public func FfiConverterTypeMessageContents_lift(_ buf: RustBuffer) throws -> MessageContents {
    return try FfiConverterTypeMessageContents.lift(buf)
}

public func FfiConverterTypeMessageContents_lower(_ value: MessageContents) -> RustBuffer {
    return FfiConverterTypeMessageContents.lower(value)
}

extension MessageContents: Sendable {}
extension MessageContents: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Note: Current implementation only adds support for associated values of `MetadataStringValue` & `MetadataUrlValue` variants.
 *
 * Will need to add support for remaining variants if we want to check its values.
 */

public enum MetadataTypedValue {
    case metadataBoolValue
    case metadataBoolArrayValue
    case metadataDecimalValue
    case metadataDecimalArrayValue
    case metadataGlobalAddressValue
    case metadataGlobalAddressArrayValue
    case metadataI32Value
    case metadataI32ArrayValue
    case metadataI64Value
    case metadataI64ArrayValue
    case metadataInstantValue
    case metadataInstantArrayValue
    case metadataNonFungibleGlobalIdValue
    case metadataNonFungibleGlobalIdArrayValue
    case metadataNonFungibleLocalIdValue
    case metadataNonFungibleLocalIdArrayValue
    case metadataOriginValue
    case metadataOriginArrayValue
    case metadataPublicKeyValue
    case metadataPublicKeyArrayValue
    case metadataPublicKeyHashValue
    case metadataPublicKeyHashArrayValue
    case metadataStringValue(value: String
    )
    case metadataStringArrayValue
    case metadataU32Value
    case metadataU32ArrayValue
    case metadataU64Value
    case metadataU64ArrayValue
    case metadataU8Value
    case metadataU8ArrayValue
    case metadataUrlValue(value: Url
    )
    case metadataUrlArrayValue
}

public struct FfiConverterTypeMetadataTypedValue: FfiConverterRustBuffer {
    typealias SwiftType = MetadataTypedValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataTypedValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .metadataBoolValue

        case 2: return .metadataBoolArrayValue

        case 3: return .metadataDecimalValue

        case 4: return .metadataDecimalArrayValue

        case 5: return .metadataGlobalAddressValue

        case 6: return .metadataGlobalAddressArrayValue

        case 7: return .metadataI32Value

        case 8: return .metadataI32ArrayValue

        case 9: return .metadataI64Value

        case 10: return .metadataI64ArrayValue

        case 11: return .metadataInstantValue

        case 12: return .metadataInstantArrayValue

        case 13: return .metadataNonFungibleGlobalIdValue

        case 14: return .metadataNonFungibleGlobalIdArrayValue

        case 15: return .metadataNonFungibleLocalIdValue

        case 16: return .metadataNonFungibleLocalIdArrayValue

        case 17: return .metadataOriginValue

        case 18: return .metadataOriginArrayValue

        case 19: return .metadataPublicKeyValue

        case 20: return .metadataPublicKeyArrayValue

        case 21: return .metadataPublicKeyHashValue

        case 22: return .metadataPublicKeyHashArrayValue

        case 23: return try .metadataStringValue(value: FfiConverterString.read(from: &buf)
            )

        case 24: return .metadataStringArrayValue

        case 25: return .metadataU32Value

        case 26: return .metadataU32ArrayValue

        case 27: return .metadataU64Value

        case 28: return .metadataU64ArrayValue

        case 29: return .metadataU8Value

        case 30: return .metadataU8ArrayValue

        case 31: return try .metadataUrlValue(value: FfiConverterTypeUrl.read(from: &buf)
            )

        case 32: return .metadataUrlArrayValue

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MetadataTypedValue, into buf: inout [UInt8]) {
        switch value {
        case .metadataBoolValue:
            writeInt(&buf, Int32(1))

        case .metadataBoolArrayValue:
            writeInt(&buf, Int32(2))

        case .metadataDecimalValue:
            writeInt(&buf, Int32(3))

        case .metadataDecimalArrayValue:
            writeInt(&buf, Int32(4))

        case .metadataGlobalAddressValue:
            writeInt(&buf, Int32(5))

        case .metadataGlobalAddressArrayValue:
            writeInt(&buf, Int32(6))

        case .metadataI32Value:
            writeInt(&buf, Int32(7))

        case .metadataI32ArrayValue:
            writeInt(&buf, Int32(8))

        case .metadataI64Value:
            writeInt(&buf, Int32(9))

        case .metadataI64ArrayValue:
            writeInt(&buf, Int32(10))

        case .metadataInstantValue:
            writeInt(&buf, Int32(11))

        case .metadataInstantArrayValue:
            writeInt(&buf, Int32(12))

        case .metadataNonFungibleGlobalIdValue:
            writeInt(&buf, Int32(13))

        case .metadataNonFungibleGlobalIdArrayValue:
            writeInt(&buf, Int32(14))

        case .metadataNonFungibleLocalIdValue:
            writeInt(&buf, Int32(15))

        case .metadataNonFungibleLocalIdArrayValue:
            writeInt(&buf, Int32(16))

        case .metadataOriginValue:
            writeInt(&buf, Int32(17))

        case .metadataOriginArrayValue:
            writeInt(&buf, Int32(18))

        case .metadataPublicKeyValue:
            writeInt(&buf, Int32(19))

        case .metadataPublicKeyArrayValue:
            writeInt(&buf, Int32(20))

        case .metadataPublicKeyHashValue:
            writeInt(&buf, Int32(21))

        case .metadataPublicKeyHashArrayValue:
            writeInt(&buf, Int32(22))

        case let .metadataStringValue(value):
            writeInt(&buf, Int32(23))
            FfiConverterString.write(value, into: &buf)

        case .metadataStringArrayValue:
            writeInt(&buf, Int32(24))

        case .metadataU32Value:
            writeInt(&buf, Int32(25))

        case .metadataU32ArrayValue:
            writeInt(&buf, Int32(26))

        case .metadataU64Value:
            writeInt(&buf, Int32(27))

        case .metadataU64ArrayValue:
            writeInt(&buf, Int32(28))

        case .metadataU8Value:
            writeInt(&buf, Int32(29))

        case .metadataU8ArrayValue:
            writeInt(&buf, Int32(30))

        case let .metadataUrlValue(value):
            writeInt(&buf, Int32(31))
            FfiConverterTypeUrl.write(value, into: &buf)

        case .metadataUrlArrayValue:
            writeInt(&buf, Int32(32))
        }
    }
}

public func FfiConverterTypeMetadataTypedValue_lift(_ buf: RustBuffer) throws -> MetadataTypedValue {
    return try FfiConverterTypeMetadataTypedValue.lift(buf)
}

public func FfiConverterTypeMetadataTypedValue_lower(_ value: MetadataTypedValue) -> RustBuffer {
    return FfiConverterTypeMetadataTypedValue.lower(value)
}

extension MetadataTypedValue: Sendable {}
extension MetadataTypedValue: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Million, Billion or Trillion, helper for Decimal192 formatting.
 */

public enum Multiplier: UInt8 {
    case million = 6
    case billion = 9
    case trillion = 12
}

public struct FfiConverterTypeMultiplier: FfiConverterRustBuffer {
    typealias SwiftType = Multiplier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Multiplier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .million

        case 2: return .billion

        case 3: return .trillion

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Multiplier, into buf: inout [UInt8]) {
        switch value {
        case .million:
            writeInt(&buf, Int32(1))

        case .billion:
            writeInt(&buf, Int32(2))

        case .trillion:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeMultiplier_lift(_ buf: RustBuffer) throws -> Multiplier {
    return try FfiConverterTypeMultiplier.lift(buf)
}

public func FfiConverterTypeMultiplier_lower(_ value: Multiplier) -> RustBuffer {
    return FfiConverterTypeMultiplier.lower(value)
}

extension Multiplier: Sendable {}
extension Multiplier: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NetworkId: UInt8 {
    /**
     * Mainnet (0x01 / 0d01)
     *
     * The Radix public network.
     *
     * https://github.com/radixdlt/radixdlt-scrypto/blob/v1.0.1/radix-engine-common/src/network/mod.rs#L79
     */
    case mainnet = 1
    /**
     * Stokenet (0x02 / 0d02)
     *
     * The public testnet for Radix.
     *
     * https://github.com/radixdlt/radixdlt-scrypto/blob/v1.0.1/radix-engine-common/src/network/mod.rs#L71
     */
    case stokenet = 2
    /**
     * Adapanet (0x0a / 0d10
     */
    case adapanet = 10
    /**
     * Nebunet (0x0b / 0d11 )
     *
     * The first Betanet of Babylon
     */
    case nebunet = 11
    /**
     * Kisharnet (0x0c / 0d12)
     *
     * The first release candidate of Babylon (RCnet v1)
     */
    case kisharnet = 12
    /**
     * Ansharnet (0x0d / 0d13)
     *
     * The second release candidate of Babylon (RCnet v2)
     */
    case ansharnet = 13
    /**
     * Zabanet (0x0e / 0d14)
     *
     * The third release candidate of Babylon (RCnet v3)
     */
    case zabanet = 14
    /**
     * Enkinet (0x21 / 0d33)
     *
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L94
     */
    case enkinet = 33
    /**
     * Hammunet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L95
     * Decimal value: 34
     */
    case hammunet = 34
    /**
     * Nergalnet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L96
     * Decimal value: 35
     */
    case nergalnet = 35
    /**
     * Mardunet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L97
     * Decimal value: 36
     */
    case mardunet = 36
    /**
     * Simulator (0xf2 / 0d242)
     */
    case simulator = 242
}

public struct FfiConverterTypeNetworkID: FfiConverterRustBuffer {
    typealias SwiftType = NetworkId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .mainnet

        case 2: return .stokenet

        case 3: return .adapanet

        case 4: return .nebunet

        case 5: return .kisharnet

        case 6: return .ansharnet

        case 7: return .zabanet

        case 8: return .enkinet

        case 9: return .hammunet

        case 10: return .nergalnet

        case 11: return .mardunet

        case 12: return .simulator

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NetworkId, into buf: inout [UInt8]) {
        switch value {
        case .mainnet:
            writeInt(&buf, Int32(1))

        case .stokenet:
            writeInt(&buf, Int32(2))

        case .adapanet:
            writeInt(&buf, Int32(3))

        case .nebunet:
            writeInt(&buf, Int32(4))

        case .kisharnet:
            writeInt(&buf, Int32(5))

        case .ansharnet:
            writeInt(&buf, Int32(6))

        case .zabanet:
            writeInt(&buf, Int32(7))

        case .enkinet:
            writeInt(&buf, Int32(8))

        case .hammunet:
            writeInt(&buf, Int32(9))

        case .nergalnet:
            writeInt(&buf, Int32(10))

        case .mardunet:
            writeInt(&buf, Int32(11))

        case .simulator:
            writeInt(&buf, Int32(12))
        }
    }
}

public func FfiConverterTypeNetworkID_lift(_ buf: RustBuffer) throws -> NetworkId {
    return try FfiConverterTypeNetworkID.lift(buf)
}

public func FfiConverterTypeNetworkID_lower(_ value: NetworkId) -> RustBuffer {
    return FfiConverterTypeNetworkID.lower(value)
}

extension NetworkId: Sendable {}
extension NetworkId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NetworkMethod {
    case post
    case get
    case head
}

public struct FfiConverterTypeNetworkMethod: FfiConverterRustBuffer {
    typealias SwiftType = NetworkMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .post

        case 2: return .get

        case 3: return .head

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NetworkMethod, into buf: inout [UInt8]) {
        switch value {
        case .post:
            writeInt(&buf, Int32(1))

        case .get:
            writeInt(&buf, Int32(2))

        case .head:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeNetworkMethod_lift(_ buf: RustBuffer) throws -> NetworkMethod {
    return try FfiConverterTypeNetworkMethod.lift(buf)
}

public func FfiConverterTypeNetworkMethod_lower(_ value: NetworkMethod) -> RustBuffer {
    return FfiConverterTypeNetworkMethod.lower(value)
}

extension NetworkMethod: Sendable {}
extension NetworkMethod: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NonFungibleLocalId {
    /**
     * Unsigned integers, up to u64.
     *
     * Create using `NonFungibleLocalId::integer(...)`.
     */
    case integer(value: UInt64
    )
    /**
     * String matching `[_0-9a-zA-Z]{1,64}`.
     *
     * Create using `NonFungibleLocalId::string(...).unwrap()`.
     */
    case str(value: NonFungibleLocalIdString
    )
    /**
     * Bytes, of length between 1 and 64.
     *
     * Create using `NonFungibleLocalId::bytes(...).unwrap()`.
     */
    case bytes(value: NonEmptyMax64Bytes
    )
    /**
     * RUID, v4, variant 1, big endian. See https://www.rfc-editor.org/rfc/rfc4122
     *
     * Create using `NonFungibleLocalId::ruid(...).unwrap()`.
     */
    case ruid(value: Exactly32Bytes
    )
}

public struct FfiConverterTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleLocalId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .integer(value: FfiConverterUInt64.read(from: &buf)
            )

        case 2: return try .str(value: FfiConverterTypeNonFungibleLocalIdString.read(from: &buf)
            )

        case 3: return try .bytes(value: FfiConverterTypeNonEmptyMax64Bytes.read(from: &buf)
            )

        case 4: return try .ruid(value: FfiConverterTypeExactly32Bytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleLocalId, into buf: inout [UInt8]) {
        switch value {
        case let .integer(value):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(value, into: &buf)

        case let .str(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNonFungibleLocalIdString.write(value, into: &buf)

        case let .bytes(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNonEmptyMax64Bytes.write(value, into: &buf)

        case let .ruid(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeExactly32Bytes.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeNonFungibleLocalId_lift(_ buf: RustBuffer) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalId_lower(_ value: NonFungibleLocalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalId.lower(value)
}

extension NonFungibleLocalId: Sendable {}
extension NonFungibleLocalId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NonFungibleResourceIndicator {
    case byAll(predictedAmount: PredictedDecimal, predictedIds: PredictedNonFungibleLocalIds)
    case byAmount(amount: Decimal192, predictedIds: PredictedNonFungibleLocalIds)
    case byIds(ids: [NonFungibleLocalId]
    )
}

public struct FfiConverterTypeNonFungibleResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .byAll(predictedAmount: FfiConverterTypePredictedDecimal.read(from: &buf), predictedIds: FfiConverterTypePredictedNonFungibleLocalIds.read(from: &buf))

        case 2: return try .byAmount(amount: FfiConverterTypeDecimal192.read(from: &buf), predictedIds: FfiConverterTypePredictedNonFungibleLocalIds.read(from: &buf))

        case 3: return try .byIds(ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        case let .byAll(predictedAmount, predictedIds):
            writeInt(&buf, Int32(1))
            FfiConverterTypePredictedDecimal.write(predictedAmount, into: &buf)
            FfiConverterTypePredictedNonFungibleLocalIds.write(predictedIds, into: &buf)

        case let .byAmount(amount, predictedIds):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDecimal192.write(amount, into: &buf)
            FfiConverterTypePredictedNonFungibleLocalIds.write(predictedIds, into: &buf)

        case let .byIds(ids):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
        }
    }
}

public func FfiConverterTypeNonFungibleResourceIndicator_lift(_ buf: RustBuffer) throws -> NonFungibleResourceIndicator {
    return try FfiConverterTypeNonFungibleResourceIndicator.lift(buf)
}

public func FfiConverterTypeNonFungibleResourceIndicator_lower(_ value: NonFungibleResourceIndicator) -> RustBuffer {
    return FfiConverterTypeNonFungibleResourceIndicator.lower(value)
}

extension NonFungibleResourceIndicator: Sendable {}
extension NonFungibleResourceIndicator: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PersonaDataNameVariant {
    case western
    case eastern
}

public struct FfiConverterTypePersonaDataNameVariant: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataNameVariant

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataNameVariant {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .western

        case 2: return .eastern

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PersonaDataNameVariant, into buf: inout [UInt8]) {
        switch value {
        case .western:
            writeInt(&buf, Int32(1))

        case .eastern:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypePersonaDataNameVariant_lift(_ buf: RustBuffer) throws -> PersonaDataNameVariant {
    return try FfiConverterTypePersonaDataNameVariant.lift(buf)
}

public func FfiConverterTypePersonaDataNameVariant_lower(_ value: PersonaDataNameVariant) -> RustBuffer {
    return FfiConverterTypePersonaDataNameVariant.lower(value)
}

extension PersonaDataNameVariant: Sendable {}
extension PersonaDataNameVariant: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The kind of the Pool, either One, Two or Multi resources.
 */

public enum PoolKind {
    /**
     * A Pool to which user can contribute liquidity of a single
     * resource kind.
     */
    case oneResource
    /**
     * A Pool to which user can contribute liquidity of two different
     * resources
     */
    case twoResources
    /**
     * A Pool to which user can contribute liquidity of many different
     * resources
     */
    case multiResources
}

public struct FfiConverterTypePoolKind: FfiConverterRustBuffer {
    typealias SwiftType = PoolKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PoolKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .oneResource

        case 2: return .twoResources

        case 3: return .multiResources

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PoolKind, into buf: inout [UInt8]) {
        switch value {
        case .oneResource:
            writeInt(&buf, Int32(1))

        case .twoResources:
            writeInt(&buf, Int32(2))

        case .multiResources:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypePoolKind_lift(_ buf: RustBuffer) throws -> PoolKind {
    return try FfiConverterTypePoolKind.lift(buf)
}

public func FfiConverterTypePoolKind_lower(_ value: PoolKind) -> RustBuffer {
    return FfiConverterTypePoolKind.lower(value)
}

extension PoolKind: Sendable {}
extension PoolKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of analyzing a file (bytes), containing either a Profile
 * which we were able to successfully JSON deserialize from the bytes,
 * or EncryptedProfile for which wallets will continue prompting the
 * user for an encryption password and then call JSON deserialize
 * of `EncryptedProfileSnapshot` using [`Profile::new_from_encryption_bytes`](Profile::new_from_encryption_bytes)
 * or if we failed to parse as Profile and `EncryptedProfileSnapshot`
 * then `NotProfile` is used, indicating that the bytes is not at all
 * a Profile.
 */

public enum ProfileFileContents {
    /**
     * The JSON deserialized Profile from some bytes.
     */
    case plaintextProfile(Profile
    )
    /**
     * We successfully JSON deserialized the bytes into
     * `EncryptedProfileSnapshot`, the wallets should proceed
     * with asking the user for the decryption password.
     */
    case encryptedProfile
    /**
     * The bytes is neither a valid `Profile` nor `EncryptedProfile`,
     * it is either a corrupt file or it is not at all a Profile file,
     * contrary to the users beliefs (or the user accidentally selected
     * a random file...)
     */
    case notProfile
}

public struct FfiConverterTypeProfileFileContents: FfiConverterRustBuffer {
    typealias SwiftType = ProfileFileContents

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileFileContents {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .plaintextProfile(FfiConverterTypeProfile.read(from: &buf)
            )

        case 2: return .encryptedProfile

        case 3: return .notProfile

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileFileContents, into buf: inout [UInt8]) {
        switch value {
        case let .plaintextProfile(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeProfile.write(v1, into: &buf)

        case .encryptedProfile:
            writeInt(&buf, Int32(2))

        case .notProfile:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeProfileFileContents_lift(_ buf: RustBuffer) throws -> ProfileFileContents {
    return try FfiConverterTypeProfileFileContents.lift(buf)
}

public func FfiConverterTypeProfileFileContents_lower(_ value: ProfileFileContents) -> RustBuffer {
    return FfiConverterTypeProfileFileContents.lower(value)
}

extension ProfileFileContents: Sendable {}
extension ProfileFileContents: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The version of the Profile Snapshot data format (JSON).
 */

public enum ProfileSnapshotVersion: UInt16 {
    /**
     * The version we went live with on Babylon mainnet 2023-09-28,
     * shipped with iOS 1.0.0 (7) and Android v 1.0.0.
     */
    case v100 = 100
}

public struct FfiConverterTypeProfileSnapshotVersion: FfiConverterRustBuffer {
    typealias SwiftType = ProfileSnapshotVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileSnapshotVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .v100

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileSnapshotVersion, into buf: inout [UInt8]) {
        switch value {
        case .v100:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeProfileSnapshotVersion_lift(_ buf: RustBuffer) throws -> ProfileSnapshotVersion {
    return try FfiConverterTypeProfileSnapshotVersion.lift(buf)
}

public func FfiConverterTypeProfileSnapshotVersion_lower(_ value: ProfileSnapshotVersion) -> RustBuffer {
    return FfiConverterTypeProfileSnapshotVersion.lower(value)
}

extension ProfileSnapshotVersion: Sendable {}
extension ProfileSnapshotVersion: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ProfileState {
    /**
     * When no profile exists in secure storage when OS is booted.
     */
    case none
    /**
     * When the profile snapshot retrieved from secure storage failed to convert into a
     * valid Profile.
     */
    case incompatible(CommonError
    )
    /**
     * When a valid 'Profile' exists. This can either happen when the os boots, or a profile is
     * restored, or the user creates a new profile.
     */
    case loaded(Profile
    )
}

public struct FfiConverterTypeProfileState: FfiConverterRustBuffer {
    typealias SwiftType = ProfileState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .none

        case 2: return try .incompatible(FfiConverterTypeCommonError.read(from: &buf)
            )

        case 3: return try .loaded(FfiConverterTypeProfile.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileState, into buf: inout [UInt8]) {
        switch value {
        case .none:
            writeInt(&buf, Int32(1))

        case let .incompatible(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeCommonError.write(v1, into: &buf)

        case let .loaded(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeProfile.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeProfileState_lift(_ buf: RustBuffer) throws -> ProfileState {
    return try FfiConverterTypeProfileState.lift(buf)
}

public func FfiConverterTypeProfileState_lower(_ value: ProfileState) -> RustBuffer {
    return FfiConverterTypeProfileState.lower(value)
}

extension ProfileState: Sendable {}
extension ProfileState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of supported public keys on different curves, supported
 * curves are `secp256k1` and `Curve25519`
 */

public enum PublicKey {
    /**
     * An Ed25519 public key used to verify cryptographic signatures.
     */
    case ed25519(Ed25519PublicKey
    )
    /**
     * A secp256k1 public key used to verify cryptographic signatures (ECDSA signatures).
     */
    case secp256k1(Secp256k1PublicKey
    )
}

public struct FfiConverterTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .ed25519(FfiConverterTypeEd25519PublicKey.read(from: &buf)
            )

        case 2: return try .secp256k1(FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        switch value {
        case let .ed25519(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEd25519PublicKey.write(v1, into: &buf)

        case let .secp256k1(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecp256k1PublicKey.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypePublicKey_lift(_ buf: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(buf)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}

extension PublicKey: Sendable {}
extension PublicKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Hashes of public keys, either Ed25519PublicKey or Secp256k1PublicKey
 */

public enum PublicKeyHash {
    case ed25519(value: Exactly29Bytes
    )
    case secp256k1(value: Exactly29Bytes
    )
}

public struct FfiConverterTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = PublicKeyHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKeyHash {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .ed25519(value: FfiConverterTypeExactly29Bytes.read(from: &buf)
            )

        case 2: return try .secp256k1(value: FfiConverterTypeExactly29Bytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKeyHash, into buf: inout [UInt8]) {
        switch value {
        case let .ed25519(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeExactly29Bytes.write(value, into: &buf)

        case let .secp256k1(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeExactly29Bytes.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypePublicKeyHash_lift(_ buf: RustBuffer) throws -> PublicKeyHash {
    return try FfiConverterTypePublicKeyHash.lift(buf)
}

public func FfiConverterTypePublicKeyHash_lower(_ value: PublicKeyHash) -> RustBuffer {
    return FfiConverterTypePublicKeyHash.lower(value)
}

extension PublicKeyHash: Sendable {}
extension PublicKeyHash: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
 * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
 * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
 */

public enum RadixConnectPurpose {
    case general
    case unknown
}

public struct FfiConverterTypeRadixConnectPurpose: FfiConverterRustBuffer {
    typealias SwiftType = RadixConnectPurpose

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectPurpose {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .general

        case 2: return .unknown

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RadixConnectPurpose, into buf: inout [UInt8]) {
        switch value {
        case .general:
            writeInt(&buf, Int32(1))

        case .unknown:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeRadixConnectPurpose_lift(_ buf: RustBuffer) throws -> RadixConnectPurpose {
    return try FfiConverterTypeRadixConnectPurpose.lift(buf)
}

public func FfiConverterTypeRadixConnectPurpose_lower(_ value: RadixConnectPurpose) -> RustBuffer {
    return FfiConverterTypeRadixConnectPurpose.lower(value)
}

extension RadixConnectPurpose: Sendable {}
extension RadixConnectPurpose: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A quantifier of a quantity, either `atLeast` or `exactly`, as in
 * "I want AT LEAST 3" or "I want EXACTLY 10".
 *
 * This is typically sent by a Dapp when requesting access to accounts
 * or PersonaData.
 */

public enum RequestedNumberQuantifier {
    /**
     * (Request access to) *exactly* N many of something, where quantity `N` is
     * not part of this enum, e.g. "I want EXACTLY 2 accounts"
     */
    case exactly
    /**
     * (Request access to) *at least* N many of something, where quantity `N` is
     * not part of this enum, e.g. "I want AT LEAST 3 accounts"
     */
    case atLeast
}

public struct FfiConverterTypeRequestedNumberQuantifier: FfiConverterRustBuffer {
    typealias SwiftType = RequestedNumberQuantifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedNumberQuantifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .exactly

        case 2: return .atLeast

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestedNumberQuantifier, into buf: inout [UInt8]) {
        switch value {
        case .exactly:
            writeInt(&buf, Int32(1))

        case .atLeast:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeRequestedNumberQuantifier_lift(_ buf: RustBuffer) throws -> RequestedNumberQuantifier {
    return try FfiConverterTypeRequestedNumberQuantifier.lift(buf)
}

public func FfiConverterTypeRequestedNumberQuantifier_lower(_ value: RequestedNumberQuantifier) -> RustBuffer {
    return FfiConverterTypeRequestedNumberQuantifier.lower(value)
}

extension RequestedNumberQuantifier: Sendable {}
extension RequestedNumberQuantifier: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The set of instructions that is only allowed in manifests created by the
 * wallet itself.
 */

public enum ReservedInstruction {
    case accountLockFee
    case accountSecurify
    case identitySecurify
    case accessControllerMethod
    case accountUpdateSettings
}

public struct FfiConverterTypeReservedInstruction: FfiConverterRustBuffer {
    typealias SwiftType = ReservedInstruction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReservedInstruction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .accountLockFee

        case 2: return .accountSecurify

        case 3: return .identitySecurify

        case 4: return .accessControllerMethod

        case 5: return .accountUpdateSettings

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReservedInstruction, into buf: inout [UInt8]) {
        switch value {
        case .accountLockFee:
            writeInt(&buf, Int32(1))

        case .accountSecurify:
            writeInt(&buf, Int32(2))

        case .identitySecurify:
            writeInt(&buf, Int32(3))

        case .accessControllerMethod:
            writeInt(&buf, Int32(4))

        case .accountUpdateSettings:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeReservedInstruction_lift(_ buf: RustBuffer) throws -> ReservedInstruction {
    return try FfiConverterTypeReservedInstruction.lift(buf)
}

public func FfiConverterTypeReservedInstruction_lower(_ value: ReservedInstruction) -> RustBuffer {
    return FfiConverterTypeReservedInstruction.lower(value)
}

extension ReservedInstruction: Sendable {}
extension ReservedInstruction: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum representation of an resource for which the user can set up its preferences.
 */

public enum ResourceIdentifier {
    case fungible(ResourceAddress
    )
    case nonFungible(ResourceAddress
    )
    case poolUnit(PoolAddress
    )
}

public struct FfiConverterTypeResourceIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = ResourceIdentifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceIdentifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .fungible(FfiConverterTypeResourceAddress.read(from: &buf)
            )

        case 2: return try .nonFungible(FfiConverterTypeResourceAddress.read(from: &buf)
            )

        case 3: return try .poolUnit(FfiConverterTypePoolAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceIdentifier, into buf: inout [UInt8]) {
        switch value {
        case let .fungible(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(v1, into: &buf)

        case let .nonFungible(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(v1, into: &buf)

        case let .poolUnit(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypePoolAddress.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeResourceIdentifier_lift(_ buf: RustBuffer) throws -> ResourceIdentifier {
    return try FfiConverterTypeResourceIdentifier.lift(buf)
}

public func FfiConverterTypeResourceIdentifier_lower(_ value: ResourceIdentifier) -> RustBuffer {
    return FfiConverterTypeResourceIdentifier.lower(value)
}

extension ResourceIdentifier: Sendable {}
extension ResourceIdentifier: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourceIndicator {
    case fungible(resourceAddress: ResourceAddress, indicator: FungibleResourceIndicator)
    case nonFungible(resourceAddress: ResourceAddress, indicator: NonFungibleResourceIndicator)
}

public struct FfiConverterTypeResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = ResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .fungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), indicator: FfiConverterTypeFungibleResourceIndicator.read(from: &buf))

        case 2: return try .nonFungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), indicator: FfiConverterTypeNonFungibleResourceIndicator.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        case let .fungible(resourceAddress, indicator):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeFungibleResourceIndicator.write(indicator, into: &buf)

        case let .nonFungible(resourceAddress, indicator):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeNonFungibleResourceIndicator.write(indicator, into: &buf)
        }
    }
}

public func FfiConverterTypeResourceIndicator_lift(_ buf: RustBuffer) throws -> ResourceIndicator {
    return try FfiConverterTypeResourceIndicator.lift(buf)
}

public func FfiConverterTypeResourceIndicator_lower(_ value: ResourceIndicator) -> RustBuffer {
    return FfiConverterTypeResourceIndicator.lower(value)
}

extension ResourceIndicator: Sendable {}
extension ResourceIndicator: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The addresses that can be added as exception to the `DepositRule`
 */

public enum ResourceOrNonFungible {
    case resource(value: ResourceAddress
    )
    case nonFungible(value: NonFungibleGlobalId
    )
}

public struct FfiConverterTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = ResourceOrNonFungible

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceOrNonFungible {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .resource(value: FfiConverterTypeResourceAddress.read(from: &buf)
            )

        case 2: return try .nonFungible(value: FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceOrNonFungible, into buf: inout [UInt8]) {
        switch value {
        case let .resource(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(value, into: &buf)

        case let .nonFungible(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNonFungibleGlobalId.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeResourceOrNonFungible_lift(_ buf: RustBuffer) throws -> ResourceOrNonFungible {
    return try FfiConverterTypeResourceOrNonFungible.lift(buf)
}

public func FfiConverterTypeResourceOrNonFungible_lower(_ value: ResourceOrNonFungible) -> RustBuffer {
    return FfiConverterTypeResourceOrNonFungible.lower(value)
}

extension ResourceOrNonFungible: Sendable {}
extension ResourceOrNonFungible: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourcePreference {
    case allowed
    case disallowed
}

public struct FfiConverterTypeResourcePreference: FfiConverterRustBuffer {
    typealias SwiftType = ResourcePreference

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreference {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .allowed

        case 2: return .disallowed

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourcePreference, into buf: inout [UInt8]) {
        switch value {
        case .allowed:
            writeInt(&buf, Int32(1))

        case .disallowed:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeResourcePreference_lift(_ buf: RustBuffer) throws -> ResourcePreference {
    return try FfiConverterTypeResourcePreference.lift(buf)
}

public func FfiConverterTypeResourcePreference_lower(_ value: ResourcePreference) -> RustBuffer {
    return FfiConverterTypeResourcePreference.lower(value)
}

extension ResourcePreference: Sendable {}
extension ResourcePreference: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourcePreferenceUpdate {
    case set(value: ResourcePreference
    )
    case remove
}

public struct FfiConverterTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    typealias SwiftType = ResourcePreferenceUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreferenceUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .set(value: FfiConverterTypeResourcePreference.read(from: &buf)
            )

        case 2: return .remove

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourcePreferenceUpdate, into buf: inout [UInt8]) {
        switch value {
        case let .set(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourcePreference.write(value, into: &buf)

        case .remove:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeResourcePreferenceUpdate_lift(_ buf: RustBuffer) throws -> ResourcePreferenceUpdate {
    return try FfiConverterTypeResourcePreferenceUpdate.lift(buf)
}

public func FfiConverterTypeResourcePreferenceUpdate_lower(_ value: ResourcePreferenceUpdate) -> RustBuffer {
    return FfiConverterTypeResourcePreferenceUpdate.lower(value)
}

extension ResourcePreferenceUpdate: Sendable {}
extension ResourcePreferenceUpdate: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourceSpecifier {
    case fungible(resourceAddress: ResourceAddress, amount: Decimal192)
    case nonFungible(resourceAddress: ResourceAddress, ids: [NonFungibleLocalId])
}

public struct FfiConverterTypeResourceSpecifier: FfiConverterRustBuffer {
    typealias SwiftType = ResourceSpecifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceSpecifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .fungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), amount: FfiConverterTypeDecimal192.read(from: &buf))

        case 2: return try .nonFungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceSpecifier, into buf: inout [UInt8]) {
        switch value {
        case let .fungible(resourceAddress, amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal192.write(amount, into: &buf)

        case let .nonFungible(resourceAddress, ids):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
        }
    }
}

public func FfiConverterTypeResourceSpecifier_lift(_ buf: RustBuffer) throws -> ResourceSpecifier {
    return try FfiConverterTypeResourceSpecifier.lift(buf)
}

public func FfiConverterTypeResourceSpecifier_lower(_ value: ResourceSpecifier) -> RustBuffer {
    return FfiConverterTypeResourceSpecifier.lower(value)
}

extension ResourceSpecifier: Sendable {}
extension ResourceSpecifier: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Indicates the visibility of a resource.
 */

public enum ResourceVisibility {
    case hidden
    case visible
}

public struct FfiConverterTypeResourceVisibility: FfiConverterRustBuffer {
    typealias SwiftType = ResourceVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .hidden

        case 2: return .visible

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceVisibility, into buf: inout [UInt8]) {
        switch value {
        case .hidden:
            writeInt(&buf, Int32(1))

        case .visible:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeResourceVisibility_lift(_ buf: RustBuffer) throws -> ResourceVisibility {
    return try FfiConverterTypeResourceVisibility.lift(buf)
}

public func FfiConverterTypeResourceVisibility_lower(_ value: ResourceVisibility) -> RustBuffer {
    return FfiConverterTypeResourceVisibility.lower(value)
}

extension ResourceVisibility: Sendable {}
extension ResourceVisibility: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Defines the rounding strategy used when you round e.g. `Decimal192`.
 *
 * Following the same naming convention as https://docs.rs/rust_decimal/latest/rust_decimal/enum.RoundingStrategy.html.
 */

public enum RoundingMode {
    /**
     * The number is always rounded toward positive infinity, e.g. `3.1 -> 4`, `-3.1 -> -3`.
     */
    case toPositiveInfinity
    /**
     * The number is always rounded toward negative infinity, e.g. `3.1 -> 3`, `-3.1 -> -4`.
     */
    case toNegativeInfinity
    /**
     * The number is always rounded toward zero, e.g. `3.1 -> 3`, `-3.1 -> -3`.
     */
    case toZero
    /**
     * The number is always rounded away from zero, e.g. `3.1 -> 4`, `-3.1 -> -4`.
     */
    case awayFromZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded toward zero, e.g. `3.5 -> 3`, `-3.5 -> -3`.
     */
    case toNearestMidpointTowardZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded away from zero, e.g. `3.5 -> 4`, `-3.5 -> -4`.
     */
    case toNearestMidpointAwayFromZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded toward the nearest even number. Also known as "Bankers Rounding".
     */
    case toNearestMidpointToEven
}

public struct FfiConverterTypeRoundingMode: FfiConverterRustBuffer {
    typealias SwiftType = RoundingMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoundingMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .toPositiveInfinity

        case 2: return .toNegativeInfinity

        case 3: return .toZero

        case 4: return .awayFromZero

        case 5: return .toNearestMidpointTowardZero

        case 6: return .toNearestMidpointAwayFromZero

        case 7: return .toNearestMidpointToEven

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoundingMode, into buf: inout [UInt8]) {
        switch value {
        case .toPositiveInfinity:
            writeInt(&buf, Int32(1))

        case .toNegativeInfinity:
            writeInt(&buf, Int32(2))

        case .toZero:
            writeInt(&buf, Int32(3))

        case .awayFromZero:
            writeInt(&buf, Int32(4))

        case .toNearestMidpointTowardZero:
            writeInt(&buf, Int32(5))

        case .toNearestMidpointAwayFromZero:
            writeInt(&buf, Int32(6))

        case .toNearestMidpointToEven:
            writeInt(&buf, Int32(7))
        }
    }
}

public func FfiConverterTypeRoundingMode_lift(_ buf: RustBuffer) throws -> RoundingMode {
    return try FfiConverterTypeRoundingMode.lift(buf)
}

public func FfiConverterTypeRoundingMode_lower(_ value: RoundingMode) -> RustBuffer {
    return FfiConverterTypeRoundingMode.lower(value)
}

extension RoundingMode: Sendable {}
extension RoundingMode: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Elliptic Curves which the SLIP10 derivation algorithm supports.
 *
 * We use SLIP10 for hierarchical deterministic derivation since we
 * prefer using Curve25519 - which is incompatible with BIP32 (BIP44).
 *
 * For for information see [SLIP10 reference](https://github.com/satoshilabs/slips/blob/master/slip-0010.md)
 */

public enum Slip10Curve {
    /**
     * Curve25519 which we use for Ed25519 for EdDSA signatures.
     */
    case curve25519
    /**
     * The bitcoin curve, used by Radix Olympia and still valid
     * to support legacy accounts.
     */
    case secp256k1
}

public struct FfiConverterTypeSLIP10Curve: FfiConverterRustBuffer {
    typealias SwiftType = Slip10Curve

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Slip10Curve {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .curve25519

        case 2: return .secp256k1

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Slip10Curve, into buf: inout [UInt8]) {
        switch value {
        case .curve25519:
            writeInt(&buf, Int32(1))

        case .secp256k1:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeSLIP10Curve_lift(_ buf: RustBuffer) throws -> Slip10Curve {
    return try FfiConverterTypeSLIP10Curve.lift(buf)
}

public func FfiConverterTypeSLIP10Curve_lower(_ value: Slip10Curve) -> RustBuffer {
    return FfiConverterTypeSLIP10Curve.lower(value)
}

extension Slip10Curve: Sendable {}
extension Slip10Curve: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SecureStorageKey {
    case hostId
    case deviceFactorSourceMnemonic(factorSourceId: FactorSourceIdFromHash
    )
    case profileSnapshot
}

public struct FfiConverterTypeSecureStorageKey: FfiConverterRustBuffer {
    typealias SwiftType = SecureStorageKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .hostId

        case 2: return try .deviceFactorSourceMnemonic(factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )

        case 3: return .profileSnapshot

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecureStorageKey, into buf: inout [UInt8]) {
        switch value {
        case .hostId:
            writeInt(&buf, Int32(1))

        case let .deviceFactorSourceMnemonic(factorSourceId):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFactorSourceIDFromHash.write(factorSourceId, into: &buf)

        case .profileSnapshot:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeSecureStorageKey_lift(_ buf: RustBuffer) throws -> SecureStorageKey {
    return try FfiConverterTypeSecureStorageKey.lift(buf)
}

public func FfiConverterTypeSecureStorageKey_lower(_ value: SecureStorageKey) -> RustBuffer {
    return FfiConverterTypeSecureStorageKey.lower(value)
}

extension SecureStorageKey: Sendable {}
extension SecureStorageKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SecurityQuestionKind {
    case freeform
}

public struct FfiConverterTypeSecurityQuestionKind: FfiConverterRustBuffer {
    typealias SwiftType = SecurityQuestionKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .freeform

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecurityQuestionKind, into buf: inout [UInt8]) {
        switch value {
        case .freeform:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeSecurityQuestionKind_lift(_ buf: RustBuffer) throws -> SecurityQuestionKind {
    return try FfiConverterTypeSecurityQuestionKind.lift(buf)
}

public func FfiConverterTypeSecurityQuestionKind_lower(_ value: SecurityQuestionKind) -> RustBuffer {
    return FfiConverterTypeSecurityQuestionKind.lower(value)
}

extension SecurityQuestionKind: Sendable {}
extension SecurityQuestionKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 *  NOT PRODUCTION READY YET 
 * The KDF algorithm used to derive the decryption key from a combination of answers to security questions.
 *
 * N.B. Not to be confused with the much simpler password based Key Derivation used
 * to encrypt Profile part of manual file export.
 *  NOT PRODUCTION READY YET 
 */

public enum SecurityQuestionsNotProductionReadyKdfScheme {
    /**
     *  NOT PRODUCTION READY YET 
     * First iteration of KDF for SecurityQuestions
     *  NOT PRODUCTION READY YET 
     */
    case version1(SecurityQuestionsNotProductionReadyKdfSchemeVersion1
    )
}

public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme: FfiConverterRustBuffer {
    typealias SwiftType = SecurityQuestionsNotProductionReadyKdfScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyKdfScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .version1(FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecurityQuestionsNotProductionReadyKdfScheme, into buf: inout [UInt8]) {
        switch value {
        case let .version1(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyKdfScheme {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme_lower(_ value: SecurityQuestionsNotProductionReadyKdfScheme) -> RustBuffer {
    return FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme.lower(value)
}

extension SecurityQuestionsNotProductionReadyKdfScheme: Sendable {}
extension SecurityQuestionsNotProductionReadyKdfScheme: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either a Signature on `Curve25519` or `Secp256k1`
 */

public enum Signature {
    case secp256k1(value: Secp256k1Signature
    )
    case ed25519(value: Ed25519Signature
    )
}

public struct FfiConverterTypeSignature: FfiConverterRustBuffer {
    typealias SwiftType = Signature

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Signature {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(value: FfiConverterTypeSecp256k1Signature.read(from: &buf)
            )

        case 2: return try .ed25519(value: FfiConverterTypeEd25519Signature.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Signature, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecp256k1Signature.write(value, into: &buf)

        case let .ed25519(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEd25519Signature.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeSignature_lift(_ buf: RustBuffer) throws -> Signature {
    return try FfiConverterTypeSignature.lift(buf)
}

public func FfiConverterTypeSignature_lower(_ value: Signature) -> RustBuffer {
    return FfiConverterTypeSignature.lower(value)
}

extension Signature: Sendable {}
extension Signature: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents any natively supported signature, including public key.
 */

public enum SignatureWithPublicKey {
    case secp256k1(publicKey: Secp256k1PublicKey, signature: Secp256k1Signature)
    case ed25519(publicKey: Ed25519PublicKey, signature: Ed25519Signature)
}

public struct FfiConverterTypeSignatureWithPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = SignatureWithPublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureWithPublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(publicKey: FfiConverterTypeSecp256k1PublicKey.read(from: &buf), signature: FfiConverterTypeSecp256k1Signature.read(from: &buf))

        case 2: return try .ed25519(publicKey: FfiConverterTypeEd25519PublicKey.read(from: &buf), signature: FfiConverterTypeEd25519Signature.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureWithPublicKey, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(publicKey, signature):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecp256k1PublicKey.write(publicKey, into: &buf)
            FfiConverterTypeSecp256k1Signature.write(signature, into: &buf)

        case let .ed25519(publicKey, signature):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEd25519PublicKey.write(publicKey, into: &buf)
            FfiConverterTypeEd25519Signature.write(signature, into: &buf)
        }
    }
}

public func FfiConverterTypeSignatureWithPublicKey_lift(_ buf: RustBuffer) throws -> SignatureWithPublicKey {
    return try FfiConverterTypeSignatureWithPublicKey.lift(buf)
}

public func FfiConverterTypeSignatureWithPublicKey_lower(_ value: SignatureWithPublicKey) -> RustBuffer {
    return FfiConverterTypeSignatureWithPublicKey.lower(value)
}

extension SignatureWithPublicKey: Sendable {}
extension SignatureWithPublicKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UnsafeStorageKey {
    case factorSourceUserHasWrittenDown
}

public struct FfiConverterTypeUnsafeStorageKey: FfiConverterRustBuffer {
    typealias SwiftType = UnsafeStorageKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsafeStorageKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .factorSourceUserHasWrittenDown

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UnsafeStorageKey, into buf: inout [UInt8]) {
        switch value {
        case .factorSourceUserHasWrittenDown:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeUnsafeStorageKey_lift(_ buf: RustBuffer) throws -> UnsafeStorageKey {
    return try FfiConverterTypeUnsafeStorageKey.lift(buf)
}

public func FfiConverterTypeUnsafeStorageKey_lower(_ value: UnsafeStorageKey) -> RustBuffer {
    return FfiConverterTypeUnsafeStorageKey.lower(value)
}

extension UnsafeStorageKey: Sendable {}
extension UnsafeStorageKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionAuthRequestResponseItem {
    case usePersona(WalletToDappInteractionAuthUsePersonaRequestResponseItem
    )
    case loginWithoutChallenge(WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem
    )
    case loginWithChallenge(WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem
    )
}

public struct FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionAuthRequestResponseItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthRequestResponseItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .usePersona(FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.read(from: &buf)
            )

        case 2: return try .loginWithoutChallenge(FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.read(from: &buf)
            )

        case 3: return try .loginWithChallenge(FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionAuthRequestResponseItem, into buf: inout [UInt8]) {
        switch value {
        case let .usePersona(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.write(v1, into: &buf)

        case let .loginWithoutChallenge(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.write(v1, into: &buf)

        case let .loginWithChallenge(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem_lower(_ value: WalletToDappInteractionAuthRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.lower(value)
}

extension WalletToDappInteractionAuthRequestResponseItem: Sendable {}
extension WalletToDappInteractionAuthRequestResponseItem: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionResponse {
    case success(WalletToDappInteractionSuccessResponse
    )
    case failure(WalletToDappInteractionFailureResponse
    )
}

public struct FfiConverterTypeWalletToDappInteractionResponse: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionResponse

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionResponse {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .success(FfiConverterTypeWalletToDappInteractionSuccessResponse.read(from: &buf)
            )

        case 2: return try .failure(FfiConverterTypeWalletToDappInteractionFailureResponse.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionResponse, into buf: inout [UInt8]) {
        switch value {
        case let .success(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionSuccessResponse.write(v1, into: &buf)

        case let .failure(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionFailureResponse.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletToDappInteractionResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionResponse {
    return try FfiConverterTypeWalletToDappInteractionResponse.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionResponse_lower(_ value: WalletToDappInteractionResponse) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionResponse.lower(value)
}

extension WalletToDappInteractionResponse: Sendable {}
extension WalletToDappInteractionResponse: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionResponseItems {
    case authorizedRequest(WalletToDappInteractionAuthorizedRequestResponseItems
    )
    case unauthorizedRequest(WalletToDappInteractionUnauthorizedRequestResponseItems
    )
    case transaction(WalletToDappInteractionTransactionResponseItems
    )
}

public struct FfiConverterTypeWalletToDappInteractionResponseItems: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionResponseItems

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionResponseItems {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .authorizedRequest(FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.read(from: &buf)
            )

        case 2: return try .unauthorizedRequest(FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.read(from: &buf)
            )

        case 3: return try .transaction(FfiConverterTypeWalletToDappInteractionTransactionResponseItems.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionResponseItems, into buf: inout [UInt8]) {
        switch value {
        case let .authorizedRequest(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.write(v1, into: &buf)

        case let .unauthorizedRequest(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.write(v1, into: &buf)

        case let .transaction(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletToDappInteractionTransactionResponseItems.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletToDappInteractionResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionResponseItems {
    return try FfiConverterTypeWalletToDappInteractionResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionResponseItems_lower(_ value: WalletToDappInteractionResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionResponseItems.lower(value)
}

extension WalletToDappInteractionResponseItems: Sendable {}
extension WalletToDappInteractionResponseItems: Equatable, Hashable {}

private struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionAccountsRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionAccountsRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionPersonaDataRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDappToWalletInteractionResetRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionResetRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionResetRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionResetRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDecimal192: FfiConverterRustBuffer {
    typealias SwiftType = Decimal192?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDecimal192.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDecimal192.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDisplayName: FfiConverterRustBuffer {
    typealias SwiftType = DisplayName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDisplayName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDisplayName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeFungibleResourcesCollection: FfiConverterRustBuffer {
    typealias SwiftType = FungibleResourcesCollection?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFungibleResourcesCollection.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFungibleResourcesCollection.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
    typealias SwiftType = HierarchicalDeterministicFactorInstance?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePersonaDataEntryName: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataEntryName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataEntryName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataEntryName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePersonaDataIdentifiedName: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataIdentifiedName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataIdentifiedName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataIdentifiedName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeRequestedQuantity: FfiConverterRustBuffer {
    typealias SwiftType = RequestedQuantity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRequestedQuantity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRequestedQuantity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses: FfiConverterRustBuffer {
    typealias SwiftType = SharedToDappWithPersonaAccountAddresses?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSharedToDappWithPersonaAccountAddresses.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSharedToDappWithPersonaAccountAddresses.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries: FfiConverterRustBuffer {
    typealias SwiftType = SharedToDappWithPersonaIDsOfPersonaDataEntries?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionAccountsRequestResponseItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionPersonaDataRequestResponseItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeAccountForDisplay: FfiConverterRustBuffer {
    typealias SwiftType = [AccountForDisplay]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAccountForDisplay.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAccountForDisplay.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeAssetException: FfiConverterRustBuffer {
    typealias SwiftType = [AssetException]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAssetException.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAssetException.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [EmailAddress]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeEmailAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeEmailAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryPhoneNumber]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePersonaDataEntryPhoneNumber.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePersonaDataEntryPhoneNumber.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
    typealias SwiftType = [WalletToDappInteractionAccountProof]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeWalletToDappInteractionAccountProof.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeWalletToDappInteractionAccountProof.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceOrNonFungible]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeResourceOrNonFungible.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeBagOfBytes: FfiConverterRustBuffer {
    typealias SwiftType = BagOfBytes?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBagOfBytes.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionAuthChallengeNonce?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePersonaDataEntryID: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataEntryId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataEntryID.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataEntryID.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeUrl: FfiConverterRustBuffer {
    typealias SwiftType = Url?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUrl.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUrl.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceInt8: FfiConverterRustBuffer {
    typealias SwiftType = [Int8]

    public static func write(_ value: [Int8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int8] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccount: FfiConverterRustBuffer {
    typealias SwiftType = [Account]

    public static func write(_ value: [Account], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Account] {
        let len: Int32 = try readInt(&buf)
        var seq = [Account]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccount.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountAddress: FfiConverterRustBuffer {
    typealias SwiftType = [AccountAddress]

    public static func write(_ value: [AccountAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountForDisplay: FfiConverterRustBuffer {
    typealias SwiftType = [AccountForDisplay]

    public static func write(_ value: [AccountForDisplay], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountForDisplay.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountForDisplay] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountForDisplay]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountForDisplay.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAppearanceID: FfiConverterRustBuffer {
    typealias SwiftType = [AppearanceId]

    public static func write(_ value: [AppearanceId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAppearanceID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AppearanceId] {
        let len: Int32 = try readInt(&buf)
        var seq = [AppearanceId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAppearanceID.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAssetException: FfiConverterRustBuffer {
    typealias SwiftType = [AssetException]

    public static func write(_ value: [AssetException], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAssetException.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetException] {
        let len: Int32 = try readInt(&buf)
        var seq = [AssetException]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAssetException.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAuthorizedDapp: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedDapp]

    public static func write(_ value: [AuthorizedDapp], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedDapp.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedDapp] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedDapp]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAuthorizedDapp.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAuthorizedPersonaDetailed: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedPersonaDetailed]

    public static func write(_ value: [AuthorizedPersonaDetailed], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedPersonaDetailed.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedPersonaDetailed] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedPersonaDetailed]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAuthorizedPersonaDetailed.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAuthorizedPersonaSimple: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedPersonaSimple]

    public static func write(_ value: [AuthorizedPersonaSimple], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedPersonaSimple.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedPersonaSimple] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedPersonaSimple]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAuthorizedPersonaSimple.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeBIP39Word: FfiConverterRustBuffer {
    typealias SwiftType = [Bip39Word]

    public static func write(_ value: [Bip39Word], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBIP39Word.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip39Word] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bip39Word]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeBIP39Word.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeBlob: FfiConverterRustBuffer {
    typealias SwiftType = [Blob]

    public static func write(_ value: [Blob], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBlob.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Blob] {
        let len: Int32 = try readInt(&buf)
        var seq = [Blob]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeBlob.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeComponentAddress: FfiConverterRustBuffer {
    typealias SwiftType = [ComponentAddress]

    public static func write(_ value: [ComponentAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeComponentAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ComponentAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [ComponentAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeComponentAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [EmailAddress]

    public static func write(_ value: [EmailAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEmailAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EmailAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [EmailAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeEmailAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeEntityMetadataItem: FfiConverterRustBuffer {
    typealias SwiftType = [EntityMetadataItem]

    public static func write(_ value: [EntityMetadataItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEntityMetadataItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityMetadataItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [EntityMetadataItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeEntityMetadataItem.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeExactly60Bytes: FfiConverterRustBuffer {
    typealias SwiftType = [Exactly60Bytes]

    public static func write(_ value: [Exactly60Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeExactly60Bytes.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Exactly60Bytes] {
        let len: Int32 = try readInt(&buf)
        var seq = [Exactly60Bytes]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeExactly60Bytes.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorInstance: FfiConverterRustBuffer {
    typealias SwiftType = [FactorInstance]

    public static func write(_ value: [FactorInstance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorInstance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorInstance] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorInstance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorInstance.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeGateway: FfiConverterRustBuffer {
    typealias SwiftType = [Gateway]

    public static func write(_ value: [Gateway], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGateway.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Gateway] {
        let len: Int32 = try readInt(&buf)
        var seq = [Gateway]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeGateway.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHDPathComponent: FfiConverterRustBuffer {
    typealias SwiftType = [HdPathComponent]

    public static func write(_ value: [HdPathComponent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHDPathComponent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HdPathComponent] {
        let len: Int32 = try readInt(&buf)
        var seq = [HdPathComponent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeHDPathComponent.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHierarchicalDeterministicPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [HierarchicalDeterministicPublicKey]

    public static func write(_ value: [HierarchicalDeterministicPublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHierarchicalDeterministicPublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HierarchicalDeterministicPublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [HierarchicalDeterministicPublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeIdentityAddress: FfiConverterRustBuffer {
    typealias SwiftType = [IdentityAddress]

    public static func write(_ value: [IdentityAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIdentityAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IdentityAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [IdentityAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeIdentityAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeIntentSignature: FfiConverterRustBuffer {
    typealias SwiftType = [IntentSignature]

    public static func write(_ value: [IntentSignature], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIntentSignature.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IntentSignature] {
        let len: Int32 = try readInt(&buf)
        var seq = [IntentSignature]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeIntentSignature.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNonFungibleGlobalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleGlobalId]

    public static func write(_ value: [NonFungibleGlobalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleGlobalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleGlobalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNonFungibleGlobalId.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeP2PLink: FfiConverterRustBuffer {
    typealias SwiftType = [P2pLink]

    public static func write(_ value: [P2pLink], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeP2PLink.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [P2pLink] {
        let len: Int32 = try readInt(&buf)
        var seq = [P2pLink]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeP2PLink.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerAssetFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetFungibleTransfer]

    public static func write(_ value: [PerAssetFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerAssetFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerAssetNonFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetNonFungibleTransfer]

    public static func write(_ value: [PerAssetNonFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetNonFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetNonFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetNonFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerAssetNonFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerAssetTransfersOfFungibleResource: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetTransfersOfFungibleResource]

    public static func write(_ value: [PerAssetTransfersOfFungibleResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetTransfersOfFungibleResource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetTransfersOfFungibleResource] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetTransfersOfFungibleResource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerAssetTransfersOfFungibleResource.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetTransfersOfNonFungibleResource]

    public static func write(_ value: [PerAssetTransfersOfNonFungibleResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetTransfersOfNonFungibleResource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetTransfersOfNonFungibleResource] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetTransfersOfNonFungibleResource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerAssetTransfersOfNonFungibleResource.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerRecipientAssetTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerRecipientAssetTransfer]

    public static func write(_ value: [PerRecipientAssetTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerRecipientAssetTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientAssetTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerRecipientAssetTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerRecipientAssetTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerRecipientFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerRecipientFungibleTransfer]

    public static func write(_ value: [PerRecipientFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerRecipientFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerRecipientFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerRecipientFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerRecipientNonFungiblesTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerRecipientNonFungiblesTransfer]

    public static func write(_ value: [PerRecipientNonFungiblesTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerRecipientNonFungiblesTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientNonFungiblesTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerRecipientNonFungiblesTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerRecipientNonFungiblesTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersona: FfiConverterRustBuffer {
    typealias SwiftType = [Persona]

    public static func write(_ value: [Persona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Persona] {
        let len: Int32 = try readInt(&buf)
        var seq = [Persona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersona.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryPhoneNumber]

    public static func write(_ value: [PersonaDataEntryPhoneNumber], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataEntryPhoneNumber.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataEntryPhoneNumber] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataEntryPhoneNumber]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataEntryPhoneNumber.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataIdentifiedEmailAddress]

    public static func write(_ value: [PersonaDataIdentifiedEmailAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataIdentifiedEmailAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataIdentifiedEmailAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataIdentifiedEmailAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataIdentifiedEmailAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataIdentifiedPhoneNumber]

    public static func write(_ value: [PersonaDataIdentifiedPhoneNumber], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataIdentifiedPhoneNumber.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataIdentifiedPhoneNumber] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataIdentifiedPhoneNumber]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataIdentifiedPhoneNumber.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePoolAddress: FfiConverterRustBuffer {
    typealias SwiftType = [PoolAddress]

    public static func write(_ value: [PoolAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePoolAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PoolAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [PoolAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePoolAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeProfileNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [ProfileNetwork]

    public static func write(_ value: [ProfileNetwork], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProfileNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ProfileNetwork] {
        let len: Int32 = try readInt(&buf)
        var seq = [ProfileNetwork]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeProfileNetwork.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceAddress: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceAddress]

    public static func write(_ value: [ResourceAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceAppPreference: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceAppPreference]

    public static func write(_ value: [ResourceAppPreference], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceAppPreference.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAppPreference] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceAppPreference]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceAppPreference.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityStructureOfFactorSourceIDs]

    public static func write(_ value: [SecurityStructureOfFactorSourceIDs], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurityStructureOfFactorSourceIDs.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityStructureOfFactorSourceIDs] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityStructureOfFactorSourceIDs]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSecurityStructureOfFactorSourceIDs.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSecurityStructureOfFactorSources: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityStructureOfFactorSources]

    public static func write(_ value: [SecurityStructureOfFactorSources], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurityStructureOfFactorSources.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityStructureOfFactorSources] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityStructureOfFactorSources]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSecurityStructureOfFactorSources.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityNotProductionReadyQuestion]

    public static func write(_ value: [SecurityNotProductionReadyQuestion], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityNotProductionReadyQuestion] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityNotProductionReadyQuestion]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityNotProductionReadyQuestionAndAnswer]

    public static func write(_ value: [SecurityNotProductionReadyQuestionAndAnswer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityNotProductionReadyQuestionAndAnswer] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityNotProductionReadyQuestionAndAnswer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeStakeClaim: FfiConverterRustBuffer {
    typealias SwiftType = [StakeClaim]

    public static func write(_ value: [StakeClaim], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStakeClaim.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [StakeClaim] {
        let len: Int32 = try readInt(&buf)
        var seq = [StakeClaim]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeStakeClaim.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeStateEntityDetailsResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = [StateEntityDetailsResponseItem]

    public static func write(_ value: [StateEntityDetailsResponseItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStateEntityDetailsResponseItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [StateEntityDetailsResponseItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [StateEntityDetailsResponseItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeStateEntityDetailsResponseItem.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTrackedPoolContribution: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedPoolContribution]

    public static func write(_ value: [TrackedPoolContribution], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedPoolContribution.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedPoolContribution] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedPoolContribution]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTrackedPoolContribution.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTrackedPoolRedemption: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedPoolRedemption]

    public static func write(_ value: [TrackedPoolRedemption], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedPoolRedemption.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedPoolRedemption] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedPoolRedemption]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTrackedPoolRedemption.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTrackedValidatorClaim: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedValidatorClaim]

    public static func write(_ value: [TrackedValidatorClaim], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedValidatorClaim.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorClaim] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedValidatorClaim]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTrackedValidatorClaim.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTrackedValidatorStake: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedValidatorStake]

    public static func write(_ value: [TrackedValidatorStake], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedValidatorStake.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorStake] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedValidatorStake]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTrackedValidatorStake.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTransactionGuarantee: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionGuarantee]

    public static func write(_ value: [TransactionGuarantee], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionGuarantee.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionGuarantee] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionGuarantee]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTransactionGuarantee.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTransactionPreviewResponseLogsInner: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionPreviewResponseLogsInner]

    public static func write(_ value: [TransactionPreviewResponseLogsInner], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionPreviewResponseLogsInner.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionPreviewResponseLogsInner] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionPreviewResponseLogsInner]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTransactionPreviewResponseLogsInner.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeValidatorAddress: FfiConverterRustBuffer {
    typealias SwiftType = [ValidatorAddress]

    public static func write(_ value: [ValidatorAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeValidatorAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ValidatorAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [ValidatorAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeValidatorAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeWalletInteractionWalletAccount: FfiConverterRustBuffer {
    typealias SwiftType = [WalletInteractionWalletAccount]

    public static func write(_ value: [WalletInteractionWalletAccount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletInteractionWalletAccount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletInteractionWalletAccount] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletInteractionWalletAccount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeWalletInteractionWalletAccount.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
    typealias SwiftType = [WalletToDappInteractionAccountProof]

    public static func write(_ value: [WalletToDappInteractionAccountProof], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletToDappInteractionAccountProof.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletToDappInteractionAccountProof] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletToDappInteractionAccountProof]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeWalletToDappInteractionAccountProof.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = [AccountOrPersona]

    public static func write(_ value: [AccountOrPersona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountOrPersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountOrPersona] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountOrPersona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountOrPersona.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = [Address]

    public static func write(_ value: [Address], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Address] {
        let len: Int32 = try readInt(&buf)
        var seq = [Address]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAddressOfAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = [AddressOfAccountOrPersona]

    public static func write(_ value: [AddressOfAccountOrPersona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddressOfAccountOrPersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AddressOfAccountOrPersona] {
        let len: Int32 = try readInt(&buf)
        var seq = [AddressOfAccountOrPersona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAddressOfAccountOrPersona.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeBIP39WordCount: FfiConverterRustBuffer {
    typealias SwiftType = [Bip39WordCount]

    public static func write(_ value: [Bip39WordCount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBIP39WordCount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip39WordCount] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bip39WordCount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeBIP39WordCount.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeDerivationPath: FfiConverterRustBuffer {
    typealias SwiftType = [DerivationPath]

    public static func write(_ value: [DerivationPath], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivationPath.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationPath] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivationPath]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeDerivationPath.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeDerivationPathScheme: FfiConverterRustBuffer {
    typealias SwiftType = [DerivationPathScheme]

    public static func write(_ value: [DerivationPathScheme], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivationPathScheme.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationPathScheme] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivationPathScheme]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeDerivationPathScheme.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeDetailedManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = [DetailedManifestClass]

    public static func write(_ value: [DetailedManifestClass], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDetailedManifestClass.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DetailedManifestClass] {
        let len: Int32 = try readInt(&buf)
        var seq = [DetailedManifestClass]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeDetailedManifestClass.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeEntityFlag: FfiConverterRustBuffer {
    typealias SwiftType = [EntityFlag]

    public static func write(_ value: [EntityFlag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEntityFlag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityFlag] {
        let len: Int32 = try readInt(&buf)
        var seq = [EntityFlag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeEntityFlag.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeEventKind: FfiConverterRustBuffer {
    typealias SwiftType = [EventKind]

    public static func write(_ value: [EventKind], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEventKind.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EventKind] {
        let len: Int32 = try readInt(&buf)
        var seq = [EventKind]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeEventKind.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorSource: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSource]

    public static func write(_ value: [FactorSource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSource] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorSource.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorSourceFlag: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSourceFlag]

    public static func write(_ value: [FactorSourceFlag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSourceFlag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceFlag] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSourceFlag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorSourceFlag.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorSourceID: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSourceId]

    public static func write(_ value: [FactorSourceId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSourceID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceId] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSourceId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorSourceID.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFungibleResourcesCollectionItem: FfiConverterRustBuffer {
    typealias SwiftType = [FungibleResourcesCollectionItem]

    public static func write(_ value: [FungibleResourcesCollectionItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFungibleResourcesCollectionItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FungibleResourcesCollectionItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [FungibleResourcesCollectionItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFungibleResourcesCollectionItem.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHomeCard: FfiConverterRustBuffer {
    typealias SwiftType = [HomeCard]

    public static func write(_ value: [HomeCard], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHomeCard.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HomeCard] {
        let len: Int32 = try readInt(&buf)
        var seq = [HomeCard]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeHomeCard.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeLogFilter: FfiConverterRustBuffer {
    typealias SwiftType = [LogFilter]

    public static func write(_ value: [LogFilter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLogFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LogFilter] {
        let len: Int32 = try readInt(&buf)
        var seq = [LogFilter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeLogFilter.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = [LogLevel]

    public static func write(_ value: [LogLevel], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLogLevel.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LogLevel] {
        let len: Int32 = try readInt(&buf)
        var seq = [LogLevel]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeLogLevel.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNetworkID: FfiConverterRustBuffer {
    typealias SwiftType = [NetworkId]

    public static func write(_ value: [NetworkId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNetworkID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NetworkId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NetworkId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNetworkID.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleLocalId]

    public static func write(_ value: [NonFungibleLocalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleLocalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleLocalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleLocalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNonFungibleLocalId.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKeyHash]

    public static func write(_ value: [PublicKeyHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKeyHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKeyHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKeyHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePublicKeyHash.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeReservedInstruction: FfiConverterRustBuffer {
    typealias SwiftType = [ReservedInstruction]

    public static func write(_ value: [ReservedInstruction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReservedInstruction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReservedInstruction] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReservedInstruction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeReservedInstruction.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceIdentifier]

    public static func write(_ value: [ResourceIdentifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceIdentifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceIdentifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceIdentifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceIdentifier.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceIndicator]

    public static func write(_ value: [ResourceIndicator], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceIndicator.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceIndicator] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceIndicator]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceIndicator.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceOrNonFungible]

    public static func write(_ value: [ResourceOrNonFungible], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceOrNonFungible.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceOrNonFungible] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceOrNonFungible]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceOrNonFungible.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceSpecifier: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceSpecifier]

    public static func write(_ value: [ResourceSpecifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceSpecifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceSpecifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceSpecifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceSpecifier.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSLIP10Curve: FfiConverterRustBuffer {
    typealias SwiftType = [Slip10Curve]

    public static func write(_ value: [Slip10Curve], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSLIP10Curve.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Slip10Curve] {
        let len: Int32 = try readInt(&buf)
        var seq = [Slip10Curve]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSLIP10Curve.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataEntryID: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryId]

    public static func write(_ value: [PersonaDataEntryId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataEntryID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataEntryId] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataEntryId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataEntryID.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressTypeDepositRule: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: DepositRule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterTypeDepositRule.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: DepositRule] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: DepositRule]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterTypeDepositRule.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [ResourceIndicator]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterSequenceTypeResourceIndicator.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceIndicator]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [ResourceIndicator]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceIndicator.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [ResourceOrNonFungible]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterSequenceTypeResourceOrNonFungible.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceOrNonFungible]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [ResourceOrNonFungible]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData: FfiConverterRustBuffer {
    public static func write(_ value: [NonFungibleGlobalId: UnstakeData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeNonFungibleGlobalId.write(key, into: &buf)
            FfiConverterTypeUnstakeData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId: UnstakeData] {
        let len: Int32 = try readInt(&buf)
        var dict = [NonFungibleGlobalId: UnstakeData]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
            let value = try FfiConverterTypeUnstakeData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeResourceAddressTypeDecimal192: FfiConverterRustBuffer {
    public static func write(_ value: [ResourceAddress: Decimal192], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeResourceAddress.write(key, into: &buf)
            FfiConverterTypeDecimal192.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: Decimal192] {
        let len: Int32 = try readInt(&buf)
        var dict = [ResourceAddress: Decimal192]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeResourceAddress.read(from: &buf)
            let value = try FfiConverterTypeDecimal192.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource: FfiConverterRustBuffer {
    public static func write(_ value: [ResourceAddress: NewlyCreatedResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeResourceAddress.write(key, into: &buf)
            FfiConverterTypeNewlyCreatedResource.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: NewlyCreatedResource] {
        let len: Int32 = try readInt(&buf)
        var dict = [ResourceAddress: NewlyCreatedResource]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeResourceAddress.read(from: &buf)
            let value = try FfiConverterTypeNewlyCreatedResource.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    public static func write(_ value: [ResourceAddress: ResourcePreferenceUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeResourceAddress.write(key, into: &buf)
            FfiConverterTypeResourcePreferenceUpdate.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: ResourcePreferenceUpdate] {
        let len: Int32 = try readInt(&buf)
        var dict = [ResourceAddress: ResourcePreferenceUpdate]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeResourceAddress.read(from: &buf)
            let value = try FfiConverterTypeResourcePreferenceUpdate.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bip39Passphrase = String
public struct FfiConverterTypeBIP39Passphrase: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Passphrase {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Bip39Passphrase, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bip39Passphrase {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Bip39Passphrase) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeBIP39Passphrase_lift(_ value: RustBuffer) throws -> Bip39Passphrase {
    return try FfiConverterTypeBIP39Passphrase.lift(value)
}

public func FfiConverterTypeBIP39Passphrase_lower(_ value: Bip39Passphrase) -> RustBuffer {
    return FfiConverterTypeBIP39Passphrase.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bip39SeedSecretMagic = BagOfBytes
public struct FfiConverterTypeBIP39SeedSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39SeedSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Bip39SeedSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bip39SeedSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Bip39SeedSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeBIP39SeedSecretMagic_lift(_ value: RustBuffer) throws -> Bip39SeedSecretMagic {
    return try FfiConverterTypeBIP39SeedSecretMagic.lift(value)
}

public func FfiConverterTypeBIP39SeedSecretMagic_lower(_ value: Bip39SeedSecretMagic) -> RustBuffer {
    return FfiConverterTypeBIP39SeedSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BagOfBytes = Data

public struct FfiConverterTypeBagOfBytes: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BagOfBytes {
        let builtinValue = try FfiConverterSequenceInt8.read(from: &buf)
        return Data(builtinValue.map { i8 in UInt8(bitPattern: i8) })
    }

    public static func write(_ value: BagOfBytes, into buf: inout [UInt8]) {
        let builtinValue = value.map { u8 in Int8(bitPattern: u8) }
        return FfiConverterSequenceInt8.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BagOfBytes {
        let builtinValue = try FfiConverterSequenceInt8.lift(value)
        return Data(builtinValue.map { i8 in UInt8(bitPattern: i8) })
    }

    public static func lower(_ value: BagOfBytes) -> RustBuffer {
        let builtinValue = value.map { u8 in Int8(bitPattern: u8) }
        return FfiConverterSequenceInt8.lower(builtinValue)
    }
}

public func FfiConverterTypeBagOfBytes_lift(_ value: RustBuffer) throws -> BagOfBytes {
    return try FfiConverterTypeBagOfBytes.lift(value)
}

public func FfiConverterTypeBagOfBytes_lower(_ value: BagOfBytes) -> RustBuffer {
    return FfiConverterTypeBagOfBytes.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DappOrigin = String
public struct FfiConverterTypeDappOrigin: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappOrigin {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: DappOrigin, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DappOrigin {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: DappOrigin) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeDappOrigin_lift(_ value: RustBuffer) throws -> DappOrigin {
    return try FfiConverterTypeDappOrigin.lift(value)
}

public func FfiConverterTypeDappOrigin_lower(_ value: DappOrigin) -> RustBuffer {
    return FfiConverterTypeDappOrigin.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DappToWalletInteractionAuthChallengeNonce = Exactly32Bytes
public struct FfiConverterTypeDappToWalletInteractionAuthChallengeNonce: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthChallengeNonce {
        return try FfiConverterTypeExactly32Bytes.read(from: &buf)
    }

    public static func write(_ value: DappToWalletInteractionAuthChallengeNonce, into buf: inout [UInt8]) {
        return FfiConverterTypeExactly32Bytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DappToWalletInteractionAuthChallengeNonce {
        return try FfiConverterTypeExactly32Bytes.lift(value)
    }

    public static func lower(_ value: DappToWalletInteractionAuthChallengeNonce) -> RustBuffer {
        return FfiConverterTypeExactly32Bytes.lower(value)
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthChallengeNonce_lift(_ value: RustBuffer) throws -> DappToWalletInteractionAuthChallengeNonce {
    return try FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.lift(value)
}

public func FfiConverterTypeDappToWalletInteractionAuthChallengeNonce_lower(_ value: DappToWalletInteractionAuthChallengeNonce) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DeviceId = Uuid
public struct FfiConverterTypeDeviceID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: DeviceId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DeviceId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: DeviceId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypeDeviceID_lift(_ value: RustBuffer) throws -> DeviceId {
    return try FfiConverterTypeDeviceID.lift(value)
}

public func FfiConverterTypeDeviceID_lower(_ value: DeviceId) -> RustBuffer {
    return FfiConverterTypeDeviceID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Entropy16BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeEntropy16BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy16BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Entropy16BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Entropy16BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Entropy16BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeEntropy16BytesSecretMagic_lift(_ value: RustBuffer) throws -> Entropy16BytesSecretMagic {
    return try FfiConverterTypeEntropy16BytesSecretMagic.lift(value)
}

public func FfiConverterTypeEntropy16BytesSecretMagic_lower(_ value: Entropy16BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeEntropy16BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Entropy20BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeEntropy20BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy20BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Entropy20BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Entropy20BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Entropy20BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeEntropy20BytesSecretMagic_lift(_ value: RustBuffer) throws -> Entropy20BytesSecretMagic {
    return try FfiConverterTypeEntropy20BytesSecretMagic.lift(value)
}

public func FfiConverterTypeEntropy20BytesSecretMagic_lower(_ value: Entropy20BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeEntropy20BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Entropy24BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeEntropy24BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy24BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Entropy24BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Entropy24BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Entropy24BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeEntropy24BytesSecretMagic_lift(_ value: RustBuffer) throws -> Entropy24BytesSecretMagic {
    return try FfiConverterTypeEntropy24BytesSecretMagic.lift(value)
}

public func FfiConverterTypeEntropy24BytesSecretMagic_lower(_ value: Entropy24BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeEntropy24BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Entropy28BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeEntropy28BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy28BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Entropy28BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Entropy28BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Entropy28BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeEntropy28BytesSecretMagic_lift(_ value: RustBuffer) throws -> Entropy28BytesSecretMagic {
    return try FfiConverterTypeEntropy28BytesSecretMagic.lift(value)
}

public func FfiConverterTypeEntropy28BytesSecretMagic_lower(_ value: Entropy28BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeEntropy28BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Entropy32BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeEntropy32BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy32BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Entropy32BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Entropy32BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Entropy32BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeEntropy32BytesSecretMagic_lift(_ value: RustBuffer) throws -> Entropy32BytesSecretMagic {
    return try FfiConverterTypeEntropy32BytesSecretMagic.lift(value)
}

public func FfiConverterTypeEntropy32BytesSecretMagic_lower(_ value: Entropy32BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeEntropy32BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Epoch = UInt64
public struct FfiConverterTypeEpoch: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Epoch {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: Epoch, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> Epoch {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: Epoch) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}

public func FfiConverterTypeEpoch_lift(_ value: UInt64) throws -> Epoch {
    return try FfiConverterTypeEpoch.lift(value)
}

public func FfiConverterTypeEpoch_lower(_ value: Epoch) -> UInt64 {
    return FfiConverterTypeEpoch.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly12BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly12BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly12BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly12BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly12BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly12BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly12BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly12BytesSecretMagic {
    return try FfiConverterTypeExactly12BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly12BytesSecretMagic_lower(_ value: Exactly12BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly12BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly29BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly29BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly29BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly29BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly29BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly29BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly29BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly29BytesSecretMagic {
    return try FfiConverterTypeExactly29BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly29BytesSecretMagic_lower(_ value: Exactly29BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly29BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly32BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly32BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly32BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly32BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly32BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly32BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly32BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly32BytesSecretMagic {
    return try FfiConverterTypeExactly32BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly32BytesSecretMagic_lower(_ value: Exactly32BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly32BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly33BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly33BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly33BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly33BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly33BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly33BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly33BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly33BytesSecretMagic {
    return try FfiConverterTypeExactly33BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly33BytesSecretMagic_lower(_ value: Exactly33BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly33BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly60BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly60BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly60BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly60BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly60BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly60BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly60BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly60BytesSecretMagic {
    return try FfiConverterTypeExactly60BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly60BytesSecretMagic_lower(_ value: Exactly60BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly60BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly64BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly64BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly64BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly64BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly64BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly64BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly64BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly64BytesSecretMagic {
    return try FfiConverterTypeExactly64BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly64BytesSecretMagic_lower(_ value: Exactly64BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly64BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Exactly65BytesSecretMagic = BagOfBytes
public struct FfiConverterTypeExactly65BytesSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly65BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: Exactly65BytesSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Exactly65BytesSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: Exactly65BytesSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeExactly65BytesSecretMagic_lift(_ value: RustBuffer) throws -> Exactly65BytesSecretMagic {
    return try FfiConverterTypeExactly65BytesSecretMagic.lift(value)
}

public func FfiConverterTypeExactly65BytesSecretMagic_lower(_ value: Exactly65BytesSecretMagic) -> RustBuffer {
    return FfiConverterTypeExactly65BytesSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias HashSecretMagic = BagOfBytes
public struct FfiConverterTypeHashSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HashSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: HashSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> HashSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: HashSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeHashSecretMagic_lift(_ value: RustBuffer) throws -> HashSecretMagic {
    return try FfiConverterTypeHashSecretMagic.lift(value)
}

public func FfiConverterTypeHashSecretMagic_lower(_ value: HashSecretMagic) -> RustBuffer {
    return FfiConverterTypeHashSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias InstructionsSecretMagic = BagOfBytes
public struct FfiConverterTypeInstructionsSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InstructionsSecretMagic {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: InstructionsSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> InstructionsSecretMagic {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: InstructionsSecretMagic) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeInstructionsSecretMagic_lift(_ value: RustBuffer) throws -> InstructionsSecretMagic {
    return try FfiConverterTypeInstructionsSecretMagic.lift(value)
}

public func FfiConverterTypeInstructionsSecretMagic_lower(_ value: InstructionsSecretMagic) -> RustBuffer {
    return FfiConverterTypeInstructionsSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias IsAdvancedLockEnabled = Bool
public struct FfiConverterTypeIsAdvancedLockEnabled: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IsAdvancedLockEnabled {
        return try FfiConverterBool.read(from: &buf)
    }

    public static func write(_ value: IsAdvancedLockEnabled, into buf: inout [UInt8]) {
        return FfiConverterBool.write(value, into: &buf)
    }

    public static func lift(_ value: Int8) throws -> IsAdvancedLockEnabled {
        return try FfiConverterBool.lift(value)
    }

    public static func lower(_ value: IsAdvancedLockEnabled) -> Int8 {
        return FfiConverterBool.lower(value)
    }
}

public func FfiConverterTypeIsAdvancedLockEnabled_lift(_ value: Int8) throws -> IsAdvancedLockEnabled {
    return try FfiConverterTypeIsAdvancedLockEnabled.lift(value)
}

public func FfiConverterTypeIsAdvancedLockEnabled_lower(_ value: IsAdvancedLockEnabled) -> Int8 {
    return FfiConverterTypeIsAdvancedLockEnabled.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias IsCloudProfileSyncEnabled = Bool
public struct FfiConverterTypeIsCloudProfileSyncEnabled: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IsCloudProfileSyncEnabled {
        return try FfiConverterBool.read(from: &buf)
    }

    public static func write(_ value: IsCloudProfileSyncEnabled, into buf: inout [UInt8]) {
        return FfiConverterBool.write(value, into: &buf)
    }

    public static func lift(_ value: Int8) throws -> IsCloudProfileSyncEnabled {
        return try FfiConverterBool.lift(value)
    }

    public static func lower(_ value: IsCloudProfileSyncEnabled) -> Int8 {
        return FfiConverterBool.lower(value)
    }
}

public func FfiConverterTypeIsCloudProfileSyncEnabled_lift(_ value: Int8) throws -> IsCloudProfileSyncEnabled {
    return try FfiConverterTypeIsCloudProfileSyncEnabled.lift(value)
}

public func FfiConverterTypeIsCloudProfileSyncEnabled_lower(_ value: IsCloudProfileSyncEnabled) -> Int8 {
    return FfiConverterTypeIsCloudProfileSyncEnabled.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias IsDeveloperModeEnabled = Bool
public struct FfiConverterTypeIsDeveloperModeEnabled: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IsDeveloperModeEnabled {
        return try FfiConverterBool.read(from: &buf)
    }

    public static func write(_ value: IsDeveloperModeEnabled, into buf: inout [UInt8]) {
        return FfiConverterBool.write(value, into: &buf)
    }

    public static func lift(_ value: Int8) throws -> IsDeveloperModeEnabled {
        return try FfiConverterBool.lift(value)
    }

    public static func lower(_ value: IsDeveloperModeEnabled) -> Int8 {
        return FfiConverterBool.lower(value)
    }
}

public func FfiConverterTypeIsDeveloperModeEnabled_lift(_ value: Int8) throws -> IsDeveloperModeEnabled {
    return try FfiConverterTypeIsDeveloperModeEnabled.lift(value)
}

public func FfiConverterTypeIsDeveloperModeEnabled_lower(_ value: IsDeveloperModeEnabled) -> Int8 {
    return FfiConverterTypeIsDeveloperModeEnabled.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias LegacyOlympiaAccountAddressSecretMagic = Secp256k1PublicKey
public struct FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyOlympiaAccountAddressSecretMagic {
        return try FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
    }

    public static func write(_ value: LegacyOlympiaAccountAddressSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterTypeSecp256k1PublicKey.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> LegacyOlympiaAccountAddressSecretMagic {
        return try FfiConverterTypeSecp256k1PublicKey.lift(value)
    }

    public static func lower(_ value: LegacyOlympiaAccountAddressSecretMagic) -> RustBuffer {
        return FfiConverterTypeSecp256k1PublicKey.lower(value)
    }
}

public func FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic_lift(_ value: RustBuffer) throws -> LegacyOlympiaAccountAddressSecretMagic {
    return try FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic.lift(value)
}

public func FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic_lower(_ value: LegacyOlympiaAccountAddressSecretMagic) -> RustBuffer {
    return FfiConverterTypeLegacyOlympiaAccountAddressSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias NonceSecretMagic = UInt32
public struct FfiConverterTypeNonceSecretMagic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonceSecretMagic {
        return try FfiConverterUInt32.read(from: &buf)
    }

    public static func write(_ value: NonceSecretMagic, into buf: inout [UInt8]) {
        return FfiConverterUInt32.write(value, into: &buf)
    }

    public static func lift(_ value: UInt32) throws -> NonceSecretMagic {
        return try FfiConverterUInt32.lift(value)
    }

    public static func lower(_ value: NonceSecretMagic) -> UInt32 {
        return FfiConverterUInt32.lower(value)
    }
}

public func FfiConverterTypeNonceSecretMagic_lift(_ value: UInt32) throws -> NonceSecretMagic {
    return try FfiConverterTypeNonceSecretMagic.lift(value)
}

public func FfiConverterTypeNonceSecretMagic_lower(_ value: NonceSecretMagic) -> UInt32 {
    return FfiConverterTypeNonceSecretMagic.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PersonaDataEntryId = Uuid
public struct FfiConverterTypePersonaDataEntryID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: PersonaDataEntryId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PersonaDataEntryId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: PersonaDataEntryId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypePersonaDataEntryID_lift(_ value: RustBuffer) throws -> PersonaDataEntryId {
    return try FfiConverterTypePersonaDataEntryID.lift(value)
}

public func FfiConverterTypePersonaDataEntryID_lower(_ value: PersonaDataEntryId) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ProfileId = Uuid
public struct FfiConverterTypeProfileID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: ProfileId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ProfileId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: ProfileId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypeProfileID_lift(_ value: RustBuffer) throws -> ProfileId {
    return try FfiConverterTypeProfileID.lift(value)
}

public func FfiConverterTypeProfileID_lower(_ value: ProfileId) -> RustBuffer {
    return FfiConverterTypeProfileID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetAccessControllerAddress = String
public struct FfiConverterTypeRetAccessControllerAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetAccessControllerAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetAccessControllerAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetAccessControllerAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetAccessControllerAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetAccessControllerAddress_lift(_ value: RustBuffer) throws -> RetAccessControllerAddress {
    return try FfiConverterTypeRetAccessControllerAddress.lift(value)
}

public func FfiConverterTypeRetAccessControllerAddress_lower(_ value: RetAccessControllerAddress) -> RustBuffer {
    return FfiConverterTypeRetAccessControllerAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetAccountAddress = String
public struct FfiConverterTypeRetAccountAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetAccountAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetAccountAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetAccountAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetAccountAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetAccountAddress_lift(_ value: RustBuffer) throws -> RetAccountAddress {
    return try FfiConverterTypeRetAccountAddress.lift(value)
}

public func FfiConverterTypeRetAccountAddress_lower(_ value: RetAccountAddress) -> RustBuffer {
    return FfiConverterTypeRetAccountAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetComponentAddress = String
public struct FfiConverterTypeRetComponentAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetComponentAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetComponentAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetComponentAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetComponentAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetComponentAddress_lift(_ value: RustBuffer) throws -> RetComponentAddress {
    return try FfiConverterTypeRetComponentAddress.lift(value)
}

public func FfiConverterTypeRetComponentAddress_lower(_ value: RetComponentAddress) -> RustBuffer {
    return FfiConverterTypeRetComponentAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetIdentityAddress = String
public struct FfiConverterTypeRetIdentityAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetIdentityAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetIdentityAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetIdentityAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetIdentityAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetIdentityAddress_lift(_ value: RustBuffer) throws -> RetIdentityAddress {
    return try FfiConverterTypeRetIdentityAddress.lift(value)
}

public func FfiConverterTypeRetIdentityAddress_lower(_ value: RetIdentityAddress) -> RustBuffer {
    return FfiConverterTypeRetIdentityAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetPackageAddress = String
public struct FfiConverterTypeRetPackageAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetPackageAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetPackageAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetPackageAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetPackageAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetPackageAddress_lift(_ value: RustBuffer) throws -> RetPackageAddress {
    return try FfiConverterTypeRetPackageAddress.lift(value)
}

public func FfiConverterTypeRetPackageAddress_lower(_ value: RetPackageAddress) -> RustBuffer {
    return FfiConverterTypeRetPackageAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetPoolAddress = String
public struct FfiConverterTypeRetPoolAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetPoolAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetPoolAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetPoolAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetPoolAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetPoolAddress_lift(_ value: RustBuffer) throws -> RetPoolAddress {
    return try FfiConverterTypeRetPoolAddress.lift(value)
}

public func FfiConverterTypeRetPoolAddress_lower(_ value: RetPoolAddress) -> RustBuffer {
    return FfiConverterTypeRetPoolAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetResourceAddress = String
public struct FfiConverterTypeRetResourceAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetResourceAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetResourceAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetResourceAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetResourceAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetResourceAddress_lift(_ value: RustBuffer) throws -> RetResourceAddress {
    return try FfiConverterTypeRetResourceAddress.lift(value)
}

public func FfiConverterTypeRetResourceAddress_lower(_ value: RetResourceAddress) -> RustBuffer {
    return FfiConverterTypeRetResourceAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetValidatorAddress = String
public struct FfiConverterTypeRetValidatorAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetValidatorAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetValidatorAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetValidatorAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetValidatorAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetValidatorAddress_lift(_ value: RustBuffer) throws -> RetValidatorAddress {
    return try FfiConverterTypeRetValidatorAddress.lift(value)
}

public func FfiConverterTypeRetValidatorAddress_lower(_ value: RetValidatorAddress) -> RustBuffer {
    return FfiConverterTypeRetValidatorAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RetVaultAddress = String
public struct FfiConverterTypeRetVaultAddress: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetVaultAddress {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RetVaultAddress, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RetVaultAddress {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RetVaultAddress) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeRetVaultAddress_lift(_ value: RustBuffer) throws -> RetVaultAddress {
    return try FfiConverterTypeRetVaultAddress.lift(value)
}

public func FfiConverterTypeRetVaultAddress_lower(_ value: RetVaultAddress) -> RustBuffer {
    return FfiConverterTypeRetVaultAddress.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ScryptoDecimal192 = String
public struct FfiConverterTypeScryptoDecimal192: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScryptoDecimal192 {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ScryptoDecimal192, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ScryptoDecimal192 {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ScryptoDecimal192) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeScryptoDecimal192_lift(_ value: RustBuffer) throws -> ScryptoDecimal192 {
    return try FfiConverterTypeScryptoDecimal192.lift(value)
}

public func FfiConverterTypeScryptoDecimal192_lower(_ value: ScryptoDecimal192) -> RustBuffer {
    return FfiConverterTypeScryptoDecimal192.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ScryptoEd25519PublicKey = BagOfBytes
public struct FfiConverterTypeScryptoEd25519PublicKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScryptoEd25519PublicKey {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: ScryptoEd25519PublicKey, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ScryptoEd25519PublicKey {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: ScryptoEd25519PublicKey) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeScryptoEd25519PublicKey_lift(_ value: RustBuffer) throws -> ScryptoEd25519PublicKey {
    return try FfiConverterTypeScryptoEd25519PublicKey.lift(value)
}

public func FfiConverterTypeScryptoEd25519PublicKey_lower(_ value: ScryptoEd25519PublicKey) -> RustBuffer {
    return FfiConverterTypeScryptoEd25519PublicKey.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ScryptoSecp256k1PublicKey = BagOfBytes
public struct FfiConverterTypeScryptoSecp256k1PublicKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScryptoSecp256k1PublicKey {
        return try FfiConverterTypeBagOfBytes.read(from: &buf)
    }

    public static func write(_ value: ScryptoSecp256k1PublicKey, into buf: inout [UInt8]) {
        return FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ScryptoSecp256k1PublicKey {
        return try FfiConverterTypeBagOfBytes.lift(value)
    }

    public static func lower(_ value: ScryptoSecp256k1PublicKey) -> RustBuffer {
        return FfiConverterTypeBagOfBytes.lower(value)
    }
}

public func FfiConverterTypeScryptoSecp256k1PublicKey_lift(_ value: RustBuffer) throws -> ScryptoSecp256k1PublicKey {
    return try FfiConverterTypeScryptoSecp256k1PublicKey.lift(value)
}

public func FfiConverterTypeScryptoSecp256k1PublicKey_lower(_ value: ScryptoSecp256k1PublicKey) -> RustBuffer {
    return FfiConverterTypeScryptoSecp256k1PublicKey.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ScryptoStringNonFungibleLocalId = String
public struct FfiConverterTypeScryptoStringNonFungibleLocalId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScryptoStringNonFungibleLocalId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ScryptoStringNonFungibleLocalId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ScryptoStringNonFungibleLocalId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ScryptoStringNonFungibleLocalId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeScryptoStringNonFungibleLocalId_lift(_ value: RustBuffer) throws -> ScryptoStringNonFungibleLocalId {
    return try FfiConverterTypeScryptoStringNonFungibleLocalId.lift(value)
}

public func FfiConverterTypeScryptoStringNonFungibleLocalId_lower(_ value: ScryptoStringNonFungibleLocalId) -> RustBuffer {
    return FfiConverterTypeScryptoStringNonFungibleLocalId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SecurityStructureId = Uuid
public struct FfiConverterTypeSecurityStructureID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: SecurityStructureId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> SecurityStructureId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: SecurityStructureId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypeSecurityStructureID_lift(_ value: RustBuffer) throws -> SecurityStructureId {
    return try FfiConverterTypeSecurityStructureID.lift(value)
}

public func FfiConverterTypeSecurityStructureID_lower(_ value: SecurityStructureId) -> RustBuffer {
    return FfiConverterTypeSecurityStructureID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SessionId = Uuid
public struct FfiConverterTypeSessionID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: SessionId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> SessionId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: SessionId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypeSessionID_lift(_ value: RustBuffer) throws -> SessionId {
    return try FfiConverterTypeSessionID.lift(value)
}

public func FfiConverterTypeSessionID_lower(_ value: SessionId) -> RustBuffer {
    return FfiConverterTypeSessionID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TxVersion = UInt64
public struct FfiConverterTypeTXVersion: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxVersion {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: TxVersion, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> TxVersion {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: TxVersion) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}

public func FfiConverterTypeTXVersion_lift(_ value: UInt64) throws -> TxVersion {
    return try FfiConverterTypeTXVersion.lift(value)
}

public func FfiConverterTypeTXVersion_lower(_ value: TxVersion) -> UInt64 {
    return FfiConverterTypeTXVersion.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Timestamp = Date

public struct FfiConverterTypeTimestamp: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timestamp {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return {
            let stringToDeserialize = builtinValue // this is UniFFIs counterpart to `$0`
            let formatter = ISO8601DateFormatter()
            let formatOptionMS = ISO8601DateFormatter.Options.withFractionalSeconds
            formatter.formatOptions.insert(formatOptionMS)

            func format() -> Date? {
                formatter.date(from: stringToDeserialize)
            }

            if let date = format() {
                return date
            }

            // try without fractional seconds
            formatter.formatOptions.remove(formatOptionMS)
            return format()!
        }()
    }

    public static func write(_ value: Timestamp, into buf: inout [UInt8]) {
        let builtinValue = {
            let dateToSerialize = value // this is UniFFIs counterpart to `$0`
            let formatter = ISO8601DateFormatter()
            formatter.formatOptions.insert(.withFractionalSeconds)
            return formatter.string(from: dateToSerialize)
        }()

        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Timestamp {
        let builtinValue = try FfiConverterString.lift(value)
        return {
            let stringToDeserialize = builtinValue // this is UniFFIs counterpart to `$0`
            let formatter = ISO8601DateFormatter()
            let formatOptionMS = ISO8601DateFormatter.Options.withFractionalSeconds
            formatter.formatOptions.insert(formatOptionMS)

            func format() -> Date? {
                formatter.date(from: stringToDeserialize)
            }

            if let date = format() {
                return date
            }

            // try without fractional seconds
            formatter.formatOptions.remove(formatOptionMS)
            return format()!
        }()
    }

    public static func lower(_ value: Timestamp) -> RustBuffer {
        let builtinValue = {
            let dateToSerialize = value // this is UniFFIs counterpart to `$0`
            let formatter = ISO8601DateFormatter()
            formatter.formatOptions.insert(.withFractionalSeconds)
            return formatter.string(from: dateToSerialize)
        }()

        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeTimestamp_lift(_ value: RustBuffer) throws -> Timestamp {
    return try FfiConverterTypeTimestamp.lift(value)
}

public func FfiConverterTypeTimestamp_lower(_ value: Timestamp) -> RustBuffer {
    return FfiConverterTypeTimestamp.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Url = URL

public struct FfiConverterTypeUrl: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Url {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return URL(string: builtinValue)!
    }

    public static func write(_ value: Url, into buf: inout [UInt8]) {
        let builtinValue = String(describing: value)
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Url {
        let builtinValue = try FfiConverterString.lift(value)
        return URL(string: builtinValue)!
    }

    public static func lower(_ value: Url) -> RustBuffer {
        let builtinValue = String(describing: value)
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeUrl_lift(_ value: RustBuffer) throws -> Url {
    return try FfiConverterTypeUrl.lift(value)
}

public func FfiConverterTypeUrl_lower(_ value: Url) -> RustBuffer {
    return FfiConverterTypeUrl.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Uuid = UUID

public struct FfiConverterTypeUuid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return UUID(uuidString: builtinValue)!
    }

    public static func write(_ value: Uuid, into buf: inout [UInt8]) {
        let builtinValue = value.uuidString
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Uuid {
        let builtinValue = try FfiConverterString.lift(value)
        return UUID(uuidString: builtinValue)!
    }

    public static func lower(_ value: Uuid) -> RustBuffer {
        let builtinValue = value.uuidString
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeUuid_lift(_ value: RustBuffer) throws -> Uuid {
    return try FfiConverterTypeUuid.lift(value)
}

public func FfiConverterTypeUuid_lower(_ value: Uuid) -> RustBuffer {
    return FfiConverterTypeUuid.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletInteractionId = String
public struct FfiConverterTypeWalletInteractionId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: WalletInteractionId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> WalletInteractionId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: WalletInteractionId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeWalletInteractionId_lift(_ value: RustBuffer) throws -> WalletInteractionId {
    return try FfiConverterTypeWalletInteractionId.lift(value)
}

public func FfiConverterTypeWalletInteractionId_lower(_ value: WalletInteractionId) -> RustBuffer {
    return FfiConverterTypeWalletInteractionId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletInteractionVersion = UInt64
public struct FfiConverterTypeWalletInteractionVersion: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionVersion {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: WalletInteractionVersion, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> WalletInteractionVersion {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: WalletInteractionVersion) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}

public func FfiConverterTypeWalletInteractionVersion_lift(_ value: UInt64) throws -> WalletInteractionVersion {
    return try FfiConverterTypeWalletInteractionVersion.lift(value)
}

public func FfiConverterTypeWalletInteractionVersion_lower(_ value: WalletInteractionVersion) -> UInt64 {
    return FfiConverterTypeWalletInteractionVersion.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

private func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> Void,
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> Void,
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> Void,
    handleError: @escaping (Int8, RustBuffer) -> Void
) -> UniffiForeignFuture {
    let task = Task {
        do {
            try handleSuccess(await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> Void,
    handleError: @escaping (Int8, RustBuffer) -> Void,
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            try handleSuccess(await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
private var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountSargon() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}

public func accessControllerAddressBech32Address(address: AccessControllerAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_access_controller_address_bech32_address(
            FfiConverterTypeAccessControllerAddress.lower(address), $0
        )
    })
}

public func accessControllerAddressFormatted(address: AccessControllerAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_access_controller_address_formatted(
            FfiConverterTypeAccessControllerAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func accessControllerAddressMapToNetwork(address: AccessControllerAddress, networkId: NetworkId) -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_access_controller_address_map_to_network(
            FfiConverterTypeAccessControllerAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func accessControllerAddressNetworkId(address: AccessControllerAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_access_controller_address_network_id(
            FfiConverterTypeAccessControllerAddress.lower(address), $0
        )
    })
}

public func accountAddressBech32Address(address: AccountAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_account_address_bech32_address(
            FfiConverterTypeAccountAddress.lower(address), $0
        )
    })
}

public func accountAddressFormatted(address: AccountAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_account_address_formatted(
            FfiConverterTypeAccountAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns `false` for all addresses created with `Ed25519PublicKey`s, i.e.
 * for all accounts created by the Babylon Radix Wallets.
 * Returns `true` for all addresses created with `Secp256k1PublicKey`s, i.e.
 * imported from the legacy Olympia desktop application.
 */
public func accountAddressIsLegacy(address: AccountAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_account_address_is_legacy(
            FfiConverterTypeAccountAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func accountAddressMapToNetwork(address: AccountAddress, networkId: NetworkId) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_account_address_map_to_network(
            FfiConverterTypeAccountAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func accountAddressNetworkId(address: AccountAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_account_address_network_id(
            FfiConverterTypeAccountAddress.lower(address), $0
        )
    })
}

public func accountOrAddressOfAccountAddress(recipient: AccountOrAddressOf) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_account_or_address_of_account_address(
            FfiConverterTypeAccountOrAddressOf.lower(recipient), $0
        )
    })
}

public func accountOrPersonaGetId(entity: AccountOrPersona) -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_account_or_persona_get_id(
            FfiConverterTypeAccountOrPersona.lower(entity), $0
        )
    })
}

public func addressFormatted(address: Address, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_address_formatted(
            FfiConverterTypeAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func addressMapToNetwork(address: Address, networkId: NetworkId) -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_address_map_to_network(
            FfiConverterTypeAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func addressNetworkId(address: Address) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_address_network_id(
            FfiConverterTypeAddress.lower(address), $0
        )
    })
}

public func addressOfAccountOrPersonaFormatted(address: AddressOfAccountOrPersona, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_address_of_account_or_persona_formatted(
            FfiConverterTypeAddressOfAccountOrPersona.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func addressOfAccountOrPersonaMapToNetwork(address: AddressOfAccountOrPersona, networkId: NetworkId) -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_address_of_account_or_persona_map_to_network(
            FfiConverterTypeAddressOfAccountOrPersona.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func addressOfAccountOrPersonaNetworkId(address: AddressOfAccountOrPersona) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_address_of_account_or_persona_network_id(
            FfiConverterTypeAddressOfAccountOrPersona.lower(address), $0
        )
    })
}

public func addressOfAccountOrPersonaSampleValuesAll() -> [AddressOfAccountOrPersona] {
    return try! FfiConverterSequenceTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_address_of_account_or_persona_sample_values_all($0
        )
    })
}

public func addressOfAccountOrPersonaToString(address: AddressOfAccountOrPersona) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_address_of_account_or_persona_to_string(
            FfiConverterTypeAddressOfAccountOrPersona.lower(address), $0
        )
    })
}

public func addressSampleValuesAll() -> [Address] {
    return try! FfiConverterSequenceTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_address_sample_values_all($0
        )
    })
}

public func addressToString(address: Address) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_address_to_string(
            FfiConverterTypeAddress.lower(address), $0
        )
    })
}

public func androidNotarizeHashWithPrivateKeyBytes(privateKeyBytes: Exactly32Bytes, signedIntentHash: SignedIntentHash) throws -> NotarySignature {
    return try FfiConverterTypeNotarySignature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_android_notarize_hash_with_private_key_bytes(
            FfiConverterTypeExactly32Bytes.lower(privateKeyBytes),
            FfiConverterTypeSignedIntentHash.lower(signedIntentHash), $0
        )
    })
}

public func androidSecretKeyGetPublicKeyFromPrivateKeyBytes(privateKeyBytes: Exactly32Bytes) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_android_secret_key_get_public_key_from_private_key_bytes(
            FfiConverterTypeExactly32Bytes.lower(privateKeyBytes), $0
        )
    })
}

public func androidSignHashWithPrivateKeyBytes(privateKeyBytes: Exactly32Bytes, hash: Hash) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_android_sign_hash_with_private_key_bytes(
            FfiConverterTypeExactly32Bytes.lower(privateKeyBytes),
            FfiConverterTypeHash.lower(hash), $0
        )
    })
}

public func appPreferencesHasGatewayWithUrl(appPreferences: AppPreferences, url: FfiUrl) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_app_preferences_has_gateway_with_url(
            FfiConverterTypeAppPreferences.lower(appPreferences),
            FfiConverterTypeFfiUrl.lower(url), $0
        )
    })
}

public func appearanceIdsAll() -> [AppearanceId] {
    return try! FfiConverterSequenceTypeAppearanceID.lift(try! rustCall {
        uniffi_sargon_fn_func_appearance_ids_all($0
        )
    })
}

public func arculusCardModelToString(model: ArculusCardModel) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_arculus_card_model_to_string(
            FfiConverterTypeArculusCardModel.lower(model), $0
        )
    })
}

public func authorizedDappToJsonBytes(authorizedDapp: AuthorizedDapp) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_authorized_dapp_to_json_bytes(
            FfiConverterTypeAuthorizedDapp.lower(authorizedDapp), $0
        )
    })
}

public func bIP39SeedToBytes(bytes: Bip39Seed) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_b_i_p39_seed_to_bytes(
            FfiConverterTypeBIP39Seed.lower(bytes), $0
        )
    })
}

public func bagOfBytesAppendCafe(to: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_bag_of_bytes_append_cafe(
            FfiConverterTypeBagOfBytes.lower(to), $0
        )
    })
}

public func bagOfBytesAppendDeadbeef(to: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_bag_of_bytes_append_deadbeef(
            FfiConverterTypeBagOfBytes.lower(to), $0
        )
    })
}

public func bagOfBytesPrependCafe(inFrontOf: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_bag_of_bytes_prepend_cafe(
            FfiConverterTypeBagOfBytes.lower(inFrontOf), $0
        )
    })
}

public func bagOfBytesPrependDeadbeef(inFrontOf: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_bag_of_bytes_prepend_deadbeef(
            FfiConverterTypeBagOfBytes.lower(inFrontOf), $0
        )
    })
}

public func bip39LanguageWordlist(language: Bip39Language) -> [Bip39Word] {
    return try! FfiConverterSequenceTypeBIP39Word.lift(try! rustCall {
        uniffi_sargon_fn_func_bip39_language_wordlist(
            FfiConverterTypeBIP39Language.lower(language), $0
        )
    })
}

public func bip39WordCountAll() -> [Bip39WordCount] {
    return try! FfiConverterSequenceTypeBIP39WordCount.lift(try! rustCall {
        uniffi_sargon_fn_func_bip39_word_count_all($0
        )
    })
}

public func bip44LikePathGetAddressIndex(path: Bip44LikePath) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_fn_func_bip44_like_path_get_address_index(
            FfiConverterTypeBIP44LikePath.lower(path), $0
        )
    })
}

public func bip44LikePathToString(path: Bip44LikePath) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_bip44_like_path_to_string(
            FfiConverterTypeBIP44LikePath.lower(path), $0
        )
    })
}

public func blobToBytes(blob: Blob) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_blob_to_bytes(
            FfiConverterTypeBlob.lower(blob), $0
        )
    })
}

public func blobToString(blob: Blob) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_blob_to_string(
            FfiConverterTypeBlob.lower(blob), $0
        )
    })
}

public func blobsListOfBlobs(blobs: Blobs) -> [Blob] {
    return try! FfiConverterSequenceTypeBlob.lift(try! rustCall {
        uniffi_sargon_fn_func_blobs_list_of_blobs(
            FfiConverterTypeBlobs.lower(blobs), $0
        )
    })
}

public func buildInformation() -> SargonBuildInformation {
    return try! FfiConverterTypeSargonBuildInformation.lift(try! rustCall {
        uniffi_sargon_fn_func_build_information($0
        )
    })
}

public func cap26PathToString(path: Cap26Path) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_cap26_path_to_string(
            FfiConverterTypeCAP26Path.lower(path), $0
        )
    })
}

public func checkIfEncryptedProfileJsonContainsLegacyP2pLinks(jsonStr: String, password: String) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_check_if_encrypted_profile_json_contains_legacy_p2p_links(
            FfiConverterString.lower(jsonStr),
            FfiConverterString.lower(password), $0
        )
    })
}

public func checkIfProfileJsonContainsLegacyP2pLinks(jsonStr: String) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_check_if_profile_json_contains_legacy_p2p_links(
            FfiConverterString.lower(jsonStr), $0
        )
    })
}

public func compiledNotarizedIntentGetBytes(compiledNotarizedIntent: CompiledNotarizedIntent) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_compiled_notarized_intent_get_bytes(
            FfiConverterTypeCompiledNotarizedIntent.lower(compiledNotarizedIntent), $0
        )
    })
}

public func componentAddressBech32Address(address: ComponentAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_component_address_bech32_address(
            FfiConverterTypeComponentAddress.lower(address), $0
        )
    })
}

public func componentAddressFormatted(address: ComponentAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_component_address_formatted(
            FfiConverterTypeComponentAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns `true` if the ComponentAddress is `global` (i.e. not `internal`)
 */
public func componentAddressIsGlobal(address: ComponentAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_component_address_is_global(
            FfiConverterTypeComponentAddress.lower(address), $0
        )
    })
}

/**
 * Returns `true` if the ComponentAddress is `internal` (i.e. not `global`)
 */
public func componentAddressIsInternal(address: ComponentAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_component_address_is_internal(
            FfiConverterTypeComponentAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func componentAddressMapToNetwork(address: ComponentAddress, networkId: NetworkId) -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_component_address_map_to_network(
            FfiConverterTypeComponentAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func componentAddressNetworkId(address: ComponentAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_component_address_network_id(
            FfiConverterTypeComponentAddress.lower(address), $0
        )
    })
}

public func dappToWalletInteractionUnvalidatedToJsonBytes(dappToWalletInteractionUnvalidated: DappToWalletInteractionUnvalidated) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_dapp_to_wallet_interaction_unvalidated_to_json_bytes(
            FfiConverterTypeDappToWalletInteractionUnvalidated.lower(dappToWalletInteractionUnvalidated), $0
        )
    })
}

public func dappToWalletInteractionUnvalidatedToJsonString(interactionUnvalidated: DappToWalletInteractionUnvalidated, prettyPrinted: Bool) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_dapp_to_wallet_interaction_unvalidated_to_json_string(
            FfiConverterTypeDappToWalletInteractionUnvalidated.lower(interactionUnvalidated),
            FfiConverterBool.lower(prettyPrinted), $0
        )
    })
}

public func debugPrintCompiledNotarizedIntent(compiled: CompiledNotarizedIntent) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_debug_print_compiled_notarized_intent(
            FfiConverterTypeCompiledNotarizedIntent.lower(compiled), $0
        )
    })
}

/**
 * Returns `decimal.abs()`, panics if `decimal` is `Decimal192::MIN`
 */
public func decimalAbs(decimal: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_abs(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * `lhs + rhs``
 */
public func decimalAdd(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_add(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * Clamps `decimal` to zero, i.e. `max(decimal, 0)`
 */
public func decimalClampedToZero(decimal: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_clamped_to_zero(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * `lhs / rhs``
 */
public func decimalDiv(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_div(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

public func decimalFormatted(decimal: Decimal192, locale: LocaleConfig, totalPlaces: UInt8, useGroupingSeparator: Bool) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_formatted(
            FfiConverterTypeDecimal192.lower(decimal),
            FfiConverterTypeLocaleConfig.lower(locale),
            FfiConverterUInt8.lower(totalPlaces),
            FfiConverterBool.lower(useGroupingSeparator), $0
        )
    })
}

/**
 * A human readable, locale respecting string. Does not perform any rounding or truncation.
 */
public func decimalFormattedPlain(decimal: Decimal192, locale: LocaleConfig, useGroupingSeparator: Bool) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_formatted_plain(
            FfiConverterTypeDecimal192.lower(decimal),
            FfiConverterTypeLocaleConfig.lower(locale),
            FfiConverterBool.lower(useGroupingSeparator), $0
        )
    })
}

/**
 * `lhs > rhs`
 */
public func decimalGreaterThan(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_greater_than(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * `lhs >= rhs`
 */
public func decimalGreaterThanOrEqual(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_greater_than_or_equal(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * Whether this decimal is negative.
 */
public func decimalIsNegative(decimal: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_is_negative(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * Whether this decimal is positive.
 */
public func decimalIsPositive(decimal: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_is_positive(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * Whether this decimal is zero.
 */
public func decimalIsZero(decimal: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_is_zero(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * `lhs < rhs`
 */
public func decimalLessThan(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_less_than(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * `lhs <= rhs`
 */
public func decimalLessThanOrEqual(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_less_than_or_equal(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * The maximum possible value of `Decimal192`, being:
 * `3138550867693340381917894711603833208051.177722232017256447`
 */
public func decimalMax() -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_max($0
        )
    })
}

/**
 * The minimum possible value of `Decimal192`, being:
 * `-3138550867693340381917894711603833208051.177722232017256448`
 */
public func decimalMin() -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_min($0
        )
    })
}

/**
 * `lhs * rhs``
 */
public func decimalMul(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_mul(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * Negates the `decimal`
 */
public func decimalNeg(decimal: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_neg(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * Rounds this number to the specified decimal places.
 *
 * # Panics
 * - Panic if the number of decimal places is not within [0..SCALE(=18)]
 */
public func decimalRound(decimal: Decimal192, decimalPlaces: UInt8, roundingMode: RoundingMode) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_decimal_round(
            FfiConverterTypeDecimal192.lower(decimal),
            FfiConverterUInt8.lower(decimalPlaces),
            FfiConverterTypeRoundingMode.lower(roundingMode), $0
        )
    })
}

/**
 * `lhs - rhs``
 */
public func decimalSub(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_sub(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * `decimal.to_string()`
 */
public func decimalToString(decimal: Decimal192) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_decimal_to_string(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

public func defaultGetIdPath() -> GetIdPath {
    return try! FfiConverterTypeGetIDPath.lift(try! rustCall {
        uniffi_sargon_fn_func_default_get_id_path($0
        )
    })
}

public func dependencyInformationToString(info: DependencyInformation) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_dependency_information_to_string(
            FfiConverterTypeDependencyInformation.lower(info), $0
        )
    })
}

public func depositRuleToJsonString(depositRule: DepositRule) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_deposit_rule_to_json_string(
            FfiConverterTypeDepositRule.lower(depositRule), $0
        )
    })
}

public func derivationPathToHdPath(path: DerivationPath) -> HdPath {
    return try! FfiConverterTypeHDPath.lift(try! rustCall {
        uniffi_sargon_fn_func_derivation_path_to_hd_path(
            FfiConverterTypeDerivationPath.lower(path), $0
        )
    })
}

public func derivationPathToString(path: DerivationPath) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_derivation_path_to_string(
            FfiConverterTypeDerivationPath.lower(path), $0
        )
    })
}

public func deviceFactorSourceIsMainBdfs(deviceFactorSource: DeviceFactorSource) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_device_factor_source_is_main_bdfs(
            FfiConverterTypeDeviceFactorSource.lower(deviceFactorSource), $0
        )
    })
}

public func deviceInfoDescriptionToString(deviceInfoDescription: DeviceInfoDescription) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_device_info_description_to_string(
            FfiConverterTypeDeviceInfoDescription.lower(deviceInfoDescription), $0
        )
    })
}

public func deviceInfoToJsonBytes(deviceInfo: DeviceInfo) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_device_info_to_json_bytes(
            FfiConverterTypeDeviceInfo.lower(deviceInfo), $0
        )
    })
}

public func displayNameToJsonString(displayName: DisplayName) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_display_name_to_json_string(
            FfiConverterTypeDisplayName.lower(displayName), $0
        )
    })
}

public func ed25519PublicKeyToBytes(publicKey: Ed25519PublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_ed25519_public_key_to_bytes(
            FfiConverterTypeEd25519PublicKey.lower(publicKey), $0
        )
    })
}

/**
 * Encodes the `Ed25519PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"b7a3c12dc0c8c748ab07525b701122b88bd78f600c76342d27f25e5f92444cde"`
 */
public func ed25519PublicKeyToHex(publicKey: Ed25519PublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_ed25519_public_key_to_hex(
            FfiConverterTypeEd25519PublicKey.lower(publicKey), $0
        )
    })
}

public func ed25519PublicKeyToJsonString(ed25519PublicKey: Ed25519PublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_ed25519_public_key_to_json_string(
            FfiConverterTypeEd25519PublicKey.lower(ed25519PublicKey), $0
        )
    })
}

public func ed25519SignatureToJsonString(ed25519Signature: Ed25519Signature) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_ed25519_signature_to_json_string(
            FfiConverterTypeEd25519Signature.lower(ed25519Signature), $0
        )
    })
}

public func ed25519SignatureToString(signature: Ed25519Signature) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_ed25519_signature_to_string(
            FfiConverterTypeEd25519Signature.lower(signature), $0
        )
    })
}

public func entropy16BytesToBytes(bytes: Entropy16Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_entropy16_bytes_to_bytes(
            FfiConverterTypeEntropy16Bytes.lower(bytes), $0
        )
    })
}

public func entropy20BytesToBytes(bytes: Entropy20Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_entropy20_bytes_to_bytes(
            FfiConverterTypeEntropy20Bytes.lower(bytes), $0
        )
    })
}

public func entropy24BytesToBytes(bytes: Entropy24Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_entropy24_bytes_to_bytes(
            FfiConverterTypeEntropy24Bytes.lower(bytes), $0
        )
    })
}

public func entropy28BytesToBytes(bytes: Entropy28Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_entropy28_bytes_to_bytes(
            FfiConverterTypeEntropy28Bytes.lower(bytes), $0
        )
    })
}

public func entropy32BytesToBytes(bytes: Entropy32Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_entropy32_bytes_to_bytes(
            FfiConverterTypeEntropy32Bytes.lower(bytes), $0
        )
    })
}

public func errorCodeFromError(error: CommonError) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_fn_func_error_code_from_error(
            FfiConverterTypeCommonError.lower(error), $0
        )
    })
}

public func errorMessageFromError(error: CommonError) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_error_message_from_error(
            FfiConverterTypeCommonError.lower(error), $0
        )
    })
}

public func eventKind(event: Event) -> EventKind {
    return try! FfiConverterTypeEventKind.lift(try! rustCall {
        uniffi_sargon_fn_func_event_kind(
            FfiConverterTypeEvent.lower(event), $0
        )
    })
}

public func eventKindAffectsCurrentAccounts(eventKind: EventKind) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_event_kind_affects_current_accounts(
            FfiConverterTypeEventKind.lower(eventKind), $0
        )
    })
}

public func eventKindAffectsCurrentNetwork(eventKind: EventKind) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_event_kind_affects_current_network(
            FfiConverterTypeEventKind.lower(eventKind), $0
        )
    })
}

public func eventKindAffectsFactorSources(eventKind: EventKind) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_event_kind_affects_factor_sources(
            FfiConverterTypeEventKind.lower(eventKind), $0
        )
    })
}

public func eventKindAffectsSavedGateways(eventKind: EventKind) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_event_kind_affects_saved_gateways(
            FfiConverterTypeEventKind.lower(eventKind), $0
        )
    })
}

public func eventKindAffectsSecurityStructures(eventKind: EventKind) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_event_kind_affects_security_structures(
            FfiConverterTypeEventKind.lower(eventKind), $0
        )
    })
}

public func eventKindAll() -> [EventKind] {
    return try! FfiConverterSequenceTypeEventKind.lift(try! rustCall {
        uniffi_sargon_fn_func_event_kind_all($0
        )
    })
}

public func exactly12BytesToJsonString(exactly12Bytes: Exactly12Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly12_bytes_to_json_string(
            FfiConverterTypeExactly12Bytes.lower(exactly12Bytes), $0
        )
    })
}

public func exactly29BytesToJsonString(exactly29Bytes: Exactly29Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly29_bytes_to_json_string(
            FfiConverterTypeExactly29Bytes.lower(exactly29Bytes), $0
        )
    })
}

public func exactly32BytesToJsonString(exactly32Bytes: Exactly32Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly32_bytes_to_json_string(
            FfiConverterTypeExactly32Bytes.lower(exactly32Bytes), $0
        )
    })
}

public func exactly33BytesToJsonString(exactly33Bytes: Exactly33Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly33_bytes_to_json_string(
            FfiConverterTypeExactly33Bytes.lower(exactly33Bytes), $0
        )
    })
}

public func exactly60BytesToJsonString(exactly60Bytes: Exactly60Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly60_bytes_to_json_string(
            FfiConverterTypeExactly60Bytes.lower(exactly60Bytes), $0
        )
    })
}

public func exactly64BytesToJsonString(exactly64Bytes: Exactly64Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly64_bytes_to_json_string(
            FfiConverterTypeExactly64Bytes.lower(exactly64Bytes), $0
        )
    })
}

public func exactly65BytesToJsonString(exactly65Bytes: Exactly65Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly65_bytes_to_json_string(
            FfiConverterTypeExactly65Bytes.lower(exactly65Bytes), $0
        )
    })
}

public func exactly12BytesToBytes(bytes: Exactly12Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_12_bytes_to_bytes(
            FfiConverterTypeExactly12Bytes.lower(bytes), $0
        )
    })
}

public func exactly12BytesToHex(bytes: Exactly12Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_12_bytes_to_hex(
            FfiConverterTypeExactly12Bytes.lower(bytes), $0
        )
    })
}

public func exactly29BytesToBytes(bytes: Exactly29Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_29_bytes_to_bytes(
            FfiConverterTypeExactly29Bytes.lower(bytes), $0
        )
    })
}

public func exactly29BytesToHex(bytes: Exactly29Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_29_bytes_to_hex(
            FfiConverterTypeExactly29Bytes.lower(bytes), $0
        )
    })
}

public func exactly32BytesToBytes(bytes: Exactly32Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_32_bytes_to_bytes(
            FfiConverterTypeExactly32Bytes.lower(bytes), $0
        )
    })
}

public func exactly32BytesToHex(bytes: Exactly32Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_32_bytes_to_hex(
            FfiConverterTypeExactly32Bytes.lower(bytes), $0
        )
    })
}

public func exactly33BytesToBytes(bytes: Exactly33Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_33_bytes_to_bytes(
            FfiConverterTypeExactly33Bytes.lower(bytes), $0
        )
    })
}

public func exactly33BytesToHex(bytes: Exactly33Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_33_bytes_to_hex(
            FfiConverterTypeExactly33Bytes.lower(bytes), $0
        )
    })
}

public func exactly60BytesToBytes(bytes: Exactly60Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_60_bytes_to_bytes(
            FfiConverterTypeExactly60Bytes.lower(bytes), $0
        )
    })
}

public func exactly60BytesToHex(bytes: Exactly60Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_60_bytes_to_hex(
            FfiConverterTypeExactly60Bytes.lower(bytes), $0
        )
    })
}

public func exactly64BytesToBytes(bytes: Exactly64Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_64_bytes_to_bytes(
            FfiConverterTypeExactly64Bytes.lower(bytes), $0
        )
    })
}

public func exactly64BytesToHex(bytes: Exactly64Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_64_bytes_to_hex(
            FfiConverterTypeExactly64Bytes.lower(bytes), $0
        )
    })
}

public func exactly65BytesToBytes(bytes: Exactly65Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_65_bytes_to_bytes(
            FfiConverterTypeExactly65Bytes.lower(bytes), $0
        )
    })
}

public func exactly65BytesToHex(bytes: Exactly65Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_exactly_65_bytes_to_hex(
            FfiConverterTypeExactly65Bytes.lower(bytes), $0
        )
    })
}

public func factorSourceCryptoParametersSupportsBabylon(parameters: FactorSourceCryptoParameters) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_crypto_parameters_supports_babylon(
            FfiConverterTypeFactorSourceCryptoParameters.lower(parameters), $0
        )
    })
}

public func factorSourceCryptoParametersSupportsOlympia(parameters: FactorSourceCryptoParameters) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_crypto_parameters_supports_olympia(
            FfiConverterTypeFactorSourceCryptoParameters.lower(parameters), $0
        )
    })
}

public func factorSourceIDFromAddressToJsonBytes(factorSourceIDFromAddress: FactorSourceIdFromAddress) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_i_d_from_address_to_json_bytes(
            FfiConverterTypeFactorSourceIDFromAddress.lower(factorSourceIDFromAddress), $0
        )
    })
}

public func factorSourceIDFromHashToJsonBytes(factorSourceIDFromHash: FactorSourceIdFromHash) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_i_d_from_hash_to_json_bytes(
            FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceIDFromHash), $0
        )
    })
}

public func factorSourceIdFromAddressToString(factorSourceId: FactorSourceIdFromAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_id_from_address_to_string(
            FfiConverterTypeFactorSourceIDFromAddress.lower(factorSourceId), $0
        )
    })
}

public func factorSourceIdFromHashToString(factorSourceId: FactorSourceIdFromHash) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_id_from_hash_to_string(
            FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceId), $0
        )
    })
}

public func factorSourceIdToString(factorSourceId: FactorSourceId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_id_to_string(
            FfiConverterTypeFactorSourceID.lower(factorSourceId), $0
        )
    })
}

public func factorSourceKindToString(kind: FactorSourceKind) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_kind_to_string(
            FfiConverterTypeFactorSourceKind.lower(kind), $0
        )
    })
}

public func factorSourceSupportsBabylon(factorSource: FactorSource) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_supports_babylon(
            FfiConverterTypeFactorSource.lower(factorSource), $0
        )
    })
}

public func factorSourceSupportsOlympia(factorSource: FactorSource) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_supports_olympia(
            FfiConverterTypeFactorSource.lower(factorSource), $0
        )
    })
}

public func factorSourceToString(factorSource: FactorSource) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_source_to_string(
            FfiConverterTypeFactorSource.lower(factorSource), $0
        )
    })
}

public func factorSourcesAllSampleValues() -> [FactorSource] {
    return try! FfiConverterSequenceTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_factor_sources_all_sample_values($0
        )
    })
}

public func ffiUrlGetUrl(ffiUrl: FfiUrl) -> Url {
    return try! FfiConverterTypeUrl.lift(try! rustCall {
        uniffi_sargon_fn_func_ffi_url_get_url(
            FfiConverterTypeFfiUrl.lower(ffiUrl), $0
        )
    })
}

public func fiatCurrencyToJsonString(fiatCurrency: FiatCurrency) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_fiat_currency_to_json_string(
            FfiConverterTypeFiatCurrency.lower(fiatCurrency), $0
        )
    })
}

public func fungibleResourceIndicatorGetAmount(indicator: FungibleResourceIndicator) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_fungible_resource_indicator_get_amount(
            FfiConverterTypeFungibleResourceIndicator.lower(indicator), $0
        )
    })
}

public func gatewayId(gateway: Gateway) -> Url {
    return try! FfiConverterTypeUrl.lift(try! rustCall {
        uniffi_sargon_fn_func_gateway_id(
            FfiConverterTypeGateway.lower(gateway), $0
        )
    })
}

public func gatewayIsWellknown(gateway: Gateway) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_gateway_is_wellknown(
            FfiConverterTypeGateway.lower(gateway), $0
        )
    })
}

public func gatewayMainnet() -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_gateway_mainnet($0
        )
    })
}

public func gatewayStokenet() -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_gateway_stokenet($0
        )
    })
}

public func gatewayToString(gateway: Gateway) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_gateway_to_string(
            FfiConverterTypeGateway.lower(gateway), $0
        )
    })
}

public func gatewayWellknownGateways() -> [Gateway] {
    return try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_gateway_wellknown_gateways($0
        )
    })
}

public func hash(data: BagOfBytes) -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_fn_func_hash(
            FfiConverterTypeBagOfBytes.lower(data), $0
        )
    })
}

public func hashGetBytes(hash: Hash) -> Exactly32Bytes {
    return try! FfiConverterTypeExactly32Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_hash_get_bytes(
            FfiConverterTypeHash.lower(hash), $0
        )
    })
}

public func hdPathComponentGetNonHardenedValue(component: HdPathComponent) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_fn_func_hd_path_component_get_non_hardened_value(
            FfiConverterTypeHDPathComponent.lower(component), $0
        )
    })
}

public func headerToJsonBytes(header: Header) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_header_to_json_bytes(
            FfiConverterTypeHeader.lower(header), $0
        )
    })
}

public func hierarchicalDeterministicPublicKeyIsValidSignatureForHash(key: HierarchicalDeterministicPublicKey, signature: Signature, hash: Hash) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_hierarchical_deterministic_public_key_is_valid_signature_for_hash(
            FfiConverterTypeHierarchicalDeterministicPublicKey.lower(key),
            FfiConverterTypeSignature.lower(signature),
            FfiConverterTypeHash.lower(hash), $0
        )
    })
}

public func hostIdToJsonBytes(hostId: HostId) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_host_id_to_json_bytes(
            FfiConverterTypeHostId.lower(hostId), $0
        )
    })
}

public func hostOsGetName(hostOs: HostOs) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_host_os_get_name(
            FfiConverterTypeHostOS.lower(hostOs), $0
        )
    })
}

public func hostOsGetVendor(hostOs: HostOs) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_host_os_get_vendor(
            FfiConverterTypeHostOS.lower(hostOs), $0
        )
    })
}

public func hostOsGetVersion(hostOs: HostOs) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_host_os_get_version(
            FfiConverterTypeHostOS.lower(hostOs), $0
        )
    })
}

public func identityAddressBech32Address(address: IdentityAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_identity_address_bech32_address(
            FfiConverterTypeIdentityAddress.lower(address), $0
        )
    })
}

public func identityAddressFormatted(address: IdentityAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_identity_address_formatted(
            FfiConverterTypeIdentityAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func identityAddressMapToNetwork(address: IdentityAddress, networkId: NetworkId) -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_identity_address_map_to_network(
            FfiConverterTypeIdentityAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func identityAddressNetworkId(address: IdentityAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_identity_address_network_id(
            FfiConverterTypeIdentityAddress.lower(address), $0
        )
    })
}

public func intentHashFormatted(address: IntentHash, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_intent_hash_formatted(
            FfiConverterTypeIntentHash.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func intentSignatureGetSignatureWithPublicKey(intentSignature: IntentSignature) -> SignatureWithPublicKey {
    return try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_intent_signature_get_signature_with_public_key(
            FfiConverterTypeIntentSignature.lower(intentSignature), $0
        )
    })
}

public func isSafeToShowErrorMessageFromError(error: CommonError) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_is_safe_to_show_error_message_from_error(
            FfiConverterTypeCommonError.lower(error), $0
        )
    })
}

public func ledgerHwWalletModelToString(model: LedgerHardwareWalletModel) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_ledger_hw_wallet_model_to_string(
            FfiConverterTypeLedgerHardwareWalletModel.lower(model), $0
        )
    })
}

public func legacyOlympiaAccountAddressFormatted(address: LegacyOlympiaAccountAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_legacy_olympia_account_address_formatted(
            FfiConverterTypeLegacyOlympiaAccountAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func legacyOlympiaAccountAddressIsLegacyOfBabylon(legacyOlympiaAddress: LegacyOlympiaAccountAddress, babylonAccountAddress: AccountAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_legacy_olympia_account_address_is_legacy_of_babylon(
            FfiConverterTypeLegacyOlympiaAccountAddress.lower(legacyOlympiaAddress),
            FfiConverterTypeAccountAddress.lower(babylonAccountAddress), $0
        )
    })
}

public func legacyOlympiaAccountAddressToBabylonAccountAddress(address: LegacyOlympiaAccountAddress) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_legacy_olympia_account_address_to_babylon_account_address(
            FfiConverterTypeLegacyOlympiaAccountAddress.lower(address), $0
        )
    })
}

public func legacyOlympiaAccountAddressToString(address: LegacyOlympiaAccountAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_legacy_olympia_account_address_to_string(
            FfiConverterTypeLegacyOlympiaAccountAddress.lower(address), $0
        )
    })
}

public func linkConnectionQRDataToJsonBytes(linkConnectionQRData: LinkConnectionQrData) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_link_connection_q_r_data_to_json_bytes(
            FfiConverterTypeLinkConnectionQRData.lower(linkConnectionQRData), $0
        )
    })
}

public func manifestCreateFungibleToken(addressOfOwner: AccountAddress) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_create_fungible_token(
            FfiConverterTypeAccountAddress.lower(addressOfOwner), $0
        )
    })
}

public func manifestCreateFungibleTokenWithMetadata(addressOfOwner: AccountAddress, initialSupply: Decimal192, metadata: TokenDefinitionMetadata) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_create_fungible_token_with_metadata(
            FfiConverterTypeAccountAddress.lower(addressOfOwner),
            FfiConverterTypeDecimal192.lower(initialSupply),
            FfiConverterTypeTokenDefinitionMetadata.lower(metadata), $0
        )
    })
}

/**
 * Creates many fungible tokens, with initial supply, to be owned by `address_of_owner`.
 *
 * # Panics
 * Panics if `address_of_owner` is on `Mainnet`, use a testnet instead.
 * Panics if `count` is zero or is greater than the number of token metadata defined in `sample_resource_definition_metadata` (25)
 */
public func manifestCreateMultipleFungibleTokens(addressOfOwner: AccountAddress, count: UInt8?) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_create_multiple_fungible_tokens(
            FfiConverterTypeAccountAddress.lower(addressOfOwner),
            FfiConverterOptionUInt8.lower(count), $0
        )
    })
}

public func manifestCreateMultipleNonFungibleTokens(addressOfOwner: AccountAddress, collectionCount: UInt8?, nftsPerCollection: UInt8?) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_create_multiple_non_fungible_tokens(
            FfiConverterTypeAccountAddress.lower(addressOfOwner),
            FfiConverterOptionUInt8.lower(collectionCount),
            FfiConverterOptionUInt8.lower(nftsPerCollection), $0
        )
    })
}

public func manifestCreateNonFungibleToken(addressOfOwner: AccountAddress, nftsPerCollection: UInt8?) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_create_non_fungible_token(
            FfiConverterTypeAccountAddress.lower(addressOfOwner),
            FfiConverterOptionUInt8.lower(nftsPerCollection), $0
        )
    })
}

public func manifestForFaucet(includeLockFeeInstruction: Bool, addressOfReceivingAccount: AccountAddress) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_for_faucet(
            FfiConverterBool.lower(includeLockFeeInstruction),
            FfiConverterTypeAccountAddress.lower(addressOfReceivingAccount), $0
        )
    })
}

public func manifestMarkingAccountAsDappDefinitionType(accountAddress: AccountAddress) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_marking_account_as_dapp_definition_type(
            FfiConverterTypeAccountAddress.lower(accountAddress), $0
        )
    })
}

public func manifestPerAssetTransfers(transfers: PerAssetTransfers) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_per_asset_transfers(
            FfiConverterTypePerAssetTransfers.lower(transfers), $0
        )
    })
}

/**
 * Uses `per_asset_transfers` after having transposed the `PerRecipientAssetTransfers`
 * into `PerAssetTransfers`. We always use `PerAssetTransfers` when building the manifest
 * since it is more efficient (allows a single withdraw per resource) => fewer instruction =>
 * cheaper TX fee for user.
 */
public func manifestPerRecipientTransfers(transfers: PerRecipientAssetTransfers) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_per_recipient_transfers(
            FfiConverterTypePerRecipientAssetTransfers.lower(transfers), $0
        )
    })
}

public func manifestSetOwnerKeysHashes(addressOfAccountOrPersona: AddressOfAccountOrPersona, ownerKeyHashes: [PublicKeyHash]) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_set_owner_keys_hashes(
            FfiConverterTypeAddressOfAccountOrPersona.lower(addressOfAccountOrPersona),
            FfiConverterSequenceTypePublicKeyHash.lower(ownerKeyHashes), $0
        )
    })
}

public func manifestStakesClaim(accountAddress: AccountAddress, stakeClaims: [StakeClaim]) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_stakes_claim(
            FfiConverterTypeAccountAddress.lower(accountAddress),
            FfiConverterSequenceTypeStakeClaim.lower(stakeClaims), $0
        )
    })
}

public func manifestThirdPartyDepositUpdate(accountAddress: AccountAddress, from: ThirdPartyDeposits, to: ThirdPartyDeposits) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_manifest_third_party_deposit_update(
            FfiConverterTypeAccountAddress.lower(accountAddress),
            FfiConverterTypeThirdPartyDeposits.lower(from),
            FfiConverterTypeThirdPartyDeposits.lower(to), $0
        )
    })
}

public func messageAsPlaintext(message: Message) -> String? {
    return try! FfiConverterOptionString.lift(try! rustCall {
        uniffi_sargon_fn_func_message_as_plaintext(
            FfiConverterTypeMessage.lower(message), $0
        )
    })
}

/**
 * Returns the words of a mnemonic as a String joined by spaces, e.g. "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong"
 */
public func mnemonicPhrase(from: Mnemonic) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_mnemonic_phrase(
            FfiConverterTypeMnemonic.lower(from), $0
        )
    })
}

public func mnemonicWithPassphraseDerivePublicKeys(mnemonicWithPassphrase: MnemonicWithPassphrase, derivationPaths: [DerivationPath]) -> [HierarchicalDeterministicPublicKey] {
    return try! FfiConverterSequenceTypeHierarchicalDeterministicPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_mnemonic_with_passphrase_derive_public_keys(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterSequenceTypeDerivationPath.lower(derivationPaths), $0
        )
    })
}

public func mnemonicWithPassphraseSign(mnemonicWithPassphrase: MnemonicWithPassphrase, derivationPath: DerivationPath, hashToSign: Hash) -> SignatureWithPublicKey {
    return try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_mnemonic_with_passphrase_sign(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeDerivationPath.lower(derivationPath),
            FfiConverterTypeHash.lower(hashToSign), $0
        )
    })
}

public func mnemonicWithPassphraseToJsonBytes(mnemonicWithPassphrase: MnemonicWithPassphrase) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_mnemonic_with_passphrase_to_json_bytes(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase), $0
        )
    })
}

/**
 * Returns `true` if this MnemonicWithPassphrase successfully validates all `hd_keys`, that is to say,
 * that all the HierarchicalDeterministicPublicKey were indeed crated by this MnemonicWithPassphrase.
 */
public func mnemonicWithPassphraseValidatePublicKeys(mnemonicWithPassphrase: MnemonicWithPassphrase, hdKeys: [HierarchicalDeterministicPublicKey]) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_mnemonic_with_passphrase_validate_public_keys(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterSequenceTypeHierarchicalDeterministicPublicKey.lower(hdKeys), $0
        )
    })
}

/**
 * Modifies `manifest` by inserting transaction "guarantees", which is the wallet
 * term for `assert_worktop_contains`.
 */
public func modifyManifestAddGuarantees(manifest: TransactionManifest, guarantees: [TransactionGuarantee]) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_modify_manifest_add_guarantees(
            FfiConverterTypeTransactionManifest.lower(manifest),
            FfiConverterSequenceTypeTransactionGuarantee.lower(guarantees), $0
        )
    })
}

public func modifyManifestLockFee(manifest: TransactionManifest, addressOfFeePayer: AccountAddress, fee: Decimal192?) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_modify_manifest_lock_fee(
            FfiConverterTypeTransactionManifest.lower(manifest),
            FfiConverterTypeAccountAddress.lower(addressOfFeePayer),
            FfiConverterOptionTypeDecimal192.lower(fee), $0
        )
    })
}

public func networkIdDiscriminant(id: NetworkId) -> UInt8 {
    return try! FfiConverterUInt8.lift(try! rustCall {
        uniffi_sargon_fn_func_network_id_discriminant(
            FfiConverterTypeNetworkID.lower(id), $0
        )
    })
}

public func networkIdToString(id: NetworkId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_network_id_to_string(
            FfiConverterTypeNetworkID.lower(id), $0
        )
    })
}

public func networkIdsAll() -> [NetworkId] {
    return try! FfiConverterSequenceTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_network_ids_all($0
        )
    })
}

public func networkMethodToString(method: NetworkMethod) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_network_method_to_string(
            FfiConverterTypeNetworkMethod.lower(method), $0
        )
    })
}

public func newAccessControllerAddress(bech32: String) throws -> AccessControllerAddress {
    return try FfiConverterTypeAccessControllerAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_access_controller_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newAccessControllerAddressRandom(networkId: NetworkId) -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_access_controller_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newAccessControllerAddressSampleMainnet() -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_access_controller_address_sample_mainnet($0
        )
    })
}

public func newAccessControllerAddressSampleMainnetOther() -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_access_controller_address_sample_mainnet_other($0
        )
    })
}

public func newAccessControllerAddressSampleStokenet() -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_access_controller_address_sample_stokenet($0
        )
    })
}

public func newAccessControllerAddressSampleStokenetOther() -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_access_controller_address_sample_stokenet_other($0
        )
    })
}

public func newAccountAddress(bech32: String) throws -> AccountAddress {
    return try FfiConverterTypeAccountAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_account_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

public func newAccountAddressFrom(publicKey: PublicKey, networkId: NetworkId) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_address_from(
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newAccountAddressRandom(networkId: NetworkId) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newAccountAddressSampleMainnet() -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_address_sample_mainnet($0
        )
    })
}

public func newAccountAddressSampleMainnetOther() -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_address_sample_mainnet_other($0
        )
    })
}

public func newAccountAddressSampleStokenet() -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_address_sample_stokenet($0
        )
    })
}

public func newAccountAddressSampleStokenetOther() -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_address_sample_stokenet_other($0
        )
    })
}

public func newAccountForDisplayFromAccount(account: Account) -> AccountForDisplay {
    return try! FfiConverterTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_for_display_from_account(
            FfiConverterTypeAccount.lower(account), $0
        )
    })
}

public func newAccountForDisplaySample() -> AccountForDisplay {
    return try! FfiConverterTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_for_display_sample($0
        )
    })
}

public func newAccountForDisplaySampleOther() -> AccountForDisplay {
    return try! FfiConverterTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_for_display_sample_other($0
        )
    })
}

public func newAccountOrAddressOfSample() -> AccountOrAddressOf {
    return try! FfiConverterTypeAccountOrAddressOf.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_address_of_sample($0
        )
    })
}

public func newAccountOrAddressOfSampleOther() -> AccountOrAddressOf {
    return try! FfiConverterTypeAccountOrAddressOf.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_address_of_sample_other($0
        )
    })
}

public func newAccountOrPersonaSampleMainnet() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_persona_sample_mainnet($0
        )
    })
}

public func newAccountOrPersonaSampleMainnetOther() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_persona_sample_mainnet_other($0
        )
    })
}

public func newAccountOrPersonaSampleMainnetThird() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_persona_sample_mainnet_third($0
        )
    })
}

public func newAccountOrPersonaSampleStokenet() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_persona_sample_stokenet($0
        )
    })
}

public func newAccountOrPersonaSampleStokenetOther() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_persona_sample_stokenet_other($0
        )
    })
}

public func newAccountOrPersonaSampleStokenetThird() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_or_persona_sample_stokenet_third($0
        )
    })
}

public func newAccountPath(networkId: NetworkId, keyKind: Cap26KeyKind, index: UInt32) -> AccountPath {
    return try! FfiConverterTypeAccountPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_path(
            FfiConverterTypeNetworkID.lower(networkId),
            FfiConverterTypeCAP26KeyKind.lower(keyKind),
            FfiConverterUInt32.lower(index), $0
        )
    })
}

public func newAccountPathSample() -> AccountPath {
    return try! FfiConverterTypeAccountPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_path_sample($0
        )
    })
}

public func newAccountPathSampleOther() -> AccountPath {
    return try! FfiConverterTypeAccountPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_path_sample_other($0
        )
    })
}

public func newAccountSampleMainnetAlice() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_mainnet_alice($0
        )
    })
}

public func newAccountSampleMainnetBob() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_mainnet_bob($0
        )
    })
}

public func newAccountSampleMainnetCarol() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_mainnet_carol($0
        )
    })
}

public func newAccountSampleMainnetDiana() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_mainnet_diana($0
        )
    })
}

public func newAccountSampleStokenetNadia() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_stokenet_nadia($0
        )
    })
}

public func newAccountSampleStokenetOlivia() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_stokenet_olivia($0
        )
    })
}

public func newAccountSampleStokenetPaige() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_account_sample_stokenet_paige($0
        )
    })
}

public func newAccountsForDisplaySample() -> [AccountForDisplay] {
    return try! FfiConverterSequenceTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_fn_func_new_accounts_for_display_sample($0
        )
    })
}

public func newAccountsForDisplaySampleOther() -> [AccountForDisplay] {
    return try! FfiConverterSequenceTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_fn_func_new_accounts_for_display_sample_other($0
        )
    })
}

public func newAccountsOrPersonasSample() -> [AccountOrPersona] {
    return try! FfiConverterSequenceTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_accounts_or_personas_sample($0
        )
    })
}

public func newAccountsOrPersonasSampleOther() -> [AccountOrPersona] {
    return try! FfiConverterSequenceTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_accounts_or_personas_sample_other($0
        )
    })
}

public func newAccountsSample() -> [Account] {
    return try! FfiConverterSequenceTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_accounts_sample($0
        )
    })
}

public func newAccountsSampleOther() -> [Account] {
    return try! FfiConverterSequenceTypeAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_accounts_sample_other($0
        )
    })
}

public func newAddressFromBech32(string: String) throws -> Address {
    return try FfiConverterTypeAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_address_from_bech32(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newAddressOfAccountOrPersonaFromBech32(string: String) throws -> AddressOfAccountOrPersona {
    return try FfiConverterTypeAddressOfAccountOrPersona.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_from_bech32(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleAccountMainnet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_account_mainnet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleAccountMainnetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_account_mainnet_other($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleAccountStokenet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_account_stokenet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleAccountStokenetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_account_stokenet_other($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleIdentityMainnet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_identity_mainnet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleIdentityMainnetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_identity_mainnet_other($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleIdentityStokenet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_identity_stokenet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleIdentityStokenetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_identity_stokenet_other($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleMainnet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_mainnet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleMainnetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_mainnet_other($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleStokenet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_stokenet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleStokenetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_of_account_or_persona_sample_stokenet_other($0
        )
    })
}

public func newAddressSampleAccessControllerMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_access_controller_mainnet($0
        )
    })
}

public func newAddressSampleAccessControllerMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_access_controller_mainnet_other($0
        )
    })
}

public func newAddressSampleAccessControllerStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_access_controller_stokenet($0
        )
    })
}

public func newAddressSampleAccessControllerStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_access_controller_stokenet_other($0
        )
    })
}

public func newAddressSampleAccountMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_account_mainnet($0
        )
    })
}

public func newAddressSampleAccountMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_account_mainnet_other($0
        )
    })
}

public func newAddressSampleAccountStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_account_stokenet($0
        )
    })
}

public func newAddressSampleAccountStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_account_stokenet_other($0
        )
    })
}

public func newAddressSampleComponentMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_component_mainnet($0
        )
    })
}

public func newAddressSampleComponentMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_component_mainnet_other($0
        )
    })
}

public func newAddressSampleComponentStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_component_stokenet($0
        )
    })
}

public func newAddressSampleComponentStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_component_stokenet_other($0
        )
    })
}

public func newAddressSampleIdentityMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_identity_mainnet($0
        )
    })
}

public func newAddressSampleIdentityMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_identity_mainnet_other($0
        )
    })
}

public func newAddressSampleIdentityStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_identity_stokenet($0
        )
    })
}

public func newAddressSampleIdentityStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_identity_stokenet_other($0
        )
    })
}

public func newAddressSampleMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_mainnet($0
        )
    })
}

public func newAddressSampleMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_mainnet_other($0
        )
    })
}

public func newAddressSamplePackageMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_package_mainnet($0
        )
    })
}

public func newAddressSamplePackageMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_package_mainnet_other($0
        )
    })
}

public func newAddressSamplePackageStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_package_stokenet($0
        )
    })
}

public func newAddressSamplePackageStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_package_stokenet_other($0
        )
    })
}

public func newAddressSamplePoolMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_pool_mainnet($0
        )
    })
}

public func newAddressSamplePoolMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_pool_mainnet_other($0
        )
    })
}

public func newAddressSamplePoolStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_pool_stokenet($0
        )
    })
}

public func newAddressSamplePoolStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_pool_stokenet_other($0
        )
    })
}

public func newAddressSampleResourceMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_resource_mainnet($0
        )
    })
}

public func newAddressSampleResourceMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_resource_mainnet_other($0
        )
    })
}

public func newAddressSampleResourceStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_resource_stokenet($0
        )
    })
}

public func newAddressSampleResourceStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_resource_stokenet_other($0
        )
    })
}

public func newAddressSampleStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_stokenet($0
        )
    })
}

public func newAddressSampleStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_stokenet_other($0
        )
    })
}

public func newAddressSampleValidatorMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_validator_mainnet($0
        )
    })
}

public func newAddressSampleValidatorMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_validator_mainnet_other($0
        )
    })
}

public func newAddressSampleValidatorStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_validator_stokenet($0
        )
    })
}

public func newAddressSampleValidatorStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_validator_stokenet_other($0
        )
    })
}

public func newAddressSampleVaultMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_vault_mainnet($0
        )
    })
}

public func newAddressSampleVaultMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_vault_mainnet_other($0
        )
    })
}

public func newAddressSampleVaultStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_vault_stokenet($0
        )
    })
}

public func newAddressSampleVaultStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_address_sample_vault_stokenet_other($0
        )
    })
}

public func newAppPreferencesDefault() -> AppPreferences {
    return try! FfiConverterTypeAppPreferences.lift(try! rustCall {
        uniffi_sargon_fn_func_new_app_preferences_default($0
        )
    })
}

public func newAppPreferencesSample() -> AppPreferences {
    return try! FfiConverterTypeAppPreferences.lift(try! rustCall {
        uniffi_sargon_fn_func_new_app_preferences_sample($0
        )
    })
}

public func newAppPreferencesSampleOther() -> AppPreferences {
    return try! FfiConverterTypeAppPreferences.lift(try! rustCall {
        uniffi_sargon_fn_func_new_app_preferences_sample_other($0
        )
    })
}

public func newAppearanceId(validating: UInt8) throws -> AppearanceId {
    return try FfiConverterTypeAppearanceID.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_appearance_id(
            FfiConverterUInt8.lower(validating), $0
        )
    })
}

public func newAppearanceIdFromNumberOfAccountsOnNetwork(count: UInt64) -> AppearanceId {
    return try! FfiConverterTypeAppearanceID.lift(try! rustCall {
        uniffi_sargon_fn_func_new_appearance_id_from_number_of_accounts_on_network(
            FfiConverterUInt64.lower(count), $0
        )
    })
}

public func newAppearanceIdSample() -> AppearanceId {
    return try! FfiConverterTypeAppearanceID.lift(try! rustCall {
        uniffi_sargon_fn_func_new_appearance_id_sample($0
        )
    })
}

public func newAppearanceIdSampleOther() -> AppearanceId {
    return try! FfiConverterTypeAppearanceID.lift(try! rustCall {
        uniffi_sargon_fn_func_new_appearance_id_sample_other($0
        )
    })
}

public func newArculusCardFactorSourceFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: ArculusCardHint) -> ArculusCardFactorSource {
    return try! FfiConverterTypeArculusCardFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_arculus_card_factor_source_from_mnemonic_with_passphrase(
            FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
            FfiConverterTypeArculusCardHint.lower(hint), $0
        )
    })
}

public func newArculusCardFactorSourceSample() -> ArculusCardFactorSource {
    return try! FfiConverterTypeArculusCardFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_arculus_card_factor_source_sample($0
        )
    })
}

public func newArculusCardFactorSourceSampleOther() -> ArculusCardFactorSource {
    return try! FfiConverterTypeArculusCardFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_arculus_card_factor_source_sample_other($0
        )
    })
}

public func newAssetExceptionSample() -> AssetException {
    return try! FfiConverterTypeAssetException.lift(try! rustCall {
        uniffi_sargon_fn_func_new_asset_exception_sample($0
        )
    })
}

public func newAssetExceptionSampleOther() -> AssetException {
    return try! FfiConverterTypeAssetException.lift(try! rustCall {
        uniffi_sargon_fn_func_new_asset_exception_sample_other($0
        )
    })
}

public func newAssetsExceptionListSample() -> [AssetException] {
    return try! FfiConverterSequenceTypeAssetException.lift(try! rustCall {
        uniffi_sargon_fn_func_new_assets_exception_list_sample($0
        )
    })
}

public func newAssetsExceptionListSampleOther() -> [AssetException] {
    return try! FfiConverterSequenceTypeAssetException.lift(try! rustCall {
        uniffi_sargon_fn_func_new_assets_exception_list_sample_other($0
        )
    })
}

public func newAuthorizedDappDetailedSample() -> AuthorizedDappDetailed {
    return try! FfiConverterTypeAuthorizedDappDetailed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapp_detailed_sample($0
        )
    })
}

public func newAuthorizedDappDetailedSampleOther() -> AuthorizedDappDetailed {
    return try! FfiConverterTypeAuthorizedDappDetailed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapp_detailed_sample_other($0
        )
    })
}

public func newAuthorizedDappFromJsonBytes(jsonBytes: BagOfBytes) throws -> AuthorizedDapp {
    return try FfiConverterTypeAuthorizedDapp.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_authorized_dapp_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newAuthorizedDappSampleMainnetDashboard() -> AuthorizedDapp {
    return try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapp_sample_mainnet_dashboard($0
        )
    })
}

public func newAuthorizedDappSampleMainnetGumballclub() -> AuthorizedDapp {
    return try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapp_sample_mainnet_gumballclub($0
        )
    })
}

public func newAuthorizedDappSampleStokenetDevconsole() -> AuthorizedDapp {
    return try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapp_sample_stokenet_devconsole($0
        )
    })
}

public func newAuthorizedDappSampleStokenetSandbox() -> AuthorizedDapp {
    return try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapp_sample_stokenet_sandbox($0
        )
    })
}

public func newAuthorizedDappsSample() -> [AuthorizedDapp] {
    return try! FfiConverterSequenceTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapps_sample($0
        )
    })
}

public func newAuthorizedDappsSampleOther() -> [AuthorizedDapp] {
    return try! FfiConverterSequenceTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_dapps_sample_other($0
        )
    })
}

public func newAuthorizedPersonaDetailedSample() -> AuthorizedPersonaDetailed {
    return try! FfiConverterTypeAuthorizedPersonaDetailed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_persona_detailed_sample($0
        )
    })
}

public func newAuthorizedPersonaDetailedSampleOther() -> AuthorizedPersonaDetailed {
    return try! FfiConverterTypeAuthorizedPersonaDetailed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_persona_detailed_sample_other($0
        )
    })
}

public func newAuthorizedPersonaSimpleSampleMainnet() -> AuthorizedPersonaSimple {
    return try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_persona_simple_sample_mainnet($0
        )
    })
}

public func newAuthorizedPersonaSimpleSampleMainnetOther() -> AuthorizedPersonaSimple {
    return try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_persona_simple_sample_mainnet_other($0
        )
    })
}

public func newAuthorizedPersonaSimpleSampleStokenet() -> AuthorizedPersonaSimple {
    return try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_persona_simple_sample_stokenet($0
        )
    })
}

public func newAuthorizedPersonaSimpleSampleStokenetOther() -> AuthorizedPersonaSimple {
    return try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_fn_func_new_authorized_persona_simple_sample_stokenet_other($0
        )
    })
}

public func newBIP39SeedFromBytes(bytes: BagOfBytes) throws -> Bip39Seed {
    return try FfiConverterTypeBIP39Seed.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_b_i_p39_seed_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newBIP39SeedSample() -> Bip39Seed {
    return try! FfiConverterTypeBIP39Seed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_b_i_p39_seed_sample($0
        )
    })
}

public func newBIP39SeedSampleOther() -> Bip39Seed {
    return try! FfiConverterTypeBIP39Seed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_b_i_p39_seed_sample_other($0
        )
    })
}

public func newBagOfBytesFrom(bytes: Data) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_from(
            FfiConverterData.lower(bytes), $0
        )
    })
}

public func newBagOfBytesSampleAced() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_sample_aced($0
        )
    })
}

public func newBagOfBytesSampleBabe() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_sample_babe($0
        )
    })
}

public func newBagOfBytesSampleCafe() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_sample_cafe($0
        )
    })
}

public func newBagOfBytesSampleDead() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_sample_dead($0
        )
    })
}

public func newBagOfBytesSampleEcad() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_sample_ecad($0
        )
    })
}

public func newBagOfBytesSampleFade() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bag_of_bytes_sample_fade($0
        )
    })
}

public func newBip39LanguageSample() -> Bip39Language {
    return try! FfiConverterTypeBIP39Language.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip39_language_sample($0
        )
    })
}

public func newBip39LanguageSampleOther() -> Bip39Language {
    return try! FfiConverterTypeBIP39Language.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip39_language_sample_other($0
        )
    })
}

public func newBip39WordSample() -> Bip39Word {
    return try! FfiConverterTypeBIP39Word.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip39_word_sample($0
        )
    })
}

public func newBip39WordSampleOther() -> Bip39Word {
    return try! FfiConverterTypeBIP39Word.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip39_word_sample_other($0
        )
    })
}

public func newBip44LikePathFromIndex(index: UInt32) -> Bip44LikePath {
    return try! FfiConverterTypeBIP44LikePath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip44_like_path_from_index(
            FfiConverterUInt32.lower(index), $0
        )
    })
}

public func newBip44LikePathFromString(string: String) throws -> Bip44LikePath {
    return try FfiConverterTypeBIP44LikePath.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_bip44_like_path_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newBip44LikePathSample() -> Bip44LikePath {
    return try! FfiConverterTypeBIP44LikePath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip44_like_path_sample($0
        )
    })
}

public func newBip44LikePathSampleOther() -> Bip44LikePath {
    return try! FfiConverterTypeBIP44LikePath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_bip44_like_path_sample_other($0
        )
    })
}

public func newBlobFromBytes(bytes: BagOfBytes) -> Blob {
    return try! FfiConverterTypeBlob.lift(try! rustCall {
        uniffi_sargon_fn_func_new_blob_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newBlobsFromBlobList(blobs: [Blob]) -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_fn_func_new_blobs_from_blob_list(
            FfiConverterSequenceTypeBlob.lower(blobs), $0
        )
    })
}

public func newBlobsSample() -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_fn_func_new_blobs_sample($0
        )
    })
}

public func newBlobsSampleOther() -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_fn_func_new_blobs_sample_other($0
        )
    })
}

public func newCap26PathFromString(string: String) throws -> Cap26Path {
    return try FfiConverterTypeCAP26Path.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_cap26_path_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newCompiledNotarizedIntentSample() -> CompiledNotarizedIntent {
    return try! FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_new_compiled_notarized_intent_sample($0
        )
    })
}

public func newCompiledNotarizedIntentSampleOther() -> CompiledNotarizedIntent {
    return try! FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_new_compiled_notarized_intent_sample_other($0
        )
    })
}

public func newComponentAddress(bech32: String) throws -> ComponentAddress {
    return try FfiConverterTypeComponentAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_component_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newComponentAddressRandom(networkId: NetworkId) -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_component_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Sample to a mainnet ComponentAddress (global)
 */
public func newComponentAddressSampleMainnetGlobal() -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_component_address_sample_mainnet_global($0
        )
    })
}

/**
 * Sample to a mainnet ComponentAddress (internal)
 */
public func newComponentAddressSampleMainnetInternal() -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_component_address_sample_mainnet_internal($0
        )
    })
}

/**
 * Sample to a stokenet ComponentAddress (global)
 */
public func newComponentAddressSampleStokenetGlobal() -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_component_address_sample_stokenet_global($0
        )
    })
}

/**
 * Sample to a stokenet ComponentAddress (internal)
 */
public func newComponentAddressSampleStokenetInternal() -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_component_address_sample_stokenet_internal($0
        )
    })
}

public func newDappToWalletInteractionUnvalidatedFromJsonBytes(jsonBytes: BagOfBytes) throws -> DappToWalletInteractionUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionUnvalidated.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_dapp_to_wallet_interaction_unvalidated_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newDappToWalletInteractionUnvalidatedFromJsonString(jsonStr: String) throws -> DappToWalletInteractionUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionUnvalidated.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_dapp_to_wallet_interaction_unvalidated_from_json_string(
            FfiConverterString.lower(jsonStr), $0
        )
    })
}

public func newDappToWalletInteractionUnvalidatedSample() -> DappToWalletInteractionUnvalidated {
    return try! FfiConverterTypeDappToWalletInteractionUnvalidated.lift(try! rustCall {
        uniffi_sargon_fn_func_new_dapp_to_wallet_interaction_unvalidated_sample($0
        )
    })
}

public func newDappToWalletInteractionUnvalidatedSampleOther() -> DappToWalletInteractionUnvalidated {
    return try! FfiConverterTypeDappToWalletInteractionUnvalidated.lift(try! rustCall {
        uniffi_sargon_fn_func_new_dapp_to_wallet_interaction_unvalidated_sample_other($0
        )
    })
}

/**
 * Creates the Decimal192 `10^exponent`
 */
public func newDecimalExponent(exponent: UInt8) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_new_decimal_exponent(
            FfiConverterUInt8.lower(exponent), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a f32 float. Will
 * fail if the f32 cannot be losslessly represented
 * by the underlying Decimal from Scrypto.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert!(new_decimal_from_f32(208050.17).to_string() == "208050.17");
 *
 * assert!(new_decimal_from_f32(f32::MIN_POSITIVE).to_string() == "0");
 * ```
 */
public func newDecimalFromF32(value: Float) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_new_decimal_from_f32(
            FfiConverterFloat.lower(value), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a f64 float. Will
 * fail if the f64 cannot be losslessly represented
 * by the underlying Decimal from Scrypto.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert!(new_decimal_from_f64(208050.17).is_ok());
 *
 * assert!(new_decimal_from_f64(f64::MIN_POSITIVE).is_ok());
 * ```
 */
public func newDecimalFromF64(value: Double) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_decimal_from_f64(
            FfiConverterDouble.lower(value), $0
        )
    })
}

/**
 * Tries to creates a new `Decimal192` from a formatted String for
 * a specific locale.
 */
public func newDecimalFromFormattedString(formattedString: String, locale: LocaleConfig) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_decimal_from_formatted_string(
            FfiConverterString.lower(formattedString),
            FfiConverterTypeLocaleConfig.lower(locale), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a i32 integer.
 */
public func newDecimalFromI32(value: Int32) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_new_decimal_from_i32(
            FfiConverterInt32.lower(value), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a i64 integer.
 */
public func newDecimalFromI64(value: Int64) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_new_decimal_from_i64(
            FfiConverterInt64.lower(value), $0
        )
    })
}

/**
 * Tries to creates a new `Decimal192` from a String, throws a `CommonError`
 * if the `string` was not a valid Decimal192.
 */
public func newDecimalFromString(string: String) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_decimal_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a u32 integer.
 */
public func newDecimalFromU32(value: UInt32) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_new_decimal_from_u32(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a u64 integer.
 */
public func newDecimalFromU64(value: UInt64) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_new_decimal_from_u64(
            FfiConverterUInt64.lower(value), $0
        )
    })
}

public func newDependencyInformationSample() -> DependencyInformation {
    return try! FfiConverterTypeDependencyInformation.lift(try! rustCall {
        uniffi_sargon_fn_func_new_dependency_information_sample($0
        )
    })
}

public func newDependencyInformationSampleOther() -> DependencyInformation {
    return try! FfiConverterTypeDependencyInformation.lift(try! rustCall {
        uniffi_sargon_fn_func_new_dependency_information_sample_other($0
        )
    })
}

public func newDepositRuleFromJsonString(jsonString: String) throws -> DepositRule {
    return try FfiConverterTypeDepositRule.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_deposit_rule_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newDepositRuleSample() -> DepositRule {
    return try! FfiConverterTypeDepositRule.lift(try! rustCall {
        uniffi_sargon_fn_func_new_deposit_rule_sample($0
        )
    })
}

public func newDepositRuleSampleOther() -> DepositRule {
    return try! FfiConverterTypeDepositRule.lift(try! rustCall {
        uniffi_sargon_fn_func_new_deposit_rule_sample_other($0
        )
    })
}

public func newDepositorsAllowListSample() -> [ResourceOrNonFungible] {
    return try! FfiConverterSequenceTypeResourceOrNonFungible.lift(try! rustCall {
        uniffi_sargon_fn_func_new_depositors_allow_list_sample($0
        )
    })
}

public func newDepositorsAllowListSampleOther() -> [ResourceOrNonFungible] {
    return try! FfiConverterSequenceTypeResourceOrNonFungible.lift(try! rustCall {
        uniffi_sargon_fn_func_new_depositors_allow_list_sample_other($0
        )
    })
}

public func newDerivationPathFromString(string: String) throws -> DerivationPath {
    return try FfiConverterTypeDerivationPath.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_derivation_path_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newDerivationPathSample() -> DerivationPath {
    return try! FfiConverterTypeDerivationPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_derivation_path_sample($0
        )
    })
}

public func newDerivationPathSampleOther() -> DerivationPath {
    return try! FfiConverterTypeDerivationPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_derivation_path_sample_other($0
        )
    })
}

public func newDetailedAuthorizedPersonasSample() -> [AuthorizedPersonaDetailed] {
    return try! FfiConverterSequenceTypeAuthorizedPersonaDetailed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_detailed_authorized_personas_sample($0
        )
    })
}

public func newDetailedAuthorizedPersonasSampleOther() -> [AuthorizedPersonaDetailed] {
    return try! FfiConverterSequenceTypeAuthorizedPersonaDetailed.lift(try! rustCall {
        uniffi_sargon_fn_func_new_detailed_authorized_personas_sample_other($0
        )
    })
}

public func newDeviceFactorSourceBabylon(isMain: Bool, mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> DeviceFactorSource {
    return try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_factor_source_babylon(
            FfiConverterBool.lower(isMain),
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newDeviceFactorSourceOlympia(mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> DeviceFactorSource {
    return try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_factor_source_olympia(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newDeviceFactorSourceSample() -> DeviceFactorSource {
    return try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_factor_source_sample($0
        )
    })
}

public func newDeviceFactorSourceSampleOther() -> DeviceFactorSource {
    return try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_factor_source_sample_other($0
        )
    })
}

public func newDeviceInfoDescriptionSample() -> DeviceInfoDescription {
    return try! FfiConverterTypeDeviceInfoDescription.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_info_description_sample($0
        )
    })
}

public func newDeviceInfoDescriptionSampleOther() -> DeviceInfoDescription {
    return try! FfiConverterTypeDeviceInfoDescription.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_info_description_sample_other($0
        )
    })
}

public func newDeviceInfoFromHostInfo(hostId: HostId, hostInfo: HostInfo) -> DeviceInfo {
    return try! FfiConverterTypeDeviceInfo.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_info_from_host_info(
            FfiConverterTypeHostId.lower(hostId),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newDeviceInfoFromJsonBytes(jsonBytes: BagOfBytes) throws -> DeviceInfo {
    return try FfiConverterTypeDeviceInfo.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_device_info_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newDeviceInfoSample() -> DeviceInfo {
    return try! FfiConverterTypeDeviceInfo.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_info_sample($0
        )
    })
}

public func newDeviceInfoSampleOther() -> DeviceInfo {
    return try! FfiConverterTypeDeviceInfo.lift(try! rustCall {
        uniffi_sargon_fn_func_new_device_info_sample_other($0
        )
    })
}

public func newDisplayName(name: String) throws -> DisplayName {
    return try FfiConverterTypeDisplayName.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_display_name(
            FfiConverterString.lower(name), $0
        )
    })
}

public func newDisplayNameFromJsonString(jsonString: String) throws -> DisplayName {
    return try FfiConverterTypeDisplayName.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_display_name_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newDisplayNameSample() -> DisplayName {
    return try! FfiConverterTypeDisplayName.lift(try! rustCall {
        uniffi_sargon_fn_func_new_display_name_sample($0
        )
    })
}

public func newDisplayNameSampleOther() -> DisplayName {
    return try! FfiConverterTypeDisplayName.lift(try! rustCall {
        uniffi_sargon_fn_func_new_display_name_sample_other($0
        )
    })
}

public func newEd25519PublicKeyFromBytes(bytes: BagOfBytes) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_ed25519_public_key_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEd25519PublicKeyFromHex(hex: String) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_ed25519_public_key_from_hex(
            FfiConverterString.lower(hex), $0
        )
    })
}

public func newEd25519PublicKeyFromJsonString(jsonString: String) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_ed25519_public_key_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newEd25519PublicKeySample() -> Ed25519PublicKey {
    return try! FfiConverterTypeEd25519PublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ed25519_public_key_sample($0
        )
    })
}

public func newEd25519PublicKeySampleOther() -> Ed25519PublicKey {
    return try! FfiConverterTypeEd25519PublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ed25519_public_key_sample_other($0
        )
    })
}

public func newEd25519SignatureFromBytes(bytes: BagOfBytes) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_ed25519_signature_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEd25519SignatureFromExactly64Bytes(bytes: Exactly64Bytes) -> Ed25519Signature {
    return try! FfiConverterTypeEd25519Signature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ed25519_signature_from_exactly_64_bytes(
            FfiConverterTypeExactly64Bytes.lower(bytes), $0
        )
    })
}

public func newEd25519SignatureFromJsonString(jsonString: String) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_ed25519_signature_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newEd25519SignatureSample() -> Ed25519Signature {
    return try! FfiConverterTypeEd25519Signature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ed25519_signature_sample($0
        )
    })
}

public func newEd25519SignatureSampleOther() -> Ed25519Signature {
    return try! FfiConverterTypeEd25519Signature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ed25519_signature_sample_other($0
        )
    })
}

public func newEmailAddressSample() -> EmailAddress {
    return try! FfiConverterTypeEmailAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_email_address_sample($0
        )
    })
}

public func newEmailAddressSampleOther() -> EmailAddress {
    return try! FfiConverterTypeEmailAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_email_address_sample_other($0
        )
    })
}

public func newEntityFlagSample() -> EntityFlag {
    return try! FfiConverterTypeEntityFlag.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entity_flag_sample($0
        )
    })
}

public func newEntityFlagSampleOther() -> EntityFlag {
    return try! FfiConverterTypeEntityFlag.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entity_flag_sample_other($0
        )
    })
}

public func newEntityFlagsSample() -> [EntityFlag] {
    return try! FfiConverterSequenceTypeEntityFlag.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entity_flags_sample($0
        )
    })
}

public func newEntityFlagsSampleOther() -> [EntityFlag] {
    return try! FfiConverterSequenceTypeEntityFlag.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entity_flags_sample_other($0
        )
    })
}

public func newEntitySecurityStateSample() -> EntitySecurityState {
    return try! FfiConverterTypeEntitySecurityState.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entity_security_state_sample($0
        )
    })
}

public func newEntitySecurityStateSampleOther() -> EntitySecurityState {
    return try! FfiConverterTypeEntitySecurityState.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entity_security_state_sample_other($0
        )
    })
}

public func newEntropy16BytesFromBytes(bytes: BagOfBytes) throws -> Entropy16Bytes {
    return try FfiConverterTypeEntropy16Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_entropy16_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy16BytesSample() -> Entropy16Bytes {
    return try! FfiConverterTypeEntropy16Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy16_bytes_sample($0
        )
    })
}

public func newEntropy16BytesSampleOther() -> Entropy16Bytes {
    return try! FfiConverterTypeEntropy16Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy16_bytes_sample_other($0
        )
    })
}

public func newEntropy20BytesFromBytes(bytes: BagOfBytes) throws -> Entropy20Bytes {
    return try FfiConverterTypeEntropy20Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_entropy20_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy20BytesSample() -> Entropy20Bytes {
    return try! FfiConverterTypeEntropy20Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy20_bytes_sample($0
        )
    })
}

public func newEntropy20BytesSampleOther() -> Entropy20Bytes {
    return try! FfiConverterTypeEntropy20Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy20_bytes_sample_other($0
        )
    })
}

public func newEntropy24BytesFromBytes(bytes: BagOfBytes) throws -> Entropy24Bytes {
    return try FfiConverterTypeEntropy24Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_entropy24_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy24BytesSample() -> Entropy24Bytes {
    return try! FfiConverterTypeEntropy24Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy24_bytes_sample($0
        )
    })
}

public func newEntropy24BytesSampleOther() -> Entropy24Bytes {
    return try! FfiConverterTypeEntropy24Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy24_bytes_sample_other($0
        )
    })
}

public func newEntropy28BytesFromBytes(bytes: BagOfBytes) throws -> Entropy28Bytes {
    return try FfiConverterTypeEntropy28Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_entropy28_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy28BytesSample() -> Entropy28Bytes {
    return try! FfiConverterTypeEntropy28Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy28_bytes_sample($0
        )
    })
}

public func newEntropy28BytesSampleOther() -> Entropy28Bytes {
    return try! FfiConverterTypeEntropy28Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy28_bytes_sample_other($0
        )
    })
}

public func newEntropy32BytesFromBytes(bytes: BagOfBytes) throws -> Entropy32Bytes {
    return try FfiConverterTypeEntropy32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_entropy32_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy32BytesSample() -> Entropy32Bytes {
    return try! FfiConverterTypeEntropy32Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy32_bytes_sample($0
        )
    })
}

public func newEntropy32BytesSampleOther() -> Entropy32Bytes {
    return try! FfiConverterTypeEntropy32Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_entropy32_bytes_sample_other($0
        )
    })
}

public func newExactly12BytesFromJsonString(jsonString: String) throws -> Exactly12Bytes {
    return try FfiConverterTypeExactly12Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly12_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly29BytesFromJsonString(jsonString: String) throws -> Exactly29Bytes {
    return try FfiConverterTypeExactly29Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly29_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly32BytesFromJsonString(jsonString: String) throws -> Exactly32Bytes {
    return try FfiConverterTypeExactly32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly32_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly33BytesFromJsonString(jsonString: String) throws -> Exactly33Bytes {
    return try FfiConverterTypeExactly33Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly33_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly60BytesFromJsonString(jsonString: String) throws -> Exactly60Bytes {
    return try FfiConverterTypeExactly60Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly60_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly64BytesFromJsonString(jsonString: String) throws -> Exactly64Bytes {
    return try FfiConverterTypeExactly64Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly64_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly65BytesFromJsonString(jsonString: String) throws -> Exactly65Bytes {
    return try FfiConverterTypeExactly65Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly65_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly12Bytes(bytes: BagOfBytes) throws -> Exactly12Bytes {
    return try FfiConverterTypeExactly12Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_12_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly12BytesSample() -> Exactly12Bytes {
    return try! FfiConverterTypeExactly12Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_12_bytes_sample($0
        )
    })
}

public func newExactly12BytesSampleOther() -> Exactly12Bytes {
    return try! FfiConverterTypeExactly12Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_12_bytes_sample_other($0
        )
    })
}

public func newExactly29Bytes(bytes: BagOfBytes) throws -> Exactly29Bytes {
    return try FfiConverterTypeExactly29Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_29_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly29BytesSample() -> Exactly29Bytes {
    return try! FfiConverterTypeExactly29Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_29_bytes_sample($0
        )
    })
}

public func newExactly29BytesSampleOther() -> Exactly29Bytes {
    return try! FfiConverterTypeExactly29Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_29_bytes_sample_other($0
        )
    })
}

public func newExactly32Bytes(bytes: BagOfBytes) throws -> Exactly32Bytes {
    return try FfiConverterTypeExactly32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_32_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly32BytesSample() -> Exactly32Bytes {
    return try! FfiConverterTypeExactly32Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_32_bytes_sample($0
        )
    })
}

public func newExactly32BytesSampleOther() -> Exactly32Bytes {
    return try! FfiConverterTypeExactly32Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_32_bytes_sample_other($0
        )
    })
}

public func newExactly33Bytes(bytes: BagOfBytes) throws -> Exactly33Bytes {
    return try FfiConverterTypeExactly33Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_33_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly33BytesSample() -> Exactly33Bytes {
    return try! FfiConverterTypeExactly33Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_33_bytes_sample($0
        )
    })
}

public func newExactly33BytesSampleOther() -> Exactly33Bytes {
    return try! FfiConverterTypeExactly33Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_33_bytes_sample_other($0
        )
    })
}

public func newExactly60Bytes(bytes: BagOfBytes) throws -> Exactly60Bytes {
    return try FfiConverterTypeExactly60Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_60_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly60BytesSample() -> Exactly60Bytes {
    return try! FfiConverterTypeExactly60Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_60_bytes_sample($0
        )
    })
}

public func newExactly60BytesSampleOther() -> Exactly60Bytes {
    return try! FfiConverterTypeExactly60Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_60_bytes_sample_other($0
        )
    })
}

public func newExactly64Bytes(bytes: BagOfBytes) throws -> Exactly64Bytes {
    return try FfiConverterTypeExactly64Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_64_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly64BytesSample() -> Exactly64Bytes {
    return try! FfiConverterTypeExactly64Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_64_bytes_sample($0
        )
    })
}

public func newExactly64BytesSampleOther() -> Exactly64Bytes {
    return try! FfiConverterTypeExactly64Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_64_bytes_sample_other($0
        )
    })
}

public func newExactly65Bytes(bytes: BagOfBytes) throws -> Exactly65Bytes {
    return try FfiConverterTypeExactly65Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_exactly_65_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly65BytesSample() -> Exactly65Bytes {
    return try! FfiConverterTypeExactly65Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_65_bytes_sample($0
        )
    })
}

public func newExactly65BytesSampleOther() -> Exactly65Bytes {
    return try! FfiConverterTypeExactly65Bytes.lift(try! rustCall {
        uniffi_sargon_fn_func_new_exactly_65_bytes_sample_other($0
        )
    })
}

public func newFactorSourceCommonBabylon() -> FactorSourceCommon {
    return try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_common_babylon($0
        )
    })
}

public func newFactorSourceCommonBdfs(isMain: Bool) -> FactorSourceCommon {
    return try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_common_bdfs(
            FfiConverterBool.lower(isMain), $0
        )
    })
}

public func newFactorSourceCommonOlympia() -> FactorSourceCommon {
    return try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_common_olympia($0
        )
    })
}

public func newFactorSourceCommonSample() -> FactorSourceCommon {
    return try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_common_sample($0
        )
    })
}

public func newFactorSourceCommonSampleOther() -> FactorSourceCommon {
    return try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_common_sample_other($0
        )
    })
}

public func newFactorSourceCryptoParametersPresetBabylonOlympiaCompatible() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_crypto_parameters_preset_babylon_olympia_compatible($0
        )
    })
}

public func newFactorSourceCryptoParametersPresetBabylonOnly() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_crypto_parameters_preset_babylon_only($0
        )
    })
}

public func newFactorSourceCryptoParametersPresetOlympiaOnly() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_crypto_parameters_preset_olympia_only($0
        )
    })
}

public func newFactorSourceCryptoParametersSample() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_crypto_parameters_sample($0
        )
    })
}

public func newFactorSourceCryptoParametersSampleOther() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_crypto_parameters_sample_other($0
        )
    })
}

public func newFactorSourceIDFromAddressFromJsonBytes(jsonBytes: BagOfBytes) throws -> FactorSourceIdFromAddress {
    return try FfiConverterTypeFactorSourceIDFromAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_factor_source_i_d_from_address_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newFactorSourceIDFromHashFromJsonBytes(jsonBytes: BagOfBytes) throws -> FactorSourceIdFromHash {
    return try FfiConverterTypeFactorSourceIDFromHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_factor_source_i_d_from_hash_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newFactorSourceIdFromAddressSample() -> FactorSourceIdFromAddress {
    return try! FfiConverterTypeFactorSourceIDFromAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_from_address_sample($0
        )
    })
}

public func newFactorSourceIdFromAddressSampleOther() -> FactorSourceIdFromAddress {
    return try! FfiConverterTypeFactorSourceIDFromAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_from_address_sample_other($0
        )
    })
}

public func newFactorSourceIdFromHashFromMnemonicWithPassphrase(factorSourceKind: FactorSourceKind, mnemonicWithPassphrase: MnemonicWithPassphrase) -> FactorSourceIdFromHash {
    return try! FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_from_hash_from_mnemonic_with_passphrase(
            FfiConverterTypeFactorSourceKind.lower(factorSourceKind),
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase), $0
        )
    })
}

public func newFactorSourceIdFromHashSample() -> FactorSourceIdFromHash {
    return try! FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_from_hash_sample($0
        )
    })
}

public func newFactorSourceIdFromHashSampleOther() -> FactorSourceIdFromHash {
    return try! FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_from_hash_sample_other($0
        )
    })
}

public func newFactorSourceIdSample() -> FactorSourceId {
    return try! FfiConverterTypeFactorSourceID.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_sample($0
        )
    })
}

public func newFactorSourceIdSampleOther() -> FactorSourceId {
    return try! FfiConverterTypeFactorSourceID.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_id_sample_other($0
        )
    })
}

public func newFactorSourceKindFromString(string: String) throws -> FactorSourceKind {
    return try FfiConverterTypeFactorSourceKind.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_factor_source_kind_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newFactorSourceKindSample() -> FactorSourceKind {
    return try! FfiConverterTypeFactorSourceKind.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_kind_sample($0
        )
    })
}

public func newFactorSourceKindSampleOther() -> FactorSourceKind {
    return try! FfiConverterTypeFactorSourceKind.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_kind_sample_other($0
        )
    })
}

public func newFactorSourceSample() -> FactorSource {
    return try! FfiConverterTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_sample($0
        )
    })
}

public func newFactorSourceSampleOther() -> FactorSource {
    return try! FfiConverterTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_source_sample_other($0
        )
    })
}

public func newFactorSourcesSample() -> [FactorSource] {
    return try! FfiConverterSequenceTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_sources_sample($0
        )
    })
}

public func newFactorSourcesSampleOther() -> [FactorSource] {
    return try! FfiConverterSequenceTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_factor_sources_sample_other($0
        )
    })
}

public func newFiatCurrencyFromJsonString(jsonString: String) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_fiat_currency_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newFiatCurrencySample() -> FiatCurrency {
    return try! FfiConverterTypeFiatCurrency.lift(try! rustCall {
        uniffi_sargon_fn_func_new_fiat_currency_sample($0
        )
    })
}

public func newFiatCurrencySampleOther() -> FiatCurrency {
    return try! FfiConverterTypeFiatCurrency.lift(try! rustCall {
        uniffi_sargon_fn_func_new_fiat_currency_sample_other($0
        )
    })
}

public func newFungibleResourceIndicatorSample() -> FungibleResourceIndicator {
    return try! FfiConverterTypeFungibleResourceIndicator.lift(try! rustCall {
        uniffi_sargon_fn_func_new_fungible_resource_indicator_sample($0
        )
    })
}

public func newFungibleResourceIndicatorSampleOther() -> FungibleResourceIndicator {
    return try! FfiConverterTypeFungibleResourceIndicator.lift(try! rustCall {
        uniffi_sargon_fn_func_new_fungible_resource_indicator_sample_other($0
        )
    })
}

public func newGatewayForNetworkId(networkId: NetworkId) -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_new_gateway_for_network_id(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newGatewaySample() -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_new_gateway_sample($0
        )
    })
}

public func newGatewaySampleOther() -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_new_gateway_sample_other($0
        )
    })
}

public func newGatewayWithUrlOnNetwork(url: String, networkId: NetworkId) throws -> Gateway {
    return try FfiConverterTypeGateway.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_gateway_with_url_on_network(
            FfiConverterString.lower(url),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newGatewaysSample() -> [Gateway] {
    return try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_new_gateways_sample($0
        )
    })
}

public func newGatewaysSampleOther() -> [Gateway] {
    return try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_new_gateways_sample_other($0
        )
    })
}

public func newHashFromBytes(bytes: Exactly32Bytes) -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hash_from_bytes(
            FfiConverterTypeExactly32Bytes.lower(bytes), $0
        )
    })
}

public func newHashFromString(string: String) throws -> Hash {
    return try FfiConverterTypeHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_hash_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newHashSample() -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hash_sample($0
        )
    })
}

public func newHashSampleOther() -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hash_sample_other($0
        )
    })
}

public func newHeaderFromJsonBytes(jsonBytes: BagOfBytes) throws -> Header {
    return try FfiConverterTypeHeader.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_header_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newHeaderSample() -> Header {
    return try! FfiConverterTypeHeader.lift(try! rustCall {
        uniffi_sargon_fn_func_new_header_sample($0
        )
    })
}

public func newHeaderSampleOther() -> Header {
    return try! FfiConverterTypeHeader.lift(try! rustCall {
        uniffi_sargon_fn_func_new_header_sample_other($0
        )
    })
}

/**
 * Instantiates a new `Header` with creating and last used on `DeviceInfo` with
 * "Unknown device" as description, and empty content hint
 */
public func newHeaderWithCreatingDevice(creatingDevice: DeviceInfo) -> Header {
    return try! FfiConverterTypeHeader.lift(try! rustCall {
        uniffi_sargon_fn_func_new_header_with_creating_device(
            FfiConverterTypeDeviceInfo.lower(creatingDevice), $0
        )
    })
}

public func newHiddenResourcesSample() -> [ResourceIdentifier] {
    return try! FfiConverterSequenceTypeResourceIdentifier.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hidden_resources_sample($0
        )
    })
}

public func newHiddenResourcesSampleOther() -> [ResourceIdentifier] {
    return try! FfiConverterSequenceTypeResourceIdentifier.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hidden_resources_sample_other($0
        )
    })
}

public func newHierarchicalDeterministicFactorInstanceSample() -> HierarchicalDeterministicFactorInstance {
    return try! FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hierarchical_deterministic_factor_instance_sample($0
        )
    })
}

public func newHierarchicalDeterministicFactorInstanceSampleOther() -> HierarchicalDeterministicFactorInstance {
    return try! FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hierarchical_deterministic_factor_instance_sample_other($0
        )
    })
}

public func newHierarchicalDeterministicPublicKeySample() -> HierarchicalDeterministicPublicKey {
    return try! FfiConverterTypeHierarchicalDeterministicPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hierarchical_deterministic_public_key_sample($0
        )
    })
}

public func newHierarchicalDeterministicPublicKeySampleOther() -> HierarchicalDeterministicPublicKey {
    return try! FfiConverterTypeHierarchicalDeterministicPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_hierarchical_deterministic_public_key_sample_other($0
        )
    })
}

public func newHomeCardsSample() -> [HomeCard] {
    return try! FfiConverterSequenceTypeHomeCard.lift(try! rustCall {
        uniffi_sargon_fn_func_new_home_cards_sample($0
        )
    })
}

public func newHomeCardsSampleOther() -> [HomeCard] {
    return try! FfiConverterSequenceTypeHomeCard.lift(try! rustCall {
        uniffi_sargon_fn_func_new_home_cards_sample_other($0
        )
    })
}

public func newHostIdFromJsonBytes(jsonBytes: BagOfBytes) throws -> HostId {
    return try FfiConverterTypeHostId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_host_id_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newHostIdSample() -> HostId {
    return try! FfiConverterTypeHostId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_host_id_sample($0
        )
    })
}

public func newHostIdSampleOther() -> HostId {
    return try! FfiConverterTypeHostId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_host_id_sample_other($0
        )
    })
}

public func newHostInfoSample() -> HostInfo {
    return try! FfiConverterTypeHostInfo.lift(try! rustCall {
        uniffi_sargon_fn_func_new_host_info_sample($0
        )
    })
}

public func newHostInfoSampleOther() -> HostInfo {
    return try! FfiConverterTypeHostInfo.lift(try! rustCall {
        uniffi_sargon_fn_func_new_host_info_sample_other($0
        )
    })
}

public func newHostOsAndroid(vendor: String, version: String) -> HostOs {
    return try! FfiConverterTypeHostOS.lift(try! rustCall {
        uniffi_sargon_fn_func_new_host_os_android(
            FfiConverterString.lower(vendor),
            FfiConverterString.lower(version), $0
        )
    })
}

public func newHostOsIos(version: String) -> HostOs {
    return try! FfiConverterTypeHostOS.lift(try! rustCall {
        uniffi_sargon_fn_func_new_host_os_ios(
            FfiConverterString.lower(version), $0
        )
    })
}

public func newHostOsOther(name: String, vendor: String, version: String) -> HostOs {
    return try! FfiConverterTypeHostOS.lift(try! rustCall {
        uniffi_sargon_fn_func_new_host_os_other(
            FfiConverterString.lower(name),
            FfiConverterString.lower(vendor),
            FfiConverterString.lower(version), $0
        )
    })
}

public func newHostOsSample() -> HostOs {
    return try! FfiConverterTypeHostOS.lift(try! rustCall {
        uniffi_sargon_fn_func_new_host_os_sample($0
        )
    })
}

public func newHostOsSampleOther() -> HostOs {
    return try! FfiConverterTypeHostOS.lift(try! rustCall {
        uniffi_sargon_fn_func_new_host_os_sample_other($0
        )
    })
}

public func newIdentityAddress(bech32: String) throws -> IdentityAddress {
    return try FfiConverterTypeIdentityAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_identity_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

public func newIdentityAddressFrom(publicKey: PublicKey, networkId: NetworkId) -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_address_from(
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newIdentityAddressRandom(networkId: NetworkId) -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newIdentityAddressSampleMainnet() -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_address_sample_mainnet($0
        )
    })
}

public func newIdentityAddressSampleMainnetOther() -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_address_sample_mainnet_other($0
        )
    })
}

public func newIdentityAddressSampleStokenet() -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_address_sample_stokenet($0
        )
    })
}

public func newIdentityAddressSampleStokenetOther() -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_address_sample_stokenet_other($0
        )
    })
}

public func newIdentityPath(networkId: NetworkId, keyKind: Cap26KeyKind, index: UInt32) -> IdentityPath {
    return try! FfiConverterTypeIdentityPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_path(
            FfiConverterTypeNetworkID.lower(networkId),
            FfiConverterTypeCAP26KeyKind.lower(keyKind),
            FfiConverterUInt32.lower(index), $0
        )
    })
}

public func newIdentityPathSample() -> IdentityPath {
    return try! FfiConverterTypeIdentityPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_path_sample($0
        )
    })
}

public func newIdentityPathSampleOther() -> IdentityPath {
    return try! FfiConverterTypeIdentityPath.lift(try! rustCall {
        uniffi_sargon_fn_func_new_identity_path_sample_other($0
        )
    })
}

public func newIntentHashFromString(string: String) throws -> IntentHash {
    return try FfiConverterTypeIntentHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_intent_hash_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newIntentHashSample() -> IntentHash {
    return try! FfiConverterTypeIntentHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_intent_hash_sample($0
        )
    })
}

public func newIntentHashSampleOther() -> IntentHash {
    return try! FfiConverterTypeIntentHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_intent_hash_sample_other($0
        )
    })
}

public func newIntentSignatureFromSignatureWithPublicKey(signatureWithPublicKey: SignatureWithPublicKey) -> IntentSignature {
    return try! FfiConverterTypeIntentSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_intent_signature_from_signature_with_public_key(
            FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey), $0
        )
    })
}

public func newIntentSignatureSample() -> IntentSignature {
    return try! FfiConverterTypeIntentSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_intent_signature_sample($0
        )
    })
}

public func newIntentSignatureSampleOther() -> IntentSignature {
    return try! FfiConverterTypeIntentSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_intent_signature_sample_other($0
        )
    })
}

public func newLedgerHardwareWalletFactorSourceSample() -> LedgerHardwareWalletFactorSource {
    return try! FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ledger_hardware_wallet_factor_source_sample($0
        )
    })
}

public func newLedgerHardwareWalletFactorSourceSampleOther() -> LedgerHardwareWalletFactorSource {
    return try! FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ledger_hardware_wallet_factor_source_sample_other($0
        )
    })
}

public func newLedgerHardwareWalletFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: LedgerHardwareWalletHint, common: FactorSourceCommon) -> LedgerHardwareWalletFactorSource {
    return try! FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ledger_hardware_wallet_from_mnemonic_with_passphrase(
            FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
            FfiConverterTypeLedgerHardwareWalletHint.lower(hint),
            FfiConverterTypeFactorSourceCommon.lower(common), $0
        )
    })
}

public func newLedgerHwWalletModelFromString(string: String) throws -> LedgerHardwareWalletModel {
    return try FfiConverterTypeLedgerHardwareWalletModel.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_ledger_hw_wallet_model_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newLedgerHwWalletModelSample() -> LedgerHardwareWalletModel {
    return try! FfiConverterTypeLedgerHardwareWalletModel.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ledger_hw_wallet_model_sample($0
        )
    })
}

public func newLedgerHwWalletModelSampleOther() -> LedgerHardwareWalletModel {
    return try! FfiConverterTypeLedgerHardwareWalletModel.lift(try! rustCall {
        uniffi_sargon_fn_func_new_ledger_hw_wallet_model_sample_other($0
        )
    })
}

public func newLegacyOlympiaAccountAddressFromPublicKey(publicKey: Secp256k1PublicKey) -> LegacyOlympiaAccountAddress {
    return try! FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_legacy_olympia_account_address_from_public_key(
            FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
        )
    })
}

public func newLegacyOlympiaAccountAddressFromString(string: String) throws -> LegacyOlympiaAccountAddress {
    return try FfiConverterTypeLegacyOlympiaAccountAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_legacy_olympia_account_address_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newLegacyOlympiaAccountAddressSample() -> LegacyOlympiaAccountAddress {
    return try! FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_legacy_olympia_account_address_sample($0
        )
    })
}

public func newLegacyOlympiaAccountAddressSampleOther() -> LegacyOlympiaAccountAddress {
    return try! FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_legacy_olympia_account_address_sample_other($0
        )
    })
}

public func newLinkConnectionQRDataFromJsonBytes(jsonBytes: BagOfBytes) throws -> LinkConnectionQrData {
    return try FfiConverterTypeLinkConnectionQRData.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_link_connection_q_r_data_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newLinkConnectionQrDataSample() -> LinkConnectionQrData {
    return try! FfiConverterTypeLinkConnectionQRData.lift(try! rustCall {
        uniffi_sargon_fn_func_new_link_connection_qr_data_sample($0
        )
    })
}

public func newLinkConnectionQrDataSampleOther() -> LinkConnectionQrData {
    return try! FfiConverterTypeLinkConnectionQRData.lift(try! rustCall {
        uniffi_sargon_fn_func_new_link_connection_qr_data_sample_other($0
        )
    })
}

public func newMatrixOfFactorSourcesSample() -> MatrixOfFactorSources {
    return try! FfiConverterTypeMatrixOfFactorSources.lift(try! rustCall {
        uniffi_sargon_fn_func_new_matrix_of_factor_sources_sample($0
        )
    })
}

public func newMatrixOfFactorSourcesSampleOther() -> MatrixOfFactorSources {
    return try! FfiConverterTypeMatrixOfFactorSources.lift(try! rustCall {
        uniffi_sargon_fn_func_new_matrix_of_factor_sources_sample_other($0
        )
    })
}

public func newMessagePlaintextSample() -> Message {
    return try! FfiConverterTypeMessage.lift(try! rustCall {
        uniffi_sargon_fn_func_new_message_plaintext_sample($0
        )
    })
}

public func newMessagePlaintextSampleOther() -> Message {
    return try! FfiConverterTypeMessage.lift(try! rustCall {
        uniffi_sargon_fn_func_new_message_plaintext_sample_other($0
        )
    })
}

public func newMessagePlaintextString(string: String) -> Message {
    return try! FfiConverterTypeMessage.lift(try! rustCall {
        uniffi_sargon_fn_func_new_message_plaintext_string(
            FfiConverterString.lower(string), $0
        )
    })
}

/**
 * Returns new mnemonic from a string of words
 */
public func newMnemonicFromPhrase(phrase: String) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_mnemonic_from_phrase(
            FfiConverterString.lower(phrase), $0
        )
    })
}

public func newMnemonicFromPhraseLanguage(phrase: String, language: Bip39Language) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_mnemonic_from_phrase_language(
            FfiConverterString.lower(phrase),
            FfiConverterTypeBIP39Language.lower(language), $0
        )
    })
}

public func newMnemonicFromWords(words: [Bip39Word]) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_mnemonic_from_words(
            FfiConverterSequenceTypeBIP39Word.lower(words), $0
        )
    })
}

public func newMnemonicGenerateWithEntropy(entropy: Bip39Entropy, language: Bip39Language) -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_generate_with_entropy(
            FfiConverterTypeBIP39Entropy.lower(entropy),
            FfiConverterTypeBIP39Language.lower(language), $0
        )
    })
}

public func newMnemonicSample() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample($0
        )
    })
}

public func newMnemonicSampleArculus() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_arculus($0
        )
    })
}

public func newMnemonicSampleArculusOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_arculus_other($0
        )
    })
}

public func newMnemonicSampleDevice() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_device($0
        )
    })
}

public func newMnemonicSampleDevice12Words() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_device_12_words($0
        )
    })
}

public func newMnemonicSampleDevice12WordsOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_device_12_words_other($0
        )
    })
}

public func newMnemonicSampleDeviceOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_device_other($0
        )
    })
}

public func newMnemonicSampleLedger() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_ledger($0
        )
    })
}

public func newMnemonicSampleLedgerOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_ledger_other($0
        )
    })
}

public func newMnemonicSampleOffDevice() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_off_device($0
        )
    })
}

public func newMnemonicSampleOffDeviceOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_off_device_other($0
        )
    })
}

public func newMnemonicSampleOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_other($0
        )
    })
}

public func newMnemonicSampleSecurityQuestions() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_security_questions($0
        )
    })
}

public func newMnemonicSampleSecurityQuestionsOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_sample_security_questions_other($0
        )
    })
}

public func newMnemonicWithPassphraseFromJsonBytes(jsonBytes: BagOfBytes) throws -> MnemonicWithPassphrase {
    return try FfiConverterTypeMnemonicWithPassphrase.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_mnemonic_with_passphrase_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newMnemonicWithPassphraseSample() -> MnemonicWithPassphrase {
    return try! FfiConverterTypeMnemonicWithPassphrase.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_with_passphrase_sample($0
        )
    })
}

public func newMnemonicWithPassphraseSampleOther() -> MnemonicWithPassphrase {
    return try! FfiConverterTypeMnemonicWithPassphrase.lift(try! rustCall {
        uniffi_sargon_fn_func_new_mnemonic_with_passphrase_sample_other($0
        )
    })
}

public func newNetworkDefinitionLookupByName(logicalName: String) throws -> NetworkDefinition {
    return try FfiConverterTypeNetworkDefinition.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_network_definition_lookup_by_name(
            FfiConverterString.lower(logicalName), $0
        )
    })
}

public func newNetworkDefinitionSample() -> NetworkDefinition {
    return try! FfiConverterTypeNetworkDefinition.lift(try! rustCall {
        uniffi_sargon_fn_func_new_network_definition_sample($0
        )
    })
}

public func newNetworkDefinitionSampleOther() -> NetworkDefinition {
    return try! FfiConverterTypeNetworkDefinition.lift(try! rustCall {
        uniffi_sargon_fn_func_new_network_definition_sample_other($0
        )
    })
}

public func newNetworkIdFromDiscriminant(discriminant: UInt8) throws -> NetworkId {
    return try FfiConverterTypeNetworkID.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_network_id_from_discriminant(
            FfiConverterUInt8.lower(discriminant), $0
        )
    })
}

public func newNetworkMethodSample() -> NetworkMethod {
    return try! FfiConverterTypeNetworkMethod.lift(try! rustCall {
        uniffi_sargon_fn_func_new_network_method_sample($0
        )
    })
}

public func newNetworkMethodSampleOther() -> NetworkMethod {
    return try! FfiConverterTypeNetworkMethod.lift(try! rustCall {
        uniffi_sargon_fn_func_new_network_method_sample_other($0
        )
    })
}

public func newNonEmptyMax32Bytes(bagOfBytes: BagOfBytes) throws -> NonEmptyMax32Bytes {
    return try FfiConverterTypeNonEmptyMax32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_empty_max_32_bytes(
            FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
        )
    })
}

public func newNonEmptyMax64Bytes(bagOfBytes: BagOfBytes) throws -> NonEmptyMax64Bytes {
    return try FfiConverterTypeNonEmptyMax64Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_empty_max_64_bytes(
            FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
        )
    })
}

public func newNonFungibleGlobalIdFromString(string: String) throws -> NonFungibleGlobalId {
    return try FfiConverterTypeNonFungibleGlobalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_global_id_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newNonFungibleGlobalIdSample() -> NonFungibleGlobalId {
    return try! FfiConverterTypeNonFungibleGlobalId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_global_id_sample($0
        )
    })
}

public func newNonFungibleGlobalIdSampleOther() -> NonFungibleGlobalId {
    return try! FfiConverterTypeNonFungibleGlobalId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_global_id_sample_other($0
        )
    })
}

public func newNonFungibleLocalIdBytes(bytes: BagOfBytes) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_local_id_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newNonFungibleLocalIdFromString(localId: String) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_local_id_from_string(
            FfiConverterString.lower(localId), $0
        )
    })
}

public func newNonFungibleLocalIdInt(value: UInt64) -> NonFungibleLocalId {
    return try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_local_id_int(
            FfiConverterUInt64.lower(value), $0
        )
    })
}

public func newNonFungibleLocalIdRandom() -> NonFungibleLocalId {
    return try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_local_id_random($0
        )
    })
}

public func newNonFungibleLocalIdRuid(bytes: BagOfBytes) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_local_id_ruid(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newNonFungibleLocalIdSample() -> NonFungibleLocalId {
    return try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_local_id_sample($0
        )
    })
}

public func newNonFungibleLocalIdSampleOther() -> NonFungibleLocalId {
    return try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_local_id_sample_other($0
        )
    })
}

public func newNonFungibleLocalIdString(string: String) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_local_id_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newNonFungibleLocalIdStringFromStr(string: String) throws -> NonFungibleLocalIdString {
    return try FfiConverterTypeNonFungibleLocalIdString.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_local_id_string_from_str(
            FfiConverterString.lower(string), $0
        )
    })
}

/**
 * Tries to bech32 decode the string into a specialized address.
 */
public func newNonFungibleResourceAddress(bech32: String) throws -> NonFungibleResourceAddress {
    return try FfiConverterTypeNonFungibleResourceAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_non_fungible_resource_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newNonFungibleResourceAddressRandom(networkId: NetworkId) -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newNonFungibleResourceAddressSampleMainnet() -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_address_sample_mainnet($0
        )
    })
}

public func newNonFungibleResourceAddressSampleMainnetOther() -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_address_sample_mainnet_other($0
        )
    })
}

public func newNonFungibleResourceAddressSampleStokenet() -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_address_sample_stokenet($0
        )
    })
}

public func newNonFungibleResourceAddressSampleStokenetOther() -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_address_sample_stokenet_other($0
        )
    })
}

public func newNonFungibleResourceIndicatorSample() -> NonFungibleResourceIndicator {
    return try! FfiConverterTypeNonFungibleResourceIndicator.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_indicator_sample($0
        )
    })
}

public func newNonFungibleResourceIndicatorSampleOther() -> NonFungibleResourceIndicator {
    return try! FfiConverterTypeNonFungibleResourceIndicator.lift(try! rustCall {
        uniffi_sargon_fn_func_new_non_fungible_resource_indicator_sample_other($0
        )
    })
}

public func newNonceFromU32(value: UInt32) -> Nonce {
    return try! FfiConverterTypeNonce.lift(try! rustCall {
        uniffi_sargon_fn_func_new_nonce_from_u32(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

public func newNonceRandom() -> Nonce {
    return try! FfiConverterTypeNonce.lift(try! rustCall {
        uniffi_sargon_fn_func_new_nonce_random($0
        )
    })
}

public func newNonceSample() -> Nonce {
    return try! FfiConverterTypeNonce.lift(try! rustCall {
        uniffi_sargon_fn_func_new_nonce_sample($0
        )
    })
}

public func newNonceSampleOther() -> Nonce {
    return try! FfiConverterTypeNonce.lift(try! rustCall {
        uniffi_sargon_fn_func_new_nonce_sample_other($0
        )
    })
}

public func newNotarizedTransactionSample() -> NotarizedTransaction {
    return try! FfiConverterTypeNotarizedTransaction.lift(try! rustCall {
        uniffi_sargon_fn_func_new_notarized_transaction_sample($0
        )
    })
}

public func newNotarizedTransactionSampleOther() -> NotarizedTransaction {
    return try! FfiConverterTypeNotarizedTransaction.lift(try! rustCall {
        uniffi_sargon_fn_func_new_notarized_transaction_sample_other($0
        )
    })
}

public func newNotarySignature(signature: Signature) -> NotarySignature {
    return try! FfiConverterTypeNotarySignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_notary_signature(
            FfiConverterTypeSignature.lower(signature), $0
        )
    })
}

public func newNotarySignatureSample() -> NotarySignature {
    return try! FfiConverterTypeNotarySignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_notary_signature_sample($0
        )
    })
}

public func newNotarySignatureSampleOther() -> NotarySignature {
    return try! FfiConverterTypeNotarySignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_notary_signature_sample_other($0
        )
    })
}

public func newOffDeviceMnemonicFactorSourceFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: OffDeviceMnemonicHint) -> OffDeviceMnemonicFactorSource {
    return try! FfiConverterTypeOffDeviceMnemonicFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_off_device_mnemonic_factor_source_from_mnemonic_with_passphrase(
            FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
            FfiConverterTypeOffDeviceMnemonicHint.lower(hint), $0
        )
    })
}

public func newOffDeviceMnemonicFactorSourceSample() -> OffDeviceMnemonicFactorSource {
    return try! FfiConverterTypeOffDeviceMnemonicFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_off_device_mnemonic_factor_source_sample($0
        )
    })
}

public func newOffDeviceMnemonicFactorSourceSampleOther() -> OffDeviceMnemonicFactorSource {
    return try! FfiConverterTypeOffDeviceMnemonicFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_off_device_mnemonic_factor_source_sample_other($0
        )
    })
}

public func newOnLedgerSettingsDefault() -> OnLedgerSettings {
    return try! FfiConverterTypeOnLedgerSettings.lift(try! rustCall {
        uniffi_sargon_fn_func_new_on_ledger_settings_default($0
        )
    })
}

public func newOnLedgerSettingsSample() -> OnLedgerSettings {
    return try! FfiConverterTypeOnLedgerSettings.lift(try! rustCall {
        uniffi_sargon_fn_func_new_on_ledger_settings_sample($0
        )
    })
}

public func newOnLedgerSettingsSampleOther() -> OnLedgerSettings {
    return try! FfiConverterTypeOnLedgerSettings.lift(try! rustCall {
        uniffi_sargon_fn_func_new_on_ledger_settings_sample_other($0
        )
    })
}

public func newP2PLinkFromJsonBytes(jsonBytes: BagOfBytes) throws -> P2pLink {
    return try FfiConverterTypeP2PLink.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_p2_p_link_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newP2PLinksSample() -> [P2pLink] {
    return try! FfiConverterSequenceTypeP2PLink.lift(try! rustCall {
        uniffi_sargon_fn_func_new_p2_p_links_sample($0
        )
    })
}

public func newP2PLinksSampleOther() -> [P2pLink] {
    return try! FfiConverterSequenceTypeP2PLink.lift(try! rustCall {
        uniffi_sargon_fn_func_new_p2_p_links_sample_other($0
        )
    })
}

public func newP2pLinkSample() -> P2pLink {
    return try! FfiConverterTypeP2PLink.lift(try! rustCall {
        uniffi_sargon_fn_func_new_p2p_link_sample($0
        )
    })
}

public func newP2pLinkSampleOther() -> P2pLink {
    return try! FfiConverterTypeP2PLink.lift(try! rustCall {
        uniffi_sargon_fn_func_new_p2p_link_sample_other($0
        )
    })
}

public func newP2pLinksFromJsonBytes(jsonBytes: BagOfBytes) throws -> [P2pLink] {
    return try FfiConverterSequenceTypeP2PLink.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_p2p_links_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newPackageAddress(bech32: String) throws -> PackageAddress {
    return try FfiConverterTypePackageAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_package_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newPackageAddressRandom(networkId: NetworkId) -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_package_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newPackageAddressSampleMainnet() -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_package_address_sample_mainnet($0
        )
    })
}

public func newPackageAddressSampleMainnetOther() -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_package_address_sample_mainnet_other($0
        )
    })
}

public func newPackageAddressSampleStokenet() -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_package_address_sample_stokenet($0
        )
    })
}

public func newPackageAddressSampleStokenetOther() -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_package_address_sample_stokenet_other($0
        )
    })
}

public func newPerAssetTransfersSample() -> PerAssetTransfers {
    return try! FfiConverterTypePerAssetTransfers.lift(try! rustCall {
        uniffi_sargon_fn_func_new_per_asset_transfers_sample($0
        )
    })
}

public func newPerAssetTransfersSampleOther() -> PerAssetTransfers {
    return try! FfiConverterTypePerAssetTransfers.lift(try! rustCall {
        uniffi_sargon_fn_func_new_per_asset_transfers_sample_other($0
        )
    })
}

public func newPersonaDataEntryEmailAddressFromJsonString(jsonString: String) throws -> EmailAddress {
    return try FfiConverterTypeEmailAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_persona_data_entry_email_address_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newPersonaDataEntryEmailAddressSample() -> EmailAddress {
    return try! FfiConverterTypeEmailAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_entry_email_address_sample($0
        )
    })
}

public func newPersonaDataEntryEmailAddressSampleOther() -> EmailAddress {
    return try! FfiConverterTypeEmailAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_entry_email_address_sample_other($0
        )
    })
}

public func newPersonaDataEntryNameFromJsonBytes(jsonBytes: BagOfBytes) throws -> PersonaDataEntryName {
    return try FfiConverterTypePersonaDataEntryName.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_persona_data_entry_name_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newPersonaDataEntryNameSample() -> PersonaDataEntryName {
    return try! FfiConverterTypePersonaDataEntryName.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_entry_name_sample($0
        )
    })
}

public func newPersonaDataEntryNameSampleOther() -> PersonaDataEntryName {
    return try! FfiConverterTypePersonaDataEntryName.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_entry_name_sample_other($0
        )
    })
}

public func newPersonaDataEntryPhoneNumberFromJsonString(jsonString: String) throws -> PersonaDataEntryPhoneNumber {
    return try FfiConverterTypePersonaDataEntryPhoneNumber.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_persona_data_entry_phone_number_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newPersonaDataEntryPhoneNumberSample() -> PersonaDataEntryPhoneNumber {
    return try! FfiConverterTypePersonaDataEntryPhoneNumber.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_entry_phone_number_sample($0
        )
    })
}

public func newPersonaDataEntryPhoneNumberSampleOther() -> PersonaDataEntryPhoneNumber {
    return try! FfiConverterTypePersonaDataEntryPhoneNumber.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_entry_phone_number_sample_other($0
        )
    })
}

public func newPersonaDataSample() -> PersonaData {
    return try! FfiConverterTypePersonaData.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_sample($0
        )
    })
}

public func newPersonaDataSampleOther() -> PersonaData {
    return try! FfiConverterTypePersonaData.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_data_sample_other($0
        )
    })
}

public func newPersonaSample() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample($0
        )
    })
}

public func newPersonaSampleMainnetBatman() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_mainnet_batman($0
        )
    })
}

public func newPersonaSampleMainnetRipley() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_mainnet_ripley($0
        )
    })
}

public func newPersonaSampleMainnetSatoshi() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_mainnet_satoshi($0
        )
    })
}

public func newPersonaSampleMainnetTuring() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_mainnet_turing($0
        )
    })
}

public func newPersonaSampleOther() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_other($0
        )
    })
}

public func newPersonaSampleStokenetConnor() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_stokenet_connor($0
        )
    })
}

public func newPersonaSampleStokenetHermione() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_stokenet_hermione($0
        )
    })
}

public func newPersonaSampleStokenetLeiaSkywalker() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_persona_sample_stokenet_leia_skywalker($0
        )
    })
}

public func newPersonasSample() -> [Persona] {
    return try! FfiConverterSequenceTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_personas_sample($0
        )
    })
}

public func newPersonasSampleOther() -> [Persona] {
    return try! FfiConverterSequenceTypePersona.lift(try! rustCall {
        uniffi_sargon_fn_func_new_personas_sample_other($0
        )
    })
}

public func newPoolAddress(bech32: String) throws -> PoolAddress {
    return try FfiConverterTypePoolAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_pool_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newPoolAddressRandom(networkId: NetworkId) -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Sample to a mainnet PoolAddress with three resources.
 */
public func newPoolAddressSampleMainnetMulti() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_sample_mainnet_multi($0
        )
    })
}

/**
 * Sample to a mainnet PoolAddress with single resource.
 */
public func newPoolAddressSampleMainnetSingle() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_sample_mainnet_single($0
        )
    })
}

/**
 * Sample to a mainnet PoolAddress with two resources.
 */
public func newPoolAddressSampleMainnetTwo() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_sample_mainnet_two($0
        )
    })
}

/**
 * Sample to a stokenet PoolAddress with three resources.
 */
public func newPoolAddressSampleStokenetMulti() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_sample_stokenet_multi($0
        )
    })
}

/**
 * Sample to a stokenet PoolAddress with single resource.
 */
public func newPoolAddressSampleStokenetSingle() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_sample_stokenet_single($0
        )
    })
}

/**
 * Sample to a stokenet PoolAddress with two resources.
 */
public func newPoolAddressSampleStokenetTwo() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_pool_address_sample_stokenet_two($0
        )
    })
}

public func newPrivateHdFactorSourceBabylon(isMain: Bool, entropy: NonEmptyMax32Bytes, hostInfo: HostInfo) throws -> PrivateHierarchicalDeterministicFactorSource {
    return try FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_private_hd_factor_source_babylon(
            FfiConverterBool.lower(isMain),
            FfiConverterTypeNonEmptyMax32Bytes.lower(entropy),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newPrivateHdFactorSourceBabylonFromMnemonicWithPassphrase(isMain: Bool, mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> PrivateHierarchicalDeterministicFactorSource {
    return try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_private_hd_factor_source_babylon_from_mnemonic_with_passphrase(
            FfiConverterBool.lower(isMain),
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newPrivateHdFactorSourceOlympiaFromMnemonicWithPassphrase(mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> PrivateHierarchicalDeterministicFactorSource {
    return try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_private_hd_factor_source_olympia_from_mnemonic_with_passphrase(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newPrivateHdFactorSourceSample() -> PrivateHierarchicalDeterministicFactorSource {
    return try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_private_hd_factor_source_sample($0
        )
    })
}

public func newPrivateHdFactorSourceSampleOther() -> PrivateHierarchicalDeterministicFactorSource {
    return try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_private_hd_factor_source_sample_other($0
        )
    })
}

/**
 * # Panics
 * Panics if `device_factor_source` is not a main BDFS.
 */
public func newProfile(deviceFactorSource: DeviceFactorSource, hostId: HostId, hostInfo: HostInfo) -> Profile {
    return try! FfiConverterTypeProfile.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile(
            FfiConverterTypeDeviceFactorSource.lower(deviceFactorSource),
            FfiConverterTypeHostId.lower(hostId),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newProfileFileContentsSample() -> ProfileFileContents {
    return try! FfiConverterTypeProfileFileContents.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_file_contents_sample($0
        )
    })
}

public func newProfileFileContentsSampleOther() -> ProfileFileContents {
    return try! FfiConverterTypeProfileFileContents.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_file_contents_sample_other($0
        )
    })
}

public func newProfileFromEncryptionBytes(jsonString: String, decryptionPassword: String) throws -> Profile {
    return try FfiConverterTypeProfile.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_profile_from_encryption_bytes(
            FfiConverterString.lower(jsonString),
            FfiConverterString.lower(decryptionPassword), $0
        )
    })
}

public func newProfileFromJsonString(jsonStr: String) throws -> Profile {
    return try FfiConverterTypeProfile.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_profile_from_json_string(
            FfiConverterString.lower(jsonStr), $0
        )
    })
}

public func newProfileNetworkSample() -> ProfileNetwork {
    return try! FfiConverterTypeProfileNetwork.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_network_sample($0
        )
    })
}

public func newProfileNetworkSampleOther() -> ProfileNetwork {
    return try! FfiConverterTypeProfileNetwork.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_network_sample_other($0
        )
    })
}

public func newProfileNetworksSample() -> [ProfileNetwork] {
    return try! FfiConverterSequenceTypeProfileNetwork.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_networks_sample($0
        )
    })
}

public func newProfileNetworksSampleOther() -> [ProfileNetwork] {
    return try! FfiConverterSequenceTypeProfileNetwork.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_networks_sample_other($0
        )
    })
}

public func newProfileSample() -> Profile {
    return try! FfiConverterTypeProfile.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_sample($0
        )
    })
}

public func newProfileSampleOther() -> Profile {
    return try! FfiConverterTypeProfile.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_sample_other($0
        )
    })
}

public func newProfileWithMnemonic(mnemonic: Mnemonic, hostId: HostId, hostInfo: HostInfo) -> Profile {
    return try! FfiConverterTypeProfile.lift(try! rustCall {
        uniffi_sargon_fn_func_new_profile_with_mnemonic(
            FfiConverterTypeMnemonic.lower(mnemonic),
            FfiConverterTypeHostId.lower(hostId),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

/**
 * Tries to create a PublicKey from the bytes
 */
public func newPublicKeyFromBytes(bagOfBytes: BagOfBytes) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_public_key_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
        )
    })
}

/**
 * Tries to create a PublicKey from the hex string
 */
public func newPublicKeyFromHex(hex: String) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_public_key_from_hex(
            FfiConverterString.lower(hex), $0
        )
    })
}

public func newPublicKeyHashOfKey(publicKey: PublicKey) -> PublicKeyHash {
    return try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_public_key_hash_of_key(
            FfiConverterTypePublicKey.lower(publicKey), $0
        )
    })
}

public func newPublicKeyHashSample() -> PublicKeyHash {
    return try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_public_key_hash_sample($0
        )
    })
}

public func newPublicKeyHashSampleOther() -> PublicKeyHash {
    return try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_public_key_hash_sample_other($0
        )
    })
}

public func newPublicKeySample() -> PublicKey {
    return try! FfiConverterTypePublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_public_key_sample($0
        )
    })
}

public func newPublicKeySampleOther() -> PublicKey {
    return try! FfiConverterTypePublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_public_key_sample_other($0
        )
    })
}

public func newRadixConnectMobileSessionRequestFromJsonBytes(jsonBytes: BagOfBytes) throws -> RadixConnectMobileSessionRequest {
    return try FfiConverterTypeRadixConnectMobileSessionRequest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_radix_connect_mobile_session_request_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newRadixConnectMobileSessionRequestSample() -> RadixConnectMobileSessionRequest {
    return try! FfiConverterTypeRadixConnectMobileSessionRequest.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_mobile_session_request_sample($0
        )
    })
}

public func newRadixConnectMobileSessionRequestSampleOther() -> RadixConnectMobileSessionRequest {
    return try! FfiConverterTypeRadixConnectMobileSessionRequest.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_mobile_session_request_sample_other($0
        )
    })
}

public func newRadixConnectPassword(bytes: Exactly32Bytes) -> RadixConnectPassword {
    return try! FfiConverterTypeRadixConnectPassword.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_password(
            FfiConverterTypeExactly32Bytes.lower(bytes), $0
        )
    })
}

public func newRadixConnectPasswordFromJsonString(jsonString: String) throws -> RadixConnectPassword {
    return try FfiConverterTypeRadixConnectPassword.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_radix_connect_password_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newRadixConnectPasswordSample() -> RadixConnectPassword {
    return try! FfiConverterTypeRadixConnectPassword.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_password_sample($0
        )
    })
}

public func newRadixConnectPasswordSampleOther() -> RadixConnectPassword {
    return try! FfiConverterTypeRadixConnectPassword.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_password_sample_other($0
        )
    })
}

public func newRadixConnectPurposeFromJsonString(jsonString: String) throws -> RadixConnectPurpose {
    return try FfiConverterTypeRadixConnectPurpose.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_radix_connect_purpose_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newRadixConnectPurposeFromString(string: String) -> RadixConnectPurpose {
    return try! FfiConverterTypeRadixConnectPurpose.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_purpose_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newRadixConnectPurposeSample() -> RadixConnectPurpose {
    return try! FfiConverterTypeRadixConnectPurpose.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_purpose_sample($0
        )
    })
}

public func newRadixConnectPurposeSampleOther() -> RadixConnectPurpose {
    return try! FfiConverterTypeRadixConnectPurpose.lift(try! rustCall {
        uniffi_sargon_fn_func_new_radix_connect_purpose_sample_other($0
        )
    })
}

public func newReferencesToAuthorizedPersonasSample() -> [AuthorizedPersonaSimple] {
    return try! FfiConverterSequenceTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_fn_func_new_references_to_authorized_personas_sample($0
        )
    })
}

public func newReferencesToAuthorizedPersonasSampleOther() -> [AuthorizedPersonaSimple] {
    return try! FfiConverterSequenceTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_fn_func_new_references_to_authorized_personas_sample_other($0
        )
    })
}

public func newRequestedQuantityFromJsonBytes(jsonBytes: BagOfBytes) throws -> RequestedQuantity {
    return try FfiConverterTypeRequestedQuantity.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_requested_quantity_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newRequestedQuantitySample() -> RequestedQuantity {
    return try! FfiConverterTypeRequestedQuantity.lift(try! rustCall {
        uniffi_sargon_fn_func_new_requested_quantity_sample($0
        )
    })
}

public func newRequestedQuantitySampleOther() -> RequestedQuantity {
    return try! FfiConverterTypeRequestedQuantity.lift(try! rustCall {
        uniffi_sargon_fn_func_new_requested_quantity_sample_other($0
        )
    })
}

public func newResourceAddress(bech32: String) throws -> ResourceAddress {
    return try FfiConverterTypeResourceAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_resource_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newResourceAddressRandom(networkId: NetworkId) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newResourceAddressSampleMainnetCandy() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_mainnet_candy($0
        )
    })
}

public func newResourceAddressSampleMainnetNftGcMembership() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_mainnet_nft_gc_membership($0
        )
    })
}

public func newResourceAddressSampleMainnetXrd() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_mainnet_xrd($0
        )
    })
}

public func newResourceAddressSampleStokenetCandy() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_stokenet_candy($0
        )
    })
}

public func newResourceAddressSampleStokenetGcTokens() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_stokenet_gc_tokens($0
        )
    })
}

public func newResourceAddressSampleStokenetGum() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_stokenet_gum($0
        )
    })
}

public func newResourceAddressSampleStokenetXrd() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_address_sample_stokenet_xrd($0
        )
    })
}

public func newResourceIndicatorSample() -> ResourceIndicator {
    return try! FfiConverterTypeResourceIndicator.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_indicator_sample($0
        )
    })
}

public func newResourceIndicatorSampleOther() -> ResourceIndicator {
    return try! FfiConverterTypeResourceIndicator.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_indicator_sample_other($0
        )
    })
}

public func newResourceOrNonFungibleSample() -> ResourceOrNonFungible {
    return try! FfiConverterTypeResourceOrNonFungible.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_or_non_fungible_sample($0
        )
    })
}

public func newResourceOrNonFungibleSampleOther() -> ResourceOrNonFungible {
    return try! FfiConverterTypeResourceOrNonFungible.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_or_non_fungible_sample_other($0
        )
    })
}

public func newResourcePreferencesSample() -> [ResourceAppPreference] {
    return try! FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_preferences_sample($0
        )
    })
}

public func newResourcePreferencesSampleOther() -> [ResourceAppPreference] {
    return try! FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_preferences_sample_other($0
        )
    })
}

public func newResourceSpecifierSample() -> ResourceSpecifier {
    return try! FfiConverterTypeResourceSpecifier.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_specifier_sample($0
        )
    })
}

public func newResourceSpecifierSampleOther() -> ResourceSpecifier {
    return try! FfiConverterTypeResourceSpecifier.lift(try! rustCall {
        uniffi_sargon_fn_func_new_resource_specifier_sample_other($0
        )
    })
}

public func newSLIP10CurveFromJsonString(jsonString: String) throws -> Slip10Curve {
    return try FfiConverterTypeSLIP10Curve.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_s_l_i_p10_curve_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newSargonBuildInformationSample() -> SargonBuildInformation {
    return try! FfiConverterTypeSargonBuildInformation.lift(try! rustCall {
        uniffi_sargon_fn_func_new_sargon_build_information_sample($0
        )
    })
}

public func newSargonBuildInformationSampleOther() -> SargonBuildInformation {
    return try! FfiConverterTypeSargonBuildInformation.lift(try! rustCall {
        uniffi_sargon_fn_func_new_sargon_build_information_sample_other($0
        )
    })
}

/**
 * Constructs `Gateways` with `current` set as active Gateway.
 */
public func newSavedGateways(current: Gateway) -> SavedGateways {
    return try! FfiConverterTypeSavedGateways.lift(try! rustCall {
        uniffi_sargon_fn_func_new_saved_gateways(
            FfiConverterTypeGateway.lower(current), $0
        )
    })
}

public func newSavedGatewaysChangingCurrent(to: Gateway, gateways: SavedGateways) throws -> SavedGateways {
    return try FfiConverterTypeSavedGateways.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_saved_gateways_changing_current(
            FfiConverterTypeGateway.lower(to),
            FfiConverterTypeSavedGateways.lower(gateways), $0
        )
    })
}

/**
 * Constructs `Gateways` with default preset values.
 */
public func newSavedGatewaysDefault() -> SavedGateways {
    return try! FfiConverterTypeSavedGateways.lift(try! rustCall {
        uniffi_sargon_fn_func_new_saved_gateways_default($0
        )
    })
}

/**
 * A sample value useful for tests and previews.
 */
public func newSavedGatewaysSample() -> SavedGateways {
    return try! FfiConverterTypeSavedGateways.lift(try! rustCall {
        uniffi_sargon_fn_func_new_saved_gateways_sample($0
        )
    })
}

/**
 * A sample value useful for tests and previews.
 */
public func newSavedGatewaysSampleOther() -> SavedGateways {
    return try! FfiConverterTypeSavedGateways.lift(try! rustCall {
        uniffi_sargon_fn_func_new_saved_gateways_sample_other($0
        )
    })
}

/**
 * Creates a Secp256k1PublicKey from either compressed form (33 bytes) or
 * from uncompressed form (65 bytes).
 */
public func newSecp256k1PublicKeyFromBytes(bytes: BagOfBytes) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_secp256k1_public_key_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newSecp256k1PublicKeyFromHex(hex: String) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_secp256k1_public_key_from_hex(
            FfiConverterString.lower(hex), $0
        )
    })
}

public func newSecp256k1PublicKeySample() -> Secp256k1PublicKey {
    return try! FfiConverterTypeSecp256k1PublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_secp256k1_public_key_sample($0
        )
    })
}

public func newSecp256k1PublicKeySampleOther() -> Secp256k1PublicKey {
    return try! FfiConverterTypeSecp256k1PublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_secp256k1_public_key_sample_other($0
        )
    })
}

public func newSecp256k1SignatureFromBytes(bytes: BagOfBytes) throws -> Secp256k1Signature {
    return try FfiConverterTypeSecp256k1Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_secp256k1_signature_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newSecp256k1SignatureFromExactly65Bytes(bytes: Exactly65Bytes) -> Secp256k1Signature {
    return try! FfiConverterTypeSecp256k1Signature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_secp256k1_signature_from_exactly_65_bytes(
            FfiConverterTypeExactly65Bytes.lower(bytes), $0
        )
    })
}

public func newSecp256k1SignatureSample() -> Secp256k1Signature {
    return try! FfiConverterTypeSecp256k1Signature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_secp256k1_signature_sample($0
        )
    })
}

public func newSecp256k1SignatureSampleOther() -> Secp256k1Signature {
    return try! FfiConverterTypeSecp256k1Signature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_secp256k1_signature_sample_other($0
        )
    })
}

public func newSecurityNOTPRODUCTIONREADYQuestionsAndAnswersSample() -> [SecurityNotProductionReadyQuestionAndAnswer] {
    return try! FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_and_answers_sample($0
        )
    })
}

public func newSecurityNOTPRODUCTIONREADYQuestionsAndAnswersSampleOther() -> [SecurityNotProductionReadyQuestionAndAnswer] {
    return try! FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_and_answers_sample_other($0
        )
    })
}

public func newSecurityNOTPRODUCTIONREADYQuestionsSample() -> [SecurityNotProductionReadyQuestion] {
    return try! FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_sample($0
        )
    })
}

public func newSecurityNOTPRODUCTIONREADYQuestionsSampleOther() -> [SecurityNotProductionReadyQuestion] {
    return try! FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_sample_other($0
        )
    })
}

public func newSecurityQuestionsFactorSourceByEncryptingMnemonic(mnemonic: Mnemonic, with: [SecurityNotProductionReadyQuestionAndAnswer]) throws -> SecurityQuestionsNotProductionReadyFactorSource {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_security_questions_factor_source_by_encrypting_mnemonic(
            FfiConverterTypeMnemonic.lower(mnemonic),
            FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lower(with), $0
        )
    })
}

public func newSecurityQuestionsFactorSourceSample() -> SecurityQuestionsNotProductionReadyFactorSource {
    return try! FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_questions_factor_source_sample($0
        )
    })
}

public func newSecurityQuestionsFactorSourceSampleOther() -> SecurityQuestionsNotProductionReadyFactorSource {
    return try! FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_questions_factor_source_sample_other($0
        )
    })
}

public func newSecurityStructureMetadataNamed(name: DisplayName) -> SecurityStructureMetadata {
    return try! FfiConverterTypeSecurityStructureMetadata.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_structure_metadata_named(
            FfiConverterTypeDisplayName.lower(name), $0
        )
    })
}

public func newSecurityStructureMetadataSample() -> SecurityStructureMetadata {
    return try! FfiConverterTypeSecurityStructureMetadata.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_structure_metadata_sample($0
        )
    })
}

public func newSecurityStructureMetadataSampleOther() -> SecurityStructureMetadata {
    return try! FfiConverterTypeSecurityStructureMetadata.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_structure_metadata_sample_other($0
        )
    })
}

public func newSecurityStructureOfFactorSourceIdsSample() -> SecurityStructureOfFactorSourceIDs {
    return try! FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_structure_of_factor_source_ids_sample($0
        )
    })
}

public func newSecurityStructureOfFactorSourceIdsSampleOther() -> SecurityStructureOfFactorSourceIDs {
    return try! FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_structure_of_factor_source_ids_sample_other($0
        )
    })
}

public func newSecurityStructureOfFactorSourcesAutoInDays(metadata: SecurityStructureMetadata, numberOfDaysUntilAutoConfirmation: UInt16, matrixOfFactors: MatrixOfFactorSources) -> SecurityStructureOfFactorSources {
    return try! FfiConverterTypeSecurityStructureOfFactorSources.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_structure_of_factor_sources_auto_in_days(
            FfiConverterTypeSecurityStructureMetadata.lower(metadata),
            FfiConverterUInt16.lower(numberOfDaysUntilAutoConfirmation),
            FfiConverterTypeMatrixOfFactorSources.lower(matrixOfFactors), $0
        )
    })
}

public func newSecurityStructureOfFactorSourcesSample() -> SecurityStructureOfFactorSources {
    return try! FfiConverterTypeSecurityStructureOfFactorSources.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_structure_of_factor_sources_sample($0
        )
    })
}

public func newSecurityStructureOfFactorSourcesSampleOther() -> SecurityStructureOfFactorSources {
    return try! FfiConverterTypeSecurityStructureOfFactorSources.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_structure_of_factor_sources_sample_other($0
        )
    })
}

public func newSecurityStructuresOfFactorSourceIDsSample() -> [SecurityStructureOfFactorSourceIDs] {
    return try! FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_structures_of_factor_source_i_ds_sample($0
        )
    })
}

public func newSecurityStructuresOfFactorSourceIDsSampleOther() -> [SecurityStructureOfFactorSourceIDs] {
    return try! FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_structures_of_factor_source_i_ds_sample_other($0
        )
    })
}

public func newSecurityStructuresOfFactorSourcesSample() -> [SecurityStructureOfFactorSources] {
    return try! FfiConverterSequenceTypeSecurityStructureOfFactorSources.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_structures_of_factor_sources_sample($0
        )
    })
}

public func newSecurityStructuresOfFactorSourcesSampleOther() -> [SecurityStructureOfFactorSources] {
    return try! FfiConverterSequenceTypeSecurityStructureOfFactorSources.lift(try! rustCall {
        uniffi_sargon_fn_func_new_security_structures_of_factor_sources_sample_other($0
        )
    })
}

public func newSharedPersonaDataSample() -> SharedPersonaData {
    return try! FfiConverterTypeSharedPersonaData.lift(try! rustCall {
        uniffi_sargon_fn_func_new_shared_persona_data_sample($0
        )
    })
}

public func newSharedPersonaDataSampleOther() -> SharedPersonaData {
    return try! FfiConverterTypeSharedPersonaData.lift(try! rustCall {
        uniffi_sargon_fn_func_new_shared_persona_data_sample_other($0
        )
    })
}

public func newSignatureFromBytes(bytes: BagOfBytes) throws -> Signature {
    return try FfiConverterTypeSignature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_signature_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newSignatureSample() -> Signature {
    return try! FfiConverterTypeSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signature_sample($0
        )
    })
}

public func newSignatureSampleOther() -> Signature {
    return try! FfiConverterTypeSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signature_sample_other($0
        )
    })
}

public func newSignatureWithPublicKeySample() -> SignatureWithPublicKey {
    return try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signature_with_public_key_sample($0
        )
    })
}

public func newSignatureWithPublicKeySampleOther() -> SignatureWithPublicKey {
    return try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signature_with_public_key_sample_other($0
        )
    })
}

public func newSignedIntentHashFromString(string: String) throws -> SignedIntentHash {
    return try FfiConverterTypeSignedIntentHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_signed_intent_hash_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newSignedIntentHashSample() -> SignedIntentHash {
    return try! FfiConverterTypeSignedIntentHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signed_intent_hash_sample($0
        )
    })
}

public func newSignedIntentHashSampleOther() -> SignedIntentHash {
    return try! FfiConverterTypeSignedIntentHash.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signed_intent_hash_sample_other($0
        )
    })
}

public func newSignedIntentSample() -> SignedIntent {
    return try! FfiConverterTypeSignedIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signed_intent_sample($0
        )
    })
}

public func newSignedIntentSampleOther() -> SignedIntent {
    return try! FfiConverterTypeSignedIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_new_signed_intent_sample_other($0
        )
    })
}

public func newSlip10CurveFromString(curve: String) throws -> Slip10Curve {
    return try FfiConverterTypeSLIP10Curve.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_slip10_curve_from_string(
            FfiConverterString.lower(curve), $0
        )
    })
}

public func newStakeClaimSample() -> StakeClaim {
    return try! FfiConverterTypeStakeClaim.lift(try! rustCall {
        uniffi_sargon_fn_func_new_stake_claim_sample($0
        )
    })
}

public func newStakeClaimSampleOther() -> StakeClaim {
    return try! FfiConverterTypeStakeClaim.lift(try! rustCall {
        uniffi_sargon_fn_func_new_stake_claim_sample_other($0
        )
    })
}

public func newSupportedCurvesSample() -> [Slip10Curve] {
    return try! FfiConverterSequenceTypeSLIP10Curve.lift(try! rustCall {
        uniffi_sargon_fn_func_new_supported_curves_sample($0
        )
    })
}

public func newSupportedCurvesSampleOther() -> [Slip10Curve] {
    return try! FfiConverterSequenceTypeSLIP10Curve.lift(try! rustCall {
        uniffi_sargon_fn_func_new_supported_curves_sample_other($0
        )
    })
}

public func newThirdPartyDepositsDefault() -> ThirdPartyDeposits {
    return try! FfiConverterTypeThirdPartyDeposits.lift(try! rustCall {
        uniffi_sargon_fn_func_new_third_party_deposits_default($0
        )
    })
}

public func newThirdPartyDepositsSample() -> ThirdPartyDeposits {
    return try! FfiConverterTypeThirdPartyDeposits.lift(try! rustCall {
        uniffi_sargon_fn_func_new_third_party_deposits_sample($0
        )
    })
}

public func newThirdPartyDepositsSampleOther() -> ThirdPartyDeposits {
    return try! FfiConverterTypeThirdPartyDeposits.lift(try! rustCall {
        uniffi_sargon_fn_func_new_third_party_deposits_sample_other($0
        )
    })
}

public func newTransactionHeaderSample() -> TransactionHeader {
    return try! FfiConverterTypeTransactionHeader.lift(try! rustCall {
        uniffi_sargon_fn_func_new_transaction_header_sample($0
        )
    })
}

public func newTransactionHeaderSampleOther() -> TransactionHeader {
    return try! FfiConverterTypeTransactionHeader.lift(try! rustCall {
        uniffi_sargon_fn_func_new_transaction_header_sample_other($0
        )
    })
}

public func newTransactionIntentSample() -> TransactionIntent {
    return try! FfiConverterTypeTransactionIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_new_transaction_intent_sample($0
        )
    })
}

public func newTransactionIntentSampleOther() -> TransactionIntent {
    return try! FfiConverterTypeTransactionIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_new_transaction_intent_sample_other($0
        )
    })
}

public func newTransactionManifestFromInstructionsStringAndBlobs(instructionsString: String, networkId: NetworkId, blobs: Blobs) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_transaction_manifest_from_instructions_string_and_blobs(
            FfiConverterString.lower(instructionsString),
            FfiConverterTypeNetworkID.lower(networkId),
            FfiConverterTypeBlobs.lower(blobs), $0
        )
    })
}

public func newTransactionManifestFromUnvalidatedTransactionManifest(unvalidatedTransactionManifest: UnvalidatedTransactionManifest, networkId: NetworkId) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_transaction_manifest_from_unvalidated_transaction_manifest(
            FfiConverterTypeUnvalidatedTransactionManifest.lower(unvalidatedTransactionManifest),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newTransactionManifestSample() -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_new_transaction_manifest_sample($0
        )
    })
}

public func newTransactionManifestSampleOther() -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_new_transaction_manifest_sample_other($0
        )
    })
}

public func newTrustedContactFactorSourceContactSample() -> TrustedContactFactorSourceContact {
    return try! FfiConverterTypeTrustedContactFactorSourceContact.lift(try! rustCall {
        uniffi_sargon_fn_func_new_trusted_contact_factor_source_contact_sample($0
        )
    })
}

public func newTrustedContactFactorSourceContactSampleOther() -> TrustedContactFactorSourceContact {
    return try! FfiConverterTypeTrustedContactFactorSourceContact.lift(try! rustCall {
        uniffi_sargon_fn_func_new_trusted_contact_factor_source_contact_sample_other($0
        )
    })
}

public func newTrustedContactFactorSourceFromAddressAndContact(accountAddress: AccountAddress, contact: TrustedContactFactorSourceContact) -> TrustedContactFactorSource {
    return try! FfiConverterTypeTrustedContactFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_trusted_contact_factor_source_from_address_and_contact(
            FfiConverterTypeAccountAddress.lower(accountAddress),
            FfiConverterTypeTrustedContactFactorSourceContact.lower(contact), $0
        )
    })
}

public func newTrustedContactFactorSourceSample() -> TrustedContactFactorSource {
    return try! FfiConverterTypeTrustedContactFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_trusted_contact_factor_source_sample($0
        )
    })
}

public func newTrustedContactFactorSourceSampleOther() -> TrustedContactFactorSource {
    return try! FfiConverterTypeTrustedContactFactorSource.lift(try! rustCall {
        uniffi_sargon_fn_func_new_trusted_contact_factor_source_sample_other($0
        )
    })
}

public func newUnsecuredEntityControlSample() -> UnsecuredEntityControl {
    return try! FfiConverterTypeUnsecuredEntityControl.lift(try! rustCall {
        uniffi_sargon_fn_func_new_unsecured_entity_control_sample($0
        )
    })
}

public func newUnsecuredEntityControlSampleOther() -> UnsecuredEntityControl {
    return try! FfiConverterTypeUnsecuredEntityControl.lift(try! rustCall {
        uniffi_sargon_fn_func_new_unsecured_entity_control_sample_other($0
        )
    })
}

public func newUnvalidatedTransactionManifestFromTransactionManifest(transactionManifest: TransactionManifest) -> UnvalidatedTransactionManifest {
    return try! FfiConverterTypeUnvalidatedTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_new_unvalidated_transaction_manifest_from_transaction_manifest(
            FfiConverterTypeTransactionManifest.lower(transactionManifest), $0
        )
    })
}

public func newUnvalidatedTransactionManifestSample() -> UnvalidatedTransactionManifest {
    return try! FfiConverterTypeUnvalidatedTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_new_unvalidated_transaction_manifest_sample($0
        )
    })
}

public func newUnvalidatedTransactionManifestSampleOther() -> UnvalidatedTransactionManifest {
    return try! FfiConverterTypeUnvalidatedTransactionManifest.lift(try! rustCall {
        uniffi_sargon_fn_func_new_unvalidated_transaction_manifest_sample_other($0
        )
    })
}

public func newValidatorAddress(bech32: String) throws -> ValidatorAddress {
    return try FfiConverterTypeValidatorAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_validator_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newValidatorAddressRandom(networkId: NetworkId) -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_validator_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newValidatorAddressSampleMainnet() -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_validator_address_sample_mainnet($0
        )
    })
}

public func newValidatorAddressSampleMainnetOther() -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_validator_address_sample_mainnet_other($0
        )
    })
}

public func newValidatorAddressSampleStokenet() -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_validator_address_sample_stokenet($0
        )
    })
}

public func newValidatorAddressSampleStokenetOther() -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_validator_address_sample_stokenet_other($0
        )
    })
}

public func newVaultAddress(bech32: String) throws -> VaultAddress {
    return try FfiConverterTypeVaultAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_vault_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newVaultAddressRandom(networkId: NetworkId) -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_vault_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newVaultAddressSampleMainnetFungible() -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_vault_address_sample_mainnet_fungible($0
        )
    })
}

public func newVaultAddressSampleMainnetNonFungible() -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_vault_address_sample_mainnet_non_fungible($0
        )
    })
}

public func newVaultAddressSampleStokenetFungible() -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_vault_address_sample_stokenet_fungible($0
        )
    })
}

public func newVaultAddressSampleStokenetNonFungible() -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_new_vault_address_sample_stokenet_non_fungible($0
        )
    })
}

public func newWalletInteractionVersionCurrent() -> WalletInteractionVersion {
    return try! FfiConverterTypeWalletInteractionVersion.lift(try! rustCall {
        uniffi_sargon_fn_func_new_wallet_interaction_version_current($0
        )
    })
}

public func newWalletInteractionWalletAccountFromJsonBytes(jsonBytes: BagOfBytes) throws -> WalletInteractionWalletAccount {
    return try FfiConverterTypeWalletInteractionWalletAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_wallet_interaction_wallet_account_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newWalletInteractionWalletAccountSample() -> WalletInteractionWalletAccount {
    return try! FfiConverterTypeWalletInteractionWalletAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_wallet_interaction_wallet_account_sample($0
        )
    })
}

public func newWalletInteractionWalletAccountSampleOther() -> WalletInteractionWalletAccount {
    return try! FfiConverterTypeWalletInteractionWalletAccount.lift(try! rustCall {
        uniffi_sargon_fn_func_new_wallet_interaction_wallet_account_sample_other($0
        )
    })
}

public func newWalletToDappInteractionResponseFromJsonBytes(jsonBytes: BagOfBytes) throws -> WalletToDappInteractionResponse {
    return try FfiConverterTypeWalletToDappInteractionResponse.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_new_wallet_to_dapp_interaction_response_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newWalletToDappInteractionResponseSample() -> WalletToDappInteractionResponse {
    return try! FfiConverterTypeWalletToDappInteractionResponse.lift(try! rustCall {
        uniffi_sargon_fn_func_new_wallet_to_dapp_interaction_response_sample($0
        )
    })
}

public func newWalletToDappInteractionResponseSampleOther() -> WalletToDappInteractionResponse {
    return try! FfiConverterTypeWalletToDappInteractionResponse.lift(try! rustCall {
        uniffi_sargon_fn_func_new_wallet_to_dapp_interaction_response_sample_other($0
        )
    })
}

public func nonFungibleGlobalIdFormatted(globalId: NonFungibleGlobalId, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_global_id_formatted(
            FfiConverterTypeNonFungibleGlobalId.lower(globalId),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func nonFungibleGlobalIdToString(globalId: NonFungibleGlobalId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_global_id_to_string(
            FfiConverterTypeNonFungibleGlobalId.lower(globalId), $0
        )
    })
}

public func nonFungibleLocalIdAsStr(id: NonFungibleLocalId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_local_id_as_str(
            FfiConverterTypeNonFungibleLocalId.lower(id), $0
        )
    })
}

public func nonFungibleLocalIdFormatted(id: NonFungibleLocalId, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_local_id_formatted(
            FfiConverterTypeNonFungibleLocalId.lower(id),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func nonFungibleLocalIdToUserFacingString(id: NonFungibleLocalId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_local_id_to_user_facing_string(
            FfiConverterTypeNonFungibleLocalId.lower(id), $0
        )
    })
}

/**
 * Returns the base address of this specialized address.
 */
public func nonFungibleResourceAddressAsResourceAddress(address: NonFungibleResourceAddress) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_resource_address_as_resource_address(
            FfiConverterTypeNonFungibleResourceAddress.lower(address), $0
        )
    })
}

/**
 * Returns the bech32 encoding of this address
 */
public func nonFungibleResourceAddressBech32Address(address: NonFungibleResourceAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_resource_address_bech32_address(
            FfiConverterTypeNonFungibleResourceAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func nonFungibleResourceAddressMapToNetwork(address: NonFungibleResourceAddress, networkId: NetworkId) -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_resource_address_map_to_network(
            FfiConverterTypeNonFungibleResourceAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Returns the network id this address
 */
public func nonFungibleResourceAddressNetworkId(address: NonFungibleResourceAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_resource_address_network_id(
            FfiConverterTypeNonFungibleResourceAddress.lower(address), $0
        )
    })
}

public func nonFungibleResourceIndicatorGetIds(indicator: NonFungibleResourceIndicator) -> [NonFungibleLocalId] {
    return try! FfiConverterSequenceTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_fn_func_non_fungible_resource_indicator_get_ids(
            FfiConverterTypeNonFungibleResourceIndicator.lower(indicator), $0
        )
    })
}

public func nonceGetValue(nonce: Nonce) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_fn_func_nonce_get_value(
            FfiConverterTypeNonce.lower(nonce), $0
        )
    })
}

public func notarizedTransactionCompile(notarizedTransaction: NotarizedTransaction) -> CompiledNotarizedIntent {
    return try! FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall {
        uniffi_sargon_fn_func_notarized_transaction_compile(
            FfiConverterTypeNotarizedTransaction.lower(notarizedTransaction), $0
        )
    })
}

public func notarySignatureGetSignature(notarySignature: NotarySignature) -> Signature {
    return try! FfiConverterTypeSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_notary_signature_get_signature(
            FfiConverterTypeNotarySignature.lower(notarySignature), $0
        )
    })
}

public func p2PLinkToJsonBytes(p2PLink: P2pLink) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_p2_p_link_to_json_bytes(
            FfiConverterTypeP2PLink.lower(p2PLink), $0
        )
    })
}

public func p2pLinkId(link: P2pLink) -> PublicKeyHash {
    return try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
        uniffi_sargon_fn_func_p2p_link_id(
            FfiConverterTypeP2PLink.lower(link), $0
        )
    })
}

public func p2pLinksToJsonBytes(links: [P2pLink]) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_p2p_links_to_json_bytes(
            FfiConverterSequenceTypeP2PLink.lower(links), $0
        )
    })
}

public func packageAddressBech32Address(address: PackageAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_package_address_bech32_address(
            FfiConverterTypePackageAddress.lower(address), $0
        )
    })
}

public func packageAddressFormatted(address: PackageAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_package_address_formatted(
            FfiConverterTypePackageAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func packageAddressMapToNetwork(address: PackageAddress, networkId: NetworkId) -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_package_address_map_to_network(
            FfiConverterTypePackageAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func packageAddressNetworkId(address: PackageAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_package_address_network_id(
            FfiConverterTypePackageAddress.lower(address), $0
        )
    })
}

public func personaDataEntryEmailAddressToJsonString(personaDataEntryEmailAddress: EmailAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_entry_email_address_to_json_string(
            FfiConverterTypeEmailAddress.lower(personaDataEntryEmailAddress), $0
        )
    })
}

public func personaDataEntryNameToJsonBytes(personaDataEntryName: PersonaDataEntryName) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_entry_name_to_json_bytes(
            FfiConverterTypePersonaDataEntryName.lower(personaDataEntryName), $0
        )
    })
}

public func personaDataEntryPhoneNumberToJsonString(personaDataEntryPhoneNumber: PersonaDataEntryPhoneNumber) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_entry_phone_number_to_json_string(
            FfiConverterTypePersonaDataEntryPhoneNumber.lower(personaDataEntryPhoneNumber), $0
        )
    })
}

public func personaDataIdentifiedEmailAddressSample() -> PersonaDataIdentifiedEmailAddress {
    return try! FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_identified_email_address_sample($0
        )
    })
}

public func personaDataIdentifiedEmailAddressSampleOther() -> PersonaDataIdentifiedEmailAddress {
    return try! FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_identified_email_address_sample_other($0
        )
    })
}

public func personaDataIdentifiedNameSample() -> PersonaDataIdentifiedName {
    return try! FfiConverterTypePersonaDataIdentifiedName.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_identified_name_sample($0
        )
    })
}

public func personaDataIdentifiedNameSampleOther() -> PersonaDataIdentifiedName {
    return try! FfiConverterTypePersonaDataIdentifiedName.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_identified_name_sample_other($0
        )
    })
}

public func personaDataIdentifiedPhoneNumberSample() -> PersonaDataIdentifiedPhoneNumber {
    return try! FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_identified_phone_number_sample($0
        )
    })
}

public func personaDataIdentifiedPhoneNumberSampleOther() -> PersonaDataIdentifiedPhoneNumber {
    return try! FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(try! rustCall {
        uniffi_sargon_fn_func_persona_data_identified_phone_number_sample_other($0
        )
    })
}

public func poolAddressBech32Address(address: PoolAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_pool_address_bech32_address(
            FfiConverterTypePoolAddress.lower(address), $0
        )
    })
}

public func poolAddressFormatted(address: PoolAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_pool_address_formatted(
            FfiConverterTypePoolAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns the kind of pool, either 1, 2 or Multi resources.
 */
public func poolAddressKind(address: PoolAddress) -> PoolKind {
    return try! FfiConverterTypePoolKind.lift(try! rustCall {
        uniffi_sargon_fn_func_pool_address_kind(
            FfiConverterTypePoolAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func poolAddressMapToNetwork(address: PoolAddress, networkId: NetworkId) -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_pool_address_map_to_network(
            FfiConverterTypePoolAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func poolAddressNetworkId(address: PoolAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_pool_address_network_id(
            FfiConverterTypePoolAddress.lower(address), $0
        )
    })
}

public func profileAnalyzeContentsOfFile(contents: String) -> ProfileFileContents {
    return try! FfiConverterTypeProfileFileContents.lift(try! rustCall {
        uniffi_sargon_fn_func_profile_analyze_contents_of_file(
            FfiConverterString.lower(contents), $0
        )
    })
}

public func profileEncryptWithPassword(profile: Profile, encryptionPassword: String) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_profile_encrypt_with_password(
            FfiConverterTypeProfile.lower(profile),
            FfiConverterString.lower(encryptionPassword), $0
        )
    })
}

public func profileNetworkDetailsForAuthorizedDapp(profileNetwork: ProfileNetwork, dapp: AuthorizedDapp) throws -> AuthorizedDappDetailed {
    return try FfiConverterTypeAuthorizedDappDetailed.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_profile_network_details_for_authorized_dapp(
            FfiConverterTypeProfileNetwork.lower(profileNetwork),
            FfiConverterTypeAuthorizedDapp.lower(dapp), $0
        )
    })
}

public func profileToDebugString(profile: Profile) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_profile_to_debug_string(
            FfiConverterTypeProfile.lower(profile), $0
        )
    })
}

public func profileToJsonString(profile: Profile, prettyPrinted: Bool) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_profile_to_json_string(
            FfiConverterTypeProfile.lower(profile),
            FfiConverterBool.lower(prettyPrinted), $0
        )
    })
}

public func profileToString(profile: Profile) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_profile_to_string(
            FfiConverterTypeProfile.lower(profile), $0
        )
    })
}

/**
 * Verifies an Elliptic Curve signature over either Curve25519 or Secp256k1
 */
public func publicKeyIsValidSignatureForHash(publicKey: PublicKey, signature: Signature, hash: Hash) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_public_key_is_valid_signature_for_hash(
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterTypeSignature.lower(signature),
            FfiConverterTypeHash.lower(hash), $0
        )
    })
}

public func publicKeyToBytes(publicKey: PublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_public_key_to_bytes(
            FfiConverterTypePublicKey.lower(publicKey), $0
        )
    })
}

public func publicKeyToHex(publicKey: PublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_public_key_to_hex(
            FfiConverterTypePublicKey.lower(publicKey), $0
        )
    })
}

public func radixConnectMobileSessionRequestToJsonBytes(radixConnectMobileSessionRequest: RadixConnectMobileSessionRequest) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_radix_connect_mobile_session_request_to_json_bytes(
            FfiConverterTypeRadixConnectMobileSessionRequest.lower(radixConnectMobileSessionRequest), $0
        )
    })
}

public func radixConnectPasswordMessageHash(password: RadixConnectPassword) -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_fn_func_radix_connect_password_message_hash(
            FfiConverterTypeRadixConnectPassword.lower(password), $0
        )
    })
}

public func radixConnectPasswordToJsonString(radixConnectPassword: RadixConnectPassword) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_radix_connect_password_to_json_string(
            FfiConverterTypeRadixConnectPassword.lower(radixConnectPassword), $0
        )
    })
}

public func radixConnectPurposeToJsonString(radixConnectPurpose: RadixConnectPurpose) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_radix_connect_purpose_to_json_string(
            FfiConverterTypeRadixConnectPurpose.lower(radixConnectPurpose), $0
        )
    })
}

/**
 * Checks `number_of_ids` can fulfill the [`RequestedQuantity`] (self), `number_of_ids` is
 * considered to be fulfilling the requested quantity:
 * * if: quantifier == ::Exactly && number_of_ids == quantity //  fulfills
 * * else if: quantifier == ::AtLeast && number_of_ids >= quantity //  fulfills
 * * else false //  does NOT fulfill
 */
public func requestedQuantityIsFulfilledByIds(requestedQuantity: RequestedQuantity, numberOfIds: UInt64) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_requested_quantity_is_fulfilled_by_ids(
            FfiConverterTypeRequestedQuantity.lower(requestedQuantity),
            FfiConverterUInt64.lower(numberOfIds), $0
        )
    })
}

public func requestedQuantityIsValid(requestedQuantity: RequestedQuantity) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_requested_quantity_is_valid(
            FfiConverterTypeRequestedQuantity.lower(requestedQuantity), $0
        )
    })
}

public func requestedQuantityToJsonBytes(requestedQuantity: RequestedQuantity) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_requested_quantity_to_json_bytes(
            FfiConverterTypeRequestedQuantity.lower(requestedQuantity), $0
        )
    })
}

public func resourceAddressBech32Address(address: ResourceAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_address_bech32_address(
            FfiConverterTypeResourceAddress.lower(address), $0
        )
    })
}

public func resourceAddressFormatted(address: ResourceAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_address_formatted(
            FfiConverterTypeResourceAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func resourceAddressIsFungible(address: ResourceAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_address_is_fungible(
            FfiConverterTypeResourceAddress.lower(address), $0
        )
    })
}

public func resourceAddressIsNonFungible(address: ResourceAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_address_is_non_fungible(
            FfiConverterTypeResourceAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func resourceAddressMapToNetwork(address: ResourceAddress, networkId: NetworkId) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_address_map_to_network(
            FfiConverterTypeResourceAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func resourceAddressNetworkId(address: ResourceAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_address_network_id(
            FfiConverterTypeResourceAddress.lower(address), $0
        )
    })
}

public func resourceIndicatorGetAddress(indicator: ResourceIndicator) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_indicator_get_address(
            FfiConverterTypeResourceIndicator.lower(indicator), $0
        )
    })
}

public func resourcePreferencesGetHiddenResources(resourcePreferences: [ResourceAppPreference]) -> [ResourceIdentifier] {
    return try! FfiConverterSequenceTypeResourceIdentifier.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_preferences_get_hidden_resources(
            FfiConverterSequenceTypeResourceAppPreference.lower(resourcePreferences), $0
        )
    })
}

public func resourcePreferencesHideResource(resourcePreferences: [ResourceAppPreference], resource: ResourceIdentifier) -> [ResourceAppPreference] {
    return try! FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_preferences_hide_resource(
            FfiConverterSequenceTypeResourceAppPreference.lower(resourcePreferences),
            FfiConverterTypeResourceIdentifier.lower(resource), $0
        )
    })
}

public func resourcePreferencesUnhideResource(resourcePreferences: [ResourceAppPreference], resource: ResourceIdentifier) -> [ResourceAppPreference] {
    return try! FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_preferences_unhide_resource(
            FfiConverterSequenceTypeResourceAppPreference.lower(resourcePreferences),
            FfiConverterTypeResourceIdentifier.lower(resource), $0
        )
    })
}

public func resourceSpecifierGetAddress(specifier: ResourceSpecifier) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_resource_specifier_get_address(
            FfiConverterTypeResourceSpecifier.lower(specifier), $0
        )
    })
}

/**
 * Returns every supported LogFilter
 */
public func rustLoggerGetAllFilters() -> [LogFilter] {
    return try! FfiConverterSequenceTypeLogFilter.lift(try! rustCall {
        uniffi_sargon_fn_func_rust_logger_get_all_filters($0
        )
    })
}

/**
 * Returns every supported LogLevel
 */
public func rustLoggerGetAllLevels() -> [LogLevel] {
    return try! FfiConverterSequenceTypeLogLevel.lift(try! rustCall {
        uniffi_sargon_fn_func_rust_logger_get_all_levels($0
        )
    })
}

public func rustLoggerGetLevel() -> LogFilter {
    return try! FfiConverterTypeLogFilter.lift(try! rustCall {
        uniffi_sargon_fn_func_rust_logger_get_level($0
        )
    })
}

/**
 * Do not call this when you are using the SargonOS, it will have installed
 * a logger already. This is useful in tests which are NOT SargonOS tests,
 * or BIOS tests.
 */
public func rustLoggerInit() { try! rustCall {
    uniffi_sargon_fn_func_rust_logger_init($0
    )
}
}

public func rustLoggerLogAtEveryLevel() { try! rustCall {
    uniffi_sargon_fn_func_rust_logger_log_at_every_level($0
    )
}
}

public func rustLoggerSetLevel(level: LogFilter) { try! rustCall {
    uniffi_sargon_fn_func_rust_logger_set_level(
        FfiConverterTypeLogFilter.lower(level), $0
    )
}
}

public func sLIP10CurveToJsonString(sLIP10Curve: Slip10Curve) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_s_l_i_p10_curve_to_json_string(
            FfiConverterTypeSLIP10Curve.lower(sLIP10Curve), $0
        )
    })
}

/**
 * Returns the current and the other gateways of `gateways`.
 */
public func savedGatewaysGetAllElements(gateways: SavedGateways) -> [Gateway] {
    return try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
        uniffi_sargon_fn_func_saved_gateways_get_all_elements(
            FfiConverterTypeSavedGateways.lower(gateways), $0
        )
    })
}

/**
 * Returns the public key on **compressed** form (33 bytes)
 */
public func secp256k1PublicKeyToBytes(publicKey: Secp256k1PublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_secp256k1_public_key_to_bytes(
            FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
        )
    })
}

/**
 * Returns the public key on **uncompressed** form (65 bytes)
 */
public func secp256k1PublicKeyToBytesUncompressed(publicKey: Secp256k1PublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_secp256k1_public_key_to_bytes_uncompressed(
            FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
        )
    })
}

/**
 * Encodes the compressed form (33 bytes) of a `Secp256k1PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"033083620d1596d3f8988ff3270e42970dd2a031e2b9b6488052a4170ff999f3e8"`
 */
public func secp256k1PublicKeyToHex(publicKey: Secp256k1PublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_secp256k1_public_key_to_hex(
            FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
        )
    })
}

public func secp256k1SignatureToString(signature: Secp256k1Signature) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_secp256k1_signature_to_string(
            FfiConverterTypeSecp256k1Signature.lower(signature), $0
        )
    })
}

public func secureStorageKeyIdentifier(key: SecureStorageKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_secure_storage_key_identifier(
            FfiConverterTypeSecureStorageKey.lower(key), $0
        )
    })
}

public func securityQuestionsAll() -> [SecurityNotProductionReadyQuestion] {
    return try! FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question.lift(try! rustCall {
        uniffi_sargon_fn_func_security_questions_all($0
        )
    })
}

public func securityQuestionsFactorSourceDecrypt(factorSource: SecurityQuestionsNotProductionReadyFactorSource, with: [SecurityNotProductionReadyQuestionAndAnswer]) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_security_questions_factor_source_decrypt(
            FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lower(factorSource),
            FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lower(with), $0
        )
    })
}

public func signatureToBytes(signature: Signature) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_signature_to_bytes(
            FfiConverterTypeSignature.lower(signature), $0
        )
    })
}

public func signatureToString(signature: Signature) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_signature_to_string(
            FfiConverterTypeSignature.lower(signature), $0
        )
    })
}

public func signatureWithPublicKeyGetPublicKey(signatureWithPublicKey: SignatureWithPublicKey) -> PublicKey {
    return try! FfiConverterTypePublicKey.lift(try! rustCall {
        uniffi_sargon_fn_func_signature_with_public_key_get_public_key(
            FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey), $0
        )
    })
}

public func signatureWithPublicKeyGetSignature(signatureWithPublicKey: SignatureWithPublicKey) -> Signature {
    return try! FfiConverterTypeSignature.lift(try! rustCall {
        uniffi_sargon_fn_func_signature_with_public_key_get_signature(
            FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey), $0
        )
    })
}

public func signatureWithPublicKeyIsValid(signatureWithPublicKey: SignatureWithPublicKey, forHash: Hash) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_signature_with_public_key_is_valid(
            FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey),
            FfiConverterTypeHash.lower(forHash), $0
        )
    })
}

public func signedIntentHash(signedIntent: SignedIntent) -> SignedIntentHash {
    return try! FfiConverterTypeSignedIntentHash.lift(try! rustCall {
        uniffi_sargon_fn_func_signed_intent_hash(
            FfiConverterTypeSignedIntent.lower(signedIntent), $0
        )
    })
}

public func signedIntentHashFormatted(address: SignedIntentHash, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_signed_intent_hash_formatted(
            FfiConverterTypeSignedIntentHash.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func slip10CurveToString(curve: Slip10Curve) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_slip10_curve_to_string(
            FfiConverterTypeSLIP10Curve.lower(curve), $0
        )
    })
}

/**
 * The standard transaction fee
 */
public func transactionFeePreset() -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_fee_preset($0
        )
    })
}

public func transactionIntentCompile(intent: TransactionIntent) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_intent_compile(
            FfiConverterTypeTransactionIntent.lower(intent), $0
        )
    })
}

public func transactionIntentHash(intent: TransactionIntent) -> IntentHash {
    return try! FfiConverterTypeIntentHash.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_intent_hash(
            FfiConverterTypeTransactionIntent.lower(intent), $0
        )
    })
}

public func transactionManifestBlobs(manifest: TransactionManifest) -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_manifest_blobs(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestExecutionSummary(manifest: TransactionManifest, encodedReceipt: BagOfBytes) throws -> ExecutionSummary {
    return try FfiConverterTypeExecutionSummary.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_fn_func_transaction_manifest_execution_summary(
            FfiConverterTypeTransactionManifest.lower(manifest),
            FfiConverterTypeBagOfBytes.lower(encodedReceipt), $0
        )
    })
}

public func transactionManifestInstructionsString(manifest: TransactionManifest) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_manifest_instructions_string(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestInvolvedPoolAddresses(manifest: TransactionManifest) -> [PoolAddress] {
    return try! FfiConverterSequenceTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_manifest_involved_pool_addresses(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestInvolvedResourceAddresses(manifest: TransactionManifest) -> [ResourceAddress] {
    return try! FfiConverterSequenceTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_manifest_involved_resource_addresses(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestNetworkId(manifest: TransactionManifest) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_manifest_network_id(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestSummary(manifest: TransactionManifest) -> ManifestSummary {
    return try! FfiConverterTypeManifestSummary.lift(try! rustCall {
        uniffi_sargon_fn_func_transaction_manifest_summary(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func trimSecurityQuestionsAnswer(answer: String) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_trim_security_questions_answer(
            FfiConverterString.lower(answer), $0
        )
    })
}

public func unsafeStorageKeyIdentifier(key: UnsafeStorageKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_unsafe_storage_key_identifier(
            FfiConverterTypeUnsafeStorageKey.lower(key), $0
        )
    })
}

public func validatorAddressBech32Address(address: ValidatorAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_validator_address_bech32_address(
            FfiConverterTypeValidatorAddress.lower(address), $0
        )
    })
}

public func validatorAddressFormatted(address: ValidatorAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_validator_address_formatted(
            FfiConverterTypeValidatorAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func validatorAddressMapToNetwork(address: ValidatorAddress, networkId: NetworkId) -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_validator_address_map_to_network(
            FfiConverterTypeValidatorAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func validatorAddressNetworkId(address: ValidatorAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_validator_address_network_id(
            FfiConverterTypeValidatorAddress.lower(address), $0
        )
    })
}

public func vaultAddressBech32Address(address: VaultAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_vault_address_bech32_address(
            FfiConverterTypeVaultAddress.lower(address), $0
        )
    })
}

public func vaultAddressFormatted(address: VaultAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_fn_func_vault_address_formatted(
            FfiConverterTypeVaultAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func vaultAddressIsFungible(address: VaultAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_vault_address_is_fungible(
            FfiConverterTypeVaultAddress.lower(address), $0
        )
    })
}

public func vaultAddressIsNonFungible(address: VaultAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_fn_func_vault_address_is_non_fungible(
            FfiConverterTypeVaultAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func vaultAddressMapToNetwork(address: VaultAddress, networkId: NetworkId) -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_vault_address_map_to_network(
            FfiConverterTypeVaultAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func vaultAddressNetworkId(address: VaultAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_fn_func_vault_address_network_id(
            FfiConverterTypeVaultAddress.lower(address), $0
        )
    })
}

public func walletInteractionWalletAccountToJsonBytes(walletInteractionWalletAccount: WalletInteractionWalletAccount) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_wallet_interaction_wallet_account_to_json_bytes(
            FfiConverterTypeWalletInteractionWalletAccount.lower(walletInteractionWalletAccount), $0
        )
    })
}

public func walletToDappInteractionResponseToJsonBytes(walletToDappInteractionResponse: WalletToDappInteractionResponse) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_fn_func_wallet_to_dapp_interaction_response_to_json_bytes(
            FfiConverterTypeWalletToDappInteractionResponse.lower(walletToDappInteractionResponse), $0
        )
    })
}

public func xrdAddressOfNetwork(networkId: NetworkId) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_fn_func_xrd_address_of_network(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_sargon_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_sargon_checksum_func_access_controller_address_bech32_address() != 25760 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_access_controller_address_formatted() != 38684 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_access_controller_address_map_to_network() != 7653 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_access_controller_address_network_id() != 33560 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_bech32_address() != 17948 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_formatted() != 20450 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_is_legacy() != 30193 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_map_to_network() != 36457 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_address_network_id() != 30596 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_or_address_of_account_address() != 7165 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_account_or_persona_get_id() != 16313 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_formatted() != 39678 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_map_to_network() != 53347 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_network_id() != 35977 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_of_account_or_persona_formatted() != 33377 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_of_account_or_persona_map_to_network() != 26788 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_of_account_or_persona_network_id() != 61255 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_of_account_or_persona_sample_values_all() != 37634 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_of_account_or_persona_to_string() != 61010 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_sample_values_all() != 44889 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_address_to_string() != 4384 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_android_notarize_hash_with_private_key_bytes() != 27531 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_android_secret_key_get_public_key_from_private_key_bytes() != 17350 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_android_sign_hash_with_private_key_bytes() != 26678 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_app_preferences_has_gateway_with_url() != 40321 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_appearance_ids_all() != 44342 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_arculus_card_model_to_string() != 53885 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_authorized_dapp_to_json_bytes() != 57472 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_b_i_p39_seed_to_bytes() != 29747 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bag_of_bytes_append_cafe() != 36568 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bag_of_bytes_append_deadbeef() != 37334 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bag_of_bytes_prepend_cafe() != 13192 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bag_of_bytes_prepend_deadbeef() != 48562 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bip39_language_wordlist() != 26097 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bip39_word_count_all() != 27954 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bip44_like_path_get_address_index() != 20616 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_bip44_like_path_to_string() != 15736 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_blob_to_bytes() != 37344 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_blob_to_string() != 26081 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_blobs_list_of_blobs() != 64282 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_build_information() != 42216 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_cap26_path_to_string() != 27173 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_check_if_encrypted_profile_json_contains_legacy_p2p_links() != 26929 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_check_if_profile_json_contains_legacy_p2p_links() != 57987 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_compiled_notarized_intent_get_bytes() != 46331 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_bech32_address() != 43553 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_formatted() != 21837 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_is_global() != 52839 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_is_internal() != 64064 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_map_to_network() != 39090 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_component_address_network_id() != 20181 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_dapp_to_wallet_interaction_unvalidated_to_json_bytes() != 19171 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_dapp_to_wallet_interaction_unvalidated_to_json_string() != 30974 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_debug_print_compiled_notarized_intent() != 41819 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_abs() != 51780 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_add() != 5696 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_clamped_to_zero() != 43405 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_div() != 54870 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_formatted() != 33239 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_formatted_plain() != 4879 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_greater_than() != 2639 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_greater_than_or_equal() != 22351 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_is_negative() != 21361 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_is_positive() != 57369 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_is_zero() != 56403 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_less_than() != 59937 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_less_than_or_equal() != 28175 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_max() != 7974 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_min() != 12755 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_mul() != 55479 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_neg() != 45257 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_round() != 18483 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_sub() != 7791 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_decimal_to_string() != 32945 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_default_get_id_path() != 16971 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_dependency_information_to_string() != 33585 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_deposit_rule_to_json_string() != 36586 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_derivation_path_to_hd_path() != 9453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_derivation_path_to_string() != 35541 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_device_factor_source_is_main_bdfs() != 6200 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_device_info_description_to_string() != 3956 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_device_info_to_json_bytes() != 47501 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_display_name_to_json_string() != 63874 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ed25519_public_key_to_bytes() != 28864 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ed25519_public_key_to_hex() != 54633 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ed25519_public_key_to_json_string() != 11961 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ed25519_signature_to_json_string() != 63609 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ed25519_signature_to_string() != 54939 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_entropy16_bytes_to_bytes() != 54982 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_entropy20_bytes_to_bytes() != 22819 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_entropy24_bytes_to_bytes() != 42186 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_entropy28_bytes_to_bytes() != 39686 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_entropy32_bytes_to_bytes() != 21935 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_error_code_from_error() != 36211 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_error_message_from_error() != 51552 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_event_kind() != 37385 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_event_kind_affects_current_accounts() != 41305 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_event_kind_affects_current_network() != 39766 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_event_kind_affects_factor_sources() != 48194 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_event_kind_affects_saved_gateways() != 1682 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_event_kind_affects_security_structures() != 64213 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_event_kind_all() != 31553 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly12_bytes_to_json_string() != 39975 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly29_bytes_to_json_string() != 18109 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly32_bytes_to_json_string() != 10726 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly33_bytes_to_json_string() != 37117 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly60_bytes_to_json_string() != 57816 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly64_bytes_to_json_string() != 64434 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly65_bytes_to_json_string() != 13120 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_12_bytes_to_bytes() != 14031 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_12_bytes_to_hex() != 28250 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_29_bytes_to_bytes() != 4894 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_29_bytes_to_hex() != 54665 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_32_bytes_to_bytes() != 31576 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_32_bytes_to_hex() != 22925 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_33_bytes_to_bytes() != 1951 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_33_bytes_to_hex() != 20116 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_60_bytes_to_bytes() != 14030 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_60_bytes_to_hex() != 57399 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_64_bytes_to_bytes() != 40334 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_64_bytes_to_hex() != 4287 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_65_bytes_to_bytes() != 27895 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_exactly_65_bytes_to_hex() != 45594 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_crypto_parameters_supports_babylon() != 52938 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_crypto_parameters_supports_olympia() != 10349 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_i_d_from_address_to_json_bytes() != 20208 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_i_d_from_hash_to_json_bytes() != 19779 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_id_from_address_to_string() != 28754 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_id_from_hash_to_string() != 10880 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_id_to_string() != 14810 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_kind_to_string() != 21223 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_supports_babylon() != 51556 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_supports_olympia() != 42687 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_source_to_string() != 17785 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_factor_sources_all_sample_values() != 35890 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ffi_url_get_url() != 19625 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_fiat_currency_to_json_string() != 24935 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_fungible_resource_indicator_get_amount() != 6672 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_id() != 62487 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_is_wellknown() != 27630 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_mainnet() != 6356 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_stokenet() != 5043 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_to_string() != 8255 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_gateway_wellknown_gateways() != 49249 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_hash() != 34377 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_hash_get_bytes() != 19768 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_hd_path_component_get_non_hardened_value() != 14531 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_header_to_json_bytes() != 5217 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_hierarchical_deterministic_public_key_is_valid_signature_for_hash() != 52778 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_host_id_to_json_bytes() != 10713 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_host_os_get_name() != 6185 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_host_os_get_vendor() != 53994 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_host_os_get_version() != 60582 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_identity_address_bech32_address() != 46543 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_identity_address_formatted() != 21987 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_identity_address_map_to_network() != 10517 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_identity_address_network_id() != 47961 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_intent_hash_formatted() != 9910 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_intent_signature_get_signature_with_public_key() != 59082 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_is_safe_to_show_error_message_from_error() != 4467 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_ledger_hw_wallet_model_to_string() != 31313 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_legacy_olympia_account_address_formatted() != 61803 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_legacy_olympia_account_address_is_legacy_of_babylon() != 42848 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_legacy_olympia_account_address_to_babylon_account_address() != 27801 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_legacy_olympia_account_address_to_string() != 31113 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_link_connection_q_r_data_to_json_bytes() != 8014 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_create_fungible_token() != 24371 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_create_fungible_token_with_metadata() != 13453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_create_multiple_fungible_tokens() != 9423 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_create_multiple_non_fungible_tokens() != 18157 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_create_non_fungible_token() != 369 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_for_faucet() != 17078 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_marking_account_as_dapp_definition_type() != 20272 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_per_asset_transfers() != 26522 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_per_recipient_transfers() != 24398 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_set_owner_keys_hashes() != 35668 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_stakes_claim() != 47426 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_manifest_third_party_deposit_update() != 63597 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_message_as_plaintext() != 59034 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_mnemonic_phrase() != 29100 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_mnemonic_with_passphrase_derive_public_keys() != 33297 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_mnemonic_with_passphrase_sign() != 12503 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_mnemonic_with_passphrase_to_json_bytes() != 44720 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_mnemonic_with_passphrase_validate_public_keys() != 37731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_modify_manifest_add_guarantees() != 63213 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_modify_manifest_lock_fee() != 62376 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_network_id_discriminant() != 18637 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_network_id_to_string() != 9410 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_network_ids_all() != 37779 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_network_method_to_string() != 39057 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_access_controller_address() != 33601 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_access_controller_address_random() != 41855 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_access_controller_address_sample_mainnet() != 37312 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_access_controller_address_sample_mainnet_other() != 8789 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_access_controller_address_sample_stokenet() != 8365 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_access_controller_address_sample_stokenet_other() != 63709 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address() != 2569 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_from() != 41026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_random() != 51693 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_sample_mainnet() != 54570 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_sample_mainnet_other() != 32731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_sample_stokenet() != 65160 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_address_sample_stokenet_other() != 9463 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_for_display_from_account() != 39086 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_for_display_sample() != 30591 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_for_display_sample_other() != 46613 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_address_of_sample() != 2477 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_address_of_sample_other() != 690 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_persona_sample_mainnet() != 47397 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_persona_sample_mainnet_other() != 50672 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_persona_sample_mainnet_third() != 54497 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_persona_sample_stokenet() != 42304 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_persona_sample_stokenet_other() != 25620 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_or_persona_sample_stokenet_third() != 52742 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_path() != 58971 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_path_sample() != 38953 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_path_sample_other() != 29077 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_mainnet_alice() != 2121 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_mainnet_bob() != 12275 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_mainnet_carol() != 43098 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_mainnet_diana() != 62921 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_stokenet_nadia() != 59452 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_stokenet_olivia() != 26665 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_account_sample_stokenet_paige() != 15474 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accounts_for_display_sample() != 56319 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accounts_for_display_sample_other() != 18568 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accounts_or_personas_sample() != 57382 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accounts_or_personas_sample_other() != 37298 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accounts_sample() != 52304 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_accounts_sample_other() != 55827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_from_bech32() != 37020 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_from_bech32() != 42616 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_account_mainnet() != 50600 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_account_mainnet_other() != 57767 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_account_stokenet() != 5321 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_account_stokenet_other() != 11425 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_identity_mainnet() != 32276 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_identity_mainnet_other() != 62845 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_identity_stokenet() != 58184 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_identity_stokenet_other() != 19614 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_mainnet() != 16347 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_mainnet_other() != 43108 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_stokenet() != 13408 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_of_account_or_persona_sample_stokenet_other() != 61142 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_access_controller_mainnet() != 28069 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_access_controller_mainnet_other() != 30642 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_access_controller_stokenet() != 62734 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_access_controller_stokenet_other() != 26659 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_account_mainnet() != 56609 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_account_mainnet_other() != 6596 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_account_stokenet() != 18414 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_account_stokenet_other() != 55369 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_component_mainnet() != 27352 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_component_mainnet_other() != 51433 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_component_stokenet() != 60532 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_component_stokenet_other() != 18123 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_identity_mainnet() != 61162 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_identity_mainnet_other() != 49232 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_identity_stokenet() != 39938 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_identity_stokenet_other() != 35441 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_mainnet() != 8425 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_mainnet_other() != 47495 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_package_mainnet() != 22566 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_package_mainnet_other() != 32671 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_package_stokenet() != 31480 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_package_stokenet_other() != 21526 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_pool_mainnet() != 16663 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_pool_mainnet_other() != 19344 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_pool_stokenet() != 45966 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_pool_stokenet_other() != 53469 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_resource_mainnet() != 65163 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_resource_mainnet_other() != 17673 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_resource_stokenet() != 42435 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_resource_stokenet_other() != 24663 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_stokenet() != 44722 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_stokenet_other() != 48831 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_validator_mainnet() != 26468 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_validator_mainnet_other() != 819 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_validator_stokenet() != 27575 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_validator_stokenet_other() != 59068 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_vault_mainnet() != 56941 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_vault_mainnet_other() != 20624 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_vault_stokenet() != 47675 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_address_sample_vault_stokenet_other() != 23277 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_app_preferences_default() != 21875 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_app_preferences_sample() != 26430 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_app_preferences_sample_other() != 22597 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_appearance_id() != 28026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_appearance_id_from_number_of_accounts_on_network() != 48123 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_appearance_id_sample() != 60944 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_appearance_id_sample_other() != 1141 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_arculus_card_factor_source_from_mnemonic_with_passphrase() != 40290 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_arculus_card_factor_source_sample() != 45343 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_arculus_card_factor_source_sample_other() != 65320 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_asset_exception_sample() != 51557 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_asset_exception_sample_other() != 54109 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_assets_exception_list_sample() != 744 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_assets_exception_list_sample_other() != 64252 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_detailed_sample() != 17085 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_detailed_sample_other() != 45014 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_from_json_bytes() != 25043 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_sample_mainnet_dashboard() != 11297 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_sample_mainnet_gumballclub() != 13607 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_sample_stokenet_devconsole() != 25090 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapp_sample_stokenet_sandbox() != 34108 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapps_sample() != 15614 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_dapps_sample_other() != 41193 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_persona_detailed_sample() != 48419 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_persona_detailed_sample_other() != 45187 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_persona_simple_sample_mainnet() != 9711 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_persona_simple_sample_mainnet_other() != 37878 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_persona_simple_sample_stokenet() != 60086 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_authorized_persona_simple_sample_stokenet_other() != 40314 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_b_i_p39_seed_from_bytes() != 6677 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_b_i_p39_seed_sample() != 20641 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_b_i_p39_seed_sample_other() != 60764 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_from() != 22344 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_sample_aced() != 64842 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_sample_babe() != 62899 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_sample_cafe() != 37207 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_sample_dead() != 5095 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_sample_ecad() != 34034 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bag_of_bytes_sample_fade() != 12927 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip39_language_sample() != 7193 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip39_language_sample_other() != 51248 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip39_word_sample() != 31657 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip39_word_sample_other() != 63848 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip44_like_path_from_index() != 28361 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip44_like_path_from_string() != 58508 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip44_like_path_sample() != 2907 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_bip44_like_path_sample_other() != 35179 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_blob_from_bytes() != 40775 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_blobs_from_blob_list() != 54212 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_blobs_sample() != 23083 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_blobs_sample_other() != 32184 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_cap26_path_from_string() != 34117 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_compiled_notarized_intent_sample() != 6366 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_compiled_notarized_intent_sample_other() != 36824 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address() != 30761 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address_random() != 27144 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address_sample_mainnet_global() != 46435 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address_sample_mainnet_internal() != 15814 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address_sample_stokenet_global() != 43113 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_component_address_sample_stokenet_internal() != 30221 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_dapp_to_wallet_interaction_unvalidated_from_json_bytes() != 15557 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_dapp_to_wallet_interaction_unvalidated_from_json_string() != 28292 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_dapp_to_wallet_interaction_unvalidated_sample() != 59961 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_dapp_to_wallet_interaction_unvalidated_sample_other() != 56169 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_exponent() != 14708 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_f32() != 56764 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_f64() != 20942 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_formatted_string() != 61026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_i32() != 58273 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_i64() != 54406 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_string() != 43065 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_u32() != 44217 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_decimal_from_u64() != 34678 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_dependency_information_sample() != 33653 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_dependency_information_sample_other() != 4043 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_deposit_rule_from_json_string() != 38629 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_deposit_rule_sample() != 660 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_deposit_rule_sample_other() != 47005 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_depositors_allow_list_sample() != 33963 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_depositors_allow_list_sample_other() != 42234 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_derivation_path_from_string() != 7796 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_derivation_path_sample() != 63533 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_derivation_path_sample_other() != 564 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_detailed_authorized_personas_sample() != 19857 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_detailed_authorized_personas_sample_other() != 23779 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_factor_source_babylon() != 20401 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_factor_source_olympia() != 59894 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_factor_source_sample() != 12227 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_factor_source_sample_other() != 46676 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_info_description_sample() != 8191 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_info_description_sample_other() != 35889 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_info_from_host_info() != 40956 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_info_from_json_bytes() != 9588 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_info_sample() != 33011 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_device_info_sample_other() != 53887 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_display_name() != 49394 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_display_name_from_json_string() != 16707 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_display_name_sample() != 2735 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_display_name_sample_other() != 31614 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_from_bytes() != 44499 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_from_hex() != 12721 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_from_json_string() != 35081 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_sample() != 16099 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_public_key_sample_other() != 16541 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_signature_from_bytes() != 64374 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_signature_from_exactly_64_bytes() != 25736 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_signature_from_json_string() != 63670 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_signature_sample() != 47710 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ed25519_signature_sample_other() != 12189 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_email_address_sample() != 20865 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_email_address_sample_other() != 47935 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entity_flag_sample() != 32449 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entity_flag_sample_other() != 47403 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entity_flags_sample() != 36473 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entity_flags_sample_other() != 19054 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entity_security_state_sample() != 54665 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entity_security_state_sample_other() != 60901 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy16_bytes_from_bytes() != 24861 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy16_bytes_sample() != 4672 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy16_bytes_sample_other() != 4616 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy20_bytes_from_bytes() != 64190 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy20_bytes_sample() != 52002 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy20_bytes_sample_other() != 31754 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy24_bytes_from_bytes() != 44872 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy24_bytes_sample() != 2550 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy24_bytes_sample_other() != 17735 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy28_bytes_from_bytes() != 43695 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy28_bytes_sample() != 34080 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy28_bytes_sample_other() != 64297 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy32_bytes_from_bytes() != 32787 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy32_bytes_sample() != 32839 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_entropy32_bytes_sample_other() != 25511 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly12_bytes_from_json_string() != 14387 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly29_bytes_from_json_string() != 3419 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly32_bytes_from_json_string() != 18496 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly33_bytes_from_json_string() != 356 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly60_bytes_from_json_string() != 10826 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly64_bytes_from_json_string() != 51604 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly65_bytes_from_json_string() != 53948 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_12_bytes() != 27335 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_12_bytes_sample() != 26574 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_12_bytes_sample_other() != 24711 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_29_bytes() != 10056 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_29_bytes_sample() != 6180 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_29_bytes_sample_other() != 29088 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_32_bytes() != 15118 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_32_bytes_sample() != 62764 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_32_bytes_sample_other() != 27949 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_33_bytes() != 50447 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_33_bytes_sample() != 43005 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_33_bytes_sample_other() != 59502 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_60_bytes() != 16493 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_60_bytes_sample() != 14965 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_60_bytes_sample_other() != 11654 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_64_bytes() != 29843 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_64_bytes_sample() != 48926 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_64_bytes_sample_other() != 25972 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_65_bytes() != 53842 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_65_bytes_sample() != 41067 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_exactly_65_bytes_sample_other() != 14279 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_common_babylon() != 51932 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_common_bdfs() != 58877 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_common_olympia() != 2461 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_common_sample() != 20275 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_common_sample_other() != 22745 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_crypto_parameters_preset_babylon_olympia_compatible() != 48552 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_crypto_parameters_preset_babylon_only() != 44467 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_crypto_parameters_preset_olympia_only() != 16590 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_crypto_parameters_sample() != 41685 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_crypto_parameters_sample_other() != 8264 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_i_d_from_address_from_json_bytes() != 16029 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_i_d_from_hash_from_json_bytes() != 31521 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_from_address_sample() != 30773 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_from_address_sample_other() != 37306 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_from_hash_from_mnemonic_with_passphrase() != 2864 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_from_hash_sample() != 30682 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_from_hash_sample_other() != 9217 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_sample() != 7044 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_id_sample_other() != 32146 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_kind_from_string() != 15813 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_kind_sample() != 7003 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_kind_sample_other() != 58539 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_sample() != 23677 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_source_sample_other() != 57438 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_sources_sample() != 30863 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_factor_sources_sample_other() != 38923 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_fiat_currency_from_json_string() != 17012 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_fiat_currency_sample() != 21848 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_fiat_currency_sample_other() != 17430 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_fungible_resource_indicator_sample() != 3324 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_fungible_resource_indicator_sample_other() != 51322 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateway_for_network_id() != 50026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateway_sample() != 11459 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateway_sample_other() != 27151 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateway_with_url_on_network() != 58891 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateways_sample() != 42979 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_gateways_sample_other() != 56017 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hash_from_bytes() != 43039 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hash_from_string() != 61249 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hash_sample() != 5937 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hash_sample_other() != 44813 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_header_from_json_bytes() != 20504 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_header_sample() != 6569 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_header_sample_other() != 55288 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_header_with_creating_device() != 38434 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hidden_resources_sample() != 27137 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hidden_resources_sample_other() != 25323 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hierarchical_deterministic_factor_instance_sample() != 7709 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hierarchical_deterministic_factor_instance_sample_other() != 33009 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hierarchical_deterministic_public_key_sample() != 19868 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_hierarchical_deterministic_public_key_sample_other() != 13967 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_home_cards_sample() != 31627 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_home_cards_sample_other() != 49705 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_host_id_from_json_bytes() != 36886 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_host_id_sample() != 9079 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_host_id_sample_other() != 45944 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_host_info_sample() != 39511 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_host_info_sample_other() != 18848 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_host_os_android() != 49441 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_host_os_ios() != 32176 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_host_os_other() != 64582 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_host_os_sample() != 61520 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_host_os_sample_other() != 1058 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address() != 43870 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_from() != 50540 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_random() != 38925 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_sample_mainnet() != 1456 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_sample_mainnet_other() != 10234 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_sample_stokenet() != 36518 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_address_sample_stokenet_other() != 60923 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_path() != 50878 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_path_sample() != 6128 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_identity_path_sample_other() != 52443 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_intent_hash_from_string() != 19100 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_intent_hash_sample() != 36275 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_intent_hash_sample_other() != 5461 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_intent_signature_from_signature_with_public_key() != 49901 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_intent_signature_sample() != 31835 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_intent_signature_sample_other() != 12904 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ledger_hardware_wallet_factor_source_sample() != 29405 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ledger_hardware_wallet_factor_source_sample_other() != 30760 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ledger_hardware_wallet_from_mnemonic_with_passphrase() != 55928 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ledger_hw_wallet_model_from_string() != 33130 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ledger_hw_wallet_model_sample() != 7084 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_ledger_hw_wallet_model_sample_other() != 19248 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_legacy_olympia_account_address_from_public_key() != 48548 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_legacy_olympia_account_address_from_string() != 47049 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_legacy_olympia_account_address_sample() != 7469 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_legacy_olympia_account_address_sample_other() != 34844 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_link_connection_q_r_data_from_json_bytes() != 4678 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_link_connection_qr_data_sample() != 51383 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_link_connection_qr_data_sample_other() != 9392 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_matrix_of_factor_sources_sample() != 42468 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_matrix_of_factor_sources_sample_other() != 55962 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_message_plaintext_sample() != 43854 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_message_plaintext_sample_other() != 25629 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_message_plaintext_string() != 45759 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_from_phrase() != 56379 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_from_phrase_language() != 38433 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_from_words() != 54068 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_generate_with_entropy() != 14363 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample() != 19146 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_arculus() != 13116 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_arculus_other() != 57788 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_device() != 34640 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_device_12_words() != 37652 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_device_12_words_other() != 55309 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_device_other() != 8949 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_ledger() != 2085 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_ledger_other() != 47738 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_off_device() != 55064 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_off_device_other() != 15925 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_other() != 15519 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_security_questions() != 26773 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_sample_security_questions_other() != 14973 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_with_passphrase_from_json_bytes() != 17411 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_with_passphrase_sample() != 21291 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_mnemonic_with_passphrase_sample_other() != 47176 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_network_definition_lookup_by_name() != 16885 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_network_definition_sample() != 65271 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_network_definition_sample_other() != 42724 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_network_id_from_discriminant() != 37300 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_network_method_sample() != 1208 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_network_method_sample_other() != 40589 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_empty_max_32_bytes() != 41452 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_empty_max_64_bytes() != 47176 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_global_id_from_string() != 59679 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_global_id_sample() != 55156 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_global_id_sample_other() != 41952 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_bytes() != 49201 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_from_string() != 30684 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_int() != 31453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_random() != 23592 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_ruid() != 14178 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_sample() != 9803 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_sample_other() != 861 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_string() != 52482 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_local_id_string_from_str() != 61386 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_address() != 54503 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_address_random() != 46740 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_address_sample_mainnet() != 21380 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_address_sample_mainnet_other() != 55440 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_address_sample_stokenet() != 40241 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_address_sample_stokenet_other() != 62264 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_indicator_sample() != 11037 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_non_fungible_resource_indicator_sample_other() != 35376 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_nonce_from_u32() != 11136 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_nonce_random() != 43651 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_nonce_sample() != 11088 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_nonce_sample_other() != 41267 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_notarized_transaction_sample() != 21364 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_notarized_transaction_sample_other() != 59703 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_notary_signature() != 36292 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_notary_signature_sample() != 45924 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_notary_signature_sample_other() != 61991 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_off_device_mnemonic_factor_source_from_mnemonic_with_passphrase() != 60943 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_off_device_mnemonic_factor_source_sample() != 45959 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_off_device_mnemonic_factor_source_sample_other() != 62377 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_on_ledger_settings_default() != 29280 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_on_ledger_settings_sample() != 12028 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_on_ledger_settings_sample_other() != 35880 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_p2_p_link_from_json_bytes() != 38518 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_p2_p_links_sample() != 15609 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_p2_p_links_sample_other() != 58469 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_p2p_link_sample() != 10175 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_p2p_link_sample_other() != 21151 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_p2p_links_from_json_bytes() != 207 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address() != 37949 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address_random() != 41695 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address_sample_mainnet() != 26382 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address_sample_mainnet_other() != 1195 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address_sample_stokenet() != 18632 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_package_address_sample_stokenet_other() != 52864 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_per_asset_transfers_sample() != 517 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_per_asset_transfers_sample_other() != 38110 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_email_address_from_json_string() != 30176 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_email_address_sample() != 52271 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_email_address_sample_other() != 28830 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_name_from_json_bytes() != 59599 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_name_sample() != 13808 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_name_sample_other() != 25465 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_phone_number_from_json_string() != 123 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_phone_number_sample() != 6672 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_entry_phone_number_sample_other() != 8545 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_sample() != 18517 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_data_sample_other() != 29352 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample() != 29567 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_mainnet_batman() != 23030 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_mainnet_ripley() != 16938 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_mainnet_satoshi() != 8417 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_mainnet_turing() != 17821 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_other() != 5281 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_stokenet_connor() != 57340 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_stokenet_hermione() != 32750 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_persona_sample_stokenet_leia_skywalker() != 60650 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_personas_sample() != 5762 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_personas_sample_other() != 22085 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address() != 28108 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_random() != 33642 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_sample_mainnet_multi() != 24097 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_sample_mainnet_single() != 21300 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_sample_mainnet_two() != 16203 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_sample_stokenet_multi() != 44248 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_sample_stokenet_single() != 47667 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_pool_address_sample_stokenet_two() != 47935 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_private_hd_factor_source_babylon() != 34035 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_private_hd_factor_source_babylon_from_mnemonic_with_passphrase() != 50696 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_private_hd_factor_source_olympia_from_mnemonic_with_passphrase() != 16178 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_private_hd_factor_source_sample() != 12746 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_private_hd_factor_source_sample_other() != 13964 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile() != 11539 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_file_contents_sample() != 39969 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_file_contents_sample_other() != 56084 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_from_encryption_bytes() != 51120 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_from_json_string() != 1521 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_network_sample() != 17110 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_network_sample_other() != 28204 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_networks_sample() != 60392 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_networks_sample_other() != 64081 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_sample() != 22947 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_sample_other() != 849 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_profile_with_mnemonic() != 56551 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_from_bytes() != 26414 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_from_hex() != 62045 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_hash_of_key() != 60132 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_hash_sample() != 51315 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_hash_sample_other() != 8307 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_sample() != 48753 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_public_key_sample_other() != 44351 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_mobile_session_request_from_json_bytes() != 15773 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_mobile_session_request_sample() != 32899 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_mobile_session_request_sample_other() != 45330 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_password() != 19430 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_password_from_json_string() != 43786 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_password_sample() != 56632 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_password_sample_other() != 54337 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_purpose_from_json_string() != 30750 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_purpose_from_string() != 8155 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_purpose_sample() != 58545 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_radix_connect_purpose_sample_other() != 24082 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_references_to_authorized_personas_sample() != 47667 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_references_to_authorized_personas_sample_other() != 2789 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_requested_quantity_from_json_bytes() != 35249 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_requested_quantity_sample() != 55234 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_requested_quantity_sample_other() != 19700 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address() != 6366 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_random() != 45912 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_mainnet_candy() != 29968 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_mainnet_nft_gc_membership() != 62029 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_mainnet_xrd() != 6138 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_stokenet_candy() != 44981 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_stokenet_gc_tokens() != 11387 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_stokenet_gum() != 45465 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_address_sample_stokenet_xrd() != 27754 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_indicator_sample() != 63296 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_indicator_sample_other() != 24416 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_or_non_fungible_sample() != 17434 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_or_non_fungible_sample_other() != 29487 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_preferences_sample() != 29467 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_preferences_sample_other() != 27951 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_specifier_sample() != 54710 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_resource_specifier_sample_other() != 29760 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_s_l_i_p10_curve_from_json_string() != 51394 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_sargon_build_information_sample() != 35264 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_sargon_build_information_sample_other() != 42234 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_saved_gateways() != 7808 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_saved_gateways_changing_current() != 46302 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_saved_gateways_default() != 12465 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_saved_gateways_sample() != 8684 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_saved_gateways_sample_other() != 25471 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_public_key_from_bytes() != 19094 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_public_key_from_hex() != 4874 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_public_key_sample() != 25738 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_public_key_sample_other() != 19432 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_signature_from_bytes() != 59032 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_signature_from_exactly_65_bytes() != 35236 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_signature_sample() != 53404 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_secp256k1_signature_sample_other() != 45166 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_and_answers_sample() != 58715 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_and_answers_sample_other() != 25772 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_sample() != 4632 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_sample_other() != 36737 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_questions_factor_source_by_encrypting_mnemonic() != 47351 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_questions_factor_source_sample() != 62136 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_questions_factor_source_sample_other() != 61122 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_structure_metadata_named() != 58420 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_structure_metadata_sample() != 62909 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_structure_metadata_sample_other() != 63498 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_structure_of_factor_source_ids_sample() != 14713 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_structure_of_factor_source_ids_sample_other() != 38976 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_structure_of_factor_sources_auto_in_days() != 44594 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_structure_of_factor_sources_sample() != 10841 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_structure_of_factor_sources_sample_other() != 25091 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_structures_of_factor_source_i_ds_sample() != 23969 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_structures_of_factor_source_i_ds_sample_other() != 23031 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_structures_of_factor_sources_sample() != 28140 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_security_structures_of_factor_sources_sample_other() != 18290 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_shared_persona_data_sample() != 41760 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_shared_persona_data_sample_other() != 21162 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signature_from_bytes() != 16399 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signature_sample() != 40187 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signature_sample_other() != 15062 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signature_with_public_key_sample() != 3544 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signature_with_public_key_sample_other() != 2691 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signed_intent_hash_from_string() != 9298 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signed_intent_hash_sample() != 20533 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signed_intent_hash_sample_other() != 47194 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signed_intent_sample() != 43628 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_signed_intent_sample_other() != 1979 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_slip10_curve_from_string() != 5484 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_stake_claim_sample() != 34303 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_stake_claim_sample_other() != 9047 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_supported_curves_sample() != 38686 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_supported_curves_sample_other() != 47661 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_third_party_deposits_default() != 30385 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_third_party_deposits_sample() != 55284 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_third_party_deposits_sample_other() != 56077 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_header_sample() != 61986 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_header_sample_other() != 43736 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_intent_sample() != 11735 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_intent_sample_other() != 54416 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_manifest_from_instructions_string_and_blobs() != 477 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_manifest_from_unvalidated_transaction_manifest() != 57818 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_manifest_sample() != 63778 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_transaction_manifest_sample_other() != 38915 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_trusted_contact_factor_source_contact_sample() != 58600 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_trusted_contact_factor_source_contact_sample_other() != 44844 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_trusted_contact_factor_source_from_address_and_contact() != 61365 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_trusted_contact_factor_source_sample() != 56301 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_trusted_contact_factor_source_sample_other() != 64728 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_unsecured_entity_control_sample() != 19695 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_unsecured_entity_control_sample_other() != 10502 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_unvalidated_transaction_manifest_from_transaction_manifest() != 9814 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_unvalidated_transaction_manifest_sample() != 46063 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_unvalidated_transaction_manifest_sample_other() != 52036 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address() != 26715 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address_random() != 37504 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address_sample_mainnet() != 57279 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address_sample_mainnet_other() != 1884 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address_sample_stokenet() != 5339 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_validator_address_sample_stokenet_other() != 25591 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address() != 11091 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address_random() != 27536 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address_sample_mainnet_fungible() != 23460 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address_sample_mainnet_non_fungible() != 58209 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address_sample_stokenet_fungible() != 30491 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_vault_address_sample_stokenet_non_fungible() != 60444 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_wallet_interaction_version_current() != 41705 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_wallet_interaction_wallet_account_from_json_bytes() != 35939 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_wallet_interaction_wallet_account_sample() != 25280 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_wallet_interaction_wallet_account_sample_other() != 52617 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_wallet_to_dapp_interaction_response_from_json_bytes() != 7825 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_wallet_to_dapp_interaction_response_sample() != 36669 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_new_wallet_to_dapp_interaction_response_sample_other() != 2432 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_global_id_formatted() != 43733 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_global_id_to_string() != 39748 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_local_id_as_str() != 56180 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_local_id_formatted() != 15563 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_local_id_to_user_facing_string() != 55152 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_resource_address_as_resource_address() != 59145 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_resource_address_bech32_address() != 3970 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_resource_address_map_to_network() != 12314 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_resource_address_network_id() != 31736 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_non_fungible_resource_indicator_get_ids() != 44094 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_nonce_get_value() != 8562 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_notarized_transaction_compile() != 62096 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_notary_signature_get_signature() != 52377 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_p2_p_link_to_json_bytes() != 16315 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_p2p_link_id() != 10640 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_p2p_links_to_json_bytes() != 12947 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_package_address_bech32_address() != 54775 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_package_address_formatted() != 8252 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_package_address_map_to_network() != 52718 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_package_address_network_id() != 5555 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_entry_email_address_to_json_string() != 18445 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_entry_name_to_json_bytes() != 54193 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_entry_phone_number_to_json_string() != 16974 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_identified_email_address_sample() != 52470 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_identified_email_address_sample_other() != 178 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_identified_name_sample() != 62267 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_identified_name_sample_other() != 16367 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_identified_phone_number_sample() != 32965 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_persona_data_identified_phone_number_sample_other() != 19226 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_pool_address_bech32_address() != 47256 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_pool_address_formatted() != 4906 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_pool_address_kind() != 54453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_pool_address_map_to_network() != 41332 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_pool_address_network_id() != 42097 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_profile_analyze_contents_of_file() != 10056 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_profile_encrypt_with_password() != 22486 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_profile_network_details_for_authorized_dapp() != 39168 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_profile_to_debug_string() != 1782 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_profile_to_json_string() != 61644 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_profile_to_string() != 25731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_public_key_is_valid_signature_for_hash() != 86 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_public_key_to_bytes() != 27512 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_public_key_to_hex() != 22162 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_radix_connect_mobile_session_request_to_json_bytes() != 63831 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_radix_connect_password_message_hash() != 2615 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_radix_connect_password_to_json_string() != 23214 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_radix_connect_purpose_to_json_string() != 51972 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_requested_quantity_is_fulfilled_by_ids() != 47126 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_requested_quantity_is_valid() != 61093 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_requested_quantity_to_json_bytes() != 57734 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_bech32_address() != 61503 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_formatted() != 44562 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_is_fungible() != 53819 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_is_non_fungible() != 50396 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_map_to_network() != 16830 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_address_network_id() != 26803 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_indicator_get_address() != 122 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_preferences_get_hidden_resources() != 1300 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_preferences_hide_resource() != 31299 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_preferences_unhide_resource() != 54430 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_resource_specifier_get_address() != 15388 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_rust_logger_get_all_filters() != 36490 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_rust_logger_get_all_levels() != 46428 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_rust_logger_get_level() != 40781 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_rust_logger_init() != 41198 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_rust_logger_log_at_every_level() != 28400 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_rust_logger_set_level() != 22953 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_s_l_i_p10_curve_to_json_string() != 41585 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_saved_gateways_get_all_elements() != 44642 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secp256k1_public_key_to_bytes() != 48737 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secp256k1_public_key_to_bytes_uncompressed() != 49512 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secp256k1_public_key_to_hex() != 62658 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secp256k1_signature_to_string() != 50053 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_secure_storage_key_identifier() != 30568 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_security_questions_all() != 59959 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_security_questions_factor_source_decrypt() != 12220 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signature_to_bytes() != 39380 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signature_to_string() != 61098 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signature_with_public_key_get_public_key() != 32591 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signature_with_public_key_get_signature() != 62703 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signature_with_public_key_is_valid() != 50388 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signed_intent_hash() != 12469 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_signed_intent_hash_formatted() != 44800 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_slip10_curve_to_string() != 45343 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_fee_preset() != 14032 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_intent_compile() != 48674 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_intent_hash() != 25944 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_blobs() != 45400 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_execution_summary() != 54879 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_instructions_string() != 28699 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_involved_pool_addresses() != 58037 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_involved_resource_addresses() != 11845 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_network_id() != 61620 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_transaction_manifest_summary() != 27199 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_trim_security_questions_answer() != 54045 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_unsafe_storage_key_identifier() != 32326 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_validator_address_bech32_address() != 16268 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_validator_address_formatted() != 12167 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_validator_address_map_to_network() != 57873 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_validator_address_network_id() != 45312 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_bech32_address() != 4501 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_formatted() != 63212 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_is_fungible() != 47259 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_is_non_fungible() != 44675 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_map_to_network() != 42813 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_vault_address_network_id() != 28367 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_wallet_interaction_wallet_account_to_json_bytes() != 44501 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_wallet_to_dapp_interaction_response_to_json_bytes() != 17356 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_func_xrd_address_of_network() != 8656 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_entropyproviderdriver_generate_secure_random_bytes() != 45285 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_eventbusdriver_handle_event_notification() != 42749 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_filesystemdriver_load_from_file() != 8637 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_filesystemdriver_save_to_file() != 8153 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_filesystemdriver_delete_file() != 52104 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_gatewayclient_current_epoch() != 23731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_gatewayclient_dry_run_transaction() != 148 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_gatewayclient_submit_notarized_transaction() != 36728 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_gatewayclient_xrd_balance_of_account() != 10716 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_gatewayclient_xrd_balance_of_account_or_zero() != 30651 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_homecardsmanager_bootstrap() != 33477 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_homecardsmanager_card_dismissed() != 34290 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_homecardsmanager_deferred_deep_link_received() != 4735 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_homecardsmanager_wallet_created() != 40911 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_homecardsmanager_wallet_reset() != 21943 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_homecardsmanager_wallet_restored() != 19027 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_homecardsobserver_handle_cards_update() != 41688 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_homecardsstorage_save_cards() != 3946 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_homecardsstorage_load_cards() != 38253 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_hostinfodriver_host_os() != 29707 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_hostinfodriver_host_device_name() != 9673 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_hostinfodriver_host_app_version() != 21633 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_hostinfodriver_host_device_model() != 29349 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_loggingdriver_log() != 10046 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_networkingdriver_execute_network_request() != 31432 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_profilestatechangedriver_handle_profile_state_change() != 17947 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_radixconnectmobile_handle_deep_link() != 52154 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_radixconnectmobile_send_dapp_interaction_response() != 1669 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_radixconnectmobilesessionstorage_save_session() != 5589 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_radixconnectmobilesessionstorage_load_session() != 5721 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_account_by_address() != 41408 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_accounts_for_display_on_current_network() != 16872 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_accounts_on_current_network() != 18914 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_add_account() != 8652 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_add_accounts() != 55041 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_add_factor_source() != 5802 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_add_factor_sources() != 32872 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_add_security_structure_of_factor_sources() != 47145 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_batch_create_many_accounts_then_save_once() != 55272 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_batch_create_unsaved_accounts() != 46948 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_bdfs() != 28574 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_change_current_gateway() != 36612 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_create_and_save_new_account() != 50786 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_create_and_save_new_mainnet_account() != 57882 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_create_and_save_new_unnamed_mainnet_account() != 57917 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_create_device_factor_source() != 35720 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_create_unsaved_account() != 27609 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_create_unsaved_mainnet_account() != 51558 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_create_unsaved_unnamed_mainnet_account() != 36994 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_current_gateway() != 35313 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_current_network() != 6085 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_current_network_id() != 28473 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_debug_add_all_sample_factors() != 14577 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_delete_wallet() != 45650 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_factor_sources() != 14061 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_gateways() != 8403 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_has_any_account_on_any_network() != 31083 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_has_any_network() != 20616 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_import_profile() != 12584 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_import_wallet() != 39456 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_load_private_device_factor_source_by_id() != 16527 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_new_wallet() != 29950 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_profile() != 20363 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_resolve_host_id() != 9894 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_resolve_host_info() != 20521 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_security_structure_of_factor_sources_from_security_structure_of_factor_source_ids() != 2073 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_security_structures_of_factor_source_ids() != 36388 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_security_structures_of_factor_sources() != 53447 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_set_profile() != 52975 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_update_account() != 20288 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_sargonos_update_factor_source() != 9646 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_securestoragedriver_load_data() != 64897 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_securestoragedriver_save_data() != 18629 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_securestoragedriver_delete_data_for_key() != 25137 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_unsafestoragedriver_load_data() != 51876 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_unsafestoragedriver_save_data() != 17823 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_method_unsafestoragedriver_delete_data_for_key() != 9675 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_bios_new() != 48809 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_drivers_new() != 31378 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_ffiurl_new() != 42451 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_gatewayclient_new() != 32041 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_gatewayclient_with_gateway() != 23914 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_homecardsmanager_new() != 10217 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_radixconnectmobile_new() != 42493 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_checksum_constructor_sargonos_boot() != 3002 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitEntropyProviderDriver()
    uniffiCallbackInitEventBusDriver()
    uniffiCallbackInitFileSystemDriver()
    uniffiCallbackInitHomeCardsObserver()
    uniffiCallbackInitHomeCardsStorage()
    uniffiCallbackInitHostInfoDriver()
    uniffiCallbackInitLoggingDriver()
    uniffiCallbackInitNetworkingDriver()
    uniffiCallbackInitProfileStateChangeDriver()
    uniffiCallbackInitRadixConnectMobileSessionStorage()
    uniffiCallbackInitSecureStorageDriver()
    uniffiCallbackInitUnsafeStorageDriver()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
