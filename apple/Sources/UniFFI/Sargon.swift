// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(SargonFFI)
import SargonFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_sargon_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_sargon_uniffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol ArculusCsdkDriver : AnyObject {
    
    func walletInit()  -> ArculusWalletPointer?
    
    func walletFree(wallet: ArculusWalletPointer) 
    
    func selectWalletRequest(wallet: ArculusWalletPointer, aid: BagOfBytes)  -> BagOfBytes?
    
    func selectWalletResponse(wallet: ArculusWalletPointer, response: BagOfBytes)  -> BagOfBytes?
    
    func createWalletSeedRequest(wallet: ArculusWalletPointer, wordCount: Int64)  -> BagOfBytes?
    
    func createWalletSeedResponse(wallet: ArculusWalletPointer, response: BagOfBytes)  -> BagOfBytes?
    
    func seedPhraseFromMnemonicSentence(wallet: ArculusWalletPointer, mnemonicSentence: BagOfBytes, passphrase: BagOfBytes?)  -> BagOfBytes?
    
    func initRecoverWalletRequest(wallet: ArculusWalletPointer, wordCount: Int64)  -> BagOfBytes?
    
    func initRecoverWalletResponse(wallet: ArculusWalletPointer, response: BagOfBytes)  -> Int32
    
    func finishRecoverWalletRequest(wallet: ArculusWalletPointer, seed: BagOfBytes)  -> BagOfBytes?
    
    func finishRecoverWalletResponse(wallet: ArculusWalletPointer, response: BagOfBytes)  -> Int32
    
    func resetWalletRequest(wallet: ArculusWalletPointer)  -> BagOfBytes?
    
    func resetWalletResponse(wallet: ArculusWalletPointer, response: BagOfBytes)  -> Int32
    
    func getGguidRequest(wallet: ArculusWalletPointer)  -> BagOfBytes?
    
    func getGguidResponse(wallet: ArculusWalletPointer, response: BagOfBytes)  -> BagOfBytes?
    
    func getFirmwareVersionRequest(wallet: ArculusWalletPointer)  -> BagOfBytes?
    
    func getFirmwareVersionResponse(wallet: ArculusWalletPointer, response: BagOfBytes)  -> BagOfBytes?
    
    func storeDataPinRequest(wallet: ArculusWalletPointer, pin: String)  -> BagOfBytes?
    
    func storeDataPinResponse(wallet: ArculusWalletPointer, response: BagOfBytes)  -> Int32
    
    func verifyPinRequest(wallet: ArculusWalletPointer, pin: String)  -> BagOfBytes?
    
    func verifyPinResponse(wallet: ArculusWalletPointer, response: BagOfBytes)  -> ArculusVerifyPinResponse
    
    func initEncryptedSessionRequest(wallet: ArculusWalletPointer)  -> BagOfBytes?
    
    func initEncryptedSessionResponse(wallet: ArculusWalletPointer, response: BagOfBytes)  -> Int32
    
    func getPublicKeyByPathRequest(wallet: ArculusWalletPointer, path: BagOfBytes, curve: UInt16)  -> BagOfBytes?
    
    func getPublicKeyByPathResponse(wallet: ArculusWalletPointer, response: BagOfBytes)  -> BagOfBytes?
    
    func signHashPathRequest(wallet: ArculusWalletPointer, path: BagOfBytes, curve: UInt16, algorithm: UInt8, hash: BagOfBytes)  -> [BagOfBytes]?
    
    func signHashPathResponse(wallet: ArculusWalletPointer, response: BagOfBytes)  -> BagOfBytes?
    
}

open class ArculusCsdkDriverImpl:
    ArculusCsdkDriver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_arculuscsdkdriver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_arculuscsdkdriver(pointer, $0) }
    }

    

    
open func walletInit() -> ArculusWalletPointer?  {
    return try!  FfiConverterOptionTypeArculusWalletPointer.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_wallet_init(self.uniffiClonePointer(),$0
    )
})
}
    
open func walletFree(wallet: ArculusWalletPointer)  {try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_wallet_free(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),$0
    )
}
}
    
open func selectWalletRequest(wallet: ArculusWalletPointer, aid: BagOfBytes) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_select_wallet_request(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(aid),$0
    )
})
}
    
open func selectWalletResponse(wallet: ArculusWalletPointer, response: BagOfBytes) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_select_wallet_response(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(response),$0
    )
})
}
    
open func createWalletSeedRequest(wallet: ArculusWalletPointer, wordCount: Int64) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_create_wallet_seed_request(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterInt64.lower(wordCount),$0
    )
})
}
    
open func createWalletSeedResponse(wallet: ArculusWalletPointer, response: BagOfBytes) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_create_wallet_seed_response(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(response),$0
    )
})
}
    
open func seedPhraseFromMnemonicSentence(wallet: ArculusWalletPointer, mnemonicSentence: BagOfBytes, passphrase: BagOfBytes?) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_seed_phrase_from_mnemonic_sentence(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(mnemonicSentence),
        FfiConverterOptionTypeBagOfBytes.lower(passphrase),$0
    )
})
}
    
open func initRecoverWalletRequest(wallet: ArculusWalletPointer, wordCount: Int64) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_init_recover_wallet_request(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterInt64.lower(wordCount),$0
    )
})
}
    
open func initRecoverWalletResponse(wallet: ArculusWalletPointer, response: BagOfBytes) -> Int32  {
    return try!  FfiConverterInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_init_recover_wallet_response(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(response),$0
    )
})
}
    
open func finishRecoverWalletRequest(wallet: ArculusWalletPointer, seed: BagOfBytes) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_finish_recover_wallet_request(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(seed),$0
    )
})
}
    
open func finishRecoverWalletResponse(wallet: ArculusWalletPointer, response: BagOfBytes) -> Int32  {
    return try!  FfiConverterInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_finish_recover_wallet_response(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(response),$0
    )
})
}
    
open func resetWalletRequest(wallet: ArculusWalletPointer) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_reset_wallet_request(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),$0
    )
})
}
    
open func resetWalletResponse(wallet: ArculusWalletPointer, response: BagOfBytes) -> Int32  {
    return try!  FfiConverterInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_reset_wallet_response(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(response),$0
    )
})
}
    
open func getGguidRequest(wallet: ArculusWalletPointer) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_get_gguid_request(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),$0
    )
})
}
    
open func getGguidResponse(wallet: ArculusWalletPointer, response: BagOfBytes) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_get_gguid_response(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(response),$0
    )
})
}
    
open func getFirmwareVersionRequest(wallet: ArculusWalletPointer) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_get_firmware_version_request(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),$0
    )
})
}
    
open func getFirmwareVersionResponse(wallet: ArculusWalletPointer, response: BagOfBytes) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_get_firmware_version_response(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(response),$0
    )
})
}
    
open func storeDataPinRequest(wallet: ArculusWalletPointer, pin: String) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_store_data_pin_request(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterString.lower(pin),$0
    )
})
}
    
open func storeDataPinResponse(wallet: ArculusWalletPointer, response: BagOfBytes) -> Int32  {
    return try!  FfiConverterInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_store_data_pin_response(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(response),$0
    )
})
}
    
open func verifyPinRequest(wallet: ArculusWalletPointer, pin: String) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_verify_pin_request(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterString.lower(pin),$0
    )
})
}
    
open func verifyPinResponse(wallet: ArculusWalletPointer, response: BagOfBytes) -> ArculusVerifyPinResponse  {
    return try!  FfiConverterTypeArculusVerifyPINResponse.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_verify_pin_response(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(response),$0
    )
})
}
    
open func initEncryptedSessionRequest(wallet: ArculusWalletPointer) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_init_encrypted_session_request(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),$0
    )
})
}
    
open func initEncryptedSessionResponse(wallet: ArculusWalletPointer, response: BagOfBytes) -> Int32  {
    return try!  FfiConverterInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_init_encrypted_session_response(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(response),$0
    )
})
}
    
open func getPublicKeyByPathRequest(wallet: ArculusWalletPointer, path: BagOfBytes, curve: UInt16) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_get_public_key_by_path_request(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(path),
        FfiConverterUInt16.lower(curve),$0
    )
})
}
    
open func getPublicKeyByPathResponse(wallet: ArculusWalletPointer, response: BagOfBytes) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_get_public_key_by_path_response(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(response),$0
    )
})
}
    
open func signHashPathRequest(wallet: ArculusWalletPointer, path: BagOfBytes, curve: UInt16, algorithm: UInt8, hash: BagOfBytes) -> [BagOfBytes]?  {
    return try!  FfiConverterOptionSequenceTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_sign_hash_path_request(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(path),
        FfiConverterUInt16.lower(curve),
        FfiConverterUInt8.lower(algorithm),
        FfiConverterTypeBagOfBytes.lower(hash),$0
    )
})
}
    
open func signHashPathResponse(wallet: ArculusWalletPointer, response: BagOfBytes) -> BagOfBytes?  {
    return try!  FfiConverterOptionTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_arculuscsdkdriver_sign_hash_path_response(self.uniffiClonePointer(),
        FfiConverterTypeArculusWalletPointer.lower(wallet),
        FfiConverterTypeBagOfBytes.lower(response),$0
    )
})
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceArculusCSDKDriver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceArculusCsdkDriver] = [UniffiVTableCallbackInterfaceArculusCsdkDriver(
        walletInit: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> ArculusWalletPointer? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.walletInit(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeArculusWalletPointer.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        walletFree: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.walletFree(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        selectWalletRequest: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            aid: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.selectWalletRequest(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     aid: try FfiConverterTypeBagOfBytes.lift(aid)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        selectWalletResponse: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            response: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.selectWalletResponse(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     response: try FfiConverterTypeBagOfBytes.lift(response)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        createWalletSeedRequest: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            wordCount: Int64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.createWalletSeedRequest(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     wordCount: try FfiConverterInt64.lift(wordCount)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        createWalletSeedResponse: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            response: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.createWalletSeedResponse(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     response: try FfiConverterTypeBagOfBytes.lift(response)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        seedPhraseFromMnemonicSentence: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            mnemonicSentence: RustBuffer,
            passphrase: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.seedPhraseFromMnemonicSentence(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     mnemonicSentence: try FfiConverterTypeBagOfBytes.lift(mnemonicSentence),
                     passphrase: try FfiConverterOptionTypeBagOfBytes.lift(passphrase)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        initRecoverWalletRequest: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            wordCount: Int64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.initRecoverWalletRequest(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     wordCount: try FfiConverterInt64.lift(wordCount)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        initRecoverWalletResponse: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            response: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int32>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Int32 in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.initRecoverWalletResponse(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     response: try FfiConverterTypeBagOfBytes.lift(response)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterInt32.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        finishRecoverWalletRequest: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            seed: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.finishRecoverWalletRequest(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     seed: try FfiConverterTypeBagOfBytes.lift(seed)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        finishRecoverWalletResponse: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            response: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int32>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Int32 in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.finishRecoverWalletResponse(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     response: try FfiConverterTypeBagOfBytes.lift(response)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterInt32.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        resetWalletRequest: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.resetWalletRequest(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        resetWalletResponse: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            response: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int32>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Int32 in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.resetWalletResponse(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     response: try FfiConverterTypeBagOfBytes.lift(response)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterInt32.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        getGguidRequest: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.getGguidRequest(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        getGguidResponse: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            response: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.getGguidResponse(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     response: try FfiConverterTypeBagOfBytes.lift(response)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        getFirmwareVersionRequest: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.getFirmwareVersionRequest(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        getFirmwareVersionResponse: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            response: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.getFirmwareVersionResponse(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     response: try FfiConverterTypeBagOfBytes.lift(response)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        storeDataPinRequest: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            pin: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.storeDataPinRequest(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     pin: try FfiConverterString.lift(pin)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        storeDataPinResponse: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            response: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int32>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Int32 in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.storeDataPinResponse(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     response: try FfiConverterTypeBagOfBytes.lift(response)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterInt32.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        verifyPinRequest: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            pin: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.verifyPinRequest(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     pin: try FfiConverterString.lift(pin)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        verifyPinResponse: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            response: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> ArculusVerifyPinResponse in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.verifyPinResponse(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     response: try FfiConverterTypeBagOfBytes.lift(response)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeArculusVerifyPINResponse.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        initEncryptedSessionRequest: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.initEncryptedSessionRequest(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        initEncryptedSessionResponse: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            response: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int32>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Int32 in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.initEncryptedSessionResponse(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     response: try FfiConverterTypeBagOfBytes.lift(response)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterInt32.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        getPublicKeyByPathRequest: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            path: RustBuffer,
            curve: UInt16,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.getPublicKeyByPathRequest(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     path: try FfiConverterTypeBagOfBytes.lift(path),
                     curve: try FfiConverterUInt16.lift(curve)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        getPublicKeyByPathResponse: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            response: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.getPublicKeyByPathResponse(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     response: try FfiConverterTypeBagOfBytes.lift(response)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        signHashPathRequest: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            path: RustBuffer,
            curve: UInt16,
            algorithm: UInt8,
            hash: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> [BagOfBytes]? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.signHashPathRequest(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     path: try FfiConverterTypeBagOfBytes.lift(path),
                     curve: try FfiConverterUInt16.lift(curve),
                     algorithm: try FfiConverterUInt8.lift(algorithm),
                     hash: try FfiConverterTypeBagOfBytes.lift(hash)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionSequenceTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        signHashPathResponse: { (
            uniffiHandle: UInt64,
            wallet: RustBuffer,
            response: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeArculusCSDKDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.signHashPathResponse(
                     wallet: try FfiConverterTypeArculusWalletPointer.lift(wallet),
                     response: try FfiConverterTypeBagOfBytes.lift(response)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionTypeBagOfBytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeArculusCSDKDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ArculusCSDKDriver: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitArculusCSDKDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_arculuscsdkdriver(UniffiCallbackInterfaceArculusCSDKDriver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeArculusCSDKDriver: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<ArculusCsdkDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ArculusCsdkDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ArculusCsdkDriver {
        return ArculusCsdkDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ArculusCsdkDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCsdkDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ArculusCsdkDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusCSDKDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> ArculusCsdkDriver {
    return try FfiConverterTypeArculusCSDKDriver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusCSDKDriver_lower(_ value: ArculusCsdkDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeArculusCSDKDriver.lower(value)
}




public protocol BiosProtocol : AnyObject {
    
}

open class Bios:
    BiosProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_bios(self.pointer, $0) }
    }
public convenience init(drivers: Drivers) {
    let pointer =
        try! rustCall() {
    uniffi_sargon_uniffi_fn_constructor_bios_new(
        FfiConverterTypeDrivers.lower(drivers),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_bios(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBios: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bios

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bios {
        return Bios(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bios) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bios {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bios, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBios_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bios {
    return try FfiConverterTypeBios.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBios_lower(_ value: Bios) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBios.lower(value)
}




public protocol BlogPostsClientProtocol : AnyObject {
    
    func getBlogPosts() async throws  -> BlogPosts
    
}

open class BlogPostsClient:
    BlogPostsClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_blogpostsclient(self.pointer, $0) }
    }
public convenience init(networkingDriver: NetworkingDriver, fileSystemDriver: FileSystemDriver) {
    let pointer =
        try! rustCall() {
    uniffi_sargon_uniffi_fn_constructor_blogpostsclient_new(
        FfiConverterTypeNetworkingDriver.lower(networkingDriver),
        FfiConverterTypeFileSystemDriver.lower(fileSystemDriver),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_blogpostsclient(pointer, $0) }
    }

    

    
open func getBlogPosts()async throws  -> BlogPosts  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_blogpostsclient_get_blog_posts(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeBlogPosts.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlogPostsClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BlogPostsClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BlogPostsClient {
        return BlogPostsClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BlogPostsClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlogPostsClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BlogPostsClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlogPostsClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> BlogPostsClient {
    return try FfiConverterTypeBlogPostsClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlogPostsClient_lower(_ value: BlogPostsClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBlogPostsClient.lower(value)
}




public protocol DriversProtocol : AnyObject {
    
}

open class Drivers:
    DriversProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_drivers(self.pointer, $0) }
    }
public convenience init(networking: NetworkingDriver, secureStorage: SecureStorageDriver, entropyProvider: EntropyProviderDriver, hostInfo: HostInfoDriver, logging: LoggingDriver, eventBus: EventBusDriver, fileSystem: FileSystemDriver, unsafeStorage: UnsafeStorageDriver, profileStateChangeDriver: ProfileStateChangeDriver, arculusCsdkDriver: ArculusCsdkDriver, nfcTagDriver: NfcTagDriver) {
    let pointer =
        try! rustCall() {
    uniffi_sargon_uniffi_fn_constructor_drivers_new(
        FfiConverterTypeNetworkingDriver.lower(networking),
        FfiConverterTypeSecureStorageDriver.lower(secureStorage),
        FfiConverterTypeEntropyProviderDriver.lower(entropyProvider),
        FfiConverterTypeHostInfoDriver.lower(hostInfo),
        FfiConverterTypeLoggingDriver.lower(logging),
        FfiConverterTypeEventBusDriver.lower(eventBus),
        FfiConverterTypeFileSystemDriver.lower(fileSystem),
        FfiConverterTypeUnsafeStorageDriver.lower(unsafeStorage),
        FfiConverterTypeProfileStateChangeDriver.lower(profileStateChangeDriver),
        FfiConverterTypeArculusCSDKDriver.lower(arculusCsdkDriver),
        FfiConverterTypeNFCTagDriver.lower(nfcTagDriver),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_drivers(pointer, $0) }
    }

    

    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDrivers: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Drivers

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Drivers {
        return Drivers(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Drivers) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Drivers {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Drivers, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDrivers_lift(_ pointer: UnsafeMutableRawPointer) throws -> Drivers {
    return try FfiConverterTypeDrivers.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDrivers_lower(_ value: Drivers) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDrivers.lower(value)
}




public protocol EntropyProviderDriver : AnyObject {
    
    func generateSecureRandomBytes()  -> Entropy32Bytes
    
}

open class EntropyProviderDriverImpl:
    EntropyProviderDriver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_entropyproviderdriver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_entropyproviderdriver(pointer, $0) }
    }

    

    
open func generateSecureRandomBytes() -> Entropy32Bytes  {
    return try!  FfiConverterTypeEntropy32Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_entropyproviderdriver_generate_secure_random_bytes(self.uniffiClonePointer(),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceEntropyProviderDriver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceEntropyProviderDriver] = [UniffiVTableCallbackInterfaceEntropyProviderDriver(
        generateSecureRandomBytes: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Entropy32Bytes in
                guard let uniffiObj = try? FfiConverterTypeEntropyProviderDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.generateSecureRandomBytes(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeEntropy32Bytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeEntropyProviderDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EntropyProviderDriver: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitEntropyProviderDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_entropyproviderdriver(UniffiCallbackInterfaceEntropyProviderDriver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntropyProviderDriver: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<EntropyProviderDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EntropyProviderDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EntropyProviderDriver {
        return EntropyProviderDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EntropyProviderDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntropyProviderDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EntropyProviderDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntropyProviderDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> EntropyProviderDriver {
    return try FfiConverterTypeEntropyProviderDriver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntropyProviderDriver_lower(_ value: EntropyProviderDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEntropyProviderDriver.lower(value)
}




/**
 * A driver which received and asynchronously *handles* event notifications
 * emitted by the `SargonOS`. Letting the method be async allows for Rust side
 * to wait for host clients to complete something which might require user
 * attention. E.g. presentation of an alert and await user input.
 *
 * Due to limitations in UniFFI and lack of first class citizen support of
 * async sequences (like we have in Swift) we cannot export an accessor of the
 * received events here. Instead implementing types on the FFI side SHOULD
 * create the driver as a singleton object they can reference later and build
 * async streams in that implementing type.
 *
 * See Swifts EventBus implementation for more details.
 */
public protocol EventBusDriver : AnyObject {
    
    /**
     * Asynchronously *handles* event notifications
     * emitted by the `SargonOS`. Letting the method be async allows for Rust side
     * to wait for host clients to complete something which might require user
     * attention. E.g. presentation of an alert and await user input.
     */
    func handleEventNotification(eventNotification: EventNotification) async 
    
}

/**
 * A driver which received and asynchronously *handles* event notifications
 * emitted by the `SargonOS`. Letting the method be async allows for Rust side
 * to wait for host clients to complete something which might require user
 * attention. E.g. presentation of an alert and await user input.
 *
 * Due to limitations in UniFFI and lack of first class citizen support of
 * async sequences (like we have in Swift) we cannot export an accessor of the
 * received events here. Instead implementing types on the FFI side SHOULD
 * create the driver as a singleton object they can reference later and build
 * async streams in that implementing type.
 *
 * See Swifts EventBus implementation for more details.
 */
open class EventBusDriverImpl:
    EventBusDriver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_eventbusdriver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_eventbusdriver(pointer, $0) }
    }

    

    
    /**
     * Asynchronously *handles* event notifications
     * emitted by the `SargonOS`. Letting the method be async allows for Rust side
     * to wait for host clients to complete something which might require user
     * attention. E.g. presentation of an alert and await user input.
     */
open func handleEventNotification(eventNotification: EventNotification)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_eventbusdriver_handle_event_notification(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEventNotification.lower(eventNotification)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceEventBusDriver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceEventBusDriver] = [UniffiVTableCallbackInterfaceEventBusDriver(
        handleEventNotification: { (
            uniffiHandle: UInt64,
            eventNotification: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeEventBusDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.handleEventNotification(
                     eventNotification: try FfiConverterTypeEventNotification.lift(eventNotification)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeEventBusDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EventBusDriver: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitEventBusDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_eventbusdriver(UniffiCallbackInterfaceEventBusDriver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventBusDriver: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<EventBusDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventBusDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBusDriver {
        return EventBusDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventBusDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventBusDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventBusDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventBusDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBusDriver {
    return try FfiConverterTypeEventBusDriver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventBusDriver_lower(_ value: EventBusDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventBusDriver.lower(value)
}




/**
 * A wrapper around `Url` that allows us to safely deal with Urls generated on hosts.
 *
 * Context: We have defined a custom type conversion between Rust's `Url` and the hosts analogues.
 * However, a Url could be considered valid on host but not on Rust. For example, Swift allows to build a Url
 * from string `"invalid input"`, while Rust doesn't.
 *
 * Therefore, if a given Rust function expects a `Url` as param and is sent one from host side which is invalid,
 * the code will panic. However, if we send the wrapper instead, we make sure the conversion is safely done on the
 * host side, dealing with the failing conversion properly rather than panicking.
 */
public protocol FfiUrlProtocol : AnyObject {
    
}

/**
 * A wrapper around `Url` that allows us to safely deal with Urls generated on hosts.
 *
 * Context: We have defined a custom type conversion between Rust's `Url` and the hosts analogues.
 * However, a Url could be considered valid on host but not on Rust. For example, Swift allows to build a Url
 * from string `"invalid input"`, while Rust doesn't.
 *
 * Therefore, if a given Rust function expects a `Url` as param and is sent one from host side which is invalid,
 * the code will panic. However, if we send the wrapper instead, we make sure the conversion is safely done on the
 * host side, dealing with the failing conversion properly rather than panicking.
 */
open class FfiUrl:
    CustomDebugStringConvertible,
    CustomStringConvertible,
    Equatable,
    Hashable,
    FfiUrlProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_ffiurl(self.pointer, $0) }
    }
public convenience init(urlPath: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_constructor_ffiurl_new(
        FfiConverterString.lower(urlPath),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_ffiurl(pointer, $0) }
    }

    

    
    open var debugDescription: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_sargon_uniffi_fn_method_ffiurl_uniffi_trait_debug(self.uniffiClonePointer(),$0
    )
}
        )
    }
    open var description: String {
        return try!  FfiConverterString.lift(
            try! rustCall() {
    uniffi_sargon_uniffi_fn_method_ffiurl_uniffi_trait_display(self.uniffiClonePointer(),$0
    )
}
        )
    }
    public static func == (self: FfiUrl, other: FfiUrl) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_sargon_uniffi_fn_method_ffiurl_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeFfiUrl.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_sargon_uniffi_fn_method_ffiurl_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiUrl: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiUrl

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUrl {
        return FfiUrl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiUrl) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUrl {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiUrl, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiUrl_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUrl {
    return try FfiConverterTypeFfiUrl.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiUrl_lower(_ value: FfiUrl) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiUrl.lower(value)
}




public protocol FileSystemDriver : AnyObject {
    
    func writableAppDirPath() async throws  -> String
    
    func loadFromFile(path: String) async throws  -> BagOfBytes?
    
    func saveToFile(path: String, data: BagOfBytes, isAllowedToOverwrite: Bool) async throws 
    
    func deleteFile(path: String) async throws 
    
}

open class FileSystemDriverImpl:
    FileSystemDriver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_filesystemdriver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_filesystemdriver(pointer, $0) }
    }

    

    
open func writableAppDirPath()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_filesystemdriver_writable_app_dir_path(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func loadFromFile(path: String)async throws  -> BagOfBytes?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_filesystemdriver_load_from_file(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(path)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func saveToFile(path: String, data: BagOfBytes, isAllowedToOverwrite: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_filesystemdriver_save_to_file(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(path),FfiConverterTypeBagOfBytes.lower(data),FfiConverterBool.lower(isAllowedToOverwrite)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func deleteFile(path: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_filesystemdriver_delete_file(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(path)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFileSystemDriver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFileSystemDriver] = [UniffiVTableCallbackInterfaceFileSystemDriver(
        writableAppDirPath: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.writableAppDirPath(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        loadFromFile: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadFromFile(
                     path: try FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        saveToFile: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            data: RustBuffer,
            isAllowedToOverwrite: Int8,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveToFile(
                     path: try FfiConverterString.lift(path),
                     data: try FfiConverterTypeBagOfBytes.lift(data),
                     isAllowedToOverwrite: try FfiConverterBool.lift(isAllowedToOverwrite)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteFile: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteFile(
                     path: try FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFileSystemDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FileSystemDriver: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFileSystemDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_filesystemdriver(UniffiCallbackInterfaceFileSystemDriver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileSystemDriver: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FileSystemDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FileSystemDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FileSystemDriver {
        return FileSystemDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FileSystemDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileSystemDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FileSystemDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileSystemDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> FileSystemDriver {
    return try FfiConverterTypeFileSystemDriver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileSystemDriver_lower(_ value: FileSystemDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFileSystemDriver.lower(value)
}




/**
 * Manages the home cards by handling storage, parsing, and updating operations.
 * Call `bootstrap` before invoking any other public functions.
 */
public protocol HomeCardsManagerProtocol : AnyObject {
    
    /**
     * Initializes `HomeCards` by loading from storage.
     * This function should be called before invoking any other public functions.
     * Notifies `HomeCardsObserver`.
     */
    func bootstrap() async throws 
    
    /**
     * Dismisses a specified `HomeCard` by removing it from `HomeCardsStorage`.
     * Notifies `HomeCardsObserver`.
     */
    func cardDismissed(card: HomeCard) async throws 
    
    /**
     * Handles a deferred deep link by parsing it and saving the generated `HomeCards` to `HomeCardsStorage`.
     * `HomeCard::ContinueRadQuest` if found in the link parsing result, replaces `HomeCard::StartRadQuest`.
     * Notifies `HomeCardsObserver`.
     */
    func deferredDeepLinkReceived(encodedValue: String) async throws 
    
    /**
     * Initializes and saves to storage default `HomeCards`.
     * Marks the wallet creation and populates the set of cards required for a new wallet.
     * Notifies `HomeCardsObserver`.
     */
    func walletCreated() async throws 
    
    /**
     * Clears the home cards from the `HomeCardsStorage`.
     * Notifies `HomeCardsObserver`.
     */
    func walletReset() async throws 
    
    /**
     * Marks the wallet restoration.
     * Ensures only the expected `HomeCards` remain in `HomeCardsStorage` - currently none.
     * Notifies `HomeCardsObserver`.
     */
    func walletRestored() async throws 
    
}

/**
 * Manages the home cards by handling storage, parsing, and updating operations.
 * Call `bootstrap` before invoking any other public functions.
 */
open class HomeCardsManager:
    HomeCardsManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_homecardsmanager(self.pointer, $0) }
    }
public convenience init(networkingDriver: NetworkingDriver, networkId: NetworkId, cardsStorage: HomeCardsStorage, observer: HomeCardsObserver) {
    let pointer =
        try! rustCall() {
    uniffi_sargon_uniffi_fn_constructor_homecardsmanager_new(
        FfiConverterTypeNetworkingDriver.lower(networkingDriver),
        FfiConverterTypeNetworkID.lower(networkId),
        FfiConverterTypeHomeCardsStorage.lower(cardsStorage),
        FfiConverterTypeHomeCardsObserver.lower(observer),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_homecardsmanager(pointer, $0) }
    }

    

    
    /**
     * Initializes `HomeCards` by loading from storage.
     * This function should be called before invoking any other public functions.
     * Notifies `HomeCardsObserver`.
     */
open func bootstrap()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_homecardsmanager_bootstrap(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Dismisses a specified `HomeCard` by removing it from `HomeCardsStorage`.
     * Notifies `HomeCardsObserver`.
     */
open func cardDismissed(card: HomeCard)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_homecardsmanager_card_dismissed(
                    self.uniffiClonePointer(),
                    FfiConverterTypeHomeCard.lower(card)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Handles a deferred deep link by parsing it and saving the generated `HomeCards` to `HomeCardsStorage`.
     * `HomeCard::ContinueRadQuest` if found in the link parsing result, replaces `HomeCard::StartRadQuest`.
     * Notifies `HomeCardsObserver`.
     */
open func deferredDeepLinkReceived(encodedValue: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_homecardsmanager_deferred_deep_link_received(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(encodedValue)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Initializes and saves to storage default `HomeCards`.
     * Marks the wallet creation and populates the set of cards required for a new wallet.
     * Notifies `HomeCardsObserver`.
     */
open func walletCreated()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_homecardsmanager_wallet_created(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Clears the home cards from the `HomeCardsStorage`.
     * Notifies `HomeCardsObserver`.
     */
open func walletReset()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_homecardsmanager_wallet_reset(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Marks the wallet restoration.
     * Ensures only the expected `HomeCards` remain in `HomeCardsStorage` - currently none.
     * Notifies `HomeCardsObserver`.
     */
open func walletRestored()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_homecardsmanager_wallet_restored(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHomeCardsManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeCardsManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsManager {
        return HomeCardsManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeCardsManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCardsManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeCardsManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHomeCardsManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsManager {
    return try FfiConverterTypeHomeCardsManager.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHomeCardsManager_lower(_ value: HomeCardsManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeCardsManager.lower(value)
}




/**
 * Trait for observing home cards updates.
 * Defines a method for handling updates to home cards.
 */
public protocol HomeCardsObserver : AnyObject {
    
    /**
     * Handles updates to the home cards.
     */
    func handleCardsUpdate(cards: [HomeCard]) 
    
}

/**
 * Trait for observing home cards updates.
 * Defines a method for handling updates to home cards.
 */
open class HomeCardsObserverImpl:
    HomeCardsObserver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_homecardsobserver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_homecardsobserver(pointer, $0) }
    }

    

    
    /**
     * Handles updates to the home cards.
     */
open func handleCardsUpdate(cards: [HomeCard])  {try! rustCall() {
    uniffi_sargon_uniffi_fn_method_homecardsobserver_handle_cards_update(self.uniffiClonePointer(),
        FfiConverterSequenceTypeHomeCard.lower(cards),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceHomeCardsObserver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceHomeCardsObserver] = [UniffiVTableCallbackInterfaceHomeCardsObserver(
        handleCardsUpdate: { (
            uniffiHandle: UInt64,
            cards: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeHomeCardsObserver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.handleCardsUpdate(
                     cards: try FfiConverterSequenceTypeHomeCard.lift(cards)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeHomeCardsObserver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HomeCardsObserver: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitHomeCardsObserver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_homecardsobserver(UniffiCallbackInterfaceHomeCardsObserver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHomeCardsObserver: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<HomeCardsObserver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeCardsObserver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsObserver {
        return HomeCardsObserverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeCardsObserver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCardsObserver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeCardsObserver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHomeCardsObserver_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsObserver {
    return try FfiConverterTypeHomeCardsObserver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHomeCardsObserver_lower(_ value: HomeCardsObserver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeCardsObserver.lower(value)
}




/**
 * A trait for storing and loading home cards.
 * Defines asynchronous methods for saving and loading encoded home cards.
 */
public protocol HomeCardsStorage : AnyObject {
    
    /**
     * Saves the encoded home cards to the storage.
     */
    func saveCards(encodedCards: BagOfBytes) async throws 
    
    /**
     * Loads the encoded home cards from the storage.
     */
    func loadCards() async throws  -> BagOfBytes?
    
    /**
     * Saves the encoded dismissed home cards to the storage.
     */
    func saveDismissedCards(encodedCards: BagOfBytes) async throws 
    
    /**
     * Loads the encoded dismissed home cards from the storage.
     */
    func loadDismissedCards() async throws  -> BagOfBytes?
    
}

/**
 * A trait for storing and loading home cards.
 * Defines asynchronous methods for saving and loading encoded home cards.
 */
open class HomeCardsStorageImpl:
    HomeCardsStorage {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_homecardsstorage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_homecardsstorage(pointer, $0) }
    }

    

    
    /**
     * Saves the encoded home cards to the storage.
     */
open func saveCards(encodedCards: BagOfBytes)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_homecardsstorage_save_cards(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBagOfBytes.lower(encodedCards)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Loads the encoded home cards from the storage.
     */
open func loadCards()async throws  -> BagOfBytes?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_homecardsstorage_load_cards(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Saves the encoded dismissed home cards to the storage.
     */
open func saveDismissedCards(encodedCards: BagOfBytes)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_homecardsstorage_save_dismissed_cards(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBagOfBytes.lower(encodedCards)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Loads the encoded dismissed home cards from the storage.
     */
open func loadDismissedCards()async throws  -> BagOfBytes?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_homecardsstorage_load_dismissed_cards(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceHomeCardsStorage {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceHomeCardsStorage] = [UniffiVTableCallbackInterfaceHomeCardsStorage(
        saveCards: { (
            uniffiHandle: UInt64,
            encodedCards: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeHomeCardsStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveCards(
                     encodedCards: try FfiConverterTypeBagOfBytes.lift(encodedCards)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        loadCards: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeHomeCardsStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadCards(
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        saveDismissedCards: { (
            uniffiHandle: UInt64,
            encodedCards: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeHomeCardsStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveDismissedCards(
                     encodedCards: try FfiConverterTypeBagOfBytes.lift(encodedCards)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        loadDismissedCards: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeHomeCardsStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadDismissedCards(
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeHomeCardsStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HomeCardsStorage: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitHomeCardsStorage() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_homecardsstorage(UniffiCallbackInterfaceHomeCardsStorage.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHomeCardsStorage: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<HomeCardsStorage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeCardsStorage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsStorage {
        return HomeCardsStorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeCardsStorage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCardsStorage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeCardsStorage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHomeCardsStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsStorage {
    return try FfiConverterTypeHomeCardsStorage.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHomeCardsStorage_lower(_ value: HomeCardsStorage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeCardsStorage.lower(value)
}




public protocol HostInfoDriver : AnyObject {
    
    /**
     * The **current** device's operating system, e.g. "iOS 17.4.1"
     */
    func hostOs() async  -> HostOs
    
    /**
     * The name of the host device (iPhone/Android), e.g. "My Red iPhone"
     */
    func hostDeviceName() async  -> String
    
    /**
     * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1".
     */
    func hostAppVersion() async  -> String
    
    /**
     * The model of the host device (iPhone/Android), .e.g. "iPhone SE 2nd Gen"
     */
    func hostDeviceModel() async  -> String
    
}

open class HostInfoDriverImpl:
    HostInfoDriver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_hostinfodriver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_hostinfodriver(pointer, $0) }
    }

    

    
    /**
     * The **current** device's operating system, e.g. "iOS 17.4.1"
     */
open func hostOs()async  -> HostOs  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_hostinfodriver_host_os(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeHostOS.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * The name of the host device (iPhone/Android), e.g. "My Red iPhone"
     */
open func hostDeviceName()async  -> String  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_hostinfodriver_host_device_name(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1".
     */
open func hostAppVersion()async  -> String  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_hostinfodriver_host_app_version(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * The model of the host device (iPhone/Android), .e.g. "iPhone SE 2nd Gen"
     */
open func hostDeviceModel()async  -> String  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_hostinfodriver_host_device_model(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceHostInfoDriver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceHostInfoDriver] = [UniffiVTableCallbackInterfaceHostInfoDriver(
        hostOs: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> HostOs in
                guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hostOs(
                )
            }

            let uniffiHandleSuccess = { (returnValue: HostOs) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeHostOS.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        hostDeviceName: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hostDeviceName(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        hostAppVersion: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hostAppVersion(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        hostDeviceModel: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hostDeviceModel(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeHostInfoDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HostInfoDriver: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitHostInfoDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_hostinfodriver(UniffiCallbackInterfaceHostInfoDriver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHostInfoDriver: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<HostInfoDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HostInfoDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HostInfoDriver {
        return HostInfoDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HostInfoDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostInfoDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HostInfoDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHostInfoDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> HostInfoDriver {
    return try FfiConverterTypeHostInfoDriver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHostInfoDriver_lower(_ value: HostInfoDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHostInfoDriver.lower(value)
}




/**
 * Sargon os
 */
public protocol HostInteractor : AnyObject {
    
    func signTransactions(request: SignRequestOfTransactionIntent) async throws  -> SignResponseOfTransactionIntentHash
    
    func signSubintents(request: SignRequestOfSubintent) async throws  -> SignResponseOfSubintentHash
    
    func deriveKeys(request: KeyDerivationRequest) async throws  -> KeyDerivationResponse
    
    func signAuth(request: SignRequestOfAuthIntent) async throws  -> SignResponseOfAuthIntentHash
    
    func requestAuthorization(purpose: AuthorizationPurpose) async  -> AuthorizationResponse
    
    func spotCheck(factorSource: FactorSource, allowSkip: Bool) async throws  -> SpotCheckResponse
    
}

/**
 * Sargon os
 */
open class HostInteractorImpl:
    HostInteractor {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_hostinteractor(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_hostinteractor(pointer, $0) }
    }

    

    
open func signTransactions(request: SignRequestOfTransactionIntent)async throws  -> SignResponseOfTransactionIntentHash  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_hostinteractor_sign_transactions(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSignRequestOfTransactionIntent.lower(request)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSignResponseOfTransactionIntentHash.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func signSubintents(request: SignRequestOfSubintent)async throws  -> SignResponseOfSubintentHash  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_hostinteractor_sign_subintents(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSignRequestOfSubintent.lower(request)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSignResponseOfSubintentHash.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func deriveKeys(request: KeyDerivationRequest)async throws  -> KeyDerivationResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_hostinteractor_derive_keys(
                    self.uniffiClonePointer(),
                    FfiConverterTypeKeyDerivationRequest.lower(request)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeKeyDerivationResponse.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func signAuth(request: SignRequestOfAuthIntent)async throws  -> SignResponseOfAuthIntentHash  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_hostinteractor_sign_auth(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSignRequestOfAuthIntent.lower(request)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSignResponseOfAuthIntentHash.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func requestAuthorization(purpose: AuthorizationPurpose)async  -> AuthorizationResponse  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_hostinteractor_request_authorization(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAuthorizationPurpose.lower(purpose)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAuthorizationResponse.lift,
            errorHandler: nil
            
        )
}
    
open func spotCheck(factorSource: FactorSource, allowSkip: Bool)async throws  -> SpotCheckResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_hostinteractor_spot_check(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSource.lower(factorSource),FfiConverterBool.lower(allowSkip)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSpotCheckResponse.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceHostInteractor {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceHostInteractor] = [UniffiVTableCallbackInterfaceHostInteractor(
        signTransactions: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> SignResponseOfTransactionIntentHash in
                guard let uniffiObj = try? FfiConverterTypeHostInteractor.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.signTransactions(
                     request: try FfiConverterTypeSignRequestOfTransactionIntent.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: SignResponseOfTransactionIntentHash) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeSignResponseOfTransactionIntentHash.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        signSubintents: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> SignResponseOfSubintentHash in
                guard let uniffiObj = try? FfiConverterTypeHostInteractor.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.signSubintents(
                     request: try FfiConverterTypeSignRequestOfSubintent.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: SignResponseOfSubintentHash) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeSignResponseOfSubintentHash.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deriveKeys: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> KeyDerivationResponse in
                guard let uniffiObj = try? FfiConverterTypeHostInteractor.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deriveKeys(
                     request: try FfiConverterTypeKeyDerivationRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: KeyDerivationResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeKeyDerivationResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        signAuth: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> SignResponseOfAuthIntentHash in
                guard let uniffiObj = try? FfiConverterTypeHostInteractor.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.signAuth(
                     request: try FfiConverterTypeSignRequestOfAuthIntent.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: SignResponseOfAuthIntentHash) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeSignResponseOfAuthIntentHash.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        requestAuthorization: { (
            uniffiHandle: UInt64,
            purpose: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> AuthorizationResponse in
                guard let uniffiObj = try? FfiConverterTypeHostInteractor.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.requestAuthorization(
                     purpose: try FfiConverterTypeAuthorizationPurpose.lift(purpose)
                )
            }

            let uniffiHandleSuccess = { (returnValue: AuthorizationResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeAuthorizationResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        spotCheck: { (
            uniffiHandle: UInt64,
            factorSource: RustBuffer,
            allowSkip: Int8,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> SpotCheckResponse in
                guard let uniffiObj = try? FfiConverterTypeHostInteractor.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.spotCheck(
                     factorSource: try FfiConverterTypeFactorSource.lift(factorSource),
                     allowSkip: try FfiConverterBool.lift(allowSkip)
                )
            }

            let uniffiHandleSuccess = { (returnValue: SpotCheckResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeSpotCheckResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeHostInteractor.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HostInteractor: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitHostInteractor() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_hostinteractor(UniffiCallbackInterfaceHostInteractor.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHostInteractor: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<HostInteractor>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HostInteractor

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HostInteractor {
        return HostInteractorImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HostInteractor) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostInteractor {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HostInteractor, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHostInteractor_lift(_ pointer: UnsafeMutableRawPointer) throws -> HostInteractor {
    return try FfiConverterTypeHostInteractor.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHostInteractor_lower(_ value: HostInteractor) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHostInteractor.lower(value)
}




/**
 * * Trace
 * * Debug
 * * Info
 * * Warning
 * * Error
 */
public protocol LoggingDriver : AnyObject {
    
    func log(level: LogLevel, msg: String) 
    
}

/**
 * * Trace
 * * Debug
 * * Info
 * * Warning
 * * Error
 */
open class LoggingDriverImpl:
    LoggingDriver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_loggingdriver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_loggingdriver(pointer, $0) }
    }

    

    
open func log(level: LogLevel, msg: String)  {try! rustCall() {
    uniffi_sargon_uniffi_fn_method_loggingdriver_log(self.uniffiClonePointer(),
        FfiConverterTypeLogLevel.lower(level),
        FfiConverterString.lower(msg),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLoggingDriver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceLoggingDriver] = [UniffiVTableCallbackInterfaceLoggingDriver(
        log: { (
            uniffiHandle: UInt64,
            level: RustBuffer,
            msg: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeLoggingDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.log(
                     level: try FfiConverterTypeLogLevel.lift(level),
                     msg: try FfiConverterString.lift(msg)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeLoggingDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface LoggingDriver: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitLoggingDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_loggingdriver(UniffiCallbackInterfaceLoggingDriver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLoggingDriver: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<LoggingDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LoggingDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LoggingDriver {
        return LoggingDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LoggingDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoggingDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LoggingDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLoggingDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> LoggingDriver {
    return try FfiConverterTypeLoggingDriver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLoggingDriver_lower(_ value: LoggingDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLoggingDriver.lower(value)
}




/**
 * A builder of `MnemonicWithPassphrase` required for a new `DeviceFactorSource` creation.
 * Exposes functions to be called by hosts to be able to use the resulting `MnemonicWithPassphrase`.
 */
public protocol MnemonicBuilderProtocol : AnyObject {
    
    /**
     * Creates a new mnemonic from given `words`
     */
    func createMnemonicFromWords(words: [String]) throws  -> MnemonicBuilder
    
    /**
     * Generates a new mnemonic
     */
    func generateNewMnemonic()  -> MnemonicBuilder
    
    /**
     * Returns the `FactorSourceID` from the mnemonic with passphrase
     * Panics if the mnemonic with passphrase wasn't yet created
     */
    func getFactorSourceId(kind: FactorSourceKind)  -> FactorSourceId
    
    /**
     * Get a set of words indices within `MnemonicWithPassphrase` to be confirmed.
     * Always includes the last mnemonic word index.
     */
    func getIndicesInMnemonicOfWordsToConfirm()  -> [UInt16]
    
    func getMnemonicWithPassphrase()  -> MnemonicWithPassphrase
    
    /**
     * Returns the words of the mnemonic with passphrase.
     */
    func getWords()  -> [Bip39Word]
    
    /**
     * Verifies if the `words_to_confirm` contains the expected number of words.
     * Verifies if the `words_to_confirm` are correct within the previously created `MnemonicWithPassphrase`.
     * Returns unconfirmed words if not all of the words were confirmed or the `MnemonicWithPassphrase`.
     */
    func validateWords(wordsToConfirm: [UInt16: String])  -> MnemonicValidationOutcome
    
}

/**
 * A builder of `MnemonicWithPassphrase` required for a new `DeviceFactorSource` creation.
 * Exposes functions to be called by hosts to be able to use the resulting `MnemonicWithPassphrase`.
 */
open class MnemonicBuilder:
    Equatable,
    Hashable,
    MnemonicBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_mnemonicbuilder(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_sargon_uniffi_fn_constructor_mnemonicbuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_mnemonicbuilder(pointer, $0) }
    }

    

    
    /**
     * Creates a new mnemonic from given `words`
     */
open func createMnemonicFromWords(words: [String])throws  -> MnemonicBuilder  {
    return try  FfiConverterTypeMnemonicBuilder.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_mnemonicbuilder_create_mnemonic_from_words(self.uniffiClonePointer(),
        FfiConverterSequenceString.lower(words),$0
    )
})
}
    
    /**
     * Generates a new mnemonic
     */
open func generateNewMnemonic() -> MnemonicBuilder  {
    return try!  FfiConverterTypeMnemonicBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_mnemonicbuilder_generate_new_mnemonic(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the `FactorSourceID` from the mnemonic with passphrase
     * Panics if the mnemonic with passphrase wasn't yet created
     */
open func getFactorSourceId(kind: FactorSourceKind) -> FactorSourceId  {
    return try!  FfiConverterTypeFactorSourceID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_mnemonicbuilder_get_factor_source_id(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceKind.lower(kind),$0
    )
})
}
    
    /**
     * Get a set of words indices within `MnemonicWithPassphrase` to be confirmed.
     * Always includes the last mnemonic word index.
     */
open func getIndicesInMnemonicOfWordsToConfirm() -> [UInt16]  {
    return try!  FfiConverterSequenceUInt16.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_mnemonicbuilder_get_indices_in_mnemonic_of_words_to_confirm(self.uniffiClonePointer(),$0
    )
})
}
    
open func getMnemonicWithPassphrase() -> MnemonicWithPassphrase  {
    return try!  FfiConverterTypeMnemonicWithPassphrase.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_mnemonicbuilder_get_mnemonic_with_passphrase(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the words of the mnemonic with passphrase.
     */
open func getWords() -> [Bip39Word]  {
    return try!  FfiConverterSequenceTypeBIP39Word.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_mnemonicbuilder_get_words(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Verifies if the `words_to_confirm` contains the expected number of words.
     * Verifies if the `words_to_confirm` are correct within the previously created `MnemonicWithPassphrase`.
     * Returns unconfirmed words if not all of the words were confirmed or the `MnemonicWithPassphrase`.
     */
open func validateWords(wordsToConfirm: [UInt16: String]) -> MnemonicValidationOutcome  {
    return try!  FfiConverterTypeMnemonicValidationOutcome.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_mnemonicbuilder_validate_words(self.uniffiClonePointer(),
        FfiConverterDictionaryUInt16String.lower(wordsToConfirm),$0
    )
})
}
    
    public static func == (self: MnemonicBuilder, other: MnemonicBuilder) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_sargon_uniffi_fn_method_mnemonicbuilder_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeMnemonicBuilder.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_sargon_uniffi_fn_method_mnemonicbuilder_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonicBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MnemonicBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MnemonicBuilder {
        return MnemonicBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MnemonicBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MnemonicBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonicBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> MnemonicBuilder {
    return try FfiConverterTypeMnemonicBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonicBuilder_lower(_ value: MnemonicBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMnemonicBuilder.lower(value)
}




public protocol NfcTagDriver : AnyObject {
    
    func startSession(purpose: NfcTagDriverPurpose) async throws 
    
    func endSession(withFailure: CommonError?) async 
    
    func sendReceive(command: BagOfBytes) async throws  -> BagOfBytes
    
    func sendReceiveCommandChain(commands: [BagOfBytes]) async throws  -> BagOfBytes
    
    func setProgress(progress: UInt8) async 
    
}

open class NfcTagDriverImpl:
    NfcTagDriver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_nfctagdriver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_nfctagdriver(pointer, $0) }
    }

    

    
open func startSession(purpose: NfcTagDriverPurpose)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_nfctagdriver_start_session(
                    self.uniffiClonePointer(),
                    FfiConverterTypeNFCTagDriverPurpose.lower(purpose)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func endSession(withFailure: CommonError?)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_nfctagdriver_end_session(
                    self.uniffiClonePointer(),
                    FfiConverterOptionTypeCommonError.lower(withFailure)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func sendReceive(command: BagOfBytes)async throws  -> BagOfBytes  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_nfctagdriver_send_receive(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBagOfBytes.lower(command)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeBagOfBytes.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func sendReceiveCommandChain(commands: [BagOfBytes])async throws  -> BagOfBytes  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_nfctagdriver_send_receive_command_chain(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeBagOfBytes.lower(commands)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeBagOfBytes.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func setProgress(progress: UInt8)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_nfctagdriver_set_progress(
                    self.uniffiClonePointer(),
                    FfiConverterUInt8.lower(progress)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceNFCTagDriver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceNfcTagDriver] = [UniffiVTableCallbackInterfaceNfcTagDriver(
        startSession: { (
            uniffiHandle: UInt64,
            purpose: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeNFCTagDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.startSession(
                     purpose: try FfiConverterTypeNFCTagDriverPurpose.lift(purpose)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        endSession: { (
            uniffiHandle: UInt64,
            withFailure: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeNFCTagDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.endSession(
                     withFailure: try FfiConverterOptionTypeCommonError.lift(withFailure)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        sendReceive: { (
            uniffiHandle: UInt64,
            command: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes in
                guard let uniffiObj = try? FfiConverterTypeNFCTagDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.sendReceive(
                     command: try FfiConverterTypeBagOfBytes.lift(command)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        sendReceiveCommandChain: { (
            uniffiHandle: UInt64,
            commands: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes in
                guard let uniffiObj = try? FfiConverterTypeNFCTagDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.sendReceiveCommandChain(
                     commands: try FfiConverterSequenceTypeBagOfBytes.lift(commands)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        setProgress: { (
            uniffiHandle: UInt64,
            progress: UInt8,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeNFCTagDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.setProgress(
                     progress: try FfiConverterUInt8.lift(progress)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeNFCTagDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface NFCTagDriver: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitNFCTagDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_nfctagdriver(UniffiCallbackInterfaceNFCTagDriver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNFCTagDriver: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<NfcTagDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NfcTagDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NfcTagDriver {
        return NfcTagDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NfcTagDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NfcTagDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NfcTagDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNFCTagDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> NfcTagDriver {
    return try FfiConverterTypeNFCTagDriver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNFCTagDriver_lower(_ value: NfcTagDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNFCTagDriver.lower(value)
}




/**
 * Trait for executing network requests, to be implemented by hosts, so that
 * Sargon can make network requests with some HTTP client.
 */
public protocol NetworkingDriver : AnyObject {
    
    /**
     * Method invoked by Sargon Rust side, telling an implementing type to
     * execute a `NetworkRequest` and pass the Result back to Sargon Rust side.
     *
     * Either: `Err` or `Ok(NetworkResponse)`.
     */
    func executeNetworkRequest(request: NetworkRequest) async throws  -> NetworkResponse
    
}

/**
 * Trait for executing network requests, to be implemented by hosts, so that
 * Sargon can make network requests with some HTTP client.
 */
open class NetworkingDriverImpl:
    NetworkingDriver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_networkingdriver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_networkingdriver(pointer, $0) }
    }

    

    
    /**
     * Method invoked by Sargon Rust side, telling an implementing type to
     * execute a `NetworkRequest` and pass the Result back to Sargon Rust side.
     *
     * Either: `Err` or `Ok(NetworkResponse)`.
     */
open func executeNetworkRequest(request: NetworkRequest)async throws  -> NetworkResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_networkingdriver_execute_network_request(
                    self.uniffiClonePointer(),
                    FfiConverterTypeNetworkRequest.lower(request)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeNetworkResponse.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceNetworkingDriver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceNetworkingDriver] = [UniffiVTableCallbackInterfaceNetworkingDriver(
        executeNetworkRequest: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> NetworkResponse in
                guard let uniffiObj = try? FfiConverterTypeNetworkingDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.executeNetworkRequest(
                     request: try FfiConverterTypeNetworkRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: NetworkResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeNetworkResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeNetworkingDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface NetworkingDriver: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitNetworkingDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_networkingdriver(UniffiCallbackInterfaceNetworkingDriver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetworkingDriver: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<NetworkingDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NetworkingDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkingDriver {
        return NetworkingDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NetworkingDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkingDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NetworkingDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkingDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkingDriver {
    return try FfiConverterTypeNetworkingDriver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkingDriver_lower(_ value: NetworkingDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNetworkingDriver.lower(value)
}




public protocol ProfileStateChangeDriver : AnyObject {
    
    func handleProfileStateChange(changedProfileState: ProfileState) async 
    
}

open class ProfileStateChangeDriverImpl:
    ProfileStateChangeDriver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_profilestatechangedriver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_profilestatechangedriver(pointer, $0) }
    }

    

    
open func handleProfileStateChange(changedProfileState: ProfileState)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_profilestatechangedriver_handle_profile_state_change(
                    self.uniffiClonePointer(),
                    FfiConverterTypeProfileState.lower(changedProfileState)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceProfileStateChangeDriver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceProfileStateChangeDriver] = [UniffiVTableCallbackInterfaceProfileStateChangeDriver(
        handleProfileStateChange: { (
            uniffiHandle: UInt64,
            changedProfileState: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeProfileStateChangeDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.handleProfileStateChange(
                     changedProfileState: try FfiConverterTypeProfileState.lift(changedProfileState)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeProfileStateChangeDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ProfileStateChangeDriver: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitProfileStateChangeDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_profilestatechangedriver(UniffiCallbackInterfaceProfileStateChangeDriver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProfileStateChangeDriver: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<ProfileStateChangeDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ProfileStateChangeDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ProfileStateChangeDriver {
        return ProfileStateChangeDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ProfileStateChangeDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileStateChangeDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ProfileStateChangeDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileStateChangeDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> ProfileStateChangeDriver {
    return try FfiConverterTypeProfileStateChangeDriver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileStateChangeDriver_lower(_ value: ProfileStateChangeDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeProfileStateChangeDriver.lower(value)
}




/**
 * The Radix Connect Mobile client that handles the interaction with dApps on mobile through deepLinks.
 */
public protocol RadixConnectMobileProtocol : AnyObject {
    
    /**
     * Try to parse the deep link and create a RadixConnectMobileDappRequest.
     * This is a stateful operation as it will create an in flight session, that needs to be validated by the user.
     */
    func handleDeepLink(url: String) async throws  -> RadixConnectMobileSessionRequest
    
    /**
     * Send the Host's response to the dApp.
     * This is a stateful operation as it will save the session in the secure storage if the user validated the session.
     */
    func sendDappInteractionResponse(walletResponse: RadixConnectMobileWalletResponse) async throws 
    
}

/**
 * The Radix Connect Mobile client that handles the interaction with dApps on mobile through deepLinks.
 */
open class RadixConnectMobile:
    RadixConnectMobileProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_radixconnectmobile(self.pointer, $0) }
    }
public convenience init(networkingDriver: NetworkingDriver, sessionStorage: RadixConnectMobileSessionStorage) {
    let pointer =
        try! rustCall() {
    uniffi_sargon_uniffi_fn_constructor_radixconnectmobile_new(
        FfiConverterTypeNetworkingDriver.lower(networkingDriver),
        FfiConverterTypeRadixConnectMobileSessionStorage.lower(sessionStorage),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_radixconnectmobile(pointer, $0) }
    }

    

    
    /**
     * Try to parse the deep link and create a RadixConnectMobileDappRequest.
     * This is a stateful operation as it will create an in flight session, that needs to be validated by the user.
     */
open func handleDeepLink(url: String)async throws  -> RadixConnectMobileSessionRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_radixconnectmobile_handle_deep_link(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRadixConnectMobileSessionRequest.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Send the Host's response to the dApp.
     * This is a stateful operation as it will save the session in the secure storage if the user validated the session.
     */
open func sendDappInteractionResponse(walletResponse: RadixConnectMobileWalletResponse)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_radixconnectmobile_send_dapp_interaction_response(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRadixConnectMobileWalletResponse.lower(walletResponse)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRadixConnectMobile: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RadixConnectMobile

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobile {
        return RadixConnectMobile(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RadixConnectMobile) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobile {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RadixConnectMobile, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixConnectMobile_lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobile {
    return try FfiConverterTypeRadixConnectMobile.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixConnectMobile_lower(_ value: RadixConnectMobile) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRadixConnectMobile.lower(value)
}




/**
 * A trait for storing and loading Radix Connect Mobile sessions.
 */
public protocol RadixConnectMobileSessionStorage : AnyObject {
    
    /**
     * Saves the session to the storage identified by the session id.
     */
    func saveSession(sessionId: SessionId, encodedSession: BagOfBytes) async throws 
    
    /**
     * Loads the session from the storage identified by the session id.
     */
    func loadSession(sessionId: SessionId) async throws  -> BagOfBytes?
    
}

/**
 * A trait for storing and loading Radix Connect Mobile sessions.
 */
open class RadixConnectMobileSessionStorageImpl:
    RadixConnectMobileSessionStorage {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_radixconnectmobilesessionstorage(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_radixconnectmobilesessionstorage(pointer, $0) }
    }

    

    
    /**
     * Saves the session to the storage identified by the session id.
     */
open func saveSession(sessionId: SessionId, encodedSession: BagOfBytes)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_radixconnectmobilesessionstorage_save_session(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSessionID.lower(sessionId),FfiConverterTypeBagOfBytes.lower(encodedSession)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Loads the session from the storage identified by the session id.
     */
open func loadSession(sessionId: SessionId)async throws  -> BagOfBytes?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_radixconnectmobilesessionstorage_load_session(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSessionID.lower(sessionId)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRadixConnectMobileSessionStorage {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceRadixConnectMobileSessionStorage] = [UniffiVTableCallbackInterfaceRadixConnectMobileSessionStorage(
        saveSession: { (
            uniffiHandle: UInt64,
            sessionId: RustBuffer,
            encodedSession: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeRadixConnectMobileSessionStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveSession(
                     sessionId: try FfiConverterTypeSessionID.lift(sessionId),
                     encodedSession: try FfiConverterTypeBagOfBytes.lift(encodedSession)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        loadSession: { (
            uniffiHandle: UInt64,
            sessionId: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeRadixConnectMobileSessionStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadSession(
                     sessionId: try FfiConverterTypeSessionID.lift(sessionId)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeRadixConnectMobileSessionStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RadixConnectMobileSessionStorage: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitRadixConnectMobileSessionStorage() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_radixconnectmobilesessionstorage(UniffiCallbackInterfaceRadixConnectMobileSessionStorage.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRadixConnectMobileSessionStorage: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<RadixConnectMobileSessionStorage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RadixConnectMobileSessionStorage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobileSessionStorage {
        return RadixConnectMobileSessionStorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RadixConnectMobileSessionStorage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileSessionStorage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RadixConnectMobileSessionStorage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixConnectMobileSessionStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobileSessionStorage {
    return try FfiConverterTypeRadixConnectMobileSessionStorage.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixConnectMobileSessionStorage_lower(_ value: RadixConnectMobileSessionStorage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRadixConnectMobileSessionStorage.lower(value)
}




public protocol RadixNameServiceProtocol : AnyObject {
    
    func resolveReceiverAccountForDomain(domain: RnsDomain) async throws  -> RnsDomainConfiguredReceiver
    
}

open class RadixNameService:
    RadixNameServiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_radixnameservice(self.pointer, $0) }
    }
public convenience init(networkingDriver: NetworkingDriver, networkId: NetworkId)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_constructor_radixnameservice_new(
        FfiConverterTypeNetworkingDriver.lower(networkingDriver),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_radixnameservice(pointer, $0) }
    }

    

    
open func resolveReceiverAccountForDomain(domain: RnsDomain)async throws  -> RnsDomainConfiguredReceiver  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_radixnameservice_resolve_receiver_account_for_domain(
                    self.uniffiClonePointer(),
                    FfiConverterTypeRnsDomain.lower(domain)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRnsDomainConfiguredReceiver.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRadixNameService: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RadixNameService

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixNameService {
        return RadixNameService(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RadixNameService) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixNameService {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RadixNameService, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixNameService_lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixNameService {
    return try FfiConverterTypeRadixNameService.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixNameService_lower(_ value: RadixNameService) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRadixNameService.lower(value)
}




/**
 * The Sargon "Operating System" is the root "manager" of the Sargon library
 * which holds an in-memory Profile and a collection of "clients" which are
 * created from "drivers" which the hosts (iOS/Android wallets) "installs"
 * during app launch, enabling the  Sargon "Operating System" to e.g read/write
 * to secure storage and make use of the network connection of the iPhone/Android
 * phone.
 */
public protocol SargonOsProtocol : AnyObject {
    
    func debugFactorInstancesInCache() async  -> [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]]
    
    /**
     * Add the `account` to active profile and **saves** the updated profile to
     * secure storage.
     *
     * Returns `Ok(())` if the `account` was new and successfully added. If
     * saving failed or if the account was already present in Profile, an
     * error is returned.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
     */
    func addAccount(account: Account) async throws 
    
    /**
     * Adds the `accounts` to active profile and **saves** the updated profile to
     * secure storage.
     *
     * Returns `Ok(())` if the `accounts` were new and successfully added. If
     * saving failed or if the accounts were already present in Profile, an
     * error is returned.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
     */
    func addAccounts(accounts: [Account]) async throws 
    
    /**
     * Returns `Ok(false)` if the Profile already contained a factor source with the
     * same id (Profile unchanged occurred).
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceAdded }`
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
     * if the newly added FactorSource is a new **main** flag, then we remove the
     * main flag from the old BDFS.
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    func addFactorSource(factorSource: FactorSource) async throws  -> Bool
    
    /**
     * Adds all of the provided `factor_sources` to Profile in one single go.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourcesAdded }`
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
     * if the newly added FactorSource is a new **main** flag, then we remove the
     * main flag from the old BDFS.
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    func addFactorSources(factorSources: [FactorSource]) async throws  -> [FactorSourceId]
    
    func addNewMnemonicFactorSource(factorSourceKind: FactorSourceKind, mnemonicWithPassphrase: MnemonicWithPassphrase, name: String) async throws  -> FactorSourceId
    
    /**
     * Adds the security structure of factor source IDs to Profile if none with the
     * same ID already exists, and if all factors it references are found in Profile.
     *
     * If `structure` references a FactorSource by ID which is unknown to Profile,
     * `Err(CommonError::StructureReferencesUnknownFactorSource)` is returned.
     *
     * If Profile already contains a structure with the same ID, `Ok(false)` is
     * returned **without** modifying the existing one.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::SecurityStructureAdded { id } }`
     */
    func addSecurityStructureOfFactorSourceIds(structureIds: SecurityStructureOfFactorSourceIDs) async throws 
    
    /**
     * Performs initial transaction analysis for a given raw manifest, including:
     * 1. Creating the SubintentManifest.
     * 2. Validating if the manifest is open or enclosed.
     * 3. If open, the manifest with its summary is returned.
     * 4. If enclosed, it extracts the transaction signers and then transaction preview GW request is executed.
     * 3. The execution summary is created with the manifest and receipt.
     *
     * Maps relevant errors to ensure proper handling by the hosts.
     */
    func analysePreAuthPreview(instructions: String, blobs: Blobs, nonce: Nonce, notaryPublicKey: PublicKey) async throws  -> PreAuthToReview
    
    /**
     * Performs initial transaction analysis for a given raw manifest, including:
     * 1. Extracting the transaction signers.
     * 2. Executing the transaction preview GW request.
     * 3. Running the execution summary with the manifest and receipt.
     *
     * Maps relevant errors to ensure proper handling by the hosts.
     */
    func analyseTransactionPreview(instructions: String, blobs: Blobs, areInstructionsOriginatingFromHost: Bool, nonce: Nonce, notaryPublicKey: PublicKey) async throws  -> TransactionToReview
    
    /**
     * Appends the provided `crypto_parameters` to the `factor_source` in Profile.
     */
    func appendCryptoParametersToFactorSource(factorSourceId: FactorSourceId, cryptoParameters: FactorSourceCryptoParameters) async throws 
    
    func applySecurityShieldWithIdToEntities(securityShieldId: SecurityStructureId, addresses: [AddressOfAccountOrPersona]) async throws 
    
    func arculusCardConfigureWithMnemonic(mnemonic: Mnemonic, pin: String) async throws  -> FactorSourceIdFromHash
    
    func arculusCardDerivePublicKeys(factorSource: ArculusCardFactorSource, paths: [DerivationPath]) async throws  -> [HierarchicalDeterministicFactorInstance]
    
    func arculusCardReset() async throws 
    
    func arculusCardRestorePin(factorSource: ArculusCardFactorSource, mnemonic: Mnemonic, pin: String) async throws 
    
    func arculusCardSignAuth(factorSource: ArculusCardFactorSource, pin: String, perTransaction: [TransactionSignRequestInputOfAuthIntent]) async throws  -> [HdSignatureOfAuthIntentHash]
    
    func arculusCardSignSubintent(factorSource: ArculusCardFactorSource, pin: String, perTransaction: [TransactionSignRequestInputOfSubintent]) async throws  -> [HdSignatureOfSubintentHash]
    
    func arculusCardSignTransaction(factorSource: ArculusCardFactorSource, pin: String, perTransaction: [TransactionSignRequestInputOfTransactionIntent]) async throws  -> [HdSignatureOfTransactionIntentHash]
    
    func arculusCardValidateMinFirmwareVersion() async throws  -> ArculusMinFirmwareVersionRequirement
    
    /**
     * Changes the current Gateway to `to`, if it is not already the current.
     * Returns the outcome of the change, if we did in fact switch (current != to),
     * and if we switched then if `to` is new.
     *
     * If we did in fact change current, an `EventNotification` is emitted.
     *
     * # Emits Event
     * Emits `Event::GatewayChangedCurrent` if we changed the gateway.
     */
    func changeCurrentGateway(to: Gateway) async throws  -> ChangeGatewayOutcome
    
    /**
     * Queries all `account_addresses` on ledger and checks reports which one is deleted.
     *
     * Returns an array of the account addresses along with a `bool` being true if that account
     * is deleted
     */
    func checkAccountsDeletedOnLedger(networkId: NetworkId, accountAddresses: [AccountAddress]) async throws  -> [AccountAddress: Bool]
    
    /**
     * Returns all the `SecurityProblem`s that are present for the given input.
     */
    func checkSecurityProblems(input: CheckSecurityProblemsInput) throws  -> [SecurityProblem]
    
    func claimProfile(profile: Profile)  -> Profile
    
    /**
     * Create a new Account and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    func createAndSaveNewAccountWithFactorSource(factorSource: FactorSource, networkId: NetworkId, name: DisplayName) async throws  -> Account
    
    /**
     * Create a new Persona and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::PersonaAdded }`
     */
    func createAndSaveNewPersonaWithFactorSource(factorSource: FactorSource, networkId: NetworkId, name: DisplayName, personaData: PersonaData?) async throws  -> Persona
    
    /**
     * Creates the `TransactionManifest` for deleting the given `account_address`. If a
     * `recipient_account_address` is provided, the manifest will also send all the resources from
     * the deleted account to the recipient one.
     */
    func createDeleteAccountManifest(accountAddress: AccountAddress, recipientAccountAddress: AccountAddress?) async throws  -> CreateDeleteAccountManifestOutcome
    
    /**
     * Creates a new unsaved DeviceFactorSource from the provided `mnemonic_with_passphrase`,
     * either a "BDFS" or an "Olympia" one.
     */
    func createDeviceFactorSource(mnemonicWithPassphrase: MnemonicWithPassphrase, factorType: DeviceFactorSourceType)  -> DeviceFactorSource
    
    /**
     * Creates a Subintent given its discriminator, manifest and expiration.
     */
    func createSubintent(intentDiscriminator: IntentDiscriminator, subintentManifest: SubintentManifest, expiration: DappToWalletInteractionSubintentExpiration, message: String?) async throws  -> Subintent
    
    /**
     * The current gateway host client is using, which affects `current_network_id`.
     * All Network Requests reading from Radix ledger and submission of new
     * transactions will go the the Radix Network of the current Gateway.
     */
    func currentGateway() throws  -> Gateway
    
    /**
     * Returns the `ProfileNetwork` corresponding to the network ID set by the
     * current gateway.
     */
    func currentNetwork() throws  -> ProfileNetwork
    
    /**
     * Returns the id of the Network of the current Gateway set in AppPreferences
     * of the active Profile. This is the canonical value of "current network",
     * which affects which accounts host clients display to end user and to
     * which network transactions are submitted, amongst other behaviors.
     */
    func currentNetworkId() throws  -> NetworkId
    
    func debugAddAllSampleFactors() async throws  -> [FactorSourceId]
    
    func deleteWallet() async throws 
    
    func derivePublicKeys(derivationPaths: [DerivationPath], source: DerivePublicKeysSource) async throws  -> [HierarchicalDeterministicPublicKey]
    
    /**
     * Returns the entities linked to a given `FactorSource`, either on the current `Profile` or a specific one.
     */
    func entitiesLinkedToFactorSource(factorSource: FactorSource, profileToCheck: ProfileToCheck) async throws  -> EntitiesLinkedToFactorSource
    
    /**
     * Returns the entities linked to a given `SecurityStructureID`, either on the current `Profile` or a specific one.
     */
    func entitiesLinkedToSecurityStructure(shieldId: SecurityStructureId, profileToCheck: ProfileToCheck) async throws  -> EntitiesLinkedToSecurityStructure
    
    /**
     * Returns the entities linked to a given `FactorSource`, either on the current `Profile` or a specific one.
     */
    func factorSourceIntegrity(factorSource: FactorSource) async throws  -> FactorSourceIntegrity
    
    /**
     * Returns all the factor sources
     */
    func factorSources() throws  -> [FactorSource]
    
    /**
     * Returns the `gateways` values of the current Profile.
     */
    func gateways() throws  -> SavedGateways
    
    /**
     * Returns all the Security Shields along with the number of entities linked to each Security Shield,
     * either provisionally or currently securified.
     */
    func getShieldsForDisplay() async throws  -> [ShieldForDisplay]
    
    /**
     * Has **any** account, at all, including hidden, on any network.
     */
    func hasAnyAccountOnAnyNetwork() throws  -> Bool
    
    /**
     * Checks if current Profile contains any `ProfileNetwork`s.
     */
    func hasAnyNetwork() throws  -> Bool
    
    func hostId()  -> HostId
    
    /**
     * Imports the `profile`, claims it, set it as active (current) one and
     * saves it into secure storage (with the claim modification).
     *
     * # Emits Event
     * Emits `EventNotification::new(Event::ProfileImported))` event if successful.
     */
    func importProfile(profile: Profile) async throws 
    
    func importWallet(profile: Profile, bdfsSkipped: Bool) async throws 
    
    func isFactorSourceAlreadyInUse(factorSourceId: FactorSourceId) async throws  -> Bool
    
    /**
     * Loads a `MnemonicWithPassphrase` with the `id` of `device_factor_source`,
     * from SecureStorage, and returns a `PrivateHierarchicalDeterministicFactorSource`
     * built from both.
     *
     * Useful for when you will want to sign transactions or derive public keys for
     * creation of new entities.
     *
     * Returns `Err` if loading or decoding of `MnemonicWithPassphrase` from
     * SecureStorage fails.
     */
    func loadPrivateDeviceFactorSourceById(id: FactorSourceIdFromHash) async throws  -> PrivateHierarchicalDeterministicFactorSource
    
    func makeInteractionForApplyingSecurityShield(securityShieldId: SecurityStructureId, addresses: [AddressOfAccountOrPersona]) async throws  -> DappToWalletInteractionBatchOfTransactions
    
    /**
     * Updates the profile by marking the account with `account_address` as hidden.
     */
    func markAccountAsHidden(accountAddress: AccountAddress) async throws 
    
    /**
     * Updates the profile by marking the account with `account_address` as tombstoned.
     */
    func markAccountAsTombstoned(accountAddress: AccountAddress) async throws 
    
    /**
     * Marks the entities as securified by finding the `AccessControllerAddress` on ledger
     * and updates the profile.
     */
    func markEntitiesAsSecurified(entityAddresses: [AddressOfAccountOrPersona]) async throws 
    
    func newWallet() async throws 
    
    func newWalletWithDerivedBdfs(hdFactorSource: PrivateHierarchicalDeterministicFactorSource, accounts: [Account]) async throws 
    
    /**
     * Polls the status of a `SubintentHash` until it is either `Success` or `Expired`.
     */
    func pollPreAuthorizationStatus(intentHash: SubintentHash, expirationTimestamp: Instant) async throws  -> PreAuthorizationStatus
    
    /**
     * Polls the state of a Transaction until we can determine its `TransactionStatus`.
     */
    func pollTransactionStatus(intentHash: TransactionIntentHash) async throws  -> TransactionStatus
    
    func profile() throws  -> Profile
    
    /**
     * Renames the Security Shield with the given `shield_id`.
     */
    func renameSecurityStructure(securityStructureId: SecurityStructureId, name: DisplayName) async throws 
    
    func resolveHostInfo()  -> HostInfo
    
    /**
     * Returns the status of the prerequisites for building a Security Shield.
     *
     * According to [definition][doc], a Security Shield can be built if the user has, asides from
     * the Identity factor, "2 or more factors, one of which must be Hardware"
     *
     * [doc]: https://radixdlt.atlassian.net/wiki/spaces/AT/pages/3758063620/MFA+Rules+for+Factors+and+Security+Shields#Factor-Prerequisites
     */
    func securityShieldPrerequisitesStatus() throws  -> SecurityShieldPrerequisitesStatus
    
    /**
     * Returns the `SecurityStructureOfFactorSourceIDs` with the given `shield_id`.
     */
    func securityStructureOfFactorSourceIdsBySecurityStructureId(shieldId: SecurityStructureId) throws  -> SecurityStructureOfFactorSourceIDs
    
    /**
     * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
     * in profile.
     */
    func securityStructureOfFactorSourcesFromSecurityStructureOfFactorSourceIds(structureOfIds: SecurityStructureOfFactorSourceIDs) throws  -> SecurityStructureOfFactorSources
    
    /**
     * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
     * in profile.
     */
    func securityStructuresOfFactorSourceIds() throws  -> [SecurityStructureOfFactorSourceIDs]
    
    /**
     * Returns all the SecurityStructuresOfFactorSources,
     * by trying to map FactorSourceID level -> FactorSource Level
     */
    func securityStructuresOfFactorSources() throws  -> [SecurityStructureOfFactorSources]
    
    func setCardPin(factorSource: ArculusCardFactorSource, oldPin: String, newPin: String) async throws 
    
    /**
     * Sets the Security Shield with the given `shield_id` as the main shield.
     * If a main Security Shield already exists, it is removed and replaced with the new one.
     *
     * # Emits Event
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * Also emits `EventNotification::ProfileModified { change: EventProfileModified::SecurityStructuresUpdated { id } }`
     */
    func setMainSecurityStructure(shieldId: SecurityStructureId) async throws 
    
    func setProfile(profile: Profile) async throws 
    
    func signAuthAccounts(accountAddresses: [AccountAddress], challengeNonce: DappToWalletInteractionAuthChallengeNonce, metadata: DappToWalletInteractionMetadata) async throws  -> SignedAuthIntent
    
    func signAuthPersona(identityAddress: IdentityAddress, challengeNonce: DappToWalletInteractionAuthChallengeNonce, metadata: DappToWalletInteractionMetadata) async throws  -> SignedAuthIntent
    
    func signSubintent(transactionIntent: Subintent, roleKind: RoleKind) async throws  -> SignedSubintent
    
    func signTransaction(transactionIntent: TransactionIntent, roleKind: RoleKind) async throws  -> SignedIntent
    
    /**
     * Submits a notarized transaction payload to the network.
     */
    func submitTransaction(notarizedTransaction: NotarizedTransaction) async throws  -> TransactionIntentHash
    
    /**
     * Checks all active accounts in current network on ledger, if any of them are deleted.
     * Any deleted account is marked as tombstoned in profile.
     *
     * Returns true if any account became tombstoned.
     */
    func syncAccountsDeletedOnLedger() async throws  -> Bool
    
    /**
     * Triggers the spot check for the given factor source, and returns whether the spot check was successful.
     */
    func triggerSpotCheck(factorSource: FactorSource) async throws  -> Bool
    
    /**
     * Updates the account `updated` by mutating current profile and persisting
     * the change to secure storage. Throws `UnknownAccount` error if the account
     * is not found.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountUpdated { address } }`
     */
    func updateAccount(updated: Account) async throws 
    
    /**
     * Updates the factor source `updated` by mutating current profile and persisting
     * the change to secure storage. Throws `UpdateFactorSourceMutateFailed` error if the
     * factor source is not found.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
     */
    func updateFactorSource(updated: FactorSource) async throws 
    
    /**
     * Updates the name of the corresponding `factor_source` in Profile. Throws `UpdateFactorSourceMutateFailed` error if the
     * factor source is not found. Returns the updated `FactorSource`.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
     */
    func updateFactorSourceName(factorSource: FactorSource, name: String) async throws  -> FactorSource
    
    /**
     * Updates an existing `SecurityStructureOfFactorSourceIDs` in the Profile.
     * Returns an error if the structure does not exist or if it references unknown factors.
     * Emits `Event::ProfileSaved` and `Event::ProfileModified::SecurityStructuresUpdated { ids }` on success.
     */
    func updateSecurityStructureOfFactorSourceIds(structureIds: SecurityStructureOfFactorSourceIDs) async throws 
    
    func verifyCardPin(factorSource: ArculusCardFactorSource, pin: String) async throws 
    
    /**
     * Syncs entities in profile with on ledger state.
     * Returns a summary report of the actions performed.
     *
     * Checks performed on entities are:
     * 1. Checks if active accounts on profile are deleted on ledger.
     * Action => to mark them as tombstoned
     * 2. Checks if entities with provisional shield are securified on ledger.
     * Action => to mark them as securified
     * 3. more checks will be developed...
     */
    func wipSyncEntitiesStateOnLedger() async throws  -> EntitySyncOutcome
    
}

/**
 * The Sargon "Operating System" is the root "manager" of the Sargon library
 * which holds an in-memory Profile and a collection of "clients" which are
 * created from "drivers" which the hosts (iOS/Android wallets) "installs"
 * during app launch, enabling the  Sargon "Operating System" to e.g read/write
 * to secure storage and make use of the network connection of the iPhone/Android
 * phone.
 */
open class SargonOs:
    SargonOsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_sargonos(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_sargonos(pointer, $0) }
    }

    
public static func boot(bios: Bios, interactor: HostInteractor)async throws  -> SargonOs  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_constructor_sargonos_boot(FfiConverterTypeBios.lower(bios),FfiConverterTypeHostInteractor.lower(interactor)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_pointer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_pointer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeSargonOS.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

    
open func debugFactorInstancesInCache()async  -> [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]]  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos___debug_factor_instances_in_cache(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryTypeFactorSourceIDFromHashSequenceSequenceTypeFactorInstanceForDebugPurposes.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Add the `account` to active profile and **saves** the updated profile to
     * secure storage.
     *
     * Returns `Ok(())` if the `account` was new and successfully added. If
     * saving failed or if the account was already present in Profile, an
     * error is returned.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
     */
open func addAccount(account: Account)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_add_account(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAccount.lower(account)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Adds the `accounts` to active profile and **saves** the updated profile to
     * secure storage.
     *
     * Returns `Ok(())` if the `accounts` were new and successfully added. If
     * saving failed or if the accounts were already present in Profile, an
     * error is returned.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
     */
open func addAccounts(accounts: [Account])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_add_accounts(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeAccount.lower(accounts)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Returns `Ok(false)` if the Profile already contained a factor source with the
     * same id (Profile unchanged occurred).
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceAdded }`
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
     * if the newly added FactorSource is a new **main** flag, then we remove the
     * main flag from the old BDFS.
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
open func addFactorSource(factorSource: FactorSource)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_add_factor_source(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSource.lower(factorSource)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_i8,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_i8,
            freeFunc: ffi_sargon_uniffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Adds all of the provided `factor_sources` to Profile in one single go.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourcesAdded }`
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
     * if the newly added FactorSource is a new **main** flag, then we remove the
     * main flag from the old BDFS.
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
open func addFactorSources(factorSources: [FactorSource])async throws  -> [FactorSourceId]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_add_factor_sources(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeFactorSource.lower(factorSources)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFactorSourceID.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func addNewMnemonicFactorSource(factorSourceKind: FactorSourceKind, mnemonicWithPassphrase: MnemonicWithPassphrase, name: String)async throws  -> FactorSourceId  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_add_new_mnemonic_factor_source(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSourceKind.lower(factorSourceKind),FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFactorSourceID.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Adds the security structure of factor source IDs to Profile if none with the
     * same ID already exists, and if all factors it references are found in Profile.
     *
     * If `structure` references a FactorSource by ID which is unknown to Profile,
     * `Err(CommonError::StructureReferencesUnknownFactorSource)` is returned.
     *
     * If Profile already contains a structure with the same ID, `Ok(false)` is
     * returned **without** modifying the existing one.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::SecurityStructureAdded { id } }`
     */
open func addSecurityStructureOfFactorSourceIds(structureIds: SecurityStructureOfFactorSourceIDs)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_add_security_structure_of_factor_source_ids(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSecurityStructureOfFactorSourceIDs.lower(structureIds)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Performs initial transaction analysis for a given raw manifest, including:
     * 1. Creating the SubintentManifest.
     * 2. Validating if the manifest is open or enclosed.
     * 3. If open, the manifest with its summary is returned.
     * 4. If enclosed, it extracts the transaction signers and then transaction preview GW request is executed.
     * 3. The execution summary is created with the manifest and receipt.
     *
     * Maps relevant errors to ensure proper handling by the hosts.
     */
open func analysePreAuthPreview(instructions: String, blobs: Blobs, nonce: Nonce, notaryPublicKey: PublicKey)async throws  -> PreAuthToReview  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_analyse_pre_auth_preview(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(instructions),FfiConverterTypeBlobs.lower(blobs),FfiConverterTypeNonce.lower(nonce),FfiConverterTypePublicKey.lower(notaryPublicKey)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePreAuthToReview.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Performs initial transaction analysis for a given raw manifest, including:
     * 1. Extracting the transaction signers.
     * 2. Executing the transaction preview GW request.
     * 3. Running the execution summary with the manifest and receipt.
     *
     * Maps relevant errors to ensure proper handling by the hosts.
     */
open func analyseTransactionPreview(instructions: String, blobs: Blobs, areInstructionsOriginatingFromHost: Bool, nonce: Nonce, notaryPublicKey: PublicKey)async throws  -> TransactionToReview  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_analyse_transaction_preview(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(instructions),FfiConverterTypeBlobs.lower(blobs),FfiConverterBool.lower(areInstructionsOriginatingFromHost),FfiConverterTypeNonce.lower(nonce),FfiConverterTypePublicKey.lower(notaryPublicKey)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransactionToReview.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Appends the provided `crypto_parameters` to the `factor_source` in Profile.
     */
open func appendCryptoParametersToFactorSource(factorSourceId: FactorSourceId, cryptoParameters: FactorSourceCryptoParameters)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_append_crypto_parameters_to_factor_source(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSourceID.lower(factorSourceId),FfiConverterTypeFactorSourceCryptoParameters.lower(cryptoParameters)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func applySecurityShieldWithIdToEntities(securityShieldId: SecurityStructureId, addresses: [AddressOfAccountOrPersona])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_apply_security_shield_with_id_to_entities(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSecurityStructureID.lower(securityShieldId),FfiConverterSequenceTypeAddressOfAccountOrPersona.lower(addresses)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func arculusCardConfigureWithMnemonic(mnemonic: Mnemonic, pin: String)async throws  -> FactorSourceIdFromHash  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_arculus_card_configure_with_mnemonic(
                    self.uniffiClonePointer(),
                    FfiConverterTypeMnemonic.lower(mnemonic),FfiConverterString.lower(pin)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFactorSourceIDFromHash.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func arculusCardDerivePublicKeys(factorSource: ArculusCardFactorSource, paths: [DerivationPath])async throws  -> [HierarchicalDeterministicFactorInstance]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_arculus_card_derive_public_keys(
                    self.uniffiClonePointer(),
                    FfiConverterTypeArculusCardFactorSource.lower(factorSource),FfiConverterSequenceTypeDerivationPath.lower(paths)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeHierarchicalDeterministicFactorInstance.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func arculusCardReset()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_arculus_card_reset(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func arculusCardRestorePin(factorSource: ArculusCardFactorSource, mnemonic: Mnemonic, pin: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_arculus_card_restore_pin(
                    self.uniffiClonePointer(),
                    FfiConverterTypeArculusCardFactorSource.lower(factorSource),FfiConverterTypeMnemonic.lower(mnemonic),FfiConverterString.lower(pin)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func arculusCardSignAuth(factorSource: ArculusCardFactorSource, pin: String, perTransaction: [TransactionSignRequestInputOfAuthIntent])async throws  -> [HdSignatureOfAuthIntentHash]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_arculus_card_sign_auth(
                    self.uniffiClonePointer(),
                    FfiConverterTypeArculusCardFactorSource.lower(factorSource),FfiConverterString.lower(pin),FfiConverterSequenceTypeTransactionSignRequestInputOfAuthIntent.lower(perTransaction)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeHDSignatureOfAuthIntentHash.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func arculusCardSignSubintent(factorSource: ArculusCardFactorSource, pin: String, perTransaction: [TransactionSignRequestInputOfSubintent])async throws  -> [HdSignatureOfSubintentHash]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_arculus_card_sign_subintent(
                    self.uniffiClonePointer(),
                    FfiConverterTypeArculusCardFactorSource.lower(factorSource),FfiConverterString.lower(pin),FfiConverterSequenceTypeTransactionSignRequestInputOfSubintent.lower(perTransaction)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeHDSignatureOfSubintentHash.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func arculusCardSignTransaction(factorSource: ArculusCardFactorSource, pin: String, perTransaction: [TransactionSignRequestInputOfTransactionIntent])async throws  -> [HdSignatureOfTransactionIntentHash]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_arculus_card_sign_transaction(
                    self.uniffiClonePointer(),
                    FfiConverterTypeArculusCardFactorSource.lower(factorSource),FfiConverterString.lower(pin),FfiConverterSequenceTypeTransactionSignRequestInputOfTransactionIntent.lower(perTransaction)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeHDSignatureOfTransactionIntentHash.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func arculusCardValidateMinFirmwareVersion()async throws  -> ArculusMinFirmwareVersionRequirement  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_arculus_card_validate_min_firmware_version(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeArculusMinFirmwareVersionRequirement.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Changes the current Gateway to `to`, if it is not already the current.
     * Returns the outcome of the change, if we did in fact switch (current != to),
     * and if we switched then if `to` is new.
     *
     * If we did in fact change current, an `EventNotification` is emitted.
     *
     * # Emits Event
     * Emits `Event::GatewayChangedCurrent` if we changed the gateway.
     */
open func changeCurrentGateway(to: Gateway)async throws  -> ChangeGatewayOutcome  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_change_current_gateway(
                    self.uniffiClonePointer(),
                    FfiConverterTypeGateway.lower(to)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeChangeGatewayOutcome.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Queries all `account_addresses` on ledger and checks reports which one is deleted.
     *
     * Returns an array of the account addresses along with a `bool` being true if that account
     * is deleted
     */
open func checkAccountsDeletedOnLedger(networkId: NetworkId, accountAddresses: [AccountAddress])async throws  -> [AccountAddress: Bool]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_check_accounts_deleted_on_ledger(
                    self.uniffiClonePointer(),
                    FfiConverterTypeNetworkID.lower(networkId),FfiConverterSequenceTypeAccountAddress.lower(accountAddresses)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryTypeAccountAddressBool.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Returns all the `SecurityProblem`s that are present for the given input.
     */
open func checkSecurityProblems(input: CheckSecurityProblemsInput)throws  -> [SecurityProblem]  {
    return try  FfiConverterSequenceTypeSecurityProblem.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_check_security_problems(self.uniffiClonePointer(),
        FfiConverterTypeCheckSecurityProblemsInput.lower(input),$0
    )
})
}
    
open func claimProfile(profile: Profile) -> Profile  {
    return try!  FfiConverterTypeProfile.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_sargonos_claim_profile(self.uniffiClonePointer(),
        FfiConverterTypeProfile.lower(profile),$0
    )
})
}
    
    /**
     * Create a new Account and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
open func createAndSaveNewAccountWithFactorSource(factorSource: FactorSource, networkId: NetworkId, name: DisplayName)async throws  -> Account  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_create_and_save_new_account_with_factor_source(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSource.lower(factorSource),FfiConverterTypeNetworkID.lower(networkId),FfiConverterTypeDisplayName.lower(name)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAccount.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Create a new Persona and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::PersonaAdded }`
     */
open func createAndSaveNewPersonaWithFactorSource(factorSource: FactorSource, networkId: NetworkId, name: DisplayName, personaData: PersonaData?)async throws  -> Persona  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_create_and_save_new_persona_with_factor_source(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSource.lower(factorSource),FfiConverterTypeNetworkID.lower(networkId),FfiConverterTypeDisplayName.lower(name),FfiConverterOptionTypePersonaData.lower(personaData)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePersona.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Creates the `TransactionManifest` for deleting the given `account_address`. If a
     * `recipient_account_address` is provided, the manifest will also send all the resources from
     * the deleted account to the recipient one.
     */
open func createDeleteAccountManifest(accountAddress: AccountAddress, recipientAccountAddress: AccountAddress?)async throws  -> CreateDeleteAccountManifestOutcome  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_create_delete_account_manifest(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAccountAddress.lower(accountAddress),FfiConverterOptionTypeAccountAddress.lower(recipientAccountAddress)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeCreateDeleteAccountManifestOutcome.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Creates a new unsaved DeviceFactorSource from the provided `mnemonic_with_passphrase`,
     * either a "BDFS" or an "Olympia" one.
     */
open func createDeviceFactorSource(mnemonicWithPassphrase: MnemonicWithPassphrase, factorType: DeviceFactorSourceType) -> DeviceFactorSource  {
    return try!  FfiConverterTypeDeviceFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_sargonos_create_device_factor_source(self.uniffiClonePointer(),
        FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
        FfiConverterTypeDeviceFactorSourceType.lower(factorType),$0
    )
})
}
    
    /**
     * Creates a Subintent given its discriminator, manifest and expiration.
     */
open func createSubintent(intentDiscriminator: IntentDiscriminator, subintentManifest: SubintentManifest, expiration: DappToWalletInteractionSubintentExpiration, message: String?)async throws  -> Subintent  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_create_subintent(
                    self.uniffiClonePointer(),
                    FfiConverterTypeIntentDiscriminator.lower(intentDiscriminator),FfiConverterTypeSubintentManifest.lower(subintentManifest),FfiConverterTypeDappToWalletInteractionSubintentExpiration.lower(expiration),FfiConverterOptionString.lower(message)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSubintent.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * The current gateway host client is using, which affects `current_network_id`.
     * All Network Requests reading from Radix ledger and submission of new
     * transactions will go the the Radix Network of the current Gateway.
     */
open func currentGateway()throws  -> Gateway  {
    return try  FfiConverterTypeGateway.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_current_gateway(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the `ProfileNetwork` corresponding to the network ID set by the
     * current gateway.
     */
open func currentNetwork()throws  -> ProfileNetwork  {
    return try  FfiConverterTypeProfileNetwork.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_current_network(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the id of the Network of the current Gateway set in AppPreferences
     * of the active Profile. This is the canonical value of "current network",
     * which affects which accounts host clients display to end user and to
     * which network transactions are submitted, amongst other behaviors.
     */
open func currentNetworkId()throws  -> NetworkId  {
    return try  FfiConverterTypeNetworkID.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_current_network_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func debugAddAllSampleFactors()async throws  -> [FactorSourceId]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_debug_add_all_sample_factors(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeFactorSourceID.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func deleteWallet()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_delete_wallet(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func derivePublicKeys(derivationPaths: [DerivationPath], source: DerivePublicKeysSource)async throws  -> [HierarchicalDeterministicPublicKey]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_derive_public_keys(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeDerivationPath.lower(derivationPaths),FfiConverterTypeDerivePublicKeysSource.lower(source)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeHierarchicalDeterministicPublicKey.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Returns the entities linked to a given `FactorSource`, either on the current `Profile` or a specific one.
     */
open func entitiesLinkedToFactorSource(factorSource: FactorSource, profileToCheck: ProfileToCheck)async throws  -> EntitiesLinkedToFactorSource  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_entities_linked_to_factor_source(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSource.lower(factorSource),FfiConverterTypeProfileToCheck.lower(profileToCheck)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeEntitiesLinkedToFactorSource.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Returns the entities linked to a given `SecurityStructureID`, either on the current `Profile` or a specific one.
     */
open func entitiesLinkedToSecurityStructure(shieldId: SecurityStructureId, profileToCheck: ProfileToCheck)async throws  -> EntitiesLinkedToSecurityStructure  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_entities_linked_to_security_structure(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSecurityStructureID.lower(shieldId),FfiConverterTypeProfileToCheck.lower(profileToCheck)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeEntitiesLinkedToSecurityStructure.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Returns the entities linked to a given `FactorSource`, either on the current `Profile` or a specific one.
     */
open func factorSourceIntegrity(factorSource: FactorSource)async throws  -> FactorSourceIntegrity  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_factor_source_integrity(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSource.lower(factorSource)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFactorSourceIntegrity.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Returns all the factor sources
     */
open func factorSources()throws  -> [FactorSource]  {
    return try  FfiConverterSequenceTypeFactorSource.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_factor_sources(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the `gateways` values of the current Profile.
     */
open func gateways()throws  -> SavedGateways  {
    return try  FfiConverterTypeSavedGateways.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_gateways(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns all the Security Shields along with the number of entities linked to each Security Shield,
     * either provisionally or currently securified.
     */
open func getShieldsForDisplay()async throws  -> [ShieldForDisplay]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_get_shields_for_display(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeShieldForDisplay.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Has **any** account, at all, including hidden, on any network.
     */
open func hasAnyAccountOnAnyNetwork()throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_has_any_account_on_any_network(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Checks if current Profile contains any `ProfileNetwork`s.
     */
open func hasAnyNetwork()throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_has_any_network(self.uniffiClonePointer(),$0
    )
})
}
    
open func hostId() -> HostId  {
    return try!  FfiConverterTypeHostId.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_sargonos_host_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Imports the `profile`, claims it, set it as active (current) one and
     * saves it into secure storage (with the claim modification).
     *
     * # Emits Event
     * Emits `EventNotification::new(Event::ProfileImported))` event if successful.
     */
open func importProfile(profile: Profile)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_import_profile(
                    self.uniffiClonePointer(),
                    FfiConverterTypeProfile.lower(profile)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func importWallet(profile: Profile, bdfsSkipped: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_import_wallet(
                    self.uniffiClonePointer(),
                    FfiConverterTypeProfile.lower(profile),FfiConverterBool.lower(bdfsSkipped)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func isFactorSourceAlreadyInUse(factorSourceId: FactorSourceId)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_is_factor_source_already_in_use(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSourceID.lower(factorSourceId)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_i8,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_i8,
            freeFunc: ffi_sargon_uniffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Loads a `MnemonicWithPassphrase` with the `id` of `device_factor_source`,
     * from SecureStorage, and returns a `PrivateHierarchicalDeterministicFactorSource`
     * built from both.
     *
     * Useful for when you will want to sign transactions or derive public keys for
     * creation of new entities.
     *
     * Returns `Err` if loading or decoding of `MnemonicWithPassphrase` from
     * SecureStorage fails.
     */
open func loadPrivateDeviceFactorSourceById(id: FactorSourceIdFromHash)async throws  -> PrivateHierarchicalDeterministicFactorSource  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_load_private_device_factor_source_by_id(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSourceIDFromHash.lower(id)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func makeInteractionForApplyingSecurityShield(securityShieldId: SecurityStructureId, addresses: [AddressOfAccountOrPersona])async throws  -> DappToWalletInteractionBatchOfTransactions  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_make_interaction_for_applying_security_shield(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSecurityStructureID.lower(securityShieldId),FfiConverterSequenceTypeAddressOfAccountOrPersona.lower(addresses)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeDappToWalletInteractionBatchOfTransactions.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Updates the profile by marking the account with `account_address` as hidden.
     */
open func markAccountAsHidden(accountAddress: AccountAddress)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_mark_account_as_hidden(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAccountAddress.lower(accountAddress)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Updates the profile by marking the account with `account_address` as tombstoned.
     */
open func markAccountAsTombstoned(accountAddress: AccountAddress)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_mark_account_as_tombstoned(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAccountAddress.lower(accountAddress)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Marks the entities as securified by finding the `AccessControllerAddress` on ledger
     * and updates the profile.
     */
open func markEntitiesAsSecurified(entityAddresses: [AddressOfAccountOrPersona])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_mark_entities_as_securified(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeAddressOfAccountOrPersona.lower(entityAddresses)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func newWallet()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_new_wallet(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func newWalletWithDerivedBdfs(hdFactorSource: PrivateHierarchicalDeterministicFactorSource, accounts: [Account])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_new_wallet_with_derived_bdfs(
                    self.uniffiClonePointer(),
                    FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lower(hdFactorSource),FfiConverterSequenceTypeAccount.lower(accounts)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Polls the status of a `SubintentHash` until it is either `Success` or `Expired`.
     */
open func pollPreAuthorizationStatus(intentHash: SubintentHash, expirationTimestamp: Instant)async throws  -> PreAuthorizationStatus  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_poll_pre_authorization_status(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSubintentHash.lower(intentHash),FfiConverterTypeInstant.lower(expirationTimestamp)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypePreAuthorizationStatus.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Polls the state of a Transaction until we can determine its `TransactionStatus`.
     */
open func pollTransactionStatus(intentHash: TransactionIntentHash)async throws  -> TransactionStatus  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_poll_transaction_status(
                    self.uniffiClonePointer(),
                    FfiConverterTypeTransactionIntentHash.lower(intentHash)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransactionStatus.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func profile()throws  -> Profile  {
    return try  FfiConverterTypeProfile.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_profile(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Renames the Security Shield with the given `shield_id`.
     */
open func renameSecurityStructure(securityStructureId: SecurityStructureId, name: DisplayName)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_rename_security_structure(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSecurityStructureID.lower(securityStructureId),FfiConverterTypeDisplayName.lower(name)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func resolveHostInfo() -> HostInfo  {
    return try!  FfiConverterTypeHostInfo.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_sargonos_resolve_host_info(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the status of the prerequisites for building a Security Shield.
     *
     * According to [definition][doc], a Security Shield can be built if the user has, asides from
     * the Identity factor, "2 or more factors, one of which must be Hardware"
     *
     * [doc]: https://radixdlt.atlassian.net/wiki/spaces/AT/pages/3758063620/MFA+Rules+for+Factors+and+Security+Shields#Factor-Prerequisites
     */
open func securityShieldPrerequisitesStatus()throws  -> SecurityShieldPrerequisitesStatus  {
    return try  FfiConverterTypeSecurityShieldPrerequisitesStatus.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_security_shield_prerequisites_status(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the `SecurityStructureOfFactorSourceIDs` with the given `shield_id`.
     */
open func securityStructureOfFactorSourceIdsBySecurityStructureId(shieldId: SecurityStructureId)throws  -> SecurityStructureOfFactorSourceIDs  {
    return try  FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_security_structure_of_factor_source_ids_by_security_structure_id(self.uniffiClonePointer(),
        FfiConverterTypeSecurityStructureID.lower(shieldId),$0
    )
})
}
    
    /**
     * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
     * in profile.
     */
open func securityStructureOfFactorSourcesFromSecurityStructureOfFactorSourceIds(structureOfIds: SecurityStructureOfFactorSourceIDs)throws  -> SecurityStructureOfFactorSources  {
    return try  FfiConverterTypeSecurityStructureOfFactorSources.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_security_structure_of_factor_sources_from_security_structure_of_factor_source_ids(self.uniffiClonePointer(),
        FfiConverterTypeSecurityStructureOfFactorSourceIDs.lower(structureOfIds),$0
    )
})
}
    
    /**
     * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
     * in profile.
     */
open func securityStructuresOfFactorSourceIds()throws  -> [SecurityStructureOfFactorSourceIDs]  {
    return try  FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_security_structures_of_factor_source_ids(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns all the SecurityStructuresOfFactorSources,
     * by trying to map FactorSourceID level -> FactorSource Level
     */
open func securityStructuresOfFactorSources()throws  -> [SecurityStructureOfFactorSources]  {
    return try  FfiConverterSequenceTypeSecurityStructureOfFactorSources.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_method_sargonos_security_structures_of_factor_sources(self.uniffiClonePointer(),$0
    )
})
}
    
open func setCardPin(factorSource: ArculusCardFactorSource, oldPin: String, newPin: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_set_card_pin(
                    self.uniffiClonePointer(),
                    FfiConverterTypeArculusCardFactorSource.lower(factorSource),FfiConverterString.lower(oldPin),FfiConverterString.lower(newPin)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Sets the Security Shield with the given `shield_id` as the main shield.
     * If a main Security Shield already exists, it is removed and replaced with the new one.
     *
     * # Emits Event
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * Also emits `EventNotification::ProfileModified { change: EventProfileModified::SecurityStructuresUpdated { id } }`
     */
open func setMainSecurityStructure(shieldId: SecurityStructureId)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_set_main_security_structure(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSecurityStructureID.lower(shieldId)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func setProfile(profile: Profile)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_set_profile(
                    self.uniffiClonePointer(),
                    FfiConverterTypeProfile.lower(profile)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func signAuthAccounts(accountAddresses: [AccountAddress], challengeNonce: DappToWalletInteractionAuthChallengeNonce, metadata: DappToWalletInteractionMetadata)async throws  -> SignedAuthIntent  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_sign_auth_accounts(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeAccountAddress.lower(accountAddresses),FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.lower(challengeNonce),FfiConverterTypeDappToWalletInteractionMetadata.lower(metadata)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSignedAuthIntent.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func signAuthPersona(identityAddress: IdentityAddress, challengeNonce: DappToWalletInteractionAuthChallengeNonce, metadata: DappToWalletInteractionMetadata)async throws  -> SignedAuthIntent  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_sign_auth_persona(
                    self.uniffiClonePointer(),
                    FfiConverterTypeIdentityAddress.lower(identityAddress),FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.lower(challengeNonce),FfiConverterTypeDappToWalletInteractionMetadata.lower(metadata)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSignedAuthIntent.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func signSubintent(transactionIntent: Subintent, roleKind: RoleKind)async throws  -> SignedSubintent  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_sign_subintent(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSubintent.lower(transactionIntent),FfiConverterTypeRoleKind.lower(roleKind)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSignedSubintent.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func signTransaction(transactionIntent: TransactionIntent, roleKind: RoleKind)async throws  -> SignedIntent  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_sign_transaction(
                    self.uniffiClonePointer(),
                    FfiConverterTypeTransactionIntent.lower(transactionIntent),FfiConverterTypeRoleKind.lower(roleKind)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSignedIntent.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Submits a notarized transaction payload to the network.
     */
open func submitTransaction(notarizedTransaction: NotarizedTransaction)async throws  -> TransactionIntentHash  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_submit_transaction(
                    self.uniffiClonePointer(),
                    FfiConverterTypeNotarizedTransaction.lower(notarizedTransaction)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTransactionIntentHash.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Checks all active accounts in current network on ledger, if any of them are deleted.
     * Any deleted account is marked as tombstoned in profile.
     *
     * Returns true if any account became tombstoned.
     */
open func syncAccountsDeletedOnLedger()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_sync_accounts_deleted_on_ledger(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_i8,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_i8,
            freeFunc: ffi_sargon_uniffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Triggers the spot check for the given factor source, and returns whether the spot check was successful.
     */
open func triggerSpotCheck(factorSource: FactorSource)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_trigger_spot_check(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSource.lower(factorSource)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_i8,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_i8,
            freeFunc: ffi_sargon_uniffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Updates the account `updated` by mutating current profile and persisting
     * the change to secure storage. Throws `UnknownAccount` error if the account
     * is not found.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountUpdated { address } }`
     */
open func updateAccount(updated: Account)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_update_account(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAccount.lower(updated)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Updates the factor source `updated` by mutating current profile and persisting
     * the change to secure storage. Throws `UpdateFactorSourceMutateFailed` error if the
     * factor source is not found.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
     */
open func updateFactorSource(updated: FactorSource)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_update_factor_source(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSource.lower(updated)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Updates the name of the corresponding `factor_source` in Profile. Throws `UpdateFactorSourceMutateFailed` error if the
     * factor source is not found. Returns the updated `FactorSource`.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
     */
open func updateFactorSourceName(factorSource: FactorSource, name: String)async throws  -> FactorSource  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_update_factor_source_name(
                    self.uniffiClonePointer(),
                    FfiConverterTypeFactorSource.lower(factorSource),FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeFactorSource.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Updates an existing `SecurityStructureOfFactorSourceIDs` in the Profile.
     * Returns an error if the structure does not exist or if it references unknown factors.
     * Emits `Event::ProfileSaved` and `Event::ProfileModified::SecurityStructuresUpdated { ids }` on success.
     */
open func updateSecurityStructureOfFactorSourceIds(structureIds: SecurityStructureOfFactorSourceIDs)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_update_security_structure_of_factor_source_ids(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSecurityStructureOfFactorSourceIDs.lower(structureIds)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func verifyCardPin(factorSource: ArculusCardFactorSource, pin: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_verify_card_pin(
                    self.uniffiClonePointer(),
                    FfiConverterTypeArculusCardFactorSource.lower(factorSource),FfiConverterString.lower(pin)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
    /**
     * Syncs entities in profile with on ledger state.
     * Returns a summary report of the actions performed.
     *
     * Checks performed on entities are:
     * 1. Checks if active accounts on profile are deleted on ledger.
     * Action => to mark them as tombstoned
     * 2. Checks if entities with provisional shield are securified on ledger.
     * Action => to mark them as securified
     * 3. more checks will be developed...
     */
open func wipSyncEntitiesStateOnLedger()async throws  -> EntitySyncOutcome  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_sargonos_wip_sync_entities_state_on_ledger(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeEntitySyncOutcome.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSargonOS: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SargonOs

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SargonOs {
        return SargonOs(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SargonOs) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonOs {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SargonOs, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSargonOS_lift(_ pointer: UnsafeMutableRawPointer) throws -> SargonOs {
    return try FfiConverterTypeSargonOS.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSargonOS_lower(_ value: SargonOs) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSargonOS.lower(value)
}




public protocol SecureStorageDriver : AnyObject {
    
    func loadData(key: SecureStorageKey) async throws  -> BagOfBytes?
    
    func saveData(key: SecureStorageKey, data: BagOfBytes) async throws 
    
    func deleteDataForKey(key: SecureStorageKey) async throws 
    
    func containsDataForKey(key: SecureStorageKey) async throws  -> Bool
    
}

open class SecureStorageDriverImpl:
    SecureStorageDriver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_securestoragedriver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_securestoragedriver(pointer, $0) }
    }

    

    
open func loadData(key: SecureStorageKey)async throws  -> BagOfBytes?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_securestoragedriver_load_data(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSecureStorageKey.lower(key)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func saveData(key: SecureStorageKey, data: BagOfBytes)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_securestoragedriver_save_data(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSecureStorageKey.lower(key),FfiConverterTypeBagOfBytes.lower(data)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func deleteDataForKey(key: SecureStorageKey)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_securestoragedriver_delete_data_for_key(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSecureStorageKey.lower(key)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func containsDataForKey(key: SecureStorageKey)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_securestoragedriver_contains_data_for_key(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSecureStorageKey.lower(key)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_i8,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_i8,
            freeFunc: ffi_sargon_uniffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSecureStorageDriver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSecureStorageDriver] = [UniffiVTableCallbackInterfaceSecureStorageDriver(
        loadData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadData(
                     key: try FfiConverterTypeSecureStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        saveData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            data: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveData(
                     key: try FfiConverterTypeSecureStorageKey.lift(key),
                     data: try FfiConverterTypeBagOfBytes.lift(data)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteDataForKey: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteDataForKey(
                     key: try FfiConverterTypeSecureStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        containsDataForKey: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteI8,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.containsDataForKey(
                     key: try FfiConverterTypeSecureStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Bool) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructI8(
                        returnValue: FfiConverterBool.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructI8(
                        returnValue: 0,
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeSecureStorageDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SecureStorageDriver: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitSecureStorageDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_securestoragedriver(UniffiCallbackInterfaceSecureStorageDriver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecureStorageDriver: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<SecureStorageDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SecureStorageDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecureStorageDriver {
        return SecureStorageDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SecureStorageDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SecureStorageDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecureStorageDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecureStorageDriver {
    return try FfiConverterTypeSecureStorageDriver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecureStorageDriver_lower(_ value: SecureStorageDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSecureStorageDriver.lower(value)
}




/**
 * A builder of `SecurityStructureOfFactorSourceIds` a.k.a. `SecurityShield`,
 * which contains a MatrixOfFactorSourceIds - with primary, recovery, and
 * confirmation roles.
 */
public protocol SecurityShieldBuilderProtocol : AnyObject {
    
    func addFactorSourceToConfirmationOverride(factorSourceId: FactorSourceId)  -> SecurityShieldBuilder
    
    func addFactorSourceToPrimaryOverride(factorSourceId: FactorSourceId)  -> SecurityShieldBuilder
    
    /**
     * Adds the factor source to the primary role threshold list.
     *
     * Also sets the threshold to 1 if this is the first factor set and if
     * the threshold was 0.
     */
    func addFactorSourceToPrimaryThreshold(factorSourceId: FactorSourceId)  -> SecurityShieldBuilder
    
    func addFactorSourceToRecoveryOverride(factorSourceId: FactorSourceId)  -> SecurityShieldBuilder
    
    func additionOfFactorSourceOfKindToConfirmationIsFullyValid(factorSourceKind: FactorSourceKind)  -> Bool
    
    func additionOfFactorSourceOfKindToConfirmationIsValidOrCanBe(factorSourceKind: FactorSourceKind)  -> Bool
    
    func additionOfFactorSourceOfKindToPrimaryOverrideIsFullyValid(factorSourceKind: FactorSourceKind)  -> Bool
    
    func additionOfFactorSourceOfKindToPrimaryOverrideIsValidOrCanBe(factorSourceKind: FactorSourceKind)  -> Bool
    
    func additionOfFactorSourceOfKindToPrimaryThresholdIsFullyValid(factorSourceKind: FactorSourceKind)  -> Bool
    
    func additionOfFactorSourceOfKindToPrimaryThresholdIsValidOrCanBe(factorSourceKind: FactorSourceKind)  -> Bool
    
    func additionOfFactorSourceOfKindToRecoveryIsFullyValid(factorSourceKind: FactorSourceKind)  -> Bool
    
    func additionOfFactorSourceOfKindToRecoveryIsValidOrCanBe(factorSourceKind: FactorSourceKind)  -> Bool
    
    /**
     * "Statically" queries which FactorSourceKinds are allowed for authentication signing.
     */
    func allowedFactorSourceKindsForAuthenticationSigning()  -> [FactorSourceKind]
    
    func autoAssignFactorsToRecoveryAndConfirmationBasedOnPrimary(allFactors: [FactorSource])  -> SecurityShieldBuilder
    
    func build() throws  -> SecurityStructureOfFactorSourceIDs
    
    /**
     * "Statically" queries which FactorSourceKinds are disallowed for authentication signing.
     */
    func disallowedFactorSourceKindsForAuthenticationSigning()  -> [FactorSourceKind]
    
    func getAuthenticationSigningFactor()  -> FactorSourceId?
    
    func getConfirmationFactors()  -> [FactorSourceId]
    
    func getName()  -> String
    
    func getPrimaryOverrideFactors()  -> [FactorSourceId]
    
    func getPrimaryThreshold()  -> Threshold
    
    func getPrimaryThresholdFactors()  -> [FactorSourceId]
    
    func getPrimaryThresholdValues()  -> [Threshold]
    
    func getRecoveryFactors()  -> [FactorSourceId]
    
    func getTimeUntilTimedConfirmationIsCallable()  -> TimePeriod
    
    /**
     * "Statically" queries if `factor_source_kind`` is allowed for authentication signing.
     */
    func isAllowedFactorSourceKindForAuthenticationSigning(factorSourceKind: FactorSourceKind)  -> Bool
    
    func removeAllFactorsFromPrimaryOverride()  -> SecurityShieldBuilder
    
    func removeFactorFromAllRoles(factorSourceId: FactorSourceId)  -> SecurityShieldBuilder
    
    func removeFactorFromConfirmation(factorSourceId: FactorSourceId)  -> SecurityShieldBuilder
    
    func removeFactorFromPrimary(factorSourceId: FactorSourceId, factorListKind: FactorListKind)  -> SecurityShieldBuilder
    
    func removeFactorFromRecovery(factorSourceId: FactorSourceId)  -> SecurityShieldBuilder
    
    func resetRecoveryAndConfirmationRoleState()  -> SecurityShieldBuilder
    
    func selectedPrimaryThresholdFactorsStatus()  -> SelectedPrimaryThresholdFactorsStatus
    
    func setAuthenticationSigningFactor(new: FactorSourceId?)  -> SecurityShieldBuilder
    
    func setName(name: String)  -> SecurityShieldBuilder
    
    func setThreshold(threshold: Threshold)  -> SecurityShieldBuilder
    
    func setTimeUntilDelayedConfirmationIsCallable(timePeriod: TimePeriod)  -> SecurityShieldBuilder
    
    func sortedFactorSourcesForPrimaryThresholdSelection(factorSources: [FactorSource])  -> [FactorSource]
    
    func status()  -> SecurityShieldBuilderStatus
    
    func validateRoleInIsolation(role: RoleKind)  -> SecurityShieldBuilderRuleViolation?
    
    func validationForAdditionOfFactorSourceToConfirmationOverrideForEach(factorSources: [FactorSourceId])  -> [FactorSourceValidationStatus]
    
    func validationForAdditionOfFactorSourceToPrimaryOverrideForEach(factorSources: [FactorSourceId])  -> [FactorSourceValidationStatus]
    
    func validationForAdditionOfFactorSourceToPrimaryThresholdForEach(factorSources: [FactorSourceId])  -> [FactorSourceValidationStatus]
    
    func validationForAdditionOfFactorSourceToRecoveryOverrideForEach(factorSources: [FactorSourceId])  -> [FactorSourceValidationStatus]
    
}

/**
 * A builder of `SecurityStructureOfFactorSourceIds` a.k.a. `SecurityShield`,
 * which contains a MatrixOfFactorSourceIds - with primary, recovery, and
 * confirmation roles.
 */
open class SecurityShieldBuilder:
    Equatable,
    Hashable,
    SecurityShieldBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_securityshieldbuilder(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_sargon_uniffi_fn_constructor_securityshieldbuilder_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_securityshieldbuilder(pointer, $0) }
    }

    
public static func withSecurityStructureOfFactorSourceIds(securityStructureOfFactorSourceIds: SecurityStructureOfFactorSourceIDs) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_constructor_securityshieldbuilder_with_security_structure_of_factor_source_ids(
        FfiConverterTypeSecurityStructureOfFactorSourceIDs.lower(securityStructureOfFactorSourceIds),$0
    )
})
}
    

    
open func addFactorSourceToConfirmationOverride(factorSourceId: FactorSourceId) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_add_factor_source_to_confirmation_override(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceID.lower(factorSourceId),$0
    )
})
}
    
open func addFactorSourceToPrimaryOverride(factorSourceId: FactorSourceId) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_add_factor_source_to_primary_override(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceID.lower(factorSourceId),$0
    )
})
}
    
    /**
     * Adds the factor source to the primary role threshold list.
     *
     * Also sets the threshold to 1 if this is the first factor set and if
     * the threshold was 0.
     */
open func addFactorSourceToPrimaryThreshold(factorSourceId: FactorSourceId) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_add_factor_source_to_primary_threshold(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceID.lower(factorSourceId),$0
    )
})
}
    
open func addFactorSourceToRecoveryOverride(factorSourceId: FactorSourceId) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_add_factor_source_to_recovery_override(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceID.lower(factorSourceId),$0
    )
})
}
    
open func additionOfFactorSourceOfKindToConfirmationIsFullyValid(factorSourceKind: FactorSourceKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_confirmation_is_fully_valid(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceKind.lower(factorSourceKind),$0
    )
})
}
    
open func additionOfFactorSourceOfKindToConfirmationIsValidOrCanBe(factorSourceKind: FactorSourceKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_confirmation_is_valid_or_can_be(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceKind.lower(factorSourceKind),$0
    )
})
}
    
open func additionOfFactorSourceOfKindToPrimaryOverrideIsFullyValid(factorSourceKind: FactorSourceKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_primary_override_is_fully_valid(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceKind.lower(factorSourceKind),$0
    )
})
}
    
open func additionOfFactorSourceOfKindToPrimaryOverrideIsValidOrCanBe(factorSourceKind: FactorSourceKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_primary_override_is_valid_or_can_be(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceKind.lower(factorSourceKind),$0
    )
})
}
    
open func additionOfFactorSourceOfKindToPrimaryThresholdIsFullyValid(factorSourceKind: FactorSourceKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_primary_threshold_is_fully_valid(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceKind.lower(factorSourceKind),$0
    )
})
}
    
open func additionOfFactorSourceOfKindToPrimaryThresholdIsValidOrCanBe(factorSourceKind: FactorSourceKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_primary_threshold_is_valid_or_can_be(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceKind.lower(factorSourceKind),$0
    )
})
}
    
open func additionOfFactorSourceOfKindToRecoveryIsFullyValid(factorSourceKind: FactorSourceKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_recovery_is_fully_valid(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceKind.lower(factorSourceKind),$0
    )
})
}
    
open func additionOfFactorSourceOfKindToRecoveryIsValidOrCanBe(factorSourceKind: FactorSourceKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_recovery_is_valid_or_can_be(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceKind.lower(factorSourceKind),$0
    )
})
}
    
    /**
     * "Statically" queries which FactorSourceKinds are allowed for authentication signing.
     */
open func allowedFactorSourceKindsForAuthenticationSigning() -> [FactorSourceKind]  {
    return try!  FfiConverterSequenceTypeFactorSourceKind.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_allowed_factor_source_kinds_for_authentication_signing(self.uniffiClonePointer(),$0
    )
})
}
    
open func autoAssignFactorsToRecoveryAndConfirmationBasedOnPrimary(allFactors: [FactorSource]) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_auto_assign_factors_to_recovery_and_confirmation_based_on_primary(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFactorSource.lower(allFactors),$0
    )
})
}
    
open func build()throws  -> SecurityStructureOfFactorSourceIDs  {
    return try  FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(try rustCallWithError(FfiConverterTypeSecurityShieldBuilderRuleViolation.lift) {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_build(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * "Statically" queries which FactorSourceKinds are disallowed for authentication signing.
     */
open func disallowedFactorSourceKindsForAuthenticationSigning() -> [FactorSourceKind]  {
    return try!  FfiConverterSequenceTypeFactorSourceKind.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_disallowed_factor_source_kinds_for_authentication_signing(self.uniffiClonePointer(),$0
    )
})
}
    
open func getAuthenticationSigningFactor() -> FactorSourceId?  {
    return try!  FfiConverterOptionTypeFactorSourceID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_get_authentication_signing_factor(self.uniffiClonePointer(),$0
    )
})
}
    
open func getConfirmationFactors() -> [FactorSourceId]  {
    return try!  FfiConverterSequenceTypeFactorSourceID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_get_confirmation_factors(self.uniffiClonePointer(),$0
    )
})
}
    
open func getName() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_get_name(self.uniffiClonePointer(),$0
    )
})
}
    
open func getPrimaryOverrideFactors() -> [FactorSourceId]  {
    return try!  FfiConverterSequenceTypeFactorSourceID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_get_primary_override_factors(self.uniffiClonePointer(),$0
    )
})
}
    
open func getPrimaryThreshold() -> Threshold  {
    return try!  FfiConverterTypeThreshold.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_get_primary_threshold(self.uniffiClonePointer(),$0
    )
})
}
    
open func getPrimaryThresholdFactors() -> [FactorSourceId]  {
    return try!  FfiConverterSequenceTypeFactorSourceID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_get_primary_threshold_factors(self.uniffiClonePointer(),$0
    )
})
}
    
open func getPrimaryThresholdValues() -> [Threshold]  {
    return try!  FfiConverterSequenceTypeThreshold.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_get_primary_threshold_values(self.uniffiClonePointer(),$0
    )
})
}
    
open func getRecoveryFactors() -> [FactorSourceId]  {
    return try!  FfiConverterSequenceTypeFactorSourceID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_get_recovery_factors(self.uniffiClonePointer(),$0
    )
})
}
    
open func getTimeUntilTimedConfirmationIsCallable() -> TimePeriod  {
    return try!  FfiConverterTypeTimePeriod.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_get_time_until_timed_confirmation_is_callable(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * "Statically" queries if `factor_source_kind`` is allowed for authentication signing.
     */
open func isAllowedFactorSourceKindForAuthenticationSigning(factorSourceKind: FactorSourceKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_is_allowed_factor_source_kind_for_authentication_signing(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceKind.lower(factorSourceKind),$0
    )
})
}
    
open func removeAllFactorsFromPrimaryOverride() -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_remove_all_factors_from_primary_override(self.uniffiClonePointer(),$0
    )
})
}
    
open func removeFactorFromAllRoles(factorSourceId: FactorSourceId) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_remove_factor_from_all_roles(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceID.lower(factorSourceId),$0
    )
})
}
    
open func removeFactorFromConfirmation(factorSourceId: FactorSourceId) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_remove_factor_from_confirmation(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceID.lower(factorSourceId),$0
    )
})
}
    
open func removeFactorFromPrimary(factorSourceId: FactorSourceId, factorListKind: FactorListKind) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_remove_factor_from_primary(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceID.lower(factorSourceId),
        FfiConverterTypeFactorListKind.lower(factorListKind),$0
    )
})
}
    
open func removeFactorFromRecovery(factorSourceId: FactorSourceId) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_remove_factor_from_recovery(self.uniffiClonePointer(),
        FfiConverterTypeFactorSourceID.lower(factorSourceId),$0
    )
})
}
    
open func resetRecoveryAndConfirmationRoleState() -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_reset_recovery_and_confirmation_role_state(self.uniffiClonePointer(),$0
    )
})
}
    
open func selectedPrimaryThresholdFactorsStatus() -> SelectedPrimaryThresholdFactorsStatus  {
    return try!  FfiConverterTypeSelectedPrimaryThresholdFactorsStatus.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_selected_primary_threshold_factors_status(self.uniffiClonePointer(),$0
    )
})
}
    
open func setAuthenticationSigningFactor(new: FactorSourceId?) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_set_authentication_signing_factor(self.uniffiClonePointer(),
        FfiConverterOptionTypeFactorSourceID.lower(new),$0
    )
})
}
    
open func setName(name: String) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_set_name(self.uniffiClonePointer(),
        FfiConverterString.lower(name),$0
    )
})
}
    
open func setThreshold(threshold: Threshold) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_set_threshold(self.uniffiClonePointer(),
        FfiConverterTypeThreshold.lower(threshold),$0
    )
})
}
    
open func setTimeUntilDelayedConfirmationIsCallable(timePeriod: TimePeriod) -> SecurityShieldBuilder  {
    return try!  FfiConverterTypeSecurityShieldBuilder.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_set_time_until_delayed_confirmation_is_callable(self.uniffiClonePointer(),
        FfiConverterTypeTimePeriod.lower(timePeriod),$0
    )
})
}
    
open func sortedFactorSourcesForPrimaryThresholdSelection(factorSources: [FactorSource]) -> [FactorSource]  {
    return try!  FfiConverterSequenceTypeFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_sorted_factor_sources_for_primary_threshold_selection(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFactorSource.lower(factorSources),$0
    )
})
}
    
open func status() -> SecurityShieldBuilderStatus  {
    return try!  FfiConverterTypeSecurityShieldBuilderStatus.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_status(self.uniffiClonePointer(),$0
    )
})
}
    
open func validateRoleInIsolation(role: RoleKind) -> SecurityShieldBuilderRuleViolation?  {
    return try!  FfiConverterOptionTypeSecurityShieldBuilderRuleViolation.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_validate_role_in_isolation(self.uniffiClonePointer(),
        FfiConverterTypeRoleKind.lower(role),$0
    )
})
}
    
open func validationForAdditionOfFactorSourceToConfirmationOverrideForEach(factorSources: [FactorSourceId]) -> [FactorSourceValidationStatus]  {
    return try!  FfiConverterSequenceTypeFactorSourceValidationStatus.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_validation_for_addition_of_factor_source_to_confirmation_override_for_each(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFactorSourceID.lower(factorSources),$0
    )
})
}
    
open func validationForAdditionOfFactorSourceToPrimaryOverrideForEach(factorSources: [FactorSourceId]) -> [FactorSourceValidationStatus]  {
    return try!  FfiConverterSequenceTypeFactorSourceValidationStatus.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_validation_for_addition_of_factor_source_to_primary_override_for_each(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFactorSourceID.lower(factorSources),$0
    )
})
}
    
open func validationForAdditionOfFactorSourceToPrimaryThresholdForEach(factorSources: [FactorSourceId]) -> [FactorSourceValidationStatus]  {
    return try!  FfiConverterSequenceTypeFactorSourceValidationStatus.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_validation_for_addition_of_factor_source_to_primary_threshold_for_each(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFactorSourceID.lower(factorSources),$0
    )
})
}
    
open func validationForAdditionOfFactorSourceToRecoveryOverrideForEach(factorSources: [FactorSourceId]) -> [FactorSourceValidationStatus]  {
    return try!  FfiConverterSequenceTypeFactorSourceValidationStatus.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_validation_for_addition_of_factor_source_to_recovery_override_for_each(self.uniffiClonePointer(),
        FfiConverterSequenceTypeFactorSourceID.lower(factorSources),$0
    )
})
}
    
    public static func == (self: SecurityShieldBuilder, other: SecurityShieldBuilder) -> Bool {
        return try!  FfiConverterBool.lift(
            try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_uniffi_trait_eq_eq(self.uniffiClonePointer(),
        FfiConverterTypeSecurityShieldBuilder.lower(other),$0
    )
}
        )
    }
    open func hash(into hasher: inout Hasher) {
        let val = try!  FfiConverterUInt64.lift(
            try! rustCall() {
    uniffi_sargon_uniffi_fn_method_securityshieldbuilder_uniffi_trait_hash(self.uniffiClonePointer(),$0
    )
}
        )
        hasher.combine(val)
    }

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityShieldBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SecurityShieldBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecurityShieldBuilder {
        return SecurityShieldBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SecurityShieldBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityShieldBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SecurityShieldBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityShieldBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecurityShieldBuilder {
    return try FfiConverterTypeSecurityShieldBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityShieldBuilder_lower(_ value: SecurityShieldBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSecurityShieldBuilder.lower(value)
}




public protocol UnsafeStorageDriver : AnyObject {
    
    func loadData(key: UnsafeStorageKey) async throws  -> BagOfBytes?
    
    func saveData(key: UnsafeStorageKey, data: BagOfBytes) async throws 
    
    func deleteDataForKey(key: UnsafeStorageKey) async throws 
    
}

open class UnsafeStorageDriverImpl:
    UnsafeStorageDriver {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_unsafestoragedriver(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_unsafestoragedriver(pointer, $0) }
    }

    

    
open func loadData(key: UnsafeStorageKey)async throws  -> BagOfBytes?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_unsafestoragedriver_load_data(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUnsafeStorageKey.lower(key)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func saveData(key: UnsafeStorageKey, data: BagOfBytes)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_unsafestoragedriver_save_data(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUnsafeStorageKey.lower(key),FfiConverterTypeBagOfBytes.lower(data)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    
open func deleteDataForKey(key: UnsafeStorageKey)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_sargon_uniffi_fn_method_unsafestoragedriver_delete_data_for_key(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUnsafeStorageKey.lower(key)
                )
            },
            pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
            completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
            freeFunc: ffi_sargon_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCommonError.lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceUnsafeStorageDriver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceUnsafeStorageDriver] = [UniffiVTableCallbackInterfaceUnsafeStorageDriver(
        loadData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeUnsafeStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadData(
                     key: try FfiConverterTypeUnsafeStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        saveData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            data: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeUnsafeStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveData(
                     key: try FfiConverterTypeUnsafeStorageKey.lift(key),
                     data: try FfiConverterTypeBagOfBytes.lift(data)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteDataForKey: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeUnsafeStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteDataForKey(
                     key: try FfiConverterTypeUnsafeStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeUnsafeStorageDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface UnsafeStorageDriver: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitUnsafeStorageDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_unsafestoragedriver(UniffiCallbackInterfaceUnsafeStorageDriver.vtable)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsafeStorageDriver: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<UnsafeStorageDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnsafeStorageDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsafeStorageDriver {
        return UnsafeStorageDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnsafeStorageDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsafeStorageDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnsafeStorageDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsafeStorageDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsafeStorageDriver {
    return try FfiConverterTypeUnsafeStorageDriver.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsafeStorageDriver_lower(_ value: UnsafeStorageDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnsafeStorageDriver.lower(value)
}


/**
 * Address to an AccessController that controls an Account or Identity (Persona),
 * it said entity has been "securified", e.g.:
 * `"accesscontroller_rdx1c0duj4lq0dc3cpl8qd420fpn5eckh8ljeysvjm894lyl5ja5yq6y5a"`
 *
 * When a user applies a SecurityStructureConfiguration for the first time on a
 * non-securified entity (and signs and submit the resulting TX) said entity is
 * "assigned" an AccessControllerAddress by the network.
 *
 * An `AccessControllerAddress` has the [Scrypto's `EntityType`][entt] `GlobalAccessController`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalAccessControllerAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L247-L248
 */
public struct AccessControllerAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension AccessControllerAddress: Sendable {} 
extension AccessControllerAddress: Equatable, Hashable {
    public static func ==(lhs: AccessControllerAddress, rhs: AccessControllerAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccessControllerAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccessControllerAddress {
        return
            try AccessControllerAddress(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AccessControllerAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccessControllerAddress_lift(_ buf: RustBuffer) throws -> AccessControllerAddress {
    return try FfiConverterTypeAccessControllerAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccessControllerAddress_lower(_ value: AccessControllerAddress) -> RustBuffer {
    return FfiConverterTypeAccessControllerAddress.lower(value)
}


/**
 * A network unique account with a unique public address and a set of cryptographic
 * factors used to control it.
 *
 * Used to own and control assets on the radix network. Uniquely identified by an
 * account address, e.g.
 *
 * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
 *
 * But most commonly users see the address on its abbreviated form:
 *
 * `acco...nvjdwr`
 *
 * Accounts have a display name and an appearance id.
 *
 * An account can be either controlled by a "Babylon" DeviceFactorSource or a
 * Legacy one imported from Olympia, or a Ledger hardware wallet, which too might
 * have been imported from Olympia.
 */
public struct Account {
    /**
     * The ID of the network this account can be used with.
     */
    public var networkId: NetworkId
    /**
     * A globally unique identifier of this account, being a human readable
     * address of an account. Always starts with `"account_"``, for example:
     *
     * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
     *
     * Most commonly the user will see this address in its abbreviated
     * form which is:
     *
     * `acco...nvjdwr`
     *
     * No two addresses will ever be the same even for the same factor source
     * but on different networks, since the public keys controlling the
     * accounts depend on the network id.
     */
    public var address: AccountAddress
    /**
     * An off-ledger display name or description chosen by the user when she
     * created this account.
     */
    public var displayName: DisplayName
    /**
     * Security state of this account, either "securified" or not.
     */
    public var securityState: EntitySecurityState
    /**
     * The visual cue user learns to associated this account with, typically
     * a beautiful colorful gradient.
     */
    public var appearanceId: AppearanceId
    /**
     * An order set of `EntityFlag`s used to describe certain Off-ledger
     * user state about Accounts or Personas, such as if an entity is
     * marked as hidden or not.
     */
    public var flags: [EntityFlag]
    /**
     * The on ledger synced settings for this account, contains e.g.
     * ThirdPartyDeposit settings, with deposit rules for assets.
     */
    public var onLedgerSettings: OnLedgerSettings

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network this account can be used with.
         */networkId: NetworkId, 
        /**
         * A globally unique identifier of this account, being a human readable
         * address of an account. Always starts with `"account_"``, for example:
         *
         * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
         *
         * Most commonly the user will see this address in its abbreviated
         * form which is:
         *
         * `acco...nvjdwr`
         *
         * No two addresses will ever be the same even for the same factor source
         * but on different networks, since the public keys controlling the
         * accounts depend on the network id.
         */address: AccountAddress, 
        /**
         * An off-ledger display name or description chosen by the user when she
         * created this account.
         */displayName: DisplayName, 
        /**
         * Security state of this account, either "securified" or not.
         */securityState: EntitySecurityState, 
        /**
         * The visual cue user learns to associated this account with, typically
         * a beautiful colorful gradient.
         */appearanceId: AppearanceId, 
        /**
         * An order set of `EntityFlag`s used to describe certain Off-ledger
         * user state about Accounts or Personas, such as if an entity is
         * marked as hidden or not.
         */flags: [EntityFlag], 
        /**
         * The on ledger synced settings for this account, contains e.g.
         * ThirdPartyDeposit settings, with deposit rules for assets.
         */onLedgerSettings: OnLedgerSettings) {
        self.networkId = networkId
        self.address = address
        self.displayName = displayName
        self.securityState = securityState
        self.appearanceId = appearanceId
        self.flags = flags
        self.onLedgerSettings = onLedgerSettings
    }
}


extension Account: Sendable {} 
extension Account: Equatable, Hashable {
    public static func ==(lhs: Account, rhs: Account) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.securityState != rhs.securityState {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        if lhs.onLedgerSettings != rhs.onLedgerSettings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(securityState)
        hasher.combine(appearanceId)
        hasher.combine(flags)
        hasher.combine(onLedgerSettings)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Account {
        return
            try Account(
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                address: FfiConverterTypeAccountAddress.read(from: &buf), 
                displayName: FfiConverterTypeDisplayName.read(from: &buf), 
                securityState: FfiConverterTypeEntitySecurityState.read(from: &buf), 
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf), 
                flags: FfiConverterSequenceTypeEntityFlag.read(from: &buf), 
                onLedgerSettings: FfiConverterTypeOnLedgerSettings.read(from: &buf)
        )
    }

    public static func write(_ value: Account, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeEntitySecurityState.write(value.securityState, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
        FfiConverterSequenceTypeEntityFlag.write(value.flags, into: &buf)
        FfiConverterTypeOnLedgerSettings.write(value.onLedgerSettings, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccount_lift(_ buf: RustBuffer) throws -> Account {
    return try FfiConverterTypeAccount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccount_lower(_ value: Account) -> RustBuffer {
    return FfiConverterTypeAccount.lower(value)
}


/**
 * Human readable address of an account. Always starts with `"account_"``, for example:
 *
 * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
 *
 * Most commonly the user will see this address in its abbreviated
 * form which is:
 *
 * `acco...nvjdwr`
 *
 * Addresses are checksummed, as per Bech32. **Only** *Account* addresses starts with
 * the prefix `account_`.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of AccountAddresses:
 * * GlobalAccount
 * * GlobalVirtualSecp256k1Account
 * * GlobalVirtualEd25519Account
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalAccountAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L224-L228
 */
public struct AccountAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension AccountAddress: Sendable {} 
extension AccountAddress: Equatable, Hashable {
    public static func ==(lhs: AccountAddress, rhs: AccountAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountAddress {
        return
            try AccountAddress(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AccountAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountAddress_lift(_ buf: RustBuffer) throws -> AccountAddress {
    return try FfiConverterTypeAccountAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountAddress_lower(_ value: AccountAddress) -> RustBuffer {
    return FfiConverterTypeAccountAddress.lower(value)
}


/**
 * Represents an account deposit, which includes specified and unspecified resources.
 */
public struct AccountDeposits {
    public var specifiedResources: [SimpleResourceBounds]
    public var unspecifiedResources: UnspecifiedResources

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(specifiedResources: [SimpleResourceBounds], unspecifiedResources: UnspecifiedResources) {
        self.specifiedResources = specifiedResources
        self.unspecifiedResources = unspecifiedResources
    }
}


extension AccountDeposits: Sendable {} 
extension AccountDeposits: Equatable, Hashable {
    public static func ==(lhs: AccountDeposits, rhs: AccountDeposits) -> Bool {
        if lhs.specifiedResources != rhs.specifiedResources {
            return false
        }
        if lhs.unspecifiedResources != rhs.unspecifiedResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(specifiedResources)
        hasher.combine(unspecifiedResources)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountDeposits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountDeposits {
        return
            try AccountDeposits(
                specifiedResources: FfiConverterSequenceTypeSimpleResourceBounds.read(from: &buf), 
                unspecifiedResources: FfiConverterTypeUnspecifiedResources.read(from: &buf)
        )
    }

    public static func write(_ value: AccountDeposits, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeSimpleResourceBounds.write(value.specifiedResources, into: &buf)
        FfiConverterTypeUnspecifiedResources.write(value.unspecifiedResources, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountDeposits_lift(_ buf: RustBuffer) throws -> AccountDeposits {
    return try FfiConverterTypeAccountDeposits.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountDeposits_lower(_ value: AccountDeposits) -> RustBuffer {
    return FfiConverterTypeAccountDeposits.lower(value)
}


/**
 * A minimal version of an [`Account`] meant for
 * display purposes within wallet
 */
public struct AccountForDisplay {
    public var address: AccountAddress
    public var displayName: DisplayName
    public var appearanceId: AppearanceId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: AccountAddress, displayName: DisplayName, appearanceId: AppearanceId) {
        self.address = address
        self.displayName = displayName
        self.appearanceId = appearanceId
    }
}


extension AccountForDisplay: Sendable {} 
extension AccountForDisplay: Equatable, Hashable {
    public static func ==(lhs: AccountForDisplay, rhs: AccountForDisplay) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(appearanceId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountForDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountForDisplay {
        return
            try AccountForDisplay(
                address: FfiConverterTypeAccountAddress.read(from: &buf), 
                displayName: FfiConverterTypeDisplayName.read(from: &buf), 
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf)
        )
    }

    public static func write(_ value: AccountForDisplay, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountForDisplay_lift(_ buf: RustBuffer) throws -> AccountForDisplay {
    return try FfiConverterTypeAccountForDisplay.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountForDisplay_lower(_ value: AccountForDisplay) -> RustBuffer {
    return FfiConverterTypeAccountForDisplay.lower(value)
}


public struct AccountPath {
    public var networkId: NetworkId
    public var keyKind: Cap26KeyKind
    public var index: Hardened

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, keyKind: Cap26KeyKind, index: Hardened) {
        self.networkId = networkId
        self.keyKind = keyKind
        self.index = index
    }
}


extension AccountPath: Sendable {} 
extension AccountPath: Equatable, Hashable {
    public static func ==(lhs: AccountPath, rhs: AccountPath) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.keyKind != rhs.keyKind {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(keyKind)
        hasher.combine(index)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountPath {
        return
            try AccountPath(
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                keyKind: FfiConverterTypeCAP26KeyKind.read(from: &buf), 
                index: FfiConverterTypeHardened.read(from: &buf)
        )
    }

    public static func write(_ value: AccountPath, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeCAP26KeyKind.write(value.keyKind, into: &buf)
        FfiConverterTypeHardened.write(value.index, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountPath_lift(_ buf: RustBuffer) throws -> AccountPath {
    return try FfiConverterTypeAccountPath.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountPath_lower(_ value: AccountPath) -> RustBuffer {
    return FfiConverterTypeAccountPath.lower(value)
}


/**
 * A struct that represents the addresses of entities in a bad state.
 */
public struct AddressesOfEntitiesInBadState {
    public var accounts: [AccountAddress]
    public var hiddenAccounts: [AccountAddress]
    public var personas: [IdentityAddress]
    public var hiddenPersonas: [IdentityAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accounts: [AccountAddress], hiddenAccounts: [AccountAddress], personas: [IdentityAddress], hiddenPersonas: [IdentityAddress]) {
        self.accounts = accounts
        self.hiddenAccounts = hiddenAccounts
        self.personas = personas
        self.hiddenPersonas = hiddenPersonas
    }
}


extension AddressesOfEntitiesInBadState: Sendable {} 
extension AddressesOfEntitiesInBadState: Equatable, Hashable {
    public static func ==(lhs: AddressesOfEntitiesInBadState, rhs: AddressesOfEntitiesInBadState) -> Bool {
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.hiddenAccounts != rhs.hiddenAccounts {
            return false
        }
        if lhs.personas != rhs.personas {
            return false
        }
        if lhs.hiddenPersonas != rhs.hiddenPersonas {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accounts)
        hasher.combine(hiddenAccounts)
        hasher.combine(personas)
        hasher.combine(hiddenPersonas)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressesOfEntitiesInBadState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressesOfEntitiesInBadState {
        return
            try AddressesOfEntitiesInBadState(
                accounts: FfiConverterSequenceTypeAccountAddress.read(from: &buf), 
                hiddenAccounts: FfiConverterSequenceTypeAccountAddress.read(from: &buf), 
                personas: FfiConverterSequenceTypeIdentityAddress.read(from: &buf), 
                hiddenPersonas: FfiConverterSequenceTypeIdentityAddress.read(from: &buf)
        )
    }

    public static func write(_ value: AddressesOfEntitiesInBadState, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAccountAddress.write(value.accounts, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.hiddenAccounts, into: &buf)
        FfiConverterSequenceTypeIdentityAddress.write(value.personas, into: &buf)
        FfiConverterSequenceTypeIdentityAddress.write(value.hiddenPersonas, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressesOfEntitiesInBadState_lift(_ buf: RustBuffer) throws -> AddressesOfEntitiesInBadState {
    return try FfiConverterTypeAddressesOfEntitiesInBadState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressesOfEntitiesInBadState_lower(_ value: AddressesOfEntitiesInBadState) -> RustBuffer {
    return FfiConverterTypeAddressesOfEntitiesInBadState.lower(value)
}


/**
 * AES GCM 256 encryption
 */
public struct AesGcm256 {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}


extension AesGcm256: Sendable {} 
extension AesGcm256: Equatable, Hashable {
    public static func ==(lhs: AesGcm256, rhs: AesGcm256) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAesGcm256: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesGcm256 {
        return
            AesGcm256()
    }

    public static func write(_ value: AesGcm256, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesGcm256_lift(_ buf: RustBuffer) throws -> AesGcm256 {
    return try FfiConverterTypeAesGcm256.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAesGcm256_lower(_ value: AesGcm256) -> RustBuffer {
    return FfiConverterTypeAesGcm256.lower(value)
}


/**
 * Settings related to displaying of information to the user inside the app.
 *
 * **N.B. neither of these settings are in fact not yet used by clients.**
 */
public struct AppDisplay {
    /**
     * If we should show the aggregate value of users portfolio in fiat currency
     * of hide it.
     */
    public var isCurrencyAmountVisible: Bool
    /**
     * Which fiat currency the prices are measured in.
     */
    public var fiatCurrencyPriceTarget: FiatCurrency

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If we should show the aggregate value of users portfolio in fiat currency
         * of hide it.
         */isCurrencyAmountVisible: Bool, 
        /**
         * Which fiat currency the prices are measured in.
         */fiatCurrencyPriceTarget: FiatCurrency) {
        self.isCurrencyAmountVisible = isCurrencyAmountVisible
        self.fiatCurrencyPriceTarget = fiatCurrencyPriceTarget
    }
}


extension AppDisplay: Sendable {} 
extension AppDisplay: Equatable, Hashable {
    public static func ==(lhs: AppDisplay, rhs: AppDisplay) -> Bool {
        if lhs.isCurrencyAmountVisible != rhs.isCurrencyAmountVisible {
            return false
        }
        if lhs.fiatCurrencyPriceTarget != rhs.fiatCurrencyPriceTarget {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCurrencyAmountVisible)
        hasher.combine(fiatCurrencyPriceTarget)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppDisplay {
        return
            try AppDisplay(
                isCurrencyAmountVisible: FfiConverterBool.read(from: &buf), 
                fiatCurrencyPriceTarget: FfiConverterTypeFiatCurrency.read(from: &buf)
        )
    }

    public static func write(_ value: AppDisplay, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCurrencyAmountVisible, into: &buf)
        FfiConverterTypeFiatCurrency.write(value.fiatCurrencyPriceTarget, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppDisplay_lift(_ buf: RustBuffer) throws -> AppDisplay {
    return try FfiConverterTypeAppDisplay.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppDisplay_lower(_ value: AppDisplay) -> RustBuffer {
    return FfiConverterTypeAppDisplay.lower(value)
}


/**
 * Collection of all settings, preferences and configuration related to how the wallet
 * behaves and looks.
 *
 * Current and other saved Gateways, security settings,
 * App Display settings and preferences for transaction.
 */
public struct AppPreferences {
    /**
     * Display settings in the wallet app, such as appearances, currency etc.
     */
    public var display: AppDisplay
    /**
     * The gateway of the active network and collection of other saved gateways.
     */
    public var gateways: SavedGateways
    /**
     * Controls e.g. if Profile Snapshot gets synced to iCloud/Google backup or not.
     */
    public var security: Security
    /**
     * Default config related to making of transactions
     */
    public var transaction: TransactionPreferences

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Display settings in the wallet app, such as appearances, currency etc.
         */display: AppDisplay, 
        /**
         * The gateway of the active network and collection of other saved gateways.
         */gateways: SavedGateways, 
        /**
         * Controls e.g. if Profile Snapshot gets synced to iCloud/Google backup or not.
         */security: Security, 
        /**
         * Default config related to making of transactions
         */transaction: TransactionPreferences) {
        self.display = display
        self.gateways = gateways
        self.security = security
        self.transaction = transaction
    }
}


extension AppPreferences: Sendable {} 
extension AppPreferences: Equatable, Hashable {
    public static func ==(lhs: AppPreferences, rhs: AppPreferences) -> Bool {
        if lhs.display != rhs.display {
            return false
        }
        if lhs.gateways != rhs.gateways {
            return false
        }
        if lhs.security != rhs.security {
            return false
        }
        if lhs.transaction != rhs.transaction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(display)
        hasher.combine(gateways)
        hasher.combine(security)
        hasher.combine(transaction)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppPreferences {
        return
            try AppPreferences(
                display: FfiConverterTypeAppDisplay.read(from: &buf), 
                gateways: FfiConverterTypeSavedGateways.read(from: &buf), 
                security: FfiConverterTypeSecurity.read(from: &buf), 
                transaction: FfiConverterTypeTransactionPreferences.read(from: &buf)
        )
    }

    public static func write(_ value: AppPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeAppDisplay.write(value.display, into: &buf)
        FfiConverterTypeSavedGateways.write(value.gateways, into: &buf)
        FfiConverterTypeSecurity.write(value.security, into: &buf)
        FfiConverterTypeTransactionPreferences.write(value.transaction, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppPreferences_lift(_ buf: RustBuffer) throws -> AppPreferences {
    return try FfiConverterTypeAppPreferences.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppPreferences_lower(_ value: AppPreferences) -> RustBuffer {
    return FfiConverterTypeAppPreferences.lower(value)
}


public struct AppearanceId {
    public var value: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt8) {
        self.value = value
    }
}


extension AppearanceId: Sendable {} 
extension AppearanceId: Equatable, Hashable {
    public static func ==(lhs: AppearanceId, rhs: AppearanceId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAppearanceID: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppearanceId {
        return
            try AppearanceId(
                value: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: AppearanceId, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppearanceID_lift(_ buf: RustBuffer) throws -> AppearanceId {
    return try FfiConverterTypeAppearanceID.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAppearanceID_lower(_ value: AppearanceId) -> RustBuffer {
    return FfiConverterTypeAppearanceID.lower(value)
}


/**
 * An Arculus card, a hierarchal deterministic wallet capable of CAP26 derivation
 * which users interact with by placing it near their host device, which
 * communicates with the card over NFC.
 */
public struct ArculusCardFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic,
     * that is secured by the Arculus Card.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a ArculusCardFactorSource to help user disambiguate
     * between it and another one.
     */
    public var hint: ArculusCardHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic,
         * that is secured by the Arculus Card.
         */id: FactorSourceIdFromHash, 
        /**
         * Common properties shared between FactorSources of different kinds,
         * describing its state, when added, and supported cryptographic parameters.
         */common: FactorSourceCommon, 
        /**
         * Properties describing a ArculusCardFactorSource to help user disambiguate
         * between it and another one.
         */hint: ArculusCardHint) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}


extension ArculusCardFactorSource: Sendable {} 
extension ArculusCardFactorSource: Equatable, Hashable {
    public static func ==(lhs: ArculusCardFactorSource, rhs: ArculusCardFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeArculusCardFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCardFactorSource {
        return
            try ArculusCardFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf), 
                hint: FfiConverterTypeArculusCardHint.read(from: &buf)
        )
    }

    public static func write(_ value: ArculusCardFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeArculusCardHint.write(value.hint, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusCardFactorSource_lift(_ buf: RustBuffer) throws -> ArculusCardFactorSource {
    return try FfiConverterTypeArculusCardFactorSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusCardFactorSource_lower(_ value: ArculusCardFactorSource) -> RustBuffer {
    return FfiConverterTypeArculusCardFactorSource.lower(value)
}


public struct ArculusCardHint {
    /**
     * A user-assigned name for the arculus card, intended to help users
     * differentiate between multiple arculus cards.
     *
     * E.g. "Black" or "Silver"
     */
    public var label: String
    public var model: ArculusCardModel

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A user-assigned name for the arculus card, intended to help users
         * differentiate between multiple arculus cards.
         *
         * E.g. "Black" or "Silver"
         */label: String, model: ArculusCardModel) {
        self.label = label
        self.model = model
    }
}


extension ArculusCardHint: Sendable {} 
extension ArculusCardHint: Equatable, Hashable {
    public static func ==(lhs: ArculusCardHint, rhs: ArculusCardHint) -> Bool {
        if lhs.label != rhs.label {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(label)
        hasher.combine(model)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeArculusCardHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCardHint {
        return
            try ArculusCardHint(
                label: FfiConverterString.read(from: &buf), 
                model: FfiConverterTypeArculusCardModel.read(from: &buf)
        )
    }

    public static func write(_ value: ArculusCardHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.label, into: &buf)
        FfiConverterTypeArculusCardModel.write(value.model, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusCardHint_lift(_ buf: RustBuffer) throws -> ArculusCardHint {
    return try FfiConverterTypeArculusCardHint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusCardHint_lower(_ value: ArculusCardHint) -> RustBuffer {
    return FfiConverterTypeArculusCardHint.lower(value)
}


public struct ArculusVerifyPinResponse {
    public var status: Int32
    public var numberOfTriesRemaining: Int8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(status: Int32, numberOfTriesRemaining: Int8) {
        self.status = status
        self.numberOfTriesRemaining = numberOfTriesRemaining
    }
}


extension ArculusVerifyPinResponse: Sendable {} 
extension ArculusVerifyPinResponse: Equatable, Hashable {
    public static func ==(lhs: ArculusVerifyPinResponse, rhs: ArculusVerifyPinResponse) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.numberOfTriesRemaining != rhs.numberOfTriesRemaining {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(numberOfTriesRemaining)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeArculusVerifyPINResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusVerifyPinResponse {
        return
            try ArculusVerifyPinResponse(
                status: FfiConverterInt32.read(from: &buf), 
                numberOfTriesRemaining: FfiConverterInt8.read(from: &buf)
        )
    }

    public static func write(_ value: ArculusVerifyPinResponse, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.status, into: &buf)
        FfiConverterInt8.write(value.numberOfTriesRemaining, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusVerifyPINResponse_lift(_ buf: RustBuffer) throws -> ArculusVerifyPinResponse {
    return try FfiConverterTypeArculusVerifyPINResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusVerifyPINResponse_lower(_ value: ArculusVerifyPinResponse) -> RustBuffer {
    return FfiConverterTypeArculusVerifyPINResponse.lower(value)
}


public struct ArculusWalletPointer {
    public var pointer: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pointer: UInt64) {
        self.pointer = pointer
    }
}


extension ArculusWalletPointer: Sendable {} 
extension ArculusWalletPointer: Equatable, Hashable {
    public static func ==(lhs: ArculusWalletPointer, rhs: ArculusWalletPointer) -> Bool {
        if lhs.pointer != rhs.pointer {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pointer)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeArculusWalletPointer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusWalletPointer {
        return
            try ArculusWalletPointer(
                pointer: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ArculusWalletPointer, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.pointer, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusWalletPointer_lift(_ buf: RustBuffer) throws -> ArculusWalletPointer {
    return try FfiConverterTypeArculusWalletPointer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusWalletPointer_lower(_ value: ArculusWalletPointer) -> RustBuffer {
    return FfiConverterTypeArculusWalletPointer.lower(value)
}


/**
 * The specific Asset exception rule, which overrides the general
 * `deposit_rule` of a `ThirdPartyDeposits` settings.
 */
public struct AssetException {
    /**
     * Address of an asset to either deny or allow, as an exception overriding the `ThirdPartyDeposits`'s general `deposit_rule`.
     */
    public var address: ResourceAddress
    /**
     * Either deny or allow the `address`.
     */
    public var exceptionRule: DepositAddressExceptionRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Address of an asset to either deny or allow, as an exception overriding the `ThirdPartyDeposits`'s general `deposit_rule`.
         */address: ResourceAddress, 
        /**
         * Either deny or allow the `address`.
         */exceptionRule: DepositAddressExceptionRule) {
        self.address = address
        self.exceptionRule = exceptionRule
    }
}


extension AssetException: Sendable {} 
extension AssetException: Equatable, Hashable {
    public static func ==(lhs: AssetException, rhs: AssetException) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.exceptionRule != rhs.exceptionRule {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(exceptionRule)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAssetException: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetException {
        return
            try AssetException(
                address: FfiConverterTypeResourceAddress.read(from: &buf), 
                exceptionRule: FfiConverterTypeDepositAddressExceptionRule.read(from: &buf)
        )
    }

    public static func write(_ value: AssetException, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.address, into: &buf)
        FfiConverterTypeDepositAddressExceptionRule.write(value.exceptionRule, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAssetException_lift(_ buf: RustBuffer) throws -> AssetException {
    return try FfiConverterTypeAssetException.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAssetException_lower(_ value: AssetException) -> RustBuffer {
    return FfiConverterTypeAssetException.lower(value)
}


public struct AuthIntent {
    /**
     * The challenge nonce that with some `metadata` values are generating the `RolaChallenge`
     * needed to be signed
     */
    public var challengeNonce: Exactly32Bytes
    /**
     * The `NetworkID` on which the request was made
     */
    public var networkId: NetworkId
    /**
     * The origin `Url` of the dApp from which the request was made
     */
    public var origin: DappOrigin
    /**
     * The dApp's definition address
     */
    public var dappDefinitionAddress: AccountAddress
    /**
     * The entities needed to be signed.
     */
    public var entitiesToSign: [AddressOfAccountOrPersona]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The challenge nonce that with some `metadata` values are generating the `RolaChallenge`
         * needed to be signed
         */challengeNonce: Exactly32Bytes, 
        /**
         * The `NetworkID` on which the request was made
         */networkId: NetworkId, 
        /**
         * The origin `Url` of the dApp from which the request was made
         */origin: DappOrigin, 
        /**
         * The dApp's definition address
         */dappDefinitionAddress: AccountAddress, 
        /**
         * The entities needed to be signed.
         */entitiesToSign: [AddressOfAccountOrPersona]) {
        self.challengeNonce = challengeNonce
        self.networkId = networkId
        self.origin = origin
        self.dappDefinitionAddress = dappDefinitionAddress
        self.entitiesToSign = entitiesToSign
    }
}


extension AuthIntent: Sendable {} 
extension AuthIntent: Equatable, Hashable {
    public static func ==(lhs: AuthIntent, rhs: AuthIntent) -> Bool {
        if lhs.challengeNonce != rhs.challengeNonce {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        if lhs.entitiesToSign != rhs.entitiesToSign {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challengeNonce)
        hasher.combine(networkId)
        hasher.combine(origin)
        hasher.combine(dappDefinitionAddress)
        hasher.combine(entitiesToSign)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthIntent {
        return
            try AuthIntent(
                challengeNonce: FfiConverterTypeExactly32Bytes.read(from: &buf), 
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                origin: FfiConverterTypeDappOrigin.read(from: &buf), 
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf), 
                entitiesToSign: FfiConverterSequenceTypeAddressOfAccountOrPersona.read(from: &buf)
        )
    }

    public static func write(_ value: AuthIntent, into buf: inout [UInt8]) {
        FfiConverterTypeExactly32Bytes.write(value.challengeNonce, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
        FfiConverterSequenceTypeAddressOfAccountOrPersona.write(value.entitiesToSign, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthIntent_lift(_ buf: RustBuffer) throws -> AuthIntent {
    return try FfiConverterTypeAuthIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthIntent_lower(_ value: AuthIntent) -> RustBuffer {
    return FfiConverterTypeAuthIntent.lower(value)
}


public struct AuthIntentHash {
    public var payload: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(payload: BagOfBytes) {
        self.payload = payload
    }
}


extension AuthIntentHash: Sendable {} 
extension AuthIntentHash: Equatable, Hashable {
    public static func ==(lhs: AuthIntentHash, rhs: AuthIntentHash) -> Bool {
        if lhs.payload != rhs.payload {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payload)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthIntentHash {
        return
            try AuthIntentHash(
                payload: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: AuthIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.payload, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthIntentHash_lift(_ buf: RustBuffer) throws -> AuthIntentHash {
    return try FfiConverterTypeAuthIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthIntentHash_lower(_ value: AuthIntentHash) -> RustBuffer {
    return FfiConverterTypeAuthIntentHash.lower(value)
}


/**
 * A connection made between a Radix Dapp and the user.
 */
public struct AuthorizedDapp {
    /**
     * The ID of the network the authorized Dapp is on.
     */
    public var networkId: NetworkId
    /**
     * A `DappDefinitionAddress` is in fact just an alias for
     * [`AccountAddress`], it is the address of the account
     * which owns controls the Dapp.
     */
    public var dappDefinitionAddress: AccountAddress
    /**
     * The Display name as sent by the Dapp in any interaction
     * request (CAP21), e.g. "Radix Dashboard".
     */
    public var displayName: String?
    /**
     * An order set of `AuthorizedPersonaSimple`s, which is a collection of all
     * the Personas the user has used to interact with this Dapp, it is called
     * "references to", since the Personas are not stored in full, that would be
     * bad duplication of data (which might go stale), instead we refer to the
     * necessary data by IDs.
     */
    public var referencesToAuthorizedPersonas: [AuthorizedPersonaSimple]
    /**
     * The preferences the user has configured for this Dapp.
     */
    public var preferences: AuthorizedDappPreferences

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network the authorized Dapp is on.
         */networkId: NetworkId, 
        /**
         * A `DappDefinitionAddress` is in fact just an alias for
         * [`AccountAddress`], it is the address of the account
         * which owns controls the Dapp.
         */dappDefinitionAddress: AccountAddress, 
        /**
         * The Display name as sent by the Dapp in any interaction
         * request (CAP21), e.g. "Radix Dashboard".
         */displayName: String?, 
        /**
         * An order set of `AuthorizedPersonaSimple`s, which is a collection of all
         * the Personas the user has used to interact with this Dapp, it is called
         * "references to", since the Personas are not stored in full, that would be
         * bad duplication of data (which might go stale), instead we refer to the
         * necessary data by IDs.
         */referencesToAuthorizedPersonas: [AuthorizedPersonaSimple], 
        /**
         * The preferences the user has configured for this Dapp.
         */preferences: AuthorizedDappPreferences) {
        self.networkId = networkId
        self.dappDefinitionAddress = dappDefinitionAddress
        self.displayName = displayName
        self.referencesToAuthorizedPersonas = referencesToAuthorizedPersonas
        self.preferences = preferences
    }
}


extension AuthorizedDapp: Sendable {} 
extension AuthorizedDapp: Equatable, Hashable {
    public static func ==(lhs: AuthorizedDapp, rhs: AuthorizedDapp) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.referencesToAuthorizedPersonas != rhs.referencesToAuthorizedPersonas {
            return false
        }
        if lhs.preferences != rhs.preferences {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(dappDefinitionAddress)
        hasher.combine(displayName)
        hasher.combine(referencesToAuthorizedPersonas)
        hasher.combine(preferences)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthorizedDapp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDapp {
        return
            try AuthorizedDapp(
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                referencesToAuthorizedPersonas: FfiConverterSequenceTypeAuthorizedPersonaSimple.read(from: &buf), 
                preferences: FfiConverterTypeAuthorizedDappPreferences.read(from: &buf)
        )
    }

    public static func write(_ value: AuthorizedDapp, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterSequenceTypeAuthorizedPersonaSimple.write(value.referencesToAuthorizedPersonas, into: &buf)
        FfiConverterTypeAuthorizedDappPreferences.write(value.preferences, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizedDapp_lift(_ buf: RustBuffer) throws -> AuthorizedDapp {
    return try FfiConverterTypeAuthorizedDapp.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizedDapp_lower(_ value: AuthorizedDapp) -> RustBuffer {
    return FfiConverterTypeAuthorizedDapp.lower(value)
}


public struct AuthorizedDappDetailed {
    public var networkId: NetworkId
    public var dappDefinitionAddress: AccountAddress
    public var displayName: DisplayName?
    public var detailedAuthorizedPersonas: [AuthorizedPersonaDetailed]
    public var preferences: AuthorizedDappPreferences

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, dappDefinitionAddress: AccountAddress, displayName: DisplayName?, detailedAuthorizedPersonas: [AuthorizedPersonaDetailed], preferences: AuthorizedDappPreferences) {
        self.networkId = networkId
        self.dappDefinitionAddress = dappDefinitionAddress
        self.displayName = displayName
        self.detailedAuthorizedPersonas = detailedAuthorizedPersonas
        self.preferences = preferences
    }
}


extension AuthorizedDappDetailed: Sendable {} 
extension AuthorizedDappDetailed: Equatable, Hashable {
    public static func ==(lhs: AuthorizedDappDetailed, rhs: AuthorizedDappDetailed) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.detailedAuthorizedPersonas != rhs.detailedAuthorizedPersonas {
            return false
        }
        if lhs.preferences != rhs.preferences {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(dappDefinitionAddress)
        hasher.combine(displayName)
        hasher.combine(detailedAuthorizedPersonas)
        hasher.combine(preferences)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthorizedDappDetailed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappDetailed {
        return
            try AuthorizedDappDetailed(
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf), 
                displayName: FfiConverterOptionTypeDisplayName.read(from: &buf), 
                detailedAuthorizedPersonas: FfiConverterSequenceTypeAuthorizedPersonaDetailed.read(from: &buf), 
                preferences: FfiConverterTypeAuthorizedDappPreferences.read(from: &buf)
        )
    }

    public static func write(_ value: AuthorizedDappDetailed, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
        FfiConverterOptionTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterSequenceTypeAuthorizedPersonaDetailed.write(value.detailedAuthorizedPersonas, into: &buf)
        FfiConverterTypeAuthorizedDappPreferences.write(value.preferences, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizedDappDetailed_lift(_ buf: RustBuffer) throws -> AuthorizedDappDetailed {
    return try FfiConverterTypeAuthorizedDappDetailed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizedDappDetailed_lower(_ value: AuthorizedDappDetailed) -> RustBuffer {
    return FfiConverterTypeAuthorizedDappDetailed.lower(value)
}


/**
 * The preferences the user has configured off-ledger for a given `AuthorizedDapp`.
 * Allows users, for example, to hide direct deposit claims for a given Dapp.
 */
public struct AuthorizedDappPreferences {
    public var deposits: AuthorizedDappPreferenceDeposits

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deposits: AuthorizedDappPreferenceDeposits) {
        self.deposits = deposits
    }
}


extension AuthorizedDappPreferences: Sendable {} 
extension AuthorizedDappPreferences: Equatable, Hashable {
    public static func ==(lhs: AuthorizedDappPreferences, rhs: AuthorizedDappPreferences) -> Bool {
        if lhs.deposits != rhs.deposits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deposits)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthorizedDappPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappPreferences {
        return
            try AuthorizedDappPreferences(
                deposits: FfiConverterTypeAuthorizedDappPreferenceDeposits.read(from: &buf)
        )
    }

    public static func write(_ value: AuthorizedDappPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeAuthorizedDappPreferenceDeposits.write(value.deposits, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizedDappPreferences_lift(_ buf: RustBuffer) throws -> AuthorizedDappPreferences {
    return try FfiConverterTypeAuthorizedDappPreferences.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizedDappPreferences_lower(_ value: AuthorizedDappPreferences) -> RustBuffer {
    return FfiConverterTypeAuthorizedDappPreferences.lower(value)
}


public struct AuthorizedPersonaDetailed {
    /**
     * Address that globally and uniquely identifies this Persona.
     */
    public var identityAddress: IdentityAddress
    /**
     * The display name of the Persona, as stored in `Persona`
     */
    public var displayName: DisplayName
    /**
     * Information of accounts the user has given the Dapp access to,
     * being the triple `(accountAddress, displayName, appearanceID)`
     */
    public var simpleAccounts: [AccountForDisplay]?
    /**
     * The persona data that the user has given the Dapp access to
     */
    public var sharedPersonaData: PersonaData
    /**
     * If this persona has an auth sign key created
     */
    public var hasAuthenticationSigningKey: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Address that globally and uniquely identifies this Persona.
         */identityAddress: IdentityAddress, 
        /**
         * The display name of the Persona, as stored in `Persona`
         */displayName: DisplayName, 
        /**
         * Information of accounts the user has given the Dapp access to,
         * being the triple `(accountAddress, displayName, appearanceID)`
         */simpleAccounts: [AccountForDisplay]?, 
        /**
         * The persona data that the user has given the Dapp access to
         */sharedPersonaData: PersonaData, 
        /**
         * If this persona has an auth sign key created
         */hasAuthenticationSigningKey: Bool) {
        self.identityAddress = identityAddress
        self.displayName = displayName
        self.simpleAccounts = simpleAccounts
        self.sharedPersonaData = sharedPersonaData
        self.hasAuthenticationSigningKey = hasAuthenticationSigningKey
    }
}


extension AuthorizedPersonaDetailed: Sendable {} 
extension AuthorizedPersonaDetailed: Equatable, Hashable {
    public static func ==(lhs: AuthorizedPersonaDetailed, rhs: AuthorizedPersonaDetailed) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.simpleAccounts != rhs.simpleAccounts {
            return false
        }
        if lhs.sharedPersonaData != rhs.sharedPersonaData {
            return false
        }
        if lhs.hasAuthenticationSigningKey != rhs.hasAuthenticationSigningKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(displayName)
        hasher.combine(simpleAccounts)
        hasher.combine(sharedPersonaData)
        hasher.combine(hasAuthenticationSigningKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthorizedPersonaDetailed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedPersonaDetailed {
        return
            try AuthorizedPersonaDetailed(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf), 
                displayName: FfiConverterTypeDisplayName.read(from: &buf), 
                simpleAccounts: FfiConverterOptionSequenceTypeAccountForDisplay.read(from: &buf), 
                sharedPersonaData: FfiConverterTypePersonaData.read(from: &buf), 
                hasAuthenticationSigningKey: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: AuthorizedPersonaDetailed, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterOptionSequenceTypeAccountForDisplay.write(value.simpleAccounts, into: &buf)
        FfiConverterTypePersonaData.write(value.sharedPersonaData, into: &buf)
        FfiConverterBool.write(value.hasAuthenticationSigningKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizedPersonaDetailed_lift(_ buf: RustBuffer) throws -> AuthorizedPersonaDetailed {
    return try FfiConverterTypeAuthorizedPersonaDetailed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizedPersonaDetailed_lower(_ value: AuthorizedPersonaDetailed) -> RustBuffer {
    return FfiConverterTypeAuthorizedPersonaDetailed.lower(value)
}


/**
 * Simple data representation of a Persona the user has shared with a Dapp.
 * Simple meaning "the bare minimum amount of data" that enabled `Sargon` to
 * be able to reconstruct a `AuthorizedPersonaDetailed` value, used to populate
 * views.
 *
 * N.B. as of 2024-01-31 of `Sargon` we have not yet implemented the struct
 * `AuthorizedPersonaDetailed` since it is not JSON, but logic, and we have yet
 * to migrate `Sargon` into iOS/Android clients, thus we will defer the work
 * of mapping `AuthorizedPersonaSimple` -> `AuthorizedPersonaDetailed`.
 */
public struct AuthorizedPersonaSimple {
    /**
     * The globally unique identifier of a Persona is its address, used
     * to lookup persona
     */
    public var identityAddress: IdentityAddress
    /**
     * Date of last login for this persona.
     */
    public var lastLogin: Timestamp
    /**
     * List of "ongoing accountAddresses" that user given the dApp access to.
     */
    public var sharedAccounts: SharedToDappWithPersonaAccountAddresses?
    /**
     * ID to PersonaData entries to user has shared with a Dapp.
     */
    public var sharedPersonaData: SharedPersonaData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The globally unique identifier of a Persona is its address, used
         * to lookup persona
         */identityAddress: IdentityAddress, 
        /**
         * Date of last login for this persona.
         */lastLogin: Timestamp, 
        /**
         * List of "ongoing accountAddresses" that user given the dApp access to.
         */sharedAccounts: SharedToDappWithPersonaAccountAddresses?, 
        /**
         * ID to PersonaData entries to user has shared with a Dapp.
         */sharedPersonaData: SharedPersonaData) {
        self.identityAddress = identityAddress
        self.lastLogin = lastLogin
        self.sharedAccounts = sharedAccounts
        self.sharedPersonaData = sharedPersonaData
    }
}


extension AuthorizedPersonaSimple: Sendable {} 
extension AuthorizedPersonaSimple: Equatable, Hashable {
    public static func ==(lhs: AuthorizedPersonaSimple, rhs: AuthorizedPersonaSimple) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.lastLogin != rhs.lastLogin {
            return false
        }
        if lhs.sharedAccounts != rhs.sharedAccounts {
            return false
        }
        if lhs.sharedPersonaData != rhs.sharedPersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(lastLogin)
        hasher.combine(sharedAccounts)
        hasher.combine(sharedPersonaData)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthorizedPersonaSimple: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedPersonaSimple {
        return
            try AuthorizedPersonaSimple(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf), 
                lastLogin: FfiConverterTypeTimestamp.read(from: &buf), 
                sharedAccounts: FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses.read(from: &buf), 
                sharedPersonaData: FfiConverterTypeSharedPersonaData.read(from: &buf)
        )
    }

    public static func write(_ value: AuthorizedPersonaSimple, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastLogin, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses.write(value.sharedAccounts, into: &buf)
        FfiConverterTypeSharedPersonaData.write(value.sharedPersonaData, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizedPersonaSimple_lift(_ buf: RustBuffer) throws -> AuthorizedPersonaSimple {
    return try FfiConverterTypeAuthorizedPersonaSimple.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizedPersonaSimple_lower(_ value: AuthorizedPersonaSimple) -> RustBuffer {
    return FfiConverterTypeAuthorizedPersonaSimple.lower(value)
}


/**
 * A BIP39 seed for hierarchal deterministic wallets, as per the [BIP39 standard][doc].
 *
 * We typically obtain this by calling [`to_seed` on `MnemonicWithPassphrase`][MnemonicWithPassphrase::to_seed].
 *
 * [doc]: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#user-content-From_mnemonic_to_seed
 */
public struct Bip39Seed {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Bip39Seed: Sendable {} 
extension Bip39Seed: Equatable, Hashable {
    public static func ==(lhs: Bip39Seed, rhs: Bip39Seed) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBIP39Seed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Seed {
        return
            try Bip39Seed(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Bip39Seed, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP39Seed_lift(_ buf: RustBuffer) throws -> Bip39Seed {
    return try FfiConverterTypeBIP39Seed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP39Seed_lower(_ value: Bip39Seed) -> RustBuffer {
    return FfiConverterTypeBIP39Seed.lower(value)
}


/**
 * A word in the BIP39 word list of `language` at known `index` (0-2047).
 */
public struct Bip39Word {
    public var word: String
    public var index: U11
    public var language: Bip39Language

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(word: String, index: U11, language: Bip39Language) {
        self.word = word
        self.index = index
        self.language = language
    }
}


extension Bip39Word: Sendable {} 
extension Bip39Word: Equatable, Hashable {
    public static func ==(lhs: Bip39Word, rhs: Bip39Word) -> Bool {
        if lhs.word != rhs.word {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(word)
        hasher.combine(index)
        hasher.combine(language)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBIP39Word: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Word {
        return
            try Bip39Word(
                word: FfiConverterString.read(from: &buf), 
                index: FfiConverterTypeU11.read(from: &buf), 
                language: FfiConverterTypeBIP39Language.read(from: &buf)
        )
    }

    public static func write(_ value: Bip39Word, into buf: inout [UInt8]) {
        FfiConverterString.write(value.word, into: &buf)
        FfiConverterTypeU11.write(value.index, into: &buf)
        FfiConverterTypeBIP39Language.write(value.language, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP39Word_lift(_ buf: RustBuffer) throws -> Bip39Word {
    return try FfiConverterTypeBIP39Word.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP39Word_lower(_ value: Bip39Word) -> RustBuffer {
    return FfiConverterTypeBIP39Word.lower(value)
}


/**
 * Either a canonical BIP44 derivation path like so:
 *
 * `m / purpose' / coin_type' / account' / change / address_index`
 *
 * Or an Radix Olympia BIP44 "like" path, where the `address_index` accidentally
 * was made hardened, i.e.:
 *
 * `m / purpose' / coin_type' / account' / change / address_index'`
 *
 * This was a mistake made during implementation of Radix Olympia.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * fn parse(s: &str) -> Result<BIP44LikePath> {
 * s.parse::<BIP44LikePath>()
 * }
 *
 * assert!(parse("m/44'/1022'/0'/0/0").is_ok()); // Canonical BIP44
 * assert!(parse("m/44'/1022'/0'/0/0'").is_ok()); // BIP44 like
 *
 * assert_eq!(parse("m/44'/1022'/0'/0'/0"), Err(CommonError::InvalidBIP44LikePathChangeWasUnexpectedlyHardened));
 * assert_eq!(parse("m/44'/1022'/0'/0'/0'"), Err(CommonError::InvalidBIP44LikePathChangeWasUnexpectedlyHardened));
 * assert_eq!(parse("m/44'/0'/0'/0/0'"), Err(CommonError::CoinTypeNotFound { bad_value: 0 }));
 * ```
 */
public struct Bip44LikePath {
    public var account: HdPathComponent
    public var change: HdPathComponent
    public var index: HdPathComponent

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(account: HdPathComponent, change: HdPathComponent, index: HdPathComponent) {
        self.account = account
        self.change = change
        self.index = index
    }
}


extension Bip44LikePath: Sendable {} 
extension Bip44LikePath: Equatable, Hashable {
    public static func ==(lhs: Bip44LikePath, rhs: Bip44LikePath) -> Bool {
        if lhs.account != rhs.account {
            return false
        }
        if lhs.change != rhs.change {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(account)
        hasher.combine(change)
        hasher.combine(index)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBIP44LikePath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip44LikePath {
        return
            try Bip44LikePath(
                account: FfiConverterTypeHDPathComponent.read(from: &buf), 
                change: FfiConverterTypeHDPathComponent.read(from: &buf), 
                index: FfiConverterTypeHDPathComponent.read(from: &buf)
        )
    }

    public static func write(_ value: Bip44LikePath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPathComponent.write(value.account, into: &buf)
        FfiConverterTypeHDPathComponent.write(value.change, into: &buf)
        FfiConverterTypeHDPathComponent.write(value.index, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP44LikePath_lift(_ buf: RustBuffer) throws -> Bip44LikePath {
    return try FfiConverterTypeBIP44LikePath.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP44LikePath_lower(_ value: Bip44LikePath) -> RustBuffer {
    return FfiConverterTypeBIP44LikePath.lower(value)
}


/**
 * A struct that represents the result of a given backup.
 *
 * Reference for iOS: it is a combination of `BackupStatus` and `BackupResult` (all in one).
 */
public struct BackupResult {
    /**
     * Whether this backup matches the one on Profile.
     */
    public var isCurrent: Bool
    /**
     * Whether this backup has failed.
     */
    public var isFailed: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether this backup matches the one on Profile.
         */isCurrent: Bool, 
        /**
         * Whether this backup has failed.
         */isFailed: Bool) {
        self.isCurrent = isCurrent
        self.isFailed = isFailed
    }
}


extension BackupResult: Sendable {} 
extension BackupResult: Equatable, Hashable {
    public static func ==(lhs: BackupResult, rhs: BackupResult) -> Bool {
        if lhs.isCurrent != rhs.isCurrent {
            return false
        }
        if lhs.isFailed != rhs.isFailed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCurrent)
        hasher.combine(isFailed)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBackupResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupResult {
        return
            try BackupResult(
                isCurrent: FfiConverterBool.read(from: &buf), 
                isFailed: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: BackupResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCurrent, into: &buf)
        FfiConverterBool.write(value.isFailed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupResult_lift(_ buf: RustBuffer) throws -> BackupResult {
    return try FfiConverterTypeBackupResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupResult_lower(_ value: BackupResult) -> RustBuffer {
    return FfiConverterTypeBackupResult.lower(value)
}


/**
 * Blob is a wrapper a bag of bytes
 */
public struct Blob {
    fileprivate let secretMagic: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BagOfBytes) {
        self.secretMagic = secretMagic
    }
}


extension Blob: Sendable {} 
extension Blob: Equatable, Hashable {
    public static func ==(lhs: Blob, rhs: Blob) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlob: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Blob {
        return
            try Blob(
                secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Blob, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlob_lift(_ buf: RustBuffer) throws -> Blob {
    return try FfiConverterTypeBlob.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlob_lower(_ value: Blob) -> RustBuffer {
    return FfiConverterTypeBlob.lower(value)
}


/**
 * Vec of Blobs
 */
public struct Blobs {
    fileprivate let secretMagic: [Blob]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: [Blob]) {
        self.secretMagic = secretMagic
    }
}


extension Blobs: Sendable {} 
extension Blobs: Equatable, Hashable {
    public static func ==(lhs: Blobs, rhs: Blobs) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlobs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Blobs {
        return
            try Blobs(
                secretMagic: FfiConverterSequenceTypeBlob.read(from: &buf)
        )
    }

    public static func write(_ value: Blobs, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBlob.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlobs_lift(_ buf: RustBuffer) throws -> Blobs {
    return try FfiConverterTypeBlobs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlobs_lower(_ value: Blobs) -> RustBuffer {
    return FfiConverterTypeBlobs.lower(value)
}


public struct BlogPost {
    public var name: String
    public var image: Url
    public var url: Url

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, image: Url, url: Url) {
        self.name = name
        self.image = image
        self.url = url
    }
}


extension BlogPost: Sendable {} 
extension BlogPost: Equatable, Hashable {
    public static func ==(lhs: BlogPost, rhs: BlogPost) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.image != rhs.image {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(image)
        hasher.combine(url)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlogPost: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlogPost {
        return
            try BlogPost(
                name: FfiConverterString.read(from: &buf), 
                image: FfiConverterTypeUrl.read(from: &buf), 
                url: FfiConverterTypeUrl.read(from: &buf)
        )
    }

    public static func write(_ value: BlogPost, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeUrl.write(value.image, into: &buf)
        FfiConverterTypeUrl.write(value.url, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlogPost_lift(_ buf: RustBuffer) throws -> BlogPost {
    return try FfiConverterTypeBlogPost.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlogPost_lower(_ value: BlogPost) -> RustBuffer {
    return FfiConverterTypeBlogPost.lower(value)
}


public struct BlogPosts {
    /**
     * All of the blog posts
     */
    public var posts: [BlogPost]
    /**
     * The most recent new blog post.
     * There might be more than one new blog post, but we'll inform the user
     * about the latest one only.
     */
    public var newBlogPost: BlogPost?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * All of the blog posts
         */posts: [BlogPost], 
        /**
         * The most recent new blog post.
         * There might be more than one new blog post, but we'll inform the user
         * about the latest one only.
         */newBlogPost: BlogPost?) {
        self.posts = posts
        self.newBlogPost = newBlogPost
    }
}


extension BlogPosts: Sendable {} 
extension BlogPosts: Equatable, Hashable {
    public static func ==(lhs: BlogPosts, rhs: BlogPosts) -> Bool {
        if lhs.posts != rhs.posts {
            return false
        }
        if lhs.newBlogPost != rhs.newBlogPost {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(posts)
        hasher.combine(newBlogPost)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBlogPosts: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlogPosts {
        return
            try BlogPosts(
                posts: FfiConverterSequenceTypeBlogPost.read(from: &buf), 
                newBlogPost: FfiConverterOptionTypeBlogPost.read(from: &buf)
        )
    }

    public static func write(_ value: BlogPosts, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBlogPost.write(value.posts, into: &buf)
        FfiConverterOptionTypeBlogPost.write(value.newBlogPost, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlogPosts_lift(_ buf: RustBuffer) throws -> BlogPosts {
    return try FfiConverterTypeBlogPosts.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBlogPosts_lower(_ value: BlogPosts) -> RustBuffer {
    return FfiConverterTypeBlogPosts.lower(value)
}


public struct CheckSecurityProblemsInput {
    /**
     * Whether the cloud profile sync is enabled.
     */
    public var isCloudProfileSyncEnabled: Bool
    /**
     * Addresses of entities that are unrecoverable. This is, the Factor Source used to create such entities
     * has not been backed up (e.g. seed phrase was not written down).
     */
    public var unrecoverableEntities: AddressesOfEntitiesInBadState
    /**
     * Addresses of entities that we don't have control over them. This is, the Factor Source used to create such entities
     * is missing (e.g. entity was imported but seed phrase never entered).
     */
    public var withoutControlEntities: AddressesOfEntitiesInBadState
    /**
     * Information about the latest backup made on the cloud.
     */
    public var lastCloudBackup: BackupResult?
    /**
     * Information about the latest backup made manually.
     */
    public var lastManualBackup: BackupResult?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the cloud profile sync is enabled.
         */isCloudProfileSyncEnabled: Bool, 
        /**
         * Addresses of entities that are unrecoverable. This is, the Factor Source used to create such entities
         * has not been backed up (e.g. seed phrase was not written down).
         */unrecoverableEntities: AddressesOfEntitiesInBadState, 
        /**
         * Addresses of entities that we don't have control over them. This is, the Factor Source used to create such entities
         * is missing (e.g. entity was imported but seed phrase never entered).
         */withoutControlEntities: AddressesOfEntitiesInBadState, 
        /**
         * Information about the latest backup made on the cloud.
         */lastCloudBackup: BackupResult?, 
        /**
         * Information about the latest backup made manually.
         */lastManualBackup: BackupResult?) {
        self.isCloudProfileSyncEnabled = isCloudProfileSyncEnabled
        self.unrecoverableEntities = unrecoverableEntities
        self.withoutControlEntities = withoutControlEntities
        self.lastCloudBackup = lastCloudBackup
        self.lastManualBackup = lastManualBackup
    }
}


extension CheckSecurityProblemsInput: Sendable {} 
extension CheckSecurityProblemsInput: Equatable, Hashable {
    public static func ==(lhs: CheckSecurityProblemsInput, rhs: CheckSecurityProblemsInput) -> Bool {
        if lhs.isCloudProfileSyncEnabled != rhs.isCloudProfileSyncEnabled {
            return false
        }
        if lhs.unrecoverableEntities != rhs.unrecoverableEntities {
            return false
        }
        if lhs.withoutControlEntities != rhs.withoutControlEntities {
            return false
        }
        if lhs.lastCloudBackup != rhs.lastCloudBackup {
            return false
        }
        if lhs.lastManualBackup != rhs.lastManualBackup {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCloudProfileSyncEnabled)
        hasher.combine(unrecoverableEntities)
        hasher.combine(withoutControlEntities)
        hasher.combine(lastCloudBackup)
        hasher.combine(lastManualBackup)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCheckSecurityProblemsInput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckSecurityProblemsInput {
        return
            try CheckSecurityProblemsInput(
                isCloudProfileSyncEnabled: FfiConverterBool.read(from: &buf), 
                unrecoverableEntities: FfiConverterTypeAddressesOfEntitiesInBadState.read(from: &buf), 
                withoutControlEntities: FfiConverterTypeAddressesOfEntitiesInBadState.read(from: &buf), 
                lastCloudBackup: FfiConverterOptionTypeBackupResult.read(from: &buf), 
                lastManualBackup: FfiConverterOptionTypeBackupResult.read(from: &buf)
        )
    }

    public static func write(_ value: CheckSecurityProblemsInput, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCloudProfileSyncEnabled, into: &buf)
        FfiConverterTypeAddressesOfEntitiesInBadState.write(value.unrecoverableEntities, into: &buf)
        FfiConverterTypeAddressesOfEntitiesInBadState.write(value.withoutControlEntities, into: &buf)
        FfiConverterOptionTypeBackupResult.write(value.lastCloudBackup, into: &buf)
        FfiConverterOptionTypeBackupResult.write(value.lastManualBackup, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckSecurityProblemsInput_lift(_ buf: RustBuffer) throws -> CheckSecurityProblemsInput {
    return try FfiConverterTypeCheckSecurityProblemsInput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckSecurityProblemsInput_lower(_ value: CheckSecurityProblemsInput) -> RustBuffer {
    return FfiConverterTypeCheckSecurityProblemsInput.lower(value)
}


/**
 * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
 * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
 * contain elements with the same value, but under different IDs.
 */
public struct CollectionOfEmailAddresses {
    public var collection: [PersonaDataIdentifiedEmailAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(collection: [PersonaDataIdentifiedEmailAddress]) {
        self.collection = collection
    }
}


extension CollectionOfEmailAddresses: Sendable {} 
extension CollectionOfEmailAddresses: Equatable, Hashable {
    public static func ==(lhs: CollectionOfEmailAddresses, rhs: CollectionOfEmailAddresses) -> Bool {
        if lhs.collection != rhs.collection {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(collection)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCollectionOfEmailAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionOfEmailAddresses {
        return
            try CollectionOfEmailAddresses(
                collection: FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress.read(from: &buf)
        )
    }

    public static func write(_ value: CollectionOfEmailAddresses, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress.write(value.collection, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCollectionOfEmailAddresses_lift(_ buf: RustBuffer) throws -> CollectionOfEmailAddresses {
    return try FfiConverterTypeCollectionOfEmailAddresses.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCollectionOfEmailAddresses_lower(_ value: CollectionOfEmailAddresses) -> RustBuffer {
    return FfiConverterTypeCollectionOfEmailAddresses.lower(value)
}


/**
 * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
 * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
 * contain elements with the same value, but under different IDs.
 */
public struct CollectionOfPhoneNumbers {
    public var collection: [PersonaDataIdentifiedPhoneNumber]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(collection: [PersonaDataIdentifiedPhoneNumber]) {
        self.collection = collection
    }
}


extension CollectionOfPhoneNumbers: Sendable {} 
extension CollectionOfPhoneNumbers: Equatable, Hashable {
    public static func ==(lhs: CollectionOfPhoneNumbers, rhs: CollectionOfPhoneNumbers) -> Bool {
        if lhs.collection != rhs.collection {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(collection)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCollectionOfPhoneNumbers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionOfPhoneNumbers {
        return
            try CollectionOfPhoneNumbers(
                collection: FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber.read(from: &buf)
        )
    }

    public static func write(_ value: CollectionOfPhoneNumbers, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber.write(value.collection, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCollectionOfPhoneNumbers_lift(_ buf: RustBuffer) throws -> CollectionOfPhoneNumbers {
    return try FfiConverterTypeCollectionOfPhoneNumbers.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCollectionOfPhoneNumbers_lower(_ value: CollectionOfPhoneNumbers) -> RustBuffer {
    return FfiConverterTypeCollectionOfPhoneNumbers.lower(value)
}


public struct CompiledNotarizedIntent {
    fileprivate let secretMagic: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BagOfBytes) {
        self.secretMagic = secretMagic
    }
}


extension CompiledNotarizedIntent: Sendable {} 
extension CompiledNotarizedIntent: Equatable, Hashable {
    public static func ==(lhs: CompiledNotarizedIntent, rhs: CompiledNotarizedIntent) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCompiledNotarizedIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompiledNotarizedIntent {
        return
            try CompiledNotarizedIntent(
                secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: CompiledNotarizedIntent, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompiledNotarizedIntent_lift(_ buf: RustBuffer) throws -> CompiledNotarizedIntent {
    return try FfiConverterTypeCompiledNotarizedIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompiledNotarizedIntent_lower(_ value: CompiledNotarizedIntent) -> RustBuffer {
    return FfiConverterTypeCompiledNotarizedIntent.lower(value)
}


public struct CompiledSubintent {
    /**
     * A base-64 encoded version of the compiled subintent
     */
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A base-64 encoded version of the compiled subintent
         */secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension CompiledSubintent: Sendable {} 
extension CompiledSubintent: Equatable, Hashable {
    public static func ==(lhs: CompiledSubintent, rhs: CompiledSubintent) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCompiledSubintent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompiledSubintent {
        return
            try CompiledSubintent(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CompiledSubintent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompiledSubintent_lift(_ buf: RustBuffer) throws -> CompiledSubintent {
    return try FfiConverterTypeCompiledSubintent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompiledSubintent_lower(_ value: CompiledSubintent) -> RustBuffer {
    return FfiConverterTypeCompiledSubintent.lower(value)
}


public struct CompiledTransactionIntent {
    /**
     * A base-64 encoded version of the compiled intent
     */
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A base-64 encoded version of the compiled intent
         */secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension CompiledTransactionIntent: Sendable {} 
extension CompiledTransactionIntent: Equatable, Hashable {
    public static func ==(lhs: CompiledTransactionIntent, rhs: CompiledTransactionIntent) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCompiledTransactionIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompiledTransactionIntent {
        return
            try CompiledTransactionIntent(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CompiledTransactionIntent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompiledTransactionIntent_lift(_ buf: RustBuffer) throws -> CompiledTransactionIntent {
    return try FfiConverterTypeCompiledTransactionIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCompiledTransactionIntent_lower(_ value: CompiledTransactionIntent) -> RustBuffer {
    return FfiConverterTypeCompiledTransactionIntent.lower(value)
}


/**
 * An address to some On-Ledger (OnNetwork) component, e.g. a Dapp, being an instantiation
 * of some Scrypto blueprint, e.g:
 * `"component_rdx1cptxxxxxxxxxfaucetxxxxxxxxx000527798379xxxxxxxxxfaucet"`
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of ComponentAddress:
 * * GlobalGenericComponent
 * * InternalGenericComponent
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalComponentAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L243-L246
 */
public struct ComponentAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension ComponentAddress: Sendable {} 
extension ComponentAddress: Equatable, Hashable {
    public static func ==(lhs: ComponentAddress, rhs: ComponentAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeComponentAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComponentAddress {
        return
            try ComponentAddress(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ComponentAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeComponentAddress_lift(_ buf: RustBuffer) throws -> ComponentAddress {
    return try FfiConverterTypeComponentAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeComponentAddress_lower(_ value: ComponentAddress) -> RustBuffer {
    return FfiConverterTypeComponentAddress.lower(value)
}


/**
 * Role of FactorInstances
 */
public struct ConfirmationRoleWithFactorInstances {
    /**
     * How many threshold factors that must be used to perform some function with
     * this role.
     */
    public var threshold: Threshold
    /**
     * Factors which are used in combination with other factors, amounting to at
     * least `threshold` many factors to perform some function with this role.
     */
    public var thresholdFactors: [FactorInstance]
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * How many threshold factors that must be used to perform some function with
         * this role.
         */threshold: Threshold, 
        /**
         * Factors which are used in combination with other factors, amounting to at
         * least `threshold` many factors to perform some function with this role.
         */thresholdFactors: [FactorInstance], 
        /**
         * Overriding / Super admin / "sudo" / God / factors, **ANY**
         * single of these factor which can perform the function of this role,
         * disregarding of `threshold`.
         */overrideFactors: [FactorInstance]) {
        self.threshold = threshold
        self.thresholdFactors = thresholdFactors
        self.overrideFactors = overrideFactors
    }
}


extension ConfirmationRoleWithFactorInstances: Sendable {} 
extension ConfirmationRoleWithFactorInstances: Equatable, Hashable {
    public static func ==(lhs: ConfirmationRoleWithFactorInstances, rhs: ConfirmationRoleWithFactorInstances) -> Bool {
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(threshold)
        hasher.combine(thresholdFactors)
        hasher.combine(overrideFactors)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmationRoleWithFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationRoleWithFactorInstances {
        return
            try ConfirmationRoleWithFactorInstances(
                threshold: FfiConverterTypeThreshold.read(from: &buf), 
                thresholdFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf), 
                overrideFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf)
        )
    }

    public static func write(_ value: ConfirmationRoleWithFactorInstances, into buf: inout [UInt8]) {
        FfiConverterTypeThreshold.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorInstance.write(value.thresholdFactors, into: &buf)
        FfiConverterSequenceTypeFactorInstance.write(value.overrideFactors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmationRoleWithFactorInstances_lift(_ buf: RustBuffer) throws -> ConfirmationRoleWithFactorInstances {
    return try FfiConverterTypeConfirmationRoleWithFactorInstances.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmationRoleWithFactorInstances_lower(_ value: ConfirmationRoleWithFactorInstances) -> RustBuffer {
    return FfiConverterTypeConfirmationRoleWithFactorInstances.lower(value)
}


/**
 * Role of FactorSourceIDs
 */
public struct ConfirmationRoleWithFactorSourceIDs {
    /**
     * How many threshold factors that must be used to perform some function with
     * this role.
     */
    public var threshold: Threshold
    /**
     * Factors which are used in combination with other factors, amounting to at
     * least `threshold` many factors to perform some function with this role.
     */
    public var thresholdFactors: [FactorSourceId]
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSourceId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * How many threshold factors that must be used to perform some function with
         * this role.
         */threshold: Threshold, 
        /**
         * Factors which are used in combination with other factors, amounting to at
         * least `threshold` many factors to perform some function with this role.
         */thresholdFactors: [FactorSourceId], 
        /**
         * Overriding / Super admin / "sudo" / God / factors, **ANY**
         * single of these factor which can perform the function of this role,
         * disregarding of `threshold`.
         */overrideFactors: [FactorSourceId]) {
        self.threshold = threshold
        self.thresholdFactors = thresholdFactors
        self.overrideFactors = overrideFactors
    }
}


extension ConfirmationRoleWithFactorSourceIDs: Sendable {} 
extension ConfirmationRoleWithFactorSourceIDs: Equatable, Hashable {
    public static func ==(lhs: ConfirmationRoleWithFactorSourceIDs, rhs: ConfirmationRoleWithFactorSourceIDs) -> Bool {
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(threshold)
        hasher.combine(thresholdFactors)
        hasher.combine(overrideFactors)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmationRoleWithFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationRoleWithFactorSourceIDs {
        return
            try ConfirmationRoleWithFactorSourceIDs(
                threshold: FfiConverterTypeThreshold.read(from: &buf), 
                thresholdFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf), 
                overrideFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
        )
    }

    public static func write(_ value: ConfirmationRoleWithFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterTypeThreshold.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSourceID.write(value.thresholdFactors, into: &buf)
        FfiConverterSequenceTypeFactorSourceID.write(value.overrideFactors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmationRoleWithFactorSourceIDs_lift(_ buf: RustBuffer) throws -> ConfirmationRoleWithFactorSourceIDs {
    return try FfiConverterTypeConfirmationRoleWithFactorSourceIDs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmationRoleWithFactorSourceIDs_lower(_ value: ConfirmationRoleWithFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypeConfirmationRoleWithFactorSourceIDs.lower(value)
}


/**
 * Role of `FactorSource`s
 */
public struct ConfirmationRoleWithFactorSources {
    /**
     * How many threshold factors that must be used to perform some function with
     * this role.
     */
    public var threshold: Threshold
    /**
     * Factors which are used in combination with other factors, amounting to at
     * least `threshold` many factors to perform some function with this role.
     */
    public var thresholdFactors: [FactorSource]
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * How many threshold factors that must be used to perform some function with
         * this role.
         */threshold: Threshold, 
        /**
         * Factors which are used in combination with other factors, amounting to at
         * least `threshold` many factors to perform some function with this role.
         */thresholdFactors: [FactorSource], 
        /**
         * Overriding / Super admin / "sudo" / God / factors, **ANY**
         * single of these factor which can perform the function of this role,
         * disregarding of `threshold`.
         */overrideFactors: [FactorSource]) {
        self.threshold = threshold
        self.thresholdFactors = thresholdFactors
        self.overrideFactors = overrideFactors
    }
}


extension ConfirmationRoleWithFactorSources: Sendable {} 
extension ConfirmationRoleWithFactorSources: Equatable, Hashable {
    public static func ==(lhs: ConfirmationRoleWithFactorSources, rhs: ConfirmationRoleWithFactorSources) -> Bool {
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(threshold)
        hasher.combine(thresholdFactors)
        hasher.combine(overrideFactors)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfirmationRoleWithFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationRoleWithFactorSources {
        return
            try ConfirmationRoleWithFactorSources(
                threshold: FfiConverterTypeThreshold.read(from: &buf), 
                thresholdFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf), 
                overrideFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf)
        )
    }

    public static func write(_ value: ConfirmationRoleWithFactorSources, into buf: inout [UInt8]) {
        FfiConverterTypeThreshold.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.thresholdFactors, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.overrideFactors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmationRoleWithFactorSources_lift(_ buf: RustBuffer) throws -> ConfirmationRoleWithFactorSources {
    return try FfiConverterTypeConfirmationRoleWithFactorSources.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfirmationRoleWithFactorSources_lower(_ value: ConfirmationRoleWithFactorSources) -> RustBuffer {
    return FfiConverterTypeConfirmationRoleWithFactorSources.lower(value)
}


/**
 * A hint describing the contents of a Profile, acting as a
 * summary of a Profile used by a ProfileSnapshot Header.
 *
 * Important to know that this is just a **hint**, the values
 * SHOULD be kept up to date, might might not be, since they
 * are stored values which must be kept in sync.
 */
public struct ContentHint {
    /**
     * The total number of accounts on all networks.
     *
     * Important to remember that this is a counter inside a
     * content **hint**. This counter SHOULD be update when
     * new accounts are created, but failing to do is of no
     * real consequence.
     *
     * This counter includes any by user hidden accounts.
     */
    public var numberOfAccountsOnAllNetworksInTotal: UInt16
    /**
     * The total number of personas on all networks.
     *
     * Important to remember that this is a counter inside a
     * content **hint**. This counter SHOULD be update when
     * new accounts are created, but failing to do is of no
     * real consequence.
     *
     * This counter includes any by user hidden personas.
     */
    public var numberOfPersonasOnAllNetworksInTotal: UInt16
    /**
     * The total number of networks that the user has used, i.e.
     * on which she has any accounts or personas.
     */
    public var numberOfNetworks: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The total number of accounts on all networks.
         *
         * Important to remember that this is a counter inside a
         * content **hint**. This counter SHOULD be update when
         * new accounts are created, but failing to do is of no
         * real consequence.
         *
         * This counter includes any by user hidden accounts.
         */numberOfAccountsOnAllNetworksInTotal: UInt16, 
        /**
         * The total number of personas on all networks.
         *
         * Important to remember that this is a counter inside a
         * content **hint**. This counter SHOULD be update when
         * new accounts are created, but failing to do is of no
         * real consequence.
         *
         * This counter includes any by user hidden personas.
         */numberOfPersonasOnAllNetworksInTotal: UInt16, 
        /**
         * The total number of networks that the user has used, i.e.
         * on which she has any accounts or personas.
         */numberOfNetworks: UInt16) {
        self.numberOfAccountsOnAllNetworksInTotal = numberOfAccountsOnAllNetworksInTotal
        self.numberOfPersonasOnAllNetworksInTotal = numberOfPersonasOnAllNetworksInTotal
        self.numberOfNetworks = numberOfNetworks
    }
}


extension ContentHint: Sendable {} 
extension ContentHint: Equatable, Hashable {
    public static func ==(lhs: ContentHint, rhs: ContentHint) -> Bool {
        if lhs.numberOfAccountsOnAllNetworksInTotal != rhs.numberOfAccountsOnAllNetworksInTotal {
            return false
        }
        if lhs.numberOfPersonasOnAllNetworksInTotal != rhs.numberOfPersonasOnAllNetworksInTotal {
            return false
        }
        if lhs.numberOfNetworks != rhs.numberOfNetworks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numberOfAccountsOnAllNetworksInTotal)
        hasher.combine(numberOfPersonasOnAllNetworksInTotal)
        hasher.combine(numberOfNetworks)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeContentHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContentHint {
        return
            try ContentHint(
                numberOfAccountsOnAllNetworksInTotal: FfiConverterUInt16.read(from: &buf), 
                numberOfPersonasOnAllNetworksInTotal: FfiConverterUInt16.read(from: &buf), 
                numberOfNetworks: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: ContentHint, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.numberOfAccountsOnAllNetworksInTotal, into: &buf)
        FfiConverterUInt16.write(value.numberOfPersonasOnAllNetworksInTotal, into: &buf)
        FfiConverterUInt16.write(value.numberOfNetworks, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContentHint_lift(_ buf: RustBuffer) throws -> ContentHint {
    return try FfiConverterTypeContentHint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeContentHint_lower(_ value: ContentHint) -> RustBuffer {
    return FfiConverterTypeContentHint.lower(value)
}


public struct CreateDeleteAccountManifestOutcome {
    public var manifest: TransactionManifest
    public var nonTransferableResources: [ResourceAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(manifest: TransactionManifest, nonTransferableResources: [ResourceAddress]) {
        self.manifest = manifest
        self.nonTransferableResources = nonTransferableResources
    }
}


extension CreateDeleteAccountManifestOutcome: Sendable {} 
extension CreateDeleteAccountManifestOutcome: Equatable, Hashable {
    public static func ==(lhs: CreateDeleteAccountManifestOutcome, rhs: CreateDeleteAccountManifestOutcome) -> Bool {
        if lhs.manifest != rhs.manifest {
            return false
        }
        if lhs.nonTransferableResources != rhs.nonTransferableResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(manifest)
        hasher.combine(nonTransferableResources)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreateDeleteAccountManifestOutcome: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateDeleteAccountManifestOutcome {
        return
            try CreateDeleteAccountManifestOutcome(
                manifest: FfiConverterTypeTransactionManifest.read(from: &buf), 
                nonTransferableResources: FfiConverterSequenceTypeResourceAddress.read(from: &buf)
        )
    }

    public static func write(_ value: CreateDeleteAccountManifestOutcome, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionManifest.write(value.manifest, into: &buf)
        FfiConverterSequenceTypeResourceAddress.write(value.nonTransferableResources, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateDeleteAccountManifestOutcome_lift(_ buf: RustBuffer) throws -> CreateDeleteAccountManifestOutcome {
    return try FfiConverterTypeCreateDeleteAccountManifestOutcome.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateDeleteAccountManifestOutcome_lower(_ value: CreateDeleteAccountManifestOutcome) -> RustBuffer {
    return FfiConverterTypeCreateDeleteAccountManifestOutcome.lower(value)
}


public struct DappToWalletInteraction {
    public var interactionId: WalletInteractionId
    public var items: DappToWalletInteractionItems
    public var metadata: DappToWalletInteractionMetadata

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, items: DappToWalletInteractionItems, metadata: DappToWalletInteractionMetadata) {
        self.interactionId = interactionId
        self.items = items
        self.metadata = metadata
    }
}


extension DappToWalletInteraction: Sendable {} 
extension DappToWalletInteraction: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteraction, rhs: DappToWalletInteraction) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(items)
        hasher.combine(metadata)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteraction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteraction {
        return
            try DappToWalletInteraction(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf), 
                items: FfiConverterTypeDappToWalletInteractionItems.read(from: &buf), 
                metadata: FfiConverterTypeDappToWalletInteractionMetadata.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteraction, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeDappToWalletInteractionItems.write(value.items, into: &buf)
        FfiConverterTypeDappToWalletInteractionMetadata.write(value.metadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteraction_lift(_ buf: RustBuffer) throws -> DappToWalletInteraction {
    return try FfiConverterTypeDappToWalletInteraction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteraction_lower(_ value: DappToWalletInteraction) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteraction.lower(value)
}


public struct DappToWalletInteractionAccountsRequestItem {
    public var numberOfAccounts: RequestedQuantity
    public var challenge: DappToWalletInteractionAuthChallengeNonce?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(numberOfAccounts: RequestedQuantity, challenge: DappToWalletInteractionAuthChallengeNonce?) {
        self.numberOfAccounts = numberOfAccounts
        self.challenge = challenge
    }
}


extension DappToWalletInteractionAccountsRequestItem: Sendable {} 
extension DappToWalletInteractionAccountsRequestItem: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionAccountsRequestItem, rhs: DappToWalletInteractionAccountsRequestItem) -> Bool {
        if lhs.numberOfAccounts != rhs.numberOfAccounts {
            return false
        }
        if lhs.challenge != rhs.challenge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numberOfAccounts)
        hasher.combine(challenge)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionAccountsRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAccountsRequestItem {
        return
            try DappToWalletInteractionAccountsRequestItem(
                numberOfAccounts: FfiConverterTypeRequestedQuantity.read(from: &buf), 
                challenge: FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionAccountsRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.numberOfAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionAccountsRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAccountsRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAccountsRequestItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionAccountsRequestItem_lower(_ value: DappToWalletInteractionAccountsRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAccountsRequestItem.lower(value)
}


public struct DappToWalletInteractionAuthLoginWithChallengeRequestItem {
    public var challenge: DappToWalletInteractionAuthChallengeNonce

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(challenge: DappToWalletInteractionAuthChallengeNonce) {
        self.challenge = challenge
    }
}


extension DappToWalletInteractionAuthLoginWithChallengeRequestItem: Sendable {} 
extension DappToWalletInteractionAuthLoginWithChallengeRequestItem: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionAuthLoginWithChallengeRequestItem, rhs: DappToWalletInteractionAuthLoginWithChallengeRequestItem) -> Bool {
        if lhs.challenge != rhs.challenge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challenge)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthLoginWithChallengeRequestItem {
        return
            try DappToWalletInteractionAuthLoginWithChallengeRequestItem(
                challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionAuthLoginWithChallengeRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthLoginWithChallengeRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem_lower(_ value: DappToWalletInteractionAuthLoginWithChallengeRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.lower(value)
}


public struct DappToWalletInteractionAuthUsePersonaRequestItem {
    public var identityAddress: IdentityAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityAddress: IdentityAddress) {
        self.identityAddress = identityAddress
    }
}


extension DappToWalletInteractionAuthUsePersonaRequestItem: Sendable {} 
extension DappToWalletInteractionAuthUsePersonaRequestItem: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionAuthUsePersonaRequestItem, rhs: DappToWalletInteractionAuthUsePersonaRequestItem) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthUsePersonaRequestItem {
        return
            try DappToWalletInteractionAuthUsePersonaRequestItem(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionAuthUsePersonaRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthUsePersonaRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem_lower(_ value: DappToWalletInteractionAuthUsePersonaRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.lower(value)
}


public struct DappToWalletInteractionAuthorizedRequestItems {
    public var auth: DappToWalletInteractionAuthRequestItem
    public var reset: DappToWalletInteractionResetRequestItem?
    public var ongoingAccounts: DappToWalletInteractionAccountsRequestItem?
    public var ongoingPersonaData: DappToWalletInteractionPersonaDataRequestItem?
    public var oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?
    public var oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?
    public var proofOfOwnership: DappToWalletInteractionProofOfOwnershipRequestItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(auth: DappToWalletInteractionAuthRequestItem, reset: DappToWalletInteractionResetRequestItem?, ongoingAccounts: DappToWalletInteractionAccountsRequestItem?, ongoingPersonaData: DappToWalletInteractionPersonaDataRequestItem?, oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?, oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?, proofOfOwnership: DappToWalletInteractionProofOfOwnershipRequestItem?) {
        self.auth = auth
        self.reset = reset
        self.ongoingAccounts = ongoingAccounts
        self.ongoingPersonaData = ongoingPersonaData
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
        self.proofOfOwnership = proofOfOwnership
    }
}


extension DappToWalletInteractionAuthorizedRequestItems: Sendable {} 
extension DappToWalletInteractionAuthorizedRequestItems: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionAuthorizedRequestItems, rhs: DappToWalletInteractionAuthorizedRequestItems) -> Bool {
        if lhs.auth != rhs.auth {
            return false
        }
        if lhs.reset != rhs.reset {
            return false
        }
        if lhs.ongoingAccounts != rhs.ongoingAccounts {
            return false
        }
        if lhs.ongoingPersonaData != rhs.ongoingPersonaData {
            return false
        }
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        if lhs.proofOfOwnership != rhs.proofOfOwnership {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(auth)
        hasher.combine(reset)
        hasher.combine(ongoingAccounts)
        hasher.combine(ongoingPersonaData)
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
        hasher.combine(proofOfOwnership)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthorizedRequestItems {
        return
            try DappToWalletInteractionAuthorizedRequestItems(
                auth: FfiConverterTypeDappToWalletInteractionAuthRequestItem.read(from: &buf), 
                reset: FfiConverterOptionTypeDappToWalletInteractionResetRequestItem.read(from: &buf), 
                ongoingAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf), 
                ongoingPersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf), 
                oneTimeAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf), 
                oneTimePersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf), 
                proofOfOwnership: FfiConverterOptionTypeDappToWalletInteractionProofOfOwnershipRequestItem.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionAuthorizedRequestItems, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionAuthRequestItem.write(value.auth, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionResetRequestItem.write(value.reset, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.ongoingAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.ongoingPersonaData, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.oneTimePersonaData, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionProofOfOwnershipRequestItem.write(value.proofOfOwnership, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthorizedRequestItems {
    return try FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems_lower(_ value: DappToWalletInteractionAuthorizedRequestItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.lower(value)
}


public struct DappToWalletInteractionBatchOfTransactions {
    public var transactions: [UnvalidatedTransactionManifest]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactions: [UnvalidatedTransactionManifest]) {
        self.transactions = transactions
    }
}


extension DappToWalletInteractionBatchOfTransactions: Sendable {} 
extension DappToWalletInteractionBatchOfTransactions: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionBatchOfTransactions, rhs: DappToWalletInteractionBatchOfTransactions) -> Bool {
        if lhs.transactions != rhs.transactions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactions)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionBatchOfTransactions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionBatchOfTransactions {
        return
            try DappToWalletInteractionBatchOfTransactions(
                transactions: FfiConverterSequenceTypeUnvalidatedTransactionManifest.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionBatchOfTransactions, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeUnvalidatedTransactionManifest.write(value.transactions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionBatchOfTransactions_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionBatchOfTransactions {
    return try FfiConverterTypeDappToWalletInteractionBatchOfTransactions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionBatchOfTransactions_lower(_ value: DappToWalletInteractionBatchOfTransactions) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionBatchOfTransactions.lower(value)
}


public struct DappToWalletInteractionMetadata {
    public var version: WalletInteractionVersion
    public var networkId: NetworkId
    public var origin: DappOrigin
    public var dappDefinitionAddress: AccountAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: WalletInteractionVersion, networkId: NetworkId, origin: DappOrigin, dappDefinitionAddress: AccountAddress) {
        self.version = version
        self.networkId = networkId
        self.origin = origin
        self.dappDefinitionAddress = dappDefinitionAddress
    }
}


extension DappToWalletInteractionMetadata: Sendable {} 
extension DappToWalletInteractionMetadata: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionMetadata, rhs: DappToWalletInteractionMetadata) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(networkId)
        hasher.combine(origin)
        hasher.combine(dappDefinitionAddress)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionMetadata {
        return
            try DappToWalletInteractionMetadata(
                version: FfiConverterTypeWalletInteractionVersion.read(from: &buf), 
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                origin: FfiConverterTypeDappOrigin.read(from: &buf), 
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionVersion.write(value.version, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionMetadata_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionMetadata {
    return try FfiConverterTypeDappToWalletInteractionMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionMetadata_lower(_ value: DappToWalletInteractionMetadata) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionMetadata.lower(value)
}


public struct DappToWalletInteractionMetadataUnvalidated {
    public var version: WalletInteractionVersion
    public var networkId: NetworkId
    public var origin: DappOrigin
    public var dappDefinitionAddress: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: WalletInteractionVersion, networkId: NetworkId, origin: DappOrigin, dappDefinitionAddress: String) {
        self.version = version
        self.networkId = networkId
        self.origin = origin
        self.dappDefinitionAddress = dappDefinitionAddress
    }
}


extension DappToWalletInteractionMetadataUnvalidated: Sendable {} 
extension DappToWalletInteractionMetadataUnvalidated: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionMetadataUnvalidated, rhs: DappToWalletInteractionMetadataUnvalidated) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(networkId)
        hasher.combine(origin)
        hasher.combine(dappDefinitionAddress)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionMetadataUnvalidated: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionMetadataUnvalidated {
        return
            try DappToWalletInteractionMetadataUnvalidated(
                version: FfiConverterTypeWalletInteractionVersion.read(from: &buf), 
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                origin: FfiConverterTypeDappOrigin.read(from: &buf), 
                dappDefinitionAddress: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionMetadataUnvalidated, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionVersion.write(value.version, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
        FfiConverterString.write(value.dappDefinitionAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionMetadataUnvalidated_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionMetadataUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionMetadataUnvalidated_lower(_ value: DappToWalletInteractionMetadataUnvalidated) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.lower(value)
}


public struct DappToWalletInteractionPersonaDataRequestItem {
    public var isRequestingName: Bool?
    public var numberOfRequestedEmailAddresses: RequestedQuantity?
    public var numberOfRequestedPhoneNumbers: RequestedQuantity?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isRequestingName: Bool?, numberOfRequestedEmailAddresses: RequestedQuantity?, numberOfRequestedPhoneNumbers: RequestedQuantity?) {
        self.isRequestingName = isRequestingName
        self.numberOfRequestedEmailAddresses = numberOfRequestedEmailAddresses
        self.numberOfRequestedPhoneNumbers = numberOfRequestedPhoneNumbers
    }
}


extension DappToWalletInteractionPersonaDataRequestItem: Sendable {} 
extension DappToWalletInteractionPersonaDataRequestItem: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionPersonaDataRequestItem, rhs: DappToWalletInteractionPersonaDataRequestItem) -> Bool {
        if lhs.isRequestingName != rhs.isRequestingName {
            return false
        }
        if lhs.numberOfRequestedEmailAddresses != rhs.numberOfRequestedEmailAddresses {
            return false
        }
        if lhs.numberOfRequestedPhoneNumbers != rhs.numberOfRequestedPhoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isRequestingName)
        hasher.combine(numberOfRequestedEmailAddresses)
        hasher.combine(numberOfRequestedPhoneNumbers)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionPersonaDataRequestItem {
        return
            try DappToWalletInteractionPersonaDataRequestItem(
                isRequestingName: FfiConverterOptionBool.read(from: &buf), 
                numberOfRequestedEmailAddresses: FfiConverterOptionTypeRequestedQuantity.read(from: &buf), 
                numberOfRequestedPhoneNumbers: FfiConverterOptionTypeRequestedQuantity.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionPersonaDataRequestItem, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.isRequestingName, into: &buf)
        FfiConverterOptionTypeRequestedQuantity.write(value.numberOfRequestedEmailAddresses, into: &buf)
        FfiConverterOptionTypeRequestedQuantity.write(value.numberOfRequestedPhoneNumbers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionPersonaDataRequestItem {
    return try FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem_lower(_ value: DappToWalletInteractionPersonaDataRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.lower(value)
}


public struct DappToWalletInteractionPreAuthorizationItems {
    public var request: DappToWalletInteractionSubintentRequestItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(request: DappToWalletInteractionSubintentRequestItem) {
        self.request = request
    }
}


extension DappToWalletInteractionPreAuthorizationItems: Sendable {} 
extension DappToWalletInteractionPreAuthorizationItems: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionPreAuthorizationItems, rhs: DappToWalletInteractionPreAuthorizationItems) -> Bool {
        if lhs.request != rhs.request {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(request)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionPreAuthorizationItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionPreAuthorizationItems {
        return
            try DappToWalletInteractionPreAuthorizationItems(
                request: FfiConverterTypeDappToWalletInteractionSubintentRequestItem.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionPreAuthorizationItems, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionSubintentRequestItem.write(value.request, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionPreAuthorizationItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionPreAuthorizationItems {
    return try FfiConverterTypeDappToWalletInteractionPreAuthorizationItems.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionPreAuthorizationItems_lower(_ value: DappToWalletInteractionPreAuthorizationItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionPreAuthorizationItems.lower(value)
}


/**
 * A request to prove ownership of `Accounts` and/or a `Persona`.
 */
public struct DappToWalletInteractionProofOfOwnershipRequestItem {
    /**
     * The challenge that must be signed to prove ownership.
     */
    public var challenge: DappToWalletInteractionAuthChallengeNonce
    /**
     * The list of `AccountAddress`es for which the wallet must prove ownership.
     */
    public var accountAddresses: [AccountAddress]?
    /**
     * The `IdentityAddress` for which the wallet must prove ownership.
     */
    public var identityAddress: IdentityAddress?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The challenge that must be signed to prove ownership.
         */challenge: DappToWalletInteractionAuthChallengeNonce, 
        /**
         * The list of `AccountAddress`es for which the wallet must prove ownership.
         */accountAddresses: [AccountAddress]?, 
        /**
         * The `IdentityAddress` for which the wallet must prove ownership.
         */identityAddress: IdentityAddress?) {
        self.challenge = challenge
        self.accountAddresses = accountAddresses
        self.identityAddress = identityAddress
    }
}


extension DappToWalletInteractionProofOfOwnershipRequestItem: Sendable {} 
extension DappToWalletInteractionProofOfOwnershipRequestItem: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionProofOfOwnershipRequestItem, rhs: DappToWalletInteractionProofOfOwnershipRequestItem) -> Bool {
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.accountAddresses != rhs.accountAddresses {
            return false
        }
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challenge)
        hasher.combine(accountAddresses)
        hasher.combine(identityAddress)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionProofOfOwnershipRequestItem {
        return
            try DappToWalletInteractionProofOfOwnershipRequestItem(
                challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf), 
                accountAddresses: FfiConverterOptionSequenceTypeAccountAddress.read(from: &buf), 
                identityAddress: FfiConverterOptionTypeIdentityAddress.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionProofOfOwnershipRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
        FfiConverterOptionSequenceTypeAccountAddress.write(value.accountAddresses, into: &buf)
        FfiConverterOptionTypeIdentityAddress.write(value.identityAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionProofOfOwnershipRequestItem {
    return try FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem_lower(_ value: DappToWalletInteractionProofOfOwnershipRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem.lower(value)
}


public struct DappToWalletInteractionResetRequestItem {
    public var accounts: Bool
    public var personaData: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accounts: Bool, personaData: Bool) {
        self.accounts = accounts
        self.personaData = personaData
    }
}


extension DappToWalletInteractionResetRequestItem: Sendable {} 
extension DappToWalletInteractionResetRequestItem: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionResetRequestItem, rhs: DappToWalletInteractionResetRequestItem) -> Bool {
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.personaData != rhs.personaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accounts)
        hasher.combine(personaData)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionResetRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionResetRequestItem {
        return
            try DappToWalletInteractionResetRequestItem(
                accounts: FfiConverterBool.read(from: &buf), 
                personaData: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionResetRequestItem, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.accounts, into: &buf)
        FfiConverterBool.write(value.personaData, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionResetRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionResetRequestItem {
    return try FfiConverterTypeDappToWalletInteractionResetRequestItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionResetRequestItem_lower(_ value: DappToWalletInteractionResetRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionResetRequestItem.lower(value)
}


public struct DappToWalletInteractionSendTransactionItem {
    public var unvalidatedManifest: UnvalidatedTransactionManifest
    public var version: TxVersion
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(unvalidatedManifest: UnvalidatedTransactionManifest, version: TxVersion, message: String?) {
        self.unvalidatedManifest = unvalidatedManifest
        self.version = version
        self.message = message
    }
}


extension DappToWalletInteractionSendTransactionItem: Sendable {} 
extension DappToWalletInteractionSendTransactionItem: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionSendTransactionItem, rhs: DappToWalletInteractionSendTransactionItem) -> Bool {
        if lhs.unvalidatedManifest != rhs.unvalidatedManifest {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(unvalidatedManifest)
        hasher.combine(version)
        hasher.combine(message)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionSendTransactionItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSendTransactionItem {
        return
            try DappToWalletInteractionSendTransactionItem(
                unvalidatedManifest: FfiConverterTypeUnvalidatedTransactionManifest.read(from: &buf), 
                version: FfiConverterTypeTXVersion.read(from: &buf), 
                message: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionSendTransactionItem, into buf: inout [UInt8]) {
        FfiConverterTypeUnvalidatedTransactionManifest.write(value.unvalidatedManifest, into: &buf)
        FfiConverterTypeTXVersion.write(value.version, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionSendTransactionItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSendTransactionItem {
    return try FfiConverterTypeDappToWalletInteractionSendTransactionItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionSendTransactionItem_lower(_ value: DappToWalletInteractionSendTransactionItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSendTransactionItem.lower(value)
}


/**
 * Suggests that the subintent's expiry timestamp is set to `current_time + expire_after_seconds`
 * at the last moment, right before the intent is fixed for signing.
 */
public struct DappToWalletInteractionSubintentExpireAfterDelay {
    /**
     * The time (in seconds) after the subintent is signed that it will expire.
     */
    public var expireAfterSeconds: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The time (in seconds) after the subintent is signed that it will expire.
         */expireAfterSeconds: UInt64) {
        self.expireAfterSeconds = expireAfterSeconds
    }
}


extension DappToWalletInteractionSubintentExpireAfterDelay: Sendable {} 
extension DappToWalletInteractionSubintentExpireAfterDelay: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionSubintentExpireAfterDelay, rhs: DappToWalletInteractionSubintentExpireAfterDelay) -> Bool {
        if lhs.expireAfterSeconds != rhs.expireAfterSeconds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(expireAfterSeconds)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentExpireAfterDelay {
        return
            try DappToWalletInteractionSubintentExpireAfterDelay(
                expireAfterSeconds: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionSubintentExpireAfterDelay, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.expireAfterSeconds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentExpireAfterDelay {
    return try FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay_lower(_ value: DappToWalletInteractionSubintentExpireAfterDelay) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay.lower(value)
}


/**
 * The subintent expires at a specific fixed timestamp
 */
public struct DappToWalletInteractionSubintentExpireAtTime {
    /**
     * The unix timestamp in seconds when the subintent expires.
     */
    public var unixTimestampSeconds: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The unix timestamp in seconds when the subintent expires.
         */unixTimestampSeconds: UInt64) {
        self.unixTimestampSeconds = unixTimestampSeconds
    }
}


extension DappToWalletInteractionSubintentExpireAtTime: Sendable {} 
extension DappToWalletInteractionSubintentExpireAtTime: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionSubintentExpireAtTime, rhs: DappToWalletInteractionSubintentExpireAtTime) -> Bool {
        if lhs.unixTimestampSeconds != rhs.unixTimestampSeconds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(unixTimestampSeconds)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentExpireAtTime {
        return
            try DappToWalletInteractionSubintentExpireAtTime(
                unixTimestampSeconds: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionSubintentExpireAtTime, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.unixTimestampSeconds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentExpireAtTime {
    return try FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime_lower(_ value: DappToWalletInteractionSubintentExpireAtTime) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime.lower(value)
}


public struct DappToWalletInteractionSubintentRequestItem {
    public var version: SubintentVersion
    public var unvalidatedManifest: UnvalidatedSubintentManifest
    public var message: String?
    public var expiration: DappToWalletInteractionSubintentExpiration

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: SubintentVersion, unvalidatedManifest: UnvalidatedSubintentManifest, message: String?, expiration: DappToWalletInteractionSubintentExpiration) {
        self.version = version
        self.unvalidatedManifest = unvalidatedManifest
        self.message = message
        self.expiration = expiration
    }
}


extension DappToWalletInteractionSubintentRequestItem: Sendable {} 
extension DappToWalletInteractionSubintentRequestItem: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionSubintentRequestItem, rhs: DappToWalletInteractionSubintentRequestItem) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.unvalidatedManifest != rhs.unvalidatedManifest {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.expiration != rhs.expiration {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(unvalidatedManifest)
        hasher.combine(message)
        hasher.combine(expiration)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionSubintentRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentRequestItem {
        return
            try DappToWalletInteractionSubintentRequestItem(
                version: FfiConverterTypeSubintentVersion.read(from: &buf), 
                unvalidatedManifest: FfiConverterTypeUnvalidatedSubintentManifest.read(from: &buf), 
                message: FfiConverterOptionString.read(from: &buf), 
                expiration: FfiConverterTypeDappToWalletInteractionSubintentExpiration.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionSubintentRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeSubintentVersion.write(value.version, into: &buf)
        FfiConverterTypeUnvalidatedSubintentManifest.write(value.unvalidatedManifest, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterTypeDappToWalletInteractionSubintentExpiration.write(value.expiration, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionSubintentRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentRequestItem {
    return try FfiConverterTypeDappToWalletInteractionSubintentRequestItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionSubintentRequestItem_lower(_ value: DappToWalletInteractionSubintentRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSubintentRequestItem.lower(value)
}


public struct DappToWalletInteractionTransactionItems {
    public var send: DappToWalletInteractionSendTransactionItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(send: DappToWalletInteractionSendTransactionItem) {
        self.send = send
    }
}


extension DappToWalletInteractionTransactionItems: Sendable {} 
extension DappToWalletInteractionTransactionItems: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionTransactionItems, rhs: DappToWalletInteractionTransactionItems) -> Bool {
        if lhs.send != rhs.send {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(send)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionTransactionItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionTransactionItems {
        return
            try DappToWalletInteractionTransactionItems(
                send: FfiConverterTypeDappToWalletInteractionSendTransactionItem.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionTransactionItems, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionSendTransactionItem.write(value.send, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionTransactionItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionTransactionItems {
    return try FfiConverterTypeDappToWalletInteractionTransactionItems.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionTransactionItems_lower(_ value: DappToWalletInteractionTransactionItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionTransactionItems.lower(value)
}


public struct DappToWalletInteractionUnauthorizedRequestItems {
    public var oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?
    public var oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?, oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?) {
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
    }
}


extension DappToWalletInteractionUnauthorizedRequestItems: Sendable {} 
extension DappToWalletInteractionUnauthorizedRequestItems: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionUnauthorizedRequestItems, rhs: DappToWalletInteractionUnauthorizedRequestItems) -> Bool {
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionUnauthorizedRequestItems {
        return
            try DappToWalletInteractionUnauthorizedRequestItems(
                oneTimeAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf), 
                oneTimePersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionUnauthorizedRequestItems, into buf: inout [UInt8]) {
        FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.oneTimePersonaData, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionUnauthorizedRequestItems {
    return try FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems_lower(_ value: DappToWalletInteractionUnauthorizedRequestItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.lower(value)
}


public struct DappToWalletInteractionUnvalidated {
    public var interactionId: WalletInteractionId
    public var items: DappToWalletInteractionItems
    public var metadata: DappToWalletInteractionMetadataUnvalidated

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, items: DappToWalletInteractionItems, metadata: DappToWalletInteractionMetadataUnvalidated) {
        self.interactionId = interactionId
        self.items = items
        self.metadata = metadata
    }
}


extension DappToWalletInteractionUnvalidated: Sendable {} 
extension DappToWalletInteractionUnvalidated: Equatable, Hashable {
    public static func ==(lhs: DappToWalletInteractionUnvalidated, rhs: DappToWalletInteractionUnvalidated) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(items)
        hasher.combine(metadata)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionUnvalidated: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionUnvalidated {
        return
            try DappToWalletInteractionUnvalidated(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf), 
                items: FfiConverterTypeDappToWalletInteractionItems.read(from: &buf), 
                metadata: FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.read(from: &buf)
        )
    }

    public static func write(_ value: DappToWalletInteractionUnvalidated, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeDappToWalletInteractionItems.write(value.items, into: &buf)
        FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.write(value.metadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionUnvalidated_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionUnvalidated.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionUnvalidated_lower(_ value: DappToWalletInteractionUnvalidated) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionUnvalidated.lower(value)
}


public struct DappWalletInteractionPersona {
    public var identityAddress: IdentityAddress
    public var label: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityAddress: IdentityAddress, label: String) {
        self.identityAddress = identityAddress
        self.label = label
    }
}


extension DappWalletInteractionPersona: Sendable {} 
extension DappWalletInteractionPersona: Equatable, Hashable {
    public static func ==(lhs: DappWalletInteractionPersona, rhs: DappWalletInteractionPersona) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(label)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappWalletInteractionPersona: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappWalletInteractionPersona {
        return
            try DappWalletInteractionPersona(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf), 
                label: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DappWalletInteractionPersona, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappWalletInteractionPersona_lift(_ buf: RustBuffer) throws -> DappWalletInteractionPersona {
    return try FfiConverterTypeDappWalletInteractionPersona.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappWalletInteractionPersona_lower(_ value: DappWalletInteractionPersona) -> RustBuffer {
    return FfiConverterTypeDappWalletInteractionPersona.lower(value)
}


/**
 * `Decimal192` represents a 192 bit representation of a fixed-scale decimal number.
 *
 * The finite set of values are of the form `m / 10^18`, where `m` is
 * an integer such that `-2^(192 - 1) <= m < 2^(192 - 1)`.
 *
 * Fractional part: ~60 bits/18 digits
 * Integer part   : 132 bits /40 digits
 * Max            :  3138550867693340381917894711603833208051.177722232017256447
 * Min            : -3138550867693340381917894711603833208051.177722232017256448
 *
 * Unless otherwise specified, all operations will panic if underflow/overflow.
 *
 * Powering it is the [Scrypto Decimal type, see docs][scrypto].
 *
 * Note: This type cannot be called `Decimal`, since it results in naming collision
 * in the Swift land (clash with `Foundation.Decimal`) instead we have created a
 * type alias `Decimal = Decimal192` which we use in Rust land.
 *
 * [scrypto]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/math/decimal.rs#L42
 */
public struct Decimal192 {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension Decimal192: Sendable {} 
extension Decimal192: Equatable, Hashable {
    public static func ==(lhs: Decimal192, rhs: Decimal192) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDecimal192: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Decimal192 {
        return
            try Decimal192(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Decimal192, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDecimal192_lift(_ buf: RustBuffer) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDecimal192_lower(_ value: Decimal192) -> RustBuffer {
    return FfiConverterTypeDecimal192.lower(value)
}


/**
 * A factor source representing the host device which SargonOS runs on, typically
 * an iPhone or Android device.
 *
 * This is the initial factor source of
 * all new Accounts and Personas. Users authenticate signing by authorizing
 * the host to access a mnemonic stored in secure storage on
 * the device.
 */
public struct DeviceFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a DeviceFactorSource to help user disambiguate between it and another one.
     */
    public var hint: DeviceFactorSourceHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic.
         */id: FactorSourceIdFromHash, 
        /**
         * Common properties shared between FactorSources of different kinds,
         * describing its state, when added, and supported cryptographic parameters.
         */common: FactorSourceCommon, 
        /**
         * Properties describing a DeviceFactorSource to help user disambiguate between it and another one.
         */hint: DeviceFactorSourceHint) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}


extension DeviceFactorSource: Sendable {} 
extension DeviceFactorSource: Equatable, Hashable {
    public static func ==(lhs: DeviceFactorSource, rhs: DeviceFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeviceFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSource {
        return
            try DeviceFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf), 
                hint: FfiConverterTypeDeviceFactorSourceHint.read(from: &buf)
        )
    }

    public static func write(_ value: DeviceFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeDeviceFactorSourceHint.write(value.hint, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceFactorSource_lift(_ buf: RustBuffer) throws -> DeviceFactorSource {
    return try FfiConverterTypeDeviceFactorSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceFactorSource_lower(_ value: DeviceFactorSource) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSource.lower(value)
}


/**
 * Properties describing a DeviceFactorSource to help user disambiguate between
 * it and another one.
 */
public struct DeviceFactorSourceHint {
    /**
     * A user-assigned name for the device, intended to help users
     * differentiate between multiple devices.
     *
     * Example: "My Phone"
     */
    public var label: String
    /**
     * The name of the device as provided by the system.
     *
     * Example: "iPhone RED"
     */
    public var deviceName: String
    /**
     * "iPhone SE 2nd gen"
     */
    public var model: String
    /**
     * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
     * standard, a multiple of 3, from 12 to 24 words.
     */
    public var mnemonicWordCount: Bip39WordCount
    /**
     * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
     *
     * It is possible that the host device has been updated to a new
     * version than recorded here, but Sargon or host clients might
     * just not have updated this value here.
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var systemVersion: String?
    /**
     * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
     *
     * It is possible that the host device has been updated to a new
     * version than recorded here, but Sargon or host clients might
     * just not have updated this value here.
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var hostAppVersion: String?
    /**
     * The vendor of the device host, e.g. "Apple" or "Samsung".
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var hostVendor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A user-assigned name for the device, intended to help users
         * differentiate between multiple devices.
         *
         * Example: "My Phone"
         */label: String, 
        /**
         * The name of the device as provided by the system.
         *
         * Example: "iPhone RED"
         */deviceName: String, 
        /**
         * "iPhone SE 2nd gen"
         */model: String, 
        /**
         * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
         * standard, a multiple of 3, from 12 to 24 words.
         */mnemonicWordCount: Bip39WordCount, 
        /**
         * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
         *
         * It is possible that the host device has been updated to a new
         * version than recorded here, but Sargon or host clients might
         * just not have updated this value here.
         *
         * MUST be optional since this was added on 2024-05-03 and
         * was not present in earlier version of wallet (pre 1.6.0).
         */systemVersion: String?, 
        /**
         * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
         *
         * It is possible that the host device has been updated to a new
         * version than recorded here, but Sargon or host clients might
         * just not have updated this value here.
         *
         * MUST be optional since this was added on 2024-05-03 and
         * was not present in earlier version of wallet (pre 1.6.0).
         */hostAppVersion: String?, 
        /**
         * The vendor of the device host, e.g. "Apple" or "Samsung".
         *
         * MUST be optional since this was added on 2024-05-03 and
         * was not present in earlier version of wallet (pre 1.6.0).
         */hostVendor: String?) {
        self.label = label
        self.deviceName = deviceName
        self.model = model
        self.mnemonicWordCount = mnemonicWordCount
        self.systemVersion = systemVersion
        self.hostAppVersion = hostAppVersion
        self.hostVendor = hostVendor
    }
}


extension DeviceFactorSourceHint: Sendable {} 
extension DeviceFactorSourceHint: Equatable, Hashable {
    public static func ==(lhs: DeviceFactorSourceHint, rhs: DeviceFactorSourceHint) -> Bool {
        if lhs.label != rhs.label {
            return false
        }
        if lhs.deviceName != rhs.deviceName {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        if lhs.mnemonicWordCount != rhs.mnemonicWordCount {
            return false
        }
        if lhs.systemVersion != rhs.systemVersion {
            return false
        }
        if lhs.hostAppVersion != rhs.hostAppVersion {
            return false
        }
        if lhs.hostVendor != rhs.hostVendor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(label)
        hasher.combine(deviceName)
        hasher.combine(model)
        hasher.combine(mnemonicWordCount)
        hasher.combine(systemVersion)
        hasher.combine(hostAppVersion)
        hasher.combine(hostVendor)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeviceFactorSourceHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSourceHint {
        return
            try DeviceFactorSourceHint(
                label: FfiConverterString.read(from: &buf), 
                deviceName: FfiConverterString.read(from: &buf), 
                model: FfiConverterString.read(from: &buf), 
                mnemonicWordCount: FfiConverterTypeBIP39WordCount.read(from: &buf), 
                systemVersion: FfiConverterOptionString.read(from: &buf), 
                hostAppVersion: FfiConverterOptionString.read(from: &buf), 
                hostVendor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: DeviceFactorSourceHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.label, into: &buf)
        FfiConverterString.write(value.deviceName, into: &buf)
        FfiConverterString.write(value.model, into: &buf)
        FfiConverterTypeBIP39WordCount.write(value.mnemonicWordCount, into: &buf)
        FfiConverterOptionString.write(value.systemVersion, into: &buf)
        FfiConverterOptionString.write(value.hostAppVersion, into: &buf)
        FfiConverterOptionString.write(value.hostVendor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceFactorSourceHint_lift(_ buf: RustBuffer) throws -> DeviceFactorSourceHint {
    return try FfiConverterTypeDeviceFactorSourceHint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceFactorSourceHint_lower(_ value: DeviceFactorSourceHint) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSourceHint.lower(value)
}


/**
 * A struct representing the integrity of a device factor source.
 */
public struct DeviceFactorSourceIntegrity {
    /**
     * The factor source that is linked to the entities.
     */
    public var factorSource: DeviceFactorSource
    /**
     * Whether the mnemonic of the factor source is present in secure storage.
     */
    public var isMnemonicPresentInSecureStorage: Bool
    /**
     * Whether the mnemonic of the factor source is marked as backed up.
     */
    public var isMnemonicMarkedAsBackedUp: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The factor source that is linked to the entities.
         */factorSource: DeviceFactorSource, 
        /**
         * Whether the mnemonic of the factor source is present in secure storage.
         */isMnemonicPresentInSecureStorage: Bool, 
        /**
         * Whether the mnemonic of the factor source is marked as backed up.
         */isMnemonicMarkedAsBackedUp: Bool) {
        self.factorSource = factorSource
        self.isMnemonicPresentInSecureStorage = isMnemonicPresentInSecureStorage
        self.isMnemonicMarkedAsBackedUp = isMnemonicMarkedAsBackedUp
    }
}


extension DeviceFactorSourceIntegrity: Sendable {} 
extension DeviceFactorSourceIntegrity: Equatable, Hashable {
    public static func ==(lhs: DeviceFactorSourceIntegrity, rhs: DeviceFactorSourceIntegrity) -> Bool {
        if lhs.factorSource != rhs.factorSource {
            return false
        }
        if lhs.isMnemonicPresentInSecureStorage != rhs.isMnemonicPresentInSecureStorage {
            return false
        }
        if lhs.isMnemonicMarkedAsBackedUp != rhs.isMnemonicMarkedAsBackedUp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSource)
        hasher.combine(isMnemonicPresentInSecureStorage)
        hasher.combine(isMnemonicMarkedAsBackedUp)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeviceFactorSourceIntegrity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSourceIntegrity {
        return
            try DeviceFactorSourceIntegrity(
                factorSource: FfiConverterTypeDeviceFactorSource.read(from: &buf), 
                isMnemonicPresentInSecureStorage: FfiConverterBool.read(from: &buf), 
                isMnemonicMarkedAsBackedUp: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: DeviceFactorSourceIntegrity, into buf: inout [UInt8]) {
        FfiConverterTypeDeviceFactorSource.write(value.factorSource, into: &buf)
        FfiConverterBool.write(value.isMnemonicPresentInSecureStorage, into: &buf)
        FfiConverterBool.write(value.isMnemonicMarkedAsBackedUp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceFactorSourceIntegrity_lift(_ buf: RustBuffer) throws -> DeviceFactorSourceIntegrity {
    return try FfiConverterTypeDeviceFactorSourceIntegrity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceFactorSourceIntegrity_lower(_ value: DeviceFactorSourceIntegrity) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSourceIntegrity.lower(value)
}


/**
 * A short summary of a device the Profile is being used
 * on, typically an iPhone or an Android phone.
 */
public struct DeviceInfo {
    /**
     * A best effort stable and unique identifier of this
     * device.
     *
     * Apple has made it so that iOS devices cannot
     * query iOS for a unique identifier of the device, thus
     * the iOS team has made their own impl of a best effort
     * stable identifier.
     */
    public var id: DeviceId
    /**
     * The date this description of the device was made, might
     * be equal to when the app was first ever launched on the
     * device.
     */
    public var date: Timestamp
    /**
     * A short description of the device, we devices should
     * read the device model and a given name from the device
     * if they are able to.
     */
    public var description: String
    /**
     * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
     *
     * It is possible that the host device has been updated to a new
     * version than recorded here, but Sargon or host clients might
     * just not have updated this value here.
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var systemVersion: String?
    /**
     * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
     *
     * It is possible that the host device has been updated to a new
     * version than recorded here, but Sargon or host clients might
     * just not have updated this value here.
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var hostAppVersion: String?
    /**
     * The vendor of the host client, e.g. "Apple" for iPhone clients,
     * or "Samsung" for Android clients.
     *
     * MUST be optional since this was added on 2024-05-16 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var hostVendor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A best effort stable and unique identifier of this
         * device.
         *
         * Apple has made it so that iOS devices cannot
         * query iOS for a unique identifier of the device, thus
         * the iOS team has made their own impl of a best effort
         * stable identifier.
         */id: DeviceId, 
        /**
         * The date this description of the device was made, might
         * be equal to when the app was first ever launched on the
         * device.
         */date: Timestamp, 
        /**
         * A short description of the device, we devices should
         * read the device model and a given name from the device
         * if they are able to.
         */description: String, 
        /**
         * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
         *
         * It is possible that the host device has been updated to a new
         * version than recorded here, but Sargon or host clients might
         * just not have updated this value here.
         *
         * MUST be optional since this was added on 2024-05-03 and
         * was not present in earlier version of wallet (pre 1.6.0).
         */systemVersion: String?, 
        /**
         * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
         *
         * It is possible that the host device has been updated to a new
         * version than recorded here, but Sargon or host clients might
         * just not have updated this value here.
         *
         * MUST be optional since this was added on 2024-05-03 and
         * was not present in earlier version of wallet (pre 1.6.0).
         */hostAppVersion: String?, 
        /**
         * The vendor of the host client, e.g. "Apple" for iPhone clients,
         * or "Samsung" for Android clients.
         *
         * MUST be optional since this was added on 2024-05-16 and
         * was not present in earlier version of wallet (pre 1.6.0).
         */hostVendor: String?) {
        self.id = id
        self.date = date
        self.description = description
        self.systemVersion = systemVersion
        self.hostAppVersion = hostAppVersion
        self.hostVendor = hostVendor
    }
}


extension DeviceInfo: Sendable {} 
extension DeviceInfo: Equatable, Hashable {
    public static func ==(lhs: DeviceInfo, rhs: DeviceInfo) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.date != rhs.date {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.systemVersion != rhs.systemVersion {
            return false
        }
        if lhs.hostAppVersion != rhs.hostAppVersion {
            return false
        }
        if lhs.hostVendor != rhs.hostVendor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(date)
        hasher.combine(description)
        hasher.combine(systemVersion)
        hasher.combine(hostAppVersion)
        hasher.combine(hostVendor)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeviceInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceInfo {
        return
            try DeviceInfo(
                id: FfiConverterTypeDeviceID.read(from: &buf), 
                date: FfiConverterTypeTimestamp.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                systemVersion: FfiConverterOptionString.read(from: &buf), 
                hostAppVersion: FfiConverterOptionString.read(from: &buf), 
                hostVendor: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: DeviceInfo, into buf: inout [UInt8]) {
        FfiConverterTypeDeviceID.write(value.id, into: &buf)
        FfiConverterTypeTimestamp.write(value.date, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.systemVersion, into: &buf)
        FfiConverterOptionString.write(value.hostAppVersion, into: &buf)
        FfiConverterOptionString.write(value.hostVendor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceInfo_lift(_ buf: RustBuffer) throws -> DeviceInfo {
    return try FfiConverterTypeDeviceInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceInfo_lower(_ value: DeviceInfo) -> RustBuffer {
    return FfiConverterTypeDeviceInfo.lower(value)
}


/**
 * A name and model of a host device.
 *
 * This used to be a String only in Pre 1.6.0 wallets, so
 * we have a custom Deserialize impl of it.
 */
public struct DeviceInfoDescription {
    /**
     * Host device name, e.g. "My Precious"
     */
    public var name: String
    /**
     * Host device model, e.g. "iPhone 15 Pro"
     */
    public var model: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Host device name, e.g. "My Precious"
         */name: String, 
        /**
         * Host device model, e.g. "iPhone 15 Pro"
         */model: String) {
        self.name = name
        self.model = model
    }
}


extension DeviceInfoDescription: Sendable {} 
extension DeviceInfoDescription: Equatable, Hashable {
    public static func ==(lhs: DeviceInfoDescription, rhs: DeviceInfoDescription) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeviceInfoDescription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceInfoDescription {
        return
            try DeviceInfoDescription(
                name: FfiConverterString.read(from: &buf), 
                model: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DeviceInfoDescription, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.model, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceInfoDescription_lift(_ buf: RustBuffer) throws -> DeviceInfoDescription {
    return try FfiConverterTypeDeviceInfoDescription.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceInfoDescription_lower(_ value: DeviceInfoDescription) -> RustBuffer {
    return FfiConverterTypeDeviceInfoDescription.lower(value)
}


/**
 * A max 30 chars long string used for display purposes, e.g.
 * the name of an Account or Persona.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 * #[allow(clippy::upper_case_acronyms)]
 * type SUT = DisplayName;
 *
 * assert_eq!(SUT::MAX_LEN, 30);
 * assert_eq!("Satoshi".parse::<SUT>().unwrap().to_string(), "Satoshi");
 * ```
 *
 * Names with longer than 30 chars are trimmed.
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 * #[allow(clippy::upper_case_acronyms)]
 * type SUT = DisplayName;
 * assert_eq!("A very big name that is over than 30 characters long".parse::<SUT>().unwrap().to_string(), "A very big name that is over t");
 * ```

 */
public struct DisplayName {
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: String) {
        self.value = value
    }
}


extension DisplayName: Sendable {} 
extension DisplayName: Equatable, Hashable {
    public static func ==(lhs: DisplayName, rhs: DisplayName) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDisplayName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DisplayName {
        return
            try DisplayName(
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DisplayName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDisplayName_lift(_ buf: RustBuffer) throws -> DisplayName {
    return try FfiConverterTypeDisplayName.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDisplayName_lower(_ value: DisplayName) -> RustBuffer {
    return FfiConverterTypeDisplayName.lower(value)
}


/**
 * An Ed25519 public key used to verify cryptographic signatures (EdDSA signatures).
 */
public struct Ed25519PublicKey {
    fileprivate let secretMagic: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BagOfBytes) {
        self.secretMagic = secretMagic
    }
}


extension Ed25519PublicKey: Sendable {} 
extension Ed25519PublicKey: Equatable, Hashable {
    public static func ==(lhs: Ed25519PublicKey, rhs: Ed25519PublicKey) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEd25519PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519PublicKey {
        return
            try Ed25519PublicKey(
                secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Ed25519PublicKey, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEd25519PublicKey_lift(_ buf: RustBuffer) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEd25519PublicKey_lower(_ value: Ed25519PublicKey) -> RustBuffer {
    return FfiConverterTypeEd25519PublicKey.lower(value)
}


/**
 * Represents an ED25519 signature.
 */
public struct Ed25519Signature {
    public var bytes: Exactly64Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Exactly64Bytes) {
        self.bytes = bytes
    }
}


extension Ed25519Signature: Sendable {} 
extension Ed25519Signature: Equatable, Hashable {
    public static func ==(lhs: Ed25519Signature, rhs: Ed25519Signature) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEd25519Signature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519Signature {
        return
            try Ed25519Signature(
                bytes: FfiConverterTypeExactly64Bytes.read(from: &buf)
        )
    }

    public static func write(_ value: Ed25519Signature, into buf: inout [UInt8]) {
        FfiConverterTypeExactly64Bytes.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEd25519Signature_lift(_ buf: RustBuffer) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEd25519Signature_lower(_ value: Ed25519Signature) -> RustBuffer {
    return FfiConverterTypeEd25519Signature.lower(value)
}


/**
 * An email address.
 *
 * Current implementation does not validate the email address other than it
 * cannot be empty (in the future we might add some simple validation).
 */
public struct EmailAddress {
    public var email: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(email: String) {
        self.email = email
    }
}


extension EmailAddress: Sendable {} 
extension EmailAddress: Equatable, Hashable {
    public static func ==(lhs: EmailAddress, rhs: EmailAddress) -> Bool {
        if lhs.email != rhs.email {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(email)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEmailAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmailAddress {
        return
            try EmailAddress(
                email: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: EmailAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.email, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmailAddress_lift(_ buf: RustBuffer) throws -> EmailAddress {
    return try FfiConverterTypeEmailAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmailAddress_lower(_ value: EmailAddress) -> RustBuffer {
    return FfiConverterTypeEmailAddress.lower(value)
}


/**
 * This is the result of checking what entities are controlled by a given `FactorSource`.
 */
public struct EntitiesLinkedToFactorSource {
    /**
     * The integrity of the factor source.
     */
    public var integrity: FactorSourceIntegrity
    /**
     * The visible accounts linked to the factor source.
     */
    public var accounts: [Account]
    /**
     * The hidden accounts linked to the factor source.
     */
    public var hiddenAccounts: [Account]
    /**
     * The visible personas linked to the factor source.
     */
    public var personas: [Persona]
    /**
     * The hidden personas linked to the factor source.
     */
    public var hiddenPersonas: [Persona]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The integrity of the factor source.
         */integrity: FactorSourceIntegrity, 
        /**
         * The visible accounts linked to the factor source.
         */accounts: [Account], 
        /**
         * The hidden accounts linked to the factor source.
         */hiddenAccounts: [Account], 
        /**
         * The visible personas linked to the factor source.
         */personas: [Persona], 
        /**
         * The hidden personas linked to the factor source.
         */hiddenPersonas: [Persona]) {
        self.integrity = integrity
        self.accounts = accounts
        self.hiddenAccounts = hiddenAccounts
        self.personas = personas
        self.hiddenPersonas = hiddenPersonas
    }
}


extension EntitiesLinkedToFactorSource: Sendable {} 
extension EntitiesLinkedToFactorSource: Equatable, Hashable {
    public static func ==(lhs: EntitiesLinkedToFactorSource, rhs: EntitiesLinkedToFactorSource) -> Bool {
        if lhs.integrity != rhs.integrity {
            return false
        }
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.hiddenAccounts != rhs.hiddenAccounts {
            return false
        }
        if lhs.personas != rhs.personas {
            return false
        }
        if lhs.hiddenPersonas != rhs.hiddenPersonas {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(integrity)
        hasher.combine(accounts)
        hasher.combine(hiddenAccounts)
        hasher.combine(personas)
        hasher.combine(hiddenPersonas)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntitiesLinkedToFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntitiesLinkedToFactorSource {
        return
            try EntitiesLinkedToFactorSource(
                integrity: FfiConverterTypeFactorSourceIntegrity.read(from: &buf), 
                accounts: FfiConverterSequenceTypeAccount.read(from: &buf), 
                hiddenAccounts: FfiConverterSequenceTypeAccount.read(from: &buf), 
                personas: FfiConverterSequenceTypePersona.read(from: &buf), 
                hiddenPersonas: FfiConverterSequenceTypePersona.read(from: &buf)
        )
    }

    public static func write(_ value: EntitiesLinkedToFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIntegrity.write(value.integrity, into: &buf)
        FfiConverterSequenceTypeAccount.write(value.accounts, into: &buf)
        FfiConverterSequenceTypeAccount.write(value.hiddenAccounts, into: &buf)
        FfiConverterSequenceTypePersona.write(value.personas, into: &buf)
        FfiConverterSequenceTypePersona.write(value.hiddenPersonas, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntitiesLinkedToFactorSource_lift(_ buf: RustBuffer) throws -> EntitiesLinkedToFactorSource {
    return try FfiConverterTypeEntitiesLinkedToFactorSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntitiesLinkedToFactorSource_lower(_ value: EntitiesLinkedToFactorSource) -> RustBuffer {
    return FfiConverterTypeEntitiesLinkedToFactorSource.lower(value)
}


/**
 * This is the result of checking what entities are controlled by a given `SecurityStructure`.
 */
public struct EntitiesLinkedToSecurityStructure {
    /**
     * The metadata of the linked security structure.
     */
    public var metadata: SecurityStructureMetadata
    /**
     * The visible accounts linked to the security structure.
     */
    public var accounts: [Account]
    /**
     * The hidden accounts linked to the security structure.
     */
    public var hiddenAccounts: [Account]
    /**
     * The visible personas linked to the security structure.
     */
    public var personas: [Persona]
    /**
     * The hidden personas linked to the security structure.
     */
    public var hiddenPersonas: [Persona]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The metadata of the linked security structure.
         */metadata: SecurityStructureMetadata, 
        /**
         * The visible accounts linked to the security structure.
         */accounts: [Account], 
        /**
         * The hidden accounts linked to the security structure.
         */hiddenAccounts: [Account], 
        /**
         * The visible personas linked to the security structure.
         */personas: [Persona], 
        /**
         * The hidden personas linked to the security structure.
         */hiddenPersonas: [Persona]) {
        self.metadata = metadata
        self.accounts = accounts
        self.hiddenAccounts = hiddenAccounts
        self.personas = personas
        self.hiddenPersonas = hiddenPersonas
    }
}


extension EntitiesLinkedToSecurityStructure: Sendable {} 
extension EntitiesLinkedToSecurityStructure: Equatable, Hashable {
    public static func ==(lhs: EntitiesLinkedToSecurityStructure, rhs: EntitiesLinkedToSecurityStructure) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.hiddenAccounts != rhs.hiddenAccounts {
            return false
        }
        if lhs.personas != rhs.personas {
            return false
        }
        if lhs.hiddenPersonas != rhs.hiddenPersonas {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
        hasher.combine(accounts)
        hasher.combine(hiddenAccounts)
        hasher.combine(personas)
        hasher.combine(hiddenPersonas)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntitiesLinkedToSecurityStructure: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntitiesLinkedToSecurityStructure {
        return
            try EntitiesLinkedToSecurityStructure(
                metadata: FfiConverterTypeSecurityStructureMetadata.read(from: &buf), 
                accounts: FfiConverterSequenceTypeAccount.read(from: &buf), 
                hiddenAccounts: FfiConverterSequenceTypeAccount.read(from: &buf), 
                personas: FfiConverterSequenceTypePersona.read(from: &buf), 
                hiddenPersonas: FfiConverterSequenceTypePersona.read(from: &buf)
        )
    }

    public static func write(_ value: EntitiesLinkedToSecurityStructure, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureMetadata.write(value.metadata, into: &buf)
        FfiConverterSequenceTypeAccount.write(value.accounts, into: &buf)
        FfiConverterSequenceTypeAccount.write(value.hiddenAccounts, into: &buf)
        FfiConverterSequenceTypePersona.write(value.personas, into: &buf)
        FfiConverterSequenceTypePersona.write(value.hiddenPersonas, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntitiesLinkedToSecurityStructure_lift(_ buf: RustBuffer) throws -> EntitiesLinkedToSecurityStructure {
    return try FfiConverterTypeEntitiesLinkedToSecurityStructure.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntitiesLinkedToSecurityStructure_lower(_ value: EntitiesLinkedToSecurityStructure) -> RustBuffer {
    return FfiConverterTypeEntitiesLinkedToSecurityStructure.lower(value)
}


/**
 * The report that gathers the different actions performed on profile after sync completes.
 */
public struct EntitySyncOutcome {
    public var actionsPerformed: [EntitySyncActionPerformed]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(actionsPerformed: [EntitySyncActionPerformed]) {
        self.actionsPerformed = actionsPerformed
    }
}


extension EntitySyncOutcome: Sendable {} 
extension EntitySyncOutcome: Equatable, Hashable {
    public static func ==(lhs: EntitySyncOutcome, rhs: EntitySyncOutcome) -> Bool {
        if lhs.actionsPerformed != rhs.actionsPerformed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(actionsPerformed)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntitySyncOutcome: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntitySyncOutcome {
        return
            try EntitySyncOutcome(
                actionsPerformed: FfiConverterSequenceTypeEntitySyncActionPerformed.read(from: &buf)
        )
    }

    public static func write(_ value: EntitySyncOutcome, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeEntitySyncActionPerformed.write(value.actionsPerformed, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntitySyncOutcome_lift(_ buf: RustBuffer) throws -> EntitySyncOutcome {
    return try FfiConverterTypeEntitySyncOutcome.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntitySyncOutcome_lower(_ value: EntitySyncOutcome) -> RustBuffer {
    return FfiConverterTypeEntitySyncOutcome.lower(value)
}


public struct Entropy16Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Entropy16Bytes: Sendable {} 
extension Entropy16Bytes: Equatable, Hashable {
    public static func ==(lhs: Entropy16Bytes, rhs: Entropy16Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntropy16Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy16Bytes {
        return
            try Entropy16Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Entropy16Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntropy16Bytes_lift(_ buf: RustBuffer) throws -> Entropy16Bytes {
    return try FfiConverterTypeEntropy16Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntropy16Bytes_lower(_ value: Entropy16Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy16Bytes.lower(value)
}


public struct Entropy20Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Entropy20Bytes: Sendable {} 
extension Entropy20Bytes: Equatable, Hashable {
    public static func ==(lhs: Entropy20Bytes, rhs: Entropy20Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntropy20Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy20Bytes {
        return
            try Entropy20Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Entropy20Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntropy20Bytes_lift(_ buf: RustBuffer) throws -> Entropy20Bytes {
    return try FfiConverterTypeEntropy20Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntropy20Bytes_lower(_ value: Entropy20Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy20Bytes.lower(value)
}


public struct Entropy24Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Entropy24Bytes: Sendable {} 
extension Entropy24Bytes: Equatable, Hashable {
    public static func ==(lhs: Entropy24Bytes, rhs: Entropy24Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntropy24Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy24Bytes {
        return
            try Entropy24Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Entropy24Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntropy24Bytes_lift(_ buf: RustBuffer) throws -> Entropy24Bytes {
    return try FfiConverterTypeEntropy24Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntropy24Bytes_lower(_ value: Entropy24Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy24Bytes.lower(value)
}


public struct Entropy28Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Entropy28Bytes: Sendable {} 
extension Entropy28Bytes: Equatable, Hashable {
    public static func ==(lhs: Entropy28Bytes, rhs: Entropy28Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntropy28Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy28Bytes {
        return
            try Entropy28Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Entropy28Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntropy28Bytes_lift(_ buf: RustBuffer) throws -> Entropy28Bytes {
    return try FfiConverterTypeEntropy28Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntropy28Bytes_lower(_ value: Entropy28Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy28Bytes.lower(value)
}


public struct Entropy32Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Entropy32Bytes: Sendable {} 
extension Entropy32Bytes: Equatable, Hashable {
    public static func ==(lhs: Entropy32Bytes, rhs: Entropy32Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntropy32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy32Bytes {
        return
            try Entropy32Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Entropy32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntropy32Bytes_lift(_ buf: RustBuffer) throws -> Entropy32Bytes {
    return try FfiConverterTypeEntropy32Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntropy32Bytes_lower(_ value: Entropy32Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy32Bytes.lower(value)
}


/**
 * A notification containing a timestamped and unique `event`, host client
 * can subscribe to these notifications by using the EventBusDriver.
 */
public struct EventNotification {
    public var id: Uuid
    public var event: Event
    public var timestamp: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Uuid, event: Event, timestamp: Timestamp) {
        self.id = id
        self.event = event
        self.timestamp = timestamp
    }
}


extension EventNotification: Sendable {} 
extension EventNotification: Equatable, Hashable {
    public static func ==(lhs: EventNotification, rhs: EventNotification) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.event != rhs.event {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(event)
        hasher.combine(timestamp)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventNotification: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventNotification {
        return
            try EventNotification(
                id: FfiConverterTypeUuid.read(from: &buf), 
                event: FfiConverterTypeEvent.read(from: &buf), 
                timestamp: FfiConverterTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: EventNotification, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeEvent.write(value.event, into: &buf)
        FfiConverterTypeTimestamp.write(value.timestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventNotification_lift(_ buf: RustBuffer) throws -> EventNotification {
    return try FfiConverterTypeEventNotification.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventNotification_lower(_ value: EventNotification) -> RustBuffer {
    return FfiConverterTypeEventNotification.lower(value)
}


/**
 * 12 bytes, used by AES encryption, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly12Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Exactly12Bytes: Sendable {} 
extension Exactly12Bytes: Equatable, Hashable {
    public static func ==(lhs: Exactly12Bytes, rhs: Exactly12Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExactly12Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly12Bytes {
        return
            try Exactly12Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Exactly12Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly12Bytes_lift(_ buf: RustBuffer) throws -> Exactly12Bytes {
    return try FfiConverterTypeExactly12Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly12Bytes_lower(_ value: Exactly12Bytes) -> RustBuffer {
    return FfiConverterTypeExactly12Bytes.lower(value)
}


/**
 * 29 bytes, typically used as PublicKeyHash, or otherwise NodeId payload,
 * implementation wise those bytes are stored inside a `BagOfBytes`
 * (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly29Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Exactly29Bytes: Sendable {} 
extension Exactly29Bytes: Equatable, Hashable {
    public static func ==(lhs: Exactly29Bytes, rhs: Exactly29Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExactly29Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly29Bytes {
        return
            try Exactly29Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Exactly29Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly29Bytes_lift(_ buf: RustBuffer) throws -> Exactly29Bytes {
    return try FfiConverterTypeExactly29Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly29Bytes_lower(_ value: Exactly29Bytes) -> RustBuffer {
    return FfiConverterTypeExactly29Bytes.lower(value)
}


/**
 * 32 bytes, most commonly used fixed length bytes, used by PrivateKeys,
 * Ed25519PublicKey, and BIP39 entropy, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly32Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Exactly32Bytes: Sendable {} 
extension Exactly32Bytes: Equatable, Hashable {
    public static func ==(lhs: Exactly32Bytes, rhs: Exactly32Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExactly32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly32Bytes {
        return
            try Exactly32Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Exactly32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly32Bytes_lift(_ buf: RustBuffer) throws -> Exactly32Bytes {
    return try FfiConverterTypeExactly32Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly32Bytes_lower(_ value: Exactly32Bytes) -> RustBuffer {
    return FfiConverterTypeExactly32Bytes.lower(value)
}


/**
 * 33 bytes, used by Secp256k1PublicKeys, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly33Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Exactly33Bytes: Sendable {} 
extension Exactly33Bytes: Equatable, Hashable {
    public static func ==(lhs: Exactly33Bytes, rhs: Exactly33Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExactly33Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly33Bytes {
        return
            try Exactly33Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Exactly33Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly33Bytes_lift(_ buf: RustBuffer) throws -> Exactly33Bytes {
    return try FfiConverterTypeExactly33Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly33Bytes_lower(_ value: Exactly33Bytes) -> RustBuffer {
    return FfiConverterTypeExactly33Bytes.lower(value)
}


/**
 * 60 bytes, used as encrypted mnemonic for security questions factor
 * source. 32 bytes mnemonic when encrypted results in exactly this length.
 */
public struct Exactly60Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Exactly60Bytes: Sendable {} 
extension Exactly60Bytes: Equatable, Hashable {
    public static func ==(lhs: Exactly60Bytes, rhs: Exactly60Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExactly60Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly60Bytes {
        return
            try Exactly60Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Exactly60Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly60Bytes_lift(_ buf: RustBuffer) throws -> Exactly60Bytes {
    return try FfiConverterTypeExactly60Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly60Bytes_lower(_ value: Exactly60Bytes) -> RustBuffer {
    return FfiConverterTypeExactly60Bytes.lower(value)
}


/**
 * 64 bytes, used by Ed25519Signatures, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly64Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Exactly64Bytes: Sendable {} 
extension Exactly64Bytes: Equatable, Hashable {
    public static func ==(lhs: Exactly64Bytes, rhs: Exactly64Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExactly64Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly64Bytes {
        return
            try Exactly64Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Exactly64Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly64Bytes_lift(_ buf: RustBuffer) throws -> Exactly64Bytes {
    return try FfiConverterTypeExactly64Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly64Bytes_lower(_ value: Exactly64Bytes) -> RustBuffer {
    return FfiConverterTypeExactly64Bytes.lower(value)
}


/**
 * 65 bytes, used by Secp256k1Signatures, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly65Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension Exactly65Bytes: Sendable {} 
extension Exactly65Bytes: Equatable, Hashable {
    public static func ==(lhs: Exactly65Bytes, rhs: Exactly65Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExactly65Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly65Bytes {
        return
            try Exactly65Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Exactly65Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly65Bytes_lift(_ buf: RustBuffer) throws -> Exactly65Bytes {
    return try FfiConverterTypeExactly65Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExactly65Bytes_lower(_ value: Exactly65Bytes) -> RustBuffer {
    return FfiConverterTypeExactly65Bytes.lower(value)
}


/**
 * A summary of the execution of the manifest and the information that helps
 * wallets present the contents of a transaction.
 */
public struct ExecutionSummary {
    /**
     * Per account, a list of all token balances that has been withdrawn from that account.
     */
    public var withdrawals: [AccountAddress: [ResourceIndicator]]
    /**
     * Per account, a list of all token balances that has been deposited into that account.
     */
    public var deposits: [AccountAddress: [ResourceIndicator]]
    /**
     * Addresses of accounts encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the accounts of all those addresses, which might be multiple
     * signatures per Account, if MFA has been setup.
     */
    public var addressesOfAccountsRequiringAuth: [AccountAddress]
    /**
     * Addresses of identities (Personas) encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the identities of all those addresses, which might be multiple
     * signatures per Persona, if MFA has been setup.
     */
    public var addressesOfIdentitiesRequiringAuth: [IdentityAddress]
    /**
     * Information on the global entities created in the transaction.
     */
    public var newEntities: NewEntities
    /**
     * The manifest classification if any. None means that the manifest is non-conforming.
     */
    public var detailedClassification: DetailedManifestClass?
    /**
     * List of newly created Non-Fungibles during this transaction.
     */
    public var newlyCreatedNonFungibles: [NonFungibleGlobalId]
    /**
     * The set of instructions encountered in the manifest that are reserved
     * and can only be included in the manifest by the wallet itself.
     */
    public var reservedInstructions: [ReservedInstruction]
    /**
     * The list of the resources of proofs that were presented in the manifest.
     */
    public var presentedProofs: [ResourceSpecifier]
    /**
     * The set of all the encountered `ManifestEncounteredComponentAddress`es` in the manifest. This is
     * to be primarily used for the "using dApps" section of the wallet's tx
     * review screen.
     */
    public var encounteredAddresses: [ManifestEncounteredComponentAddress]
    /**
     * Information on how much fees were contingent and how much were not.
     */
    public var feeLocks: FeeLocks
    /**
     * Detailed information on the amount of cost units consumed.
     */
    public var feeSummary: FeeSummary

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Per account, a list of all token balances that has been withdrawn from that account.
         */withdrawals: [AccountAddress: [ResourceIndicator]], 
        /**
         * Per account, a list of all token balances that has been deposited into that account.
         */deposits: [AccountAddress: [ResourceIndicator]], 
        /**
         * Addresses of accounts encountered in the manifest where privileged
         * methods were called. The wallets will need to collect signatures
         * of the accounts of all those addresses, which might be multiple
         * signatures per Account, if MFA has been setup.
         */addressesOfAccountsRequiringAuth: [AccountAddress], 
        /**
         * Addresses of identities (Personas) encountered in the manifest where privileged
         * methods were called. The wallets will need to collect signatures
         * of the identities of all those addresses, which might be multiple
         * signatures per Persona, if MFA has been setup.
         */addressesOfIdentitiesRequiringAuth: [IdentityAddress], 
        /**
         * Information on the global entities created in the transaction.
         */newEntities: NewEntities, 
        /**
         * The manifest classification if any. None means that the manifest is non-conforming.
         */detailedClassification: DetailedManifestClass?, 
        /**
         * List of newly created Non-Fungibles during this transaction.
         */newlyCreatedNonFungibles: [NonFungibleGlobalId], 
        /**
         * The set of instructions encountered in the manifest that are reserved
         * and can only be included in the manifest by the wallet itself.
         */reservedInstructions: [ReservedInstruction], 
        /**
         * The list of the resources of proofs that were presented in the manifest.
         */presentedProofs: [ResourceSpecifier], 
        /**
         * The set of all the encountered `ManifestEncounteredComponentAddress`es` in the manifest. This is
         * to be primarily used for the "using dApps" section of the wallet's tx
         * review screen.
         */encounteredAddresses: [ManifestEncounteredComponentAddress], 
        /**
         * Information on how much fees were contingent and how much were not.
         */feeLocks: FeeLocks, 
        /**
         * Detailed information on the amount of cost units consumed.
         */feeSummary: FeeSummary) {
        self.withdrawals = withdrawals
        self.deposits = deposits
        self.addressesOfAccountsRequiringAuth = addressesOfAccountsRequiringAuth
        self.addressesOfIdentitiesRequiringAuth = addressesOfIdentitiesRequiringAuth
        self.newEntities = newEntities
        self.detailedClassification = detailedClassification
        self.newlyCreatedNonFungibles = newlyCreatedNonFungibles
        self.reservedInstructions = reservedInstructions
        self.presentedProofs = presentedProofs
        self.encounteredAddresses = encounteredAddresses
        self.feeLocks = feeLocks
        self.feeSummary = feeSummary
    }
}


extension ExecutionSummary: Sendable {} 
extension ExecutionSummary: Equatable, Hashable {
    public static func ==(lhs: ExecutionSummary, rhs: ExecutionSummary) -> Bool {
        if lhs.withdrawals != rhs.withdrawals {
            return false
        }
        if lhs.deposits != rhs.deposits {
            return false
        }
        if lhs.addressesOfAccountsRequiringAuth != rhs.addressesOfAccountsRequiringAuth {
            return false
        }
        if lhs.addressesOfIdentitiesRequiringAuth != rhs.addressesOfIdentitiesRequiringAuth {
            return false
        }
        if lhs.newEntities != rhs.newEntities {
            return false
        }
        if lhs.detailedClassification != rhs.detailedClassification {
            return false
        }
        if lhs.newlyCreatedNonFungibles != rhs.newlyCreatedNonFungibles {
            return false
        }
        if lhs.reservedInstructions != rhs.reservedInstructions {
            return false
        }
        if lhs.presentedProofs != rhs.presentedProofs {
            return false
        }
        if lhs.encounteredAddresses != rhs.encounteredAddresses {
            return false
        }
        if lhs.feeLocks != rhs.feeLocks {
            return false
        }
        if lhs.feeSummary != rhs.feeSummary {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(withdrawals)
        hasher.combine(deposits)
        hasher.combine(addressesOfAccountsRequiringAuth)
        hasher.combine(addressesOfIdentitiesRequiringAuth)
        hasher.combine(newEntities)
        hasher.combine(detailedClassification)
        hasher.combine(newlyCreatedNonFungibles)
        hasher.combine(reservedInstructions)
        hasher.combine(presentedProofs)
        hasher.combine(encounteredAddresses)
        hasher.combine(feeLocks)
        hasher.combine(feeSummary)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeExecutionSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExecutionSummary {
        return
            try ExecutionSummary(
                withdrawals: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.read(from: &buf), 
                deposits: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.read(from: &buf), 
                addressesOfAccountsRequiringAuth: FfiConverterSequenceTypeAccountAddress.read(from: &buf), 
                addressesOfIdentitiesRequiringAuth: FfiConverterSequenceTypeIdentityAddress.read(from: &buf), 
                newEntities: FfiConverterTypeNewEntities.read(from: &buf), 
                detailedClassification: FfiConverterOptionTypeDetailedManifestClass.read(from: &buf), 
                newlyCreatedNonFungibles: FfiConverterSequenceTypeNonFungibleGlobalId.read(from: &buf), 
                reservedInstructions: FfiConverterSequenceTypeReservedInstruction.read(from: &buf), 
                presentedProofs: FfiConverterSequenceTypeResourceSpecifier.read(from: &buf), 
                encounteredAddresses: FfiConverterSequenceTypeManifestEncounteredComponentAddress.read(from: &buf), 
                feeLocks: FfiConverterTypeFeeLocks.read(from: &buf), 
                feeSummary: FfiConverterTypeFeeSummary.read(from: &buf)
        )
    }

    public static func write(_ value: ExecutionSummary, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.write(value.withdrawals, into: &buf)
        FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.write(value.deposits, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsRequiringAuth, into: &buf)
        FfiConverterSequenceTypeIdentityAddress.write(value.addressesOfIdentitiesRequiringAuth, into: &buf)
        FfiConverterTypeNewEntities.write(value.newEntities, into: &buf)
        FfiConverterOptionTypeDetailedManifestClass.write(value.detailedClassification, into: &buf)
        FfiConverterSequenceTypeNonFungibleGlobalId.write(value.newlyCreatedNonFungibles, into: &buf)
        FfiConverterSequenceTypeReservedInstruction.write(value.reservedInstructions, into: &buf)
        FfiConverterSequenceTypeResourceSpecifier.write(value.presentedProofs, into: &buf)
        FfiConverterSequenceTypeManifestEncounteredComponentAddress.write(value.encounteredAddresses, into: &buf)
        FfiConverterTypeFeeLocks.write(value.feeLocks, into: &buf)
        FfiConverterTypeFeeSummary.write(value.feeSummary, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExecutionSummary_lift(_ buf: RustBuffer) throws -> ExecutionSummary {
    return try FfiConverterTypeExecutionSummary.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeExecutionSummary_lower(_ value: ExecutionSummary) -> RustBuffer {
    return FfiConverterTypeExecutionSummary.lower(value)
}


public struct FactorInstance {
    /**
     * The ID of the `FactorSource` that was used to produce this
     * factor instance. We will lookup the `FactorSource` in the
     * `Profile` and can present user with instruction to re-access
     * this factor source in order control the `badge`.
     */
    public var factorSourceId: FactorSourceId
    /**
     * Either a "physical" badge (NFT) or some source for recreation of a producer
     * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
     * is derived which produces virtual badges (signatures).
     */
    public var badge: FactorInstanceBadge

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the `FactorSource` that was used to produce this
         * factor instance. We will lookup the `FactorSource` in the
         * `Profile` and can present user with instruction to re-access
         * this factor source in order control the `badge`.
         */factorSourceId: FactorSourceId, 
        /**
         * Either a "physical" badge (NFT) or some source for recreation of a producer
         * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
         * is derived which produces virtual badges (signatures).
         */badge: FactorInstanceBadge) {
        self.factorSourceId = factorSourceId
        self.badge = badge
    }
}


extension FactorInstance: Sendable {} 
extension FactorInstance: Equatable, Hashable {
    public static func ==(lhs: FactorInstance, rhs: FactorInstance) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.badge != rhs.badge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(badge)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorInstance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstance {
        return
            try FactorInstance(
                factorSourceId: FfiConverterTypeFactorSourceID.read(from: &buf), 
                badge: FfiConverterTypeFactorInstanceBadge.read(from: &buf)
        )
    }

    public static func write(_ value: FactorInstance, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceID.write(value.factorSourceId, into: &buf)
        FfiConverterTypeFactorInstanceBadge.write(value.badge, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorInstance_lift(_ buf: RustBuffer) throws -> FactorInstance {
    return try FfiConverterTypeFactorInstance.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorInstance_lower(_ value: FactorInstance) -> RustBuffer {
    return FfiConverterTypeFactorInstance.lower(value)
}


public struct FactorInstanceForDebugPurposes {
    public var derivationPathFull: String
    public var indexAgnosticDerivationPath: String
    public var publicKeyHex: String
    public var factorSourceId: String
    public var derivationEntityIndex: UInt32
    public var factorSourceKind: FactorSourceKind

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(derivationPathFull: String, indexAgnosticDerivationPath: String, publicKeyHex: String, factorSourceId: String, derivationEntityIndex: UInt32, factorSourceKind: FactorSourceKind) {
        self.derivationPathFull = derivationPathFull
        self.indexAgnosticDerivationPath = indexAgnosticDerivationPath
        self.publicKeyHex = publicKeyHex
        self.factorSourceId = factorSourceId
        self.derivationEntityIndex = derivationEntityIndex
        self.factorSourceKind = factorSourceKind
    }
}


extension FactorInstanceForDebugPurposes: Sendable {} 
extension FactorInstanceForDebugPurposes: Equatable, Hashable {
    public static func ==(lhs: FactorInstanceForDebugPurposes, rhs: FactorInstanceForDebugPurposes) -> Bool {
        if lhs.derivationPathFull != rhs.derivationPathFull {
            return false
        }
        if lhs.indexAgnosticDerivationPath != rhs.indexAgnosticDerivationPath {
            return false
        }
        if lhs.publicKeyHex != rhs.publicKeyHex {
            return false
        }
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.derivationEntityIndex != rhs.derivationEntityIndex {
            return false
        }
        if lhs.factorSourceKind != rhs.factorSourceKind {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(derivationPathFull)
        hasher.combine(indexAgnosticDerivationPath)
        hasher.combine(publicKeyHex)
        hasher.combine(factorSourceId)
        hasher.combine(derivationEntityIndex)
        hasher.combine(factorSourceKind)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorInstanceForDebugPurposes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceForDebugPurposes {
        return
            try FactorInstanceForDebugPurposes(
                derivationPathFull: FfiConverterString.read(from: &buf), 
                indexAgnosticDerivationPath: FfiConverterString.read(from: &buf), 
                publicKeyHex: FfiConverterString.read(from: &buf), 
                factorSourceId: FfiConverterString.read(from: &buf), 
                derivationEntityIndex: FfiConverterUInt32.read(from: &buf), 
                factorSourceKind: FfiConverterTypeFactorSourceKind.read(from: &buf)
        )
    }

    public static func write(_ value: FactorInstanceForDebugPurposes, into buf: inout [UInt8]) {
        FfiConverterString.write(value.derivationPathFull, into: &buf)
        FfiConverterString.write(value.indexAgnosticDerivationPath, into: &buf)
        FfiConverterString.write(value.publicKeyHex, into: &buf)
        FfiConverterString.write(value.factorSourceId, into: &buf)
        FfiConverterUInt32.write(value.derivationEntityIndex, into: &buf)
        FfiConverterTypeFactorSourceKind.write(value.factorSourceKind, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorInstanceForDebugPurposes_lift(_ buf: RustBuffer) throws -> FactorInstanceForDebugPurposes {
    return try FfiConverterTypeFactorInstanceForDebugPurposes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorInstanceForDebugPurposes_lower(_ value: FactorInstanceForDebugPurposes) -> RustBuffer {
    return FfiConverterTypeFactorInstanceForDebugPurposes.lower(value)
}


/**
 * Common properties shared between FactorSources of different kinds, describing
 * its state, when added, and supported cryptographic parameters.
 */
public struct FactorSourceCommon {
    /**
     * Cryptographic parameters a certain FactorSource supports, e.g. Elliptic Curves.
     *
     * Since Radix Wallet App version 1.3.0, it is possible to add crypto
     * parameters to a FactorSource, e.g. when a user with a DeviceFactorSource
     * with babylon crypto parameters, lets call it `B`, with mnemonic `M` adds
     * `M` again but as an "Olympia" factor source, then the olympia crypto
     * parameters are added to `B`.
     */
    public var cryptoParameters: FactorSourceCryptoParameters
    /**
     * When this factor source for originally added by the user.
     */
    public var addedOn: Timestamp
    /**
     * Date of last usage of this factor source
     *
     * This is the only mutable property, it is mutable
     * since we will update it every time this FactorSource
     * is used.
     */
    public var lastUsedOn: Timestamp
    /**
     * Flags which describe a certain state a FactorSource might be in, e.g. `Main` (BDFS).
     */
    public var flags: [FactorSourceFlag]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Cryptographic parameters a certain FactorSource supports, e.g. Elliptic Curves.
         *
         * Since Radix Wallet App version 1.3.0, it is possible to add crypto
         * parameters to a FactorSource, e.g. when a user with a DeviceFactorSource
         * with babylon crypto parameters, lets call it `B`, with mnemonic `M` adds
         * `M` again but as an "Olympia" factor source, then the olympia crypto
         * parameters are added to `B`.
         */cryptoParameters: FactorSourceCryptoParameters, 
        /**
         * When this factor source for originally added by the user.
         */addedOn: Timestamp, 
        /**
         * Date of last usage of this factor source
         *
         * This is the only mutable property, it is mutable
         * since we will update it every time this FactorSource
         * is used.
         */lastUsedOn: Timestamp, 
        /**
         * Flags which describe a certain state a FactorSource might be in, e.g. `Main` (BDFS).
         */flags: [FactorSourceFlag]) {
        self.cryptoParameters = cryptoParameters
        self.addedOn = addedOn
        self.lastUsedOn = lastUsedOn
        self.flags = flags
    }
}


extension FactorSourceCommon: Sendable {} 
extension FactorSourceCommon: Equatable, Hashable {
    public static func ==(lhs: FactorSourceCommon, rhs: FactorSourceCommon) -> Bool {
        if lhs.cryptoParameters != rhs.cryptoParameters {
            return false
        }
        if lhs.addedOn != rhs.addedOn {
            return false
        }
        if lhs.lastUsedOn != rhs.lastUsedOn {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cryptoParameters)
        hasher.combine(addedOn)
        hasher.combine(lastUsedOn)
        hasher.combine(flags)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorSourceCommon: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceCommon {
        return
            try FactorSourceCommon(
                cryptoParameters: FfiConverterTypeFactorSourceCryptoParameters.read(from: &buf), 
                addedOn: FfiConverterTypeTimestamp.read(from: &buf), 
                lastUsedOn: FfiConverterTypeTimestamp.read(from: &buf), 
                flags: FfiConverterSequenceTypeFactorSourceFlag.read(from: &buf)
        )
    }

    public static func write(_ value: FactorSourceCommon, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceCryptoParameters.write(value.cryptoParameters, into: &buf)
        FfiConverterTypeTimestamp.write(value.addedOn, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastUsedOn, into: &buf)
        FfiConverterSequenceTypeFactorSourceFlag.write(value.flags, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceCommon_lift(_ buf: RustBuffer) throws -> FactorSourceCommon {
    return try FfiConverterTypeFactorSourceCommon.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceCommon_lower(_ value: FactorSourceCommon) -> RustBuffer {
    return FfiConverterTypeFactorSourceCommon.lower(value)
}


/**
 * Cryptographic parameters a certain FactorSource supports, e.g. which Elliptic Curves
 * it supports and which Hierarchical Deterministic (HD) derivations schemes it supports,
 * if any.
 */
public struct FactorSourceCryptoParameters {
    /**
     * Describes with which Elliptic Curves a Factor Source can be used, e.g. a
     * "Babylon" `DeviceFactorSource` is not capable of deriving keys on the curve
     * `secp256k1` - only Olympia imported FactorSources can do that.
     *
     * Either `[curve25519]` or `[secp256k1, curve25519]`
     *
     * Must not be empty.
     */
    public var supportedCurves: [Slip10Curve]
    /**
     * If not empty: Describes which kind of Hierarchical Deterministic (HD)
     * derivations a FactorSource is capable of doing - if empty: the
     * FactorSource does not support HD derivation.
     *
     * Either BIP44 or CAP26 (SLIP10)
     */
    public var supportedDerivationPathSchemes: [DerivationPathScheme]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Describes with which Elliptic Curves a Factor Source can be used, e.g. a
         * "Babylon" `DeviceFactorSource` is not capable of deriving keys on the curve
         * `secp256k1` - only Olympia imported FactorSources can do that.
         *
         * Either `[curve25519]` or `[secp256k1, curve25519]`
         *
         * Must not be empty.
         */supportedCurves: [Slip10Curve], 
        /**
         * If not empty: Describes which kind of Hierarchical Deterministic (HD)
         * derivations a FactorSource is capable of doing - if empty: the
         * FactorSource does not support HD derivation.
         *
         * Either BIP44 or CAP26 (SLIP10)
         */supportedDerivationPathSchemes: [DerivationPathScheme]) {
        self.supportedCurves = supportedCurves
        self.supportedDerivationPathSchemes = supportedDerivationPathSchemes
    }
}


extension FactorSourceCryptoParameters: Sendable {} 
extension FactorSourceCryptoParameters: Equatable, Hashable {
    public static func ==(lhs: FactorSourceCryptoParameters, rhs: FactorSourceCryptoParameters) -> Bool {
        if lhs.supportedCurves != rhs.supportedCurves {
            return false
        }
        if lhs.supportedDerivationPathSchemes != rhs.supportedDerivationPathSchemes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(supportedCurves)
        hasher.combine(supportedDerivationPathSchemes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorSourceCryptoParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceCryptoParameters {
        return
            try FactorSourceCryptoParameters(
                supportedCurves: FfiConverterSequenceTypeSLIP10Curve.read(from: &buf), 
                supportedDerivationPathSchemes: FfiConverterSequenceTypeDerivationPathScheme.read(from: &buf)
        )
    }

    public static func write(_ value: FactorSourceCryptoParameters, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeSLIP10Curve.write(value.supportedCurves, into: &buf)
        FfiConverterSequenceTypeDerivationPathScheme.write(value.supportedDerivationPathSchemes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceCryptoParameters_lift(_ buf: RustBuffer) throws -> FactorSourceCryptoParameters {
    return try FfiConverterTypeFactorSourceCryptoParameters.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceCryptoParameters_lower(_ value: FactorSourceCryptoParameters) -> RustBuffer {
    return FfiConverterTypeFactorSourceCryptoParameters.lower(value)
}


/**
 * FactorSourceID from an AccountAddress, typically used by `trustedContact` FactorSource.
 */
public struct FactorSourceIdFromAddress {
    /**
     * The kind of the FactorSource this ID refers to, typically `trustedContact`.
     */
    public var kind: FactorSourceKind
    /**
     * An account address which the FactorSource this ID refers uses/needs.
     */
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The kind of the FactorSource this ID refers to, typically `trustedContact`.
         */kind: FactorSourceKind, 
        /**
         * An account address which the FactorSource this ID refers uses/needs.
         */body: String) {
        self.kind = kind
        self.body = body
    }
}


extension FactorSourceIdFromAddress: Sendable {} 
extension FactorSourceIdFromAddress: Equatable, Hashable {
    public static func ==(lhs: FactorSourceIdFromAddress, rhs: FactorSourceIdFromAddress) -> Bool {
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kind)
        hasher.combine(body)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorSourceIDFromAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIdFromAddress {
        return
            try FactorSourceIdFromAddress(
                kind: FfiConverterTypeFactorSourceKind.read(from: &buf), 
                body: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FactorSourceIdFromAddress, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.kind, into: &buf)
        FfiConverterString.write(value.body, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceIDFromAddress_lift(_ buf: RustBuffer) throws -> FactorSourceIdFromAddress {
    return try FfiConverterTypeFactorSourceIDFromAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceIDFromAddress_lower(_ value: FactorSourceIdFromAddress) -> RustBuffer {
    return FfiConverterTypeFactorSourceIDFromAddress.lower(value)
}


/**
 * FactorSourceID from the blake2b hash of the special HD public key derived at `CAP26::GetID`,
 * for a certain `FactorSourceKind`
 */
public struct FactorSourceIdFromHash {
    /**
     * The kind of the FactorSource this ID refers to, typically `device` or `ledger`.
     */
    public var kind: FactorSourceKind
    /**
     * The blake2b hash of the special HD public key derived at `CAP26::GetID`.
     */
    public var body: Exactly32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The kind of the FactorSource this ID refers to, typically `device` or `ledger`.
         */kind: FactorSourceKind, 
        /**
         * The blake2b hash of the special HD public key derived at `CAP26::GetID`.
         */body: Exactly32Bytes) {
        self.kind = kind
        self.body = body
    }
}


extension FactorSourceIdFromHash: Sendable {} 
extension FactorSourceIdFromHash: Equatable, Hashable {
    public static func ==(lhs: FactorSourceIdFromHash, rhs: FactorSourceIdFromHash) -> Bool {
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kind)
        hasher.combine(body)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorSourceIDFromHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIdFromHash {
        return
            try FactorSourceIdFromHash(
                kind: FfiConverterTypeFactorSourceKind.read(from: &buf), 
                body: FfiConverterTypeExactly32Bytes.read(from: &buf)
        )
    }

    public static func write(_ value: FactorSourceIdFromHash, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.kind, into: &buf)
        FfiConverterTypeExactly32Bytes.write(value.body, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceIDFromHash_lift(_ buf: RustBuffer) throws -> FactorSourceIdFromHash {
    return try FfiConverterTypeFactorSourceIDFromHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceIDFromHash_lower(_ value: FactorSourceIdFromHash) -> RustBuffer {
    return FfiConverterTypeFactorSourceIDFromHash.lower(value)
}


/**
 * The "validation result" of a `FactorSourceID` in a `Role`, if
 * it we were to add it to a role list.
 */
public struct FactorSourceValidationStatus {
    public var role: RoleKind
    public var factorSourceId: FactorSourceId
    public var reasonIfInvalid: FactorSourceValidationStatusReasonIfInvalid?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(role: RoleKind, factorSourceId: FactorSourceId, reasonIfInvalid: FactorSourceValidationStatusReasonIfInvalid?) {
        self.role = role
        self.factorSourceId = factorSourceId
        self.reasonIfInvalid = reasonIfInvalid
    }
}


extension FactorSourceValidationStatus: Sendable {} 
extension FactorSourceValidationStatus: Equatable, Hashable {
    public static func ==(lhs: FactorSourceValidationStatus, rhs: FactorSourceValidationStatus) -> Bool {
        if lhs.role != rhs.role {
            return false
        }
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.reasonIfInvalid != rhs.reasonIfInvalid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(role)
        hasher.combine(factorSourceId)
        hasher.combine(reasonIfInvalid)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorSourceValidationStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceValidationStatus {
        return
            try FactorSourceValidationStatus(
                role: FfiConverterTypeRoleKind.read(from: &buf), 
                factorSourceId: FfiConverterTypeFactorSourceID.read(from: &buf), 
                reasonIfInvalid: FfiConverterOptionTypeFactorSourceValidationStatusReasonIfInvalid.read(from: &buf)
        )
    }

    public static func write(_ value: FactorSourceValidationStatus, into buf: inout [UInt8]) {
        FfiConverterTypeRoleKind.write(value.role, into: &buf)
        FfiConverterTypeFactorSourceID.write(value.factorSourceId, into: &buf)
        FfiConverterOptionTypeFactorSourceValidationStatusReasonIfInvalid.write(value.reasonIfInvalid, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceValidationStatus_lift(_ buf: RustBuffer) throws -> FactorSourceValidationStatus {
    return try FfiConverterTypeFactorSourceValidationStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceValidationStatus_lower(_ value: FactorSourceValidationStatus) -> RustBuffer {
    return FfiConverterTypeFactorSourceValidationStatus.lower(value)
}


/**
 * Information on how much fees were contingent and how much were not.
 */
public struct FeeLocks {
    public var lock: Decimal192
    public var contingentLock: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lock: Decimal192, contingentLock: Decimal192) {
        self.lock = lock
        self.contingentLock = contingentLock
    }
}


extension FeeLocks: Sendable {} 
extension FeeLocks: Equatable, Hashable {
    public static func ==(lhs: FeeLocks, rhs: FeeLocks) -> Bool {
        if lhs.lock != rhs.lock {
            return false
        }
        if lhs.contingentLock != rhs.contingentLock {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lock)
        hasher.combine(contingentLock)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeLocks: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeLocks {
        return
            try FeeLocks(
                lock: FfiConverterTypeDecimal192.read(from: &buf), 
                contingentLock: FfiConverterTypeDecimal192.read(from: &buf)
        )
    }

    public static func write(_ value: FeeLocks, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.lock, into: &buf)
        FfiConverterTypeDecimal192.write(value.contingentLock, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeLocks_lift(_ buf: RustBuffer) throws -> FeeLocks {
    return try FfiConverterTypeFeeLocks.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeLocks_lower(_ value: FeeLocks) -> RustBuffer {
    return FfiConverterTypeFeeLocks.lower(value)
}


/**
 * Detailed information on the amount of cost units consumed.
 */
public struct FeeSummary {
    public var executionCost: Decimal192
    public var finalizationCost: Decimal192
    public var royaltyCost: Decimal192
    public var storageExpansionCost: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(executionCost: Decimal192, finalizationCost: Decimal192, royaltyCost: Decimal192, storageExpansionCost: Decimal192) {
        self.executionCost = executionCost
        self.finalizationCost = finalizationCost
        self.royaltyCost = royaltyCost
        self.storageExpansionCost = storageExpansionCost
    }
}


extension FeeSummary: Sendable {} 
extension FeeSummary: Equatable, Hashable {
    public static func ==(lhs: FeeSummary, rhs: FeeSummary) -> Bool {
        if lhs.executionCost != rhs.executionCost {
            return false
        }
        if lhs.finalizationCost != rhs.finalizationCost {
            return false
        }
        if lhs.royaltyCost != rhs.royaltyCost {
            return false
        }
        if lhs.storageExpansionCost != rhs.storageExpansionCost {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(executionCost)
        hasher.combine(finalizationCost)
        hasher.combine(royaltyCost)
        hasher.combine(storageExpansionCost)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFeeSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSummary {
        return
            try FeeSummary(
                executionCost: FfiConverterTypeDecimal192.read(from: &buf), 
                finalizationCost: FfiConverterTypeDecimal192.read(from: &buf), 
                royaltyCost: FfiConverterTypeDecimal192.read(from: &buf), 
                storageExpansionCost: FfiConverterTypeDecimal192.read(from: &buf)
        )
    }

    public static func write(_ value: FeeSummary, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.executionCost, into: &buf)
        FfiConverterTypeDecimal192.write(value.finalizationCost, into: &buf)
        FfiConverterTypeDecimal192.write(value.royaltyCost, into: &buf)
        FfiConverterTypeDecimal192.write(value.storageExpansionCost, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeSummary_lift(_ buf: RustBuffer) throws -> FeeSummary {
    return try FfiConverterTypeFeeSummary.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFeeSummary_lower(_ value: FeeSummary) -> RustBuffer {
    return FfiConverterTypeFeeSummary.lower(value)
}


/**
 * A gateway to some Radix Network, which is a high level REST API which clients (wallets) can
 * consume in order to query asset balances and submit transactions.
 */
public struct Gateway {
    /**
     * The Radix network the API is a Gateway to.
     */
    public var network: NetworkDefinition
    /**
     * The URL to the gateways API endpoint
     */
    public var url: Url

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The Radix network the API is a Gateway to.
         */network: NetworkDefinition, 
        /**
         * The URL to the gateways API endpoint
         */url: Url) {
        self.network = network
        self.url = url
    }
}


extension Gateway: Sendable {} 
extension Gateway: Equatable, Hashable {
    public static func ==(lhs: Gateway, rhs: Gateway) -> Bool {
        if lhs.network != rhs.network {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(network)
        hasher.combine(url)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGateway: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Gateway {
        return
            try Gateway(
                network: FfiConverterTypeNetworkDefinition.read(from: &buf), 
                url: FfiConverterTypeUrl.read(from: &buf)
        )
    }

    public static func write(_ value: Gateway, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkDefinition.write(value.network, into: &buf)
        FfiConverterTypeUrl.write(value.url, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGateway_lift(_ buf: RustBuffer) throws -> Gateway {
    return try FfiConverterTypeGateway.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGateway_lower(_ value: Gateway) -> RustBuffer {
    return FfiConverterTypeGateway.lower(value)
}


public struct HdPath {
    public var components: [HdPathComponent]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(components: [HdPathComponent]) {
        self.components = components
    }
}


extension HdPath: Sendable {} 
extension HdPath: Equatable, Hashable {
    public static func ==(lhs: HdPath, rhs: HdPath) -> Bool {
        if lhs.components != rhs.components {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(components)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHDPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdPath {
        return
            try HdPath(
                components: FfiConverterSequenceTypeHDPathComponent.read(from: &buf)
        )
    }

    public static func write(_ value: HdPath, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeHDPathComponent.write(value.components, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDPath_lift(_ buf: RustBuffer) throws -> HdPath {
    return try FfiConverterTypeHDPath.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDPath_lower(_ value: HdPath) -> RustBuffer {
    return FfiConverterTypeHDPath.lower(value)
}


public struct HdSignatureInputOfAuthIntentHash {
    /**
     * Hash which was signed.
     */
    public var payloadId: AuthIntentHash
    /**
     * The account or identity address of the entity which signed the hash,
     * with expected public key and with derivation path to derive PrivateKey
     * with.
     */
    public var ownedFactorInstance: OwnedFactorInstance

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hash which was signed.
         */payloadId: AuthIntentHash, 
        /**
         * The account or identity address of the entity which signed the hash,
         * with expected public key and with derivation path to derive PrivateKey
         * with.
         */ownedFactorInstance: OwnedFactorInstance) {
        self.payloadId = payloadId
        self.ownedFactorInstance = ownedFactorInstance
    }
}


extension HdSignatureInputOfAuthIntentHash: Sendable {} 
extension HdSignatureInputOfAuthIntentHash: Equatable, Hashable {
    public static func ==(lhs: HdSignatureInputOfAuthIntentHash, rhs: HdSignatureInputOfAuthIntentHash) -> Bool {
        if lhs.payloadId != rhs.payloadId {
            return false
        }
        if lhs.ownedFactorInstance != rhs.ownedFactorInstance {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payloadId)
        hasher.combine(ownedFactorInstance)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHDSignatureInputOfAuthIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdSignatureInputOfAuthIntentHash {
        return
            try HdSignatureInputOfAuthIntentHash(
                payloadId: FfiConverterTypeAuthIntentHash.read(from: &buf), 
                ownedFactorInstance: FfiConverterTypeOwnedFactorInstance.read(from: &buf)
        )
    }

    public static func write(_ value: HdSignatureInputOfAuthIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeAuthIntentHash.write(value.payloadId, into: &buf)
        FfiConverterTypeOwnedFactorInstance.write(value.ownedFactorInstance, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDSignatureInputOfAuthIntentHash_lift(_ buf: RustBuffer) throws -> HdSignatureInputOfAuthIntentHash {
    return try FfiConverterTypeHDSignatureInputOfAuthIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDSignatureInputOfAuthIntentHash_lower(_ value: HdSignatureInputOfAuthIntentHash) -> RustBuffer {
    return FfiConverterTypeHDSignatureInputOfAuthIntentHash.lower(value)
}


public struct HdSignatureInputOfSubintentHash {
    /**
     * Hash which was signed.
     */
    public var payloadId: SubintentHash
    /**
     * The account or identity address of the entity which signed the hash,
     * with expected public key and with derivation path to derive PrivateKey
     * with.
     */
    public var ownedFactorInstance: OwnedFactorInstance

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hash which was signed.
         */payloadId: SubintentHash, 
        /**
         * The account or identity address of the entity which signed the hash,
         * with expected public key and with derivation path to derive PrivateKey
         * with.
         */ownedFactorInstance: OwnedFactorInstance) {
        self.payloadId = payloadId
        self.ownedFactorInstance = ownedFactorInstance
    }
}


extension HdSignatureInputOfSubintentHash: Sendable {} 
extension HdSignatureInputOfSubintentHash: Equatable, Hashable {
    public static func ==(lhs: HdSignatureInputOfSubintentHash, rhs: HdSignatureInputOfSubintentHash) -> Bool {
        if lhs.payloadId != rhs.payloadId {
            return false
        }
        if lhs.ownedFactorInstance != rhs.ownedFactorInstance {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payloadId)
        hasher.combine(ownedFactorInstance)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHDSignatureInputOfSubintentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdSignatureInputOfSubintentHash {
        return
            try HdSignatureInputOfSubintentHash(
                payloadId: FfiConverterTypeSubintentHash.read(from: &buf), 
                ownedFactorInstance: FfiConverterTypeOwnedFactorInstance.read(from: &buf)
        )
    }

    public static func write(_ value: HdSignatureInputOfSubintentHash, into buf: inout [UInt8]) {
        FfiConverterTypeSubintentHash.write(value.payloadId, into: &buf)
        FfiConverterTypeOwnedFactorInstance.write(value.ownedFactorInstance, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDSignatureInputOfSubintentHash_lift(_ buf: RustBuffer) throws -> HdSignatureInputOfSubintentHash {
    return try FfiConverterTypeHDSignatureInputOfSubintentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDSignatureInputOfSubintentHash_lower(_ value: HdSignatureInputOfSubintentHash) -> RustBuffer {
    return FfiConverterTypeHDSignatureInputOfSubintentHash.lower(value)
}


public struct HdSignatureInputOfTransactionIntentHash {
    /**
     * Hash which was signed.
     */
    public var payloadId: TransactionIntentHash
    /**
     * The account or identity address of the entity which signed the hash,
     * with expected public key and with derivation path to derive PrivateKey
     * with.
     */
    public var ownedFactorInstance: OwnedFactorInstance

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hash which was signed.
         */payloadId: TransactionIntentHash, 
        /**
         * The account or identity address of the entity which signed the hash,
         * with expected public key and with derivation path to derive PrivateKey
         * with.
         */ownedFactorInstance: OwnedFactorInstance) {
        self.payloadId = payloadId
        self.ownedFactorInstance = ownedFactorInstance
    }
}


extension HdSignatureInputOfTransactionIntentHash: Sendable {} 
extension HdSignatureInputOfTransactionIntentHash: Equatable, Hashable {
    public static func ==(lhs: HdSignatureInputOfTransactionIntentHash, rhs: HdSignatureInputOfTransactionIntentHash) -> Bool {
        if lhs.payloadId != rhs.payloadId {
            return false
        }
        if lhs.ownedFactorInstance != rhs.ownedFactorInstance {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payloadId)
        hasher.combine(ownedFactorInstance)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHDSignatureInputOfTransactionIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdSignatureInputOfTransactionIntentHash {
        return
            try HdSignatureInputOfTransactionIntentHash(
                payloadId: FfiConverterTypeTransactionIntentHash.read(from: &buf), 
                ownedFactorInstance: FfiConverterTypeOwnedFactorInstance.read(from: &buf)
        )
    }

    public static func write(_ value: HdSignatureInputOfTransactionIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionIntentHash.write(value.payloadId, into: &buf)
        FfiConverterTypeOwnedFactorInstance.write(value.ownedFactorInstance, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDSignatureInputOfTransactionIntentHash_lift(_ buf: RustBuffer) throws -> HdSignatureInputOfTransactionIntentHash {
    return try FfiConverterTypeHDSignatureInputOfTransactionIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDSignatureInputOfTransactionIntentHash_lower(_ value: HdSignatureInputOfTransactionIntentHash) -> RustBuffer {
    return FfiConverterTypeHDSignatureInputOfTransactionIntentHash.lower(value)
}


public struct HdSignatureOfAuthIntentHash {
    /**
     * The input used to produce this `HDSignature`
     */
    public var input: HdSignatureInputOfAuthIntentHash
    /**
     * The ECDSA/EdDSA signature produced by the private key of the
     * `owned_hd_factor_instance.public_key`,
     * derived by the HDFactorSource identified by
     * `owned_hd_factor_
     * instance.factor_s
     * ource_id` and which
     * was derived at `owned_hd_factor_instance.derivation_path`.
     */
    public var signature: SignatureWithPublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The input used to produce this `HDSignature`
         */input: HdSignatureInputOfAuthIntentHash, 
        /**
         * The ECDSA/EdDSA signature produced by the private key of the
         * `owned_hd_factor_instance.public_key`,
         * derived by the HDFactorSource identified by
         * `owned_hd_factor_
         * instance.factor_s
         * ource_id` and which
         * was derived at `owned_hd_factor_instance.derivation_path`.
         */signature: SignatureWithPublicKey) {
        self.input = input
        self.signature = signature
    }
}


extension HdSignatureOfAuthIntentHash: Sendable {} 
extension HdSignatureOfAuthIntentHash: Equatable, Hashable {
    public static func ==(lhs: HdSignatureOfAuthIntentHash, rhs: HdSignatureOfAuthIntentHash) -> Bool {
        if lhs.input != rhs.input {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(input)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHDSignatureOfAuthIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdSignatureOfAuthIntentHash {
        return
            try HdSignatureOfAuthIntentHash(
                input: FfiConverterTypeHDSignatureInputOfAuthIntentHash.read(from: &buf), 
                signature: FfiConverterTypeSignatureWithPublicKey.read(from: &buf)
        )
    }

    public static func write(_ value: HdSignatureOfAuthIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeHDSignatureInputOfAuthIntentHash.write(value.input, into: &buf)
        FfiConverterTypeSignatureWithPublicKey.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDSignatureOfAuthIntentHash_lift(_ buf: RustBuffer) throws -> HdSignatureOfAuthIntentHash {
    return try FfiConverterTypeHDSignatureOfAuthIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDSignatureOfAuthIntentHash_lower(_ value: HdSignatureOfAuthIntentHash) -> RustBuffer {
    return FfiConverterTypeHDSignatureOfAuthIntentHash.lower(value)
}


public struct HdSignatureOfSubintentHash {
    /**
     * The input used to produce this `HDSignature`
     */
    public var input: HdSignatureInputOfSubintentHash
    /**
     * The ECDSA/EdDSA signature produced by the private key of the
     * `owned_hd_factor_instance.public_key`,
     * derived by the HDFactorSource identified by
     * `owned_hd_factor_
     * instance.factor_s
     * ource_id` and which
     * was derived at `owned_hd_factor_instance.derivation_path`.
     */
    public var signature: SignatureWithPublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The input used to produce this `HDSignature`
         */input: HdSignatureInputOfSubintentHash, 
        /**
         * The ECDSA/EdDSA signature produced by the private key of the
         * `owned_hd_factor_instance.public_key`,
         * derived by the HDFactorSource identified by
         * `owned_hd_factor_
         * instance.factor_s
         * ource_id` and which
         * was derived at `owned_hd_factor_instance.derivation_path`.
         */signature: SignatureWithPublicKey) {
        self.input = input
        self.signature = signature
    }
}


extension HdSignatureOfSubintentHash: Sendable {} 
extension HdSignatureOfSubintentHash: Equatable, Hashable {
    public static func ==(lhs: HdSignatureOfSubintentHash, rhs: HdSignatureOfSubintentHash) -> Bool {
        if lhs.input != rhs.input {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(input)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHDSignatureOfSubintentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdSignatureOfSubintentHash {
        return
            try HdSignatureOfSubintentHash(
                input: FfiConverterTypeHDSignatureInputOfSubintentHash.read(from: &buf), 
                signature: FfiConverterTypeSignatureWithPublicKey.read(from: &buf)
        )
    }

    public static func write(_ value: HdSignatureOfSubintentHash, into buf: inout [UInt8]) {
        FfiConverterTypeHDSignatureInputOfSubintentHash.write(value.input, into: &buf)
        FfiConverterTypeSignatureWithPublicKey.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDSignatureOfSubintentHash_lift(_ buf: RustBuffer) throws -> HdSignatureOfSubintentHash {
    return try FfiConverterTypeHDSignatureOfSubintentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDSignatureOfSubintentHash_lower(_ value: HdSignatureOfSubintentHash) -> RustBuffer {
    return FfiConverterTypeHDSignatureOfSubintentHash.lower(value)
}


public struct HdSignatureOfTransactionIntentHash {
    /**
     * The input used to produce this `HDSignature`
     */
    public var input: HdSignatureInputOfTransactionIntentHash
    /**
     * The ECDSA/EdDSA signature produced by the private key of the
     * `owned_hd_factor_instance.public_key`,
     * derived by the HDFactorSource identified by
     * `owned_hd_factor_
     * instance.factor_s
     * ource_id` and which
     * was derived at `owned_hd_factor_instance.derivation_path`.
     */
    public var signature: SignatureWithPublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The input used to produce this `HDSignature`
         */input: HdSignatureInputOfTransactionIntentHash, 
        /**
         * The ECDSA/EdDSA signature produced by the private key of the
         * `owned_hd_factor_instance.public_key`,
         * derived by the HDFactorSource identified by
         * `owned_hd_factor_
         * instance.factor_s
         * ource_id` and which
         * was derived at `owned_hd_factor_instance.derivation_path`.
         */signature: SignatureWithPublicKey) {
        self.input = input
        self.signature = signature
    }
}


extension HdSignatureOfTransactionIntentHash: Sendable {} 
extension HdSignatureOfTransactionIntentHash: Equatable, Hashable {
    public static func ==(lhs: HdSignatureOfTransactionIntentHash, rhs: HdSignatureOfTransactionIntentHash) -> Bool {
        if lhs.input != rhs.input {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(input)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHDSignatureOfTransactionIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdSignatureOfTransactionIntentHash {
        return
            try HdSignatureOfTransactionIntentHash(
                input: FfiConverterTypeHDSignatureInputOfTransactionIntentHash.read(from: &buf), 
                signature: FfiConverterTypeSignatureWithPublicKey.read(from: &buf)
        )
    }

    public static func write(_ value: HdSignatureOfTransactionIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeHDSignatureInputOfTransactionIntentHash.write(value.input, into: &buf)
        FfiConverterTypeSignatureWithPublicKey.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDSignatureOfTransactionIntentHash_lift(_ buf: RustBuffer) throws -> HdSignatureOfTransactionIntentHash {
    return try FfiConverterTypeHDSignatureOfTransactionIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDSignatureOfTransactionIntentHash_lower(_ value: HdSignatureOfTransactionIntentHash) -> RustBuffer {
    return FfiConverterTypeHDSignatureOfTransactionIntentHash.lower(value)
}


/**
 * Represents a 32-byte hash digest.
 *
 * Made UniFFI convertible via HashSecretMagic,
 * exposed in Swift/Kotlin as its own struct/data class, with
 * hidden secret magic.
 */
public struct Hash {
    public var value: Exactly32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Exactly32Bytes) {
        self.value = value
    }
}


extension Hash: Sendable {} 
extension Hash: Equatable, Hashable {
    public static func ==(lhs: Hash, rhs: Hash) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hash {
        return
            try Hash(
                value: FfiConverterTypeExactly32Bytes.read(from: &buf)
        )
    }

    public static func write(_ value: Hash, into buf: inout [UInt8]) {
        FfiConverterTypeExactly32Bytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHash_lift(_ buf: RustBuffer) throws -> Hash {
    return try FfiConverterTypeHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHash_lower(_ value: Hash) -> RustBuffer {
    return FfiConverterTypeHash.lower(value)
}


/**
 * The header of a Profile(Snapshot) contains crucial metadata
 * about this Profile, such as which JSON data format it is
 * compatible with and which device was used to create it and
 * a hint about its contents.
 */
public struct Header {
    /**
     * A versioning number that is increased when breaking
     * changes is made to ProfileSnapshot JSON data format.
     */
    public var snapshotVersion: ProfileSnapshotVersion
    /**
     * An immutable and unique identifier of a Profile.
     */
    public var id: ProfileId
    /**
     * The device which was used to create the Profile.
     */
    public var creatingDevice: DeviceInfo
    /**
     * The device on which the profile was last used.
     */
    public var lastUsedOnDevice: DeviceInfo
    /**
     * When the Profile was last modified.
     */
    public var lastModified: Timestamp
    /**
     * Hint about the contents of the profile, e.g. number of Accounts and Personas.
     */
    public var contentHint: ContentHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A versioning number that is increased when breaking
         * changes is made to ProfileSnapshot JSON data format.
         */snapshotVersion: ProfileSnapshotVersion, 
        /**
         * An immutable and unique identifier of a Profile.
         */id: ProfileId, 
        /**
         * The device which was used to create the Profile.
         */creatingDevice: DeviceInfo, 
        /**
         * The device on which the profile was last used.
         */lastUsedOnDevice: DeviceInfo, 
        /**
         * When the Profile was last modified.
         */lastModified: Timestamp, 
        /**
         * Hint about the contents of the profile, e.g. number of Accounts and Personas.
         */contentHint: ContentHint) {
        self.snapshotVersion = snapshotVersion
        self.id = id
        self.creatingDevice = creatingDevice
        self.lastUsedOnDevice = lastUsedOnDevice
        self.lastModified = lastModified
        self.contentHint = contentHint
    }
}


extension Header: Sendable {} 
extension Header: Equatable, Hashable {
    public static func ==(lhs: Header, rhs: Header) -> Bool {
        if lhs.snapshotVersion != rhs.snapshotVersion {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.creatingDevice != rhs.creatingDevice {
            return false
        }
        if lhs.lastUsedOnDevice != rhs.lastUsedOnDevice {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.contentHint != rhs.contentHint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(snapshotVersion)
        hasher.combine(id)
        hasher.combine(creatingDevice)
        hasher.combine(lastUsedOnDevice)
        hasher.combine(lastModified)
        hasher.combine(contentHint)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Header {
        return
            try Header(
                snapshotVersion: FfiConverterTypeProfileSnapshotVersion.read(from: &buf), 
                id: FfiConverterTypeProfileID.read(from: &buf), 
                creatingDevice: FfiConverterTypeDeviceInfo.read(from: &buf), 
                lastUsedOnDevice: FfiConverterTypeDeviceInfo.read(from: &buf), 
                lastModified: FfiConverterTypeTimestamp.read(from: &buf), 
                contentHint: FfiConverterTypeContentHint.read(from: &buf)
        )
    }

    public static func write(_ value: Header, into buf: inout [UInt8]) {
        FfiConverterTypeProfileSnapshotVersion.write(value.snapshotVersion, into: &buf)
        FfiConverterTypeProfileID.write(value.id, into: &buf)
        FfiConverterTypeDeviceInfo.write(value.creatingDevice, into: &buf)
        FfiConverterTypeDeviceInfo.write(value.lastUsedOnDevice, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastModified, into: &buf)
        FfiConverterTypeContentHint.write(value.contentHint, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeader_lift(_ buf: RustBuffer) throws -> Header {
    return try FfiConverterTypeHeader.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHeader_lower(_ value: Header) -> RustBuffer {
    return FfiConverterTypeHeader.lower(value)
}


/**
 * A virtual hierarchical deterministic `FactorInstance`
 */
public struct HierarchicalDeterministicFactorInstance {
    public var factorSourceId: FactorSourceIdFromHash
    public var publicKey: HierarchicalDeterministicPublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceId: FactorSourceIdFromHash, publicKey: HierarchicalDeterministicPublicKey) {
        self.factorSourceId = factorSourceId
        self.publicKey = publicKey
    }
}


extension HierarchicalDeterministicFactorInstance: Sendable {} 
extension HierarchicalDeterministicFactorInstance: Equatable, Hashable {
    public static func ==(lhs: HierarchicalDeterministicFactorInstance, rhs: HierarchicalDeterministicFactorInstance) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(publicKey)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HierarchicalDeterministicFactorInstance {
        return
            try HierarchicalDeterministicFactorInstance(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                publicKey: FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf)
        )
    }

    public static func write(_ value: HierarchicalDeterministicFactorInstance, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterTypeHierarchicalDeterministicPublicKey.write(value.publicKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHierarchicalDeterministicFactorInstance_lift(_ buf: RustBuffer) throws -> HierarchicalDeterministicFactorInstance {
    return try FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHierarchicalDeterministicFactorInstance_lower(_ value: HierarchicalDeterministicFactorInstance) -> RustBuffer {
    return FfiConverterTypeHierarchicalDeterministicFactorInstance.lower(value)
}


/**
 * The **source** of a virtual hierarchical deterministic badge, contains a
 * derivation path and public key, from which a private key is derived which
 * produces virtual badges (signatures).
 *
 * The `.device` `FactorSource` produces `FactorInstance`s with this kind if badge source.
 */
public struct HierarchicalDeterministicPublicKey {
    /**
     * The expected public key of the private key derived at `derivationPath`
     */
    public var publicKey: PublicKey
    /**
     * The HD derivation path for the key pair which produces virtual badges (signatures).
     */
    public var derivationPath: DerivationPath

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The expected public key of the private key derived at `derivationPath`
         */publicKey: PublicKey, 
        /**
         * The HD derivation path for the key pair which produces virtual badges (signatures).
         */derivationPath: DerivationPath) {
        self.publicKey = publicKey
        self.derivationPath = derivationPath
    }
}


extension HierarchicalDeterministicPublicKey: Sendable {} 
extension HierarchicalDeterministicPublicKey: Equatable, Hashable {
    public static func ==(lhs: HierarchicalDeterministicPublicKey, rhs: HierarchicalDeterministicPublicKey) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.derivationPath != rhs.derivationPath {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(derivationPath)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHierarchicalDeterministicPublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HierarchicalDeterministicPublicKey {
        return
            try HierarchicalDeterministicPublicKey(
                publicKey: FfiConverterTypePublicKey.read(from: &buf), 
                derivationPath: FfiConverterTypeDerivationPath.read(from: &buf)
        )
    }

    public static func write(_ value: HierarchicalDeterministicPublicKey, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterTypeDerivationPath.write(value.derivationPath, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHierarchicalDeterministicPublicKey_lift(_ buf: RustBuffer) throws -> HierarchicalDeterministicPublicKey {
    return try FfiConverterTypeHierarchicalDeterministicPublicKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHierarchicalDeterministicPublicKey_lower(_ value: HierarchicalDeterministicPublicKey) -> RustBuffer {
    return FfiConverterTypeHierarchicalDeterministicPublicKey.lower(value)
}


public struct HostId {
    /**
     * A best effort stable and unique identifier of this
     * host's device.
     */
    public var id: DeviceId
    /**
     * The date this id of the device was generated, might
     * be equal to when the app was first ever launched on the
     * device.
     */
    public var generatedAt: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A best effort stable and unique identifier of this
         * host's device.
         */id: DeviceId, 
        /**
         * The date this id of the device was generated, might
         * be equal to when the app was first ever launched on the
         * device.
         */generatedAt: Timestamp) {
        self.id = id
        self.generatedAt = generatedAt
    }
}


extension HostId: Sendable {} 
extension HostId: Equatable, Hashable {
    public static func ==(lhs: HostId, rhs: HostId) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.generatedAt != rhs.generatedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(generatedAt)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHostId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostId {
        return
            try HostId(
                id: FfiConverterTypeDeviceID.read(from: &buf), 
                generatedAt: FfiConverterTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: HostId, into buf: inout [UInt8]) {
        FfiConverterTypeDeviceID.write(value.id, into: &buf)
        FfiConverterTypeTimestamp.write(value.generatedAt, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHostId_lift(_ buf: RustBuffer) throws -> HostId {
    return try FfiConverterTypeHostId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHostId_lower(_ value: HostId) -> RustBuffer {
    return FfiConverterTypeHostId.lower(value)
}


public struct HostInfo {
    /**
     * A short description of the device. The host should
     * read the device model and a given name from the device
     * if they are able to.
     */
    public var description: DeviceInfoDescription
    /**
     * The **current** os and version of the device's operating system, e.g. "iOS 17.4.1".
     */
    public var hostOs: HostOs
    /**
     * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
     */
    public var hostAppVersion: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A short description of the device. The host should
         * read the device model and a given name from the device
         * if they are able to.
         */description: DeviceInfoDescription, 
        /**
         * The **current** os and version of the device's operating system, e.g. "iOS 17.4.1".
         */hostOs: HostOs, 
        /**
         * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
         */hostAppVersion: String) {
        self.description = description
        self.hostOs = hostOs
        self.hostAppVersion = hostAppVersion
    }
}


extension HostInfo: Sendable {} 
extension HostInfo: Equatable, Hashable {
    public static func ==(lhs: HostInfo, rhs: HostInfo) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.hostOs != rhs.hostOs {
            return false
        }
        if lhs.hostAppVersion != rhs.hostAppVersion {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(hostOs)
        hasher.combine(hostAppVersion)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHostInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostInfo {
        return
            try HostInfo(
                description: FfiConverterTypeDeviceInfoDescription.read(from: &buf), 
                hostOs: FfiConverterTypeHostOS.read(from: &buf), 
                hostAppVersion: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: HostInfo, into buf: inout [UInt8]) {
        FfiConverterTypeDeviceInfoDescription.write(value.description, into: &buf)
        FfiConverterTypeHostOS.write(value.hostOs, into: &buf)
        FfiConverterString.write(value.hostAppVersion, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHostInfo_lift(_ buf: RustBuffer) throws -> HostInfo {
    return try FfiConverterTypeHostInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHostInfo_lower(_ value: HostInfo) -> RustBuffer {
    return FfiConverterTypeHostInfo.lower(value)
}


/**
 * Human readable address of an identity, which are used by Personas. Always starts with
 * the prefix `"identity_"`, for example:
 *
 * `identity_rdx12tgzjrz9u0xz4l28vf04hz87eguclmfaq4d2p8f8lv7zg9ssnzku8j`
 *
 * Addresses are checksummed, as per Bech32. **Only** *Identity* addresses starts with
 * the prefix `"identity_"`.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of IdentityAddresses:
 * * GlobalIdentity,
 * * GlobalVirtualSecp256k1Identity,
 * * GlobalVirtualEd25519Identity
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert_eq!(
 * "identity_rdx12tgzjrz9u0xz4l28vf04hz87eguclmfaq4d2p8f8lv7zg9ssnzku8j".parse::<IdentityAddress>().unwrap().network_id(),
 * NetworkID::Mainnet
 * );
 * ```
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalIdentityAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L229-L234
 */
public struct IdentityAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension IdentityAddress: Sendable {} 
extension IdentityAddress: Equatable, Hashable {
    public static func ==(lhs: IdentityAddress, rhs: IdentityAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityAddress {
        return
            try IdentityAddress(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityAddress_lift(_ buf: RustBuffer) throws -> IdentityAddress {
    return try FfiConverterTypeIdentityAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityAddress_lower(_ value: IdentityAddress) -> RustBuffer {
    return FfiConverterTypeIdentityAddress.lower(value)
}


public struct IdentityPath {
    public var networkId: NetworkId
    public var keyKind: Cap26KeyKind
    public var index: Hardened

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, keyKind: Cap26KeyKind, index: Hardened) {
        self.networkId = networkId
        self.keyKind = keyKind
        self.index = index
    }
}


extension IdentityPath: Sendable {} 
extension IdentityPath: Equatable, Hashable {
    public static func ==(lhs: IdentityPath, rhs: IdentityPath) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.keyKind != rhs.keyKind {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(keyKind)
        hasher.combine(index)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityPath {
        return
            try IdentityPath(
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                keyKind: FfiConverterTypeCAP26KeyKind.read(from: &buf), 
                index: FfiConverterTypeHardened.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityPath, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeCAP26KeyKind.write(value.keyKind, into: &buf)
        FfiConverterTypeHardened.write(value.index, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityPath_lift(_ buf: RustBuffer) throws -> IdentityPath {
    return try FfiConverterTypeIdentityPath.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityPath_lower(_ value: IdentityPath) -> RustBuffer {
    return FfiConverterTypeIdentityPath.lower(value)
}


/**
 * Represents a Unix timestamp, capturing the seconds since the unix epoch.
 */
public struct Instant {
    public var secondsSinceUnixEpoch: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(secondsSinceUnixEpoch: Int64) {
        self.secondsSinceUnixEpoch = secondsSinceUnixEpoch
    }
}


extension Instant: Sendable {} 
extension Instant: Equatable, Hashable {
    public static func ==(lhs: Instant, rhs: Instant) -> Bool {
        if lhs.secondsSinceUnixEpoch != rhs.secondsSinceUnixEpoch {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secondsSinceUnixEpoch)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInstant: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Instant {
        return
            try Instant(
                secondsSinceUnixEpoch: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Instant, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.secondsSinceUnixEpoch, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInstant_lift(_ buf: RustBuffer) throws -> Instant {
    return try FfiConverterTypeInstant.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInstant_lower(_ value: Instant) -> RustBuffer {
    return FfiConverterTypeInstant.lower(value)
}


public struct Instructions {
    fileprivate let secretMagic: String
    public var networkId: NetworkId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String, networkId: NetworkId) {
        self.secretMagic = secretMagic
        self.networkId = networkId
    }
}


extension Instructions: Sendable {} 
extension Instructions: Equatable, Hashable {
    public static func ==(lhs: Instructions, rhs: Instructions) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
        hasher.combine(networkId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInstructions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Instructions {
        return
            try Instructions(
                secretMagic: FfiConverterString.read(from: &buf), 
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
        )
    }

    public static func write(_ value: Instructions, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInstructions_lift(_ buf: RustBuffer) throws -> Instructions {
    return try FfiConverterTypeInstructions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInstructions_lower(_ value: Instructions) -> RustBuffer {
    return FfiConverterTypeInstructions.lower(value)
}


/**
 * A random number generated part of an intent header,
 * ensuring every intent is unique even though its
 * transaction manifest might be equal. This intent discriminator is
 * generated by wallets for incoming intents.
 *
 * `IntentDiscriminator` is similar to the `Nonce` used in `TransactionHeader`.
 */
public struct IntentDiscriminator {
    fileprivate let secretMagic: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: UInt64) {
        self.secretMagic = secretMagic
    }
}


extension IntentDiscriminator: Sendable {} 
extension IntentDiscriminator: Equatable, Hashable {
    public static func ==(lhs: IntentDiscriminator, rhs: IntentDiscriminator) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIntentDiscriminator: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentDiscriminator {
        return
            try IntentDiscriminator(
                secretMagic: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: IntentDiscriminator, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIntentDiscriminator_lift(_ buf: RustBuffer) throws -> IntentDiscriminator {
    return try FfiConverterTypeIntentDiscriminator.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIntentDiscriminator_lower(_ value: IntentDiscriminator) -> RustBuffer {
    return FfiConverterTypeIntentDiscriminator.lower(value)
}


/**
 * Represents the header of an intent in V2, containing network ID,
 * epoch range, optional proposer timestamps, and an intent discriminator.
 */
public struct IntentHeaderV2 {
    public var networkId: NetworkId
    public var startEpochInclusive: Epoch
    public var endEpochExclusive: Epoch
    public var minProposerTimestampInclusive: Instant?
    public var maxProposerTimestampExclusive: Instant?
    /**
     * This field is intended to enable a network user to generate an identical intent with
     * a new hash. Users can simply set this randomly if they wish to. A u64 is large
     * enough to avoid any risk of collision over the course of a single epoch anyway.
     *
     * This field's name intent_discriminator is the new name for what was the nonce field in
     * IntentV1. This was poorly named, as it caused confusion with an Ethereum-style nonce.
     */
    public var intentDiscriminator: IntentDiscriminator

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, startEpochInclusive: Epoch, endEpochExclusive: Epoch, minProposerTimestampInclusive: Instant?, maxProposerTimestampExclusive: Instant?, 
        /**
         * This field is intended to enable a network user to generate an identical intent with
         * a new hash. Users can simply set this randomly if they wish to. A u64 is large
         * enough to avoid any risk of collision over the course of a single epoch anyway.
         *
         * This field's name intent_discriminator is the new name for what was the nonce field in
         * IntentV1. This was poorly named, as it caused confusion with an Ethereum-style nonce.
         */intentDiscriminator: IntentDiscriminator) {
        self.networkId = networkId
        self.startEpochInclusive = startEpochInclusive
        self.endEpochExclusive = endEpochExclusive
        self.minProposerTimestampInclusive = minProposerTimestampInclusive
        self.maxProposerTimestampExclusive = maxProposerTimestampExclusive
        self.intentDiscriminator = intentDiscriminator
    }
}


extension IntentHeaderV2: Sendable {} 
extension IntentHeaderV2: Equatable, Hashable {
    public static func ==(lhs: IntentHeaderV2, rhs: IntentHeaderV2) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.startEpochInclusive != rhs.startEpochInclusive {
            return false
        }
        if lhs.endEpochExclusive != rhs.endEpochExclusive {
            return false
        }
        if lhs.minProposerTimestampInclusive != rhs.minProposerTimestampInclusive {
            return false
        }
        if lhs.maxProposerTimestampExclusive != rhs.maxProposerTimestampExclusive {
            return false
        }
        if lhs.intentDiscriminator != rhs.intentDiscriminator {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(startEpochInclusive)
        hasher.combine(endEpochExclusive)
        hasher.combine(minProposerTimestampInclusive)
        hasher.combine(maxProposerTimestampExclusive)
        hasher.combine(intentDiscriminator)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIntentHeaderV2: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentHeaderV2 {
        return
            try IntentHeaderV2(
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                startEpochInclusive: FfiConverterTypeEpoch.read(from: &buf), 
                endEpochExclusive: FfiConverterTypeEpoch.read(from: &buf), 
                minProposerTimestampInclusive: FfiConverterOptionTypeInstant.read(from: &buf), 
                maxProposerTimestampExclusive: FfiConverterOptionTypeInstant.read(from: &buf), 
                intentDiscriminator: FfiConverterTypeIntentDiscriminator.read(from: &buf)
        )
    }

    public static func write(_ value: IntentHeaderV2, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeEpoch.write(value.startEpochInclusive, into: &buf)
        FfiConverterTypeEpoch.write(value.endEpochExclusive, into: &buf)
        FfiConverterOptionTypeInstant.write(value.minProposerTimestampInclusive, into: &buf)
        FfiConverterOptionTypeInstant.write(value.maxProposerTimestampExclusive, into: &buf)
        FfiConverterTypeIntentDiscriminator.write(value.intentDiscriminator, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIntentHeaderV2_lift(_ buf: RustBuffer) throws -> IntentHeaderV2 {
    return try FfiConverterTypeIntentHeaderV2.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIntentHeaderV2_lower(_ value: IntentHeaderV2) -> RustBuffer {
    return FfiConverterTypeIntentHeaderV2.lower(value)
}


public struct IntentSignature {
    public var value: SignatureWithPublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: SignatureWithPublicKey) {
        self.value = value
    }
}


extension IntentSignature: Sendable {} 
extension IntentSignature: Equatable, Hashable {
    public static func ==(lhs: IntentSignature, rhs: IntentSignature) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIntentSignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentSignature {
        return
            try IntentSignature(
                value: FfiConverterTypeSignatureWithPublicKey.read(from: &buf)
        )
    }

    public static func write(_ value: IntentSignature, into buf: inout [UInt8]) {
        FfiConverterTypeSignatureWithPublicKey.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIntentSignature_lift(_ buf: RustBuffer) throws -> IntentSignature {
    return try FfiConverterTypeIntentSignature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIntentSignature_lower(_ value: IntentSignature) -> RustBuffer {
    return FfiConverterTypeIntentSignature.lower(value)
}


public struct IntentSignatureOfOwner {
    public var owner: AddressOfAccountOrPersona
    public var intentSignature: IntentSignature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(owner: AddressOfAccountOrPersona, intentSignature: IntentSignature) {
        self.owner = owner
        self.intentSignature = intentSignature
    }
}


extension IntentSignatureOfOwner: Sendable {} 
extension IntentSignatureOfOwner: Equatable, Hashable {
    public static func ==(lhs: IntentSignatureOfOwner, rhs: IntentSignatureOfOwner) -> Bool {
        if lhs.owner != rhs.owner {
            return false
        }
        if lhs.intentSignature != rhs.intentSignature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(owner)
        hasher.combine(intentSignature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIntentSignatureOfOwner: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentSignatureOfOwner {
        return
            try IntentSignatureOfOwner(
                owner: FfiConverterTypeAddressOfAccountOrPersona.read(from: &buf), 
                intentSignature: FfiConverterTypeIntentSignature.read(from: &buf)
        )
    }

    public static func write(_ value: IntentSignatureOfOwner, into buf: inout [UInt8]) {
        FfiConverterTypeAddressOfAccountOrPersona.write(value.owner, into: &buf)
        FfiConverterTypeIntentSignature.write(value.intentSignature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIntentSignatureOfOwner_lift(_ buf: RustBuffer) throws -> IntentSignatureOfOwner {
    return try FfiConverterTypeIntentSignatureOfOwner.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIntentSignatureOfOwner_lower(_ value: IntentSignatureOfOwner) -> RustBuffer {
    return FfiConverterTypeIntentSignatureOfOwner.lower(value)
}


public struct IntentSignatures {
    public var signatures: [IntentSignature]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signatures: [IntentSignature]) {
        self.signatures = signatures
    }
}


extension IntentSignatures: Sendable {} 
extension IntentSignatures: Equatable, Hashable {
    public static func ==(lhs: IntentSignatures, rhs: IntentSignatures) -> Bool {
        if lhs.signatures != rhs.signatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signatures)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIntentSignatures: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentSignatures {
        return
            try IntentSignatures(
                signatures: FfiConverterSequenceTypeIntentSignature.read(from: &buf)
        )
    }

    public static func write(_ value: IntentSignatures, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeIntentSignature.write(value.signatures, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIntentSignatures_lift(_ buf: RustBuffer) throws -> IntentSignatures {
    return try FfiConverterTypeIntentSignatures.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIntentSignatures_lower(_ value: IntentSignatures) -> RustBuffer {
    return FfiConverterTypeIntentSignatures.lower(value)
}


/**
 * A list of entities which would fail in a transaction if we would
 * neglect certain factor source, either by user explicitly skipping
 * it or if implicitly neglected due to failure.
 */
public struct InvalidTransactionIfNeglectedOfAuthIntentHash {
    /**
     * The intent hash of the transaction which would be invalid if a
     * certain factor source would be neglected, either if user
     * explicitly skipped it or implicitly neglected due to failure.
     */
    public var signableId: AuthIntentHash
    /**
     * The entities in the transaction which would fail auth.
     */
    public var entitiesWhichWouldFailAuth: [AddressOfAccountOrPersona]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The intent hash of the transaction which would be invalid if a
         * certain factor source would be neglected, either if user
         * explicitly skipped it or implicitly neglected due to failure.
         */signableId: AuthIntentHash, 
        /**
         * The entities in the transaction which would fail auth.
         */entitiesWhichWouldFailAuth: [AddressOfAccountOrPersona]) {
        self.signableId = signableId
        self.entitiesWhichWouldFailAuth = entitiesWhichWouldFailAuth
    }
}


extension InvalidTransactionIfNeglectedOfAuthIntentHash: Sendable {} 
extension InvalidTransactionIfNeglectedOfAuthIntentHash: Equatable, Hashable {
    public static func ==(lhs: InvalidTransactionIfNeglectedOfAuthIntentHash, rhs: InvalidTransactionIfNeglectedOfAuthIntentHash) -> Bool {
        if lhs.signableId != rhs.signableId {
            return false
        }
        if lhs.entitiesWhichWouldFailAuth != rhs.entitiesWhichWouldFailAuth {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signableId)
        hasher.combine(entitiesWhichWouldFailAuth)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInvalidTransactionIfNeglectedOfAuthIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvalidTransactionIfNeglectedOfAuthIntentHash {
        return
            try InvalidTransactionIfNeglectedOfAuthIntentHash(
                signableId: FfiConverterTypeAuthIntentHash.read(from: &buf), 
                entitiesWhichWouldFailAuth: FfiConverterSequenceTypeAddressOfAccountOrPersona.read(from: &buf)
        )
    }

    public static func write(_ value: InvalidTransactionIfNeglectedOfAuthIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeAuthIntentHash.write(value.signableId, into: &buf)
        FfiConverterSequenceTypeAddressOfAccountOrPersona.write(value.entitiesWhichWouldFailAuth, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvalidTransactionIfNeglectedOfAuthIntentHash_lift(_ buf: RustBuffer) throws -> InvalidTransactionIfNeglectedOfAuthIntentHash {
    return try FfiConverterTypeInvalidTransactionIfNeglectedOfAuthIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvalidTransactionIfNeglectedOfAuthIntentHash_lower(_ value: InvalidTransactionIfNeglectedOfAuthIntentHash) -> RustBuffer {
    return FfiConverterTypeInvalidTransactionIfNeglectedOfAuthIntentHash.lower(value)
}


/**
 * A list of entities which would fail in a transaction if we would
 * neglect certain factor source, either by user explicitly skipping
 * it or if implicitly neglected due to failure.
 */
public struct InvalidTransactionIfNeglectedOfSubintentHash {
    /**
     * The intent hash of the transaction which would be invalid if a
     * certain factor source would be neglected, either if user
     * explicitly skipped it or implicitly neglected due to failure.
     */
    public var signableId: SubintentHash
    /**
     * The entities in the transaction which would fail auth.
     */
    public var entitiesWhichWouldFailAuth: [AddressOfAccountOrPersona]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The intent hash of the transaction which would be invalid if a
         * certain factor source would be neglected, either if user
         * explicitly skipped it or implicitly neglected due to failure.
         */signableId: SubintentHash, 
        /**
         * The entities in the transaction which would fail auth.
         */entitiesWhichWouldFailAuth: [AddressOfAccountOrPersona]) {
        self.signableId = signableId
        self.entitiesWhichWouldFailAuth = entitiesWhichWouldFailAuth
    }
}


extension InvalidTransactionIfNeglectedOfSubintentHash: Sendable {} 
extension InvalidTransactionIfNeglectedOfSubintentHash: Equatable, Hashable {
    public static func ==(lhs: InvalidTransactionIfNeglectedOfSubintentHash, rhs: InvalidTransactionIfNeglectedOfSubintentHash) -> Bool {
        if lhs.signableId != rhs.signableId {
            return false
        }
        if lhs.entitiesWhichWouldFailAuth != rhs.entitiesWhichWouldFailAuth {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signableId)
        hasher.combine(entitiesWhichWouldFailAuth)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInvalidTransactionIfNeglectedOfSubintentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvalidTransactionIfNeglectedOfSubintentHash {
        return
            try InvalidTransactionIfNeglectedOfSubintentHash(
                signableId: FfiConverterTypeSubintentHash.read(from: &buf), 
                entitiesWhichWouldFailAuth: FfiConverterSequenceTypeAddressOfAccountOrPersona.read(from: &buf)
        )
    }

    public static func write(_ value: InvalidTransactionIfNeglectedOfSubintentHash, into buf: inout [UInt8]) {
        FfiConverterTypeSubintentHash.write(value.signableId, into: &buf)
        FfiConverterSequenceTypeAddressOfAccountOrPersona.write(value.entitiesWhichWouldFailAuth, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvalidTransactionIfNeglectedOfSubintentHash_lift(_ buf: RustBuffer) throws -> InvalidTransactionIfNeglectedOfSubintentHash {
    return try FfiConverterTypeInvalidTransactionIfNeglectedOfSubintentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvalidTransactionIfNeglectedOfSubintentHash_lower(_ value: InvalidTransactionIfNeglectedOfSubintentHash) -> RustBuffer {
    return FfiConverterTypeInvalidTransactionIfNeglectedOfSubintentHash.lower(value)
}


/**
 * A list of entities which would fail in a transaction if we would
 * neglect certain factor source, either by user explicitly skipping
 * it or if implicitly neglected due to failure.
 */
public struct InvalidTransactionIfNeglectedOfTransactionIntentHash {
    /**
     * The intent hash of the transaction which would be invalid if a
     * certain factor source would be neglected, either if user
     * explicitly skipped it or implicitly neglected due to failure.
     */
    public var signableId: TransactionIntentHash
    /**
     * The entities in the transaction which would fail auth.
     */
    public var entitiesWhichWouldFailAuth: [AddressOfAccountOrPersona]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The intent hash of the transaction which would be invalid if a
         * certain factor source would be neglected, either if user
         * explicitly skipped it or implicitly neglected due to failure.
         */signableId: TransactionIntentHash, 
        /**
         * The entities in the transaction which would fail auth.
         */entitiesWhichWouldFailAuth: [AddressOfAccountOrPersona]) {
        self.signableId = signableId
        self.entitiesWhichWouldFailAuth = entitiesWhichWouldFailAuth
    }
}


extension InvalidTransactionIfNeglectedOfTransactionIntentHash: Sendable {} 
extension InvalidTransactionIfNeglectedOfTransactionIntentHash: Equatable, Hashable {
    public static func ==(lhs: InvalidTransactionIfNeglectedOfTransactionIntentHash, rhs: InvalidTransactionIfNeglectedOfTransactionIntentHash) -> Bool {
        if lhs.signableId != rhs.signableId {
            return false
        }
        if lhs.entitiesWhichWouldFailAuth != rhs.entitiesWhichWouldFailAuth {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signableId)
        hasher.combine(entitiesWhichWouldFailAuth)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInvalidTransactionIfNeglectedOfTransactionIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvalidTransactionIfNeglectedOfTransactionIntentHash {
        return
            try InvalidTransactionIfNeglectedOfTransactionIntentHash(
                signableId: FfiConverterTypeTransactionIntentHash.read(from: &buf), 
                entitiesWhichWouldFailAuth: FfiConverterSequenceTypeAddressOfAccountOrPersona.read(from: &buf)
        )
    }

    public static func write(_ value: InvalidTransactionIfNeglectedOfTransactionIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionIntentHash.write(value.signableId, into: &buf)
        FfiConverterSequenceTypeAddressOfAccountOrPersona.write(value.entitiesWhichWouldFailAuth, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvalidTransactionIfNeglectedOfTransactionIntentHash_lift(_ buf: RustBuffer) throws -> InvalidTransactionIfNeglectedOfTransactionIntentHash {
    return try FfiConverterTypeInvalidTransactionIfNeglectedOfTransactionIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInvalidTransactionIfNeglectedOfTransactionIntentHash_lower(_ value: InvalidTransactionIfNeglectedOfTransactionIntentHash) -> RustBuffer {
    return FfiConverterTypeInvalidTransactionIfNeglectedOfTransactionIntentHash.lower(value)
}


/**
 * PublicKey on Curve25519 used for key agreement (ECDH) with some `KeyAgreementPrivateKey`.
 */
public struct KeyAgreementPublicKey {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}


extension KeyAgreementPublicKey: Sendable {} 
extension KeyAgreementPublicKey: Equatable, Hashable {
    public static func ==(lhs: KeyAgreementPublicKey, rhs: KeyAgreementPublicKey) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyAgreementPublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyAgreementPublicKey {
        return
            try KeyAgreementPublicKey(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: KeyAgreementPublicKey, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyAgreementPublicKey_lift(_ buf: RustBuffer) throws -> KeyAgreementPublicKey {
    return try FfiConverterTypeKeyAgreementPublicKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyAgreementPublicKey_lower(_ value: KeyAgreementPublicKey) -> RustBuffer {
    return FfiConverterTypeKeyAgreementPublicKey.lower(value)
}


/**
 * A collection of derivation paths, on a per-factor-source basis.
 */
public struct KeyDerivationRequest {
    /**
     * We include this `DerivationPurpose` in dispatched use FactorSource requests to host so
     * that UI can display contextual information as to why the user is prompted to
     * authenticate FactorSource access.
     */
    public var derivationPurpose: DerivationPurpose
    public var perFactorSource: [KeyDerivationRequestPerFactorSource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * We include this `DerivationPurpose` in dispatched use FactorSource requests to host so
         * that UI can display contextual information as to why the user is prompted to
         * authenticate FactorSource access.
         */derivationPurpose: DerivationPurpose, perFactorSource: [KeyDerivationRequestPerFactorSource]) {
        self.derivationPurpose = derivationPurpose
        self.perFactorSource = perFactorSource
    }
}


extension KeyDerivationRequest: Sendable {} 
extension KeyDerivationRequest: Equatable, Hashable {
    public static func ==(lhs: KeyDerivationRequest, rhs: KeyDerivationRequest) -> Bool {
        if lhs.derivationPurpose != rhs.derivationPurpose {
            return false
        }
        if lhs.perFactorSource != rhs.perFactorSource {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(derivationPurpose)
        hasher.combine(perFactorSource)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyDerivationRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyDerivationRequest {
        return
            try KeyDerivationRequest(
                derivationPurpose: FfiConverterTypeDerivationPurpose.read(from: &buf), 
                perFactorSource: FfiConverterSequenceTypeKeyDerivationRequestPerFactorSource.read(from: &buf)
        )
    }

    public static func write(_ value: KeyDerivationRequest, into buf: inout [UInt8]) {
        FfiConverterTypeDerivationPurpose.write(value.derivationPurpose, into: &buf)
        FfiConverterSequenceTypeKeyDerivationRequestPerFactorSource.write(value.perFactorSource, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyDerivationRequest_lift(_ buf: RustBuffer) throws -> KeyDerivationRequest {
    return try FfiConverterTypeKeyDerivationRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyDerivationRequest_lower(_ value: KeyDerivationRequest) -> RustBuffer {
    return FfiConverterTypeKeyDerivationRequest.lower(value)
}


public struct KeyDerivationRequestPerFactorSource {
    public var factorSourceId: FactorSourceIdFromHash
    public var derivationPaths: [DerivationPath]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceId: FactorSourceIdFromHash, derivationPaths: [DerivationPath]) {
        self.factorSourceId = factorSourceId
        self.derivationPaths = derivationPaths
    }
}


extension KeyDerivationRequestPerFactorSource: Sendable {} 
extension KeyDerivationRequestPerFactorSource: Equatable, Hashable {
    public static func ==(lhs: KeyDerivationRequestPerFactorSource, rhs: KeyDerivationRequestPerFactorSource) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.derivationPaths != rhs.derivationPaths {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(derivationPaths)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyDerivationRequestPerFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyDerivationRequestPerFactorSource {
        return
            try KeyDerivationRequestPerFactorSource(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                derivationPaths: FfiConverterSequenceTypeDerivationPath.read(from: &buf)
        )
    }

    public static func write(_ value: KeyDerivationRequestPerFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterSequenceTypeDerivationPath.write(value.derivationPaths, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyDerivationRequestPerFactorSource_lift(_ buf: RustBuffer) throws -> KeyDerivationRequestPerFactorSource {
    return try FfiConverterTypeKeyDerivationRequestPerFactorSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyDerivationRequestPerFactorSource_lower(_ value: KeyDerivationRequestPerFactorSource) -> RustBuffer {
    return FfiConverterTypeKeyDerivationRequestPerFactorSource.lower(value)
}


/**
 * A collection of `HierarchicalDeterministicFactorInstance`s, on a
 * per-factor-source basis. In case of MonoKeyDerivation the list will contain
 * a single `KeyDerivationPerFactorSource`.
 */
public struct KeyDerivationResponse {
    public var perFactorSource: [KeyDerivationResponsePerFactorSource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(perFactorSource: [KeyDerivationResponsePerFactorSource]) {
        self.perFactorSource = perFactorSource
    }
}


extension KeyDerivationResponse: Sendable {} 
extension KeyDerivationResponse: Equatable, Hashable {
    public static func ==(lhs: KeyDerivationResponse, rhs: KeyDerivationResponse) -> Bool {
        if lhs.perFactorSource != rhs.perFactorSource {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(perFactorSource)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyDerivationResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyDerivationResponse {
        return
            try KeyDerivationResponse(
                perFactorSource: FfiConverterSequenceTypeKeyDerivationResponsePerFactorSource.read(from: &buf)
        )
    }

    public static func write(_ value: KeyDerivationResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeKeyDerivationResponsePerFactorSource.write(value.perFactorSource, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyDerivationResponse_lift(_ buf: RustBuffer) throws -> KeyDerivationResponse {
    return try FfiConverterTypeKeyDerivationResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyDerivationResponse_lower(_ value: KeyDerivationResponse) -> RustBuffer {
    return FfiConverterTypeKeyDerivationResponse.lower(value)
}


public struct KeyDerivationResponsePerFactorSource {
    public var factorSourceId: FactorSourceIdFromHash
    public var factorInstances: [HierarchicalDeterministicFactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceId: FactorSourceIdFromHash, factorInstances: [HierarchicalDeterministicFactorInstance]) {
        self.factorSourceId = factorSourceId
        self.factorInstances = factorInstances
    }
}


extension KeyDerivationResponsePerFactorSource: Sendable {} 
extension KeyDerivationResponsePerFactorSource: Equatable, Hashable {
    public static func ==(lhs: KeyDerivationResponsePerFactorSource, rhs: KeyDerivationResponsePerFactorSource) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.factorInstances != rhs.factorInstances {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(factorInstances)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyDerivationResponsePerFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyDerivationResponsePerFactorSource {
        return
            try KeyDerivationResponsePerFactorSource(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                factorInstances: FfiConverterSequenceTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
        )
    }

    public static func write(_ value: KeyDerivationResponsePerFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterSequenceTypeHierarchicalDeterministicFactorInstance.write(value.factorInstances, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyDerivationResponsePerFactorSource_lift(_ buf: RustBuffer) throws -> KeyDerivationResponsePerFactorSource {
    return try FfiConverterTypeKeyDerivationResponsePerFactorSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyDerivationResponsePerFactorSource_lower(_ value: KeyDerivationResponsePerFactorSource) -> RustBuffer {
    return FfiConverterTypeKeyDerivationResponsePerFactorSource.lower(value)
}


public struct LedgerHardwareWalletFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic,
     * that is secured by the Ledger Hardware Wallet device.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a LedgerHardwareWalletFactorSource to help user disambiguate between it and another one.
     */
    public var hint: LedgerHardwareWalletHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic,
         * that is secured by the Ledger Hardware Wallet device.
         */id: FactorSourceIdFromHash, 
        /**
         * Common properties shared between FactorSources of different kinds,
         * describing its state, when added, and supported cryptographic parameters.
         */common: FactorSourceCommon, 
        /**
         * Properties describing a LedgerHardwareWalletFactorSource to help user disambiguate between it and another one.
         */hint: LedgerHardwareWalletHint) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}


extension LedgerHardwareWalletFactorSource: Sendable {} 
extension LedgerHardwareWalletFactorSource: Equatable, Hashable {
    public static func ==(lhs: LedgerHardwareWalletFactorSource, rhs: LedgerHardwareWalletFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLedgerHardwareWalletFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletFactorSource {
        return
            try LedgerHardwareWalletFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf), 
                hint: FfiConverterTypeLedgerHardwareWalletHint.read(from: &buf)
        )
    }

    public static func write(_ value: LedgerHardwareWalletFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeLedgerHardwareWalletHint.write(value.hint, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLedgerHardwareWalletFactorSource_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletFactorSource {
    return try FfiConverterTypeLedgerHardwareWalletFactorSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLedgerHardwareWalletFactorSource_lower(_ value: LedgerHardwareWalletFactorSource) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletFactorSource.lower(value)
}


public struct LedgerHardwareWalletHint {
    /**
     * A user-assigned name for the ledger, intended to help users
     * differentiate between multiple ledgers.
     *
     * E.g. "Orange, scratched"
     */
    public var label: String
    /**
     * E.g. `nanoS+`
     */
    public var model: LedgerHardwareWalletModel

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A user-assigned name for the ledger, intended to help users
         * differentiate between multiple ledgers.
         *
         * E.g. "Orange, scratched"
         */label: String, 
        /**
         * E.g. `nanoS+`
         */model: LedgerHardwareWalletModel) {
        self.label = label
        self.model = model
    }
}


extension LedgerHardwareWalletHint: Sendable {} 
extension LedgerHardwareWalletHint: Equatable, Hashable {
    public static func ==(lhs: LedgerHardwareWalletHint, rhs: LedgerHardwareWalletHint) -> Bool {
        if lhs.label != rhs.label {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(label)
        hasher.combine(model)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLedgerHardwareWalletHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletHint {
        return
            try LedgerHardwareWalletHint(
                label: FfiConverterString.read(from: &buf), 
                model: FfiConverterTypeLedgerHardwareWalletModel.read(from: &buf)
        )
    }

    public static func write(_ value: LedgerHardwareWalletHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.label, into: &buf)
        FfiConverterTypeLedgerHardwareWalletModel.write(value.model, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLedgerHardwareWalletHint_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletHint {
    return try FfiConverterTypeLedgerHardwareWalletHint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLedgerHardwareWalletHint_lower(_ value: LedgerHardwareWalletHint) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletHint.lower(value)
}


public struct LegacyOlympiaAccountAddress {
    public var value: Secp256k1PublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Secp256k1PublicKey) {
        self.value = value
    }
}


extension LegacyOlympiaAccountAddress: Sendable {} 
extension LegacyOlympiaAccountAddress: Equatable, Hashable {
    public static func ==(lhs: LegacyOlympiaAccountAddress, rhs: LegacyOlympiaAccountAddress) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLegacyOlympiaAccountAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyOlympiaAccountAddress {
        return
            try LegacyOlympiaAccountAddress(
                value: FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
        )
    }

    public static func write(_ value: LegacyOlympiaAccountAddress, into buf: inout [UInt8]) {
        FfiConverterTypeSecp256k1PublicKey.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyOlympiaAccountAddress_lift(_ buf: RustBuffer) throws -> LegacyOlympiaAccountAddress {
    return try FfiConverterTypeLegacyOlympiaAccountAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLegacyOlympiaAccountAddress_lower(_ value: LegacyOlympiaAccountAddress) -> RustBuffer {
    return FfiConverterTypeLegacyOlympiaAccountAddress.lower(value)
}


/**
 * The QR code data scanned from the Connector Extension
 */
public struct LinkConnectionQrData {
    /**
     * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
     * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
     * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
     */
    public var purpose: RadixConnectPurpose
    /**
     * Used to be able to re-establish the P2P connection
     */
    public var password: RadixConnectPassword
    /**
     * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
     * Each client keeps a record of linked clients' public keys to prevent duplicate links.
     * This is the public key of the other client and it also serves as the seed for the link `ID`.
     */
    public var publicKeyOfOtherParty: Ed25519PublicKey
    /**
     * Represents a signature produced by Connector Extension by signing the hash of the `password`
     * with the private key of the `public_key_of_other_party`.
     */
    public var signature: Ed25519Signature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
         * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
         * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
         */purpose: RadixConnectPurpose, 
        /**
         * Used to be able to re-establish the P2P connection
         */password: RadixConnectPassword, 
        /**
         * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
         * Each client keeps a record of linked clients' public keys to prevent duplicate links.
         * This is the public key of the other client and it also serves as the seed for the link `ID`.
         */publicKeyOfOtherParty: Ed25519PublicKey, 
        /**
         * Represents a signature produced by Connector Extension by signing the hash of the `password`
         * with the private key of the `public_key_of_other_party`.
         */signature: Ed25519Signature) {
        self.purpose = purpose
        self.password = password
        self.publicKeyOfOtherParty = publicKeyOfOtherParty
        self.signature = signature
    }
}


extension LinkConnectionQrData: Sendable {} 
extension LinkConnectionQrData: Equatable, Hashable {
    public static func ==(lhs: LinkConnectionQrData, rhs: LinkConnectionQrData) -> Bool {
        if lhs.purpose != rhs.purpose {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.publicKeyOfOtherParty != rhs.publicKeyOfOtherParty {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(purpose)
        hasher.combine(password)
        hasher.combine(publicKeyOfOtherParty)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLinkConnectionQRData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LinkConnectionQrData {
        return
            try LinkConnectionQrData(
                purpose: FfiConverterTypeRadixConnectPurpose.read(from: &buf), 
                password: FfiConverterTypeRadixConnectPassword.read(from: &buf), 
                publicKeyOfOtherParty: FfiConverterTypeEd25519PublicKey.read(from: &buf), 
                signature: FfiConverterTypeEd25519Signature.read(from: &buf)
        )
    }

    public static func write(_ value: LinkConnectionQrData, into buf: inout [UInt8]) {
        FfiConverterTypeRadixConnectPurpose.write(value.purpose, into: &buf)
        FfiConverterTypeRadixConnectPassword.write(value.password, into: &buf)
        FfiConverterTypeEd25519PublicKey.write(value.publicKeyOfOtherParty, into: &buf)
        FfiConverterTypeEd25519Signature.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLinkConnectionQRData_lift(_ buf: RustBuffer) throws -> LinkConnectionQrData {
    return try FfiConverterTypeLinkConnectionQRData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLinkConnectionQRData_lower(_ value: LinkConnectionQrData) -> RustBuffer {
    return FfiConverterTypeLinkConnectionQRData.lower(value)
}


public struct LocaleConfig {
    public var decimalSeparator: String?
    public var groupingSeparator: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(decimalSeparator: String?, groupingSeparator: String?) {
        self.decimalSeparator = decimalSeparator
        self.groupingSeparator = groupingSeparator
    }
}


extension LocaleConfig: Sendable {} 
extension LocaleConfig: Equatable, Hashable {
    public static func ==(lhs: LocaleConfig, rhs: LocaleConfig) -> Bool {
        if lhs.decimalSeparator != rhs.decimalSeparator {
            return false
        }
        if lhs.groupingSeparator != rhs.groupingSeparator {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(decimalSeparator)
        hasher.combine(groupingSeparator)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocaleConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocaleConfig {
        return
            try LocaleConfig(
                decimalSeparator: FfiConverterOptionString.read(from: &buf), 
                groupingSeparator: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LocaleConfig, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.decimalSeparator, into: &buf)
        FfiConverterOptionString.write(value.groupingSeparator, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocaleConfig_lift(_ buf: RustBuffer) throws -> LocaleConfig {
    return try FfiConverterTypeLocaleConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocaleConfig_lower(_ value: LocaleConfig) -> RustBuffer {
    return FfiConverterTypeLocaleConfig.lower(value)
}


/**
 * Addresses to a specific locker, owned by a dApp, holding assets, either fungible or non_fungible,
 * that can be claimed by destined account addresses.
 * Identities cannot own assets so they do not have vaults, but Accounts do, e.g.:
 * e.g.:
 * `"locker_rdx1tz474x29nxxd4k2p2reete9xyz4apawv63dphxkr00qt23vyju49fq"`
 *
 * A `LockerAddress` has the [Scrypto's `EntityType`][entt] `GlobalAccountLocker`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalLockerAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radix-engine-toolkit/blob/476d779fee08ed1e561ac8fc8730a2a404b7de79/crates/radix-engine-toolkit-uniffi/src/common/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/476d779fee08ed1e561ac8fc8730a2a404b7de79/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L262-L265
 */
public struct LockerAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension LockerAddress: Sendable {} 
extension LockerAddress: Equatable, Hashable {
    public static func ==(lhs: LockerAddress, rhs: LockerAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLockerAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockerAddress {
        return
            try LockerAddress(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LockerAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLockerAddress_lift(_ buf: RustBuffer) throws -> LockerAddress {
    return try FfiConverterTypeLockerAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLockerAddress_lower(_ value: LockerAddress) -> RustBuffer {
    return FfiConverterTypeLockerAddress.lower(value)
}


/**
 * A summary of the manifest
 */
public struct ManifestSummary {
    /**
     * The withdrawals done in the manifest.
     */
    public var accountWithdrawals: [AccountAddress: [AccountWithdraw]]
    /**
     * The deposits done in the manifest.
     */
    public var accountDeposits: [AccountAddress: AccountDeposits]
    /**
     * The list of the resources of proofs that were presented in the manifest.
     */
    public var presentedProofs: [ResourceSpecifier]
    /**
     * Addresses of accounts withdrawn from in the manifest.
     */
    public var addressesOfAccountsWithdrawnFrom: [AccountAddress]
    /**
     * Addresses of accounts deposited into in the manifest.
     */
    public var addressesOfAccountsDepositedInto: [AccountAddress]
    /**
     * The set of all the global entities encountered in the manifest. This is
     * to be primarily used for the "using dApps" section of the wallet's tx
     * review screen.
     */
    public var encounteredEntities: [ManifestEncounteredComponentAddress]
    /**
     * Addresses of accounts encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the accounts of all those addresses, which might be multiple
     * signatures per Account, if MFA has been setup.
     */
    public var addressesOfAccountsRequiringAuth: [AccountAddress]
    /**
     * Addresses of identities (Personas) encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the identities of all those addresses, which might be multiple
     * signatures per Persona, if MFA has been setup.
     */
    public var addressesOfPersonasRequiringAuth: [IdentityAddress]
    /**
     * The set of instructions encountered in the manifest that are reserved
     * and can only be included in the manifest by the wallet itself.
     */
    public var reservedInstructions: [ReservedInstruction]
    /**
     * The various classifications that this manifest matched against. Note
     * that an empty set means that the manifest is non-conforming.
     */
    public var classification: [ManifestClass]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The withdrawals done in the manifest.
         */accountWithdrawals: [AccountAddress: [AccountWithdraw]], 
        /**
         * The deposits done in the manifest.
         */accountDeposits: [AccountAddress: AccountDeposits], 
        /**
         * The list of the resources of proofs that were presented in the manifest.
         */presentedProofs: [ResourceSpecifier], 
        /**
         * Addresses of accounts withdrawn from in the manifest.
         */addressesOfAccountsWithdrawnFrom: [AccountAddress], 
        /**
         * Addresses of accounts deposited into in the manifest.
         */addressesOfAccountsDepositedInto: [AccountAddress], 
        /**
         * The set of all the global entities encountered in the manifest. This is
         * to be primarily used for the "using dApps" section of the wallet's tx
         * review screen.
         */encounteredEntities: [ManifestEncounteredComponentAddress], 
        /**
         * Addresses of accounts encountered in the manifest where privileged
         * methods were called. The wallets will need to collect signatures
         * of the accounts of all those addresses, which might be multiple
         * signatures per Account, if MFA has been setup.
         */addressesOfAccountsRequiringAuth: [AccountAddress], 
        /**
         * Addresses of identities (Personas) encountered in the manifest where privileged
         * methods were called. The wallets will need to collect signatures
         * of the identities of all those addresses, which might be multiple
         * signatures per Persona, if MFA has been setup.
         */addressesOfPersonasRequiringAuth: [IdentityAddress], 
        /**
         * The set of instructions encountered in the manifest that are reserved
         * and can only be included in the manifest by the wallet itself.
         */reservedInstructions: [ReservedInstruction], 
        /**
         * The various classifications that this manifest matched against. Note
         * that an empty set means that the manifest is non-conforming.
         */classification: [ManifestClass]) {
        self.accountWithdrawals = accountWithdrawals
        self.accountDeposits = accountDeposits
        self.presentedProofs = presentedProofs
        self.addressesOfAccountsWithdrawnFrom = addressesOfAccountsWithdrawnFrom
        self.addressesOfAccountsDepositedInto = addressesOfAccountsDepositedInto
        self.encounteredEntities = encounteredEntities
        self.addressesOfAccountsRequiringAuth = addressesOfAccountsRequiringAuth
        self.addressesOfPersonasRequiringAuth = addressesOfPersonasRequiringAuth
        self.reservedInstructions = reservedInstructions
        self.classification = classification
    }
}


extension ManifestSummary: Sendable {} 
extension ManifestSummary: Equatable, Hashable {
    public static func ==(lhs: ManifestSummary, rhs: ManifestSummary) -> Bool {
        if lhs.accountWithdrawals != rhs.accountWithdrawals {
            return false
        }
        if lhs.accountDeposits != rhs.accountDeposits {
            return false
        }
        if lhs.presentedProofs != rhs.presentedProofs {
            return false
        }
        if lhs.addressesOfAccountsWithdrawnFrom != rhs.addressesOfAccountsWithdrawnFrom {
            return false
        }
        if lhs.addressesOfAccountsDepositedInto != rhs.addressesOfAccountsDepositedInto {
            return false
        }
        if lhs.encounteredEntities != rhs.encounteredEntities {
            return false
        }
        if lhs.addressesOfAccountsRequiringAuth != rhs.addressesOfAccountsRequiringAuth {
            return false
        }
        if lhs.addressesOfPersonasRequiringAuth != rhs.addressesOfPersonasRequiringAuth {
            return false
        }
        if lhs.reservedInstructions != rhs.reservedInstructions {
            return false
        }
        if lhs.classification != rhs.classification {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountWithdrawals)
        hasher.combine(accountDeposits)
        hasher.combine(presentedProofs)
        hasher.combine(addressesOfAccountsWithdrawnFrom)
        hasher.combine(addressesOfAccountsDepositedInto)
        hasher.combine(encounteredEntities)
        hasher.combine(addressesOfAccountsRequiringAuth)
        hasher.combine(addressesOfPersonasRequiringAuth)
        hasher.combine(reservedInstructions)
        hasher.combine(classification)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeManifestSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestSummary {
        return
            try ManifestSummary(
                accountWithdrawals: FfiConverterDictionaryTypeAccountAddressSequenceTypeAccountWithdraw.read(from: &buf), 
                accountDeposits: FfiConverterDictionaryTypeAccountAddressTypeAccountDeposits.read(from: &buf), 
                presentedProofs: FfiConverterSequenceTypeResourceSpecifier.read(from: &buf), 
                addressesOfAccountsWithdrawnFrom: FfiConverterSequenceTypeAccountAddress.read(from: &buf), 
                addressesOfAccountsDepositedInto: FfiConverterSequenceTypeAccountAddress.read(from: &buf), 
                encounteredEntities: FfiConverterSequenceTypeManifestEncounteredComponentAddress.read(from: &buf), 
                addressesOfAccountsRequiringAuth: FfiConverterSequenceTypeAccountAddress.read(from: &buf), 
                addressesOfPersonasRequiringAuth: FfiConverterSequenceTypeIdentityAddress.read(from: &buf), 
                reservedInstructions: FfiConverterSequenceTypeReservedInstruction.read(from: &buf), 
                classification: FfiConverterSequenceTypeManifestClass.read(from: &buf)
        )
    }

    public static func write(_ value: ManifestSummary, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeAccountAddressSequenceTypeAccountWithdraw.write(value.accountWithdrawals, into: &buf)
        FfiConverterDictionaryTypeAccountAddressTypeAccountDeposits.write(value.accountDeposits, into: &buf)
        FfiConverterSequenceTypeResourceSpecifier.write(value.presentedProofs, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsWithdrawnFrom, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsDepositedInto, into: &buf)
        FfiConverterSequenceTypeManifestEncounteredComponentAddress.write(value.encounteredEntities, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsRequiringAuth, into: &buf)
        FfiConverterSequenceTypeIdentityAddress.write(value.addressesOfPersonasRequiringAuth, into: &buf)
        FfiConverterSequenceTypeReservedInstruction.write(value.reservedInstructions, into: &buf)
        FfiConverterSequenceTypeManifestClass.write(value.classification, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeManifestSummary_lift(_ buf: RustBuffer) throws -> ManifestSummary {
    return try FfiConverterTypeManifestSummary.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeManifestSummary_lower(_ value: ManifestSummary) -> RustBuffer {
    return FfiConverterTypeManifestSummary.lower(value)
}


/**
 * Matrix of `FactorInstance`s containing the primary, recovery, and confirmation roles with `FactorInstance`s
 */
public struct MatrixOfFactorInstances {
    public var primaryRole: PrimaryRoleWithFactorInstances
    public var recoveryRole: RecoveryRoleWithFactorInstances
    public var confirmationRole: ConfirmationRoleWithFactorInstances
    public var timeUntilDelayedConfirmationIsCallable: TimePeriod

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(primaryRole: PrimaryRoleWithFactorInstances, recoveryRole: RecoveryRoleWithFactorInstances, confirmationRole: ConfirmationRoleWithFactorInstances, timeUntilDelayedConfirmationIsCallable: TimePeriod) {
        self.primaryRole = primaryRole
        self.recoveryRole = recoveryRole
        self.confirmationRole = confirmationRole
        self.timeUntilDelayedConfirmationIsCallable = timeUntilDelayedConfirmationIsCallable
    }
}


extension MatrixOfFactorInstances: Sendable {} 
extension MatrixOfFactorInstances: Equatable, Hashable {
    public static func ==(lhs: MatrixOfFactorInstances, rhs: MatrixOfFactorInstances) -> Bool {
        if lhs.primaryRole != rhs.primaryRole {
            return false
        }
        if lhs.recoveryRole != rhs.recoveryRole {
            return false
        }
        if lhs.confirmationRole != rhs.confirmationRole {
            return false
        }
        if lhs.timeUntilDelayedConfirmationIsCallable != rhs.timeUntilDelayedConfirmationIsCallable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(primaryRole)
        hasher.combine(recoveryRole)
        hasher.combine(confirmationRole)
        hasher.combine(timeUntilDelayedConfirmationIsCallable)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMatrixOfFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixOfFactorInstances {
        return
            try MatrixOfFactorInstances(
                primaryRole: FfiConverterTypePrimaryRoleWithFactorInstances.read(from: &buf), 
                recoveryRole: FfiConverterTypeRecoveryRoleWithFactorInstances.read(from: &buf), 
                confirmationRole: FfiConverterTypeConfirmationRoleWithFactorInstances.read(from: &buf), 
                timeUntilDelayedConfirmationIsCallable: FfiConverterTypeTimePeriod.read(from: &buf)
        )
    }

    public static func write(_ value: MatrixOfFactorInstances, into buf: inout [UInt8]) {
        FfiConverterTypePrimaryRoleWithFactorInstances.write(value.primaryRole, into: &buf)
        FfiConverterTypeRecoveryRoleWithFactorInstances.write(value.recoveryRole, into: &buf)
        FfiConverterTypeConfirmationRoleWithFactorInstances.write(value.confirmationRole, into: &buf)
        FfiConverterTypeTimePeriod.write(value.timeUntilDelayedConfirmationIsCallable, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMatrixOfFactorInstances_lift(_ buf: RustBuffer) throws -> MatrixOfFactorInstances {
    return try FfiConverterTypeMatrixOfFactorInstances.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMatrixOfFactorInstances_lower(_ value: MatrixOfFactorInstances) -> RustBuffer {
    return FfiConverterTypeMatrixOfFactorInstances.lower(value)
}


/**
 * Matrix of `FactorSourceID`s containing the primary, recovery, and confirmation roles with `FactorSourceID`s
 */
public struct MatrixOfFactorSourceIDs {
    public var primaryRole: PrimaryRoleWithFactorSourceIDs
    public var recoveryRole: RecoveryRoleWithFactorSourceIDs
    public var confirmationRole: ConfirmationRoleWithFactorSourceIDs
    public var timeUntilDelayedConfirmationIsCallable: TimePeriod

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(primaryRole: PrimaryRoleWithFactorSourceIDs, recoveryRole: RecoveryRoleWithFactorSourceIDs, confirmationRole: ConfirmationRoleWithFactorSourceIDs, timeUntilDelayedConfirmationIsCallable: TimePeriod) {
        self.primaryRole = primaryRole
        self.recoveryRole = recoveryRole
        self.confirmationRole = confirmationRole
        self.timeUntilDelayedConfirmationIsCallable = timeUntilDelayedConfirmationIsCallable
    }
}


extension MatrixOfFactorSourceIDs: Sendable {} 
extension MatrixOfFactorSourceIDs: Equatable, Hashable {
    public static func ==(lhs: MatrixOfFactorSourceIDs, rhs: MatrixOfFactorSourceIDs) -> Bool {
        if lhs.primaryRole != rhs.primaryRole {
            return false
        }
        if lhs.recoveryRole != rhs.recoveryRole {
            return false
        }
        if lhs.confirmationRole != rhs.confirmationRole {
            return false
        }
        if lhs.timeUntilDelayedConfirmationIsCallable != rhs.timeUntilDelayedConfirmationIsCallable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(primaryRole)
        hasher.combine(recoveryRole)
        hasher.combine(confirmationRole)
        hasher.combine(timeUntilDelayedConfirmationIsCallable)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMatrixOfFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixOfFactorSourceIDs {
        return
            try MatrixOfFactorSourceIDs(
                primaryRole: FfiConverterTypePrimaryRoleWithFactorSourceIDs.read(from: &buf), 
                recoveryRole: FfiConverterTypeRecoveryRoleWithFactorSourceIDs.read(from: &buf), 
                confirmationRole: FfiConverterTypeConfirmationRoleWithFactorSourceIDs.read(from: &buf), 
                timeUntilDelayedConfirmationIsCallable: FfiConverterTypeTimePeriod.read(from: &buf)
        )
    }

    public static func write(_ value: MatrixOfFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterTypePrimaryRoleWithFactorSourceIDs.write(value.primaryRole, into: &buf)
        FfiConverterTypeRecoveryRoleWithFactorSourceIDs.write(value.recoveryRole, into: &buf)
        FfiConverterTypeConfirmationRoleWithFactorSourceIDs.write(value.confirmationRole, into: &buf)
        FfiConverterTypeTimePeriod.write(value.timeUntilDelayedConfirmationIsCallable, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMatrixOfFactorSourceIDs_lift(_ buf: RustBuffer) throws -> MatrixOfFactorSourceIDs {
    return try FfiConverterTypeMatrixOfFactorSourceIDs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMatrixOfFactorSourceIDs_lower(_ value: MatrixOfFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypeMatrixOfFactorSourceIDs.lower(value)
}


/**
 * Matrix of `FactorSource`s containing the primary, recovery, and confirmation roles with `FactorSource`s
 */
public struct MatrixOfFactorSources {
    public var primaryRole: PrimaryRoleWithFactorSources
    public var recoveryRole: RecoveryRoleWithFactorSources
    public var confirmationRole: ConfirmationRoleWithFactorSources
    public var timeUntilDelayedConfirmationIsCallable: TimePeriod

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(primaryRole: PrimaryRoleWithFactorSources, recoveryRole: RecoveryRoleWithFactorSources, confirmationRole: ConfirmationRoleWithFactorSources, timeUntilDelayedConfirmationIsCallable: TimePeriod) {
        self.primaryRole = primaryRole
        self.recoveryRole = recoveryRole
        self.confirmationRole = confirmationRole
        self.timeUntilDelayedConfirmationIsCallable = timeUntilDelayedConfirmationIsCallable
    }
}


extension MatrixOfFactorSources: Sendable {} 
extension MatrixOfFactorSources: Equatable, Hashable {
    public static func ==(lhs: MatrixOfFactorSources, rhs: MatrixOfFactorSources) -> Bool {
        if lhs.primaryRole != rhs.primaryRole {
            return false
        }
        if lhs.recoveryRole != rhs.recoveryRole {
            return false
        }
        if lhs.confirmationRole != rhs.confirmationRole {
            return false
        }
        if lhs.timeUntilDelayedConfirmationIsCallable != rhs.timeUntilDelayedConfirmationIsCallable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(primaryRole)
        hasher.combine(recoveryRole)
        hasher.combine(confirmationRole)
        hasher.combine(timeUntilDelayedConfirmationIsCallable)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMatrixOfFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixOfFactorSources {
        return
            try MatrixOfFactorSources(
                primaryRole: FfiConverterTypePrimaryRoleWithFactorSources.read(from: &buf), 
                recoveryRole: FfiConverterTypeRecoveryRoleWithFactorSources.read(from: &buf), 
                confirmationRole: FfiConverterTypeConfirmationRoleWithFactorSources.read(from: &buf), 
                timeUntilDelayedConfirmationIsCallable: FfiConverterTypeTimePeriod.read(from: &buf)
        )
    }

    public static func write(_ value: MatrixOfFactorSources, into buf: inout [UInt8]) {
        FfiConverterTypePrimaryRoleWithFactorSources.write(value.primaryRole, into: &buf)
        FfiConverterTypeRecoveryRoleWithFactorSources.write(value.recoveryRole, into: &buf)
        FfiConverterTypeConfirmationRoleWithFactorSources.write(value.confirmationRole, into: &buf)
        FfiConverterTypeTimePeriod.write(value.timeUntilDelayedConfirmationIsCallable, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMatrixOfFactorSources_lift(_ buf: RustBuffer) throws -> MatrixOfFactorSources {
    return try FfiConverterTypeMatrixOfFactorSources.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMatrixOfFactorSources_lower(_ value: MatrixOfFactorSources) -> RustBuffer {
    return FfiConverterTypeMatrixOfFactorSources.lower(value)
}


public struct Mnemonic {
    public var words: [Bip39Word]
    public var wordCount: Bip39WordCount
    public var language: Bip39Language

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(words: [Bip39Word], wordCount: Bip39WordCount, language: Bip39Language) {
        self.words = words
        self.wordCount = wordCount
        self.language = language
    }
}


extension Mnemonic: Sendable {} 
extension Mnemonic: Equatable, Hashable {
    public static func ==(lhs: Mnemonic, rhs: Mnemonic) -> Bool {
        if lhs.words != rhs.words {
            return false
        }
        if lhs.wordCount != rhs.wordCount {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(words)
        hasher.combine(wordCount)
        hasher.combine(language)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        return
            try Mnemonic(
                words: FfiConverterSequenceTypeBIP39Word.read(from: &buf), 
                wordCount: FfiConverterTypeBIP39WordCount.read(from: &buf), 
                language: FfiConverterTypeBIP39Language.read(from: &buf)
        )
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBIP39Word.write(value.words, into: &buf)
        FfiConverterTypeBIP39WordCount.write(value.wordCount, into: &buf)
        FfiConverterTypeBIP39Language.write(value.language, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonic_lift(_ buf: RustBuffer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> RustBuffer {
    return FfiConverterTypeMnemonic.lower(value)
}


/**
 * A BIP39 Mnemonic and BIP39 passphrase - aka "25th word" tuple,
 * from which we can derive a HD Root used for derivation.
 */
public struct MnemonicWithPassphrase {
    public var mnemonic: Mnemonic
    public var passphrase: Bip39Passphrase

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonic: Mnemonic, passphrase: Bip39Passphrase) {
        self.mnemonic = mnemonic
        self.passphrase = passphrase
    }
}


extension MnemonicWithPassphrase: Sendable {} 
extension MnemonicWithPassphrase: Equatable, Hashable {
    public static func ==(lhs: MnemonicWithPassphrase, rhs: MnemonicWithPassphrase) -> Bool {
        if lhs.mnemonic != rhs.mnemonic {
            return false
        }
        if lhs.passphrase != rhs.passphrase {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonic)
        hasher.combine(passphrase)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonicWithPassphrase: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicWithPassphrase {
        return
            try MnemonicWithPassphrase(
                mnemonic: FfiConverterTypeMnemonic.read(from: &buf), 
                passphrase: FfiConverterTypeBIP39Passphrase.read(from: &buf)
        )
    }

    public static func write(_ value: MnemonicWithPassphrase, into buf: inout [UInt8]) {
        FfiConverterTypeMnemonic.write(value.mnemonic, into: &buf)
        FfiConverterTypeBIP39Passphrase.write(value.passphrase, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonicWithPassphrase_lift(_ buf: RustBuffer) throws -> MnemonicWithPassphrase {
    return try FfiConverterTypeMnemonicWithPassphrase.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonicWithPassphrase_lower(_ value: MnemonicWithPassphrase) -> RustBuffer {
    return FfiConverterTypeMnemonicWithPassphrase.lower(value)
}


public struct NeglectedFactor {
    /**
     * The reason why this factor was neglected.
     */
    public var reason: NeglectFactorReason
    /**
     * The neglected factors
     */
    public var factor: FactorSourceIdFromHash

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The reason why this factor was neglected.
         */reason: NeglectFactorReason, 
        /**
         * The neglected factors
         */factor: FactorSourceIdFromHash) {
        self.reason = reason
        self.factor = factor
    }
}


extension NeglectedFactor: Sendable {} 
extension NeglectedFactor: Equatable, Hashable {
    public static func ==(lhs: NeglectedFactor, rhs: NeglectedFactor) -> Bool {
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.factor != rhs.factor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(reason)
        hasher.combine(factor)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNeglectedFactor: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NeglectedFactor {
        return
            try NeglectedFactor(
                reason: FfiConverterTypeNeglectFactorReason.read(from: &buf), 
                factor: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
        )
    }

    public static func write(_ value: NeglectedFactor, into buf: inout [UInt8]) {
        FfiConverterTypeNeglectFactorReason.write(value.reason, into: &buf)
        FfiConverterTypeFactorSourceIDFromHash.write(value.factor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNeglectedFactor_lift(_ buf: RustBuffer) throws -> NeglectedFactor {
    return try FfiConverterTypeNeglectedFactor.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNeglectedFactor_lower(_ value: NeglectedFactor) -> RustBuffer {
    return FfiConverterTypeNeglectedFactor.lower(value)
}


/**
 * A version of the Radix Network, for a NetworkID with an identifier (name) and display description (display name)
 */
public struct NetworkDefinition {
    /**
     * A String identifier (always lowercase) with the name of the Network that MUST match what Gateway returns.
     */
    public var logicalName: String
    /**
     * The canonical identifier of this network.
     */
    public var id: NetworkId
    /**
     * A name of the network intended for display purposes only.
     */
    public var displayDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A String identifier (always lowercase) with the name of the Network that MUST match what Gateway returns.
         */logicalName: String, 
        /**
         * The canonical identifier of this network.
         */id: NetworkId, 
        /**
         * A name of the network intended for display purposes only.
         */displayDescription: String) {
        self.logicalName = logicalName
        self.id = id
        self.displayDescription = displayDescription
    }
}


extension NetworkDefinition: Sendable {} 
extension NetworkDefinition: Equatable, Hashable {
    public static func ==(lhs: NetworkDefinition, rhs: NetworkDefinition) -> Bool {
        if lhs.logicalName != rhs.logicalName {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.displayDescription != rhs.displayDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(logicalName)
        hasher.combine(id)
        hasher.combine(displayDescription)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetworkDefinition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkDefinition {
        return
            try NetworkDefinition(
                logicalName: FfiConverterString.read(from: &buf), 
                id: FfiConverterTypeNetworkID.read(from: &buf), 
                displayDescription: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NetworkDefinition, into buf: inout [UInt8]) {
        FfiConverterString.write(value.logicalName, into: &buf)
        FfiConverterTypeNetworkID.write(value.id, into: &buf)
        FfiConverterString.write(value.displayDescription, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkDefinition_lift(_ buf: RustBuffer) throws -> NetworkDefinition {
    return try FfiConverterTypeNetworkDefinition.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkDefinition_lower(_ value: NetworkDefinition) -> RustBuffer {
    return FfiConverterTypeNetworkDefinition.lower(value)
}


public struct NetworkRequest {
    public var url: Url
    public var method: NetworkMethod
    public var headers: [String: String]
    public var body: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: Url, method: NetworkMethod, headers: [String: String], body: BagOfBytes) {
        self.url = url
        self.method = method
        self.headers = headers
        self.body = body
    }
}


extension NetworkRequest: Sendable {} 
extension NetworkRequest: Equatable, Hashable {
    public static func ==(lhs: NetworkRequest, rhs: NetworkRequest) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(method)
        hasher.combine(headers)
        hasher.combine(body)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetworkRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkRequest {
        return
            try NetworkRequest(
                url: FfiConverterTypeUrl.read(from: &buf), 
                method: FfiConverterTypeNetworkMethod.read(from: &buf), 
                headers: FfiConverterDictionaryStringString.read(from: &buf), 
                body: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: NetworkRequest, into buf: inout [UInt8]) {
        FfiConverterTypeUrl.write(value.url, into: &buf)
        FfiConverterTypeNetworkMethod.write(value.method, into: &buf)
        FfiConverterDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterTypeBagOfBytes.write(value.body, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkRequest_lift(_ buf: RustBuffer) throws -> NetworkRequest {
    return try FfiConverterTypeNetworkRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkRequest_lower(_ value: NetworkRequest) -> RustBuffer {
    return FfiConverterTypeNetworkRequest.lower(value)
}


public struct NetworkResponse {
    public var statusCode: UInt16
    /**
     * Can be empty.
     */
    public var body: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(statusCode: UInt16, 
        /**
         * Can be empty.
         */body: BagOfBytes) {
        self.statusCode = statusCode
        self.body = body
    }
}


extension NetworkResponse: Sendable {} 
extension NetworkResponse: Equatable, Hashable {
    public static func ==(lhs: NetworkResponse, rhs: NetworkResponse) -> Bool {
        if lhs.statusCode != rhs.statusCode {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(statusCode)
        hasher.combine(body)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetworkResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkResponse {
        return
            try NetworkResponse(
                statusCode: FfiConverterUInt16.read(from: &buf), 
                body: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: NetworkResponse, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.statusCode, into: &buf)
        FfiConverterTypeBagOfBytes.write(value.body, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkResponse_lift(_ buf: RustBuffer) throws -> NetworkResponse {
    return try FfiConverterTypeNetworkResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkResponse_lower(_ value: NetworkResponse) -> RustBuffer {
    return FfiConverterTypeNetworkResponse.lower(value)
}


/**
 * Information on the global entities created in the transaction.
 */
public struct NewEntities {
    public var metadata: [ResourceAddress: NewlyCreatedResource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(metadata: [ResourceAddress: NewlyCreatedResource]) {
        self.metadata = metadata
    }
}


extension NewEntities: Sendable {} 
extension NewEntities: Equatable, Hashable {
    public static func ==(lhs: NewEntities, rhs: NewEntities) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNewEntities: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewEntities {
        return
            try NewEntities(
                metadata: FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource.read(from: &buf)
        )
    }

    public static func write(_ value: NewEntities, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource.write(value.metadata, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNewEntities_lift(_ buf: RustBuffer) throws -> NewEntities {
    return try FfiConverterTypeNewEntities.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNewEntities_lower(_ value: NewEntities) -> RustBuffer {
    return FfiConverterTypeNewEntities.lower(value)
}


/**
 * Metadata about a newly created Resource
 */
public struct NewlyCreatedResource {
    public var name: String?
    public var symbol: String?
    public var description: String?
    public var iconUrl: String?
    public var tags: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String?, symbol: String?, description: String?, iconUrl: String?, tags: [String]) {
        self.name = name
        self.symbol = symbol
        self.description = description
        self.iconUrl = iconUrl
        self.tags = tags
    }
}


extension NewlyCreatedResource: Sendable {} 
extension NewlyCreatedResource: Equatable, Hashable {
    public static func ==(lhs: NewlyCreatedResource, rhs: NewlyCreatedResource) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.iconUrl != rhs.iconUrl {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(symbol)
        hasher.combine(description)
        hasher.combine(iconUrl)
        hasher.combine(tags)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNewlyCreatedResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewlyCreatedResource {
        return
            try NewlyCreatedResource(
                name: FfiConverterOptionString.read(from: &buf), 
                symbol: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                iconUrl: FfiConverterOptionString.read(from: &buf), 
                tags: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: NewlyCreatedResource, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.symbol, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.iconUrl, into: &buf)
        FfiConverterSequenceString.write(value.tags, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNewlyCreatedResource_lift(_ buf: RustBuffer) throws -> NewlyCreatedResource {
    return try FfiConverterTypeNewlyCreatedResource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNewlyCreatedResource_lower(_ value: NewlyCreatedResource) -> RustBuffer {
    return FfiConverterTypeNewlyCreatedResource.lower(value)
}


/**
 * 32 bytes, typically used as entropy for Mnemonics.
 */
public struct NonEmptyMax32Bytes {
    public var bagOfBytes: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bagOfBytes: BagOfBytes) {
        self.bagOfBytes = bagOfBytes
    }
}


extension NonEmptyMax32Bytes: Sendable {} 
extension NonEmptyMax32Bytes: Equatable, Hashable {
    public static func ==(lhs: NonEmptyMax32Bytes, rhs: NonEmptyMax32Bytes) -> Bool {
        if lhs.bagOfBytes != rhs.bagOfBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bagOfBytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNonEmptyMax32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonEmptyMax32Bytes {
        return
            try NonEmptyMax32Bytes(
                bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: NonEmptyMax32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonEmptyMax32Bytes_lift(_ buf: RustBuffer) throws -> NonEmptyMax32Bytes {
    return try FfiConverterTypeNonEmptyMax32Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonEmptyMax32Bytes_lower(_ value: NonEmptyMax32Bytes) -> RustBuffer {
    return FfiConverterTypeNonEmptyMax32Bytes.lower(value)
}


/**
 * 64 bytes, typically used by NonFungibleLocalId::Bytes
 */
public struct NonEmptyMax64Bytes {
    public var bagOfBytes: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bagOfBytes: BagOfBytes) {
        self.bagOfBytes = bagOfBytes
    }
}


extension NonEmptyMax64Bytes: Sendable {} 
extension NonEmptyMax64Bytes: Equatable, Hashable {
    public static func ==(lhs: NonEmptyMax64Bytes, rhs: NonEmptyMax64Bytes) -> Bool {
        if lhs.bagOfBytes != rhs.bagOfBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bagOfBytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNonEmptyMax64Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonEmptyMax64Bytes {
        return
            try NonEmptyMax64Bytes(
                bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: NonEmptyMax64Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonEmptyMax64Bytes_lift(_ buf: RustBuffer) throws -> NonEmptyMax64Bytes {
    return try FfiConverterTypeNonEmptyMax64Bytes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonEmptyMax64Bytes_lower(_ value: NonEmptyMax64Bytes) -> RustBuffer {
    return FfiConverterTypeNonEmptyMax64Bytes.lower(value)
}


public struct NonFungibleGlobalId {
    public var resourceAddress: ResourceAddress
    public var nonFungibleLocalId: NonFungibleLocalId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: ResourceAddress, nonFungibleLocalId: NonFungibleLocalId) {
        self.resourceAddress = resourceAddress
        self.nonFungibleLocalId = nonFungibleLocalId
    }
}


extension NonFungibleGlobalId: Sendable {} 
extension NonFungibleGlobalId: Equatable, Hashable {
    public static func ==(lhs: NonFungibleGlobalId, rhs: NonFungibleGlobalId) -> Bool {
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.nonFungibleLocalId != rhs.nonFungibleLocalId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resourceAddress)
        hasher.combine(nonFungibleLocalId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNonFungibleGlobalId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleGlobalId {
        return
            try NonFungibleGlobalId(
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), 
                nonFungibleLocalId: FfiConverterTypeNonFungibleLocalId.read(from: &buf)
        )
    }

    public static func write(_ value: NonFungibleGlobalId, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeNonFungibleLocalId.write(value.nonFungibleLocalId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonFungibleGlobalId_lift(_ buf: RustBuffer) throws -> NonFungibleGlobalId {
    return try FfiConverterTypeNonFungibleGlobalId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonFungibleGlobalId_lower(_ value: NonFungibleGlobalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleGlobalId.lower(value)
}


/**
 * A string matching `[_0-9a-zA-Z]{1,64}`.
 *
 * This is an internal wrapping of Scrypto's `StringNonFungibleLocalId`
 * with a UniFFI custom converter using `String` as `Builtin`.
 *
 * Using this type instead of `String` directly in `NonFungibleLocalId::Str`,
 * allows us to do impl `From<NonFungibleLocalId> for NonFungibleLocalId` instead
 * of `TryFrom<NonFungibleLocalId>`.
 */
public struct NonFungibleLocalIdString {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension NonFungibleLocalIdString: Sendable {} 
extension NonFungibleLocalIdString: Equatable, Hashable {
    public static func ==(lhs: NonFungibleLocalIdString, rhs: NonFungibleLocalIdString) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNonFungibleLocalIdString: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalIdString {
        return
            try NonFungibleLocalIdString(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NonFungibleLocalIdString, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonFungibleLocalIdString_lift(_ buf: RustBuffer) throws -> NonFungibleLocalIdString {
    return try FfiConverterTypeNonFungibleLocalIdString.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonFungibleLocalIdString_lower(_ value: NonFungibleLocalIdString) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalIdString.lower(value)
}


/**
 * NonFungibleResourceAddress is a specialized ResourceAddress for resources
 * which are non fungible, it ALWAYS has an `'n'` after bech32 separator `'1'`, e.g.:
 * `"resource_rdx1nfyg2f68jw7hfdlg5hzvd8ylsa7e0kjl68t5t62v3ttamtejc9wlxa"`.
 *
 * As opposed to a fungible resource address, e.g. that of XRD which has `'t'`
 * after bech32 separator `'1'`, see:
 * `"resource_rdx1tknxxxxxxxxxradxrdxxxxxxxxx009923554798xxxxxxxxxradxrd"`
 *
 * This means that given an instance of `NonFungibleResourceAddress`, it is
 * guaranteed that its entity type is [`::GlobalNonFungibleResourceManager`],
 * and not `::GlobalFungibleResourceManager`.
 *
 * This type can safely be used with [`StakeClaim`]s, unfortunately since Radix Engine
 * and/or network does not validate the resource address of a `NonFungibleGlobalId`,
 * we cannot use this for that type.
 */
public struct NonFungibleResourceAddress {
    public var value: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: ResourceAddress) {
        self.value = value
    }
}


extension NonFungibleResourceAddress: Sendable {} 
extension NonFungibleResourceAddress: Equatable, Hashable {
    public static func ==(lhs: NonFungibleResourceAddress, rhs: NonFungibleResourceAddress) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNonFungibleResourceAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleResourceAddress {
        return
            try NonFungibleResourceAddress(
                value: FfiConverterTypeResourceAddress.read(from: &buf)
        )
    }

    public static func write(_ value: NonFungibleResourceAddress, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonFungibleResourceAddress_lift(_ buf: RustBuffer) throws -> NonFungibleResourceAddress {
    return try FfiConverterTypeNonFungibleResourceAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonFungibleResourceAddress_lower(_ value: NonFungibleResourceAddress) -> RustBuffer {
    return FfiConverterTypeNonFungibleResourceAddress.lower(value)
}


public struct Nonce {
    fileprivate let secretMagic: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: UInt32) {
        self.secretMagic = secretMagic
    }
}


extension Nonce: Sendable {} 
extension Nonce: Equatable, Hashable {
    public static func ==(lhs: Nonce, rhs: Nonce) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNonce: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nonce {
        return
            try Nonce(
                secretMagic: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Nonce, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonce_lift(_ buf: RustBuffer) throws -> Nonce {
    return try FfiConverterTypeNonce.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonce_lower(_ value: Nonce) -> RustBuffer {
    return FfiConverterTypeNonce.lower(value)
}


public struct NotarizedTransaction {
    public var signedIntent: SignedIntent
    public var notarySignature: NotarySignature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signedIntent: SignedIntent, notarySignature: NotarySignature) {
        self.signedIntent = signedIntent
        self.notarySignature = notarySignature
    }
}


extension NotarizedTransaction: Sendable {} 
extension NotarizedTransaction: Equatable, Hashable {
    public static func ==(lhs: NotarizedTransaction, rhs: NotarizedTransaction) -> Bool {
        if lhs.signedIntent != rhs.signedIntent {
            return false
        }
        if lhs.notarySignature != rhs.notarySignature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signedIntent)
        hasher.combine(notarySignature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotarizedTransaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarizedTransaction {
        return
            try NotarizedTransaction(
                signedIntent: FfiConverterTypeSignedIntent.read(from: &buf), 
                notarySignature: FfiConverterTypeNotarySignature.read(from: &buf)
        )
    }

    public static func write(_ value: NotarizedTransaction, into buf: inout [UInt8]) {
        FfiConverterTypeSignedIntent.write(value.signedIntent, into: &buf)
        FfiConverterTypeNotarySignature.write(value.notarySignature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotarizedTransaction_lift(_ buf: RustBuffer) throws -> NotarizedTransaction {
    return try FfiConverterTypeNotarizedTransaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotarizedTransaction_lower(_ value: NotarizedTransaction) -> RustBuffer {
    return FfiConverterTypeNotarizedTransaction.lower(value)
}


public struct NotarySignature {
    fileprivate let secretMagic: Signature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Signature) {
        self.secretMagic = secretMagic
    }
}


extension NotarySignature: Sendable {} 
extension NotarySignature: Equatable, Hashable {
    public static func ==(lhs: NotarySignature, rhs: NotarySignature) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotarySignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarySignature {
        return
            try NotarySignature(
                secretMagic: FfiConverterTypeSignature.read(from: &buf)
        )
    }

    public static func write(_ value: NotarySignature, into buf: inout [UInt8]) {
        FfiConverterTypeSignature.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotarySignature_lift(_ buf: RustBuffer) throws -> NotarySignature {
    return try FfiConverterTypeNotarySignature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotarySignature_lower(_ value: NotarySignature) -> RustBuffer {
    return FfiConverterTypeNotarySignature.lower(value)
}


/**
 * A factor source representing a Mnemonic the user has to input every time
 * the use the factor source, since it is not saved on the device, it is said
 * to be "off device".
 */
public struct OffDeviceMnemonicFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a OffDeviceMnemonicFactorSource to help user
     * disambiguate between it and another one.
     */
    public var hint: OffDeviceMnemonicHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic.
         */id: FactorSourceIdFromHash, 
        /**
         * Common properties shared between FactorSources of different kinds,
         * describing its state, when added, and supported cryptographic parameters.
         */common: FactorSourceCommon, 
        /**
         * Properties describing a OffDeviceMnemonicFactorSource to help user
         * disambiguate between it and another one.
         */hint: OffDeviceMnemonicHint) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}


extension OffDeviceMnemonicFactorSource: Sendable {} 
extension OffDeviceMnemonicFactorSource: Equatable, Hashable {
    public static func ==(lhs: OffDeviceMnemonicFactorSource, rhs: OffDeviceMnemonicFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOffDeviceMnemonicFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OffDeviceMnemonicFactorSource {
        return
            try OffDeviceMnemonicFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf), 
                hint: FfiConverterTypeOffDeviceMnemonicHint.read(from: &buf)
        )
    }

    public static func write(_ value: OffDeviceMnemonicFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeOffDeviceMnemonicHint.write(value.hint, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOffDeviceMnemonicFactorSource_lift(_ buf: RustBuffer) throws -> OffDeviceMnemonicFactorSource {
    return try FfiConverterTypeOffDeviceMnemonicFactorSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOffDeviceMnemonicFactorSource_lower(_ value: OffDeviceMnemonicFactorSource) -> RustBuffer {
    return FfiConverterTypeOffDeviceMnemonicFactorSource.lower(value)
}


/**
 * Properties describing a DeviceFactorSource to help user disambiguate between
 * it and another one.
 */
public struct OffDeviceMnemonicHint {
    /**
     * A user-assigned name for the passphrase, intended to help users
     * differentiate between multiple passphrases.
     */
    public var label: DisplayName
    /**
     * The number of words the `OffDeviceMnemonic`, intended to help the host provide the correct
     * input form for validation when the user enters the words.
     */
    public var wordCount: Bip39WordCount

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A user-assigned name for the passphrase, intended to help users
         * differentiate between multiple passphrases.
         */label: DisplayName, 
        /**
         * The number of words the `OffDeviceMnemonic`, intended to help the host provide the correct
         * input form for validation when the user enters the words.
         */wordCount: Bip39WordCount) {
        self.label = label
        self.wordCount = wordCount
    }
}


extension OffDeviceMnemonicHint: Sendable {} 
extension OffDeviceMnemonicHint: Equatable, Hashable {
    public static func ==(lhs: OffDeviceMnemonicHint, rhs: OffDeviceMnemonicHint) -> Bool {
        if lhs.label != rhs.label {
            return false
        }
        if lhs.wordCount != rhs.wordCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(label)
        hasher.combine(wordCount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOffDeviceMnemonicHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OffDeviceMnemonicHint {
        return
            try OffDeviceMnemonicHint(
                label: FfiConverterTypeDisplayName.read(from: &buf), 
                wordCount: FfiConverterTypeBIP39WordCount.read(from: &buf)
        )
    }

    public static func write(_ value: OffDeviceMnemonicHint, into buf: inout [UInt8]) {
        FfiConverterTypeDisplayName.write(value.label, into: &buf)
        FfiConverterTypeBIP39WordCount.write(value.wordCount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOffDeviceMnemonicHint_lift(_ buf: RustBuffer) throws -> OffDeviceMnemonicHint {
    return try FfiConverterTypeOffDeviceMnemonicHint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOffDeviceMnemonicHint_lower(_ value: OffDeviceMnemonicHint) -> RustBuffer {
    return FfiConverterTypeOffDeviceMnemonicHint.lower(value)
}


/**
 * Account settings that user has set on the account component
 * On-Ledger, that is set via a transaction mutating the state
 * on the network.
 *
 * This settings include third-party deposits, controlling who
 * can send which assets to this account.
 *
 * These settings SHOULD be kept in sync between local state
 * (in Profile) and On-Ledger.
 */
public struct OnLedgerSettings {
    /**
     * Controls the ability of third-parties to deposit into this account
     */
    public var thirdPartyDeposits: ThirdPartyDeposits

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Controls the ability of third-parties to deposit into this account
         */thirdPartyDeposits: ThirdPartyDeposits) {
        self.thirdPartyDeposits = thirdPartyDeposits
    }
}


extension OnLedgerSettings: Sendable {} 
extension OnLedgerSettings: Equatable, Hashable {
    public static func ==(lhs: OnLedgerSettings, rhs: OnLedgerSettings) -> Bool {
        if lhs.thirdPartyDeposits != rhs.thirdPartyDeposits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thirdPartyDeposits)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOnLedgerSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnLedgerSettings {
        return
            try OnLedgerSettings(
                thirdPartyDeposits: FfiConverterTypeThirdPartyDeposits.read(from: &buf)
        )
    }

    public static func write(_ value: OnLedgerSettings, into buf: inout [UInt8]) {
        FfiConverterTypeThirdPartyDeposits.write(value.thirdPartyDeposits, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnLedgerSettings_lift(_ buf: RustBuffer) throws -> OnLedgerSettings {
    return try FfiConverterTypeOnLedgerSettings.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOnLedgerSettings_lower(_ value: OnLedgerSettings) -> RustBuffer {
    return FfiConverterTypeOnLedgerSettings.lower(value)
}


/**
 * Concrete implementation of `sargon::Owned<HierarchicalDeterministicFactorInstance>`.
 */
public struct OwnedFactorInstance {
    /**
     * The known owner - an account or persona - of `value`.
     */
    public var owner: AddressOfAccountOrPersona
    /**
     * An HD Factor Instance known to be owned by `owner` - an account or persona.
     */
    public var factorInstance: HierarchicalDeterministicFactorInstance

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The known owner - an account or persona - of `value`.
         */owner: AddressOfAccountOrPersona, 
        /**
         * An HD Factor Instance known to be owned by `owner` - an account or persona.
         */factorInstance: HierarchicalDeterministicFactorInstance) {
        self.owner = owner
        self.factorInstance = factorInstance
    }
}


extension OwnedFactorInstance: Sendable {} 
extension OwnedFactorInstance: Equatable, Hashable {
    public static func ==(lhs: OwnedFactorInstance, rhs: OwnedFactorInstance) -> Bool {
        if lhs.owner != rhs.owner {
            return false
        }
        if lhs.factorInstance != rhs.factorInstance {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(owner)
        hasher.combine(factorInstance)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOwnedFactorInstance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OwnedFactorInstance {
        return
            try OwnedFactorInstance(
                owner: FfiConverterTypeAddressOfAccountOrPersona.read(from: &buf), 
                factorInstance: FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
        )
    }

    public static func write(_ value: OwnedFactorInstance, into buf: inout [UInt8]) {
        FfiConverterTypeAddressOfAccountOrPersona.write(value.owner, into: &buf)
        FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value.factorInstance, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOwnedFactorInstance_lift(_ buf: RustBuffer) throws -> OwnedFactorInstance {
    return try FfiConverterTypeOwnedFactorInstance.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOwnedFactorInstance_lower(_ value: OwnedFactorInstance) -> RustBuffer {
    return FfiConverterTypeOwnedFactorInstance.lower(value)
}


/**
 * A client the user have connected P2P with, typically a WebRTC connection with the dApp or Connector Extension.
 * Each client generates a curve25119 keypair. The public key is used as an identifier for the client.
 * The hash of the connection password is used to establish the P2P connection.
 * There can be multiple types of links (trusted vs untrusted) differentiated by `RadixConnectPurpose`.
 * Here are the [CAP-36][doc] requirements.
 *
 * [doc]: https://radixdlt.atlassian.net/wiki/spaces/AT/pages/3251863610/CAP-36+WebRTC+Clients+Protocol
 */
public struct P2pLink {
    /**
     * The most important property of this struct, the `RadixConnectPassword`,
     * is used to be able to re-establish the P2P connection
     */
    public var connectionPassword: RadixConnectPassword
    /**
     * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
     * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
     * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
     */
    public var connectionPurpose: RadixConnectPurpose
    /**
     * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
     * Each client keeps a record of linked clients' public keys to prevent duplicate links.
     * This is the public key of the other client and it also serves as the seed for the link `ID`.
     */
    public var publicKey: Ed25519PublicKey
    /**
     * Client name, e.g. "Chrome on Macbook" or "My work Android" or "My wifes iPhone SE".
     */
    public var displayName: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The most important property of this struct, the `RadixConnectPassword`,
         * is used to be able to re-establish the P2P connection
         */connectionPassword: RadixConnectPassword, 
        /**
         * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
         * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
         * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
         */connectionPurpose: RadixConnectPurpose, 
        /**
         * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
         * Each client keeps a record of linked clients' public keys to prevent duplicate links.
         * This is the public key of the other client and it also serves as the seed for the link `ID`.
         */publicKey: Ed25519PublicKey, 
        /**
         * Client name, e.g. "Chrome on Macbook" or "My work Android" or "My wifes iPhone SE".
         */displayName: String) {
        self.connectionPassword = connectionPassword
        self.connectionPurpose = connectionPurpose
        self.publicKey = publicKey
        self.displayName = displayName
    }
}


extension P2pLink: Sendable {} 
extension P2pLink: Equatable, Hashable {
    public static func ==(lhs: P2pLink, rhs: P2pLink) -> Bool {
        if lhs.connectionPassword != rhs.connectionPassword {
            return false
        }
        if lhs.connectionPurpose != rhs.connectionPurpose {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(connectionPassword)
        hasher.combine(connectionPurpose)
        hasher.combine(publicKey)
        hasher.combine(displayName)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeP2PLink: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> P2pLink {
        return
            try P2pLink(
                connectionPassword: FfiConverterTypeRadixConnectPassword.read(from: &buf), 
                connectionPurpose: FfiConverterTypeRadixConnectPurpose.read(from: &buf), 
                publicKey: FfiConverterTypeEd25519PublicKey.read(from: &buf), 
                displayName: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: P2pLink, into buf: inout [UInt8]) {
        FfiConverterTypeRadixConnectPassword.write(value.connectionPassword, into: &buf)
        FfiConverterTypeRadixConnectPurpose.write(value.connectionPurpose, into: &buf)
        FfiConverterTypeEd25519PublicKey.write(value.publicKey, into: &buf)
        FfiConverterString.write(value.displayName, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeP2PLink_lift(_ buf: RustBuffer) throws -> P2pLink {
    return try FfiConverterTypeP2PLink.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeP2PLink_lower(_ value: P2pLink) -> RustBuffer {
    return FfiConverterTypeP2PLink.lower(value)
}


/**
 * The unique address identifying a package - which is a collection of blueprints on Ledger, e.g.:
 * `"package_rdx1pkgxxxxxxxxxfaucetxxxxxxxxx000034355863xxxxxxxxxfaucet"`
 *
 * PackageAddress has [Scrypto's `EntityType`][entt] type `GlobalPackage`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalPackageAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L241C29-L241C42
 */
public struct PackageAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension PackageAddress: Sendable {} 
extension PackageAddress: Equatable, Hashable {
    public static func ==(lhs: PackageAddress, rhs: PackageAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePackageAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PackageAddress {
        return
            try PackageAddress(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PackageAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePackageAddress_lift(_ buf: RustBuffer) throws -> PackageAddress {
    return try FfiConverterTypePackageAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePackageAddress_lower(_ value: PackageAddress) -> RustBuffer {
    return FfiConverterTypePackageAddress.lower(value)
}


/**
 * NOT IMPLEMENTED NOR USED YET
 *
 * A password based FactorSource is essentially a Input Key Material based Mnemonic,
 * user needs to input the password - key material - every time they use this factor source
 */
public struct PasswordFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a PasswordFactorSource to help user
     * disambiguate between it and another one.
     */
    public var hint: PasswordFactorSourceHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic.
         */id: FactorSourceIdFromHash, 
        /**
         * Common properties shared between FactorSources of different kinds,
         * describing its state, when added, and supported cryptographic parameters.
         */common: FactorSourceCommon, 
        /**
         * Properties describing a PasswordFactorSource to help user
         * disambiguate between it and another one.
         */hint: PasswordFactorSourceHint) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}


extension PasswordFactorSource: Sendable {} 
extension PasswordFactorSource: Equatable, Hashable {
    public static func ==(lhs: PasswordFactorSource, rhs: PasswordFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePasswordFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PasswordFactorSource {
        return
            try PasswordFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf), 
                hint: FfiConverterTypePasswordFactorSourceHint.read(from: &buf)
        )
    }

    public static func write(_ value: PasswordFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypePasswordFactorSourceHint.write(value.hint, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePasswordFactorSource_lift(_ buf: RustBuffer) throws -> PasswordFactorSource {
    return try FfiConverterTypePasswordFactorSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePasswordFactorSource_lower(_ value: PasswordFactorSource) -> RustBuffer {
    return FfiConverterTypePasswordFactorSource.lower(value)
}


/**
 * Properties describing a PasswordFactorSource to help user disambiguate between
 * it and another one.
 */
public struct PasswordFactorSourceHint {
    public var label: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(label: String) {
        self.label = label
    }
}


extension PasswordFactorSourceHint: Sendable {} 
extension PasswordFactorSourceHint: Equatable, Hashable {
    public static func ==(lhs: PasswordFactorSourceHint, rhs: PasswordFactorSourceHint) -> Bool {
        if lhs.label != rhs.label {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(label)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePasswordFactorSourceHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PasswordFactorSourceHint {
        return
            try PasswordFactorSourceHint(
                label: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PasswordFactorSourceHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.label, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePasswordFactorSourceHint_lift(_ buf: RustBuffer) throws -> PasswordFactorSourceHint {
    return try FfiConverterTypePasswordFactorSourceHint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePasswordFactorSourceHint_lower(_ value: PasswordFactorSourceHint) -> RustBuffer {
    return FfiConverterTypePasswordFactorSourceHint.lower(value)
}


public struct PerAssetFungibleResource {
    public var resourceAddress: ResourceAddress
    public var divisibility: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: ResourceAddress, divisibility: UInt8?) {
        self.resourceAddress = resourceAddress
        self.divisibility = divisibility
    }
}


extension PerAssetFungibleResource: Sendable {} 
extension PerAssetFungibleResource: Equatable, Hashable {
    public static func ==(lhs: PerAssetFungibleResource, rhs: PerAssetFungibleResource) -> Bool {
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.divisibility != rhs.divisibility {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resourceAddress)
        hasher.combine(divisibility)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerAssetFungibleResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetFungibleResource {
        return
            try PerAssetFungibleResource(
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), 
                divisibility: FfiConverterOptionUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: PerAssetFungibleResource, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterOptionUInt8.write(value.divisibility, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerAssetFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetFungibleResource {
    return try FfiConverterTypePerAssetFungibleResource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerAssetFungibleResource_lower(_ value: PerAssetFungibleResource) -> RustBuffer {
    return FfiConverterTypePerAssetFungibleResource.lower(value)
}


/**
 * A fungible transfer to `recipient`, with a specified amount of tokens to send.
 */
public struct PerAssetFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * Amount
     */
    public var amount: Decimal192
    /**
     * The account or account address to send the tokens to.
     */
    public var recipient: TransferRecipient

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */useTryDepositOrAbort: Bool, 
        /**
         * Amount
         */amount: Decimal192, 
        /**
         * The account or account address to send the tokens to.
         */recipient: TransferRecipient) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.amount = amount
        self.recipient = recipient
    }
}


extension PerAssetFungibleTransfer: Sendable {} 
extension PerAssetFungibleTransfer: Equatable, Hashable {
    public static func ==(lhs: PerAssetFungibleTransfer, rhs: PerAssetFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.recipient != rhs.recipient {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(amount)
        hasher.combine(recipient)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerAssetFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetFungibleTransfer {
        return
            try PerAssetFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf), 
                amount: FfiConverterTypeDecimal192.read(from: &buf), 
                recipient: FfiConverterTypeTransferRecipient.read(from: &buf)
        )
    }

    public static func write(_ value: PerAssetFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterTypeTransferRecipient.write(value.recipient, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerAssetFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerAssetFungibleTransfer {
    return try FfiConverterTypePerAssetFungibleTransfer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerAssetFungibleTransfer_lower(_ value: PerAssetFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerAssetFungibleTransfer.lower(value)
}


/**
 * A non fungible transfer to `recipient`, with specified Local IDs to send.
 */
public struct PerAssetNonFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * Amount
     */
    public var nonFungibleLocalIds: [NonFungibleLocalId]
    /**
     * The account or account address to send the tokens to.
     */
    public var recipient: TransferRecipient

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */useTryDepositOrAbort: Bool, 
        /**
         * Amount
         */nonFungibleLocalIds: [NonFungibleLocalId], 
        /**
         * The account or account address to send the tokens to.
         */recipient: TransferRecipient) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.nonFungibleLocalIds = nonFungibleLocalIds
        self.recipient = recipient
    }
}


extension PerAssetNonFungibleTransfer: Sendable {} 
extension PerAssetNonFungibleTransfer: Equatable, Hashable {
    public static func ==(lhs: PerAssetNonFungibleTransfer, rhs: PerAssetNonFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.nonFungibleLocalIds != rhs.nonFungibleLocalIds {
            return false
        }
        if lhs.recipient != rhs.recipient {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(nonFungibleLocalIds)
        hasher.combine(recipient)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerAssetNonFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetNonFungibleTransfer {
        return
            try PerAssetNonFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf), 
                nonFungibleLocalIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf), 
                recipient: FfiConverterTypeTransferRecipient.read(from: &buf)
        )
    }

    public static func write(_ value: PerAssetNonFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.nonFungibleLocalIds, into: &buf)
        FfiConverterTypeTransferRecipient.write(value.recipient, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerAssetNonFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerAssetNonFungibleTransfer {
    return try FfiConverterTypePerAssetNonFungibleTransfer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerAssetNonFungibleTransfer_lower(_ value: PerAssetNonFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerAssetNonFungibleTransfer.lower(value)
}


public struct PerAssetTransfers {
    public var fromAccount: AccountAddress
    public var fungibleResources: [PerAssetTransfersOfFungibleResource]
    public var nonFungibleResources: [PerAssetTransfersOfNonFungibleResource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fromAccount: AccountAddress, fungibleResources: [PerAssetTransfersOfFungibleResource], nonFungibleResources: [PerAssetTransfersOfNonFungibleResource]) {
        self.fromAccount = fromAccount
        self.fungibleResources = fungibleResources
        self.nonFungibleResources = nonFungibleResources
    }
}


extension PerAssetTransfers: Sendable {} 
extension PerAssetTransfers: Equatable, Hashable {
    public static func ==(lhs: PerAssetTransfers, rhs: PerAssetTransfers) -> Bool {
        if lhs.fromAccount != rhs.fromAccount {
            return false
        }
        if lhs.fungibleResources != rhs.fungibleResources {
            return false
        }
        if lhs.nonFungibleResources != rhs.nonFungibleResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fromAccount)
        hasher.combine(fungibleResources)
        hasher.combine(nonFungibleResources)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerAssetTransfers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfers {
        return
            try PerAssetTransfers(
                fromAccount: FfiConverterTypeAccountAddress.read(from: &buf), 
                fungibleResources: FfiConverterSequenceTypePerAssetTransfersOfFungibleResource.read(from: &buf), 
                nonFungibleResources: FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource.read(from: &buf)
        )
    }

    public static func write(_ value: PerAssetTransfers, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.fromAccount, into: &buf)
        FfiConverterSequenceTypePerAssetTransfersOfFungibleResource.write(value.fungibleResources, into: &buf)
        FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource.write(value.nonFungibleResources, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerAssetTransfers_lift(_ buf: RustBuffer) throws -> PerAssetTransfers {
    return try FfiConverterTypePerAssetTransfers.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerAssetTransfers_lower(_ value: PerAssetTransfers) -> RustBuffer {
    return FfiConverterTypePerAssetTransfers.lower(value)
}


public struct PerAssetTransfersOfFungibleResource {
    public var resource: PerAssetFungibleResource
    public var transfers: [PerAssetFungibleTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resource: PerAssetFungibleResource, transfers: [PerAssetFungibleTransfer]) {
        self.resource = resource
        self.transfers = transfers
    }
}


extension PerAssetTransfersOfFungibleResource: Sendable {} 
extension PerAssetTransfersOfFungibleResource: Equatable, Hashable {
    public static func ==(lhs: PerAssetTransfersOfFungibleResource, rhs: PerAssetTransfersOfFungibleResource) -> Bool {
        if lhs.resource != rhs.resource {
            return false
        }
        if lhs.transfers != rhs.transfers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resource)
        hasher.combine(transfers)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerAssetTransfersOfFungibleResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfersOfFungibleResource {
        return
            try PerAssetTransfersOfFungibleResource(
                resource: FfiConverterTypePerAssetFungibleResource.read(from: &buf), 
                transfers: FfiConverterSequenceTypePerAssetFungibleTransfer.read(from: &buf)
        )
    }

    public static func write(_ value: PerAssetTransfersOfFungibleResource, into buf: inout [UInt8]) {
        FfiConverterTypePerAssetFungibleResource.write(value.resource, into: &buf)
        FfiConverterSequenceTypePerAssetFungibleTransfer.write(value.transfers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerAssetTransfersOfFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetTransfersOfFungibleResource {
    return try FfiConverterTypePerAssetTransfersOfFungibleResource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerAssetTransfersOfFungibleResource_lower(_ value: PerAssetTransfersOfFungibleResource) -> RustBuffer {
    return FfiConverterTypePerAssetTransfersOfFungibleResource.lower(value)
}


public struct PerAssetTransfersOfNonFungibleResource {
    public var resource: ResourceAddress
    public var transfers: [PerAssetNonFungibleTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resource: ResourceAddress, transfers: [PerAssetNonFungibleTransfer]) {
        self.resource = resource
        self.transfers = transfers
    }
}


extension PerAssetTransfersOfNonFungibleResource: Sendable {} 
extension PerAssetTransfersOfNonFungibleResource: Equatable, Hashable {
    public static func ==(lhs: PerAssetTransfersOfNonFungibleResource, rhs: PerAssetTransfersOfNonFungibleResource) -> Bool {
        if lhs.resource != rhs.resource {
            return false
        }
        if lhs.transfers != rhs.transfers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resource)
        hasher.combine(transfers)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerAssetTransfersOfNonFungibleResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfersOfNonFungibleResource {
        return
            try PerAssetTransfersOfNonFungibleResource(
                resource: FfiConverterTypeResourceAddress.read(from: &buf), 
                transfers: FfiConverterSequenceTypePerAssetNonFungibleTransfer.read(from: &buf)
        )
    }

    public static func write(_ value: PerAssetTransfersOfNonFungibleResource, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resource, into: &buf)
        FfiConverterSequenceTypePerAssetNonFungibleTransfer.write(value.transfers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerAssetTransfersOfNonFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetTransfersOfNonFungibleResource {
    return try FfiConverterTypePerAssetTransfersOfNonFungibleResource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerAssetTransfersOfNonFungibleResource_lower(_ value: PerAssetTransfersOfNonFungibleResource) -> RustBuffer {
    return FfiConverterTypePerAssetTransfersOfNonFungibleResource.lower(value)
}


public struct PerFactorOutcomeOfAuthIntentHash {
    public var factorSourceId: FactorSourceIdFromHash
    public var outcome: FactorOutcomeOfAuthIntentHash

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceId: FactorSourceIdFromHash, outcome: FactorOutcomeOfAuthIntentHash) {
        self.factorSourceId = factorSourceId
        self.outcome = outcome
    }
}


extension PerFactorOutcomeOfAuthIntentHash: Sendable {} 
extension PerFactorOutcomeOfAuthIntentHash: Equatable, Hashable {
    public static func ==(lhs: PerFactorOutcomeOfAuthIntentHash, rhs: PerFactorOutcomeOfAuthIntentHash) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.outcome != rhs.outcome {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(outcome)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerFactorOutcomeOfAuthIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerFactorOutcomeOfAuthIntentHash {
        return
            try PerFactorOutcomeOfAuthIntentHash(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                outcome: FfiConverterTypeFactorOutcomeOfAuthIntentHash.read(from: &buf)
        )
    }

    public static func write(_ value: PerFactorOutcomeOfAuthIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterTypeFactorOutcomeOfAuthIntentHash.write(value.outcome, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerFactorOutcomeOfAuthIntentHash_lift(_ buf: RustBuffer) throws -> PerFactorOutcomeOfAuthIntentHash {
    return try FfiConverterTypePerFactorOutcomeOfAuthIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerFactorOutcomeOfAuthIntentHash_lower(_ value: PerFactorOutcomeOfAuthIntentHash) -> RustBuffer {
    return FfiConverterTypePerFactorOutcomeOfAuthIntentHash.lower(value)
}


public struct PerFactorOutcomeOfSubintentHash {
    public var factorSourceId: FactorSourceIdFromHash
    public var outcome: FactorOutcomeOfSubintentHash

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceId: FactorSourceIdFromHash, outcome: FactorOutcomeOfSubintentHash) {
        self.factorSourceId = factorSourceId
        self.outcome = outcome
    }
}


extension PerFactorOutcomeOfSubintentHash: Sendable {} 
extension PerFactorOutcomeOfSubintentHash: Equatable, Hashable {
    public static func ==(lhs: PerFactorOutcomeOfSubintentHash, rhs: PerFactorOutcomeOfSubintentHash) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.outcome != rhs.outcome {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(outcome)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerFactorOutcomeOfSubintentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerFactorOutcomeOfSubintentHash {
        return
            try PerFactorOutcomeOfSubintentHash(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                outcome: FfiConverterTypeFactorOutcomeOfSubintentHash.read(from: &buf)
        )
    }

    public static func write(_ value: PerFactorOutcomeOfSubintentHash, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterTypeFactorOutcomeOfSubintentHash.write(value.outcome, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerFactorOutcomeOfSubintentHash_lift(_ buf: RustBuffer) throws -> PerFactorOutcomeOfSubintentHash {
    return try FfiConverterTypePerFactorOutcomeOfSubintentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerFactorOutcomeOfSubintentHash_lower(_ value: PerFactorOutcomeOfSubintentHash) -> RustBuffer {
    return FfiConverterTypePerFactorOutcomeOfSubintentHash.lower(value)
}


public struct PerFactorOutcomeOfTransactionIntentHash {
    public var factorSourceId: FactorSourceIdFromHash
    public var outcome: FactorOutcomeOfTransactionIntentHash

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceId: FactorSourceIdFromHash, outcome: FactorOutcomeOfTransactionIntentHash) {
        self.factorSourceId = factorSourceId
        self.outcome = outcome
    }
}


extension PerFactorOutcomeOfTransactionIntentHash: Sendable {} 
extension PerFactorOutcomeOfTransactionIntentHash: Equatable, Hashable {
    public static func ==(lhs: PerFactorOutcomeOfTransactionIntentHash, rhs: PerFactorOutcomeOfTransactionIntentHash) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.outcome != rhs.outcome {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(outcome)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerFactorOutcomeOfTransactionIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerFactorOutcomeOfTransactionIntentHash {
        return
            try PerFactorOutcomeOfTransactionIntentHash(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                outcome: FfiConverterTypeFactorOutcomeOfTransactionIntentHash.read(from: &buf)
        )
    }

    public static func write(_ value: PerFactorOutcomeOfTransactionIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterTypeFactorOutcomeOfTransactionIntentHash.write(value.outcome, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerFactorOutcomeOfTransactionIntentHash_lift(_ buf: RustBuffer) throws -> PerFactorOutcomeOfTransactionIntentHash {
    return try FfiConverterTypePerFactorOutcomeOfTransactionIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerFactorOutcomeOfTransactionIntentHash_lower(_ value: PerFactorOutcomeOfTransactionIntentHash) -> RustBuffer {
    return FfiConverterTypePerFactorOutcomeOfTransactionIntentHash.lower(value)
}


public struct PerFactorSourceInputOfAuthIntent {
    /**
     * The factor source which the interactor should request signatures with
     */
    public var factorSourceId: FactorSourceIdFromHash
    /**
     * A set of transactions to sign, with multiple derivations paths.
     */
    public var perTransaction: [TransactionSignRequestInputOfAuthIntent]
    /**
     * A collection of transactions which would be invalid if the user skips
     * signing with this factor source.
     */
    public var invalidTransactionsIfNeglected: [InvalidTransactionIfNeglectedOfAuthIntentHash]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The factor source which the interactor should request signatures with
         */factorSourceId: FactorSourceIdFromHash, 
        /**
         * A set of transactions to sign, with multiple derivations paths.
         */perTransaction: [TransactionSignRequestInputOfAuthIntent], 
        /**
         * A collection of transactions which would be invalid if the user skips
         * signing with this factor source.
         */invalidTransactionsIfNeglected: [InvalidTransactionIfNeglectedOfAuthIntentHash]) {
        self.factorSourceId = factorSourceId
        self.perTransaction = perTransaction
        self.invalidTransactionsIfNeglected = invalidTransactionsIfNeglected
    }
}


extension PerFactorSourceInputOfAuthIntent: Sendable {} 
extension PerFactorSourceInputOfAuthIntent: Equatable, Hashable {
    public static func ==(lhs: PerFactorSourceInputOfAuthIntent, rhs: PerFactorSourceInputOfAuthIntent) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.perTransaction != rhs.perTransaction {
            return false
        }
        if lhs.invalidTransactionsIfNeglected != rhs.invalidTransactionsIfNeglected {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(perTransaction)
        hasher.combine(invalidTransactionsIfNeglected)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerFactorSourceInputOfAuthIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerFactorSourceInputOfAuthIntent {
        return
            try PerFactorSourceInputOfAuthIntent(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                perTransaction: FfiConverterSequenceTypeTransactionSignRequestInputOfAuthIntent.read(from: &buf), 
                invalidTransactionsIfNeglected: FfiConverterSequenceTypeInvalidTransactionIfNeglectedOfAuthIntentHash.read(from: &buf)
        )
    }

    public static func write(_ value: PerFactorSourceInputOfAuthIntent, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterSequenceTypeTransactionSignRequestInputOfAuthIntent.write(value.perTransaction, into: &buf)
        FfiConverterSequenceTypeInvalidTransactionIfNeglectedOfAuthIntentHash.write(value.invalidTransactionsIfNeglected, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerFactorSourceInputOfAuthIntent_lift(_ buf: RustBuffer) throws -> PerFactorSourceInputOfAuthIntent {
    return try FfiConverterTypePerFactorSourceInputOfAuthIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerFactorSourceInputOfAuthIntent_lower(_ value: PerFactorSourceInputOfAuthIntent) -> RustBuffer {
    return FfiConverterTypePerFactorSourceInputOfAuthIntent.lower(value)
}


public struct PerFactorSourceInputOfSubintent {
    /**
     * The factor source which the interactor should request signatures with
     */
    public var factorSourceId: FactorSourceIdFromHash
    /**
     * A set of transactions to sign, with multiple derivations paths.
     */
    public var perTransaction: [TransactionSignRequestInputOfSubintent]
    /**
     * A collection of transactions which would be invalid if the user skips
     * signing with this factor source.
     */
    public var invalidTransactionsIfNeglected: [InvalidTransactionIfNeglectedOfSubintentHash]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The factor source which the interactor should request signatures with
         */factorSourceId: FactorSourceIdFromHash, 
        /**
         * A set of transactions to sign, with multiple derivations paths.
         */perTransaction: [TransactionSignRequestInputOfSubintent], 
        /**
         * A collection of transactions which would be invalid if the user skips
         * signing with this factor source.
         */invalidTransactionsIfNeglected: [InvalidTransactionIfNeglectedOfSubintentHash]) {
        self.factorSourceId = factorSourceId
        self.perTransaction = perTransaction
        self.invalidTransactionsIfNeglected = invalidTransactionsIfNeglected
    }
}


extension PerFactorSourceInputOfSubintent: Sendable {} 
extension PerFactorSourceInputOfSubintent: Equatable, Hashable {
    public static func ==(lhs: PerFactorSourceInputOfSubintent, rhs: PerFactorSourceInputOfSubintent) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.perTransaction != rhs.perTransaction {
            return false
        }
        if lhs.invalidTransactionsIfNeglected != rhs.invalidTransactionsIfNeglected {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(perTransaction)
        hasher.combine(invalidTransactionsIfNeglected)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerFactorSourceInputOfSubintent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerFactorSourceInputOfSubintent {
        return
            try PerFactorSourceInputOfSubintent(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                perTransaction: FfiConverterSequenceTypeTransactionSignRequestInputOfSubintent.read(from: &buf), 
                invalidTransactionsIfNeglected: FfiConverterSequenceTypeInvalidTransactionIfNeglectedOfSubintentHash.read(from: &buf)
        )
    }

    public static func write(_ value: PerFactorSourceInputOfSubintent, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterSequenceTypeTransactionSignRequestInputOfSubintent.write(value.perTransaction, into: &buf)
        FfiConverterSequenceTypeInvalidTransactionIfNeglectedOfSubintentHash.write(value.invalidTransactionsIfNeglected, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerFactorSourceInputOfSubintent_lift(_ buf: RustBuffer) throws -> PerFactorSourceInputOfSubintent {
    return try FfiConverterTypePerFactorSourceInputOfSubintent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerFactorSourceInputOfSubintent_lower(_ value: PerFactorSourceInputOfSubintent) -> RustBuffer {
    return FfiConverterTypePerFactorSourceInputOfSubintent.lower(value)
}


public struct PerFactorSourceInputOfTransactionIntent {
    /**
     * The factor source which the interactor should request signatures with
     */
    public var factorSourceId: FactorSourceIdFromHash
    /**
     * A set of transactions to sign, with multiple derivations paths.
     */
    public var perTransaction: [TransactionSignRequestInputOfTransactionIntent]
    /**
     * A collection of transactions which would be invalid if the user skips
     * signing with this factor source.
     */
    public var invalidTransactionsIfNeglected: [InvalidTransactionIfNeglectedOfTransactionIntentHash]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The factor source which the interactor should request signatures with
         */factorSourceId: FactorSourceIdFromHash, 
        /**
         * A set of transactions to sign, with multiple derivations paths.
         */perTransaction: [TransactionSignRequestInputOfTransactionIntent], 
        /**
         * A collection of transactions which would be invalid if the user skips
         * signing with this factor source.
         */invalidTransactionsIfNeglected: [InvalidTransactionIfNeglectedOfTransactionIntentHash]) {
        self.factorSourceId = factorSourceId
        self.perTransaction = perTransaction
        self.invalidTransactionsIfNeglected = invalidTransactionsIfNeglected
    }
}


extension PerFactorSourceInputOfTransactionIntent: Sendable {} 
extension PerFactorSourceInputOfTransactionIntent: Equatable, Hashable {
    public static func ==(lhs: PerFactorSourceInputOfTransactionIntent, rhs: PerFactorSourceInputOfTransactionIntent) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.perTransaction != rhs.perTransaction {
            return false
        }
        if lhs.invalidTransactionsIfNeglected != rhs.invalidTransactionsIfNeglected {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(perTransaction)
        hasher.combine(invalidTransactionsIfNeglected)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerFactorSourceInputOfTransactionIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerFactorSourceInputOfTransactionIntent {
        return
            try PerFactorSourceInputOfTransactionIntent(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                perTransaction: FfiConverterSequenceTypeTransactionSignRequestInputOfTransactionIntent.read(from: &buf), 
                invalidTransactionsIfNeglected: FfiConverterSequenceTypeInvalidTransactionIfNeglectedOfTransactionIntentHash.read(from: &buf)
        )
    }

    public static func write(_ value: PerFactorSourceInputOfTransactionIntent, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterSequenceTypeTransactionSignRequestInputOfTransactionIntent.write(value.perTransaction, into: &buf)
        FfiConverterSequenceTypeInvalidTransactionIfNeglectedOfTransactionIntentHash.write(value.invalidTransactionsIfNeglected, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerFactorSourceInputOfTransactionIntent_lift(_ buf: RustBuffer) throws -> PerFactorSourceInputOfTransactionIntent {
    return try FfiConverterTypePerFactorSourceInputOfTransactionIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerFactorSourceInputOfTransactionIntent_lower(_ value: PerFactorSourceInputOfTransactionIntent) -> RustBuffer {
    return FfiConverterTypePerFactorSourceInputOfTransactionIntent.lower(value)
}


public struct PerRecipientAssetTransfer {
    public var recipient: TransferRecipient
    public var fungibles: [PerRecipientFungibleTransfer]
    public var nonFungibles: [PerRecipientNonFungibleTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(recipient: TransferRecipient, fungibles: [PerRecipientFungibleTransfer], nonFungibles: [PerRecipientNonFungibleTransfer]) {
        self.recipient = recipient
        self.fungibles = fungibles
        self.nonFungibles = nonFungibles
    }
}


extension PerRecipientAssetTransfer: Sendable {} 
extension PerRecipientAssetTransfer: Equatable, Hashable {
    public static func ==(lhs: PerRecipientAssetTransfer, rhs: PerRecipientAssetTransfer) -> Bool {
        if lhs.recipient != rhs.recipient {
            return false
        }
        if lhs.fungibles != rhs.fungibles {
            return false
        }
        if lhs.nonFungibles != rhs.nonFungibles {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(recipient)
        hasher.combine(fungibles)
        hasher.combine(nonFungibles)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerRecipientAssetTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientAssetTransfer {
        return
            try PerRecipientAssetTransfer(
                recipient: FfiConverterTypeTransferRecipient.read(from: &buf), 
                fungibles: FfiConverterSequenceTypePerRecipientFungibleTransfer.read(from: &buf), 
                nonFungibles: FfiConverterSequenceTypePerRecipientNonFungibleTransfer.read(from: &buf)
        )
    }

    public static func write(_ value: PerRecipientAssetTransfer, into buf: inout [UInt8]) {
        FfiConverterTypeTransferRecipient.write(value.recipient, into: &buf)
        FfiConverterSequenceTypePerRecipientFungibleTransfer.write(value.fungibles, into: &buf)
        FfiConverterSequenceTypePerRecipientNonFungibleTransfer.write(value.nonFungibles, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerRecipientAssetTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientAssetTransfer {
    return try FfiConverterTypePerRecipientAssetTransfer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerRecipientAssetTransfer_lower(_ value: PerRecipientAssetTransfer) -> RustBuffer {
    return FfiConverterTypePerRecipientAssetTransfer.lower(value)
}


public struct PerRecipientAssetTransfers {
    public var addressOfSender: AccountAddress
    public var transfers: [PerRecipientAssetTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addressOfSender: AccountAddress, transfers: [PerRecipientAssetTransfer]) {
        self.addressOfSender = addressOfSender
        self.transfers = transfers
    }
}


extension PerRecipientAssetTransfers: Sendable {} 
extension PerRecipientAssetTransfers: Equatable, Hashable {
    public static func ==(lhs: PerRecipientAssetTransfers, rhs: PerRecipientAssetTransfers) -> Bool {
        if lhs.addressOfSender != rhs.addressOfSender {
            return false
        }
        if lhs.transfers != rhs.transfers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addressOfSender)
        hasher.combine(transfers)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerRecipientAssetTransfers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientAssetTransfers {
        return
            try PerRecipientAssetTransfers(
                addressOfSender: FfiConverterTypeAccountAddress.read(from: &buf), 
                transfers: FfiConverterSequenceTypePerRecipientAssetTransfer.read(from: &buf)
        )
    }

    public static func write(_ value: PerRecipientAssetTransfers, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.addressOfSender, into: &buf)
        FfiConverterSequenceTypePerRecipientAssetTransfer.write(value.transfers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerRecipientAssetTransfers_lift(_ buf: RustBuffer) throws -> PerRecipientAssetTransfers {
    return try FfiConverterTypePerRecipientAssetTransfers.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerRecipientAssetTransfers_lower(_ value: PerRecipientAssetTransfers) -> RustBuffer {
    return FfiConverterTypePerRecipientAssetTransfers.lower(value)
}


/**
 * A fungible transfer of `resource_address` token, with a specified amount
 * of tokens and divisibility.
 */
public struct PerRecipientFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * Amount
     */
    public var amount: Decimal192
    public var divisibility: UInt8?
    /**
     * The address of the resource being sent
     */
    public var resourceAddress: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */useTryDepositOrAbort: Bool, 
        /**
         * Amount
         */amount: Decimal192, divisibility: UInt8?, 
        /**
         * The address of the resource being sent
         */resourceAddress: ResourceAddress) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.amount = amount
        self.divisibility = divisibility
        self.resourceAddress = resourceAddress
    }
}


extension PerRecipientFungibleTransfer: Sendable {} 
extension PerRecipientFungibleTransfer: Equatable, Hashable {
    public static func ==(lhs: PerRecipientFungibleTransfer, rhs: PerRecipientFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.divisibility != rhs.divisibility {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(amount)
        hasher.combine(divisibility)
        hasher.combine(resourceAddress)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerRecipientFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientFungibleTransfer {
        return
            try PerRecipientFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf), 
                amount: FfiConverterTypeDecimal192.read(from: &buf), 
                divisibility: FfiConverterOptionUInt8.read(from: &buf), 
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf)
        )
    }

    public static func write(_ value: PerRecipientFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterOptionUInt8.write(value.divisibility, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerRecipientFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientFungibleTransfer {
    return try FfiConverterTypePerRecipientFungibleTransfer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerRecipientFungibleTransfer_lower(_ value: PerRecipientFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerRecipientFungibleTransfer.lower(value)
}


/**
 * A non fungible transfer of `resource_address` token, with specified Local IDs to send.
 */
public struct PerRecipientNonFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * The local IDS of the NonFungible tokens being sent
     */
    public var localIds: [NonFungibleLocalId]
    /**
     * The address of the resource being sent
     */
    public var resourceAddress: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */useTryDepositOrAbort: Bool, 
        /**
         * The local IDS of the NonFungible tokens being sent
         */localIds: [NonFungibleLocalId], 
        /**
         * The address of the resource being sent
         */resourceAddress: ResourceAddress) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.localIds = localIds
        self.resourceAddress = resourceAddress
    }
}


extension PerRecipientNonFungibleTransfer: Sendable {} 
extension PerRecipientNonFungibleTransfer: Equatable, Hashable {
    public static func ==(lhs: PerRecipientNonFungibleTransfer, rhs: PerRecipientNonFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.localIds != rhs.localIds {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(localIds)
        hasher.combine(resourceAddress)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePerRecipientNonFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientNonFungibleTransfer {
        return
            try PerRecipientNonFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf), 
                localIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf), 
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf)
        )
    }

    public static func write(_ value: PerRecipientNonFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.localIds, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerRecipientNonFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientNonFungibleTransfer {
    return try FfiConverterTypePerRecipientNonFungibleTransfer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePerRecipientNonFungibleTransfer_lower(_ value: PerRecipientNonFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerRecipientNonFungibleTransfer.lower(value)
}


/**
 * A Persona is an identity a user chooses to login to a dApp with, using
 * RadixConnect - Radix decentralized login solution. A persona is very
 * similar to [`Account`]s, in the sense that they are On-Network/On-Ledger
 * components, with a unique network dependent address ([`IdentityAddress`])
 * and with a security state (see [`EntitySecurityState`]) knowing which
 * factor instances that control this component, but with one important
 * difference: a Persona cannot hold funds. It is impossible to transfer
 * any asset to a Persona. The On-Network component representation of
 * the Persona is called `Identity`. The concept "Persona" is a Radix
 * Wallet (Profile) *application* of an Identity.
 *
 * Personas have data (see [`PersonaData`]), which is personal information
 * a user has associated with a this Persona, of different kinds, such as name,
 * email address(es) or phone number(s). The `PersonaData` is **never** uploaded
 * to the Radix Network, i.e. it is a pure Radix Wallet (Profile) construct,
 * On-Network Identities does not know of PersonaData, and never will (well
 * technically, nothing stops a user from building their own wallet and uploading
 * personal information to the metadata of the Identity component... but `Sargon`
 * never will, nor will the Radix Wallet.).
 */
public struct Persona {
    /**
     * The ID of the network this account can be used with.
     */
    public var networkId: NetworkId
    /**
     * The address of an identity, used by Personas, a bech32 encoding of a public key hash
     * that starts with the prefix `"identity_"`, dependent on NetworkID, meaning the same
     * public key used for two IdentityAddresses on two different networks will not have
     * the same address.
     */
    public var address: IdentityAddress
    /**
     * An off-ledger display name or description chosen by the user when they
     * created this persona.
     */
    public var displayName: DisplayName
    /**
     * Describes the state this Persona is in, in regards to how
     * the user controls it, i.e. if it is controlled by a single factor (private key)
     * or an `AccessController` with a potential Multi-Factor setup.
     */
    public var securityState: EntitySecurityState
    /**
     * An order set of `EntityFlag`s used to describe certain Off-ledger
     * user state about this Persona, e.g. if it is marked as hidden or not.
     */
    public var flags: [EntityFlag]
    /**
     * Personal information a user has associated with a certain Persona, of different kinds, such as name,
     * email address(es) or phone number(s). This information is only ever stored in Profile and is never
     * uploaded to the Radix Network.
     */
    public var personaData: PersonaData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network this account can be used with.
         */networkId: NetworkId, 
        /**
         * The address of an identity, used by Personas, a bech32 encoding of a public key hash
         * that starts with the prefix `"identity_"`, dependent on NetworkID, meaning the same
         * public key used for two IdentityAddresses on two different networks will not have
         * the same address.
         */address: IdentityAddress, 
        /**
         * An off-ledger display name or description chosen by the user when they
         * created this persona.
         */displayName: DisplayName, 
        /**
         * Describes the state this Persona is in, in regards to how
         * the user controls it, i.e. if it is controlled by a single factor (private key)
         * or an `AccessController` with a potential Multi-Factor setup.
         */securityState: EntitySecurityState, 
        /**
         * An order set of `EntityFlag`s used to describe certain Off-ledger
         * user state about this Persona, e.g. if it is marked as hidden or not.
         */flags: [EntityFlag], 
        /**
         * Personal information a user has associated with a certain Persona, of different kinds, such as name,
         * email address(es) or phone number(s). This information is only ever stored in Profile and is never
         * uploaded to the Radix Network.
         */personaData: PersonaData) {
        self.networkId = networkId
        self.address = address
        self.displayName = displayName
        self.securityState = securityState
        self.flags = flags
        self.personaData = personaData
    }
}


extension Persona: Sendable {} 
extension Persona: Equatable, Hashable {
    public static func ==(lhs: Persona, rhs: Persona) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.securityState != rhs.securityState {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        if lhs.personaData != rhs.personaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(securityState)
        hasher.combine(flags)
        hasher.combine(personaData)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersona: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Persona {
        return
            try Persona(
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                address: FfiConverterTypeIdentityAddress.read(from: &buf), 
                displayName: FfiConverterTypeDisplayName.read(from: &buf), 
                securityState: FfiConverterTypeEntitySecurityState.read(from: &buf), 
                flags: FfiConverterSequenceTypeEntityFlag.read(from: &buf), 
                personaData: FfiConverterTypePersonaData.read(from: &buf)
        )
    }

    public static func write(_ value: Persona, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeIdentityAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeEntitySecurityState.write(value.securityState, into: &buf)
        FfiConverterSequenceTypeEntityFlag.write(value.flags, into: &buf)
        FfiConverterTypePersonaData.write(value.personaData, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersona_lift(_ buf: RustBuffer) throws -> Persona {
    return try FfiConverterTypePersona.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersona_lower(_ value: Persona) -> RustBuffer {
    return FfiConverterTypePersona.lower(value)
}


/**
 * Personal information a user has associated with a certain Persona, of different kinds, such as name,
 * email address(es) or phone number(s). This information is only ever stored in Profile and is never
 * uploaded to the Radix Network.
 *
 * These entries of different kinds can be queried for in a request sent by a dApp, e.g.
 * Radix Dashboard might ask "Give me ongoing access to Name and 2 Email addresses for
 * a Persona" (just a silly example, Radix Dashboard would never ask for that and why 2 email addresses?).
 *
 * The Profile will then use the fact that each Persona Data Entry has a stable ID so that Profile can
 * refer the entry just by the ID, and Profile can thus record which Persona Data Entry a user has selected
 * to share with the dApp, without duplicating the value of that entry (just like how we use FactorSourceIDs).
 * Since a dApp can ask for *ongoing* access next time the user interacts with the same dApp, if user has
 * not revoked the dApps access, the wallet clients will automatically send back the Persona Data Entry values
 * even if they have been updated - the value might have changed but their IDs have not. Thus if a user
 * deletes a Persona Data Entry (e.g. a phone number), and later re-inputs the same phone number, even
 * it the exact same value is used, it will still be treated as a new entry since its ID is new, meaning
 * that the next time the user interacts with a previously authorized dApp the wallet cannot automatically
 * respond back to dApp with the PersonaData, but user will have to re-authorize the request for ongoing
 * access for the requested PersonaData entries.
 */
public struct PersonaData {
    /**
     * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
     * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
     *
     * Note that the type is Option of `PersonaDataIdentifiedName` and not of type [`PersonaDataEntryName`][name],
     * `PersonaDataIdentifiedName` is essentially a tuple of `(Uuid, PersonaDataEntryName)`.
     *
     * [name]: PersonaDataEntryName
     */
    public var name: PersonaDataIdentifiedName?
    /**
     * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
     * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
     * contain elements with the same value, but under different IDs.
     */
    public var phoneNumbers: CollectionOfPhoneNumbers
    /**
     * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
     * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
     * contain elements with the same value, but under different IDs.
     */
    public var emailAddresses: CollectionOfEmailAddresses

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
         * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
         *
         * Note that the type is Option of `PersonaDataIdentifiedName` and not of type [`PersonaDataEntryName`][name],
         * `PersonaDataIdentifiedName` is essentially a tuple of `(Uuid, PersonaDataEntryName)`.
         *
         * [name]: PersonaDataEntryName
         */name: PersonaDataIdentifiedName?, 
        /**
         * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
         * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
         * contain elements with the same value, but under different IDs.
         */phoneNumbers: CollectionOfPhoneNumbers, 
        /**
         * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
         * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
         * contain elements with the same value, but under different IDs.
         */emailAddresses: CollectionOfEmailAddresses) {
        self.name = name
        self.phoneNumbers = phoneNumbers
        self.emailAddresses = emailAddresses
    }
}


extension PersonaData: Sendable {} 
extension PersonaData: Equatable, Hashable {
    public static func ==(lhs: PersonaData, rhs: PersonaData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(phoneNumbers)
        hasher.combine(emailAddresses)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersonaData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaData {
        return
            try PersonaData(
                name: FfiConverterOptionTypePersonaDataIdentifiedName.read(from: &buf), 
                phoneNumbers: FfiConverterTypeCollectionOfPhoneNumbers.read(from: &buf), 
                emailAddresses: FfiConverterTypeCollectionOfEmailAddresses.read(from: &buf)
        )
    }

    public static func write(_ value: PersonaData, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataIdentifiedName.write(value.name, into: &buf)
        FfiConverterTypeCollectionOfPhoneNumbers.write(value.phoneNumbers, into: &buf)
        FfiConverterTypeCollectionOfEmailAddresses.write(value.emailAddresses, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaData_lift(_ buf: RustBuffer) throws -> PersonaData {
    return try FfiConverterTypePersonaData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaData_lower(_ value: PersonaData) -> RustBuffer {
    return FfiConverterTypePersonaData.lower(value)
}


/**
 * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
 * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
 *
 * Nickname is optional in the sense that it can be left blank. Family name and given names are never empty.
 *
 * If a name has multiple given names, they all go into the `given_names` String, e.g. Pippi Longstocking's real name -
 * her Swedish name - is in full: "Pippilotta Viktualia Rullgardina Krusmynta Efraimsdotter Lngstrump", where her
 * given names: "Pippilotta Viktualia Rullgardina Krusmynta Efraimsdotter" are put in the `given_names` field, and
 * "Lngstrump" (Longstocking) is her family name.
 */
public struct PersonaDataEntryName {
    public var variant: PersonaDataNameVariant
    public var familyName: String
    public var givenNames: String
    public var nickname: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(variant: PersonaDataNameVariant, familyName: String, givenNames: String, nickname: String) {
        self.variant = variant
        self.familyName = familyName
        self.givenNames = givenNames
        self.nickname = nickname
    }
}


extension PersonaDataEntryName: Sendable {} 
extension PersonaDataEntryName: Equatable, Hashable {
    public static func ==(lhs: PersonaDataEntryName, rhs: PersonaDataEntryName) -> Bool {
        if lhs.variant != rhs.variant {
            return false
        }
        if lhs.familyName != rhs.familyName {
            return false
        }
        if lhs.givenNames != rhs.givenNames {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(variant)
        hasher.combine(familyName)
        hasher.combine(givenNames)
        hasher.combine(nickname)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersonaDataEntryName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryName {
        return
            try PersonaDataEntryName(
                variant: FfiConverterTypePersonaDataNameVariant.read(from: &buf), 
                familyName: FfiConverterString.read(from: &buf), 
                givenNames: FfiConverterString.read(from: &buf), 
                nickname: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PersonaDataEntryName, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataNameVariant.write(value.variant, into: &buf)
        FfiConverterString.write(value.familyName, into: &buf)
        FfiConverterString.write(value.givenNames, into: &buf)
        FfiConverterString.write(value.nickname, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataEntryName_lift(_ buf: RustBuffer) throws -> PersonaDataEntryName {
    return try FfiConverterTypePersonaDataEntryName.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataEntryName_lower(_ value: PersonaDataEntryName) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryName.lower(value)
}


/**
 * A persons telephone number they have chosen to associated with a Persona, e.g.
 * `+46 987 654 321` (don't try calling this number, it does not exist).
 *
 * Current implementation does not validate the phone number other than it
 * cannot be empty, since telephone number validation is tricky.
 */
public struct PersonaDataEntryPhoneNumber {
    public var number: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(number: String) {
        self.number = number
    }
}


extension PersonaDataEntryPhoneNumber: Sendable {} 
extension PersonaDataEntryPhoneNumber: Equatable, Hashable {
    public static func ==(lhs: PersonaDataEntryPhoneNumber, rhs: PersonaDataEntryPhoneNumber) -> Bool {
        if lhs.number != rhs.number {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(number)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryPhoneNumber {
        return
            try PersonaDataEntryPhoneNumber(
                number: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PersonaDataEntryPhoneNumber, into buf: inout [UInt8]) {
        FfiConverterString.write(value.number, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataEntryPhoneNumber_lift(_ buf: RustBuffer) throws -> PersonaDataEntryPhoneNumber {
    return try FfiConverterTypePersonaDataEntryPhoneNumber.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataEntryPhoneNumber_lower(_ value: PersonaDataEntryPhoneNumber) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryPhoneNumber.lower(value)
}


/**
 * An identifiable Persona email address. Essentially it is a tuple of a
 * [`(PersonaDataEntryEmailAddress, Uuid)`].
 */
public struct PersonaDataIdentifiedEmailAddress {
    public var id: PersonaDataEntryId
    public var value: EmailAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PersonaDataEntryId, value: EmailAddress) {
        self.id = id
        self.value = value
    }
}


extension PersonaDataIdentifiedEmailAddress: Sendable {} 
extension PersonaDataIdentifiedEmailAddress: Equatable, Hashable {
    public static func ==(lhs: PersonaDataIdentifiedEmailAddress, rhs: PersonaDataIdentifiedEmailAddress) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersonaDataIdentifiedEmailAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedEmailAddress {
        return
            try PersonaDataIdentifiedEmailAddress(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf), 
                value: FfiConverterTypeEmailAddress.read(from: &buf)
        )
    }

    public static func write(_ value: PersonaDataIdentifiedEmailAddress, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypeEmailAddress.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataIdentifiedEmailAddress_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedEmailAddress {
    return try FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataIdentifiedEmailAddress_lower(_ value: PersonaDataIdentifiedEmailAddress) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedEmailAddress.lower(value)
}


/**
 * An identifiable Persona name. Essentially it is a tuple of a
 * [`(PersonaDataEntryName, Uuid)`].
 */
public struct PersonaDataIdentifiedName {
    public var id: PersonaDataEntryId
    public var value: PersonaDataEntryName

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PersonaDataEntryId, value: PersonaDataEntryName) {
        self.id = id
        self.value = value
    }
}


extension PersonaDataIdentifiedName: Sendable {} 
extension PersonaDataIdentifiedName: Equatable, Hashable {
    public static func ==(lhs: PersonaDataIdentifiedName, rhs: PersonaDataIdentifiedName) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersonaDataIdentifiedName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedName {
        return
            try PersonaDataIdentifiedName(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf), 
                value: FfiConverterTypePersonaDataEntryName.read(from: &buf)
        )
    }

    public static func write(_ value: PersonaDataIdentifiedName, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypePersonaDataEntryName.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataIdentifiedName_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedName {
    return try FfiConverterTypePersonaDataIdentifiedName.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataIdentifiedName_lower(_ value: PersonaDataIdentifiedName) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedName.lower(value)
}


/**
 * An identifiable Persona phone number. Essentially it is a tuple of a
 * [`(PersonaDataEntryPhoneNumber, Uuid)`].
 */
public struct PersonaDataIdentifiedPhoneNumber {
    public var id: PersonaDataEntryId
    public var value: PersonaDataEntryPhoneNumber

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PersonaDataEntryId, value: PersonaDataEntryPhoneNumber) {
        self.id = id
        self.value = value
    }
}


extension PersonaDataIdentifiedPhoneNumber: Sendable {} 
extension PersonaDataIdentifiedPhoneNumber: Equatable, Hashable {
    public static func ==(lhs: PersonaDataIdentifiedPhoneNumber, rhs: PersonaDataIdentifiedPhoneNumber) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersonaDataIdentifiedPhoneNumber: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedPhoneNumber {
        return
            try PersonaDataIdentifiedPhoneNumber(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf), 
                value: FfiConverterTypePersonaDataEntryPhoneNumber.read(from: &buf)
        )
    }

    public static func write(_ value: PersonaDataIdentifiedPhoneNumber, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypePersonaDataEntryPhoneNumber.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataIdentifiedPhoneNumber_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedPhoneNumber {
    return try FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataIdentifiedPhoneNumber_lower(_ value: PersonaDataIdentifiedPhoneNumber) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedPhoneNumber.lower(value)
}


public struct PlaintextMessage {
    public var mimeType: String
    public var message: MessageContents

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mimeType: String, message: MessageContents) {
        self.mimeType = mimeType
        self.message = message
    }
}


extension PlaintextMessage: Sendable {} 
extension PlaintextMessage: Equatable, Hashable {
    public static func ==(lhs: PlaintextMessage, rhs: PlaintextMessage) -> Bool {
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mimeType)
        hasher.combine(message)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePlaintextMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlaintextMessage {
        return
            try PlaintextMessage(
                mimeType: FfiConverterString.read(from: &buf), 
                message: FfiConverterTypeMessageContents.read(from: &buf)
        )
    }

    public static func write(_ value: PlaintextMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mimeType, into: &buf)
        FfiConverterTypeMessageContents.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePlaintextMessage_lift(_ buf: RustBuffer) throws -> PlaintextMessage {
    return try FfiConverterTypePlaintextMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePlaintextMessage_lower(_ value: PlaintextMessage) -> RustBuffer {
    return FfiConverterTypePlaintextMessage.lower(value)
}


/**
 * Addresses identifying an OnLedger (OnNetwork) Liquidity Pool (LP) of tokens that users can contribute
 * Liquidity too, e.g.:
 * `"pool_rdx1c325zs6dz3un8ykkjavy9fkvvyzarkaehgsl408qup6f95aup3le3w"`
 *
 * Typically users contribute to Liquidity Pools by using a Dapp and the Radix Wallet.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of PoolAddresses:
 * * GlobalOneResourcePool
 * * GlobalTwoResourcePool
 * * GlobalMultiResourcePool
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalPoolAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L256-L261
 */
public struct PoolAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension PoolAddress: Sendable {} 
extension PoolAddress: Equatable, Hashable {
    public static func ==(lhs: PoolAddress, rhs: PoolAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePoolAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PoolAddress {
        return
            try PoolAddress(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PoolAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoolAddress_lift(_ buf: RustBuffer) throws -> PoolAddress {
    return try FfiConverterTypePoolAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoolAddress_lower(_ value: PoolAddress) -> RustBuffer {
    return FfiConverterTypePoolAddress.lower(value)
}


/**
 * Pre-Auth analysis enclosed manifest, which does not contain any interactions with the parent manifest,
 * thus its preview can be computed as if it would have been a standalone transaction.
 */
public struct PreAuthEnclosedManifest {
    public var manifest: SubintentManifest
    public var summary: ExecutionSummary

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(manifest: SubintentManifest, summary: ExecutionSummary) {
        self.manifest = manifest
        self.summary = summary
    }
}


extension PreAuthEnclosedManifest: Sendable {} 
extension PreAuthEnclosedManifest: Equatable, Hashable {
    public static func ==(lhs: PreAuthEnclosedManifest, rhs: PreAuthEnclosedManifest) -> Bool {
        if lhs.manifest != rhs.manifest {
            return false
        }
        if lhs.summary != rhs.summary {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(manifest)
        hasher.combine(summary)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePreAuthEnclosedManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreAuthEnclosedManifest {
        return
            try PreAuthEnclosedManifest(
                manifest: FfiConverterTypeSubintentManifest.read(from: &buf), 
                summary: FfiConverterTypeExecutionSummary.read(from: &buf)
        )
    }

    public static func write(_ value: PreAuthEnclosedManifest, into buf: inout [UInt8]) {
        FfiConverterTypeSubintentManifest.write(value.manifest, into: &buf)
        FfiConverterTypeExecutionSummary.write(value.summary, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreAuthEnclosedManifest_lift(_ buf: RustBuffer) throws -> PreAuthEnclosedManifest {
    return try FfiConverterTypePreAuthEnclosedManifest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreAuthEnclosedManifest_lower(_ value: PreAuthEnclosedManifest) -> RustBuffer {
    return FfiConverterTypePreAuthEnclosedManifest.lower(value)
}


/**
 * Pre-Auth analysis open manifest, which contains multiple interactions with the parent manifest,
 * thus its preview can be computed only based on the static analysis manifest summary
 */
public struct PreAuthOpenManifest {
    public var manifest: SubintentManifest
    public var summary: ManifestSummary

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(manifest: SubintentManifest, summary: ManifestSummary) {
        self.manifest = manifest
        self.summary = summary
    }
}


extension PreAuthOpenManifest: Sendable {} 
extension PreAuthOpenManifest: Equatable, Hashable {
    public static func ==(lhs: PreAuthOpenManifest, rhs: PreAuthOpenManifest) -> Bool {
        if lhs.manifest != rhs.manifest {
            return false
        }
        if lhs.summary != rhs.summary {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(manifest)
        hasher.combine(summary)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePreAuthOpenManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreAuthOpenManifest {
        return
            try PreAuthOpenManifest(
                manifest: FfiConverterTypeSubintentManifest.read(from: &buf), 
                summary: FfiConverterTypeManifestSummary.read(from: &buf)
        )
    }

    public static func write(_ value: PreAuthOpenManifest, into buf: inout [UInt8]) {
        FfiConverterTypeSubintentManifest.write(value.manifest, into: &buf)
        FfiConverterTypeManifestSummary.write(value.summary, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreAuthOpenManifest_lift(_ buf: RustBuffer) throws -> PreAuthOpenManifest {
    return try FfiConverterTypePreAuthOpenManifest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreAuthOpenManifest_lower(_ value: PreAuthOpenManifest) -> RustBuffer {
    return FfiConverterTypePreAuthOpenManifest.lower(value)
}


public struct PredictedDecimal {
    public var value: Decimal192
    public var instructionIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Decimal192, instructionIndex: UInt64) {
        self.value = value
        self.instructionIndex = instructionIndex
    }
}


extension PredictedDecimal: Sendable {} 
extension PredictedDecimal: Equatable, Hashable {
    public static func ==(lhs: PredictedDecimal, rhs: PredictedDecimal) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(instructionIndex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePredictedDecimal: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredictedDecimal {
        return
            try PredictedDecimal(
                value: FfiConverterTypeDecimal192.read(from: &buf), 
                instructionIndex: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PredictedDecimal, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePredictedDecimal_lift(_ buf: RustBuffer) throws -> PredictedDecimal {
    return try FfiConverterTypePredictedDecimal.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePredictedDecimal_lower(_ value: PredictedDecimal) -> RustBuffer {
    return FfiConverterTypePredictedDecimal.lower(value)
}


public struct PredictedNonFungibleLocalIds {
    public var value: [NonFungibleLocalId]
    public var instructionIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: [NonFungibleLocalId], instructionIndex: UInt64) {
        self.value = value
        self.instructionIndex = instructionIndex
    }
}


extension PredictedNonFungibleLocalIds: Sendable {} 
extension PredictedNonFungibleLocalIds: Equatable, Hashable {
    public static func ==(lhs: PredictedNonFungibleLocalIds, rhs: PredictedNonFungibleLocalIds) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(instructionIndex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePredictedNonFungibleLocalIds: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredictedNonFungibleLocalIds {
        return
            try PredictedNonFungibleLocalIds(
                value: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf), 
                instructionIndex: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PredictedNonFungibleLocalIds, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePredictedNonFungibleLocalIds_lift(_ buf: RustBuffer) throws -> PredictedNonFungibleLocalIds {
    return try FfiConverterTypePredictedNonFungibleLocalIds.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePredictedNonFungibleLocalIds_lower(_ value: PredictedNonFungibleLocalIds) -> RustBuffer {
    return FfiConverterTypePredictedNonFungibleLocalIds.lower(value)
}


/**
 * Role of FactorInstances
 */
public struct PrimaryRoleWithFactorInstances {
    /**
     * How many threshold factors that must be used to perform some function with
     * this role.
     */
    public var threshold: Threshold
    /**
     * Factors which are used in combination with other factors, amounting to at
     * least `threshold` many factors to perform some function with this role.
     */
    public var thresholdFactors: [FactorInstance]
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * How many threshold factors that must be used to perform some function with
         * this role.
         */threshold: Threshold, 
        /**
         * Factors which are used in combination with other factors, amounting to at
         * least `threshold` many factors to perform some function with this role.
         */thresholdFactors: [FactorInstance], 
        /**
         * Overriding / Super admin / "sudo" / God / factors, **ANY**
         * single of these factor which can perform the function of this role,
         * disregarding of `threshold`.
         */overrideFactors: [FactorInstance]) {
        self.threshold = threshold
        self.thresholdFactors = thresholdFactors
        self.overrideFactors = overrideFactors
    }
}


extension PrimaryRoleWithFactorInstances: Sendable {} 
extension PrimaryRoleWithFactorInstances: Equatable, Hashable {
    public static func ==(lhs: PrimaryRoleWithFactorInstances, rhs: PrimaryRoleWithFactorInstances) -> Bool {
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(threshold)
        hasher.combine(thresholdFactors)
        hasher.combine(overrideFactors)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrimaryRoleWithFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimaryRoleWithFactorInstances {
        return
            try PrimaryRoleWithFactorInstances(
                threshold: FfiConverterTypeThreshold.read(from: &buf), 
                thresholdFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf), 
                overrideFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf)
        )
    }

    public static func write(_ value: PrimaryRoleWithFactorInstances, into buf: inout [UInt8]) {
        FfiConverterTypeThreshold.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorInstance.write(value.thresholdFactors, into: &buf)
        FfiConverterSequenceTypeFactorInstance.write(value.overrideFactors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrimaryRoleWithFactorInstances_lift(_ buf: RustBuffer) throws -> PrimaryRoleWithFactorInstances {
    return try FfiConverterTypePrimaryRoleWithFactorInstances.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrimaryRoleWithFactorInstances_lower(_ value: PrimaryRoleWithFactorInstances) -> RustBuffer {
    return FfiConverterTypePrimaryRoleWithFactorInstances.lower(value)
}


/**
 * Role of FactorSourceIDs
 */
public struct PrimaryRoleWithFactorSourceIDs {
    /**
     * How many threshold factors that must be used to perform some function with
     * this role.
     */
    public var threshold: Threshold
    /**
     * Factors which are used in combination with other factors, amounting to at
     * least `threshold` many factors to perform some function with this role.
     */
    public var thresholdFactors: [FactorSourceId]
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSourceId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * How many threshold factors that must be used to perform some function with
         * this role.
         */threshold: Threshold, 
        /**
         * Factors which are used in combination with other factors, amounting to at
         * least `threshold` many factors to perform some function with this role.
         */thresholdFactors: [FactorSourceId], 
        /**
         * Overriding / Super admin / "sudo" / God / factors, **ANY**
         * single of these factor which can perform the function of this role,
         * disregarding of `threshold`.
         */overrideFactors: [FactorSourceId]) {
        self.threshold = threshold
        self.thresholdFactors = thresholdFactors
        self.overrideFactors = overrideFactors
    }
}


extension PrimaryRoleWithFactorSourceIDs: Sendable {} 
extension PrimaryRoleWithFactorSourceIDs: Equatable, Hashable {
    public static func ==(lhs: PrimaryRoleWithFactorSourceIDs, rhs: PrimaryRoleWithFactorSourceIDs) -> Bool {
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(threshold)
        hasher.combine(thresholdFactors)
        hasher.combine(overrideFactors)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrimaryRoleWithFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimaryRoleWithFactorSourceIDs {
        return
            try PrimaryRoleWithFactorSourceIDs(
                threshold: FfiConverterTypeThreshold.read(from: &buf), 
                thresholdFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf), 
                overrideFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
        )
    }

    public static func write(_ value: PrimaryRoleWithFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterTypeThreshold.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSourceID.write(value.thresholdFactors, into: &buf)
        FfiConverterSequenceTypeFactorSourceID.write(value.overrideFactors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrimaryRoleWithFactorSourceIDs_lift(_ buf: RustBuffer) throws -> PrimaryRoleWithFactorSourceIDs {
    return try FfiConverterTypePrimaryRoleWithFactorSourceIDs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrimaryRoleWithFactorSourceIDs_lower(_ value: PrimaryRoleWithFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypePrimaryRoleWithFactorSourceIDs.lower(value)
}


/**
 * Role of `FactorSource`s
 */
public struct PrimaryRoleWithFactorSources {
    /**
     * How many threshold factors that must be used to perform some function with
     * this role.
     */
    public var threshold: Threshold
    /**
     * Factors which are used in combination with other factors, amounting to at
     * least `threshold` many factors to perform some function with this role.
     */
    public var thresholdFactors: [FactorSource]
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * How many threshold factors that must be used to perform some function with
         * this role.
         */threshold: Threshold, 
        /**
         * Factors which are used in combination with other factors, amounting to at
         * least `threshold` many factors to perform some function with this role.
         */thresholdFactors: [FactorSource], 
        /**
         * Overriding / Super admin / "sudo" / God / factors, **ANY**
         * single of these factor which can perform the function of this role,
         * disregarding of `threshold`.
         */overrideFactors: [FactorSource]) {
        self.threshold = threshold
        self.thresholdFactors = thresholdFactors
        self.overrideFactors = overrideFactors
    }
}


extension PrimaryRoleWithFactorSources: Sendable {} 
extension PrimaryRoleWithFactorSources: Equatable, Hashable {
    public static func ==(lhs: PrimaryRoleWithFactorSources, rhs: PrimaryRoleWithFactorSources) -> Bool {
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(threshold)
        hasher.combine(thresholdFactors)
        hasher.combine(overrideFactors)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrimaryRoleWithFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimaryRoleWithFactorSources {
        return
            try PrimaryRoleWithFactorSources(
                threshold: FfiConverterTypeThreshold.read(from: &buf), 
                thresholdFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf), 
                overrideFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf)
        )
    }

    public static func write(_ value: PrimaryRoleWithFactorSources, into buf: inout [UInt8]) {
        FfiConverterTypeThreshold.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.thresholdFactors, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.overrideFactors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrimaryRoleWithFactorSources_lift(_ buf: RustBuffer) throws -> PrimaryRoleWithFactorSources {
    return try FfiConverterTypePrimaryRoleWithFactorSources.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrimaryRoleWithFactorSources_lower(_ value: PrimaryRoleWithFactorSources) -> RustBuffer {
    return FfiConverterTypePrimaryRoleWithFactorSources.lower(value)
}


public struct PrivateHierarchicalDeterministicFactorSource {
    public var mnemonicWithPassphrase: MnemonicWithPassphrase
    public var factorSource: DeviceFactorSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonicWithPassphrase: MnemonicWithPassphrase, factorSource: DeviceFactorSource) {
        self.mnemonicWithPassphrase = mnemonicWithPassphrase
        self.factorSource = factorSource
    }
}


extension PrivateHierarchicalDeterministicFactorSource: Sendable {} 
extension PrivateHierarchicalDeterministicFactorSource: Equatable, Hashable {
    public static func ==(lhs: PrivateHierarchicalDeterministicFactorSource, rhs: PrivateHierarchicalDeterministicFactorSource) -> Bool {
        if lhs.mnemonicWithPassphrase != rhs.mnemonicWithPassphrase {
            return false
        }
        if lhs.factorSource != rhs.factorSource {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonicWithPassphrase)
        hasher.combine(factorSource)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrivateHierarchicalDeterministicFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrivateHierarchicalDeterministicFactorSource {
        return
            try PrivateHierarchicalDeterministicFactorSource(
                mnemonicWithPassphrase: FfiConverterTypeMnemonicWithPassphrase.read(from: &buf), 
                factorSource: FfiConverterTypeDeviceFactorSource.read(from: &buf)
        )
    }

    public static func write(_ value: PrivateHierarchicalDeterministicFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeMnemonicWithPassphrase.write(value.mnemonicWithPassphrase, into: &buf)
        FfiConverterTypeDeviceFactorSource.write(value.factorSource, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrivateHierarchicalDeterministicFactorSource_lift(_ buf: RustBuffer) throws -> PrivateHierarchicalDeterministicFactorSource {
    return try FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrivateHierarchicalDeterministicFactorSource_lower(_ value: PrivateHierarchicalDeterministicFactorSource) -> RustBuffer {
    return FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lower(value)
}


/**
 * The canonical representation of a users accounts, personas,
 * authorized dapps, security factors, settings and more.
 *
 * This large structure of values is called 'wallet backup data'
 * in user facing tests in host applications, but internally at
 * RDX Works known as "the Profile".
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert_eq!(Profile::sample(), Profile::sample())
 * ```
 */
public struct Profile {
    /**
     * The header of a Profile(Snapshot) contains crucial metadata
     * about this Profile, such as which JSON data format it is
     * compatible with and which device was used to create it and
     * a hint about its contents.
     */
    public var header: Header
    /**
     * All sources of factors, used for authorization such as spending funds, contains no
     * secrets.
     */
    public var factorSources: [FactorSource]
    /**
     * Settings for this profile in the app, contains default security configs
     * as well as display settings.
     */
    public var appPreferences: AppPreferences
    /**
     * An ordered mapping of NetworkID -> `Profile.Network`, containing
     * all the users Accounts, Personas and AuthorizedDapps the user
     * has created and interacted with on this network.
     */
    public var networks: [ProfileNetwork]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The header of a Profile(Snapshot) contains crucial metadata
         * about this Profile, such as which JSON data format it is
         * compatible with and which device was used to create it and
         * a hint about its contents.
         */header: Header, 
        /**
         * All sources of factors, used for authorization such as spending funds, contains no
         * secrets.
         */factorSources: [FactorSource], 
        /**
         * Settings for this profile in the app, contains default security configs
         * as well as display settings.
         */appPreferences: AppPreferences, 
        /**
         * An ordered mapping of NetworkID -> `Profile.Network`, containing
         * all the users Accounts, Personas and AuthorizedDapps the user
         * has created and interacted with on this network.
         */networks: [ProfileNetwork]) {
        self.header = header
        self.factorSources = factorSources
        self.appPreferences = appPreferences
        self.networks = networks
    }
}


extension Profile: Sendable {} 
extension Profile: Equatable, Hashable {
    public static func ==(lhs: Profile, rhs: Profile) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.factorSources != rhs.factorSources {
            return false
        }
        if lhs.appPreferences != rhs.appPreferences {
            return false
        }
        if lhs.networks != rhs.networks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(factorSources)
        hasher.combine(appPreferences)
        hasher.combine(networks)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Profile {
        return
            try Profile(
                header: FfiConverterTypeHeader.read(from: &buf), 
                factorSources: FfiConverterSequenceTypeFactorSource.read(from: &buf), 
                appPreferences: FfiConverterTypeAppPreferences.read(from: &buf), 
                networks: FfiConverterSequenceTypeProfileNetwork.read(from: &buf)
        )
    }

    public static func write(_ value: Profile, into buf: inout [UInt8]) {
        FfiConverterTypeHeader.write(value.header, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.factorSources, into: &buf)
        FfiConverterTypeAppPreferences.write(value.appPreferences, into: &buf)
        FfiConverterSequenceTypeProfileNetwork.write(value.networks, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfile_lift(_ buf: RustBuffer) throws -> Profile {
    return try FfiConverterTypeProfile.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfile_lower(_ value: Profile) -> RustBuffer {
    return FfiConverterTypeProfile.lower(value)
}


/**
 * [`Accounts`], [`Personas`] and [`AuthorizedDapps`] for some [`ProfileNetwork`]
 * which user has created/interacted with, all on the same [Radix Network][`NetworkDefinition`],
 * identified by `id` ([`NetworkID`]).
 */
public struct ProfileNetwork {
    /**
     * The ID of the network that has been used to generate the `accounts` and `personas`
     * and on which the `authorizedDapps` have been deployed on.
     */
    public var id: NetworkId
    /**
     * An ordered set of [`Accounts`]` on this network, which are [`Account`]s
     * the user has created on this network.
     */
    public var accounts: [Account]
    /**
     * An ordered set of [`Personas`] on this network, which are [`Persona`]s
     * the user has created on this network.
     */
    public var personas: [Persona]
    /**
     * An ordered set of [`AuthorizedDapps`] on this network, which are
     * [`AuthorizedDapp`]s that the user has interacted with.
     */
    public var authorizedDapps: [AuthorizedDapp]
    /**
     * Configuration related to resources
     */
    public var resourcePreferences: [ResourceAppPreference]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network that has been used to generate the `accounts` and `personas`
         * and on which the `authorizedDapps` have been deployed on.
         */id: NetworkId, 
        /**
         * An ordered set of [`Accounts`]` on this network, which are [`Account`]s
         * the user has created on this network.
         */accounts: [Account], 
        /**
         * An ordered set of [`Personas`] on this network, which are [`Persona`]s
         * the user has created on this network.
         */personas: [Persona], 
        /**
         * An ordered set of [`AuthorizedDapps`] on this network, which are
         * [`AuthorizedDapp`]s that the user has interacted with.
         */authorizedDapps: [AuthorizedDapp], 
        /**
         * Configuration related to resources
         */resourcePreferences: [ResourceAppPreference]) {
        self.id = id
        self.accounts = accounts
        self.personas = personas
        self.authorizedDapps = authorizedDapps
        self.resourcePreferences = resourcePreferences
    }
}


extension ProfileNetwork: Sendable {} 
extension ProfileNetwork: Equatable, Hashable {
    public static func ==(lhs: ProfileNetwork, rhs: ProfileNetwork) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.personas != rhs.personas {
            return false
        }
        if lhs.authorizedDapps != rhs.authorizedDapps {
            return false
        }
        if lhs.resourcePreferences != rhs.resourcePreferences {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(accounts)
        hasher.combine(personas)
        hasher.combine(authorizedDapps)
        hasher.combine(resourcePreferences)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProfileNetwork: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileNetwork {
        return
            try ProfileNetwork(
                id: FfiConverterTypeNetworkID.read(from: &buf), 
                accounts: FfiConverterSequenceTypeAccount.read(from: &buf), 
                personas: FfiConverterSequenceTypePersona.read(from: &buf), 
                authorizedDapps: FfiConverterSequenceTypeAuthorizedDapp.read(from: &buf), 
                resourcePreferences: FfiConverterSequenceTypeResourceAppPreference.read(from: &buf)
        )
    }

    public static func write(_ value: ProfileNetwork, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.id, into: &buf)
        FfiConverterSequenceTypeAccount.write(value.accounts, into: &buf)
        FfiConverterSequenceTypePersona.write(value.personas, into: &buf)
        FfiConverterSequenceTypeAuthorizedDapp.write(value.authorizedDapps, into: &buf)
        FfiConverterSequenceTypeResourceAppPreference.write(value.resourcePreferences, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileNetwork_lift(_ buf: RustBuffer) throws -> ProfileNetwork {
    return try FfiConverterTypeProfileNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileNetwork_lower(_ value: ProfileNetwork) -> RustBuffer {
    return FfiConverterTypeProfileNetwork.lower(value)
}


/**
 * The request received from the dApp that needs to be handled.
 */
public struct RadixConnectMobileSessionRequest {
    /**
     * The id of the session established with the dApp.
     * Needs to be passed back by the Host as to know which session to respond to.
     */
    public var sessionId: SessionId
    /**
     * The interaction received from the dApp.
     */
    public var interaction: DappToWalletInteractionUnvalidated
    /**
     * The origin of the dApp.
     */
    public var origin: DappOrigin
    /**
     * Whether the origin requires validation.
     */
    public var originRequiresValidation: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The id of the session established with the dApp.
         * Needs to be passed back by the Host as to know which session to respond to.
         */sessionId: SessionId, 
        /**
         * The interaction received from the dApp.
         */interaction: DappToWalletInteractionUnvalidated, 
        /**
         * The origin of the dApp.
         */origin: DappOrigin, 
        /**
         * Whether the origin requires validation.
         */originRequiresValidation: Bool) {
        self.sessionId = sessionId
        self.interaction = interaction
        self.origin = origin
        self.originRequiresValidation = originRequiresValidation
    }
}


extension RadixConnectMobileSessionRequest: Sendable {} 
extension RadixConnectMobileSessionRequest: Equatable, Hashable {
    public static func ==(lhs: RadixConnectMobileSessionRequest, rhs: RadixConnectMobileSessionRequest) -> Bool {
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.interaction != rhs.interaction {
            return false
        }
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.originRequiresValidation != rhs.originRequiresValidation {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sessionId)
        hasher.combine(interaction)
        hasher.combine(origin)
        hasher.combine(originRequiresValidation)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRadixConnectMobileSessionRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileSessionRequest {
        return
            try RadixConnectMobileSessionRequest(
                sessionId: FfiConverterTypeSessionID.read(from: &buf), 
                interaction: FfiConverterTypeDappToWalletInteractionUnvalidated.read(from: &buf), 
                origin: FfiConverterTypeDappOrigin.read(from: &buf), 
                originRequiresValidation: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RadixConnectMobileSessionRequest, into buf: inout [UInt8]) {
        FfiConverterTypeSessionID.write(value.sessionId, into: &buf)
        FfiConverterTypeDappToWalletInteractionUnvalidated.write(value.interaction, into: &buf)
        FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
        FfiConverterBool.write(value.originRequiresValidation, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixConnectMobileSessionRequest_lift(_ buf: RustBuffer) throws -> RadixConnectMobileSessionRequest {
    return try FfiConverterTypeRadixConnectMobileSessionRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixConnectMobileSessionRequest_lower(_ value: RadixConnectMobileSessionRequest) -> RustBuffer {
    return FfiConverterTypeRadixConnectMobileSessionRequest.lower(value)
}


public struct RadixConnectMobileWalletResponse {
    public var sessionId: SessionId
    public var response: WalletToDappInteractionResponse

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sessionId: SessionId, response: WalletToDappInteractionResponse) {
        self.sessionId = sessionId
        self.response = response
    }
}


extension RadixConnectMobileWalletResponse: Sendable {} 
extension RadixConnectMobileWalletResponse: Equatable, Hashable {
    public static func ==(lhs: RadixConnectMobileWalletResponse, rhs: RadixConnectMobileWalletResponse) -> Bool {
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.response != rhs.response {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sessionId)
        hasher.combine(response)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRadixConnectMobileWalletResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileWalletResponse {
        return
            try RadixConnectMobileWalletResponse(
                sessionId: FfiConverterTypeSessionID.read(from: &buf), 
                response: FfiConverterTypeWalletToDappInteractionResponse.read(from: &buf)
        )
    }

    public static func write(_ value: RadixConnectMobileWalletResponse, into buf: inout [UInt8]) {
        FfiConverterTypeSessionID.write(value.sessionId, into: &buf)
        FfiConverterTypeWalletToDappInteractionResponse.write(value.response, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixConnectMobileWalletResponse_lift(_ buf: RustBuffer) throws -> RadixConnectMobileWalletResponse {
    return try FfiConverterTypeRadixConnectMobileWalletResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixConnectMobileWalletResponse_lower(_ value: RadixConnectMobileWalletResponse) -> RustBuffer {
    return FfiConverterTypeRadixConnectMobileWalletResponse.lower(value)
}


/**
 * The hash of the connection password is used to connect to the Radix Connect Signaling Server,
 * over web sockets. The actual `ConnectionPassword` is used to encrypt all messages sent via
 * the Signaling Server.
 */
public struct RadixConnectPassword {
    public var value: Exactly32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Exactly32Bytes) {
        self.value = value
    }
}


extension RadixConnectPassword: Sendable {} 
extension RadixConnectPassword: Equatable, Hashable {
    public static func ==(lhs: RadixConnectPassword, rhs: RadixConnectPassword) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRadixConnectPassword: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectPassword {
        return
            try RadixConnectPassword(
                value: FfiConverterTypeExactly32Bytes.read(from: &buf)
        )
    }

    public static func write(_ value: RadixConnectPassword, into buf: inout [UInt8]) {
        FfiConverterTypeExactly32Bytes.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixConnectPassword_lift(_ buf: RustBuffer) throws -> RadixConnectPassword {
    return try FfiConverterTypeRadixConnectPassword.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixConnectPassword_lower(_ value: RadixConnectPassword) -> RustBuffer {
    return FfiConverterTypeRadixConnectPassword.lower(value)
}


/**
 * Role of FactorInstances
 */
public struct RecoveryRoleWithFactorInstances {
    /**
     * How many threshold factors that must be used to perform some function with
     * this role.
     */
    public var threshold: Threshold
    /**
     * Factors which are used in combination with other factors, amounting to at
     * least `threshold` many factors to perform some function with this role.
     */
    public var thresholdFactors: [FactorInstance]
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * How many threshold factors that must be used to perform some function with
         * this role.
         */threshold: Threshold, 
        /**
         * Factors which are used in combination with other factors, amounting to at
         * least `threshold` many factors to perform some function with this role.
         */thresholdFactors: [FactorInstance], 
        /**
         * Overriding / Super admin / "sudo" / God / factors, **ANY**
         * single of these factor which can perform the function of this role,
         * disregarding of `threshold`.
         */overrideFactors: [FactorInstance]) {
        self.threshold = threshold
        self.thresholdFactors = thresholdFactors
        self.overrideFactors = overrideFactors
    }
}


extension RecoveryRoleWithFactorInstances: Sendable {} 
extension RecoveryRoleWithFactorInstances: Equatable, Hashable {
    public static func ==(lhs: RecoveryRoleWithFactorInstances, rhs: RecoveryRoleWithFactorInstances) -> Bool {
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(threshold)
        hasher.combine(thresholdFactors)
        hasher.combine(overrideFactors)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecoveryRoleWithFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryRoleWithFactorInstances {
        return
            try RecoveryRoleWithFactorInstances(
                threshold: FfiConverterTypeThreshold.read(from: &buf), 
                thresholdFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf), 
                overrideFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf)
        )
    }

    public static func write(_ value: RecoveryRoleWithFactorInstances, into buf: inout [UInt8]) {
        FfiConverterTypeThreshold.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorInstance.write(value.thresholdFactors, into: &buf)
        FfiConverterSequenceTypeFactorInstance.write(value.overrideFactors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoveryRoleWithFactorInstances_lift(_ buf: RustBuffer) throws -> RecoveryRoleWithFactorInstances {
    return try FfiConverterTypeRecoveryRoleWithFactorInstances.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoveryRoleWithFactorInstances_lower(_ value: RecoveryRoleWithFactorInstances) -> RustBuffer {
    return FfiConverterTypeRecoveryRoleWithFactorInstances.lower(value)
}


/**
 * Role of FactorSourceIDs
 */
public struct RecoveryRoleWithFactorSourceIDs {
    /**
     * How many threshold factors that must be used to perform some function with
     * this role.
     */
    public var threshold: Threshold
    /**
     * Factors which are used in combination with other factors, amounting to at
     * least `threshold` many factors to perform some function with this role.
     */
    public var thresholdFactors: [FactorSourceId]
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSourceId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * How many threshold factors that must be used to perform some function with
         * this role.
         */threshold: Threshold, 
        /**
         * Factors which are used in combination with other factors, amounting to at
         * least `threshold` many factors to perform some function with this role.
         */thresholdFactors: [FactorSourceId], 
        /**
         * Overriding / Super admin / "sudo" / God / factors, **ANY**
         * single of these factor which can perform the function of this role,
         * disregarding of `threshold`.
         */overrideFactors: [FactorSourceId]) {
        self.threshold = threshold
        self.thresholdFactors = thresholdFactors
        self.overrideFactors = overrideFactors
    }
}


extension RecoveryRoleWithFactorSourceIDs: Sendable {} 
extension RecoveryRoleWithFactorSourceIDs: Equatable, Hashable {
    public static func ==(lhs: RecoveryRoleWithFactorSourceIDs, rhs: RecoveryRoleWithFactorSourceIDs) -> Bool {
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(threshold)
        hasher.combine(thresholdFactors)
        hasher.combine(overrideFactors)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecoveryRoleWithFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryRoleWithFactorSourceIDs {
        return
            try RecoveryRoleWithFactorSourceIDs(
                threshold: FfiConverterTypeThreshold.read(from: &buf), 
                thresholdFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf), 
                overrideFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
        )
    }

    public static func write(_ value: RecoveryRoleWithFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterTypeThreshold.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSourceID.write(value.thresholdFactors, into: &buf)
        FfiConverterSequenceTypeFactorSourceID.write(value.overrideFactors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoveryRoleWithFactorSourceIDs_lift(_ buf: RustBuffer) throws -> RecoveryRoleWithFactorSourceIDs {
    return try FfiConverterTypeRecoveryRoleWithFactorSourceIDs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoveryRoleWithFactorSourceIDs_lower(_ value: RecoveryRoleWithFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypeRecoveryRoleWithFactorSourceIDs.lower(value)
}


/**
 * Role of `FactorSource`s
 */
public struct RecoveryRoleWithFactorSources {
    /**
     * How many threshold factors that must be used to perform some function with
     * this role.
     */
    public var threshold: Threshold
    /**
     * Factors which are used in combination with other factors, amounting to at
     * least `threshold` many factors to perform some function with this role.
     */
    public var thresholdFactors: [FactorSource]
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * How many threshold factors that must be used to perform some function with
         * this role.
         */threshold: Threshold, 
        /**
         * Factors which are used in combination with other factors, amounting to at
         * least `threshold` many factors to perform some function with this role.
         */thresholdFactors: [FactorSource], 
        /**
         * Overriding / Super admin / "sudo" / God / factors, **ANY**
         * single of these factor which can perform the function of this role,
         * disregarding of `threshold`.
         */overrideFactors: [FactorSource]) {
        self.threshold = threshold
        self.thresholdFactors = thresholdFactors
        self.overrideFactors = overrideFactors
    }
}


extension RecoveryRoleWithFactorSources: Sendable {} 
extension RecoveryRoleWithFactorSources: Equatable, Hashable {
    public static func ==(lhs: RecoveryRoleWithFactorSources, rhs: RecoveryRoleWithFactorSources) -> Bool {
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(threshold)
        hasher.combine(thresholdFactors)
        hasher.combine(overrideFactors)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecoveryRoleWithFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryRoleWithFactorSources {
        return
            try RecoveryRoleWithFactorSources(
                threshold: FfiConverterTypeThreshold.read(from: &buf), 
                thresholdFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf), 
                overrideFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf)
        )
    }

    public static func write(_ value: RecoveryRoleWithFactorSources, into buf: inout [UInt8]) {
        FfiConverterTypeThreshold.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.thresholdFactors, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.overrideFactors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoveryRoleWithFactorSources_lift(_ buf: RustBuffer) throws -> RecoveryRoleWithFactorSources {
    return try FfiConverterTypeRecoveryRoleWithFactorSources.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoveryRoleWithFactorSources_lower(_ value: RecoveryRoleWithFactorSources) -> RustBuffer {
    return FfiConverterTypeRecoveryRoleWithFactorSources.lower(value)
}


/**
 * A requested (by Dapp) quantity, e.g. "I want AT LEAST 3 account addresses" or
 * "I want EXACTLY 2 email addresses".
 */
public struct RequestedQuantity {
    public var quantifier: RequestedNumberQuantifier
    public var quantity: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(quantifier: RequestedNumberQuantifier, quantity: UInt16) {
        self.quantifier = quantifier
        self.quantity = quantity
    }
}


extension RequestedQuantity: Sendable {} 
extension RequestedQuantity: Equatable, Hashable {
    public static func ==(lhs: RequestedQuantity, rhs: RequestedQuantity) -> Bool {
        if lhs.quantifier != rhs.quantifier {
            return false
        }
        if lhs.quantity != rhs.quantity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(quantifier)
        hasher.combine(quantity)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestedQuantity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedQuantity {
        return
            try RequestedQuantity(
                quantifier: FfiConverterTypeRequestedNumberQuantifier.read(from: &buf), 
                quantity: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: RequestedQuantity, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedNumberQuantifier.write(value.quantifier, into: &buf)
        FfiConverterUInt16.write(value.quantity, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedQuantity_lift(_ buf: RustBuffer) throws -> RequestedQuantity {
    return try FfiConverterTypeRequestedQuantity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedQuantity_lower(_ value: RequestedQuantity) -> RustBuffer {
    return FfiConverterTypeRequestedQuantity.lower(value)
}


/**
 * Addresses identifying an asset, either fungible (Token) or non_fungible (NFT), on the Radix network, e.g.
 * `"resource_rdx1tknxxxxxxxxxradxrdxxxxxxxxx009923554798xxxxxxxxxradxrd"`
 * Being the unique identifier of the Radix Token, the Rad, on mainnet.
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of ResourceAddresses:
 * * GlobalFungibleResourceManager
 * * GlobalNonFungibleResourceManager
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalResourceAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L236-L239
 */
public struct ResourceAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension ResourceAddress: Sendable {} 
extension ResourceAddress: Equatable, Hashable {
    public static func ==(lhs: ResourceAddress, rhs: ResourceAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResourceAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAddress {
        return
            try ResourceAddress(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ResourceAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceAddress_lift(_ buf: RustBuffer) throws -> ResourceAddress {
    return try FfiConverterTypeResourceAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceAddress_lower(_ value: ResourceAddress) -> RustBuffer {
    return FfiConverterTypeResourceAddress.lower(value)
}


/**
 * A preference the user has configured off-ledger for a given resource.
 * Allows users, for example, to hide a given resource on their accounts.
 *
 * Named like this to differ from RET's `ResourcePreference`.
 */
public struct ResourceAppPreference {
    /**
     * The resource for which the preference is set up.
     */
    public var resource: ResourceIdentifier
    /**
     * The visibility of the resource (hidden or visible).
     */
    public var visibility: ResourceVisibility

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The resource for which the preference is set up.
         */resource: ResourceIdentifier, 
        /**
         * The visibility of the resource (hidden or visible).
         */visibility: ResourceVisibility) {
        self.resource = resource
        self.visibility = visibility
    }
}


extension ResourceAppPreference: Sendable {} 
extension ResourceAppPreference: Equatable, Hashable {
    public static func ==(lhs: ResourceAppPreference, rhs: ResourceAppPreference) -> Bool {
        if lhs.resource != rhs.resource {
            return false
        }
        if lhs.visibility != rhs.visibility {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resource)
        hasher.combine(visibility)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResourceAppPreference: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAppPreference {
        return
            try ResourceAppPreference(
                resource: FfiConverterTypeResourceIdentifier.read(from: &buf), 
                visibility: FfiConverterTypeResourceVisibility.read(from: &buf)
        )
    }

    public static func write(_ value: ResourceAppPreference, into buf: inout [UInt8]) {
        FfiConverterTypeResourceIdentifier.write(value.resource, into: &buf)
        FfiConverterTypeResourceVisibility.write(value.visibility, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceAppPreference_lift(_ buf: RustBuffer) throws -> ResourceAppPreference {
    return try FfiConverterTypeResourceAppPreference.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceAppPreference_lower(_ value: ResourceAppPreference) -> RustBuffer {
    return FfiConverterTypeResourceAppPreference.lower(value)
}


public struct RnsDomainConfiguredReceiver {
    public var domain: RnsDomainDetails
    public var receiver: AccountAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(domain: RnsDomainDetails, receiver: AccountAddress) {
        self.domain = domain
        self.receiver = receiver
    }
}


extension RnsDomainConfiguredReceiver: Sendable {} 
extension RnsDomainConfiguredReceiver: Equatable, Hashable {
    public static func ==(lhs: RnsDomainConfiguredReceiver, rhs: RnsDomainConfiguredReceiver) -> Bool {
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.receiver != rhs.receiver {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(domain)
        hasher.combine(receiver)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRnsDomainConfiguredReceiver: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RnsDomainConfiguredReceiver {
        return
            try RnsDomainConfiguredReceiver(
                domain: FfiConverterTypeRnsDomainDetails.read(from: &buf), 
                receiver: FfiConverterTypeAccountAddress.read(from: &buf)
        )
    }

    public static func write(_ value: RnsDomainConfiguredReceiver, into buf: inout [UInt8]) {
        FfiConverterTypeRnsDomainDetails.write(value.domain, into: &buf)
        FfiConverterTypeAccountAddress.write(value.receiver, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRnsDomainConfiguredReceiver_lift(_ buf: RustBuffer) throws -> RnsDomainConfiguredReceiver {
    return try FfiConverterTypeRnsDomainConfiguredReceiver.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRnsDomainConfiguredReceiver_lower(_ value: RnsDomainConfiguredReceiver) -> RustBuffer {
    return FfiConverterTypeRnsDomainConfiguredReceiver.lower(value)
}


public struct RnsDomainDetails {
    public var domain: RnsDomain
    public var owner: AccountAddress
    public var gradientColorStart: String
    public var gradientColorEnd: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(domain: RnsDomain, owner: AccountAddress, gradientColorStart: String, gradientColorEnd: String) {
        self.domain = domain
        self.owner = owner
        self.gradientColorStart = gradientColorStart
        self.gradientColorEnd = gradientColorEnd
    }
}


extension RnsDomainDetails: Sendable {} 
extension RnsDomainDetails: Equatable, Hashable {
    public static func ==(lhs: RnsDomainDetails, rhs: RnsDomainDetails) -> Bool {
        if lhs.domain != rhs.domain {
            return false
        }
        if lhs.owner != rhs.owner {
            return false
        }
        if lhs.gradientColorStart != rhs.gradientColorStart {
            return false
        }
        if lhs.gradientColorEnd != rhs.gradientColorEnd {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(domain)
        hasher.combine(owner)
        hasher.combine(gradientColorStart)
        hasher.combine(gradientColorEnd)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRnsDomainDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RnsDomainDetails {
        return
            try RnsDomainDetails(
                domain: FfiConverterTypeRnsDomain.read(from: &buf), 
                owner: FfiConverterTypeAccountAddress.read(from: &buf), 
                gradientColorStart: FfiConverterString.read(from: &buf), 
                gradientColorEnd: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RnsDomainDetails, into buf: inout [UInt8]) {
        FfiConverterTypeRnsDomain.write(value.domain, into: &buf)
        FfiConverterTypeAccountAddress.write(value.owner, into: &buf)
        FfiConverterString.write(value.gradientColorStart, into: &buf)
        FfiConverterString.write(value.gradientColorEnd, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRnsDomainDetails_lift(_ buf: RustBuffer) throws -> RnsDomainDetails {
    return try FfiConverterTypeRnsDomainDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRnsDomainDetails_lower(_ value: RnsDomainDetails) -> RustBuffer {
    return FfiConverterTypeRnsDomainDetails.lower(value)
}


public struct SargonBuildInformation {
    public var sargonVersion: String
    public var dependencies: SargonDependencies

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sargonVersion: String, dependencies: SargonDependencies) {
        self.sargonVersion = sargonVersion
        self.dependencies = dependencies
    }
}


extension SargonBuildInformation: Sendable {} 
extension SargonBuildInformation: Equatable, Hashable {
    public static func ==(lhs: SargonBuildInformation, rhs: SargonBuildInformation) -> Bool {
        if lhs.sargonVersion != rhs.sargonVersion {
            return false
        }
        if lhs.dependencies != rhs.dependencies {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sargonVersion)
        hasher.combine(dependencies)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSargonBuildInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonBuildInformation {
        return
            try SargonBuildInformation(
                sargonVersion: FfiConverterString.read(from: &buf), 
                dependencies: FfiConverterTypeSargonDependencies.read(from: &buf)
        )
    }

    public static func write(_ value: SargonBuildInformation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.sargonVersion, into: &buf)
        FfiConverterTypeSargonDependencies.write(value.dependencies, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSargonBuildInformation_lift(_ buf: RustBuffer) throws -> SargonBuildInformation {
    return try FfiConverterTypeSargonBuildInformation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSargonBuildInformation_lower(_ value: SargonBuildInformation) -> RustBuffer {
    return FfiConverterTypeSargonBuildInformation.lower(value)
}


public struct SargonDependencies {
    public var radixEngineToolkit: DependencyInformation
    public var scryptoRadixEngine: DependencyInformation

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(radixEngineToolkit: DependencyInformation, scryptoRadixEngine: DependencyInformation) {
        self.radixEngineToolkit = radixEngineToolkit
        self.scryptoRadixEngine = scryptoRadixEngine
    }
}


extension SargonDependencies: Sendable {} 
extension SargonDependencies: Equatable, Hashable {
    public static func ==(lhs: SargonDependencies, rhs: SargonDependencies) -> Bool {
        if lhs.radixEngineToolkit != rhs.radixEngineToolkit {
            return false
        }
        if lhs.scryptoRadixEngine != rhs.scryptoRadixEngine {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(radixEngineToolkit)
        hasher.combine(scryptoRadixEngine)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSargonDependencies: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonDependencies {
        return
            try SargonDependencies(
                radixEngineToolkit: FfiConverterTypeDependencyInformation.read(from: &buf), 
                scryptoRadixEngine: FfiConverterTypeDependencyInformation.read(from: &buf)
        )
    }

    public static func write(_ value: SargonDependencies, into buf: inout [UInt8]) {
        FfiConverterTypeDependencyInformation.write(value.radixEngineToolkit, into: &buf)
        FfiConverterTypeDependencyInformation.write(value.scryptoRadixEngine, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSargonDependencies_lift(_ buf: RustBuffer) throws -> SargonDependencies {
    return try FfiConverterTypeSargonDependencies.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSargonDependencies_lower(_ value: SargonDependencies) -> RustBuffer {
    return FfiConverterTypeSargonDependencies.lower(value)
}


/**
 * The currently used Gateway and a collection of other by user added
 * or predefined Gateways the user can switch to.
 */
public struct SavedGateways {
    /**
     * The currently used Gateway, when a user query's asset balances of
     * accounts or submits transactions, this Gateway will be used.
     */
    public var current: Gateway
    /**
     * Other by user added or predefined Gateways the user can switch to.
     * It might be Gateways with different URLs on the SAME network, or
     * other networks, the identifier of a Gateway is the URL.
     */
    public var other: [Gateway]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The currently used Gateway, when a user query's asset balances of
         * accounts or submits transactions, this Gateway will be used.
         */current: Gateway, 
        /**
         * Other by user added or predefined Gateways the user can switch to.
         * It might be Gateways with different URLs on the SAME network, or
         * other networks, the identifier of a Gateway is the URL.
         */other: [Gateway]) {
        self.current = current
        self.other = other
    }
}


extension SavedGateways: Sendable {} 
extension SavedGateways: Equatable, Hashable {
    public static func ==(lhs: SavedGateways, rhs: SavedGateways) -> Bool {
        if lhs.current != rhs.current {
            return false
        }
        if lhs.other != rhs.other {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(current)
        hasher.combine(other)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSavedGateways: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SavedGateways {
        return
            try SavedGateways(
                current: FfiConverterTypeGateway.read(from: &buf), 
                other: FfiConverterSequenceTypeGateway.read(from: &buf)
        )
    }

    public static func write(_ value: SavedGateways, into buf: inout [UInt8]) {
        FfiConverterTypeGateway.write(value.current, into: &buf)
        FfiConverterSequenceTypeGateway.write(value.other, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSavedGateways_lift(_ buf: RustBuffer) throws -> SavedGateways {
    return try FfiConverterTypeSavedGateways.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSavedGateways_lower(_ value: SavedGateways) -> RustBuffer {
    return FfiConverterTypeSavedGateways.lower(value)
}


/**
 * A `secp256k1` public key used to verify cryptographic signatures (ECDSA signatures).
 */
public struct Secp256k1PublicKey {
    fileprivate let secretMagic: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BagOfBytes) {
        self.secretMagic = secretMagic
    }
}


extension Secp256k1PublicKey: Sendable {} 
extension Secp256k1PublicKey: Equatable, Hashable {
    public static func ==(lhs: Secp256k1PublicKey, rhs: Secp256k1PublicKey) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecp256k1PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1PublicKey {
        return
            try Secp256k1PublicKey(
                secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
        )
    }

    public static func write(_ value: Secp256k1PublicKey, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecp256k1PublicKey_lift(_ buf: RustBuffer) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecp256k1PublicKey_lower(_ value: Secp256k1PublicKey) -> RustBuffer {
    return FfiConverterTypeSecp256k1PublicKey.lower(value)
}


/**
 * Represents an Secp256k1 signature.
 */
public struct Secp256k1Signature {
    public var bytes: Exactly65Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Exactly65Bytes) {
        self.bytes = bytes
    }
}


extension Secp256k1Signature: Sendable {} 
extension Secp256k1Signature: Equatable, Hashable {
    public static func ==(lhs: Secp256k1Signature, rhs: Secp256k1Signature) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecp256k1Signature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1Signature {
        return
            try Secp256k1Signature(
                bytes: FfiConverterTypeExactly65Bytes.read(from: &buf)
        )
    }

    public static func write(_ value: Secp256k1Signature, into buf: inout [UInt8]) {
        FfiConverterTypeExactly65Bytes.write(value.bytes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecp256k1Signature_lift(_ buf: RustBuffer) throws -> Secp256k1Signature {
    return try FfiConverterTypeSecp256k1Signature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecp256k1Signature_lower(_ value: Secp256k1Signature) -> RustBuffer {
    return FfiConverterTypeSecp256k1Signature.lower(value)
}


/**
 * Advanced security control of an entity which has been "securified",
 * meaning an MFA security structure (`SecurityStructureOfFactorSources`)
 * which user has created has been applied to it.
 */
public struct SecuredEntityControl {
    /**
     * Virtual Entity Creation (Factor)Instance
     *
     * Optional since if we recovered this SecuredEntityControl part of
     * account recovery scan we might not know the veci
     */
    public var veci: HierarchicalDeterministicFactorInstance?
    /**
     * The address of the access controller which controls this entity.
     *
     * Looking up the public key (hashes) set in the key-value store at
     * this address reveals the true factors (public keys) used to protect
     * this entity. It will be the same as the ones in `security_structure`
     * if we have not changed them locally, which we should not do unless
     * we are sure the Ledger corresponds to the values in `security_structure`.
     */
    public var accessControllerAddress: AccessControllerAddress
    /**
     * The believed-to-be-current security structure of FactorInstances which
     * secures this entity.
     */
    public var securityStructure: SecurityStructureOfFactorInstances
    /**
     * A provisional new security structure configuration which user
     * is about to change to
     */
    public var provisionalSecurifiedConfig: ProvisionalSecurifiedConfig?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Virtual Entity Creation (Factor)Instance
         *
         * Optional since if we recovered this SecuredEntityControl part of
         * account recovery scan we might not know the veci
         */veci: HierarchicalDeterministicFactorInstance?, 
        /**
         * The address of the access controller which controls this entity.
         *
         * Looking up the public key (hashes) set in the key-value store at
         * this address reveals the true factors (public keys) used to protect
         * this entity. It will be the same as the ones in `security_structure`
         * if we have not changed them locally, which we should not do unless
         * we are sure the Ledger corresponds to the values in `security_structure`.
         */accessControllerAddress: AccessControllerAddress, 
        /**
         * The believed-to-be-current security structure of FactorInstances which
         * secures this entity.
         */securityStructure: SecurityStructureOfFactorInstances, 
        /**
         * A provisional new security structure configuration which user
         * is about to change to
         */provisionalSecurifiedConfig: ProvisionalSecurifiedConfig?) {
        self.veci = veci
        self.accessControllerAddress = accessControllerAddress
        self.securityStructure = securityStructure
        self.provisionalSecurifiedConfig = provisionalSecurifiedConfig
    }
}


extension SecuredEntityControl: Sendable {} 
extension SecuredEntityControl: Equatable, Hashable {
    public static func ==(lhs: SecuredEntityControl, rhs: SecuredEntityControl) -> Bool {
        if lhs.veci != rhs.veci {
            return false
        }
        if lhs.accessControllerAddress != rhs.accessControllerAddress {
            return false
        }
        if lhs.securityStructure != rhs.securityStructure {
            return false
        }
        if lhs.provisionalSecurifiedConfig != rhs.provisionalSecurifiedConfig {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(veci)
        hasher.combine(accessControllerAddress)
        hasher.combine(securityStructure)
        hasher.combine(provisionalSecurifiedConfig)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecuredEntityControl: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecuredEntityControl {
        return
            try SecuredEntityControl(
                veci: FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.read(from: &buf), 
                accessControllerAddress: FfiConverterTypeAccessControllerAddress.read(from: &buf), 
                securityStructure: FfiConverterTypeSecurityStructureOfFactorInstances.read(from: &buf), 
                provisionalSecurifiedConfig: FfiConverterOptionTypeProvisionalSecurifiedConfig.read(from: &buf)
        )
    }

    public static func write(_ value: SecuredEntityControl, into buf: inout [UInt8]) {
        FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.write(value.veci, into: &buf)
        FfiConverterTypeAccessControllerAddress.write(value.accessControllerAddress, into: &buf)
        FfiConverterTypeSecurityStructureOfFactorInstances.write(value.securityStructure, into: &buf)
        FfiConverterOptionTypeProvisionalSecurifiedConfig.write(value.provisionalSecurifiedConfig, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecuredEntityControl_lift(_ buf: RustBuffer) throws -> SecuredEntityControl {
    return try FfiConverterTypeSecuredEntityControl.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecuredEntityControl_lower(_ value: SecuredEntityControl) -> RustBuffer {
    return FfiConverterTypeSecuredEntityControl.lower(value)
}


public struct SecurifiedU30 {
    fileprivate let secretMagic: U30

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: U30) {
        self.secretMagic = secretMagic
    }
}


extension SecurifiedU30: Sendable {} 
extension SecurifiedU30: Equatable, Hashable {
    public static func ==(lhs: SecurifiedU30, rhs: SecurifiedU30) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurifiedU30: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurifiedU30 {
        return
            try SecurifiedU30(
                secretMagic: FfiConverterTypeU30.read(from: &buf)
        )
    }

    public static func write(_ value: SecurifiedU30, into buf: inout [UInt8]) {
        FfiConverterTypeU30.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurifiedU30_lift(_ buf: RustBuffer) throws -> SecurifiedU30 {
    return try FfiConverterTypeSecurifiedU30.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurifiedU30_lower(_ value: SecurifiedU30) -> RustBuffer {
    return FfiConverterTypeSecurifiedU30.lower(value)
}


/**
 * Controls e.g. if Profile Snapshot gets synced to iCloud or not, and whether
 * developer mode is enabled or not. In future (MFA) we will also save a list of
 * MFA security structure configurations.
 */
public struct Security {
    public var isCloudProfileSyncEnabled: Bool
    public var isDeveloperModeEnabled: Bool
    public var isAdvancedLockEnabled: Bool
    public var securityStructuresOfFactorSourceIds: [SecurityStructureOfFactorSourceIDs]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isCloudProfileSyncEnabled: Bool, isDeveloperModeEnabled: Bool, isAdvancedLockEnabled: Bool, securityStructuresOfFactorSourceIds: [SecurityStructureOfFactorSourceIDs]) {
        self.isCloudProfileSyncEnabled = isCloudProfileSyncEnabled
        self.isDeveloperModeEnabled = isDeveloperModeEnabled
        self.isAdvancedLockEnabled = isAdvancedLockEnabled
        self.securityStructuresOfFactorSourceIds = securityStructuresOfFactorSourceIds
    }
}


extension Security: Sendable {} 
extension Security: Equatable, Hashable {
    public static func ==(lhs: Security, rhs: Security) -> Bool {
        if lhs.isCloudProfileSyncEnabled != rhs.isCloudProfileSyncEnabled {
            return false
        }
        if lhs.isDeveloperModeEnabled != rhs.isDeveloperModeEnabled {
            return false
        }
        if lhs.isAdvancedLockEnabled != rhs.isAdvancedLockEnabled {
            return false
        }
        if lhs.securityStructuresOfFactorSourceIds != rhs.securityStructuresOfFactorSourceIds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCloudProfileSyncEnabled)
        hasher.combine(isDeveloperModeEnabled)
        hasher.combine(isAdvancedLockEnabled)
        hasher.combine(securityStructuresOfFactorSourceIds)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Security {
        return
            try Security(
                isCloudProfileSyncEnabled: FfiConverterBool.read(from: &buf), 
                isDeveloperModeEnabled: FfiConverterBool.read(from: &buf), 
                isAdvancedLockEnabled: FfiConverterBool.read(from: &buf), 
                securityStructuresOfFactorSourceIds: FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.read(from: &buf)
        )
    }

    public static func write(_ value: Security, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCloudProfileSyncEnabled, into: &buf)
        FfiConverterBool.write(value.isDeveloperModeEnabled, into: &buf)
        FfiConverterBool.write(value.isAdvancedLockEnabled, into: &buf)
        FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.write(value.securityStructuresOfFactorSourceIds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurity_lift(_ buf: RustBuffer) throws -> Security {
    return try FfiConverterTypeSecurity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurity_lower(_ value: Security) -> RustBuffer {
    return FfiConverterTypeSecurity.lower(value)
}


/**
 *  NOT PRODUCTION READY YET 
 * A key derivation function which produces Encryption Keys from a set of
 * key exchange keys, by performing Diffie-Hellman key exchange on each
 * Key Exchange Key in a Set, by "folding" from left to right.
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}


extension SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold: Sendable {} 
extension SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold: Equatable, Hashable {
    public static func ==(lhs: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold, rhs: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold {
        return
            SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold()
    }

    public static func write(_ value: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold_lower(_ value: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold) -> RustBuffer {
    return FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.lower(value)
}


/**
 *  NOT PRODUCTION READY YET 
 * A Key Derivation Scheme which lowercases, trims and ut8f encodes answers.
 *  NOT PRODUCTION READY YET 
 */
public struct SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8 {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }
}


extension SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8: Sendable {} 
extension SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8: Equatable, Hashable {
    public static func ==(lhs: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8, rhs: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8) -> Bool {
        return true
    }

    public func hash(into hasher: inout Hasher) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8 {
        return
            SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8()
    }

    public static func write(_ value: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8 {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8_lower(_ value: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8) -> RustBuffer {
    return FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.lower(value)
}


/**
 * Represents the reason why the `SecurityShieldBuilder` has an invalid status.
 * This struct contains the specific reasons for each component of the security shield builder
 * being invalid. The components include:
 * - Primary role
 * - Recovery role
 * - Confirmation role
 * - Authentication signing
 */
public struct SecurityShieldBuilderStatusInvalidReason {
    public var isPrimaryRoleFactorListEmpty: Bool
    public var isRecoveryRoleFactorListEmpty: Bool
    public var isConfirmationRoleFactorListEmpty: Bool
    public var isAuthSigningFactorMissing: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isPrimaryRoleFactorListEmpty: Bool, isRecoveryRoleFactorListEmpty: Bool, isConfirmationRoleFactorListEmpty: Bool, isAuthSigningFactorMissing: Bool) {
        self.isPrimaryRoleFactorListEmpty = isPrimaryRoleFactorListEmpty
        self.isRecoveryRoleFactorListEmpty = isRecoveryRoleFactorListEmpty
        self.isConfirmationRoleFactorListEmpty = isConfirmationRoleFactorListEmpty
        self.isAuthSigningFactorMissing = isAuthSigningFactorMissing
    }
}


extension SecurityShieldBuilderStatusInvalidReason: Sendable {} 
extension SecurityShieldBuilderStatusInvalidReason: Equatable, Hashable {
    public static func ==(lhs: SecurityShieldBuilderStatusInvalidReason, rhs: SecurityShieldBuilderStatusInvalidReason) -> Bool {
        if lhs.isPrimaryRoleFactorListEmpty != rhs.isPrimaryRoleFactorListEmpty {
            return false
        }
        if lhs.isRecoveryRoleFactorListEmpty != rhs.isRecoveryRoleFactorListEmpty {
            return false
        }
        if lhs.isConfirmationRoleFactorListEmpty != rhs.isConfirmationRoleFactorListEmpty {
            return false
        }
        if lhs.isAuthSigningFactorMissing != rhs.isAuthSigningFactorMissing {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isPrimaryRoleFactorListEmpty)
        hasher.combine(isRecoveryRoleFactorListEmpty)
        hasher.combine(isConfirmationRoleFactorListEmpty)
        hasher.combine(isAuthSigningFactorMissing)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityShieldBuilderStatusInvalidReason: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityShieldBuilderStatusInvalidReason {
        return
            try SecurityShieldBuilderStatusInvalidReason(
                isPrimaryRoleFactorListEmpty: FfiConverterBool.read(from: &buf), 
                isRecoveryRoleFactorListEmpty: FfiConverterBool.read(from: &buf), 
                isConfirmationRoleFactorListEmpty: FfiConverterBool.read(from: &buf), 
                isAuthSigningFactorMissing: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SecurityShieldBuilderStatusInvalidReason, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isPrimaryRoleFactorListEmpty, into: &buf)
        FfiConverterBool.write(value.isRecoveryRoleFactorListEmpty, into: &buf)
        FfiConverterBool.write(value.isConfirmationRoleFactorListEmpty, into: &buf)
        FfiConverterBool.write(value.isAuthSigningFactorMissing, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityShieldBuilderStatusInvalidReason_lift(_ buf: RustBuffer) throws -> SecurityShieldBuilderStatusInvalidReason {
    return try FfiConverterTypeSecurityShieldBuilderStatusInvalidReason.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityShieldBuilderStatusInvalidReason_lower(_ value: SecurityShieldBuilderStatusInvalidReason) -> RustBuffer {
    return FfiConverterTypeSecurityShieldBuilderStatusInvalidReason.lower(value)
}


public struct SecurityStructureMetadata {
    public var id: SecurityStructureId
    public var displayName: DisplayName
    public var createdOn: Timestamp
    public var lastUpdatedOn: Timestamp
    public var flags: [SecurityStructureFlag]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: SecurityStructureId, displayName: DisplayName, createdOn: Timestamp, lastUpdatedOn: Timestamp, flags: [SecurityStructureFlag]) {
        self.id = id
        self.displayName = displayName
        self.createdOn = createdOn
        self.lastUpdatedOn = lastUpdatedOn
        self.flags = flags
    }
}


extension SecurityStructureMetadata: Sendable {} 
extension SecurityStructureMetadata: Equatable, Hashable {
    public static func ==(lhs: SecurityStructureMetadata, rhs: SecurityStructureMetadata) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.createdOn != rhs.createdOn {
            return false
        }
        if lhs.lastUpdatedOn != rhs.lastUpdatedOn {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(displayName)
        hasher.combine(createdOn)
        hasher.combine(lastUpdatedOn)
        hasher.combine(flags)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityStructureMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureMetadata {
        return
            try SecurityStructureMetadata(
                id: FfiConverterTypeSecurityStructureID.read(from: &buf), 
                displayName: FfiConverterTypeDisplayName.read(from: &buf), 
                createdOn: FfiConverterTypeTimestamp.read(from: &buf), 
                lastUpdatedOn: FfiConverterTypeTimestamp.read(from: &buf), 
                flags: FfiConverterSequenceTypeSecurityStructureFlag.read(from: &buf)
        )
    }

    public static func write(_ value: SecurityStructureMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureID.write(value.id, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeTimestamp.write(value.createdOn, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastUpdatedOn, into: &buf)
        FfiConverterSequenceTypeSecurityStructureFlag.write(value.flags, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityStructureMetadata_lift(_ buf: RustBuffer) throws -> SecurityStructureMetadata {
    return try FfiConverterTypeSecurityStructureMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityStructureMetadata_lower(_ value: SecurityStructureMetadata) -> RustBuffer {
    return FfiConverterTypeSecurityStructureMetadata.lower(value)
}


/**
 * A MatrixOfFactorInstances and an ID which identifies it, this is
 * the Profile data structure representation of the owner key hashes which
 * have been uploaded as Scrypto AccessRules on the AccessController on-ledger.
 *
 * Also contains an authentication signing factor instance which is used for
 * Rola.
 */
public struct SecurityStructureOfFactorInstances {
    /**
     * The ID of the `SecurityStructureOfFactorSourceIDs` in
     * `profile.app_preferences.security.security_structures_of_factor_source_ids`
     * which was used to derive the factor instances in this structure. Or rather:
     * The id of `SecurityStructureOfFactorSources`.
     */
    public var securityStructureId: SecurityStructureId
    /**
     * The structure of factors to use for certain roles, Primary, Recovery
     * and Confirmation role.
     */
    public var matrixOfFactors: MatrixOfFactorInstances
    /**
     * The authentication signing factor instance which is used to sign
     * proof of ownership - aka "True Rola Key". User can select which FactorSource
     * to use during Shield Building, but typically most users will use the
     * DeviceFactorSource which is default. DerivationPath is in securified
     * KeySpace of course.
     *
     * Non-optional since we can replace it with a new one for entities
     * we have recovered during Onboarding Account Recovery Scan for securified
     * entities
     */
    public var authenticationSigningFactorInstance: HierarchicalDeterministicFactorInstance

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the `SecurityStructureOfFactorSourceIDs` in
         * `profile.app_preferences.security.security_structures_of_factor_source_ids`
         * which was used to derive the factor instances in this structure. Or rather:
         * The id of `SecurityStructureOfFactorSources`.
         */securityStructureId: SecurityStructureId, 
        /**
         * The structure of factors to use for certain roles, Primary, Recovery
         * and Confirmation role.
         */matrixOfFactors: MatrixOfFactorInstances, 
        /**
         * The authentication signing factor instance which is used to sign
         * proof of ownership - aka "True Rola Key". User can select which FactorSource
         * to use during Shield Building, but typically most users will use the
         * DeviceFactorSource which is default. DerivationPath is in securified
         * KeySpace of course.
         *
         * Non-optional since we can replace it with a new one for entities
         * we have recovered during Onboarding Account Recovery Scan for securified
         * entities
         */authenticationSigningFactorInstance: HierarchicalDeterministicFactorInstance) {
        self.securityStructureId = securityStructureId
        self.matrixOfFactors = matrixOfFactors
        self.authenticationSigningFactorInstance = authenticationSigningFactorInstance
    }
}


extension SecurityStructureOfFactorInstances: Sendable {} 
extension SecurityStructureOfFactorInstances: Equatable, Hashable {
    public static func ==(lhs: SecurityStructureOfFactorInstances, rhs: SecurityStructureOfFactorInstances) -> Bool {
        if lhs.securityStructureId != rhs.securityStructureId {
            return false
        }
        if lhs.matrixOfFactors != rhs.matrixOfFactors {
            return false
        }
        if lhs.authenticationSigningFactorInstance != rhs.authenticationSigningFactorInstance {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(securityStructureId)
        hasher.combine(matrixOfFactors)
        hasher.combine(authenticationSigningFactorInstance)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityStructureOfFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureOfFactorInstances {
        return
            try SecurityStructureOfFactorInstances(
                securityStructureId: FfiConverterTypeSecurityStructureID.read(from: &buf), 
                matrixOfFactors: FfiConverterTypeMatrixOfFactorInstances.read(from: &buf), 
                authenticationSigningFactorInstance: FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
        )
    }

    public static func write(_ value: SecurityStructureOfFactorInstances, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureID.write(value.securityStructureId, into: &buf)
        FfiConverterTypeMatrixOfFactorInstances.write(value.matrixOfFactors, into: &buf)
        FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value.authenticationSigningFactorInstance, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityStructureOfFactorInstances_lift(_ buf: RustBuffer) throws -> SecurityStructureOfFactorInstances {
    return try FfiConverterTypeSecurityStructureOfFactorInstances.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityStructureOfFactorInstances_lower(_ value: SecurityStructureOfFactorInstances) -> RustBuffer {
    return FfiConverterTypeSecurityStructureOfFactorInstances.lower(value)
}


/**
 * A `MatrixOfFactorSourceIDs` and associated metadata, this is
 * the Profile data structure representation of a "SecurityShield".
 */
public struct SecurityStructureOfFactorSourceIDs {
    /**
     * Metadata of this Security Structure, such as globally unique and
     * stable identifier, creation date and user chosen label (name).
     */
    public var metadata: SecurityStructureMetadata
    /**
     * The structure of factors to use for certain roles, Primary, Recovery
     * and Confirmation role.
     */
    public var matrixOfFactors: MatrixOfFactorSourceIDs
    /**
     * The factor to use for authentication signing aka true Rola Key.
     */
    public var authenticationSigningFactor: FactorSourceId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Metadata of this Security Structure, such as globally unique and
         * stable identifier, creation date and user chosen label (name).
         */metadata: SecurityStructureMetadata, 
        /**
         * The structure of factors to use for certain roles, Primary, Recovery
         * and Confirmation role.
         */matrixOfFactors: MatrixOfFactorSourceIDs, 
        /**
         * The factor to use for authentication signing aka true Rola Key.
         */authenticationSigningFactor: FactorSourceId) {
        self.metadata = metadata
        self.matrixOfFactors = matrixOfFactors
        self.authenticationSigningFactor = authenticationSigningFactor
    }
}


extension SecurityStructureOfFactorSourceIDs: Sendable {} 
extension SecurityStructureOfFactorSourceIDs: Equatable, Hashable {
    public static func ==(lhs: SecurityStructureOfFactorSourceIDs, rhs: SecurityStructureOfFactorSourceIDs) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.matrixOfFactors != rhs.matrixOfFactors {
            return false
        }
        if lhs.authenticationSigningFactor != rhs.authenticationSigningFactor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
        hasher.combine(matrixOfFactors)
        hasher.combine(authenticationSigningFactor)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityStructureOfFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureOfFactorSourceIDs {
        return
            try SecurityStructureOfFactorSourceIDs(
                metadata: FfiConverterTypeSecurityStructureMetadata.read(from: &buf), 
                matrixOfFactors: FfiConverterTypeMatrixOfFactorSourceIDs.read(from: &buf), 
                authenticationSigningFactor: FfiConverterTypeFactorSourceID.read(from: &buf)
        )
    }

    public static func write(_ value: SecurityStructureOfFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureMetadata.write(value.metadata, into: &buf)
        FfiConverterTypeMatrixOfFactorSourceIDs.write(value.matrixOfFactors, into: &buf)
        FfiConverterTypeFactorSourceID.write(value.authenticationSigningFactor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityStructureOfFactorSourceIDs_lift(_ buf: RustBuffer) throws -> SecurityStructureOfFactorSourceIDs {
    return try FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityStructureOfFactorSourceIDs_lower(_ value: SecurityStructureOfFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypeSecurityStructureOfFactorSourceIDs.lower(value)
}


public struct SecurityStructureOfFactorSources {
    /**
     * Metadata of this Security Structure, such as globally unique and
     * stable identifier, creation date and user chosen label (name).
     */
    public var metadata: SecurityStructureMetadata
    /**
     * The structure of factors to use for certain roles, Primary, Recovery
     * and Confirmation role.
     */
    public var matrixOfFactors: MatrixOfFactorSources
    /**
     * The factor to use for authentication signing aka true Rola Key.
     */
    public var authenticationSigningFactor: FactorSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Metadata of this Security Structure, such as globally unique and
         * stable identifier, creation date and user chosen label (name).
         */metadata: SecurityStructureMetadata, 
        /**
         * The structure of factors to use for certain roles, Primary, Recovery
         * and Confirmation role.
         */matrixOfFactors: MatrixOfFactorSources, 
        /**
         * The factor to use for authentication signing aka true Rola Key.
         */authenticationSigningFactor: FactorSource) {
        self.metadata = metadata
        self.matrixOfFactors = matrixOfFactors
        self.authenticationSigningFactor = authenticationSigningFactor
    }
}


extension SecurityStructureOfFactorSources: Sendable {} 
extension SecurityStructureOfFactorSources: Equatable, Hashable {
    public static func ==(lhs: SecurityStructureOfFactorSources, rhs: SecurityStructureOfFactorSources) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.matrixOfFactors != rhs.matrixOfFactors {
            return false
        }
        if lhs.authenticationSigningFactor != rhs.authenticationSigningFactor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
        hasher.combine(matrixOfFactors)
        hasher.combine(authenticationSigningFactor)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityStructureOfFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureOfFactorSources {
        return
            try SecurityStructureOfFactorSources(
                metadata: FfiConverterTypeSecurityStructureMetadata.read(from: &buf), 
                matrixOfFactors: FfiConverterTypeMatrixOfFactorSources.read(from: &buf), 
                authenticationSigningFactor: FfiConverterTypeFactorSource.read(from: &buf)
        )
    }

    public static func write(_ value: SecurityStructureOfFactorSources, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureMetadata.write(value.metadata, into: &buf)
        FfiConverterTypeMatrixOfFactorSources.write(value.matrixOfFactors, into: &buf)
        FfiConverterTypeFactorSource.write(value.authenticationSigningFactor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityStructureOfFactorSources_lift(_ buf: RustBuffer) throws -> SecurityStructureOfFactorSources {
    return try FfiConverterTypeSecurityStructureOfFactorSources.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityStructureOfFactorSources_lower(_ value: SecurityStructureOfFactorSources) -> RustBuffer {
    return FfiConverterTypeSecurityStructureOfFactorSources.lower(value)
}


/**
 * Identities for PersonaData entry values a user have shared with a dApp.
 */
public struct SharedPersonaData {
    /**
     * ID of a `PersonaDataEntryName` the user has shared with some dApp on some network,
     * can be `None`.
     */
    public var name: PersonaDataEntryId?
    /**
     * IDs of a `PersonaDataEntryEmailAddress`es the user has shared with some dApp on some network
     * can be `None`, or can be `Some(<EMPTY>)`.
     */
    public var emailAddresses: SharedToDappWithPersonaIDsOfPersonaDataEntries?
    /**
     * IDs of a `PersonaDataEntryPhoneNumber`s the user has shared with some dApp on some network
     * can be `None`, or can be `Some(<EMPTY>)`.
     */
    public var phoneNumbers: SharedToDappWithPersonaIDsOfPersonaDataEntries?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * ID of a `PersonaDataEntryName` the user has shared with some dApp on some network,
         * can be `None`.
         */name: PersonaDataEntryId?, 
        /**
         * IDs of a `PersonaDataEntryEmailAddress`es the user has shared with some dApp on some network
         * can be `None`, or can be `Some(<EMPTY>)`.
         */emailAddresses: SharedToDappWithPersonaIDsOfPersonaDataEntries?, 
        /**
         * IDs of a `PersonaDataEntryPhoneNumber`s the user has shared with some dApp on some network
         * can be `None`, or can be `Some(<EMPTY>)`.
         */phoneNumbers: SharedToDappWithPersonaIDsOfPersonaDataEntries?) {
        self.name = name
        self.emailAddresses = emailAddresses
        self.phoneNumbers = phoneNumbers
    }
}


extension SharedPersonaData: Sendable {} 
extension SharedPersonaData: Equatable, Hashable {
    public static func ==(lhs: SharedPersonaData, rhs: SharedPersonaData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(emailAddresses)
        hasher.combine(phoneNumbers)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSharedPersonaData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedPersonaData {
        return
            try SharedPersonaData(
                name: FfiConverterOptionTypePersonaDataEntryID.read(from: &buf), 
                emailAddresses: FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf), 
                phoneNumbers: FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf)
        )
    }

    public static func write(_ value: SharedPersonaData, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataEntryID.write(value.name, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value.emailAddresses, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value.phoneNumbers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSharedPersonaData_lift(_ buf: RustBuffer) throws -> SharedPersonaData {
    return try FfiConverterTypeSharedPersonaData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSharedPersonaData_lower(_ value: SharedPersonaData) -> RustBuffer {
    return FfiConverterTypeSharedPersonaData.lower(value)
}


/**
 * IDs that have been shared with an Dapp the user has interacted with
 * that fulfill a Dapp request's specified [`RequestedQuantity`].
 */
public struct SharedToDappWithPersonaAccountAddresses {
    /**
     * The requested quantity to be shared by user, sent by a Dapp.
     */
    public var request: RequestedQuantity
    /**
     * The by user shared IDs of data identifiable data shared with the
     * Dapp.
     */
    public var ids: [AccountAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The requested quantity to be shared by user, sent by a Dapp.
         */request: RequestedQuantity, 
        /**
         * The by user shared IDs of data identifiable data shared with the
         * Dapp.
         */ids: [AccountAddress]) {
        self.request = request
        self.ids = ids
    }
}


extension SharedToDappWithPersonaAccountAddresses: Sendable {} 
extension SharedToDappWithPersonaAccountAddresses: Equatable, Hashable {
    public static func ==(lhs: SharedToDappWithPersonaAccountAddresses, rhs: SharedToDappWithPersonaAccountAddresses) -> Bool {
        if lhs.request != rhs.request {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(request)
        hasher.combine(ids)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSharedToDappWithPersonaAccountAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedToDappWithPersonaAccountAddresses {
        return
            try SharedToDappWithPersonaAccountAddresses(
                request: FfiConverterTypeRequestedQuantity.read(from: &buf), 
                ids: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
        )
    }

    public static func write(_ value: SharedToDappWithPersonaAccountAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.request, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.ids, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSharedToDappWithPersonaAccountAddresses_lift(_ buf: RustBuffer) throws -> SharedToDappWithPersonaAccountAddresses {
    return try FfiConverterTypeSharedToDappWithPersonaAccountAddresses.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSharedToDappWithPersonaAccountAddresses_lower(_ value: SharedToDappWithPersonaAccountAddresses) -> RustBuffer {
    return FfiConverterTypeSharedToDappWithPersonaAccountAddresses.lower(value)
}


/**
 * IDs that have been shared with an Dapp the user has interacted with
 * that fulfill a Dapp request's specified [`RequestedQuantity`].
 */
public struct SharedToDappWithPersonaIDsOfPersonaDataEntries {
    /**
     * The requested quantity to be shared by user, sent by a Dapp.
     */
    public var request: RequestedQuantity
    /**
     * The by user shared IDs of data identifiable data shared with the
     * Dapp.
     */
    public var ids: [PersonaDataEntryId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The requested quantity to be shared by user, sent by a Dapp.
         */request: RequestedQuantity, 
        /**
         * The by user shared IDs of data identifiable data shared with the
         * Dapp.
         */ids: [PersonaDataEntryId]) {
        self.request = request
        self.ids = ids
    }
}


extension SharedToDappWithPersonaIDsOfPersonaDataEntries: Sendable {} 
extension SharedToDappWithPersonaIDsOfPersonaDataEntries: Equatable, Hashable {
    public static func ==(lhs: SharedToDappWithPersonaIDsOfPersonaDataEntries, rhs: SharedToDappWithPersonaIDsOfPersonaDataEntries) -> Bool {
        if lhs.request != rhs.request {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(request)
        hasher.combine(ids)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedToDappWithPersonaIDsOfPersonaDataEntries {
        return
            try SharedToDappWithPersonaIDsOfPersonaDataEntries(
                request: FfiConverterTypeRequestedQuantity.read(from: &buf), 
                ids: FfiConverterSequenceTypePersonaDataEntryID.read(from: &buf)
        )
    }

    public static func write(_ value: SharedToDappWithPersonaIDsOfPersonaDataEntries, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.request, into: &buf)
        FfiConverterSequenceTypePersonaDataEntryID.write(value.ids, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries_lift(_ buf: RustBuffer) throws -> SharedToDappWithPersonaIDsOfPersonaDataEntries {
    return try FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries_lower(_ value: SharedToDappWithPersonaIDsOfPersonaDataEntries) -> RustBuffer {
    return FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.lower(value)
}


/**
 * A minimal version of a Security Structure meant for display purposes within wallet
 */
public struct ShieldForDisplay {
    public var metadata: SecurityStructureMetadata
    public var numberOfLinkedAccounts: UInt32
    public var numberOfLinkedHiddenAccounts: UInt32
    public var numberOfLinkedPersonas: UInt32
    public var numberOfLinkedHiddenPersonas: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(metadata: SecurityStructureMetadata, numberOfLinkedAccounts: UInt32, numberOfLinkedHiddenAccounts: UInt32, numberOfLinkedPersonas: UInt32, numberOfLinkedHiddenPersonas: UInt32) {
        self.metadata = metadata
        self.numberOfLinkedAccounts = numberOfLinkedAccounts
        self.numberOfLinkedHiddenAccounts = numberOfLinkedHiddenAccounts
        self.numberOfLinkedPersonas = numberOfLinkedPersonas
        self.numberOfLinkedHiddenPersonas = numberOfLinkedHiddenPersonas
    }
}


extension ShieldForDisplay: Sendable {} 
extension ShieldForDisplay: Equatable, Hashable {
    public static func ==(lhs: ShieldForDisplay, rhs: ShieldForDisplay) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.numberOfLinkedAccounts != rhs.numberOfLinkedAccounts {
            return false
        }
        if lhs.numberOfLinkedHiddenAccounts != rhs.numberOfLinkedHiddenAccounts {
            return false
        }
        if lhs.numberOfLinkedPersonas != rhs.numberOfLinkedPersonas {
            return false
        }
        if lhs.numberOfLinkedHiddenPersonas != rhs.numberOfLinkedHiddenPersonas {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
        hasher.combine(numberOfLinkedAccounts)
        hasher.combine(numberOfLinkedHiddenAccounts)
        hasher.combine(numberOfLinkedPersonas)
        hasher.combine(numberOfLinkedHiddenPersonas)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeShieldForDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShieldForDisplay {
        return
            try ShieldForDisplay(
                metadata: FfiConverterTypeSecurityStructureMetadata.read(from: &buf), 
                numberOfLinkedAccounts: FfiConverterUInt32.read(from: &buf), 
                numberOfLinkedHiddenAccounts: FfiConverterUInt32.read(from: &buf), 
                numberOfLinkedPersonas: FfiConverterUInt32.read(from: &buf), 
                numberOfLinkedHiddenPersonas: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ShieldForDisplay, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureMetadata.write(value.metadata, into: &buf)
        FfiConverterUInt32.write(value.numberOfLinkedAccounts, into: &buf)
        FfiConverterUInt32.write(value.numberOfLinkedHiddenAccounts, into: &buf)
        FfiConverterUInt32.write(value.numberOfLinkedPersonas, into: &buf)
        FfiConverterUInt32.write(value.numberOfLinkedHiddenPersonas, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShieldForDisplay_lift(_ buf: RustBuffer) throws -> ShieldForDisplay {
    return try FfiConverterTypeShieldForDisplay.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShieldForDisplay_lower(_ value: ShieldForDisplay) -> RustBuffer {
    return FfiConverterTypeShieldForDisplay.lower(value)
}


public struct SignRequestOfAuthIntent {
    public var factorSourceKind: FactorSourceKind
    /**
     * Per factor source, a set of inputs that contain information on what signables need signing,
     * and what signables will fail if such factor source is neglected.
     */
    public var perFactorSource: [PerFactorSourceInputOfAuthIntent]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceKind: FactorSourceKind, 
        /**
         * Per factor source, a set of inputs that contain information on what signables need signing,
         * and what signables will fail if such factor source is neglected.
         */perFactorSource: [PerFactorSourceInputOfAuthIntent]) {
        self.factorSourceKind = factorSourceKind
        self.perFactorSource = perFactorSource
    }
}


extension SignRequestOfAuthIntent: Sendable {} 
extension SignRequestOfAuthIntent: Equatable, Hashable {
    public static func ==(lhs: SignRequestOfAuthIntent, rhs: SignRequestOfAuthIntent) -> Bool {
        if lhs.factorSourceKind != rhs.factorSourceKind {
            return false
        }
        if lhs.perFactorSource != rhs.perFactorSource {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceKind)
        hasher.combine(perFactorSource)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignRequestOfAuthIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignRequestOfAuthIntent {
        return
            try SignRequestOfAuthIntent(
                factorSourceKind: FfiConverterTypeFactorSourceKind.read(from: &buf), 
                perFactorSource: FfiConverterSequenceTypePerFactorSourceInputOfAuthIntent.read(from: &buf)
        )
    }

    public static func write(_ value: SignRequestOfAuthIntent, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.factorSourceKind, into: &buf)
        FfiConverterSequenceTypePerFactorSourceInputOfAuthIntent.write(value.perFactorSource, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignRequestOfAuthIntent_lift(_ buf: RustBuffer) throws -> SignRequestOfAuthIntent {
    return try FfiConverterTypeSignRequestOfAuthIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignRequestOfAuthIntent_lower(_ value: SignRequestOfAuthIntent) -> RustBuffer {
    return FfiConverterTypeSignRequestOfAuthIntent.lower(value)
}


public struct SignRequestOfSubintent {
    public var factorSourceKind: FactorSourceKind
    /**
     * Per factor source, a set of inputs that contain information on what signables need signing,
     * and what signables will fail if such factor source is neglected.
     */
    public var perFactorSource: [PerFactorSourceInputOfSubintent]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceKind: FactorSourceKind, 
        /**
         * Per factor source, a set of inputs that contain information on what signables need signing,
         * and what signables will fail if such factor source is neglected.
         */perFactorSource: [PerFactorSourceInputOfSubintent]) {
        self.factorSourceKind = factorSourceKind
        self.perFactorSource = perFactorSource
    }
}


extension SignRequestOfSubintent: Sendable {} 
extension SignRequestOfSubintent: Equatable, Hashable {
    public static func ==(lhs: SignRequestOfSubintent, rhs: SignRequestOfSubintent) -> Bool {
        if lhs.factorSourceKind != rhs.factorSourceKind {
            return false
        }
        if lhs.perFactorSource != rhs.perFactorSource {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceKind)
        hasher.combine(perFactorSource)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignRequestOfSubintent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignRequestOfSubintent {
        return
            try SignRequestOfSubintent(
                factorSourceKind: FfiConverterTypeFactorSourceKind.read(from: &buf), 
                perFactorSource: FfiConverterSequenceTypePerFactorSourceInputOfSubintent.read(from: &buf)
        )
    }

    public static func write(_ value: SignRequestOfSubintent, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.factorSourceKind, into: &buf)
        FfiConverterSequenceTypePerFactorSourceInputOfSubintent.write(value.perFactorSource, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignRequestOfSubintent_lift(_ buf: RustBuffer) throws -> SignRequestOfSubintent {
    return try FfiConverterTypeSignRequestOfSubintent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignRequestOfSubintent_lower(_ value: SignRequestOfSubintent) -> RustBuffer {
    return FfiConverterTypeSignRequestOfSubintent.lower(value)
}


public struct SignRequestOfTransactionIntent {
    public var factorSourceKind: FactorSourceKind
    /**
     * Per factor source, a set of inputs that contain information on what signables need signing,
     * and what signables will fail if such factor source is neglected.
     */
    public var perFactorSource: [PerFactorSourceInputOfTransactionIntent]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceKind: FactorSourceKind, 
        /**
         * Per factor source, a set of inputs that contain information on what signables need signing,
         * and what signables will fail if such factor source is neglected.
         */perFactorSource: [PerFactorSourceInputOfTransactionIntent]) {
        self.factorSourceKind = factorSourceKind
        self.perFactorSource = perFactorSource
    }
}


extension SignRequestOfTransactionIntent: Sendable {} 
extension SignRequestOfTransactionIntent: Equatable, Hashable {
    public static func ==(lhs: SignRequestOfTransactionIntent, rhs: SignRequestOfTransactionIntent) -> Bool {
        if lhs.factorSourceKind != rhs.factorSourceKind {
            return false
        }
        if lhs.perFactorSource != rhs.perFactorSource {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceKind)
        hasher.combine(perFactorSource)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignRequestOfTransactionIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignRequestOfTransactionIntent {
        return
            try SignRequestOfTransactionIntent(
                factorSourceKind: FfiConverterTypeFactorSourceKind.read(from: &buf), 
                perFactorSource: FfiConverterSequenceTypePerFactorSourceInputOfTransactionIntent.read(from: &buf)
        )
    }

    public static func write(_ value: SignRequestOfTransactionIntent, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.factorSourceKind, into: &buf)
        FfiConverterSequenceTypePerFactorSourceInputOfTransactionIntent.write(value.perFactorSource, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignRequestOfTransactionIntent_lift(_ buf: RustBuffer) throws -> SignRequestOfTransactionIntent {
    return try FfiConverterTypeSignRequestOfTransactionIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignRequestOfTransactionIntent_lower(_ value: SignRequestOfTransactionIntent) -> RustBuffer {
    return FfiConverterTypeSignRequestOfTransactionIntent.lower(value)
}


public struct SignResponseOfAuthIntentHash {
    public var perFactorOutcome: [PerFactorOutcomeOfAuthIntentHash]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(perFactorOutcome: [PerFactorOutcomeOfAuthIntentHash]) {
        self.perFactorOutcome = perFactorOutcome
    }
}


extension SignResponseOfAuthIntentHash: Sendable {} 
extension SignResponseOfAuthIntentHash: Equatable, Hashable {
    public static func ==(lhs: SignResponseOfAuthIntentHash, rhs: SignResponseOfAuthIntentHash) -> Bool {
        if lhs.perFactorOutcome != rhs.perFactorOutcome {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(perFactorOutcome)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignResponseOfAuthIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignResponseOfAuthIntentHash {
        return
            try SignResponseOfAuthIntentHash(
                perFactorOutcome: FfiConverterSequenceTypePerFactorOutcomeOfAuthIntentHash.read(from: &buf)
        )
    }

    public static func write(_ value: SignResponseOfAuthIntentHash, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePerFactorOutcomeOfAuthIntentHash.write(value.perFactorOutcome, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignResponseOfAuthIntentHash_lift(_ buf: RustBuffer) throws -> SignResponseOfAuthIntentHash {
    return try FfiConverterTypeSignResponseOfAuthIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignResponseOfAuthIntentHash_lower(_ value: SignResponseOfAuthIntentHash) -> RustBuffer {
    return FfiConverterTypeSignResponseOfAuthIntentHash.lower(value)
}


public struct SignResponseOfSubintentHash {
    public var perFactorOutcome: [PerFactorOutcomeOfSubintentHash]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(perFactorOutcome: [PerFactorOutcomeOfSubintentHash]) {
        self.perFactorOutcome = perFactorOutcome
    }
}


extension SignResponseOfSubintentHash: Sendable {} 
extension SignResponseOfSubintentHash: Equatable, Hashable {
    public static func ==(lhs: SignResponseOfSubintentHash, rhs: SignResponseOfSubintentHash) -> Bool {
        if lhs.perFactorOutcome != rhs.perFactorOutcome {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(perFactorOutcome)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignResponseOfSubintentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignResponseOfSubintentHash {
        return
            try SignResponseOfSubintentHash(
                perFactorOutcome: FfiConverterSequenceTypePerFactorOutcomeOfSubintentHash.read(from: &buf)
        )
    }

    public static func write(_ value: SignResponseOfSubintentHash, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePerFactorOutcomeOfSubintentHash.write(value.perFactorOutcome, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignResponseOfSubintentHash_lift(_ buf: RustBuffer) throws -> SignResponseOfSubintentHash {
    return try FfiConverterTypeSignResponseOfSubintentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignResponseOfSubintentHash_lower(_ value: SignResponseOfSubintentHash) -> RustBuffer {
    return FfiConverterTypeSignResponseOfSubintentHash.lower(value)
}


public struct SignResponseOfTransactionIntentHash {
    public var perFactorOutcome: [PerFactorOutcomeOfTransactionIntentHash]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(perFactorOutcome: [PerFactorOutcomeOfTransactionIntentHash]) {
        self.perFactorOutcome = perFactorOutcome
    }
}


extension SignResponseOfTransactionIntentHash: Sendable {} 
extension SignResponseOfTransactionIntentHash: Equatable, Hashable {
    public static func ==(lhs: SignResponseOfTransactionIntentHash, rhs: SignResponseOfTransactionIntentHash) -> Bool {
        if lhs.perFactorOutcome != rhs.perFactorOutcome {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(perFactorOutcome)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignResponseOfTransactionIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignResponseOfTransactionIntentHash {
        return
            try SignResponseOfTransactionIntentHash(
                perFactorOutcome: FfiConverterSequenceTypePerFactorOutcomeOfTransactionIntentHash.read(from: &buf)
        )
    }

    public static func write(_ value: SignResponseOfTransactionIntentHash, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePerFactorOutcomeOfTransactionIntentHash.write(value.perFactorOutcome, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignResponseOfTransactionIntentHash_lift(_ buf: RustBuffer) throws -> SignResponseOfTransactionIntentHash {
    return try FfiConverterTypeSignResponseOfTransactionIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignResponseOfTransactionIntentHash_lower(_ value: SignResponseOfTransactionIntentHash) -> RustBuffer {
    return FfiConverterTypeSignResponseOfTransactionIntentHash.lower(value)
}


public struct SignaturesPerFactorSourceOfAuthIntentHash {
    public var factorSourceId: FactorSourceIdFromHash
    public var hdSignatures: [HdSignatureOfAuthIntentHash]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceId: FactorSourceIdFromHash, hdSignatures: [HdSignatureOfAuthIntentHash]) {
        self.factorSourceId = factorSourceId
        self.hdSignatures = hdSignatures
    }
}


extension SignaturesPerFactorSourceOfAuthIntentHash: Sendable {} 
extension SignaturesPerFactorSourceOfAuthIntentHash: Equatable, Hashable {
    public static func ==(lhs: SignaturesPerFactorSourceOfAuthIntentHash, rhs: SignaturesPerFactorSourceOfAuthIntentHash) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.hdSignatures != rhs.hdSignatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(hdSignatures)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignaturesPerFactorSourceOfAuthIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignaturesPerFactorSourceOfAuthIntentHash {
        return
            try SignaturesPerFactorSourceOfAuthIntentHash(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                hdSignatures: FfiConverterSequenceTypeHDSignatureOfAuthIntentHash.read(from: &buf)
        )
    }

    public static func write(_ value: SignaturesPerFactorSourceOfAuthIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterSequenceTypeHDSignatureOfAuthIntentHash.write(value.hdSignatures, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignaturesPerFactorSourceOfAuthIntentHash_lift(_ buf: RustBuffer) throws -> SignaturesPerFactorSourceOfAuthIntentHash {
    return try FfiConverterTypeSignaturesPerFactorSourceOfAuthIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignaturesPerFactorSourceOfAuthIntentHash_lower(_ value: SignaturesPerFactorSourceOfAuthIntentHash) -> RustBuffer {
    return FfiConverterTypeSignaturesPerFactorSourceOfAuthIntentHash.lower(value)
}


public struct SignaturesPerFactorSourceOfSubintentHash {
    public var factorSourceId: FactorSourceIdFromHash
    public var hdSignatures: [HdSignatureOfSubintentHash]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceId: FactorSourceIdFromHash, hdSignatures: [HdSignatureOfSubintentHash]) {
        self.factorSourceId = factorSourceId
        self.hdSignatures = hdSignatures
    }
}


extension SignaturesPerFactorSourceOfSubintentHash: Sendable {} 
extension SignaturesPerFactorSourceOfSubintentHash: Equatable, Hashable {
    public static func ==(lhs: SignaturesPerFactorSourceOfSubintentHash, rhs: SignaturesPerFactorSourceOfSubintentHash) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.hdSignatures != rhs.hdSignatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(hdSignatures)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignaturesPerFactorSourceOfSubintentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignaturesPerFactorSourceOfSubintentHash {
        return
            try SignaturesPerFactorSourceOfSubintentHash(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                hdSignatures: FfiConverterSequenceTypeHDSignatureOfSubintentHash.read(from: &buf)
        )
    }

    public static func write(_ value: SignaturesPerFactorSourceOfSubintentHash, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterSequenceTypeHDSignatureOfSubintentHash.write(value.hdSignatures, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignaturesPerFactorSourceOfSubintentHash_lift(_ buf: RustBuffer) throws -> SignaturesPerFactorSourceOfSubintentHash {
    return try FfiConverterTypeSignaturesPerFactorSourceOfSubintentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignaturesPerFactorSourceOfSubintentHash_lower(_ value: SignaturesPerFactorSourceOfSubintentHash) -> RustBuffer {
    return FfiConverterTypeSignaturesPerFactorSourceOfSubintentHash.lower(value)
}


public struct SignaturesPerFactorSourceOfTransactionIntentHash {
    public var factorSourceId: FactorSourceIdFromHash
    public var hdSignatures: [HdSignatureOfTransactionIntentHash]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceId: FactorSourceIdFromHash, hdSignatures: [HdSignatureOfTransactionIntentHash]) {
        self.factorSourceId = factorSourceId
        self.hdSignatures = hdSignatures
    }
}


extension SignaturesPerFactorSourceOfTransactionIntentHash: Sendable {} 
extension SignaturesPerFactorSourceOfTransactionIntentHash: Equatable, Hashable {
    public static func ==(lhs: SignaturesPerFactorSourceOfTransactionIntentHash, rhs: SignaturesPerFactorSourceOfTransactionIntentHash) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.hdSignatures != rhs.hdSignatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(hdSignatures)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignaturesPerFactorSourceOfTransactionIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignaturesPerFactorSourceOfTransactionIntentHash {
        return
            try SignaturesPerFactorSourceOfTransactionIntentHash(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                hdSignatures: FfiConverterSequenceTypeHDSignatureOfTransactionIntentHash.read(from: &buf)
        )
    }

    public static func write(_ value: SignaturesPerFactorSourceOfTransactionIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterSequenceTypeHDSignatureOfTransactionIntentHash.write(value.hdSignatures, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignaturesPerFactorSourceOfTransactionIntentHash_lift(_ buf: RustBuffer) throws -> SignaturesPerFactorSourceOfTransactionIntentHash {
    return try FfiConverterTypeSignaturesPerFactorSourceOfTransactionIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignaturesPerFactorSourceOfTransactionIntentHash_lower(_ value: SignaturesPerFactorSourceOfTransactionIntentHash) -> RustBuffer {
    return FfiConverterTypeSignaturesPerFactorSourceOfTransactionIntentHash.lower(value)
}


public struct SignedAuthIntent {
    public var intent: AuthIntent
    public var intentSignaturesPerOwner: [IntentSignatureOfOwner]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(intent: AuthIntent, intentSignaturesPerOwner: [IntentSignatureOfOwner]) {
        self.intent = intent
        self.intentSignaturesPerOwner = intentSignaturesPerOwner
    }
}


extension SignedAuthIntent: Sendable {} 
extension SignedAuthIntent: Equatable, Hashable {
    public static func ==(lhs: SignedAuthIntent, rhs: SignedAuthIntent) -> Bool {
        if lhs.intent != rhs.intent {
            return false
        }
        if lhs.intentSignaturesPerOwner != rhs.intentSignaturesPerOwner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(intent)
        hasher.combine(intentSignaturesPerOwner)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignedAuthIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedAuthIntent {
        return
            try SignedAuthIntent(
                intent: FfiConverterTypeAuthIntent.read(from: &buf), 
                intentSignaturesPerOwner: FfiConverterSequenceTypeIntentSignatureOfOwner.read(from: &buf)
        )
    }

    public static func write(_ value: SignedAuthIntent, into buf: inout [UInt8]) {
        FfiConverterTypeAuthIntent.write(value.intent, into: &buf)
        FfiConverterSequenceTypeIntentSignatureOfOwner.write(value.intentSignaturesPerOwner, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedAuthIntent_lift(_ buf: RustBuffer) throws -> SignedAuthIntent {
    return try FfiConverterTypeSignedAuthIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedAuthIntent_lower(_ value: SignedAuthIntent) -> RustBuffer {
    return FfiConverterTypeSignedAuthIntent.lower(value)
}


public struct SignedIntent {
    public var intent: TransactionIntent
    public var intentSignatures: IntentSignatures

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(intent: TransactionIntent, intentSignatures: IntentSignatures) {
        self.intent = intent
        self.intentSignatures = intentSignatures
    }
}


extension SignedIntent: Sendable {} 
extension SignedIntent: Equatable, Hashable {
    public static func ==(lhs: SignedIntent, rhs: SignedIntent) -> Bool {
        if lhs.intent != rhs.intent {
            return false
        }
        if lhs.intentSignatures != rhs.intentSignatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(intent)
        hasher.combine(intentSignatures)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignedIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedIntent {
        return
            try SignedIntent(
                intent: FfiConverterTypeTransactionIntent.read(from: &buf), 
                intentSignatures: FfiConverterTypeIntentSignatures.read(from: &buf)
        )
    }

    public static func write(_ value: SignedIntent, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionIntent.write(value.intent, into: &buf)
        FfiConverterTypeIntentSignatures.write(value.intentSignatures, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedIntent_lift(_ buf: RustBuffer) throws -> SignedIntent {
    return try FfiConverterTypeSignedIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedIntent_lower(_ value: SignedIntent) -> RustBuffer {
    return FfiConverterTypeSignedIntent.lower(value)
}


public struct SignedSubintent {
    public var subintent: Subintent
    public var subintentSignatures: IntentSignatures

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(subintent: Subintent, subintentSignatures: IntentSignatures) {
        self.subintent = subintent
        self.subintentSignatures = subintentSignatures
    }
}


extension SignedSubintent: Sendable {} 
extension SignedSubintent: Equatable, Hashable {
    public static func ==(lhs: SignedSubintent, rhs: SignedSubintent) -> Bool {
        if lhs.subintent != rhs.subintent {
            return false
        }
        if lhs.subintentSignatures != rhs.subintentSignatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(subintent)
        hasher.combine(subintentSignatures)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignedSubintent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedSubintent {
        return
            try SignedSubintent(
                subintent: FfiConverterTypeSubintent.read(from: &buf), 
                subintentSignatures: FfiConverterTypeIntentSignatures.read(from: &buf)
        )
    }

    public static func write(_ value: SignedSubintent, into buf: inout [UInt8]) {
        FfiConverterTypeSubintent.write(value.subintent, into: &buf)
        FfiConverterTypeIntentSignatures.write(value.subintentSignatures, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedSubintent_lift(_ buf: RustBuffer) throws -> SignedSubintent {
    return try FfiConverterTypeSignedSubintent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedSubintent_lower(_ value: SignedSubintent) -> RustBuffer {
    return FfiConverterTypeSignedSubintent.lower(value)
}


/**
 * A Signed Intent Hash is a bech32 encoded string starting with `"signedintent_"
 */
public struct SignedTransactionIntentHash {
    /**
     * Which network this transaction hash is used on
     */
    public var networkId: NetworkId
    /**
     * the hash of the intent
     */
    public var hash: Hash
    /**
     * Bech32 encoded TX id
     */
    public var bech32EncodedTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Which network this transaction hash is used on
         */networkId: NetworkId, 
        /**
         * the hash of the intent
         */hash: Hash, 
        /**
         * Bech32 encoded TX id
         */bech32EncodedTxId: String) {
        self.networkId = networkId
        self.hash = hash
        self.bech32EncodedTxId = bech32EncodedTxId
    }
}


extension SignedTransactionIntentHash: Sendable {} 
extension SignedTransactionIntentHash: Equatable, Hashable {
    public static func ==(lhs: SignedTransactionIntentHash, rhs: SignedTransactionIntentHash) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(hash)
        hasher.combine(bech32EncodedTxId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignedTransactionIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedTransactionIntentHash {
        return
            try SignedTransactionIntentHash(
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                hash: FfiConverterTypeHash.read(from: &buf), 
                bech32EncodedTxId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SignedTransactionIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeHash.write(value.hash, into: &buf)
        FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedTransactionIntentHash_lift(_ buf: RustBuffer) throws -> SignedTransactionIntentHash {
    return try FfiConverterTypeSignedTransactionIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignedTransactionIntentHash_lower(_ value: SignedTransactionIntentHash) -> RustBuffer {
    return FfiConverterTypeSignedTransactionIntentHash.lower(value)
}


/**
 * Represents the bounds for a simple non_fungible resource, which can be either exact or not exact.
 */
public struct SimpleNonFungibleResourceBounds {
    public var certainIds: [NonFungibleLocalId]
    public var additionalAmount: SimpleCountedResourceBounds?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(certainIds: [NonFungibleLocalId], additionalAmount: SimpleCountedResourceBounds?) {
        self.certainIds = certainIds
        self.additionalAmount = additionalAmount
    }
}


extension SimpleNonFungibleResourceBounds: Sendable {} 
extension SimpleNonFungibleResourceBounds: Equatable, Hashable {
    public static func ==(lhs: SimpleNonFungibleResourceBounds, rhs: SimpleNonFungibleResourceBounds) -> Bool {
        if lhs.certainIds != rhs.certainIds {
            return false
        }
        if lhs.additionalAmount != rhs.additionalAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(certainIds)
        hasher.combine(additionalAmount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSimpleNonFungibleResourceBounds: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleNonFungibleResourceBounds {
        return
            try SimpleNonFungibleResourceBounds(
                certainIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf), 
                additionalAmount: FfiConverterOptionTypeSimpleCountedResourceBounds.read(from: &buf)
        )
    }

    public static func write(_ value: SimpleNonFungibleResourceBounds, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.certainIds, into: &buf)
        FfiConverterOptionTypeSimpleCountedResourceBounds.write(value.additionalAmount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSimpleNonFungibleResourceBounds_lift(_ buf: RustBuffer) throws -> SimpleNonFungibleResourceBounds {
    return try FfiConverterTypeSimpleNonFungibleResourceBounds.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSimpleNonFungibleResourceBounds_lower(_ value: SimpleNonFungibleResourceBounds) -> RustBuffer {
    return FfiConverterTypeSimpleNonFungibleResourceBounds.lower(value)
}


public struct StakeClaim {
    public var validatorAddress: ValidatorAddress
    public var resourceAddress: NonFungibleResourceAddress
    public var ids: [NonFungibleLocalId]
    /**
     * The summed claim amount across ids
     */
    public var amount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: ValidatorAddress, resourceAddress: NonFungibleResourceAddress, ids: [NonFungibleLocalId], 
        /**
         * The summed claim amount across ids
         */amount: Decimal192) {
        self.validatorAddress = validatorAddress
        self.resourceAddress = resourceAddress
        self.ids = ids
        self.amount = amount
    }
}


extension StakeClaim: Sendable {} 
extension StakeClaim: Equatable, Hashable {
    public static func ==(lhs: StakeClaim, rhs: StakeClaim) -> Bool {
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validatorAddress)
        hasher.combine(resourceAddress)
        hasher.combine(ids)
        hasher.combine(amount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStakeClaim: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StakeClaim {
        return
            try StakeClaim(
                validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf), 
                resourceAddress: FfiConverterTypeNonFungibleResourceAddress.read(from: &buf), 
                ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf), 
                amount: FfiConverterTypeDecimal192.read(from: &buf)
        )
    }

    public static func write(_ value: StakeClaim, into buf: inout [UInt8]) {
        FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeNonFungibleResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.ids, into: &buf)
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStakeClaim_lift(_ buf: RustBuffer) throws -> StakeClaim {
    return try FfiConverterTypeStakeClaim.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStakeClaim_lower(_ value: StakeClaim) -> RustBuffer {
    return FfiConverterTypeStakeClaim.lower(value)
}


public struct Subintent {
    public var header: IntentHeaderV2
    public var manifest: SubintentManifest
    public var message: MessageV2

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(header: IntentHeaderV2, manifest: SubintentManifest, message: MessageV2) {
        self.header = header
        self.manifest = manifest
        self.message = message
    }
}


extension Subintent: Sendable {} 
extension Subintent: Equatable, Hashable {
    public static func ==(lhs: Subintent, rhs: Subintent) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.manifest != rhs.manifest {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(manifest)
        hasher.combine(message)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubintent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Subintent {
        return
            try Subintent(
                header: FfiConverterTypeIntentHeaderV2.read(from: &buf), 
                manifest: FfiConverterTypeSubintentManifest.read(from: &buf), 
                message: FfiConverterTypeMessageV2.read(from: &buf)
        )
    }

    public static func write(_ value: Subintent, into buf: inout [UInt8]) {
        FfiConverterTypeIntentHeaderV2.write(value.header, into: &buf)
        FfiConverterTypeSubintentManifest.write(value.manifest, into: &buf)
        FfiConverterTypeMessageV2.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubintent_lift(_ buf: RustBuffer) throws -> Subintent {
    return try FfiConverterTypeSubintent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubintent_lower(_ value: Subintent) -> RustBuffer {
    return FfiConverterTypeSubintent.lower(value)
}


/**
 * `IntentHash` used to identify transactions.
 * Representation is bech32 encoded string starting with `txid_` e.g.:
 * `"txid_rdx19rpveua6xuhvz0axu0mwpqk8fywr83atv8mkrugchvw6uuslgppqh9cnj4"`
 */
public struct SubintentHash {
    /**
     * Which network this transaction hash is used on
     */
    public var networkId: NetworkId
    /**
     * the hash of the intent
     */
    public var hash: Hash
    /**
     * Bech32 encoded TX id
     */
    public var bech32EncodedTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Which network this transaction hash is used on
         */networkId: NetworkId, 
        /**
         * the hash of the intent
         */hash: Hash, 
        /**
         * Bech32 encoded TX id
         */bech32EncodedTxId: String) {
        self.networkId = networkId
        self.hash = hash
        self.bech32EncodedTxId = bech32EncodedTxId
    }
}


extension SubintentHash: Sendable {} 
extension SubintentHash: Equatable, Hashable {
    public static func ==(lhs: SubintentHash, rhs: SubintentHash) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(hash)
        hasher.combine(bech32EncodedTxId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubintentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubintentHash {
        return
            try SubintentHash(
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                hash: FfiConverterTypeHash.read(from: &buf), 
                bech32EncodedTxId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SubintentHash, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeHash.write(value.hash, into: &buf)
        FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubintentHash_lift(_ buf: RustBuffer) throws -> SubintentHash {
    return try FfiConverterTypeSubintentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubintentHash_lower(_ value: SubintentHash) -> RustBuffer {
    return FfiConverterTypeSubintentHash.lower(value)
}


public struct SubintentManifest {
    public var rawManifest: BagOfBytes
    public var networkId: NetworkId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(rawManifest: BagOfBytes, networkId: NetworkId) {
        self.rawManifest = rawManifest
        self.networkId = networkId
    }
}


extension SubintentManifest: Sendable {} 
extension SubintentManifest: Equatable, Hashable {
    public static func ==(lhs: SubintentManifest, rhs: SubintentManifest) -> Bool {
        if lhs.rawManifest != rhs.rawManifest {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rawManifest)
        hasher.combine(networkId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubintentManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubintentManifest {
        return
            try SubintentManifest(
                rawManifest: FfiConverterTypeBagOfBytes.read(from: &buf), 
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
        )
    }

    public static func write(_ value: SubintentManifest, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.rawManifest, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubintentManifest_lift(_ buf: RustBuffer) throws -> SubintentManifest {
    return try FfiConverterTypeSubintentManifest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubintentManifest_lower(_ value: SubintentManifest) -> RustBuffer {
    return FfiConverterTypeSubintentManifest.lower(value)
}


/**
 * Controls the ability of third-parties to deposit into a certain account, this is
 * useful for users who wish to not be able to receive airdrops.
 */
public struct ThirdPartyDeposits {
    /**
     * Controls the ability of third-parties to deposit into this account
     */
    public var depositRule: DepositRule
    /**
     * Denies or allows third-party deposits of specific assets by ignoring the `depositMode`
     * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
     * thus the value is unknown.
     */
    public var assetsExceptionList: [AssetException]?
    /**
     * Allows certain third-party depositors to deposit assets freely.
     * Note: There is no `deny` counterpart for this.
     * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
     * thus the value is unknown.
     */
    public var depositorsAllowList: [ResourceOrNonFungible]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Controls the ability of third-parties to deposit into this account
         */depositRule: DepositRule, 
        /**
         * Denies or allows third-party deposits of specific assets by ignoring the `depositMode`
         * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
         * thus the value is unknown.
         */assetsExceptionList: [AssetException]?, 
        /**
         * Allows certain third-party depositors to deposit assets freely.
         * Note: There is no `deny` counterpart for this.
         * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
         * thus the value is unknown.
         */depositorsAllowList: [ResourceOrNonFungible]?) {
        self.depositRule = depositRule
        self.assetsExceptionList = assetsExceptionList
        self.depositorsAllowList = depositorsAllowList
    }
}


extension ThirdPartyDeposits: Sendable {} 
extension ThirdPartyDeposits: Equatable, Hashable {
    public static func ==(lhs: ThirdPartyDeposits, rhs: ThirdPartyDeposits) -> Bool {
        if lhs.depositRule != rhs.depositRule {
            return false
        }
        if lhs.assetsExceptionList != rhs.assetsExceptionList {
            return false
        }
        if lhs.depositorsAllowList != rhs.depositorsAllowList {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(depositRule)
        hasher.combine(assetsExceptionList)
        hasher.combine(depositorsAllowList)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeThirdPartyDeposits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThirdPartyDeposits {
        return
            try ThirdPartyDeposits(
                depositRule: FfiConverterTypeDepositRule.read(from: &buf), 
                assetsExceptionList: FfiConverterOptionSequenceTypeAssetException.read(from: &buf), 
                depositorsAllowList: FfiConverterOptionSequenceTypeResourceOrNonFungible.read(from: &buf)
        )
    }

    public static func write(_ value: ThirdPartyDeposits, into buf: inout [UInt8]) {
        FfiConverterTypeDepositRule.write(value.depositRule, into: &buf)
        FfiConverterOptionSequenceTypeAssetException.write(value.assetsExceptionList, into: &buf)
        FfiConverterOptionSequenceTypeResourceOrNonFungible.write(value.depositorsAllowList, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThirdPartyDeposits_lift(_ buf: RustBuffer) throws -> ThirdPartyDeposits {
    return try FfiConverterTypeThirdPartyDeposits.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThirdPartyDeposits_lower(_ value: ThirdPartyDeposits) -> RustBuffer {
    return FfiConverterTypeThirdPartyDeposits.lower(value)
}


/**
 * Time period unit expressed in days, weeks, or years.
 *
 * Used to represent in the hosts UI the time period.
 */
public struct TimePeriod {
    /**
     * The value of the time period.
     */
    public var value: UInt16
    /**
     * The unit of the time period.
     */
    public var unit: TimePeriodUnit

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The value of the time period.
         */value: UInt16, 
        /**
         * The unit of the time period.
         */unit: TimePeriodUnit) {
        self.value = value
        self.unit = unit
    }
}


extension TimePeriod: Sendable {} 
extension TimePeriod: Equatable, Hashable {
    public static func ==(lhs: TimePeriod, rhs: TimePeriod) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.unit != rhs.unit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(unit)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimePeriod: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimePeriod {
        return
            try TimePeriod(
                value: FfiConverterUInt16.read(from: &buf), 
                unit: FfiConverterTypeTimePeriodUnit.read(from: &buf)
        )
    }

    public static func write(_ value: TimePeriod, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.value, into: &buf)
        FfiConverterTypeTimePeriodUnit.write(value.unit, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimePeriod_lift(_ buf: RustBuffer) throws -> TimePeriod {
    return try FfiConverterTypeTimePeriod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimePeriod_lower(_ value: TimePeriod) -> RustBuffer {
    return FfiConverterTypeTimePeriod.lower(value)
}


public struct TokenDefinitionMetadata {
    public var name: String
    public var description: String
    public var symbol: String
    public var iconUrl: String
    public var tags: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, description: String, symbol: String, iconUrl: String, tags: [String]) {
        self.name = name
        self.description = description
        self.symbol = symbol
        self.iconUrl = iconUrl
        self.tags = tags
    }
}


extension TokenDefinitionMetadata: Sendable {} 
extension TokenDefinitionMetadata: Equatable, Hashable {
    public static func ==(lhs: TokenDefinitionMetadata, rhs: TokenDefinitionMetadata) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.iconUrl != rhs.iconUrl {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(symbol)
        hasher.combine(iconUrl)
        hasher.combine(tags)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenDefinitionMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenDefinitionMetadata {
        return
            try TokenDefinitionMetadata(
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                symbol: FfiConverterString.read(from: &buf), 
                iconUrl: FfiConverterString.read(from: &buf), 
                tags: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: TokenDefinitionMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.symbol, into: &buf)
        FfiConverterString.write(value.iconUrl, into: &buf)
        FfiConverterSequenceString.write(value.tags, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenDefinitionMetadata_lift(_ buf: RustBuffer) throws -> TokenDefinitionMetadata {
    return try FfiConverterTypeTokenDefinitionMetadata.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenDefinitionMetadata_lower(_ value: TokenDefinitionMetadata) -> RustBuffer {
    return FfiConverterTypeTokenDefinitionMetadata.lower(value)
}


/**
 * A contribution to a pool observed in the transaction
 */
public struct TrackedPoolContribution {
    public var poolAddress: PoolAddress
    public var contributedResources: [ResourceAddress: Decimal192]
    public var poolUnitsResourceAddress: ResourceAddress
    public var poolUnitsAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolAddress: PoolAddress, contributedResources: [ResourceAddress: Decimal192], poolUnitsResourceAddress: ResourceAddress, poolUnitsAmount: Decimal192) {
        self.poolAddress = poolAddress
        self.contributedResources = contributedResources
        self.poolUnitsResourceAddress = poolUnitsResourceAddress
        self.poolUnitsAmount = poolUnitsAmount
    }
}


extension TrackedPoolContribution: Sendable {} 
extension TrackedPoolContribution: Equatable, Hashable {
    public static func ==(lhs: TrackedPoolContribution, rhs: TrackedPoolContribution) -> Bool {
        if lhs.poolAddress != rhs.poolAddress {
            return false
        }
        if lhs.contributedResources != rhs.contributedResources {
            return false
        }
        if lhs.poolUnitsResourceAddress != rhs.poolUnitsResourceAddress {
            return false
        }
        if lhs.poolUnitsAmount != rhs.poolUnitsAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(poolAddress)
        hasher.combine(contributedResources)
        hasher.combine(poolUnitsResourceAddress)
        hasher.combine(poolUnitsAmount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTrackedPoolContribution: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedPoolContribution {
        return
            try TrackedPoolContribution(
                poolAddress: FfiConverterTypePoolAddress.read(from: &buf), 
                contributedResources: FfiConverterDictionaryTypeResourceAddressTypeDecimal192.read(from: &buf), 
                poolUnitsResourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), 
                poolUnitsAmount: FfiConverterTypeDecimal192.read(from: &buf)
        )
    }

    public static func write(_ value: TrackedPoolContribution, into buf: inout [UInt8]) {
        FfiConverterTypePoolAddress.write(value.poolAddress, into: &buf)
        FfiConverterDictionaryTypeResourceAddressTypeDecimal192.write(value.contributedResources, into: &buf)
        FfiConverterTypeResourceAddress.write(value.poolUnitsResourceAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.poolUnitsAmount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrackedPoolContribution_lift(_ buf: RustBuffer) throws -> TrackedPoolContribution {
    return try FfiConverterTypeTrackedPoolContribution.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrackedPoolContribution_lower(_ value: TrackedPoolContribution) -> RustBuffer {
    return FfiConverterTypeTrackedPoolContribution.lower(value)
}


/**
 * A pool redemptions observed in the transaction
 */
public struct TrackedPoolRedemption {
    public var poolAddress: PoolAddress
    public var poolUnitsResourceAddress: ResourceAddress
    public var poolUnitsAmount: Decimal192
    public var redeemedResources: [ResourceAddress: Decimal192]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolAddress: PoolAddress, poolUnitsResourceAddress: ResourceAddress, poolUnitsAmount: Decimal192, redeemedResources: [ResourceAddress: Decimal192]) {
        self.poolAddress = poolAddress
        self.poolUnitsResourceAddress = poolUnitsResourceAddress
        self.poolUnitsAmount = poolUnitsAmount
        self.redeemedResources = redeemedResources
    }
}


extension TrackedPoolRedemption: Sendable {} 
extension TrackedPoolRedemption: Equatable, Hashable {
    public static func ==(lhs: TrackedPoolRedemption, rhs: TrackedPoolRedemption) -> Bool {
        if lhs.poolAddress != rhs.poolAddress {
            return false
        }
        if lhs.poolUnitsResourceAddress != rhs.poolUnitsResourceAddress {
            return false
        }
        if lhs.poolUnitsAmount != rhs.poolUnitsAmount {
            return false
        }
        if lhs.redeemedResources != rhs.redeemedResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(poolAddress)
        hasher.combine(poolUnitsResourceAddress)
        hasher.combine(poolUnitsAmount)
        hasher.combine(redeemedResources)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTrackedPoolRedemption: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedPoolRedemption {
        return
            try TrackedPoolRedemption(
                poolAddress: FfiConverterTypePoolAddress.read(from: &buf), 
                poolUnitsResourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), 
                poolUnitsAmount: FfiConverterTypeDecimal192.read(from: &buf), 
                redeemedResources: FfiConverterDictionaryTypeResourceAddressTypeDecimal192.read(from: &buf)
        )
    }

    public static func write(_ value: TrackedPoolRedemption, into buf: inout [UInt8]) {
        FfiConverterTypePoolAddress.write(value.poolAddress, into: &buf)
        FfiConverterTypeResourceAddress.write(value.poolUnitsResourceAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.poolUnitsAmount, into: &buf)
        FfiConverterDictionaryTypeResourceAddressTypeDecimal192.write(value.redeemedResources, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrackedPoolRedemption_lift(_ buf: RustBuffer) throws -> TrackedPoolRedemption {
    return try FfiConverterTypeTrackedPoolRedemption.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrackedPoolRedemption_lower(_ value: TrackedPoolRedemption) -> RustBuffer {
    return FfiConverterTypeTrackedPoolRedemption.lower(value)
}


/**
 * A validator claim observed in the transaction
 */
public struct TrackedValidatorClaim {
    public var validatorAddress: ValidatorAddress
    public var claimNftAddress: ResourceAddress
    public var claimNftIds: [NonFungibleLocalId]
    public var xrdAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: ValidatorAddress, claimNftAddress: ResourceAddress, claimNftIds: [NonFungibleLocalId], xrdAmount: Decimal192) {
        self.validatorAddress = validatorAddress
        self.claimNftAddress = claimNftAddress
        self.claimNftIds = claimNftIds
        self.xrdAmount = xrdAmount
    }
}


extension TrackedValidatorClaim: Sendable {} 
extension TrackedValidatorClaim: Equatable, Hashable {
    public static func ==(lhs: TrackedValidatorClaim, rhs: TrackedValidatorClaim) -> Bool {
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.claimNftAddress != rhs.claimNftAddress {
            return false
        }
        if lhs.claimNftIds != rhs.claimNftIds {
            return false
        }
        if lhs.xrdAmount != rhs.xrdAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validatorAddress)
        hasher.combine(claimNftAddress)
        hasher.combine(claimNftIds)
        hasher.combine(xrdAmount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTrackedValidatorClaim: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorClaim {
        return
            try TrackedValidatorClaim(
                validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf), 
                claimNftAddress: FfiConverterTypeResourceAddress.read(from: &buf), 
                claimNftIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf), 
                xrdAmount: FfiConverterTypeDecimal192.read(from: &buf)
        )
    }

    public static func write(_ value: TrackedValidatorClaim, into buf: inout [UInt8]) {
        FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeResourceAddress.write(value.claimNftAddress, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.claimNftIds, into: &buf)
        FfiConverterTypeDecimal192.write(value.xrdAmount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrackedValidatorClaim_lift(_ buf: RustBuffer) throws -> TrackedValidatorClaim {
    return try FfiConverterTypeTrackedValidatorClaim.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrackedValidatorClaim_lower(_ value: TrackedValidatorClaim) -> RustBuffer {
    return FfiConverterTypeTrackedValidatorClaim.lower(value)
}


/**
 * A validator stake observed in the transaction
 */
public struct TrackedValidatorStake {
    public var validatorAddress: ValidatorAddress
    public var xrdAmount: Decimal192
    public var liquidStakeUnitAddress: ResourceAddress
    public var liquidStakeUnitAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: ValidatorAddress, xrdAmount: Decimal192, liquidStakeUnitAddress: ResourceAddress, liquidStakeUnitAmount: Decimal192) {
        self.validatorAddress = validatorAddress
        self.xrdAmount = xrdAmount
        self.liquidStakeUnitAddress = liquidStakeUnitAddress
        self.liquidStakeUnitAmount = liquidStakeUnitAmount
    }
}


extension TrackedValidatorStake: Sendable {} 
extension TrackedValidatorStake: Equatable, Hashable {
    public static func ==(lhs: TrackedValidatorStake, rhs: TrackedValidatorStake) -> Bool {
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.xrdAmount != rhs.xrdAmount {
            return false
        }
        if lhs.liquidStakeUnitAddress != rhs.liquidStakeUnitAddress {
            return false
        }
        if lhs.liquidStakeUnitAmount != rhs.liquidStakeUnitAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validatorAddress)
        hasher.combine(xrdAmount)
        hasher.combine(liquidStakeUnitAddress)
        hasher.combine(liquidStakeUnitAmount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTrackedValidatorStake: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorStake {
        return
            try TrackedValidatorStake(
                validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf), 
                xrdAmount: FfiConverterTypeDecimal192.read(from: &buf), 
                liquidStakeUnitAddress: FfiConverterTypeResourceAddress.read(from: &buf), 
                liquidStakeUnitAmount: FfiConverterTypeDecimal192.read(from: &buf)
        )
    }

    public static func write(_ value: TrackedValidatorStake, into buf: inout [UInt8]) {
        FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.xrdAmount, into: &buf)
        FfiConverterTypeResourceAddress.write(value.liquidStakeUnitAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.liquidStakeUnitAmount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrackedValidatorStake_lift(_ buf: RustBuffer) throws -> TrackedValidatorStake {
    return try FfiConverterTypeTrackedValidatorStake.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTrackedValidatorStake_lower(_ value: TrackedValidatorStake) -> RustBuffer {
    return FfiConverterTypeTrackedValidatorStake.lower(value)
}


public struct TransactionGuarantee {
    /**
     * The guaranteed amount to be obtained on this transaction. For manifest & display purposes.
     */
    public var amount: Decimal192
    /**
     * The percentage the user has selected, which generated the `amount`. For display purposes only.
     */
    public var percentage: Decimal192
    public var instructionIndex: UInt64
    public var resourceAddress: ResourceAddress
    public var resourceDivisibility: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The guaranteed amount to be obtained on this transaction. For manifest & display purposes.
         */amount: Decimal192, 
        /**
         * The percentage the user has selected, which generated the `amount`. For display purposes only.
         */percentage: Decimal192, instructionIndex: UInt64, resourceAddress: ResourceAddress, resourceDivisibility: UInt8?) {
        self.amount = amount
        self.percentage = percentage
        self.instructionIndex = instructionIndex
        self.resourceAddress = resourceAddress
        self.resourceDivisibility = resourceDivisibility
    }
}


extension TransactionGuarantee: Sendable {} 
extension TransactionGuarantee: Equatable, Hashable {
    public static func ==(lhs: TransactionGuarantee, rhs: TransactionGuarantee) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.percentage != rhs.percentage {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.resourceDivisibility != rhs.resourceDivisibility {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(percentage)
        hasher.combine(instructionIndex)
        hasher.combine(resourceAddress)
        hasher.combine(resourceDivisibility)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionGuarantee: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionGuarantee {
        return
            try TransactionGuarantee(
                amount: FfiConverterTypeDecimal192.read(from: &buf), 
                percentage: FfiConverterTypeDecimal192.read(from: &buf), 
                instructionIndex: FfiConverterUInt64.read(from: &buf), 
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), 
                resourceDivisibility: FfiConverterOptionUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionGuarantee, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterTypeDecimal192.write(value.percentage, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterOptionUInt8.write(value.resourceDivisibility, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionGuarantee_lift(_ buf: RustBuffer) throws -> TransactionGuarantee {
    return try FfiConverterTypeTransactionGuarantee.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionGuarantee_lower(_ value: TransactionGuarantee) -> RustBuffer {
    return FfiConverterTypeTransactionGuarantee.lower(value)
}


public struct TransactionHeader {
    public var networkId: NetworkId
    public var startEpochInclusive: Epoch
    public var endEpochExclusive: Epoch
    public var nonce: Nonce
    public var notaryPublicKey: PublicKey
    public var notaryIsSignatory: Bool
    public var tipPercentage: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, startEpochInclusive: Epoch, endEpochExclusive: Epoch, nonce: Nonce, notaryPublicKey: PublicKey, notaryIsSignatory: Bool, tipPercentage: UInt16) {
        self.networkId = networkId
        self.startEpochInclusive = startEpochInclusive
        self.endEpochExclusive = endEpochExclusive
        self.nonce = nonce
        self.notaryPublicKey = notaryPublicKey
        self.notaryIsSignatory = notaryIsSignatory
        self.tipPercentage = tipPercentage
    }
}


extension TransactionHeader: Sendable {} 
extension TransactionHeader: Equatable, Hashable {
    public static func ==(lhs: TransactionHeader, rhs: TransactionHeader) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.startEpochInclusive != rhs.startEpochInclusive {
            return false
        }
        if lhs.endEpochExclusive != rhs.endEpochExclusive {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.notaryPublicKey != rhs.notaryPublicKey {
            return false
        }
        if lhs.notaryIsSignatory != rhs.notaryIsSignatory {
            return false
        }
        if lhs.tipPercentage != rhs.tipPercentage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(startEpochInclusive)
        hasher.combine(endEpochExclusive)
        hasher.combine(nonce)
        hasher.combine(notaryPublicKey)
        hasher.combine(notaryIsSignatory)
        hasher.combine(tipPercentage)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHeader {
        return
            try TransactionHeader(
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                startEpochInclusive: FfiConverterTypeEpoch.read(from: &buf), 
                endEpochExclusive: FfiConverterTypeEpoch.read(from: &buf), 
                nonce: FfiConverterTypeNonce.read(from: &buf), 
                notaryPublicKey: FfiConverterTypePublicKey.read(from: &buf), 
                notaryIsSignatory: FfiConverterBool.read(from: &buf), 
                tipPercentage: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionHeader, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeEpoch.write(value.startEpochInclusive, into: &buf)
        FfiConverterTypeEpoch.write(value.endEpochExclusive, into: &buf)
        FfiConverterTypeNonce.write(value.nonce, into: &buf)
        FfiConverterTypePublicKey.write(value.notaryPublicKey, into: &buf)
        FfiConverterBool.write(value.notaryIsSignatory, into: &buf)
        FfiConverterUInt16.write(value.tipPercentage, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionHeader_lift(_ buf: RustBuffer) throws -> TransactionHeader {
    return try FfiConverterTypeTransactionHeader.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionHeader_lower(_ value: TransactionHeader) -> RustBuffer {
    return FfiConverterTypeTransactionHeader.lower(value)
}


public struct TransactionIntent {
    public var header: TransactionHeader
    public var manifest: TransactionManifest
    public var message: Message

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(header: TransactionHeader, manifest: TransactionManifest, message: Message) {
        self.header = header
        self.manifest = manifest
        self.message = message
    }
}


extension TransactionIntent: Sendable {} 
extension TransactionIntent: Equatable, Hashable {
    public static func ==(lhs: TransactionIntent, rhs: TransactionIntent) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.manifest != rhs.manifest {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(manifest)
        hasher.combine(message)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionIntent {
        return
            try TransactionIntent(
                header: FfiConverterTypeTransactionHeader.read(from: &buf), 
                manifest: FfiConverterTypeTransactionManifest.read(from: &buf), 
                message: FfiConverterTypeMessage.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionIntent, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionHeader.write(value.header, into: &buf)
        FfiConverterTypeTransactionManifest.write(value.manifest, into: &buf)
        FfiConverterTypeMessage.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionIntent_lift(_ buf: RustBuffer) throws -> TransactionIntent {
    return try FfiConverterTypeTransactionIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionIntent_lower(_ value: TransactionIntent) -> RustBuffer {
    return FfiConverterTypeTransactionIntent.lower(value)
}


/**
 * `IntentHash` used to identify transactions.
 * Representation is bech32 encoded string starting with `txid_` e.g.:
 * `"txid_rdx19rpveua6xuhvz0axu0mwpqk8fywr83atv8mkrugchvw6uuslgppqh9cnj4"`
 */
public struct TransactionIntentHash {
    /**
     * Which network this transaction hash is used on
     */
    public var networkId: NetworkId
    /**
     * the hash of the intent
     */
    public var hash: Hash
    /**
     * Bech32 encoded TX id
     */
    public var bech32EncodedTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Which network this transaction hash is used on
         */networkId: NetworkId, 
        /**
         * the hash of the intent
         */hash: Hash, 
        /**
         * Bech32 encoded TX id
         */bech32EncodedTxId: String) {
        self.networkId = networkId
        self.hash = hash
        self.bech32EncodedTxId = bech32EncodedTxId
    }
}


extension TransactionIntentHash: Sendable {} 
extension TransactionIntentHash: Equatable, Hashable {
    public static func ==(lhs: TransactionIntentHash, rhs: TransactionIntentHash) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(hash)
        hasher.combine(bech32EncodedTxId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionIntentHash {
        return
            try TransactionIntentHash(
                networkId: FfiConverterTypeNetworkID.read(from: &buf), 
                hash: FfiConverterTypeHash.read(from: &buf), 
                bech32EncodedTxId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeHash.write(value.hash, into: &buf)
        FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionIntentHash_lift(_ buf: RustBuffer) throws -> TransactionIntentHash {
    return try FfiConverterTypeTransactionIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionIntentHash_lower(_ value: TransactionIntentHash) -> RustBuffer {
    return FfiConverterTypeTransactionIntentHash.lower(value)
}


public struct TransactionManifest {
    public var rawManifest: BagOfBytes
    public var networkId: NetworkId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(rawManifest: BagOfBytes, networkId: NetworkId) {
        self.rawManifest = rawManifest
        self.networkId = networkId
    }
}


extension TransactionManifest: Sendable {} 
extension TransactionManifest: Equatable, Hashable {
    public static func ==(lhs: TransactionManifest, rhs: TransactionManifest) -> Bool {
        if lhs.rawManifest != rhs.rawManifest {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rawManifest)
        hasher.combine(networkId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifest {
        return
            try TransactionManifest(
                rawManifest: FfiConverterTypeBagOfBytes.read(from: &buf), 
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionManifest, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.rawManifest, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionManifest_lift(_ buf: RustBuffer) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionManifest_lower(_ value: TransactionManifest) -> RustBuffer {
    return FfiConverterTypeTransactionManifest.lower(value)
}


public struct TransactionManifestV2 {
    public var rawManifest: BagOfBytes
    public var networkId: NetworkId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(rawManifest: BagOfBytes, networkId: NetworkId) {
        self.rawManifest = rawManifest
        self.networkId = networkId
    }
}


extension TransactionManifestV2: Sendable {} 
extension TransactionManifestV2: Equatable, Hashable {
    public static func ==(lhs: TransactionManifestV2, rhs: TransactionManifestV2) -> Bool {
        if lhs.rawManifest != rhs.rawManifest {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rawManifest)
        hasher.combine(networkId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionManifestV2: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifestV2 {
        return
            try TransactionManifestV2(
                rawManifest: FfiConverterTypeBagOfBytes.read(from: &buf), 
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionManifestV2, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.rawManifest, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionManifestV2_lift(_ buf: RustBuffer) throws -> TransactionManifestV2 {
    return try FfiConverterTypeTransactionManifestV2.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionManifestV2_lower(_ value: TransactionManifestV2) -> RustBuffer {
    return FfiConverterTypeTransactionManifestV2.lower(value)
}


/**
 * User Preferences relating to submission of transactions.
 */
public struct TransactionPreferences {
    /**
     * The deposit guarantee that will automatically be added for
     * all deposits in transactions.
     */
    public var defaultDepositGuarantee: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The deposit guarantee that will automatically be added for
         * all deposits in transactions.
         */defaultDepositGuarantee: Decimal192) {
        self.defaultDepositGuarantee = defaultDepositGuarantee
    }
}


extension TransactionPreferences: Sendable {} 
extension TransactionPreferences: Equatable, Hashable {
    public static func ==(lhs: TransactionPreferences, rhs: TransactionPreferences) -> Bool {
        if lhs.defaultDepositGuarantee != rhs.defaultDepositGuarantee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(defaultDepositGuarantee)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionPreferences {
        return
            try TransactionPreferences(
                defaultDepositGuarantee: FfiConverterTypeDecimal192.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.defaultDepositGuarantee, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionPreferences_lift(_ buf: RustBuffer) throws -> TransactionPreferences {
    return try FfiConverterTypeTransactionPreferences.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionPreferences_lower(_ value: TransactionPreferences) -> RustBuffer {
    return FfiConverterTypeTransactionPreferences.lower(value)
}


/**
 * A batch of keys (derivation paths) all being factor instances of a HDFactorSource
 * with id `factor_source_id` to sign a single transaction with, which hash
 * is `intent_hash`.
 */
public struct TransactionSignRequestInputOfAuthIntent {
    /**
     * Payload to sign
     */
    public var payload: AuthIntent
    /**
     * ID of factor to use to sign
     */
    public var factorSourceId: FactorSourceIdFromHash
    /**
     * The derivation paths to use to derive the private keys to sign with. The
     * `factor_source_id` of each item must match `factor_source_id`.
     */
    public var ownedFactorInstances: [OwnedFactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Payload to sign
         */payload: AuthIntent, 
        /**
         * ID of factor to use to sign
         */factorSourceId: FactorSourceIdFromHash, 
        /**
         * The derivation paths to use to derive the private keys to sign with. The
         * `factor_source_id` of each item must match `factor_source_id`.
         */ownedFactorInstances: [OwnedFactorInstance]) {
        self.payload = payload
        self.factorSourceId = factorSourceId
        self.ownedFactorInstances = ownedFactorInstances
    }
}


extension TransactionSignRequestInputOfAuthIntent: Sendable {} 
extension TransactionSignRequestInputOfAuthIntent: Equatable, Hashable {
    public static func ==(lhs: TransactionSignRequestInputOfAuthIntent, rhs: TransactionSignRequestInputOfAuthIntent) -> Bool {
        if lhs.payload != rhs.payload {
            return false
        }
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.ownedFactorInstances != rhs.ownedFactorInstances {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payload)
        hasher.combine(factorSourceId)
        hasher.combine(ownedFactorInstances)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionSignRequestInputOfAuthIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionSignRequestInputOfAuthIntent {
        return
            try TransactionSignRequestInputOfAuthIntent(
                payload: FfiConverterTypeAuthIntent.read(from: &buf), 
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                ownedFactorInstances: FfiConverterSequenceTypeOwnedFactorInstance.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionSignRequestInputOfAuthIntent, into buf: inout [UInt8]) {
        FfiConverterTypeAuthIntent.write(value.payload, into: &buf)
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterSequenceTypeOwnedFactorInstance.write(value.ownedFactorInstances, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionSignRequestInputOfAuthIntent_lift(_ buf: RustBuffer) throws -> TransactionSignRequestInputOfAuthIntent {
    return try FfiConverterTypeTransactionSignRequestInputOfAuthIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionSignRequestInputOfAuthIntent_lower(_ value: TransactionSignRequestInputOfAuthIntent) -> RustBuffer {
    return FfiConverterTypeTransactionSignRequestInputOfAuthIntent.lower(value)
}


/**
 * A batch of keys (derivation paths) all being factor instances of a HDFactorSource
 * with id `factor_source_id` to sign a single transaction with, which hash
 * is `intent_hash`.
 */
public struct TransactionSignRequestInputOfSubintent {
    /**
     * Payload to sign
     */
    public var payload: CompiledSubintent
    /**
     * ID of factor to use to sign
     */
    public var factorSourceId: FactorSourceIdFromHash
    /**
     * The derivation paths to use to derive the private keys to sign with. The
     * `factor_source_id` of each item must match `factor_source_id`.
     */
    public var ownedFactorInstances: [OwnedFactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Payload to sign
         */payload: CompiledSubintent, 
        /**
         * ID of factor to use to sign
         */factorSourceId: FactorSourceIdFromHash, 
        /**
         * The derivation paths to use to derive the private keys to sign with. The
         * `factor_source_id` of each item must match `factor_source_id`.
         */ownedFactorInstances: [OwnedFactorInstance]) {
        self.payload = payload
        self.factorSourceId = factorSourceId
        self.ownedFactorInstances = ownedFactorInstances
    }
}


extension TransactionSignRequestInputOfSubintent: Sendable {} 
extension TransactionSignRequestInputOfSubintent: Equatable, Hashable {
    public static func ==(lhs: TransactionSignRequestInputOfSubintent, rhs: TransactionSignRequestInputOfSubintent) -> Bool {
        if lhs.payload != rhs.payload {
            return false
        }
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.ownedFactorInstances != rhs.ownedFactorInstances {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payload)
        hasher.combine(factorSourceId)
        hasher.combine(ownedFactorInstances)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionSignRequestInputOfSubintent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionSignRequestInputOfSubintent {
        return
            try TransactionSignRequestInputOfSubintent(
                payload: FfiConverterTypeCompiledSubintent.read(from: &buf), 
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                ownedFactorInstances: FfiConverterSequenceTypeOwnedFactorInstance.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionSignRequestInputOfSubintent, into buf: inout [UInt8]) {
        FfiConverterTypeCompiledSubintent.write(value.payload, into: &buf)
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterSequenceTypeOwnedFactorInstance.write(value.ownedFactorInstances, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionSignRequestInputOfSubintent_lift(_ buf: RustBuffer) throws -> TransactionSignRequestInputOfSubintent {
    return try FfiConverterTypeTransactionSignRequestInputOfSubintent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionSignRequestInputOfSubintent_lower(_ value: TransactionSignRequestInputOfSubintent) -> RustBuffer {
    return FfiConverterTypeTransactionSignRequestInputOfSubintent.lower(value)
}


/**
 * A batch of keys (derivation paths) all being factor instances of a HDFactorSource
 * with id `factor_source_id` to sign a single transaction with, which hash
 * is `intent_hash`.
 */
public struct TransactionSignRequestInputOfTransactionIntent {
    /**
     * Payload to sign
     */
    public var payload: CompiledTransactionIntent
    /**
     * ID of factor to use to sign
     */
    public var factorSourceId: FactorSourceIdFromHash
    /**
     * The derivation paths to use to derive the private keys to sign with. The
     * `factor_source_id` of each item must match `factor_source_id`.
     */
    public var ownedFactorInstances: [OwnedFactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Payload to sign
         */payload: CompiledTransactionIntent, 
        /**
         * ID of factor to use to sign
         */factorSourceId: FactorSourceIdFromHash, 
        /**
         * The derivation paths to use to derive the private keys to sign with. The
         * `factor_source_id` of each item must match `factor_source_id`.
         */ownedFactorInstances: [OwnedFactorInstance]) {
        self.payload = payload
        self.factorSourceId = factorSourceId
        self.ownedFactorInstances = ownedFactorInstances
    }
}


extension TransactionSignRequestInputOfTransactionIntent: Sendable {} 
extension TransactionSignRequestInputOfTransactionIntent: Equatable, Hashable {
    public static func ==(lhs: TransactionSignRequestInputOfTransactionIntent, rhs: TransactionSignRequestInputOfTransactionIntent) -> Bool {
        if lhs.payload != rhs.payload {
            return false
        }
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.ownedFactorInstances != rhs.ownedFactorInstances {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(payload)
        hasher.combine(factorSourceId)
        hasher.combine(ownedFactorInstances)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionSignRequestInputOfTransactionIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionSignRequestInputOfTransactionIntent {
        return
            try TransactionSignRequestInputOfTransactionIntent(
                payload: FfiConverterTypeCompiledTransactionIntent.read(from: &buf), 
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf), 
                ownedFactorInstances: FfiConverterSequenceTypeOwnedFactorInstance.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionSignRequestInputOfTransactionIntent, into buf: inout [UInt8]) {
        FfiConverterTypeCompiledTransactionIntent.write(value.payload, into: &buf)
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterSequenceTypeOwnedFactorInstance.write(value.ownedFactorInstances, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionSignRequestInputOfTransactionIntent_lift(_ buf: RustBuffer) throws -> TransactionSignRequestInputOfTransactionIntent {
    return try FfiConverterTypeTransactionSignRequestInputOfTransactionIntent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionSignRequestInputOfTransactionIntent_lower(_ value: TransactionSignRequestInputOfTransactionIntent) -> RustBuffer {
    return FfiConverterTypeTransactionSignRequestInputOfTransactionIntent.lower(value)
}


/**
 * This is the result of the transaction preview analysis.
 * It contains all the information needed to compute and display the transaction details to the user.
 */
public struct TransactionToReview {
    public var transactionManifest: TransactionManifest
    public var executionSummary: ExecutionSummary

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionManifest: TransactionManifest, executionSummary: ExecutionSummary) {
        self.transactionManifest = transactionManifest
        self.executionSummary = executionSummary
    }
}


extension TransactionToReview: Sendable {} 
extension TransactionToReview: Equatable, Hashable {
    public static func ==(lhs: TransactionToReview, rhs: TransactionToReview) -> Bool {
        if lhs.transactionManifest != rhs.transactionManifest {
            return false
        }
        if lhs.executionSummary != rhs.executionSummary {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionManifest)
        hasher.combine(executionSummary)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionToReview: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionToReview {
        return
            try TransactionToReview(
                transactionManifest: FfiConverterTypeTransactionManifest.read(from: &buf), 
                executionSummary: FfiConverterTypeExecutionSummary.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionToReview, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionManifest.write(value.transactionManifest, into: &buf)
        FfiConverterTypeExecutionSummary.write(value.executionSummary, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionToReview_lift(_ buf: RustBuffer) throws -> TransactionToReview {
    return try FfiConverterTypeTransactionToReview.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionToReview_lower(_ value: TransactionToReview) -> RustBuffer {
    return FfiConverterTypeTransactionToReview.lower(value)
}


public struct U11 {
    public var inner: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inner: UInt16) {
        self.inner = inner
    }
}


extension U11: Sendable {} 
extension U11: Equatable, Hashable {
    public static func ==(lhs: U11, rhs: U11) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeU11: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U11 {
        return
            try U11(
                inner: FfiConverterUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: U11, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.inner, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU11_lift(_ buf: RustBuffer) throws -> U11 {
    return try FfiConverterTypeU11.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU11_lower(_ value: U11) -> RustBuffer {
    return FfiConverterTypeU11.lower(value)
}


public struct U30 {
    fileprivate let secretMagic: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: UInt32) {
        self.secretMagic = secretMagic
    }
}


extension U30: Sendable {} 
extension U30: Equatable, Hashable {
    public static func ==(lhs: U30, rhs: U30) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeU30: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U30 {
        return
            try U30(
                secretMagic: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: U30, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU30_lift(_ buf: RustBuffer) throws -> U30 {
    return try FfiConverterTypeU30.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU30_lower(_ value: U30) -> RustBuffer {
    return FfiConverterTypeU30.lower(value)
}


public struct U31 {
    fileprivate let secretMagic: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: UInt32) {
        self.secretMagic = secretMagic
    }
}


extension U31: Sendable {} 
extension U31: Equatable, Hashable {
    public static func ==(lhs: U31, rhs: U31) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeU31: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U31 {
        return
            try U31(
                secretMagic: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: U31, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU31_lift(_ buf: RustBuffer) throws -> U31 {
    return try FfiConverterTypeU31.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU31_lower(_ value: U31) -> RustBuffer {
    return FfiConverterTypeU31.lower(value)
}


public struct Unhardened {
    fileprivate let secretMagic: U31

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: U31) {
        self.secretMagic = secretMagic
    }
}


extension Unhardened: Sendable {} 
extension Unhardened: Equatable, Hashable {
    public static func ==(lhs: Unhardened, rhs: Unhardened) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnhardened: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unhardened {
        return
            try Unhardened(
                secretMagic: FfiConverterTypeU31.read(from: &buf)
        )
    }

    public static func write(_ value: Unhardened, into buf: inout [UInt8]) {
        FfiConverterTypeU31.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnhardened_lift(_ buf: RustBuffer) throws -> Unhardened {
    return try FfiConverterTypeUnhardened.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnhardened_lower(_ value: Unhardened) -> RustBuffer {
    return FfiConverterTypeUnhardened.lower(value)
}


/**
 * Basic security control of an unsecured entity. When said entity
 * is "securified" it will no longer be controlled by this `UnsecuredEntityControl`
 * but rather by an `AccessControl`. It is a name space holding the
 * single factor instance which was used to create
 */
public struct UnsecuredEntityControl {
    public var transactionSigning: HierarchicalDeterministicFactorInstance
    /**
     * The provisional security structure configuration
     */
    public var provisionalSecurifiedConfig: ProvisionalSecurifiedConfig?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionSigning: HierarchicalDeterministicFactorInstance, 
        /**
         * The provisional security structure configuration
         */provisionalSecurifiedConfig: ProvisionalSecurifiedConfig?) {
        self.transactionSigning = transactionSigning
        self.provisionalSecurifiedConfig = provisionalSecurifiedConfig
    }
}


extension UnsecuredEntityControl: Sendable {} 
extension UnsecuredEntityControl: Equatable, Hashable {
    public static func ==(lhs: UnsecuredEntityControl, rhs: UnsecuredEntityControl) -> Bool {
        if lhs.transactionSigning != rhs.transactionSigning {
            return false
        }
        if lhs.provisionalSecurifiedConfig != rhs.provisionalSecurifiedConfig {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionSigning)
        hasher.combine(provisionalSecurifiedConfig)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsecuredEntityControl: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsecuredEntityControl {
        return
            try UnsecuredEntityControl(
                transactionSigning: FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf), 
                provisionalSecurifiedConfig: FfiConverterOptionTypeProvisionalSecurifiedConfig.read(from: &buf)
        )
    }

    public static func write(_ value: UnsecuredEntityControl, into buf: inout [UInt8]) {
        FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value.transactionSigning, into: &buf)
        FfiConverterOptionTypeProvisionalSecurifiedConfig.write(value.provisionalSecurifiedConfig, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsecuredEntityControl_lift(_ buf: RustBuffer) throws -> UnsecuredEntityControl {
    return try FfiConverterTypeUnsecuredEntityControl.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsecuredEntityControl_lower(_ value: UnsecuredEntityControl) -> RustBuffer {
    return FfiConverterTypeUnsecuredEntityControl.lower(value)
}


public struct UnsecurifiedHardened {
    fileprivate let secretMagic: U30

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: U30) {
        self.secretMagic = secretMagic
    }
}


extension UnsecurifiedHardened: Sendable {} 
extension UnsecurifiedHardened: Equatable, Hashable {
    public static func ==(lhs: UnsecurifiedHardened, rhs: UnsecurifiedHardened) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsecurifiedHardened: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsecurifiedHardened {
        return
            try UnsecurifiedHardened(
                secretMagic: FfiConverterTypeU30.read(from: &buf)
        )
    }

    public static func write(_ value: UnsecurifiedHardened, into buf: inout [UInt8]) {
        FfiConverterTypeU30.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsecurifiedHardened_lift(_ buf: RustBuffer) throws -> UnsecurifiedHardened {
    return try FfiConverterTypeUnsecurifiedHardened.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsecurifiedHardened_lower(_ value: UnsecurifiedHardened) -> RustBuffer {
    return FfiConverterTypeUnsecurifiedHardened.lower(value)
}


/**
 * The data associated with the various validator claim NFTs
 */
public struct UnstakeData {
    public var name: String
    /**
     * An epoch number at (or after) which the pending unstaked XRD may be claimed.
     */
    public var claimEpoch: Epoch
    /**
     * An XRD amount to be claimed.
     */
    public var claimAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, 
        /**
         * An epoch number at (or after) which the pending unstaked XRD may be claimed.
         */claimEpoch: Epoch, 
        /**
         * An XRD amount to be claimed.
         */claimAmount: Decimal192) {
        self.name = name
        self.claimEpoch = claimEpoch
        self.claimAmount = claimAmount
    }
}


extension UnstakeData: Sendable {} 
extension UnstakeData: Equatable, Hashable {
    public static func ==(lhs: UnstakeData, rhs: UnstakeData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.claimEpoch != rhs.claimEpoch {
            return false
        }
        if lhs.claimAmount != rhs.claimAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(claimEpoch)
        hasher.combine(claimAmount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnstakeData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstakeData {
        return
            try UnstakeData(
                name: FfiConverterString.read(from: &buf), 
                claimEpoch: FfiConverterTypeEpoch.read(from: &buf), 
                claimAmount: FfiConverterTypeDecimal192.read(from: &buf)
        )
    }

    public static func write(_ value: UnstakeData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeEpoch.write(value.claimEpoch, into: &buf)
        FfiConverterTypeDecimal192.write(value.claimAmount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnstakeData_lift(_ buf: RustBuffer) throws -> UnstakeData {
    return try FfiConverterTypeUnstakeData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnstakeData_lower(_ value: UnstakeData) -> RustBuffer {
    return FfiConverterTypeUnstakeData.lower(value)
}


public struct UnvalidatedSubintentManifest {
    public var subintentManifestString: String
    public var blobs: Blobs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(subintentManifestString: String, blobs: Blobs) {
        self.subintentManifestString = subintentManifestString
        self.blobs = blobs
    }
}


extension UnvalidatedSubintentManifest: Sendable {} 
extension UnvalidatedSubintentManifest: Equatable, Hashable {
    public static func ==(lhs: UnvalidatedSubintentManifest, rhs: UnvalidatedSubintentManifest) -> Bool {
        if lhs.subintentManifestString != rhs.subintentManifestString {
            return false
        }
        if lhs.blobs != rhs.blobs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(subintentManifestString)
        hasher.combine(blobs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnvalidatedSubintentManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnvalidatedSubintentManifest {
        return
            try UnvalidatedSubintentManifest(
                subintentManifestString: FfiConverterString.read(from: &buf), 
                blobs: FfiConverterTypeBlobs.read(from: &buf)
        )
    }

    public static func write(_ value: UnvalidatedSubintentManifest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.subintentManifestString, into: &buf)
        FfiConverterTypeBlobs.write(value.blobs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnvalidatedSubintentManifest_lift(_ buf: RustBuffer) throws -> UnvalidatedSubintentManifest {
    return try FfiConverterTypeUnvalidatedSubintentManifest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnvalidatedSubintentManifest_lower(_ value: UnvalidatedSubintentManifest) -> RustBuffer {
    return FfiConverterTypeUnvalidatedSubintentManifest.lower(value)
}


public struct UnvalidatedTransactionManifest {
    public var transactionManifestString: String
    public var blobs: Blobs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionManifestString: String, blobs: Blobs) {
        self.transactionManifestString = transactionManifestString
        self.blobs = blobs
    }
}


extension UnvalidatedTransactionManifest: Sendable {} 
extension UnvalidatedTransactionManifest: Equatable, Hashable {
    public static func ==(lhs: UnvalidatedTransactionManifest, rhs: UnvalidatedTransactionManifest) -> Bool {
        if lhs.transactionManifestString != rhs.transactionManifestString {
            return false
        }
        if lhs.blobs != rhs.blobs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionManifestString)
        hasher.combine(blobs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnvalidatedTransactionManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnvalidatedTransactionManifest {
        return
            try UnvalidatedTransactionManifest(
                transactionManifestString: FfiConverterString.read(from: &buf), 
                blobs: FfiConverterTypeBlobs.read(from: &buf)
        )
    }

    public static func write(_ value: UnvalidatedTransactionManifest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.transactionManifestString, into: &buf)
        FfiConverterTypeBlobs.write(value.blobs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnvalidatedTransactionManifest_lift(_ buf: RustBuffer) throws -> UnvalidatedTransactionManifest {
    return try FfiConverterTypeUnvalidatedTransactionManifest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnvalidatedTransactionManifest_lower(_ value: UnvalidatedTransactionManifest) -> RustBuffer {
    return FfiConverterTypeUnvalidatedTransactionManifest.lower(value)
}


/**
 * Address to a Validator that secures the network by validating transactions, users can stake to these
 * validators (Delegated Proof of Stake) by using the Dashboard and sending a TX to the Radix Wallet to sign;
 * e.g.:
 * `"validator_rdx1sd5368vqdmjk0y2w7ymdts02cz9c52858gpyny56xdvzuheepdeyy0"`
 *
 * A `ValidatorAddress` has the [Scrypto's `EntityType`][entt] `GlobalValidator`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalValidatorAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L249-L250
 */
public struct ValidatorAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension ValidatorAddress: Sendable {} 
extension ValidatorAddress: Equatable, Hashable {
    public static func ==(lhs: ValidatorAddress, rhs: ValidatorAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeValidatorAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorAddress {
        return
            try ValidatorAddress(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ValidatorAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidatorAddress_lift(_ buf: RustBuffer) throws -> ValidatorAddress {
    return try FfiConverterTypeValidatorAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValidatorAddress_lower(_ value: ValidatorAddress) -> RustBuffer {
    return FfiConverterTypeValidatorAddress.lower(value)
}


/**
 * Addresses to a specific vault, owned by a user, holding asset of one kind, either fungible or non_fungible.
 * Identities cannot own assets so they do not have vaults, but Accounts do, e.g.:
 * `"internal_vault_rdx1tz474x29nxxd4k2p2reete9xyz4apawv63dphxkr00qt23vyju49fq"`
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of VaultAddresses:
 * * InternalFungibleVault
 * * InternalNonFungibleVault
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalVaultAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L251-L255
 */
public struct VaultAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}


extension VaultAddress: Sendable {} 
extension VaultAddress: Equatable, Hashable {
    public static func ==(lhs: VaultAddress, rhs: VaultAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVaultAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VaultAddress {
        return
            try VaultAddress(
                secretMagic: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: VaultAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVaultAddress_lift(_ buf: RustBuffer) throws -> VaultAddress {
    return try FfiConverterTypeVaultAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVaultAddress_lower(_ value: VaultAddress) -> RustBuffer {
    return FfiConverterTypeVaultAddress.lower(value)
}


public struct WalletInteractionWalletAccount {
    public var address: AccountAddress
    public var label: DisplayName
    public var appearanceId: AppearanceId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: AccountAddress, label: DisplayName, appearanceId: AppearanceId) {
        self.address = address
        self.label = label
        self.appearanceId = appearanceId
    }
}


extension WalletInteractionWalletAccount: Sendable {} 
extension WalletInteractionWalletAccount: Equatable, Hashable {
    public static func ==(lhs: WalletInteractionWalletAccount, rhs: WalletInteractionWalletAccount) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(label)
        hasher.combine(appearanceId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletInteractionWalletAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionWalletAccount {
        return
            try WalletInteractionWalletAccount(
                address: FfiConverterTypeAccountAddress.read(from: &buf), 
                label: FfiConverterTypeDisplayName.read(from: &buf), 
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf)
        )
    }

    public static func write(_ value: WalletInteractionWalletAccount, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.label, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletInteractionWalletAccount_lift(_ buf: RustBuffer) throws -> WalletInteractionWalletAccount {
    return try FfiConverterTypeWalletInteractionWalletAccount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletInteractionWalletAccount_lower(_ value: WalletInteractionWalletAccount) -> RustBuffer {
    return FfiConverterTypeWalletInteractionWalletAccount.lower(value)
}


public struct WalletToDappInteractionAccountProof {
    public var accountAddress: AccountAddress
    public var proof: WalletToDappInteractionAuthProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accountAddress: AccountAddress, proof: WalletToDappInteractionAuthProof) {
        self.accountAddress = accountAddress
        self.proof = proof
    }
}


extension WalletToDappInteractionAccountProof: Sendable {} 
extension WalletToDappInteractionAccountProof: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionAccountProof, rhs: WalletToDappInteractionAccountProof) -> Bool {
        if lhs.accountAddress != rhs.accountAddress {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountAddress)
        hasher.combine(proof)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAccountProof {
        return
            try WalletToDappInteractionAccountProof(
                accountAddress: FfiConverterTypeAccountAddress.read(from: &buf), 
                proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionAccountProof, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.accountAddress, into: &buf)
        FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAccountProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAccountProof {
    return try FfiConverterTypeWalletToDappInteractionAccountProof.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAccountProof_lower(_ value: WalletToDappInteractionAccountProof) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAccountProof.lower(value)
}


public struct WalletToDappInteractionAccountsRequestResponseItem {
    public var accounts: [WalletInteractionWalletAccount]
    public var challenge: DappToWalletInteractionAuthChallengeNonce?
    public var proofs: [WalletToDappInteractionAccountProof]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accounts: [WalletInteractionWalletAccount], challenge: DappToWalletInteractionAuthChallengeNonce?, proofs: [WalletToDappInteractionAccountProof]?) {
        self.accounts = accounts
        self.challenge = challenge
        self.proofs = proofs
    }
}


extension WalletToDappInteractionAccountsRequestResponseItem: Sendable {} 
extension WalletToDappInteractionAccountsRequestResponseItem: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionAccountsRequestResponseItem, rhs: WalletToDappInteractionAccountsRequestResponseItem) -> Bool {
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.proofs != rhs.proofs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accounts)
        hasher.combine(challenge)
        hasher.combine(proofs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAccountsRequestResponseItem {
        return
            try WalletToDappInteractionAccountsRequestResponseItem(
                accounts: FfiConverterSequenceTypeWalletInteractionWalletAccount.read(from: &buf), 
                challenge: FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf), 
                proofs: FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionAccountsRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeWalletInteractionWalletAccount.write(value.accounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
        FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof.write(value.proofs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAccountsRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem_lower(_ value: WalletToDappInteractionAccountsRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.lower(value)
}


public struct WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
    public var persona: DappWalletInteractionPersona
    public var challenge: DappToWalletInteractionAuthChallengeNonce
    public var proof: WalletToDappInteractionAuthProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(persona: DappWalletInteractionPersona, challenge: DappToWalletInteractionAuthChallengeNonce, proof: WalletToDappInteractionAuthProof) {
        self.persona = persona
        self.challenge = challenge
        self.proof = proof
    }
}


extension WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: Sendable {} 
extension WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem, rhs: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem) -> Bool {
        if lhs.persona != rhs.persona {
            return false
        }
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(persona)
        hasher.combine(challenge)
        hasher.combine(proof)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
        return
            try WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem(
                persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf), 
                challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf), 
                proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
        FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem_lower(_ value: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.lower(value)
}


public struct WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
    public var persona: DappWalletInteractionPersona

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(persona: DappWalletInteractionPersona) {
        self.persona = persona
    }
}


extension WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: Sendable {} 
extension WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem, rhs: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem) -> Bool {
        if lhs.persona != rhs.persona {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(persona)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
        return
            try WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem(
                persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem_lower(_ value: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.lower(value)
}


public struct WalletToDappInteractionAuthProof {
    public var publicKey: PublicKey
    public var curve: Slip10Curve
    public var signature: Signature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: PublicKey, curve: Slip10Curve, signature: Signature) {
        self.publicKey = publicKey
        self.curve = curve
        self.signature = signature
    }
}


extension WalletToDappInteractionAuthProof: Sendable {} 
extension WalletToDappInteractionAuthProof: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionAuthProof, rhs: WalletToDappInteractionAuthProof) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.curve != rhs.curve {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(curve)
        hasher.combine(signature)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionAuthProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthProof {
        return
            try WalletToDappInteractionAuthProof(
                publicKey: FfiConverterTypePublicKey.read(from: &buf), 
                curve: FfiConverterTypeSLIP10Curve.read(from: &buf), 
                signature: FfiConverterTypeSignature.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionAuthProof, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterTypeSLIP10Curve.write(value.curve, into: &buf)
        FfiConverterTypeSignature.write(value.signature, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAuthProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthProof {
    return try FfiConverterTypeWalletToDappInteractionAuthProof.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAuthProof_lower(_ value: WalletToDappInteractionAuthProof) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthProof.lower(value)
}


public struct WalletToDappInteractionAuthUsePersonaRequestResponseItem {
    public var persona: DappWalletInteractionPersona

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(persona: DappWalletInteractionPersona) {
        self.persona = persona
    }
}


extension WalletToDappInteractionAuthUsePersonaRequestResponseItem: Sendable {} 
extension WalletToDappInteractionAuthUsePersonaRequestResponseItem: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionAuthUsePersonaRequestResponseItem, rhs: WalletToDappInteractionAuthUsePersonaRequestResponseItem) -> Bool {
        if lhs.persona != rhs.persona {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(persona)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthUsePersonaRequestResponseItem {
        return
            try WalletToDappInteractionAuthUsePersonaRequestResponseItem(
                persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionAuthUsePersonaRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthUsePersonaRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem_lower(_ value: WalletToDappInteractionAuthUsePersonaRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.lower(value)
}


public struct WalletToDappInteractionAuthorizedRequestResponseItems {
    public var auth: WalletToDappInteractionAuthRequestResponseItem
    public var ongoingAccounts: WalletToDappInteractionAccountsRequestResponseItem?
    public var ongoingPersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?
    public var oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?
    public var oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?
    public var proofOfOwnership: WalletToDappInteractionProofOfOwnershipRequestResponseItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(auth: WalletToDappInteractionAuthRequestResponseItem, ongoingAccounts: WalletToDappInteractionAccountsRequestResponseItem?, ongoingPersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?, oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?, oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?, proofOfOwnership: WalletToDappInteractionProofOfOwnershipRequestResponseItem?) {
        self.auth = auth
        self.ongoingAccounts = ongoingAccounts
        self.ongoingPersonaData = ongoingPersonaData
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
        self.proofOfOwnership = proofOfOwnership
    }
}


extension WalletToDappInteractionAuthorizedRequestResponseItems: Sendable {} 
extension WalletToDappInteractionAuthorizedRequestResponseItems: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionAuthorizedRequestResponseItems, rhs: WalletToDappInteractionAuthorizedRequestResponseItems) -> Bool {
        if lhs.auth != rhs.auth {
            return false
        }
        if lhs.ongoingAccounts != rhs.ongoingAccounts {
            return false
        }
        if lhs.ongoingPersonaData != rhs.ongoingPersonaData {
            return false
        }
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        if lhs.proofOfOwnership != rhs.proofOfOwnership {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(auth)
        hasher.combine(ongoingAccounts)
        hasher.combine(ongoingPersonaData)
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
        hasher.combine(proofOfOwnership)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthorizedRequestResponseItems {
        return
            try WalletToDappInteractionAuthorizedRequestResponseItems(
                auth: FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.read(from: &buf), 
                ongoingAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf), 
                ongoingPersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf), 
                oneTimeAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf), 
                oneTimePersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf), 
                proofOfOwnership: FfiConverterOptionTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionAuthorizedRequestResponseItems, into buf: inout [UInt8]) {
        FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.write(value.auth, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.ongoingAccounts, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.ongoingPersonaData, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.oneTimePersonaData, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.write(value.proofOfOwnership, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthorizedRequestResponseItems {
    return try FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems_lower(_ value: WalletToDappInteractionAuthorizedRequestResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.lower(value)
}


public struct WalletToDappInteractionFailureResponse {
    public var interactionId: WalletInteractionId
    public var error: DappWalletInteractionErrorType
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, error: DappWalletInteractionErrorType, message: String?) {
        self.interactionId = interactionId
        self.error = error
        self.message = message
    }
}


extension WalletToDappInteractionFailureResponse: Sendable {} 
extension WalletToDappInteractionFailureResponse: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionFailureResponse, rhs: WalletToDappInteractionFailureResponse) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(error)
        hasher.combine(message)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionFailureResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionFailureResponse {
        return
            try WalletToDappInteractionFailureResponse(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf), 
                error: FfiConverterTypeDappWalletInteractionErrorType.read(from: &buf), 
                message: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionFailureResponse, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeDappWalletInteractionErrorType.write(value.error, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionFailureResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionFailureResponse {
    return try FfiConverterTypeWalletToDappInteractionFailureResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionFailureResponse_lower(_ value: WalletToDappInteractionFailureResponse) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionFailureResponse.lower(value)
}


public struct WalletToDappInteractionPersonaDataRequestResponseItem {
    public var name: PersonaDataEntryName?
    public var emailAddresses: [EmailAddress]?
    public var phoneNumbers: [PersonaDataEntryPhoneNumber]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: PersonaDataEntryName?, emailAddresses: [EmailAddress]?, phoneNumbers: [PersonaDataEntryPhoneNumber]?) {
        self.name = name
        self.emailAddresses = emailAddresses
        self.phoneNumbers = phoneNumbers
    }
}


extension WalletToDappInteractionPersonaDataRequestResponseItem: Sendable {} 
extension WalletToDappInteractionPersonaDataRequestResponseItem: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionPersonaDataRequestResponseItem, rhs: WalletToDappInteractionPersonaDataRequestResponseItem) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(emailAddresses)
        hasher.combine(phoneNumbers)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionPersonaDataRequestResponseItem {
        return
            try WalletToDappInteractionPersonaDataRequestResponseItem(
                name: FfiConverterOptionTypePersonaDataEntryName.read(from: &buf), 
                emailAddresses: FfiConverterOptionSequenceTypeEmailAddress.read(from: &buf), 
                phoneNumbers: FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionPersonaDataRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataEntryName.write(value.name, into: &buf)
        FfiConverterOptionSequenceTypeEmailAddress.write(value.emailAddresses, into: &buf)
        FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber.write(value.phoneNumbers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionPersonaDataRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem_lower(_ value: WalletToDappInteractionPersonaDataRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.lower(value)
}


public struct WalletToDappInteractionPersonaProof {
    public var identityAddress: IdentityAddress
    public var proof: WalletToDappInteractionAuthProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityAddress: IdentityAddress, proof: WalletToDappInteractionAuthProof) {
        self.identityAddress = identityAddress
        self.proof = proof
    }
}


extension WalletToDappInteractionPersonaProof: Sendable {} 
extension WalletToDappInteractionPersonaProof: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionPersonaProof, rhs: WalletToDappInteractionPersonaProof) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(proof)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionPersonaProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionPersonaProof {
        return
            try WalletToDappInteractionPersonaProof(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf), 
                proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionPersonaProof, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionPersonaProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionPersonaProof {
    return try FfiConverterTypeWalletToDappInteractionPersonaProof.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionPersonaProof_lower(_ value: WalletToDappInteractionPersonaProof) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionPersonaProof.lower(value)
}


public struct WalletToDappInteractionPreAuthorizationResponseItems {
    public var response: WalletToDappInteractionSubintentResponseItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(response: WalletToDappInteractionSubintentResponseItem) {
        self.response = response
    }
}


extension WalletToDappInteractionPreAuthorizationResponseItems: Sendable {} 
extension WalletToDappInteractionPreAuthorizationResponseItems: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionPreAuthorizationResponseItems, rhs: WalletToDappInteractionPreAuthorizationResponseItems) -> Bool {
        if lhs.response != rhs.response {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(response)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionPreAuthorizationResponseItems {
        return
            try WalletToDappInteractionPreAuthorizationResponseItems(
                response: FfiConverterTypeWalletToDappInteractionSubintentResponseItem.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionPreAuthorizationResponseItems, into buf: inout [UInt8]) {
        FfiConverterTypeWalletToDappInteractionSubintentResponseItem.write(value.response, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionPreAuthorizationResponseItems {
    return try FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems_lower(_ value: WalletToDappInteractionPreAuthorizationResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.lower(value)
}


/**
 * A response with the list of proofs of ownership for `Accounts`/`Personas`
 * and the challenge that was signed.
 */
public struct WalletToDappInteractionProofOfOwnershipRequestResponseItem {
    public var challenge: DappToWalletInteractionAuthChallengeNonce
    public var proofs: [WalletToDappInteractionProofOfOwnership]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(challenge: DappToWalletInteractionAuthChallengeNonce, proofs: [WalletToDappInteractionProofOfOwnership]) {
        self.challenge = challenge
        self.proofs = proofs
    }
}


extension WalletToDappInteractionProofOfOwnershipRequestResponseItem: Sendable {} 
extension WalletToDappInteractionProofOfOwnershipRequestResponseItem: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionProofOfOwnershipRequestResponseItem, rhs: WalletToDappInteractionProofOfOwnershipRequestResponseItem) -> Bool {
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.proofs != rhs.proofs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challenge)
        hasher.combine(proofs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionProofOfOwnershipRequestResponseItem {
        return
            try WalletToDappInteractionProofOfOwnershipRequestResponseItem(
                challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf), 
                proofs: FfiConverterSequenceTypeWalletToDappInteractionProofOfOwnership.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionProofOfOwnershipRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
        FfiConverterSequenceTypeWalletToDappInteractionProofOfOwnership.write(value.proofs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionProofOfOwnershipRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem_lower(_ value: WalletToDappInteractionProofOfOwnershipRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.lower(value)
}


public struct WalletToDappInteractionSendTransactionResponseItem {
    public var transactionIntentHash: TransactionIntentHash

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionIntentHash: TransactionIntentHash) {
        self.transactionIntentHash = transactionIntentHash
    }
}


extension WalletToDappInteractionSendTransactionResponseItem: Sendable {} 
extension WalletToDappInteractionSendTransactionResponseItem: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionSendTransactionResponseItem, rhs: WalletToDappInteractionSendTransactionResponseItem) -> Bool {
        if lhs.transactionIntentHash != rhs.transactionIntentHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionIntentHash)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSendTransactionResponseItem {
        return
            try WalletToDappInteractionSendTransactionResponseItem(
                transactionIntentHash: FfiConverterTypeTransactionIntentHash.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionSendTransactionResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionIntentHash.write(value.transactionIntentHash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSendTransactionResponseItem {
    return try FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem_lower(_ value: WalletToDappInteractionSendTransactionResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.lower(value)
}


public struct WalletToDappInteractionSubintentResponseItem {
    /**
     * A signed subintent
     */
    public var signedSubintent: SignedSubintent
    /**
     * The timestamp at which the subintent expires
     */
    public var expirationTimestamp: Instant

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A signed subintent
         */signedSubintent: SignedSubintent, 
        /**
         * The timestamp at which the subintent expires
         */expirationTimestamp: Instant) {
        self.signedSubintent = signedSubintent
        self.expirationTimestamp = expirationTimestamp
    }
}


extension WalletToDappInteractionSubintentResponseItem: Sendable {} 
extension WalletToDappInteractionSubintentResponseItem: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionSubintentResponseItem, rhs: WalletToDappInteractionSubintentResponseItem) -> Bool {
        if lhs.signedSubintent != rhs.signedSubintent {
            return false
        }
        if lhs.expirationTimestamp != rhs.expirationTimestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signedSubintent)
        hasher.combine(expirationTimestamp)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionSubintentResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSubintentResponseItem {
        return
            try WalletToDappInteractionSubintentResponseItem(
                signedSubintent: FfiConverterTypeSignedSubintent.read(from: &buf), 
                expirationTimestamp: FfiConverterTypeInstant.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionSubintentResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeSignedSubintent.write(value.signedSubintent, into: &buf)
        FfiConverterTypeInstant.write(value.expirationTimestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionSubintentResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSubintentResponseItem {
    return try FfiConverterTypeWalletToDappInteractionSubintentResponseItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionSubintentResponseItem_lower(_ value: WalletToDappInteractionSubintentResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionSubintentResponseItem.lower(value)
}


public struct WalletToDappInteractionSuccessResponse {
    public var interactionId: WalletInteractionId
    public var items: WalletToDappInteractionResponseItems

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, items: WalletToDappInteractionResponseItems) {
        self.interactionId = interactionId
        self.items = items
    }
}


extension WalletToDappInteractionSuccessResponse: Sendable {} 
extension WalletToDappInteractionSuccessResponse: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionSuccessResponse, rhs: WalletToDappInteractionSuccessResponse) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(items)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionSuccessResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSuccessResponse {
        return
            try WalletToDappInteractionSuccessResponse(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf), 
                items: FfiConverterTypeWalletToDappInteractionResponseItems.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionSuccessResponse, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeWalletToDappInteractionResponseItems.write(value.items, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionSuccessResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSuccessResponse {
    return try FfiConverterTypeWalletToDappInteractionSuccessResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionSuccessResponse_lower(_ value: WalletToDappInteractionSuccessResponse) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionSuccessResponse.lower(value)
}


public struct WalletToDappInteractionTransactionResponseItems {
    public var send: WalletToDappInteractionSendTransactionResponseItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(send: WalletToDappInteractionSendTransactionResponseItem) {
        self.send = send
    }
}


extension WalletToDappInteractionTransactionResponseItems: Sendable {} 
extension WalletToDappInteractionTransactionResponseItems: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionTransactionResponseItems, rhs: WalletToDappInteractionTransactionResponseItems) -> Bool {
        if lhs.send != rhs.send {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(send)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionTransactionResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionTransactionResponseItems {
        return
            try WalletToDappInteractionTransactionResponseItems(
                send: FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionTransactionResponseItems, into buf: inout [UInt8]) {
        FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.write(value.send, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionTransactionResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionTransactionResponseItems {
    return try FfiConverterTypeWalletToDappInteractionTransactionResponseItems.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionTransactionResponseItems_lower(_ value: WalletToDappInteractionTransactionResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionTransactionResponseItems.lower(value)
}


public struct WalletToDappInteractionUnauthorizedRequestResponseItems {
    public var oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?
    public var oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?, oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?) {
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
    }
}


extension WalletToDappInteractionUnauthorizedRequestResponseItems: Sendable {} 
extension WalletToDappInteractionUnauthorizedRequestResponseItems: Equatable, Hashable {
    public static func ==(lhs: WalletToDappInteractionUnauthorizedRequestResponseItems, rhs: WalletToDappInteractionUnauthorizedRequestResponseItems) -> Bool {
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionUnauthorizedRequestResponseItems {
        return
            try WalletToDappInteractionUnauthorizedRequestResponseItems(
                oneTimeAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf), 
                oneTimePersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf)
        )
    }

    public static func write(_ value: WalletToDappInteractionUnauthorizedRequestResponseItems, into buf: inout [UInt8]) {
        FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.oneTimePersonaData, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionUnauthorizedRequestResponseItems {
    return try FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems_lower(_ value: WalletToDappInteractionUnauthorizedRequestResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A claimable resource in an account locker.
 */

public enum AccountLockerClaimableResource {
    
    /**
     * A fungible resource with a specific claimable amount
     */
    case fungible(resourceAddress: ResourceAddress, amount: Decimal192
    )
    /**
     * A non_fungible resource with the total number of items that can be claimed
     */
    case nonFungible(resourceAddress: ResourceAddress, numberOfItems: UInt64
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountLockerClaimableResource: FfiConverterRustBuffer {
    typealias SwiftType = AccountLockerClaimableResource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountLockerClaimableResource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fungible(resourceAddress: try FfiConverterTypeResourceAddress.read(from: &buf), amount: try FfiConverterTypeDecimal192.read(from: &buf)
        )
        
        case 2: return .nonFungible(resourceAddress: try FfiConverterTypeResourceAddress.read(from: &buf), numberOfItems: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountLockerClaimableResource, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fungible(resourceAddress,amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal192.write(amount, into: &buf)
            
        
        case let .nonFungible(resourceAddress,numberOfItems):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterUInt64.write(numberOfItems, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountLockerClaimableResource_lift(_ buf: RustBuffer) throws -> AccountLockerClaimableResource {
    return try FfiConverterTypeAccountLockerClaimableResource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountLockerClaimableResource_lower(_ value: AccountLockerClaimableResource) -> RustBuffer {
    return FfiConverterTypeAccountLockerClaimableResource.lower(value)
}


extension AccountLockerClaimableResource: Sendable {} 
extension AccountLockerClaimableResource: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either an `Account` or a `Persona`.
 */

public enum AccountOrPersona {
    
    /**
     * An `Account`
     *
     * Note:
     * This case/variant can not be named `account`/ `Account` due
     * to Kotlin UniFFI limitation.
     */
    case accountEntity(Account
    )
    /**
     * A `Persona`
     *
     * Note:
     * This is named `personaEntity` / `PersonaEntity` to match
     * `accountEntity` / `AccountEntity` which can not be named
     * `account`/ `Account` due to Kotlin UniFFI limitation.
     */
    case personaEntity(Persona
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = AccountOrPersona

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountOrPersona {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accountEntity(try FfiConverterTypeAccount.read(from: &buf)
        )
        
        case 2: return .personaEntity(try FfiConverterTypePersona.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountOrPersona, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .accountEntity(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccount.write(v1, into: &buf)
            
        
        case let .personaEntity(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypePersona.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountOrPersona_lift(_ buf: RustBuffer) throws -> AccountOrPersona {
    return try FfiConverterTypeAccountOrPersona.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountOrPersona_lower(_ value: AccountOrPersona) -> RustBuffer {
    return FfiConverterTypeAccountOrPersona.lower(value)
}


extension AccountOrPersona: Sendable {} 
extension AccountOrPersona: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents a withdrawal from an account, either by amount or by specific IDs.
 */

public enum AccountWithdraw {
    
    /**
     * Withdraw a specific amount from the account.
     */
    case amount(resourceAddress: ResourceAddress, amount: Decimal192
    )
    /**
     * Withdraw specific IDs from the account.
     */
    case ids(resourceAddress: ResourceAddress, ids: [NonFungibleLocalId]
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountWithdraw: FfiConverterRustBuffer {
    typealias SwiftType = AccountWithdraw

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountWithdraw {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .amount(resourceAddress: try FfiConverterTypeResourceAddress.read(from: &buf), amount: try FfiConverterTypeDecimal192.read(from: &buf)
        )
        
        case 2: return .ids(resourceAddress: try FfiConverterTypeResourceAddress.read(from: &buf), ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountWithdraw, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .amount(resourceAddress,amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal192.write(amount, into: &buf)
            
        
        case let .ids(resourceAddress,ids):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountWithdraw_lift(_ buf: RustBuffer) throws -> AccountWithdraw {
    return try FfiConverterTypeAccountWithdraw.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountWithdraw_lower(_ value: AccountWithdraw) -> RustBuffer {
    return FfiConverterTypeAccountWithdraw.lower(value)
}


extension AccountWithdraw: Sendable {} 
extension AccountWithdraw: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of addresses.
 *
 * Does not include `LegacyOlympiaAccountAddress` nor `NonFungibleResourceAddress`
 */

public enum Address {
    
    case accessController(AccessControllerAddress
    )
    case account(AccountAddress
    )
    case component(ComponentAddress
    )
    case identity(IdentityAddress
    )
    case package(PackageAddress
    )
    case pool(PoolAddress
    )
    case resource(ResourceAddress
    )
    case validator(ValidatorAddress
    )
    case vault(VaultAddress
    )
    case locker(LockerAddress
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = Address

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accessController(try FfiConverterTypeAccessControllerAddress.read(from: &buf)
        )
        
        case 2: return .account(try FfiConverterTypeAccountAddress.read(from: &buf)
        )
        
        case 3: return .component(try FfiConverterTypeComponentAddress.read(from: &buf)
        )
        
        case 4: return .identity(try FfiConverterTypeIdentityAddress.read(from: &buf)
        )
        
        case 5: return .package(try FfiConverterTypePackageAddress.read(from: &buf)
        )
        
        case 6: return .pool(try FfiConverterTypePoolAddress.read(from: &buf)
        )
        
        case 7: return .resource(try FfiConverterTypeResourceAddress.read(from: &buf)
        )
        
        case 8: return .validator(try FfiConverterTypeValidatorAddress.read(from: &buf)
        )
        
        case 9: return .vault(try FfiConverterTypeVaultAddress.read(from: &buf)
        )
        
        case 10: return .locker(try FfiConverterTypeLockerAddress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .accessController(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccessControllerAddress.write(v1, into: &buf)
            
        
        case let .account(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountAddress.write(v1, into: &buf)
            
        
        case let .component(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeComponentAddress.write(v1, into: &buf)
            
        
        case let .identity(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeIdentityAddress.write(v1, into: &buf)
            
        
        case let .package(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypePackageAddress.write(v1, into: &buf)
            
        
        case let .pool(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypePoolAddress.write(v1, into: &buf)
            
        
        case let .resource(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeResourceAddress.write(v1, into: &buf)
            
        
        case let .validator(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeValidatorAddress.write(v1, into: &buf)
            
        
        case let .vault(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeVaultAddress.write(v1, into: &buf)
            
        
        case let .locker(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeLockerAddress.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lift(_ buf: RustBuffer) throws -> Address {
    return try FfiConverterTypeAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddress_lower(_ value: Address) -> RustBuffer {
    return FfiConverterTypeAddress.lower(value)
}


extension Address: Sendable {} 
extension Address: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AddressFormat {
    
    case full
    case raw
    case `default`
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressFormat: FfiConverterRustBuffer {
    typealias SwiftType = AddressFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .full
        
        case 2: return .raw
        
        case 3: return .`default`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .full:
            writeInt(&buf, Int32(1))
        
        
        case .raw:
            writeInt(&buf, Int32(2))
        
        
        case .`default`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressFormat_lift(_ buf: RustBuffer) throws -> AddressFormat {
    return try FfiConverterTypeAddressFormat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressFormat_lower(_ value: AddressFormat) -> RustBuffer {
    return FfiConverterTypeAddressFormat.lower(value)
}


extension AddressFormat: Sendable {} 
extension AddressFormat: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of addresses of either an Account or a Persona (IdentityAddress)
 */

public enum AddressOfAccountOrPersona {
    
    case account(AccountAddress
    )
    case identity(IdentityAddress
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddressOfAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = AddressOfAccountOrPersona

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressOfAccountOrPersona {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(try FfiConverterTypeAccountAddress.read(from: &buf)
        )
        
        case 2: return .identity(try FfiConverterTypeIdentityAddress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressOfAccountOrPersona, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountAddress.write(v1, into: &buf)
            
        
        case let .identity(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeIdentityAddress.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressOfAccountOrPersona_lift(_ buf: RustBuffer) throws -> AddressOfAccountOrPersona {
    return try FfiConverterTypeAddressOfAccountOrPersona.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddressOfAccountOrPersona_lower(_ value: AddressOfAccountOrPersona) -> RustBuffer {
    return FfiConverterTypeAddressOfAccountOrPersona.lower(value)
}


extension AddressOfAccountOrPersona: Sendable {} 
extension AddressOfAccountOrPersona: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The model of a Arculus Card.
 */

public enum ArculusCardModel {
    
    /**
     * Arculus card model: "Arculus Cold Storage Wallet",
     * for more info [see][link].
     *
     * [link]: https://www.getarculus.com/products/arculus-cold-storage-wallet.html
     */
    case arculusColdStorageWallet
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeArculusCardModel: FfiConverterRustBuffer {
    typealias SwiftType = ArculusCardModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCardModel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .arculusColdStorageWallet
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ArculusCardModel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .arculusColdStorageWallet:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusCardModel_lift(_ buf: RustBuffer) throws -> ArculusCardModel {
    return try FfiConverterTypeArculusCardModel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusCardModel_lower(_ value: ArculusCardModel) -> RustBuffer {
    return FfiConverterTypeArculusCardModel.lower(value)
}


extension ArculusCardModel: Sendable {} 
extension ArculusCardModel: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ArculusMinFirmwareVersionRequirement {
    
    case valid
    case invalid(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeArculusMinFirmwareVersionRequirement: FfiConverterRustBuffer {
    typealias SwiftType = ArculusMinFirmwareVersionRequirement

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusMinFirmwareVersionRequirement {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .valid
        
        case 2: return .invalid(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ArculusMinFirmwareVersionRequirement, into buf: inout [UInt8]) {
        switch value {
        
        
        case .valid:
            writeInt(&buf, Int32(1))
        
        
        case let .invalid(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusMinFirmwareVersionRequirement_lift(_ buf: RustBuffer) throws -> ArculusMinFirmwareVersionRequirement {
    return try FfiConverterTypeArculusMinFirmwareVersionRequirement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeArculusMinFirmwareVersionRequirement_lower(_ value: ArculusMinFirmwareVersionRequirement) -> RustBuffer {
    return FfiConverterTypeArculusMinFirmwareVersionRequirement.lower(value)
}


extension ArculusMinFirmwareVersionRequirement: Sendable {} 
extension ArculusMinFirmwareVersionRequirement: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The purpose of the authorization request
 */

public enum AuthorizationPurpose {
    
    /**
     * When a new account is about to be created.
     */
    case creatingAccount
    /**
     * When a batch of accounts is about to be created.
     */
    case creatingAccounts
    /**
     * When a new persona is about to be created.
     */
    case creatingPersona
    /**
     * When a batch of personas is about to be created.
     */
    case creatingPersonas
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthorizationPurpose: FfiConverterRustBuffer {
    typealias SwiftType = AuthorizationPurpose

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizationPurpose {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .creatingAccount
        
        case 2: return .creatingAccounts
        
        case 3: return .creatingPersona
        
        case 4: return .creatingPersonas
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthorizationPurpose, into buf: inout [UInt8]) {
        switch value {
        
        
        case .creatingAccount:
            writeInt(&buf, Int32(1))
        
        
        case .creatingAccounts:
            writeInt(&buf, Int32(2))
        
        
        case .creatingPersona:
            writeInt(&buf, Int32(3))
        
        
        case .creatingPersonas:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizationPurpose_lift(_ buf: RustBuffer) throws -> AuthorizationPurpose {
    return try FfiConverterTypeAuthorizationPurpose.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizationPurpose_lower(_ value: AuthorizationPurpose) -> RustBuffer {
    return FfiConverterTypeAuthorizationPurpose.lower(value)
}


extension AuthorizationPurpose: Sendable {} 
extension AuthorizationPurpose: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AuthorizationResponse {
    
    /**
     * The user authorized the request
     */
    case authorized
    /**
     * The user rejected the request
     */
    case rejected
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthorizationResponse: FfiConverterRustBuffer {
    typealias SwiftType = AuthorizationResponse

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizationResponse {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .authorized
        
        case 2: return .rejected
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthorizationResponse, into buf: inout [UInt8]) {
        switch value {
        
        
        case .authorized:
            writeInt(&buf, Int32(1))
        
        
        case .rejected:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizationResponse_lift(_ buf: RustBuffer) throws -> AuthorizationResponse {
    return try FfiConverterTypeAuthorizationResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizationResponse_lower(_ value: AuthorizationResponse) -> RustBuffer {
    return FfiConverterTypeAuthorizationResponse.lower(value)
}


extension AuthorizationResponse: Sendable {} 
extension AuthorizationResponse: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Indicates whether the Wallet should show direct deposit claims for the given Dapp.
 */

public enum AuthorizedDappPreferenceDeposits {
    
    case hidden
    case visible
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthorizedDappPreferenceDeposits: FfiConverterRustBuffer {
    typealias SwiftType = AuthorizedDappPreferenceDeposits

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappPreferenceDeposits {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hidden
        
        case 2: return .visible
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthorizedDappPreferenceDeposits, into buf: inout [UInt8]) {
        switch value {
        
        
        case .hidden:
            writeInt(&buf, Int32(1))
        
        
        case .visible:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizedDappPreferenceDeposits_lift(_ buf: RustBuffer) throws -> AuthorizedDappPreferenceDeposits {
    return try FfiConverterTypeAuthorizedDappPreferenceDeposits.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthorizedDappPreferenceDeposits_lower(_ value: AuthorizedDappPreferenceDeposits) -> RustBuffer {
    return FfiConverterTypeAuthorizedDappPreferenceDeposits.lower(value)
}


extension AuthorizedDappPreferenceDeposits: Sendable {} 
extension AuthorizedDappPreferenceDeposits: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * BIP39 entropy, ranging from 16-32 bytes with discrete values being multiples of in between the range.
 */

public enum Bip39Entropy {
    
    case entropyOf16Bytes(Entropy16Bytes
    )
    case entropyOf20Bytes(Entropy20Bytes
    )
    case entropyOf24Bytes(Entropy24Bytes
    )
    case entropyOf28Bytes(Entropy28Bytes
    )
    case entropyOf32Bytes(Entropy32Bytes
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBIP39Entropy: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Entropy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Entropy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .entropyOf16Bytes(try FfiConverterTypeEntropy16Bytes.read(from: &buf)
        )
        
        case 2: return .entropyOf20Bytes(try FfiConverterTypeEntropy20Bytes.read(from: &buf)
        )
        
        case 3: return .entropyOf24Bytes(try FfiConverterTypeEntropy24Bytes.read(from: &buf)
        )
        
        case 4: return .entropyOf28Bytes(try FfiConverterTypeEntropy28Bytes.read(from: &buf)
        )
        
        case 5: return .entropyOf32Bytes(try FfiConverterTypeEntropy32Bytes.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Entropy, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .entropyOf16Bytes(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEntropy16Bytes.write(v1, into: &buf)
            
        
        case let .entropyOf20Bytes(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEntropy20Bytes.write(v1, into: &buf)
            
        
        case let .entropyOf24Bytes(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEntropy24Bytes.write(v1, into: &buf)
            
        
        case let .entropyOf28Bytes(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeEntropy28Bytes.write(v1, into: &buf)
            
        
        case let .entropyOf32Bytes(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEntropy32Bytes.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP39Entropy_lift(_ buf: RustBuffer) throws -> Bip39Entropy {
    return try FfiConverterTypeBIP39Entropy.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP39Entropy_lower(_ value: Bip39Entropy) -> RustBuffer {
    return FfiConverterTypeBIP39Entropy.lower(value)
}


extension Bip39Entropy: Sendable {} 
extension Bip39Entropy: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Language to be used for the mnemonic phrase.
 *
 * The English language is always available, other languages are enabled using
 * the compilation features.
 */

public enum Bip39Language {
    
    /**
     * The English language.
     */
    case english
    /**
     * The French language.
     */
    case french
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBIP39Language: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Language

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Language {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .english
        
        case 2: return .french
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Language, into buf: inout [UInt8]) {
        switch value {
        
        
        case .english:
            writeInt(&buf, Int32(1))
        
        
        case .french:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP39Language_lift(_ buf: RustBuffer) throws -> Bip39Language {
    return try FfiConverterTypeBIP39Language.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP39Language_lower(_ value: Bip39Language) -> RustBuffer {
    return FfiConverterTypeBIP39Language.lower(value)
}


extension Bip39Language: Sendable {} 
extension Bip39Language: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
 * standard, a multiple of 3, from 12 to 24 words. All "Babylon" `DeviceFactorSource`s
 * use 24 words.
 */

public enum Bip39WordCount : UInt8 {
    
    /**
     * 24 words, used by all "Babylon" `DeviceFactorSource`s
     */
    case twentyFour = 24
    /**
     * 21 words, potentially used by third-party Olympia wallets.
     */
    case twentyOne = 21
    /**
     * 18 words, potentially used by third-party Olympia wallets.
     */
    case eighteen = 18
    /**
     * 15 words, potentially used by third-party Olympia wallets.
     */
    case fifteen = 15
    /**
     * 12 words, used by Radix Olympia legacy wallet.
     */
    case twelve = 12
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBIP39WordCount: FfiConverterRustBuffer {
    typealias SwiftType = Bip39WordCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39WordCount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .twentyFour
        
        case 2: return .twentyOne
        
        case 3: return .eighteen
        
        case 4: return .fifteen
        
        case 5: return .twelve
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39WordCount, into buf: inout [UInt8]) {
        switch value {
        
        
        case .twentyFour:
            writeInt(&buf, Int32(1))
        
        
        case .twentyOne:
            writeInt(&buf, Int32(2))
        
        
        case .eighteen:
            writeInt(&buf, Int32(3))
        
        
        case .fifteen:
            writeInt(&buf, Int32(4))
        
        
        case .twelve:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP39WordCount_lift(_ buf: RustBuffer) throws -> Bip39WordCount {
    return try FfiConverterTypeBIP39WordCount.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP39WordCount_lower(_ value: Bip39WordCount) -> RustBuffer {
    return FfiConverterTypeBIP39WordCount.lower(value)
}


extension Bip39WordCount: Sendable {} 
extension Bip39WordCount: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Account or Identity (used by Personas) part of a CAP26 derivation
 * path.
 */

public enum Cap26EntityKind {
    
    /**
     * An Account entity type
     */
    case account
    /**
     * An Identity entity type (used by Personas)
     */
    case identity
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCAP26EntityKind: FfiConverterRustBuffer {
    typealias SwiftType = Cap26EntityKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26EntityKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account
        
        case 2: return .identity
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26EntityKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .account:
            writeInt(&buf, Int32(1))
        
        
        case .identity:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCAP26EntityKind_lift(_ buf: RustBuffer) throws -> Cap26EntityKind {
    return try FfiConverterTypeCAP26EntityKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCAP26EntityKind_lower(_ value: Cap26EntityKind) -> RustBuffer {
    return FfiConverterTypeCAP26EntityKind.lower(value)
}


extension Cap26EntityKind: Sendable {} 
extension Cap26EntityKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Cap26KeyKind {
    
    /**
     * For a key to be used for signing transactions.
     * The value is the ascii sum of `"TRANSACTION_SIGNING"`
     */
    case transactionSigning
    /**
     * For a key to be used for signing authentication..
     * The value is the ascii sum of `"AUTHENTICATION_SIGNING"`
     */
    case authenticationSigning
    /**
     * For a key to be used for encrypting messages.
     * The value is the ascii sum of `"MESSAGE_ENCRYPTION"`
     */
    case messageEncryption
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCAP26KeyKind: FfiConverterRustBuffer {
    typealias SwiftType = Cap26KeyKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26KeyKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .transactionSigning
        
        case 2: return .authenticationSigning
        
        case 3: return .messageEncryption
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26KeyKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .transactionSigning:
            writeInt(&buf, Int32(1))
        
        
        case .authenticationSigning:
            writeInt(&buf, Int32(2))
        
        
        case .messageEncryption:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCAP26KeyKind_lift(_ buf: RustBuffer) throws -> Cap26KeyKind {
    return try FfiConverterTypeCAP26KeyKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCAP26KeyKind_lower(_ value: Cap26KeyKind) -> RustBuffer {
    return FfiConverterTypeCAP26KeyKind.lower(value)
}


extension Cap26KeyKind: Sendable {} 
extension Cap26KeyKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ChangeGatewayOutcome {
    
    /**
     * If we did in fact change the gateway, and if the gateway was unknown
     * or known before it was added, i.e. `is_new` will be true iff the gateway
     * was unknown before changing to it.
     */
    case didChange(
        /**
         * If the Gateway we just switched to already was in the `other` list of
         * saved gateways in AppPreferences, or if it was entirely new.
         */isNew: Bool
    )
    /**
     * We tried to change to the current gateway.
     */
    case noChange
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChangeGatewayOutcome: FfiConverterRustBuffer {
    typealias SwiftType = ChangeGatewayOutcome

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChangeGatewayOutcome {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .didChange(isNew: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .noChange
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChangeGatewayOutcome, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .didChange(isNew):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(isNew, into: &buf)
            
        
        case .noChange:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeGatewayOutcome_lift(_ buf: RustBuffer) throws -> ChangeGatewayOutcome {
    return try FfiConverterTypeChangeGatewayOutcome.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeGatewayOutcome_lower(_ value: ChangeGatewayOutcome) -> RustBuffer {
    return FfiConverterTypeChangeGatewayOutcome.lower(value)
}


extension ChangeGatewayOutcome: Sendable {} 
extension ChangeGatewayOutcome: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Created by the visitor, generally references a particular instruction,
 * or maybe an initial YIELD_TO_PARENT.
 */

public enum ChangeSource {
    
    case initialYieldFromParent
    case invocation(instructionIndex: UInt64
    )
    case newBucket(instructionIndex: UInt64
    )
    case assertion(instructionIndex: UInt64
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeChangeSource: FfiConverterRustBuffer {
    typealias SwiftType = ChangeSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChangeSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initialYieldFromParent
        
        case 2: return .invocation(instructionIndex: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .newBucket(instructionIndex: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 4: return .assertion(instructionIndex: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChangeSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initialYieldFromParent:
            writeInt(&buf, Int32(1))
        
        
        case let .invocation(instructionIndex):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(instructionIndex, into: &buf)
            
        
        case let .newBucket(instructionIndex):
            writeInt(&buf, Int32(3))
            FfiConverterUInt64.write(instructionIndex, into: &buf)
            
        
        case let .assertion(instructionIndex):
            writeInt(&buf, Int32(4))
            FfiConverterUInt64.write(instructionIndex, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeSource_lift(_ buf: RustBuffer) throws -> ChangeSource {
    return try FfiConverterTypeChangeSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeSource_lower(_ value: ChangeSource) -> RustBuffer {
    return FfiConverterTypeChangeSource.lower(value)
}


extension ChangeSource: Sendable {} 
extension ChangeSource: Equatable, Hashable {}




public enum CommonError {

    
    
    case ErasedError(internalErrorCode: UInt32, errorMessage: String
    )
    case SecureStorageAccessError(key: String, errorKind: SecureStorageAccessErrorKind, errorMessage: String
    )
    case InvalidIso8601String(badValue: String
    )
    case HostInteractionAborted
    case WrongEntityKind(expected: String, found: String
    )
    case NetworkRequestGenericFailure(underlying: String
    )
    case InvalidUrl(badValue: String
    )
    case UnknownNetworkForId(badValue: UInt8
    )
    case FailedToDeserializeJsonToValue(jsonByteCount: UInt64, typeName: String, serdeMessage: String
    )
    case InvalidSecp256k1PublicKeyPointNotOnCurve
    case InvalidBip39WordCount(badValue: UInt64
    )
    case Unknown
    case FileAlreadyExists(path: String
    )
    case SecureStorageReadError
    case SecureStorageWriteError
    case UnsafeStorageReadError
    case UnsafeStorageWriteError
    case FailedToDecodeAddressFromBech32(badValue: String
    )
    case InvalidAppearanceId(badValue: UInt8
    )
    case DecimalError
    case InvalidByteCount(expected: UInt64, found: UInt64
    )
    case IndexNotHardened(badValue: UInt32
    )
    case UnknownNetworkId(badValue: UInt8
    )
    case TooManyBytes(max: UInt64, found: UInt64
    )
    case BytesEmpty
    case FactorOutcomeSignedFactorSourceIdMismatch
    case UnknownAccount
    case NotPermissionToAccessFile(path: String
    )
    case ReservedInstructionsNotAllowedInManifest(reservedInstructions: String
    )
    case OneOfReceivingAccountsDoesNotAllowDeposits
    case FailedTransactionPreview(errorMessage: String
    )
    case FailedToExtractTransactionReceiptBytes
    case NfcSessionCancelled
    case NfcSessionLostTagConnection
    case NfcSessionUnknownTag
    case MaxTransfersPerTransactionReached(amount: UInt64
    )
    case UnknownNetworkWithName(badValue: String
    )
    case InvalidEd25519PublicKeyFromBytes(badValue: String
    )
    case InvalidSecp256k1PublicKeyFromBytes(badValue: String
    )
    case SigningFailedTooManyFactorSourcesNeglected
    case GatewaySubmitDuplicateTx(intentHash: String
    )
    case UnableToLoadMnemonicFromSecureStorage(badValue: String
    )
    case ExecutionSummaryFail(underlying: String
    )
    case FailedToGenerateManifestSummary(underlying: String
    )
    case InvalidInstructionsString(underlying: String
    )
    case AddressInvalidEntityType(addressKind: String, entityType: UInt8, nodeIdAsHex: String
    )
    case FailedToFindNetworkIdFromBech32mString(bech32mEncodedAddress: String
    )
    case InvalidMnemonicWords(indicesInMnemonic: Data
    )
    case MissingNftDataField(field: String
    )
    case UnexpectedNftDataFormat
    case RnsInvalidDomain
    case RnsUnauthenticDomain(reason: String
    )
    case RnsInvalidDomainConfiguration(reason: String
    )
    case RnsUnsupportedNetwork(network: UInt8
    )
    case RnsInvalidRecordContext(context: String
    )
    case GwMissingResponseItem(item: String
    )
    case ArculusCardWrongPin(numberOfRemainingTries: Int8
    )
    case WrongArculusCard
    case NfcSessionRenewed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCommonError: FfiConverterRustBuffer {
    typealias SwiftType = CommonError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CommonError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ErasedError(
            internalErrorCode: try FfiConverterUInt32.read(from: &buf), 
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 2: return .SecureStorageAccessError(
            key: try FfiConverterString.read(from: &buf), 
            errorKind: try FfiConverterTypeSecureStorageAccessErrorKind.read(from: &buf), 
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidIso8601String(
            badValue: try FfiConverterString.read(from: &buf)
            )
        case 4: return .HostInteractionAborted
        case 5: return .WrongEntityKind(
            expected: try FfiConverterString.read(from: &buf), 
            found: try FfiConverterString.read(from: &buf)
            )
        case 6: return .NetworkRequestGenericFailure(
            underlying: try FfiConverterString.read(from: &buf)
            )
        case 7: return .InvalidUrl(
            badValue: try FfiConverterString.read(from: &buf)
            )
        case 8: return .UnknownNetworkForId(
            badValue: try FfiConverterUInt8.read(from: &buf)
            )
        case 9: return .FailedToDeserializeJsonToValue(
            jsonByteCount: try FfiConverterUInt64.read(from: &buf), 
            typeName: try FfiConverterString.read(from: &buf), 
            serdeMessage: try FfiConverterString.read(from: &buf)
            )
        case 10: return .InvalidSecp256k1PublicKeyPointNotOnCurve
        case 11: return .InvalidBip39WordCount(
            badValue: try FfiConverterUInt64.read(from: &buf)
            )
        case 12: return .Unknown
        case 13: return .FileAlreadyExists(
            path: try FfiConverterString.read(from: &buf)
            )
        case 14: return .SecureStorageReadError
        case 15: return .SecureStorageWriteError
        case 16: return .UnsafeStorageReadError
        case 17: return .UnsafeStorageWriteError
        case 18: return .FailedToDecodeAddressFromBech32(
            badValue: try FfiConverterString.read(from: &buf)
            )
        case 19: return .InvalidAppearanceId(
            badValue: try FfiConverterUInt8.read(from: &buf)
            )
        case 20: return .DecimalError
        case 21: return .InvalidByteCount(
            expected: try FfiConverterUInt64.read(from: &buf), 
            found: try FfiConverterUInt64.read(from: &buf)
            )
        case 22: return .IndexNotHardened(
            badValue: try FfiConverterUInt32.read(from: &buf)
            )
        case 23: return .UnknownNetworkId(
            badValue: try FfiConverterUInt8.read(from: &buf)
            )
        case 24: return .TooManyBytes(
            max: try FfiConverterUInt64.read(from: &buf), 
            found: try FfiConverterUInt64.read(from: &buf)
            )
        case 25: return .BytesEmpty
        case 26: return .FactorOutcomeSignedFactorSourceIdMismatch
        case 27: return .UnknownAccount
        case 28: return .NotPermissionToAccessFile(
            path: try FfiConverterString.read(from: &buf)
            )
        case 29: return .ReservedInstructionsNotAllowedInManifest(
            reservedInstructions: try FfiConverterString.read(from: &buf)
            )
        case 30: return .OneOfReceivingAccountsDoesNotAllowDeposits
        case 31: return .FailedTransactionPreview(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 32: return .FailedToExtractTransactionReceiptBytes
        case 33: return .NfcSessionCancelled
        case 34: return .NfcSessionLostTagConnection
        case 35: return .NfcSessionUnknownTag
        case 36: return .MaxTransfersPerTransactionReached(
            amount: try FfiConverterUInt64.read(from: &buf)
            )
        case 37: return .UnknownNetworkWithName(
            badValue: try FfiConverterString.read(from: &buf)
            )
        case 38: return .InvalidEd25519PublicKeyFromBytes(
            badValue: try FfiConverterString.read(from: &buf)
            )
        case 39: return .InvalidSecp256k1PublicKeyFromBytes(
            badValue: try FfiConverterString.read(from: &buf)
            )
        case 40: return .SigningFailedTooManyFactorSourcesNeglected
        case 41: return .GatewaySubmitDuplicateTx(
            intentHash: try FfiConverterString.read(from: &buf)
            )
        case 42: return .UnableToLoadMnemonicFromSecureStorage(
            badValue: try FfiConverterString.read(from: &buf)
            )
        case 43: return .ExecutionSummaryFail(
            underlying: try FfiConverterString.read(from: &buf)
            )
        case 44: return .FailedToGenerateManifestSummary(
            underlying: try FfiConverterString.read(from: &buf)
            )
        case 45: return .InvalidInstructionsString(
            underlying: try FfiConverterString.read(from: &buf)
            )
        case 46: return .AddressInvalidEntityType(
            addressKind: try FfiConverterString.read(from: &buf), 
            entityType: try FfiConverterUInt8.read(from: &buf), 
            nodeIdAsHex: try FfiConverterString.read(from: &buf)
            )
        case 47: return .FailedToFindNetworkIdFromBech32mString(
            bech32mEncodedAddress: try FfiConverterString.read(from: &buf)
            )
        case 48: return .InvalidMnemonicWords(
            indicesInMnemonic: try FfiConverterData.read(from: &buf)
            )
        case 49: return .MissingNftDataField(
            field: try FfiConverterString.read(from: &buf)
            )
        case 50: return .UnexpectedNftDataFormat
        case 51: return .RnsInvalidDomain
        case 52: return .RnsUnauthenticDomain(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 53: return .RnsInvalidDomainConfiguration(
            reason: try FfiConverterString.read(from: &buf)
            )
        case 54: return .RnsUnsupportedNetwork(
            network: try FfiConverterUInt8.read(from: &buf)
            )
        case 55: return .RnsInvalidRecordContext(
            context: try FfiConverterString.read(from: &buf)
            )
        case 56: return .GwMissingResponseItem(
            item: try FfiConverterString.read(from: &buf)
            )
        case 57: return .ArculusCardWrongPin(
            numberOfRemainingTries: try FfiConverterInt8.read(from: &buf)
            )
        case 58: return .WrongArculusCard
        case 59: return .NfcSessionRenewed

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CommonError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ErasedError(internalErrorCode,errorMessage):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(internalErrorCode, into: &buf)
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .SecureStorageAccessError(key,errorKind,errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeSecureStorageAccessErrorKind.write(errorKind, into: &buf)
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .InvalidIso8601String(badValue):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(badValue, into: &buf)
            
        
        case .HostInteractionAborted:
            writeInt(&buf, Int32(4))
        
        
        case let .WrongEntityKind(expected,found):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(expected, into: &buf)
            FfiConverterString.write(found, into: &buf)
            
        
        case let .NetworkRequestGenericFailure(underlying):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(underlying, into: &buf)
            
        
        case let .InvalidUrl(badValue):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(badValue, into: &buf)
            
        
        case let .UnknownNetworkForId(badValue):
            writeInt(&buf, Int32(8))
            FfiConverterUInt8.write(badValue, into: &buf)
            
        
        case let .FailedToDeserializeJsonToValue(jsonByteCount,typeName,serdeMessage):
            writeInt(&buf, Int32(9))
            FfiConverterUInt64.write(jsonByteCount, into: &buf)
            FfiConverterString.write(typeName, into: &buf)
            FfiConverterString.write(serdeMessage, into: &buf)
            
        
        case .InvalidSecp256k1PublicKeyPointNotOnCurve:
            writeInt(&buf, Int32(10))
        
        
        case let .InvalidBip39WordCount(badValue):
            writeInt(&buf, Int32(11))
            FfiConverterUInt64.write(badValue, into: &buf)
            
        
        case .Unknown:
            writeInt(&buf, Int32(12))
        
        
        case let .FileAlreadyExists(path):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(path, into: &buf)
            
        
        case .SecureStorageReadError:
            writeInt(&buf, Int32(14))
        
        
        case .SecureStorageWriteError:
            writeInt(&buf, Int32(15))
        
        
        case .UnsafeStorageReadError:
            writeInt(&buf, Int32(16))
        
        
        case .UnsafeStorageWriteError:
            writeInt(&buf, Int32(17))
        
        
        case let .FailedToDecodeAddressFromBech32(badValue):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(badValue, into: &buf)
            
        
        case let .InvalidAppearanceId(badValue):
            writeInt(&buf, Int32(19))
            FfiConverterUInt8.write(badValue, into: &buf)
            
        
        case .DecimalError:
            writeInt(&buf, Int32(20))
        
        
        case let .InvalidByteCount(expected,found):
            writeInt(&buf, Int32(21))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)
            
        
        case let .IndexNotHardened(badValue):
            writeInt(&buf, Int32(22))
            FfiConverterUInt32.write(badValue, into: &buf)
            
        
        case let .UnknownNetworkId(badValue):
            writeInt(&buf, Int32(23))
            FfiConverterUInt8.write(badValue, into: &buf)
            
        
        case let .TooManyBytes(max,found):
            writeInt(&buf, Int32(24))
            FfiConverterUInt64.write(max, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)
            
        
        case .BytesEmpty:
            writeInt(&buf, Int32(25))
        
        
        case .FactorOutcomeSignedFactorSourceIdMismatch:
            writeInt(&buf, Int32(26))
        
        
        case .UnknownAccount:
            writeInt(&buf, Int32(27))
        
        
        case let .NotPermissionToAccessFile(path):
            writeInt(&buf, Int32(28))
            FfiConverterString.write(path, into: &buf)
            
        
        case let .ReservedInstructionsNotAllowedInManifest(reservedInstructions):
            writeInt(&buf, Int32(29))
            FfiConverterString.write(reservedInstructions, into: &buf)
            
        
        case .OneOfReceivingAccountsDoesNotAllowDeposits:
            writeInt(&buf, Int32(30))
        
        
        case let .FailedTransactionPreview(errorMessage):
            writeInt(&buf, Int32(31))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case .FailedToExtractTransactionReceiptBytes:
            writeInt(&buf, Int32(32))
        
        
        case .NfcSessionCancelled:
            writeInt(&buf, Int32(33))
        
        
        case .NfcSessionLostTagConnection:
            writeInt(&buf, Int32(34))
        
        
        case .NfcSessionUnknownTag:
            writeInt(&buf, Int32(35))
        
        
        case let .MaxTransfersPerTransactionReached(amount):
            writeInt(&buf, Int32(36))
            FfiConverterUInt64.write(amount, into: &buf)
            
        
        case let .UnknownNetworkWithName(badValue):
            writeInt(&buf, Int32(37))
            FfiConverterString.write(badValue, into: &buf)
            
        
        case let .InvalidEd25519PublicKeyFromBytes(badValue):
            writeInt(&buf, Int32(38))
            FfiConverterString.write(badValue, into: &buf)
            
        
        case let .InvalidSecp256k1PublicKeyFromBytes(badValue):
            writeInt(&buf, Int32(39))
            FfiConverterString.write(badValue, into: &buf)
            
        
        case .SigningFailedTooManyFactorSourcesNeglected:
            writeInt(&buf, Int32(40))
        
        
        case let .GatewaySubmitDuplicateTx(intentHash):
            writeInt(&buf, Int32(41))
            FfiConverterString.write(intentHash, into: &buf)
            
        
        case let .UnableToLoadMnemonicFromSecureStorage(badValue):
            writeInt(&buf, Int32(42))
            FfiConverterString.write(badValue, into: &buf)
            
        
        case let .ExecutionSummaryFail(underlying):
            writeInt(&buf, Int32(43))
            FfiConverterString.write(underlying, into: &buf)
            
        
        case let .FailedToGenerateManifestSummary(underlying):
            writeInt(&buf, Int32(44))
            FfiConverterString.write(underlying, into: &buf)
            
        
        case let .InvalidInstructionsString(underlying):
            writeInt(&buf, Int32(45))
            FfiConverterString.write(underlying, into: &buf)
            
        
        case let .AddressInvalidEntityType(addressKind,entityType,nodeIdAsHex):
            writeInt(&buf, Int32(46))
            FfiConverterString.write(addressKind, into: &buf)
            FfiConverterUInt8.write(entityType, into: &buf)
            FfiConverterString.write(nodeIdAsHex, into: &buf)
            
        
        case let .FailedToFindNetworkIdFromBech32mString(bech32mEncodedAddress):
            writeInt(&buf, Int32(47))
            FfiConverterString.write(bech32mEncodedAddress, into: &buf)
            
        
        case let .InvalidMnemonicWords(indicesInMnemonic):
            writeInt(&buf, Int32(48))
            FfiConverterData.write(indicesInMnemonic, into: &buf)
            
        
        case let .MissingNftDataField(field):
            writeInt(&buf, Int32(49))
            FfiConverterString.write(field, into: &buf)
            
        
        case .UnexpectedNftDataFormat:
            writeInt(&buf, Int32(50))
        
        
        case .RnsInvalidDomain:
            writeInt(&buf, Int32(51))
        
        
        case let .RnsUnauthenticDomain(reason):
            writeInt(&buf, Int32(52))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .RnsInvalidDomainConfiguration(reason):
            writeInt(&buf, Int32(53))
            FfiConverterString.write(reason, into: &buf)
            
        
        case let .RnsUnsupportedNetwork(network):
            writeInt(&buf, Int32(54))
            FfiConverterUInt8.write(network, into: &buf)
            
        
        case let .RnsInvalidRecordContext(context):
            writeInt(&buf, Int32(55))
            FfiConverterString.write(context, into: &buf)
            
        
        case let .GwMissingResponseItem(item):
            writeInt(&buf, Int32(56))
            FfiConverterString.write(item, into: &buf)
            
        
        case let .ArculusCardWrongPin(numberOfRemainingTries):
            writeInt(&buf, Int32(57))
            FfiConverterInt8.write(numberOfRemainingTries, into: &buf)
            
        
        case .WrongArculusCard:
            writeInt(&buf, Int32(58))
        
        
        case .NfcSessionRenewed:
            writeInt(&buf, Int32(59))
        
        }
    }
}


extension CommonError: Equatable, Hashable {}



extension CommonError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappToWalletInteractionAuthRequestItem {
    
    case loginWithChallenge(DappToWalletInteractionAuthLoginWithChallengeRequestItem
    )
    case loginWithoutChallenge
    case usePersona(DappToWalletInteractionAuthUsePersonaRequestItem
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionAuthRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionAuthRequestItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthRequestItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .loginWithChallenge(try FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.read(from: &buf)
        )
        
        case 2: return .loginWithoutChallenge
        
        case 3: return .usePersona(try FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappToWalletInteractionAuthRequestItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .loginWithChallenge(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.write(v1, into: &buf)
            
        
        case .loginWithoutChallenge:
            writeInt(&buf, Int32(2))
        
        
        case let .usePersona(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionAuthRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAuthRequestItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionAuthRequestItem_lower(_ value: DappToWalletInteractionAuthRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthRequestItem.lower(value)
}


extension DappToWalletInteractionAuthRequestItem: Sendable {} 
extension DappToWalletInteractionAuthRequestItem: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappToWalletInteractionItems {
    
    case unauthorizedRequest(DappToWalletInteractionUnauthorizedRequestItems
    )
    case authorizedRequest(DappToWalletInteractionAuthorizedRequestItems
    )
    case transaction(DappToWalletInteractionTransactionItems
    )
    case batchOfTransactions(DappToWalletInteractionBatchOfTransactions
    )
    case preAuthorization(DappToWalletInteractionPreAuthorizationItems
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionItems: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionItems

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionItems {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unauthorizedRequest(try FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.read(from: &buf)
        )
        
        case 2: return .authorizedRequest(try FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.read(from: &buf)
        )
        
        case 3: return .transaction(try FfiConverterTypeDappToWalletInteractionTransactionItems.read(from: &buf)
        )
        
        case 4: return .batchOfTransactions(try FfiConverterTypeDappToWalletInteractionBatchOfTransactions.read(from: &buf)
        )
        
        case 5: return .preAuthorization(try FfiConverterTypeDappToWalletInteractionPreAuthorizationItems.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappToWalletInteractionItems, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .unauthorizedRequest(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.write(v1, into: &buf)
            
        
        case let .authorizedRequest(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.write(v1, into: &buf)
            
        
        case let .transaction(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDappToWalletInteractionTransactionItems.write(v1, into: &buf)
            
        
        case let .batchOfTransactions(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeDappToWalletInteractionBatchOfTransactions.write(v1, into: &buf)
            
        
        case let .preAuthorization(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeDappToWalletInteractionPreAuthorizationItems.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionItems {
    return try FfiConverterTypeDappToWalletInteractionItems.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionItems_lower(_ value: DappToWalletInteractionItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionItems.lower(value)
}


extension DappToWalletInteractionItems: Sendable {} 
extension DappToWalletInteractionItems: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum that represents the different ways a subintent can expire.
 */

public enum DappToWalletInteractionSubintentExpiration {
    
    /**
     * The subintent expires at a specific fixed timestamp.
     *
     * For example, a dApp sends a subintent for `User A` to approve sending 100 XRD before 5:00 PM,
     * and a subintent for `User B` to approve sending 2 USDT with same expiration.
     *
     * If both users sign their subintents before 5:00 PM, the transaction to exchange
     * 100 XRD over 2 USDT will succeed. Otherwise, it would fail.
     */
    case atTime(DappToWalletInteractionSubintentExpireAtTime
    )
    /**
     * The subintent expires X seconds after its signature.
     *
     * For example, a dApp sends a subintent for `User A` to approve sending 100 XRD with 1 hour expiration,
     * and a subintent for `User B` to approve sending 2 USDT with same expiration.
     *
     * If both users sign their subintents within one hour from each other, the transaction to exchange
     * 100 XRD over 2 USDT will succeed. Otherwise, it would fail.
     */
    case afterDelay(DappToWalletInteractionSubintentExpireAfterDelay
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionSubintentExpiration: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionSubintentExpiration

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentExpiration {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .atTime(try FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime.read(from: &buf)
        )
        
        case 2: return .afterDelay(try FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappToWalletInteractionSubintentExpiration, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .atTime(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime.write(v1, into: &buf)
            
        
        case let .afterDelay(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionSubintentExpiration_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentExpiration {
    return try FfiConverterTypeDappToWalletInteractionSubintentExpiration.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionSubintentExpiration_lower(_ value: DappToWalletInteractionSubintentExpiration) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSubintentExpiration.lower(value)
}


extension DappToWalletInteractionSubintentExpiration: Sendable {} 
extension DappToWalletInteractionSubintentExpiration: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum that represents the expiration status of a subintent at a given time.
 *
 * Useful for determining if a subintent is still valid at the moment the Host apps
 * receive the corresponding request.
 */

public enum DappToWalletInteractionSubintentExpirationStatus {
    
    /**
     * The subintent hasn't expired yet
     */
    case valid
    /**
     * The subintent is too close to its expiration. Although it hasn't expired yet, the Host apps
     * shouldn't allow the user dealing with it.
     */
    case expirationTooClose
    /**
     * The subintent has already expired.
     */
    case expired
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionSubintentExpirationStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentExpirationStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .valid
        
        case 2: return .expirationTooClose
        
        case 3: return .expired
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappToWalletInteractionSubintentExpirationStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .valid:
            writeInt(&buf, Int32(1))
        
        
        case .expirationTooClose:
            writeInt(&buf, Int32(2))
        
        
        case .expired:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentExpirationStatus {
    return try FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus_lower(_ value: DappToWalletInteractionSubintentExpirationStatus) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus.lower(value)
}


extension DappToWalletInteractionSubintentExpirationStatus: Sendable {} 
extension DappToWalletInteractionSubintentExpirationStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappWalletInteractionErrorType {
    
    case rejectedByUser
    case wrongNetwork
    case failedToPrepareTransaction
    case failedToCompileTransaction
    case failedToSignTransaction
    case failedToSubmitTransaction
    case failedToPollSubmittedTransaction
    case failedToFindAccountWithEnoughFundsToLockFee
    case submittedTransactionWasDuplicate
    case submittedTransactionHasFailedTransactionStatus
    case submittedTransactionHasRejectedTransactionStatus
    case wrongAccountType
    case unknownWebsite
    case invalidOriginUrl
    case radixJsonNotFound
    case radixJsonUnknownFileFormat
    case unknownDappDefinitionAddress
    case invalidPersona
    case invalidRequest
    case incompatibleVersion
    case failedToSignAuthChallenge
    case invalidPersonaOrAccounts
    case expiredSubintent
    case subintentExpirationTooClose
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappWalletInteractionErrorType: FfiConverterRustBuffer {
    typealias SwiftType = DappWalletInteractionErrorType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappWalletInteractionErrorType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .rejectedByUser
        
        case 2: return .wrongNetwork
        
        case 3: return .failedToPrepareTransaction
        
        case 4: return .failedToCompileTransaction
        
        case 5: return .failedToSignTransaction
        
        case 6: return .failedToSubmitTransaction
        
        case 7: return .failedToPollSubmittedTransaction
        
        case 8: return .failedToFindAccountWithEnoughFundsToLockFee
        
        case 9: return .submittedTransactionWasDuplicate
        
        case 10: return .submittedTransactionHasFailedTransactionStatus
        
        case 11: return .submittedTransactionHasRejectedTransactionStatus
        
        case 12: return .wrongAccountType
        
        case 13: return .unknownWebsite
        
        case 14: return .invalidOriginUrl
        
        case 15: return .radixJsonNotFound
        
        case 16: return .radixJsonUnknownFileFormat
        
        case 17: return .unknownDappDefinitionAddress
        
        case 18: return .invalidPersona
        
        case 19: return .invalidRequest
        
        case 20: return .incompatibleVersion
        
        case 21: return .failedToSignAuthChallenge
        
        case 22: return .invalidPersonaOrAccounts
        
        case 23: return .expiredSubintent
        
        case 24: return .subintentExpirationTooClose
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappWalletInteractionErrorType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .rejectedByUser:
            writeInt(&buf, Int32(1))
        
        
        case .wrongNetwork:
            writeInt(&buf, Int32(2))
        
        
        case .failedToPrepareTransaction:
            writeInt(&buf, Int32(3))
        
        
        case .failedToCompileTransaction:
            writeInt(&buf, Int32(4))
        
        
        case .failedToSignTransaction:
            writeInt(&buf, Int32(5))
        
        
        case .failedToSubmitTransaction:
            writeInt(&buf, Int32(6))
        
        
        case .failedToPollSubmittedTransaction:
            writeInt(&buf, Int32(7))
        
        
        case .failedToFindAccountWithEnoughFundsToLockFee:
            writeInt(&buf, Int32(8))
        
        
        case .submittedTransactionWasDuplicate:
            writeInt(&buf, Int32(9))
        
        
        case .submittedTransactionHasFailedTransactionStatus:
            writeInt(&buf, Int32(10))
        
        
        case .submittedTransactionHasRejectedTransactionStatus:
            writeInt(&buf, Int32(11))
        
        
        case .wrongAccountType:
            writeInt(&buf, Int32(12))
        
        
        case .unknownWebsite:
            writeInt(&buf, Int32(13))
        
        
        case .invalidOriginUrl:
            writeInt(&buf, Int32(14))
        
        
        case .radixJsonNotFound:
            writeInt(&buf, Int32(15))
        
        
        case .radixJsonUnknownFileFormat:
            writeInt(&buf, Int32(16))
        
        
        case .unknownDappDefinitionAddress:
            writeInt(&buf, Int32(17))
        
        
        case .invalidPersona:
            writeInt(&buf, Int32(18))
        
        
        case .invalidRequest:
            writeInt(&buf, Int32(19))
        
        
        case .incompatibleVersion:
            writeInt(&buf, Int32(20))
        
        
        case .failedToSignAuthChallenge:
            writeInt(&buf, Int32(21))
        
        
        case .invalidPersonaOrAccounts:
            writeInt(&buf, Int32(22))
        
        
        case .expiredSubintent:
            writeInt(&buf, Int32(23))
        
        
        case .subintentExpirationTooClose:
            writeInt(&buf, Int32(24))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappWalletInteractionErrorType_lift(_ buf: RustBuffer) throws -> DappWalletInteractionErrorType {
    return try FfiConverterTypeDappWalletInteractionErrorType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappWalletInteractionErrorType_lower(_ value: DappWalletInteractionErrorType) -> RustBuffer {
    return FfiConverterTypeDappWalletInteractionErrorType.lower(value)
}


extension DappWalletInteractionErrorType: Sendable {} 
extension DappWalletInteractionErrorType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DependencyInformation {
    
    case version(String
    )
    case tag(String
    )
    case branch(String
    )
    case rev(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDependencyInformation: FfiConverterRustBuffer {
    typealias SwiftType = DependencyInformation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DependencyInformation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .version(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .tag(try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .branch(try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .rev(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DependencyInformation, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .version(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .tag(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .branch(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .rev(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDependencyInformation_lift(_ buf: RustBuffer) throws -> DependencyInformation {
    return try FfiConverterTypeDependencyInformation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDependencyInformation_lower(_ value: DependencyInformation) -> RustBuffer {
    return FfiConverterTypeDependencyInformation.lower(value)
}


extension DependencyInformation: Sendable {} 
extension DependencyInformation: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The exception kind for deposit address
 */

public enum DepositAddressExceptionRule {
    
    /**
     * A resource can always be deposited in to the account by third-parties
     */
    case allow
    /**
     * A resource can never be deposited in to the account by third-parties
     */
    case deny
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDepositAddressExceptionRule: FfiConverterRustBuffer {
    typealias SwiftType = DepositAddressExceptionRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositAddressExceptionRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allow
        
        case 2: return .deny
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositAddressExceptionRule, into buf: inout [UInt8]) {
        switch value {
        
        
        case .allow:
            writeInt(&buf, Int32(1))
        
        
        case .deny:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositAddressExceptionRule_lift(_ buf: RustBuffer) throws -> DepositAddressExceptionRule {
    return try FfiConverterTypeDepositAddressExceptionRule.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositAddressExceptionRule_lower(_ value: DepositAddressExceptionRule) -> RustBuffer {
    return FfiConverterTypeDepositAddressExceptionRule.lower(value)
}


extension DepositAddressExceptionRule: Sendable {} 
extension DepositAddressExceptionRule: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The general deposit rule to apply
 */

public enum DepositRule {
    
    /**
     * The account accepts **all** assets by default, except for exceptions (if any) which might not deposit/be deposited into this account.
     */
    case acceptKnown
    /**
     * The account accepts **known** assets by default, except for exceptions (if any) which might not deposit/be deposited into this account. By known we mean assets this account has received in the past.
     */
    case acceptAll
    /**
     * The account denies **all** assets by default, except for exceptions (if any) which might in fact deposit/be deposited into this account.
     */
    case denyAll
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDepositRule: FfiConverterRustBuffer {
    typealias SwiftType = DepositRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .acceptKnown
        
        case 2: return .acceptAll
        
        case 3: return .denyAll
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositRule, into buf: inout [UInt8]) {
        switch value {
        
        
        case .acceptKnown:
            writeInt(&buf, Int32(1))
        
        
        case .acceptAll:
            writeInt(&buf, Int32(2))
        
        
        case .denyAll:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositRule_lift(_ buf: RustBuffer) throws -> DepositRule {
    return try FfiConverterTypeDepositRule.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDepositRule_lower(_ value: DepositRule) -> RustBuffer {
    return FfiConverterTypeDepositRule.lower(value)
}


extension DepositRule: Sendable {} 
extension DepositRule: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A derivation path on either supported schemes, either Babylon (CAP26) or Olympia (BIP44Like).
 */

public enum DerivationPath {
    
    case account(value: AccountPath
    )
    case identity(value: IdentityPath
    )
    case bip44Like(value: Bip44LikePath
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDerivationPath: FfiConverterRustBuffer {
    typealias SwiftType = DerivationPath

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPath {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(value: try FfiConverterTypeAccountPath.read(from: &buf)
        )
        
        case 2: return .identity(value: try FfiConverterTypeIdentityPath.read(from: &buf)
        )
        
        case 3: return .bip44Like(value: try FfiConverterTypeBIP44LikePath.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivationPath, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountPath.write(value, into: &buf)
            
        
        case let .identity(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeIdentityPath.write(value, into: &buf)
            
        
        case let .bip44Like(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBIP44LikePath.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDerivationPath_lift(_ buf: RustBuffer) throws -> DerivationPath {
    return try FfiConverterTypeDerivationPath.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDerivationPath_lower(_ value: DerivationPath) -> RustBuffer {
    return FfiConverterTypeDerivationPath.lower(value)
}


extension DerivationPath: Sendable {} 
extension DerivationPath: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Which derivation path to used for some particular HD operations
 * such as signing or public key derivation. Radix Babylon introduces
 * a new scheme call Cap26 but we also need to support BIP44-like used
 * by Olympia.
 */

public enum DerivationPathScheme {
    
    /**
     * A BIP32 based derivation path scheme, using SLIP10.
     */
    case cap26
    /**
     * A BIP32 based similar to BIP44, but not strict BIP44 since the
     * last path component is hardened (a mistake made during Olympia),
     * used to support legacy accounts imported from Olympia wallet.
     */
    case bip44Olympia
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDerivationPathScheme: FfiConverterRustBuffer {
    typealias SwiftType = DerivationPathScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPathScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .cap26
        
        case 2: return .bip44Olympia
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivationPathScheme, into buf: inout [UInt8]) {
        switch value {
        
        
        case .cap26:
            writeInt(&buf, Int32(1))
        
        
        case .bip44Olympia:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDerivationPathScheme_lift(_ buf: RustBuffer) throws -> DerivationPathScheme {
    return try FfiConverterTypeDerivationPathScheme.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDerivationPathScheme_lower(_ value: DerivationPathScheme) -> RustBuffer {
    return FfiConverterTypeDerivationPathScheme.lower(value)
}


extension DerivationPathScheme: Sendable {} 
extension DerivationPathScheme: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The purpose that initiated an interaction with the host to derive keys.
 * The orchestrator behind this operation is the `KeysCollector`.
 */

public enum DerivationPurpose {
    
    /**
     * When the create account flow, initiates keys collection
     * for account VECIs
     */
    case creatingNewAccount
    /**
     * When the create persona flow, initiates keys collection
     * for identity VECIs
     */
    case creatingNewPersona
    /**
     * When applying a security shield to an account, initiates keys collection
     * for account MFA
     */
    case securifyingAccount
    /**
     * When applying a security shield to a persona, initiates keys collection
     * for identity MFA
     */
    case securifyingPersona
    /**
     * When applying a security shield to accounts and personas mixed, initiates keys collection
     * for account MFA
     */
    case securifyingAccountsAndPersonas
    /**
     * When adding a new factor source, initiates keys collection
     * for collecting various factor instances.
     */
    case preDerivingKeys
    /**
     * When deriving accounts for recovery
     */
    case accountRecovery
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDerivationPurpose: FfiConverterRustBuffer {
    typealias SwiftType = DerivationPurpose

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPurpose {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .creatingNewAccount
        
        case 2: return .creatingNewPersona
        
        case 3: return .securifyingAccount
        
        case 4: return .securifyingPersona
        
        case 5: return .securifyingAccountsAndPersonas
        
        case 6: return .preDerivingKeys
        
        case 7: return .accountRecovery
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivationPurpose, into buf: inout [UInt8]) {
        switch value {
        
        
        case .creatingNewAccount:
            writeInt(&buf, Int32(1))
        
        
        case .creatingNewPersona:
            writeInt(&buf, Int32(2))
        
        
        case .securifyingAccount:
            writeInt(&buf, Int32(3))
        
        
        case .securifyingPersona:
            writeInt(&buf, Int32(4))
        
        
        case .securifyingAccountsAndPersonas:
            writeInt(&buf, Int32(5))
        
        
        case .preDerivingKeys:
            writeInt(&buf, Int32(6))
        
        
        case .accountRecovery:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDerivationPurpose_lift(_ buf: RustBuffer) throws -> DerivationPurpose {
    return try FfiConverterTypeDerivationPurpose.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDerivationPurpose_lower(_ value: DerivationPurpose) -> RustBuffer {
    return FfiConverterTypeDerivationPurpose.lower(value)
}


extension DerivationPurpose: Sendable {} 
extension DerivationPurpose: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The source of the public keys to derive.
 */

public enum DerivePublicKeysSource {
    
    /**
     * Derive the public keys from a known mnemonic.
     */
    case mnemonic(MnemonicWithPassphrase
    )
    /**
     * Derive the public keys from a factor source added to Profile.
     */
    case factorSource(FactorSourceIdFromHash
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDerivePublicKeysSource: FfiConverterRustBuffer {
    typealias SwiftType = DerivePublicKeysSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivePublicKeysSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mnemonic(try FfiConverterTypeMnemonicWithPassphrase.read(from: &buf)
        )
        
        case 2: return .factorSource(try FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivePublicKeysSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .mnemonic(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMnemonicWithPassphrase.write(v1, into: &buf)
            
        
        case let .factorSource(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFactorSourceIDFromHash.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDerivePublicKeysSource_lift(_ buf: RustBuffer) throws -> DerivePublicKeysSource {
    return try FfiConverterTypeDerivePublicKeysSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDerivePublicKeysSource_lower(_ value: DerivePublicKeysSource) -> RustBuffer {
    return FfiConverterTypeDerivePublicKeysSource.lower(value)
}


extension DerivePublicKeysSource: Sendable {} 
extension DerivePublicKeysSource: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The execution summary process not only determines the class of the manifest,
 * but also includes additional information about this class that the wallet
 * requires to display to the user.
 */

public enum DetailedManifestClass {
    
    /**
     * A general manifest that involves any amount of arbitrary components
     * and packages where nothing more concrete can be said about the manifest
     * and its nature.
     *
     * No additional information is required beyond what the execution summary
     * will provide.
     */
    case general
    /**
     * A manifest of a 1-to-1 transfer to a one-to-many transfer of resources.
     */
    case transfer(
        /**
         * When `true`, then this is a one-to-one transfer and the wallet can
         * regard this as a "simple transfer" and communicate this information
         * to the ledger hardware wallet. Otherwise, if `false`, then this is
         * not a one-to-one transfer.
         */isOneToOneTransfer: Bool
    )
    /**
     * A manifest where XRD is claimed from one or more validators.
     */
    case validatorClaim(
        /**
         * The addresses of validators in the transaction
         */validatorAddresses: [ValidatorAddress], 
        /**
         * The claims observed in the transaction
         */validatorClaims: [TrackedValidatorClaim]
    )
    /**
     * A manifest where XRD is staked to one or more validators.
     */
    case validatorStake(
        /**
         * The addresses of validators in the transaction
         */validatorAddresses: [ValidatorAddress], 
        /**
         * The stake observed in the transaction
         */validatorStakes: [TrackedValidatorStake]
    )
    /**
     * A manifest where XRD is unstaked from one or more validators.
     */
    case validatorUnstake(
        /**
         * The addresses of validators in the transaction
         */validatorAddresses: [ValidatorAddress], 
        /**
         * The data associated with the various claim NFTs
         */claimsNonFungibleData: [NonFungibleGlobalId: UnstakeData]
    )
    /**
     * A manifest that updated the deposit settings of the account.
     */
    case accountDepositSettingsUpdate(
        /**
         * Updates to the resource preferences of the account deposit settings.
         * account_address -> (resource_address -> Update<new_preference>)
         */resourcePreferencesUpdates: [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]], 
        /**
         * Changes to the account's deposit mode.
         * account_address -> new_default_deposit_mode
         */depositModeUpdates: [AccountAddress: DepositRule], 
        /**
         * Additions to the authorized depositors
         */authorizedDepositorsAdded: [AccountAddress: [ResourceOrNonFungible]], 
        /**
         * Removals from the authorized depositors
         */authorizedDepositorsRemoved: [AccountAddress: [ResourceOrNonFungible]]
    )
    /**
     * A manifest that contributed some amount of resources to a liquidity
     * pool that can be a one-resource pool, two-resource pool, or a
     * multi-resource pool.
     */
    case poolContribution(
        /**
         * The addresses of the pools in the transaction
         */poolAddresses: [PoolAddress], 
        /**
         * The contribution observed in the transaction
         */poolContributions: [TrackedPoolContribution]
    )
    /**
     * A manifest that redeemed resources from a liquidity pool. Similar to
     * contributions, this can be any of the three pool blueprints available
     * in the pool package.
     */
    case poolRedemption(
        /**
         * The addresses of the pools in the transaction
         */poolAddresses: [PoolAddress], 
        /**
         * The redemptions observed in the transaction
         */poolRedemptions: [TrackedPoolRedemption]
    )
    /**
     * A manifest that deletes accounts.
     */
    case deleteAccounts(
        /**
         * The addresses of the accounts that are being deleted
         */accountAddresses: [AccountAddress]
    )
    /**
     * A manifest that is presented when a provisional security structure is applied
     * to an entity
     */
    case securifyEntity(
        /**
         * The entity address that is about to be securified
         */entityAddress: AddressOfAccountOrPersona, 
        /**
         * The provisional security structure metadata that is about to be applied
         * into the entity address
         */provisionalSecurityStructureMetadata: SecurityStructureMetadata
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDetailedManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = DetailedManifestClass

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DetailedManifestClass {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .general
        
        case 2: return .transfer(isOneToOneTransfer: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .validatorClaim(validatorAddresses: try FfiConverterSequenceTypeValidatorAddress.read(from: &buf), validatorClaims: try FfiConverterSequenceTypeTrackedValidatorClaim.read(from: &buf)
        )
        
        case 4: return .validatorStake(validatorAddresses: try FfiConverterSequenceTypeValidatorAddress.read(from: &buf), validatorStakes: try FfiConverterSequenceTypeTrackedValidatorStake.read(from: &buf)
        )
        
        case 5: return .validatorUnstake(validatorAddresses: try FfiConverterSequenceTypeValidatorAddress.read(from: &buf), claimsNonFungibleData: try FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData.read(from: &buf)
        )
        
        case 6: return .accountDepositSettingsUpdate(resourcePreferencesUpdates: try FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.read(from: &buf), depositModeUpdates: try FfiConverterDictionaryTypeAccountAddressTypeDepositRule.read(from: &buf), authorizedDepositorsAdded: try FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.read(from: &buf), authorizedDepositorsRemoved: try FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.read(from: &buf)
        )
        
        case 7: return .poolContribution(poolAddresses: try FfiConverterSequenceTypePoolAddress.read(from: &buf), poolContributions: try FfiConverterSequenceTypeTrackedPoolContribution.read(from: &buf)
        )
        
        case 8: return .poolRedemption(poolAddresses: try FfiConverterSequenceTypePoolAddress.read(from: &buf), poolRedemptions: try FfiConverterSequenceTypeTrackedPoolRedemption.read(from: &buf)
        )
        
        case 9: return .deleteAccounts(accountAddresses: try FfiConverterSequenceTypeAccountAddress.read(from: &buf)
        )
        
        case 10: return .securifyEntity(entityAddress: try FfiConverterTypeAddressOfAccountOrPersona.read(from: &buf), provisionalSecurityStructureMetadata: try FfiConverterTypeSecurityStructureMetadata.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DetailedManifestClass, into buf: inout [UInt8]) {
        switch value {
        
        
        case .general:
            writeInt(&buf, Int32(1))
        
        
        case let .transfer(isOneToOneTransfer):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(isOneToOneTransfer, into: &buf)
            
        
        case let .validatorClaim(validatorAddresses,validatorClaims):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedValidatorClaim.write(validatorClaims, into: &buf)
            
        
        case let .validatorStake(validatorAddresses,validatorStakes):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedValidatorStake.write(validatorStakes, into: &buf)
            
        
        case let .validatorUnstake(validatorAddresses,claimsNonFungibleData):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
            FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData.write(claimsNonFungibleData, into: &buf)
            
        
        case let .accountDepositSettingsUpdate(resourcePreferencesUpdates,depositModeUpdates,authorizedDepositorsAdded,authorizedDepositorsRemoved):
            writeInt(&buf, Int32(6))
            FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.write(resourcePreferencesUpdates, into: &buf)
            FfiConverterDictionaryTypeAccountAddressTypeDepositRule.write(depositModeUpdates, into: &buf)
            FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.write(authorizedDepositorsAdded, into: &buf)
            FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.write(authorizedDepositorsRemoved, into: &buf)
            
        
        case let .poolContribution(poolAddresses,poolContributions):
            writeInt(&buf, Int32(7))
            FfiConverterSequenceTypePoolAddress.write(poolAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedPoolContribution.write(poolContributions, into: &buf)
            
        
        case let .poolRedemption(poolAddresses,poolRedemptions):
            writeInt(&buf, Int32(8))
            FfiConverterSequenceTypePoolAddress.write(poolAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedPoolRedemption.write(poolRedemptions, into: &buf)
            
        
        case let .deleteAccounts(accountAddresses):
            writeInt(&buf, Int32(9))
            FfiConverterSequenceTypeAccountAddress.write(accountAddresses, into: &buf)
            
        
        case let .securifyEntity(entityAddress,provisionalSecurityStructureMetadata):
            writeInt(&buf, Int32(10))
            FfiConverterTypeAddressOfAccountOrPersona.write(entityAddress, into: &buf)
            FfiConverterTypeSecurityStructureMetadata.write(provisionalSecurityStructureMetadata, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDetailedManifestClass_lift(_ buf: RustBuffer) throws -> DetailedManifestClass {
    return try FfiConverterTypeDetailedManifestClass.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDetailedManifestClass_lower(_ value: DetailedManifestClass) -> RustBuffer {
    return FfiConverterTypeDetailedManifestClass.lower(value)
}


extension DetailedManifestClass: Sendable {} 
extension DetailedManifestClass: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A discriminator type for the `DetailedManifestClass` enum.
 */

public enum DetailedManifestClassKind {
    
    case general
    case transfer
    case validatorClaim
    case validatorStake
    case validatorUnstake
    case accountDepositSettingsUpdate
    case poolContribution
    case poolRedemption
    case deleteAccounts
    case securifyEntity
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDetailedManifestClassKind: FfiConverterRustBuffer {
    typealias SwiftType = DetailedManifestClassKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DetailedManifestClassKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .general
        
        case 2: return .transfer
        
        case 3: return .validatorClaim
        
        case 4: return .validatorStake
        
        case 5: return .validatorUnstake
        
        case 6: return .accountDepositSettingsUpdate
        
        case 7: return .poolContribution
        
        case 8: return .poolRedemption
        
        case 9: return .deleteAccounts
        
        case 10: return .securifyEntity
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DetailedManifestClassKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .general:
            writeInt(&buf, Int32(1))
        
        
        case .transfer:
            writeInt(&buf, Int32(2))
        
        
        case .validatorClaim:
            writeInt(&buf, Int32(3))
        
        
        case .validatorStake:
            writeInt(&buf, Int32(4))
        
        
        case .validatorUnstake:
            writeInt(&buf, Int32(5))
        
        
        case .accountDepositSettingsUpdate:
            writeInt(&buf, Int32(6))
        
        
        case .poolContribution:
            writeInt(&buf, Int32(7))
        
        
        case .poolRedemption:
            writeInt(&buf, Int32(8))
        
        
        case .deleteAccounts:
            writeInt(&buf, Int32(9))
        
        
        case .securifyEntity:
            writeInt(&buf, Int32(10))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDetailedManifestClassKind_lift(_ buf: RustBuffer) throws -> DetailedManifestClassKind {
    return try FfiConverterTypeDetailedManifestClassKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDetailedManifestClassKind_lower(_ value: DetailedManifestClassKind) -> RustBuffer {
    return FfiConverterTypeDetailedManifestClassKind.lower(value)
}


extension DetailedManifestClassKind: Sendable {} 
extension DetailedManifestClassKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * If we wanna create an Olympia DeviceFactorSource or
 * a Babylon one, either main or not.
 */

public enum DeviceFactorSourceType {
    
    case babylon
    case olympia
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeviceFactorSourceType: FfiConverterRustBuffer {
    typealias SwiftType = DeviceFactorSourceType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSourceType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .babylon
        
        case 2: return .olympia
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DeviceFactorSourceType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .babylon:
            writeInt(&buf, Int32(1))
        
        
        case .olympia:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceFactorSourceType_lift(_ buf: RustBuffer) throws -> DeviceFactorSourceType {
    return try FfiConverterTypeDeviceFactorSourceType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceFactorSourceType_lower(_ value: DeviceFactorSourceType) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSourceType.lower(value)
}


extension DeviceFactorSourceType: Sendable {} 
extension DeviceFactorSourceType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EncryptionScheme {
    
    /**
     * AES GCM 256 encryption
     */
    case version1(AesGcm256
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEncryptionScheme: FfiConverterRustBuffer {
    typealias SwiftType = EncryptionScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .version1(try FfiConverterTypeAesGcm256.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptionScheme, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .version1(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesGcm256.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptionScheme_lift(_ buf: RustBuffer) throws -> EncryptionScheme {
    return try FfiConverterTypeEncryptionScheme.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptionScheme_lower(_ value: EncryptionScheme) -> RustBuffer {
    return FfiConverterTypeEncryptionScheme.lower(value)
}


extension EncryptionScheme: Sendable {} 
extension EncryptionScheme: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Flags used to mark state of an Account or Persona such as whether
 * user has marked it as deleted or not.
 */

public enum EntityFlag {
    
    /**
     * The entity is marked as hidden by user. Entity should still be kept in Profile
     * The user can "unhide" the entity and continue involving it in transactions on ledger.
     */
    case hiddenByUser
    /**
     * The entity is marked as tombstoned by the user. Entity should still be kept in Profile
     * Such an entity cannot be involved in any transaction anymore.
     */
    case tombstonedByUser
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntityFlag: FfiConverterRustBuffer {
    typealias SwiftType = EntityFlag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityFlag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hiddenByUser
        
        case 2: return .tombstonedByUser
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityFlag, into buf: inout [UInt8]) {
        switch value {
        
        
        case .hiddenByUser:
            writeInt(&buf, Int32(1))
        
        
        case .tombstonedByUser:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntityFlag_lift(_ buf: RustBuffer) throws -> EntityFlag {
    return try FfiConverterTypeEntityFlag.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntityFlag_lower(_ value: EntityFlag) -> RustBuffer {
    return FfiConverterTypeEntityFlag.lower(value)
}


extension EntityFlag: Sendable {} 
extension EntityFlag: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EntityKind {
    
    case account
    case persona
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntityKind: FfiConverterRustBuffer {
    typealias SwiftType = EntityKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account
        
        case 2: return .persona
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .account:
            writeInt(&buf, Int32(1))
        
        
        case .persona:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntityKind_lift(_ buf: RustBuffer) throws -> EntityKind {
    return try FfiConverterTypeEntityKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntityKind_lower(_ value: EntityKind) -> RustBuffer {
    return FfiConverterTypeEntityKind.lower(value)
}


extension EntityKind: Sendable {} 
extension EntityKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the state an entity - Account or Persona - is in, in regards to how
 * the user controls it, i.e. if it is controlled by a single factor (private key)
 * or an `AccessController` with a potential Multi-Factor setup.
 */

public enum EntitySecurityState {
    
    /**
     * The entity is controlled by a single factor (private key)
     */
    case unsecured(value: UnsecuredEntityControl
    )
    /**
     * The entity is controlled by multi-factor
     */
    case securified(value: SecuredEntityControl
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntitySecurityState: FfiConverterRustBuffer {
    typealias SwiftType = EntitySecurityState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntitySecurityState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unsecured(value: try FfiConverterTypeUnsecuredEntityControl.read(from: &buf)
        )
        
        case 2: return .securified(value: try FfiConverterTypeSecuredEntityControl.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntitySecurityState, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .unsecured(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUnsecuredEntityControl.write(value, into: &buf)
            
        
        case let .securified(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecuredEntityControl.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntitySecurityState_lift(_ buf: RustBuffer) throws -> EntitySecurityState {
    return try FfiConverterTypeEntitySecurityState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntitySecurityState_lower(_ value: EntitySecurityState) -> RustBuffer {
    return FfiConverterTypeEntitySecurityState.lower(value)
}


extension EntitySecurityState: Sendable {} 
extension EntitySecurityState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The kinds of sync actions performed on entities in profile.
 */

public enum EntitySyncActionPerformed {
    
    case someEntitiesTombstoned
    case someEntitiesSecurified
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntitySyncActionPerformed: FfiConverterRustBuffer {
    typealias SwiftType = EntitySyncActionPerformed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntitySyncActionPerformed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .someEntitiesTombstoned
        
        case 2: return .someEntitiesSecurified
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntitySyncActionPerformed, into buf: inout [UInt8]) {
        switch value {
        
        
        case .someEntitiesTombstoned:
            writeInt(&buf, Int32(1))
        
        
        case .someEntitiesSecurified:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntitySyncActionPerformed_lift(_ buf: RustBuffer) throws -> EntitySyncActionPerformed {
    return try FfiConverterTypeEntitySyncActionPerformed.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntitySyncActionPerformed_lower(_ value: EntitySyncActionPerformed) -> RustBuffer {
    return FfiConverterTypeEntitySyncActionPerformed.lower(value)
}


extension EntitySyncActionPerformed: Sendable {} 
extension EntitySyncActionPerformed: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * SargonOS event contain information about something of interest that has
 * happened to the SargonOS, most prominently to the Profile. Host device
 * can subscribe to these events by use of `EventBusDriver`.
 */

public enum Event {
    
    /**
     * The SargonOS just booted.
     */
    case booted
    /**
     * Current Gateway changed
     */
    case gatewayChangedCurrent(to: Gateway, isNew: Bool
    )
    /**
     * Profile has been saved, typically it has been modified and the new
     * changed Profile got persisted into secure storage.
     */
    case profileSaved
    /**
     * A profile has been imported and has been set to active profile,
     * and saved into secure storage.
     */
    case profileImported(id: ProfileId
    )
    /**
     * The active profile has been modified (might not have been saved yet).
     */
    case profileModified(change: EventProfileModified
    )
    /**
     * The Profile was last used on another device, user ought to claim it.
     */
    case profileUsedOnOtherDevice(DeviceInfo
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .booted
        
        case 2: return .gatewayChangedCurrent(to: try FfiConverterTypeGateway.read(from: &buf), isNew: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .profileSaved
        
        case 4: return .profileImported(id: try FfiConverterTypeProfileID.read(from: &buf)
        )
        
        case 5: return .profileModified(change: try FfiConverterTypeEventProfileModified.read(from: &buf)
        )
        
        case 6: return .profileUsedOnOtherDevice(try FfiConverterTypeDeviceInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        switch value {
        
        
        case .booted:
            writeInt(&buf, Int32(1))
        
        
        case let .gatewayChangedCurrent(to,isNew):
            writeInt(&buf, Int32(2))
            FfiConverterTypeGateway.write(to, into: &buf)
            FfiConverterBool.write(isNew, into: &buf)
            
        
        case .profileSaved:
            writeInt(&buf, Int32(3))
        
        
        case let .profileImported(id):
            writeInt(&buf, Int32(4))
            FfiConverterTypeProfileID.write(id, into: &buf)
            
        
        case let .profileModified(change):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEventProfileModified.write(change, into: &buf)
            
        
        case let .profileUsedOnOtherDevice(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeDeviceInfo.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvent_lift(_ buf: RustBuffer) throws -> Event {
    return try FfiConverterTypeEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEvent_lower(_ value: Event) -> RustBuffer {
    return FfiConverterTypeEvent.lower(value)
}


extension Event: Sendable {} 
extension Event: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A discriminator identifying the kind of `Event`, this has no associated
 * values and flattens the otherwise nested `Event` enum.
 */

public enum EventKind {
    
    /**
     * Profile updated with a new account.
     */
    case accountAdded
    /**
     * Profile updated with new accounts.
     */
    case accountsAdded
    /**
     * An existing account has been updated
     */
    case accountUpdated
    /**
     * Existing accounts have been updated
     */
    case accountsUpdated
    /**
     * SargonOS did boot.
     */
    case booted
    /**
     * Current Gateway changed
     */
    case gatewayChangedCurrent
    /**
     * Profile updated with a new persona.
     */
    case personaAdded
    /**
     * Profile updated with new personas.
     */
    case personasAdded
    /**
     * An existing persona has been updated
     */
    case personaUpdated
    /**
     * Existing personas have been updated
     */
    case personasUpdated
    /**
     * Profile was saved.
     */
    case profileSaved
    /**
     * A profile has been imported and has been set to active profile,
     * and saved into secure storage.
     */
    case profileImported
    /**
     * Profile was last used on another device.
     */
    case profileUsedOnOtherDevice
    /**
     * Profile updated with a new factor source.
     */
    case factorSourceAdded
    /**
     * Profile updated with multiple new factor sources.
     */
    case factorSourcesAdded
    /**
     * An existing factor source has been updated
     */
    case factorSourceUpdated
    /**
     * A collection of existing factor sources have been updated
     */
    case factorSourcesUpdated
    /**
     * Profile updated with a new Security Structure.
     */
    case securityStructureAdded
    /**
     * Security structures have been updated
     */
    case securityStructuresUpdated
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventKind: FfiConverterRustBuffer {
    typealias SwiftType = EventKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accountAdded
        
        case 2: return .accountsAdded
        
        case 3: return .accountUpdated
        
        case 4: return .accountsUpdated
        
        case 5: return .booted
        
        case 6: return .gatewayChangedCurrent
        
        case 7: return .personaAdded
        
        case 8: return .personasAdded
        
        case 9: return .personaUpdated
        
        case 10: return .personasUpdated
        
        case 11: return .profileSaved
        
        case 12: return .profileImported
        
        case 13: return .profileUsedOnOtherDevice
        
        case 14: return .factorSourceAdded
        
        case 15: return .factorSourcesAdded
        
        case 16: return .factorSourceUpdated
        
        case 17: return .factorSourcesUpdated
        
        case 18: return .securityStructureAdded
        
        case 19: return .securityStructuresUpdated
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .accountAdded:
            writeInt(&buf, Int32(1))
        
        
        case .accountsAdded:
            writeInt(&buf, Int32(2))
        
        
        case .accountUpdated:
            writeInt(&buf, Int32(3))
        
        
        case .accountsUpdated:
            writeInt(&buf, Int32(4))
        
        
        case .booted:
            writeInt(&buf, Int32(5))
        
        
        case .gatewayChangedCurrent:
            writeInt(&buf, Int32(6))
        
        
        case .personaAdded:
            writeInt(&buf, Int32(7))
        
        
        case .personasAdded:
            writeInt(&buf, Int32(8))
        
        
        case .personaUpdated:
            writeInt(&buf, Int32(9))
        
        
        case .personasUpdated:
            writeInt(&buf, Int32(10))
        
        
        case .profileSaved:
            writeInt(&buf, Int32(11))
        
        
        case .profileImported:
            writeInt(&buf, Int32(12))
        
        
        case .profileUsedOnOtherDevice:
            writeInt(&buf, Int32(13))
        
        
        case .factorSourceAdded:
            writeInt(&buf, Int32(14))
        
        
        case .factorSourcesAdded:
            writeInt(&buf, Int32(15))
        
        
        case .factorSourceUpdated:
            writeInt(&buf, Int32(16))
        
        
        case .factorSourcesUpdated:
            writeInt(&buf, Int32(17))
        
        
        case .securityStructureAdded:
            writeInt(&buf, Int32(18))
        
        
        case .securityStructuresUpdated:
            writeInt(&buf, Int32(19))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventKind_lift(_ buf: RustBuffer) throws -> EventKind {
    return try FfiConverterTypeEventKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventKind_lower(_ value: EventKind) -> RustBuffer {
    return FfiConverterTypeEventKind.lower(value)
}


extension EventKind: Sendable {} 
extension EventKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The active profile has been modified (might not have been saved yet).
 */

public enum EventProfileModified {
    
    /**
     * A new account with `address` was inserted into the active profile
     */
    case accountAdded(address: AccountAddress
    )
    /**
     * New accounts with `addresses` were inserted into the active profile
     */
    case accountsAdded(addresses: [AccountAddress]
    )
    /**
     * An existing account has been updated
     */
    case accountUpdated(address: AccountAddress
    )
    /**
     * Existing accounts have been updated
     */
    case accountsUpdated(addresses: [AccountAddress]
    )
    /**
     * Profile updated with a new factor source.
     */
    case factorSourceAdded(id: FactorSourceId
    )
    /**
     * Profile updated with many new factor sources.
     */
    case factorSourcesAdded(ids: [FactorSourceId]
    )
    /**
     * An existing factor source has been updated
     */
    case factorSourceUpdated(id: FactorSourceId
    )
    /**
     * A collection of existing factor sources have been updated
     */
    case factorSourcesUpdated(ids: [FactorSourceId]
    )
    /**
     * A new persona with `address` was inserted into the active profile
     */
    case personaAdded(address: IdentityAddress
    )
    /**
     * New personas with `addresses` were inserted into the active profile
     */
    case personasAdded(addresses: [IdentityAddress]
    )
    /**
     * An existing persona has been updated
     */
    case personaUpdated(address: IdentityAddress
    )
    /**
     * Existing personas have been updated
     */
    case personasUpdated(addresses: [IdentityAddress]
    )
    /**
     * Profile updated with a new Security Structure.
     */
    case securityStructureAdded(id: SecurityStructureId
    )
    /**
     * Security structures have been updated
     */
    case securityStructuresUpdated(ids: [SecurityStructureId]
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventProfileModified: FfiConverterRustBuffer {
    typealias SwiftType = EventProfileModified

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventProfileModified {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accountAdded(address: try FfiConverterTypeAccountAddress.read(from: &buf)
        )
        
        case 2: return .accountsAdded(addresses: try FfiConverterSequenceTypeAccountAddress.read(from: &buf)
        )
        
        case 3: return .accountUpdated(address: try FfiConverterTypeAccountAddress.read(from: &buf)
        )
        
        case 4: return .accountsUpdated(addresses: try FfiConverterSequenceTypeAccountAddress.read(from: &buf)
        )
        
        case 5: return .factorSourceAdded(id: try FfiConverterTypeFactorSourceID.read(from: &buf)
        )
        
        case 6: return .factorSourcesAdded(ids: try FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
        )
        
        case 7: return .factorSourceUpdated(id: try FfiConverterTypeFactorSourceID.read(from: &buf)
        )
        
        case 8: return .factorSourcesUpdated(ids: try FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
        )
        
        case 9: return .personaAdded(address: try FfiConverterTypeIdentityAddress.read(from: &buf)
        )
        
        case 10: return .personasAdded(addresses: try FfiConverterSequenceTypeIdentityAddress.read(from: &buf)
        )
        
        case 11: return .personaUpdated(address: try FfiConverterTypeIdentityAddress.read(from: &buf)
        )
        
        case 12: return .personasUpdated(addresses: try FfiConverterSequenceTypeIdentityAddress.read(from: &buf)
        )
        
        case 13: return .securityStructureAdded(id: try FfiConverterTypeSecurityStructureID.read(from: &buf)
        )
        
        case 14: return .securityStructuresUpdated(ids: try FfiConverterSequenceTypeSecurityStructureID.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventProfileModified, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .accountAdded(address):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountAddress.write(address, into: &buf)
            
        
        case let .accountsAdded(addresses):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeAccountAddress.write(addresses, into: &buf)
            
        
        case let .accountUpdated(address):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAccountAddress.write(address, into: &buf)
            
        
        case let .accountsUpdated(addresses):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeAccountAddress.write(addresses, into: &buf)
            
        
        case let .factorSourceAdded(id):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFactorSourceID.write(id, into: &buf)
            
        
        case let .factorSourcesAdded(ids):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeFactorSourceID.write(ids, into: &buf)
            
        
        case let .factorSourceUpdated(id):
            writeInt(&buf, Int32(7))
            FfiConverterTypeFactorSourceID.write(id, into: &buf)
            
        
        case let .factorSourcesUpdated(ids):
            writeInt(&buf, Int32(8))
            FfiConverterSequenceTypeFactorSourceID.write(ids, into: &buf)
            
        
        case let .personaAdded(address):
            writeInt(&buf, Int32(9))
            FfiConverterTypeIdentityAddress.write(address, into: &buf)
            
        
        case let .personasAdded(addresses):
            writeInt(&buf, Int32(10))
            FfiConverterSequenceTypeIdentityAddress.write(addresses, into: &buf)
            
        
        case let .personaUpdated(address):
            writeInt(&buf, Int32(11))
            FfiConverterTypeIdentityAddress.write(address, into: &buf)
            
        
        case let .personasUpdated(addresses):
            writeInt(&buf, Int32(12))
            FfiConverterSequenceTypeIdentityAddress.write(addresses, into: &buf)
            
        
        case let .securityStructureAdded(id):
            writeInt(&buf, Int32(13))
            FfiConverterTypeSecurityStructureID.write(id, into: &buf)
            
        
        case let .securityStructuresUpdated(ids):
            writeInt(&buf, Int32(14))
            FfiConverterSequenceTypeSecurityStructureID.write(ids, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventProfileModified_lift(_ buf: RustBuffer) throws -> EventProfileModified {
    return try FfiConverterTypeEventProfileModified.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventProfileModified_lower(_ value: EventProfileModified) -> RustBuffer {
    return FfiConverterTypeEventProfileModified.lower(value)
}


extension EventProfileModified: Sendable {} 
extension EventProfileModified: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either a "physical" badge (resource) or some source for recreation of a producer
 * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
 * is derived which produces virtual badges (signatures).
 */

public enum FactorInstanceBadge {
    
    case virtual(value: FactorInstanceBadgeVirtualSource
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorInstanceBadge: FfiConverterRustBuffer {
    typealias SwiftType = FactorInstanceBadge

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceBadge {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .virtual(value: try FfiConverterTypeFactorInstanceBadgeVirtualSource.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorInstanceBadge, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .virtual(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFactorInstanceBadgeVirtualSource.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorInstanceBadge_lift(_ buf: RustBuffer) throws -> FactorInstanceBadge {
    return try FfiConverterTypeFactorInstanceBadge.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorInstanceBadge_lower(_ value: FactorInstanceBadge) -> RustBuffer {
    return FfiConverterTypeFactorInstanceBadge.lower(value)
}


extension FactorInstanceBadge: Sendable {} 
extension FactorInstanceBadge: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FactorInstanceBadgeVirtualSource {
    
    case hierarchicalDeterministic(value: HierarchicalDeterministicPublicKey
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorInstanceBadgeVirtualSource: FfiConverterRustBuffer {
    typealias SwiftType = FactorInstanceBadgeVirtualSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceBadgeVirtualSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hierarchicalDeterministic(value: try FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorInstanceBadgeVirtualSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .hierarchicalDeterministic(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeHierarchicalDeterministicPublicKey.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorInstanceBadgeVirtualSource_lift(_ buf: RustBuffer) throws -> FactorInstanceBadgeVirtualSource {
    return try FfiConverterTypeFactorInstanceBadgeVirtualSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorInstanceBadgeVirtualSource_lower(_ value: FactorInstanceBadgeVirtualSource) -> RustBuffer {
    return FfiConverterTypeFactorInstanceBadgeVirtualSource.lower(value)
}


extension FactorInstanceBadgeVirtualSource: Sendable {} 
extension FactorInstanceBadgeVirtualSource: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A kind of factor list, either threshold, or override kind.
 */

public enum FactorListKind {
    
    case threshold
    case override
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorListKind: FfiConverterRustBuffer {
    typealias SwiftType = FactorListKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorListKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .threshold
        
        case 2: return .override
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorListKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .threshold:
            writeInt(&buf, Int32(1))
        
        
        case .override:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorListKind_lift(_ buf: RustBuffer) throws -> FactorListKind {
    return try FfiConverterTypeFactorListKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorListKind_lower(_ value: FactorListKind) -> RustBuffer {
    return FfiConverterTypeFactorListKind.lower(value)
}


extension FactorListKind: Sendable {} 
extension FactorListKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The outcome of the signing process for each factor source as collected by the `SignInteractor`.
 */

public enum FactorOutcomeOfAuthIntentHash {
    
    /**
     * The user successfully signed with the factor source, the associated
     * value contains the produced signatures and any relevant metadata.
     */
    case signed(producedSignatures: [HdSignatureOfAuthIntentHash]
    )
    /**
     * The factor source got neglected, either due to user explicitly skipping
     * or due to failure
     */
    case neglected(NeglectedFactor
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorOutcomeOfAuthIntentHash: FfiConverterRustBuffer {
    typealias SwiftType = FactorOutcomeOfAuthIntentHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorOutcomeOfAuthIntentHash {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .signed(producedSignatures: try FfiConverterSequenceTypeHDSignatureOfAuthIntentHash.read(from: &buf)
        )
        
        case 2: return .neglected(try FfiConverterTypeNeglectedFactor.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorOutcomeOfAuthIntentHash, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .signed(producedSignatures):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeHDSignatureOfAuthIntentHash.write(producedSignatures, into: &buf)
            
        
        case let .neglected(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNeglectedFactor.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorOutcomeOfAuthIntentHash_lift(_ buf: RustBuffer) throws -> FactorOutcomeOfAuthIntentHash {
    return try FfiConverterTypeFactorOutcomeOfAuthIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorOutcomeOfAuthIntentHash_lower(_ value: FactorOutcomeOfAuthIntentHash) -> RustBuffer {
    return FfiConverterTypeFactorOutcomeOfAuthIntentHash.lower(value)
}


extension FactorOutcomeOfAuthIntentHash: Sendable {} 
extension FactorOutcomeOfAuthIntentHash: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The outcome of the signing process for each factor source as collected by the `SignInteractor`.
 */

public enum FactorOutcomeOfSubintentHash {
    
    /**
     * The user successfully signed with the factor source, the associated
     * value contains the produced signatures and any relevant metadata.
     */
    case signed(producedSignatures: [HdSignatureOfSubintentHash]
    )
    /**
     * The factor source got neglected, either due to user explicitly skipping
     * or due to failure
     */
    case neglected(NeglectedFactor
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorOutcomeOfSubintentHash: FfiConverterRustBuffer {
    typealias SwiftType = FactorOutcomeOfSubintentHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorOutcomeOfSubintentHash {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .signed(producedSignatures: try FfiConverterSequenceTypeHDSignatureOfSubintentHash.read(from: &buf)
        )
        
        case 2: return .neglected(try FfiConverterTypeNeglectedFactor.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorOutcomeOfSubintentHash, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .signed(producedSignatures):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeHDSignatureOfSubintentHash.write(producedSignatures, into: &buf)
            
        
        case let .neglected(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNeglectedFactor.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorOutcomeOfSubintentHash_lift(_ buf: RustBuffer) throws -> FactorOutcomeOfSubintentHash {
    return try FfiConverterTypeFactorOutcomeOfSubintentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorOutcomeOfSubintentHash_lower(_ value: FactorOutcomeOfSubintentHash) -> RustBuffer {
    return FfiConverterTypeFactorOutcomeOfSubintentHash.lower(value)
}


extension FactorOutcomeOfSubintentHash: Sendable {} 
extension FactorOutcomeOfSubintentHash: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The outcome of the signing process for each factor source as collected by the `SignInteractor`.
 */

public enum FactorOutcomeOfTransactionIntentHash {
    
    /**
     * The user successfully signed with the factor source, the associated
     * value contains the produced signatures and any relevant metadata.
     */
    case signed(producedSignatures: [HdSignatureOfTransactionIntentHash]
    )
    /**
     * The factor source got neglected, either due to user explicitly skipping
     * or due to failure
     */
    case neglected(NeglectedFactor
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorOutcomeOfTransactionIntentHash: FfiConverterRustBuffer {
    typealias SwiftType = FactorOutcomeOfTransactionIntentHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorOutcomeOfTransactionIntentHash {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .signed(producedSignatures: try FfiConverterSequenceTypeHDSignatureOfTransactionIntentHash.read(from: &buf)
        )
        
        case 2: return .neglected(try FfiConverterTypeNeglectedFactor.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorOutcomeOfTransactionIntentHash, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .signed(producedSignatures):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeHDSignatureOfTransactionIntentHash.write(producedSignatures, into: &buf)
            
        
        case let .neglected(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNeglectedFactor.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorOutcomeOfTransactionIntentHash_lift(_ buf: RustBuffer) throws -> FactorOutcomeOfTransactionIntentHash {
    return try FfiConverterTypeFactorOutcomeOfTransactionIntentHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorOutcomeOfTransactionIntentHash_lower(_ value: FactorOutcomeOfTransactionIntentHash) -> RustBuffer {
    return FfiConverterTypeFactorOutcomeOfTransactionIntentHash.lower(value)
}


extension FactorOutcomeOfTransactionIntentHash: Sendable {} 
extension FactorOutcomeOfTransactionIntentHash: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FactorSource {
    
    case device(value: DeviceFactorSource
    )
    case ledger(value: LedgerHardwareWalletFactorSource
    )
    case offDeviceMnemonic(value: OffDeviceMnemonicFactorSource
    )
    case arculusCard(value: ArculusCardFactorSource
    )
    case password(value: PasswordFactorSource
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorSource: FfiConverterRustBuffer {
    typealias SwiftType = FactorSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .device(value: try FfiConverterTypeDeviceFactorSource.read(from: &buf)
        )
        
        case 2: return .ledger(value: try FfiConverterTypeLedgerHardwareWalletFactorSource.read(from: &buf)
        )
        
        case 3: return .offDeviceMnemonic(value: try FfiConverterTypeOffDeviceMnemonicFactorSource.read(from: &buf)
        )
        
        case 4: return .arculusCard(value: try FfiConverterTypeArculusCardFactorSource.read(from: &buf)
        )
        
        case 5: return .password(value: try FfiConverterTypePasswordFactorSource.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .device(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDeviceFactorSource.write(value, into: &buf)
            
        
        case let .ledger(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLedgerHardwareWalletFactorSource.write(value, into: &buf)
            
        
        case let .offDeviceMnemonic(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeOffDeviceMnemonicFactorSource.write(value, into: &buf)
            
        
        case let .arculusCard(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeArculusCardFactorSource.write(value, into: &buf)
            
        
        case let .password(value):
            writeInt(&buf, Int32(5))
            FfiConverterTypePasswordFactorSource.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSource_lift(_ buf: RustBuffer) throws -> FactorSource {
    return try FfiConverterTypeFactorSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSource_lower(_ value: FactorSource) -> RustBuffer {
    return FfiConverterTypeFactorSource.lower(value)
}


extension FactorSource: Sendable {} 
extension FactorSource: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Flags which describe a certain state a FactorSource might be in, primarily used
 * by DeviceFactorSource's to mark which "Babylon" FactorSource is the **main** one.
 */

public enum FactorSourceFlag {
    
    /**
     * Used to mark a "babylon" `.device` FactorSource as "main". All new accounts
     * and Personas are created using the `main` `DeviceFactorSource`.
     *
     * We can only ever have one.
     * We might have zero `main` flags across all  `DeviceFactorSource`s if and only if we have only one  `DeviceFactorSource`s. If we have two or more  `DeviceFactorSource`s one of them MUST
     * be marked with `main`.
     */
    case main
    /**
     * Until we have implemented "proper" deletion, we will "flag" a
     * FactorSource as deleted by the user and hide it, meaning e.g.
     * that in Multi-Factor Setup flows it will not show up.
     */
    case deletedByUser
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorSourceFlag: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceFlag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceFlag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .main
        
        case 2: return .deletedByUser
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceFlag, into buf: inout [UInt8]) {
        switch value {
        
        
        case .main:
            writeInt(&buf, Int32(1))
        
        
        case .deletedByUser:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceFlag_lift(_ buf: RustBuffer) throws -> FactorSourceFlag {
    return try FfiConverterTypeFactorSourceFlag.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceFlag_lower(_ value: FactorSourceFlag) -> RustBuffer {
    return FfiConverterTypeFactorSourceFlag.lower(value)
}


extension FactorSourceFlag: Sendable {} 
extension FactorSourceFlag: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A unique and stable identifier of a FactorSource, e.g. a
 * DeviceFactorSource being a mnemonic securely stored in a
 * device (phone), where the ID of it is the hash of a special
 * key derived near the root of it.
 */

public enum FactorSourceId {
    
    /**
     * FactorSourceID from the blake2b hash of the special HD public key derived at `CAP26::GetID`,
     * for a certain `FactorSourceKind`
     */
    case hash(value: FactorSourceIdFromHash
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorSourceID: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hash(value: try FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .hash(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFactorSourceIDFromHash.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceID_lift(_ buf: RustBuffer) throws -> FactorSourceId {
    return try FfiConverterTypeFactorSourceID.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceID_lower(_ value: FactorSourceId) -> RustBuffer {
    return FfiConverterTypeFactorSourceID.lower(value)
}


extension FactorSourceId: Sendable {} 
extension FactorSourceId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum representing the integrity of a factor source.
 */

public enum FactorSourceIntegrity {
    
    case device(DeviceFactorSourceIntegrity
    )
    case ledger(LedgerHardwareWalletFactorSource
    )
    case offDeviceMnemonic(OffDeviceMnemonicFactorSource
    )
    case arculusCard(ArculusCardFactorSource
    )
    case password(PasswordFactorSource
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorSourceIntegrity: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceIntegrity

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIntegrity {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .device(try FfiConverterTypeDeviceFactorSourceIntegrity.read(from: &buf)
        )
        
        case 2: return .ledger(try FfiConverterTypeLedgerHardwareWalletFactorSource.read(from: &buf)
        )
        
        case 3: return .offDeviceMnemonic(try FfiConverterTypeOffDeviceMnemonicFactorSource.read(from: &buf)
        )
        
        case 4: return .arculusCard(try FfiConverterTypeArculusCardFactorSource.read(from: &buf)
        )
        
        case 5: return .password(try FfiConverterTypePasswordFactorSource.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceIntegrity, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .device(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDeviceFactorSourceIntegrity.write(v1, into: &buf)
            
        
        case let .ledger(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLedgerHardwareWalletFactorSource.write(v1, into: &buf)
            
        
        case let .offDeviceMnemonic(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeOffDeviceMnemonicFactorSource.write(v1, into: &buf)
            
        
        case let .arculusCard(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeArculusCardFactorSource.write(v1, into: &buf)
            
        
        case let .password(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypePasswordFactorSource.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceIntegrity_lift(_ buf: RustBuffer) throws -> FactorSourceIntegrity {
    return try FfiConverterTypeFactorSourceIntegrity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceIntegrity_lower(_ value: FactorSourceIntegrity) -> RustBuffer {
    return FfiConverterTypeFactorSourceIntegrity.lower(value)
}


extension FactorSourceIntegrity: Sendable {} 
extension FactorSourceIntegrity: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The **kind** (or "type") of FactorSource describes how it is used.
 */

public enum FactorSourceKind {
    
    /**
     * A user owned unencrypted mnemonic (and optional BIP39 passphrase) stored on device,
     * thus directly usable. This kind is used as the standard factor source for all new
     * wallet users.
     *
     * Attributes:
     * * Mine
     * * On device
     * * Hierarchical deterministic (Mnemonic)
     * * Entity creating
     */
    case device
    /**
     * A user owned hardware wallet by vendor Ledger HQ, most commonly
     * a Ledger Nano S or Ledger Nano X. Less common models are Ledger Nano S Plus
     * Ledger Stax.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hardware (requires Browser Connector Extension to communicate with wallet)
     * * Hierarchical deterministic
     * * Entity creating (accounts only)
     */
    case ledgerHqHardwareWallet
    /**
     * A user owned mnemonic (and optional BIP39 passphrase) user has to input when used,
     * e.g. during signing.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic  (Mnemonic)
     */
    case offDeviceMnemonic
    /**
     * An Arculus card, in credit card size, communicating with host using NFC.
     *
     * For more info see [link]
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic  (**Encrypted** mnemonic)\
     * * Hardware (communicates with host using NFC)
     *
     * [link]: https://www.getarculus.com/
     */
    case arculusCard
    /**
     * Input key material for mnemonic (and optional BIP39 passphrase).
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic (IKM -> HKDF -> Mnemonic)
     */
    case password
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorSourceKind: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .device
        
        case 2: return .ledgerHqHardwareWallet
        
        case 3: return .offDeviceMnemonic
        
        case 4: return .arculusCard
        
        case 5: return .password
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .device:
            writeInt(&buf, Int32(1))
        
        
        case .ledgerHqHardwareWallet:
            writeInt(&buf, Int32(2))
        
        
        case .offDeviceMnemonic:
            writeInt(&buf, Int32(3))
        
        
        case .arculusCard:
            writeInt(&buf, Int32(4))
        
        
        case .password:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceKind_lift(_ buf: RustBuffer) throws -> FactorSourceKind {
    return try FfiConverterTypeFactorSourceKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceKind_lower(_ value: FactorSourceKind) -> RustBuffer {
    return FfiConverterTypeFactorSourceKind.lower(value)
}


extension FactorSourceKind: Sendable {} 
extension FactorSourceKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The reason why a `FactorSourceID` is invalid if it were
 * to be added into a factor list for some role.
 */

public enum FactorSourceValidationStatusReasonIfInvalid {
    
    case basicViolation(String
    )
    case nonBasic(SecurityShieldBuilderRuleViolation
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorSourceValidationStatusReasonIfInvalid: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceValidationStatusReasonIfInvalid

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceValidationStatusReasonIfInvalid {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .basicViolation(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .nonBasic(try FfiConverterTypeSecurityShieldBuilderRuleViolation.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceValidationStatusReasonIfInvalid, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .basicViolation(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .nonBasic(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecurityShieldBuilderRuleViolation.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceValidationStatusReasonIfInvalid_lift(_ buf: RustBuffer) throws -> FactorSourceValidationStatusReasonIfInvalid {
    return try FfiConverterTypeFactorSourceValidationStatusReasonIfInvalid.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorSourceValidationStatusReasonIfInvalid_lower(_ value: FactorSourceValidationStatusReasonIfInvalid) -> RustBuffer {
    return FfiConverterTypeFactorSourceValidationStatusReasonIfInvalid.lower(value)
}


extension FactorSourceValidationStatusReasonIfInvalid: Sendable {} 
extension FactorSourceValidationStatusReasonIfInvalid: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Fiat currency to measure and display the value of some XRD or other Radix assets value/worth in.
 */

public enum FiatCurrency {
    
    /**
     * American dollars.
     */
    case usd
    /**
     * Swedish krona.
     */
    case sek
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = FiatCurrency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .usd
        
        case 2: return .sek
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        switch value {
        
        
        case .usd:
            writeInt(&buf, Int32(1))
        
        
        case .sek:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
    return FfiConverterTypeFiatCurrency.lower(value)
}


extension FiatCurrency: Sendable {} 
extension FiatCurrency: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FungibleResourceIndicator {
    
    case guaranteed(decimal: Decimal192
    )
    case predicted(predictedDecimal: PredictedDecimal
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFungibleResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = FungibleResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .guaranteed(decimal: try FfiConverterTypeDecimal192.read(from: &buf)
        )
        
        case 2: return .predicted(predictedDecimal: try FfiConverterTypePredictedDecimal.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FungibleResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .guaranteed(decimal):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal192.write(decimal, into: &buf)
            
        
        case let .predicted(predictedDecimal):
            writeInt(&buf, Int32(2))
            FfiConverterTypePredictedDecimal.write(predictedDecimal, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFungibleResourceIndicator_lift(_ buf: RustBuffer) throws -> FungibleResourceIndicator {
    return try FfiConverterTypeFungibleResourceIndicator.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFungibleResourceIndicator_lower(_ value: FungibleResourceIndicator) -> RustBuffer {
    return FfiConverterTypeFungibleResourceIndicator.lower(value)
}


extension FungibleResourceIndicator: Sendable {} 
extension FungibleResourceIndicator: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HdPathComponent {
    
    case unsecurifiedComponent(Unsecurified
    )
    case securifiedComponent(SecurifiedU30
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHDPathComponent: FfiConverterRustBuffer {
    typealias SwiftType = HdPathComponent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdPathComponent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unsecurifiedComponent(try FfiConverterTypeUnsecurified.read(from: &buf)
        )
        
        case 2: return .securifiedComponent(try FfiConverterTypeSecurifiedU30.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HdPathComponent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .unsecurifiedComponent(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUnsecurified.write(v1, into: &buf)
            
        
        case let .securifiedComponent(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecurifiedU30.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDPathComponent_lift(_ buf: RustBuffer) throws -> HdPathComponent {
    return try FfiConverterTypeHDPathComponent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHDPathComponent_lower(_ value: HdPathComponent) -> RustBuffer {
    return FfiConverterTypeHDPathComponent.lower(value)
}


extension HdPathComponent: Sendable {} 
extension HdPathComponent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Hardened {
    
    case unsecurified(UnsecurifiedHardened
    )
    case securified(SecurifiedU30
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHardened: FfiConverterRustBuffer {
    typealias SwiftType = Hardened

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hardened {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unsecurified(try FfiConverterTypeUnsecurifiedHardened.read(from: &buf)
        )
        
        case 2: return .securified(try FfiConverterTypeSecurifiedU30.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Hardened, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .unsecurified(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUnsecurifiedHardened.write(v1, into: &buf)
            
        
        case let .securified(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecurifiedU30.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHardened_lift(_ buf: RustBuffer) throws -> Hardened {
    return try FfiConverterTypeHardened.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHardened_lower(_ value: Hardened) -> RustBuffer {
    return FfiConverterTypeHardened.lower(value)
}


extension Hardened: Sendable {} 
extension Hardened: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum describing the different cards that Wallet can display on home page.
 * Each card has an associated content and optional action.
 */

public enum HomeCard {
    
    case joinRadixRewards
    /**
     * Content: "Start RadQuest, learn about Radix, earn XRD and collectibles."
     * Action: Redirect user to RadQuest.
     */
    case startRadQuest
    /**
     * Content: "Continue your Radix journey in your browser. Tap to dismiss."
     * Action: None.
     */
    case continueRadQuest
    /**
     * Content: "You can now connect with your Radix Wallet. Tap to dismiss."
     * Action: None.
     */
    case dapp(iconUrl: Url?
    )
    /**
     * Content: "To use Radix Wallet with desktop browsers, finish setup by visiting wallet.radixdlt.com"
     * Action: None
     */
    case connector
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHomeCard: FfiConverterRustBuffer {
    typealias SwiftType = HomeCard

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCard {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .joinRadixRewards
        
        case 2: return .startRadQuest
        
        case 3: return .continueRadQuest
        
        case 4: return .dapp(iconUrl: try FfiConverterOptionTypeUrl.read(from: &buf)
        )
        
        case 5: return .connector
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HomeCard, into buf: inout [UInt8]) {
        switch value {
        
        
        case .joinRadixRewards:
            writeInt(&buf, Int32(1))
        
        
        case .startRadQuest:
            writeInt(&buf, Int32(2))
        
        
        case .continueRadQuest:
            writeInt(&buf, Int32(3))
        
        
        case let .dapp(iconUrl):
            writeInt(&buf, Int32(4))
            FfiConverterOptionTypeUrl.write(iconUrl, into: &buf)
            
        
        case .connector:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHomeCard_lift(_ buf: RustBuffer) throws -> HomeCard {
    return try FfiConverterTypeHomeCard.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHomeCard_lower(_ value: HomeCard) -> RustBuffer {
    return FfiConverterTypeHomeCard.lower(value)
}


extension HomeCard: Sendable {} 
extension HomeCard: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the type of the Host machine and its version. Currently, as it stands at runtime
 * the possible values will be IOS or Android. Other is in place to facilitate unit tests
 * and to make sargon host agnostic.
 */

public enum HostOs {
    
    case ios(version: String
    )
    case android(vendor: String, version: String
    )
    case other(name: String, vendor: String, version: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHostOS: FfiConverterRustBuffer {
    typealias SwiftType = HostOs

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostOs {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ios(version: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .android(vendor: try FfiConverterString.read(from: &buf), version: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .other(name: try FfiConverterString.read(from: &buf), vendor: try FfiConverterString.read(from: &buf), version: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HostOs, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ios(version):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(version, into: &buf)
            
        
        case let .android(vendor,version):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(vendor, into: &buf)
            FfiConverterString.write(version, into: &buf)
            
        
        case let .other(name,vendor,version):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(name, into: &buf)
            FfiConverterString.write(vendor, into: &buf)
            FfiConverterString.write(version, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHostOS_lift(_ buf: RustBuffer) throws -> HostOs {
    return try FfiConverterTypeHostOS.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHostOS_lower(_ value: HostOs) -> RustBuffer {
    return FfiConverterTypeHostOS.lower(value)
}


extension HostOs: Sendable {} 
extension HostOs: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A discriminator of an `HDPathComponent`.
 */

public enum KeySpace {
    
    case unsecurified(isHardened: Bool
    )
    case securified
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeySpace: FfiConverterRustBuffer {
    typealias SwiftType = KeySpace

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeySpace {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unsecurified(isHardened: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .securified
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeySpace, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .unsecurified(isHardened):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(isHardened, into: &buf)
            
        
        case .securified:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeySpace_lift(_ buf: RustBuffer) throws -> KeySpace {
    return try FfiConverterTypeKeySpace.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeySpace_lower(_ value: KeySpace) -> RustBuffer {
    return FfiConverterTypeKeySpace.lower(value)
}


extension KeySpace: Sendable {} 
extension KeySpace: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The model of a Ledger HQ hardware wallet NanoS, e.g.
 * *Ledger Nano S+*.
 */

public enum LedgerHardwareWalletModel {
    
    case nanoS
    case nanoSPlus
    case nanoX
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLedgerHardwareWalletModel: FfiConverterRustBuffer {
    typealias SwiftType = LedgerHardwareWalletModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletModel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nanoS
        
        case 2: return .nanoSPlus
        
        case 3: return .nanoX
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LedgerHardwareWalletModel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nanoS:
            writeInt(&buf, Int32(1))
        
        
        case .nanoSPlus:
            writeInt(&buf, Int32(2))
        
        
        case .nanoX:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLedgerHardwareWalletModel_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletModel {
    return try FfiConverterTypeLedgerHardwareWalletModel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLedgerHardwareWalletModel_lower(_ value: LedgerHardwareWalletModel) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletModel.lower(value)
}


extension LedgerHardwareWalletModel: Sendable {} 
extension LedgerHardwareWalletModel: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogFilter : UInt8 {
    
    /**
     * Logging is turned off
     */
    case off = 0
    /**
     * The "error" level.
     *
     * Designates very serious errors.
     */
    case error = 1
    /**
     * The "warn" level.
     *
     * Designates hazardous situations.
     */
    case warn = 2
    /**
     * The "info" level.
     *
     * Designates useful information.
     */
    case info = 3
    /**
     * The "debug" level.
     *
     * Designates lower priority information.
     */
    case debug = 4
    /**
     * The "trace" level.
     *
     * Designates very low priority, often extremely verbose, information.
     */
    case trace = 5
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogFilter: FfiConverterRustBuffer {
    typealias SwiftType = LogFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .off
        
        case 2: return .error
        
        case 3: return .warn
        
        case 4: return .info
        
        case 5: return .debug
        
        case 6: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogFilter, into buf: inout [UInt8]) {
        switch value {
        
        
        case .off:
            writeInt(&buf, Int32(1))
        
        
        case .error:
            writeInt(&buf, Int32(2))
        
        
        case .warn:
            writeInt(&buf, Int32(3))
        
        
        case .info:
            writeInt(&buf, Int32(4))
        
        
        case .debug:
            writeInt(&buf, Int32(5))
        
        
        case .trace:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogFilter_lift(_ buf: RustBuffer) throws -> LogFilter {
    return try FfiConverterTypeLogFilter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogFilter_lower(_ value: LogFilter) -> RustBuffer {
    return FfiConverterTypeLogFilter.lower(value)
}


extension LogFilter: Sendable {} 
extension LogFilter: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel : UInt8 {
    
    /**
     * The "error" level.
     *
     * Designates very serious errors.
     */
    case error = 1
    /**
     * The "warn" level.
     *
     * Designates hazardous situations.
     */
    case warn = 2
    /**
     * The "info" level.
     *
     * Designates useful information.
     */
    case info = 3
    /**
     * The "debug" level.
     *
     * Designates lower priority information.
     */
    case debug = 4
    /**
     * The "trace" level.
     *
     * Designates very low priority, often extremely verbose, information.
     */
    case trace = 5
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warn
        
        case 3: return .info
        
        case 4: return .debug
        
        case 5: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warn:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .debug:
            writeInt(&buf, Int32(4))
        
        
        case .trace:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}


extension LogLevel: Sendable {} 
extension LogLevel: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The classification process classifies manifests into classes. The following
 * are the classes that the Radix Engine Toolkit supports.
 */

public enum ManifestClass {
    
    /**
     * A subintent manifest which satisfies the general rules allowed for in
     * general transactions and that includes a [`YieldToParent`] instruction.
     *
     * [`YieldToParent`]: radix_transactions::manifest::YieldToParent
     */
    case generalSubintent
    /**
     * A general manifest that involves any amount of arbitrary components
     * and packages where nothing more concrete can be said about the manifest
     * and its nature.
     */
    case general
    /**
     * A manifest of a 1-to-1 transfer to a one-to-many transfer of resources.
     */
    case transfer
    /**
     * A manifest that contributed some amount of resources to a liquidity
     * pool that can be a one-resource pool, two-resource pool, or a
     * multi-resource pool.
     */
    case poolContribution
    /**
     * A manifest that redeemed resources from a liquidity pool. Similar to
     * contributions, this can be any of the three pool blueprints available
     * in the pool package.
     */
    case poolRedemption
    /**
     * A manifest where XRD is staked to one or more validators.
     */
    case validatorStake
    /**
     * A manifest where XRD is unstaked from one or more validators.
     */
    case validatorUnstake
    /**
     * A manifest where XRD is claimed from one or more validators.
     */
    case validatorClaimXrd
    /**
     * A manifest that updated the deposit settings of the account.
     */
    case accountDepositSettingsUpdate
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = ManifestClass

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestClass {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .generalSubintent
        
        case 2: return .general
        
        case 3: return .transfer
        
        case 4: return .poolContribution
        
        case 5: return .poolRedemption
        
        case 6: return .validatorStake
        
        case 7: return .validatorUnstake
        
        case 8: return .validatorClaimXrd
        
        case 9: return .accountDepositSettingsUpdate
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestClass, into buf: inout [UInt8]) {
        switch value {
        
        
        case .generalSubintent:
            writeInt(&buf, Int32(1))
        
        
        case .general:
            writeInt(&buf, Int32(2))
        
        
        case .transfer:
            writeInt(&buf, Int32(3))
        
        
        case .poolContribution:
            writeInt(&buf, Int32(4))
        
        
        case .poolRedemption:
            writeInt(&buf, Int32(5))
        
        
        case .validatorStake:
            writeInt(&buf, Int32(6))
        
        
        case .validatorUnstake:
            writeInt(&buf, Int32(7))
        
        
        case .validatorClaimXrd:
            writeInt(&buf, Int32(8))
        
        
        case .accountDepositSettingsUpdate:
            writeInt(&buf, Int32(9))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeManifestClass_lift(_ buf: RustBuffer) throws -> ManifestClass {
    return try FfiConverterTypeManifestClass.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeManifestClass_lower(_ value: ManifestClass) -> RustBuffer {
    return FfiConverterTypeManifestClass.lower(value)
}


extension ManifestClass: Sendable {} 
extension ManifestClass: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of all the encountered addresses in the manifest.
 * This is to be primarily used for the "using dApps" section of the wallet's tx review screen.
 */

public enum ManifestEncounteredComponentAddress {
    
    case component(ComponentAddress
    )
    case locker(LockerAddress
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeManifestEncounteredComponentAddress: FfiConverterRustBuffer {
    typealias SwiftType = ManifestEncounteredComponentAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestEncounteredComponentAddress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .component(try FfiConverterTypeComponentAddress.read(from: &buf)
        )
        
        case 2: return .locker(try FfiConverterTypeLockerAddress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestEncounteredComponentAddress, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .component(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeComponentAddress.write(v1, into: &buf)
            
        
        case let .locker(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLockerAddress.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeManifestEncounteredComponentAddress_lift(_ buf: RustBuffer) throws -> ManifestEncounteredComponentAddress {
    return try FfiConverterTypeManifestEncounteredComponentAddress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeManifestEncounteredComponentAddress_lower(_ value: ManifestEncounteredComponentAddress) -> RustBuffer {
    return FfiConverterTypeManifestEncounteredComponentAddress.lower(value)
}


extension ManifestEncounteredComponentAddress: Sendable {} 
extension ManifestEncounteredComponentAddress: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Message {
    
    case plainText(plaintext: PlaintextMessage
    )
    case none
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .plainText(plaintext: try FfiConverterTypePlaintextMessage.read(from: &buf)
        )
        
        case 2: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .plainText(plaintext):
            writeInt(&buf, Int32(1))
            FfiConverterTypePlaintextMessage.write(plaintext, into: &buf)
            
        
        case .none:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}


extension Message: Sendable {} 
extension Message: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * We explicitly mark content as either String or Bytes - this distinguishes (along with the mime type)
 * whether the message is intended to be displayable as text, or not.
 *
 * This data model ensures that messages intended to be displayable as text are valid unicode strings.
 */

public enum MessageContents {
    
    case stringMessage(string: String
    )
    case binaryMessage(bagOfBytes: BagOfBytes
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageContents: FfiConverterRustBuffer {
    typealias SwiftType = MessageContents

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageContents {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .stringMessage(string: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .binaryMessage(bagOfBytes: try FfiConverterTypeBagOfBytes.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageContents, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .stringMessage(string):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(string, into: &buf)
            
        
        case let .binaryMessage(bagOfBytes):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBagOfBytes.write(bagOfBytes, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageContents_lift(_ buf: RustBuffer) throws -> MessageContents {
    return try FfiConverterTypeMessageContents.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageContents_lower(_ value: MessageContents) -> RustBuffer {
    return FfiConverterTypeMessageContents.lower(value)
}


extension MessageContents: Sendable {} 
extension MessageContents: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageV2 {
    
    case plainText(plaintext: PlaintextMessage
    )
    case none
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageV2: FfiConverterRustBuffer {
    typealias SwiftType = MessageV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageV2 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .plainText(plaintext: try FfiConverterTypePlaintextMessage.read(from: &buf)
        )
        
        case 2: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageV2, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .plainText(plaintext):
            writeInt(&buf, Int32(1))
            FfiConverterTypePlaintextMessage.write(plaintext, into: &buf)
            
        
        case .none:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageV2_lift(_ buf: RustBuffer) throws -> MessageV2 {
    return try FfiConverterTypeMessageV2.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageV2_lower(_ value: MessageV2) -> RustBuffer {
    return FfiConverterTypeMessageV2.lower(value)
}


extension MessageV2: Sendable {} 
extension MessageV2: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The outcome of the `build` function from `MnemonicBuilder`.
 */

public enum MnemonicValidationOutcome {
    
    /**
     * The mnemonic words were valid
     */
    case valid
    /**
     * The mnemonic words were invalid
     */
    case invalid(indicesInMnemonic: [UInt16]
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMnemonicValidationOutcome: FfiConverterRustBuffer {
    typealias SwiftType = MnemonicValidationOutcome

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicValidationOutcome {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .valid
        
        case 2: return .invalid(indicesInMnemonic: try FfiConverterSequenceUInt16.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MnemonicValidationOutcome, into buf: inout [UInt8]) {
        switch value {
        
        
        case .valid:
            writeInt(&buf, Int32(1))
        
        
        case let .invalid(indicesInMnemonic):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt16.write(indicesInMnemonic, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonicValidationOutcome_lift(_ buf: RustBuffer) throws -> MnemonicValidationOutcome {
    return try FfiConverterTypeMnemonicValidationOutcome.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMnemonicValidationOutcome_lower(_ value: MnemonicValidationOutcome) -> RustBuffer {
    return FfiConverterTypeMnemonicValidationOutcome.lower(value)
}


extension MnemonicValidationOutcome: Sendable {} 
extension MnemonicValidationOutcome: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NfcTagArculusInteractonPurpose {
    
    case identifyingCard
    case configuringCardMnemonic
    case restoringCardPin(ArculusCardFactorSource
    )
    case signTransaction(ArculusCardFactorSource
    )
    case signPreAuth(ArculusCardFactorSource
    )
    case proveOwnership(ArculusCardFactorSource
    )
    case derivingPublicKeys(ArculusCardFactorSource
    )
    case verifyingPin(ArculusCardFactorSource
    )
    case configuringCardPin(ArculusCardFactorSource
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNFCTagArculusInteractonPurpose: FfiConverterRustBuffer {
    typealias SwiftType = NfcTagArculusInteractonPurpose

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NfcTagArculusInteractonPurpose {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .identifyingCard
        
        case 2: return .configuringCardMnemonic
        
        case 3: return .restoringCardPin(try FfiConverterTypeArculusCardFactorSource.read(from: &buf)
        )
        
        case 4: return .signTransaction(try FfiConverterTypeArculusCardFactorSource.read(from: &buf)
        )
        
        case 5: return .signPreAuth(try FfiConverterTypeArculusCardFactorSource.read(from: &buf)
        )
        
        case 6: return .proveOwnership(try FfiConverterTypeArculusCardFactorSource.read(from: &buf)
        )
        
        case 7: return .derivingPublicKeys(try FfiConverterTypeArculusCardFactorSource.read(from: &buf)
        )
        
        case 8: return .verifyingPin(try FfiConverterTypeArculusCardFactorSource.read(from: &buf)
        )
        
        case 9: return .configuringCardPin(try FfiConverterTypeArculusCardFactorSource.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NfcTagArculusInteractonPurpose, into buf: inout [UInt8]) {
        switch value {
        
        
        case .identifyingCard:
            writeInt(&buf, Int32(1))
        
        
        case .configuringCardMnemonic:
            writeInt(&buf, Int32(2))
        
        
        case let .restoringCardPin(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeArculusCardFactorSource.write(v1, into: &buf)
            
        
        case let .signTransaction(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeArculusCardFactorSource.write(v1, into: &buf)
            
        
        case let .signPreAuth(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeArculusCardFactorSource.write(v1, into: &buf)
            
        
        case let .proveOwnership(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeArculusCardFactorSource.write(v1, into: &buf)
            
        
        case let .derivingPublicKeys(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeArculusCardFactorSource.write(v1, into: &buf)
            
        
        case let .verifyingPin(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeArculusCardFactorSource.write(v1, into: &buf)
            
        
        case let .configuringCardPin(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeArculusCardFactorSource.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNFCTagArculusInteractonPurpose_lift(_ buf: RustBuffer) throws -> NfcTagArculusInteractonPurpose {
    return try FfiConverterTypeNFCTagArculusInteractonPurpose.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNFCTagArculusInteractonPurpose_lower(_ value: NfcTagArculusInteractonPurpose) -> RustBuffer {
    return FfiConverterTypeNFCTagArculusInteractonPurpose.lower(value)
}


extension NfcTagArculusInteractonPurpose: Sendable {} 
extension NfcTagArculusInteractonPurpose: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NfcTagDriverPurpose {
    
    case arculus(NfcTagArculusInteractonPurpose
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNFCTagDriverPurpose: FfiConverterRustBuffer {
    typealias SwiftType = NfcTagDriverPurpose

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NfcTagDriverPurpose {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .arculus(try FfiConverterTypeNFCTagArculusInteractonPurpose.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NfcTagDriverPurpose, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .arculus(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNFCTagArculusInteractonPurpose.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNFCTagDriverPurpose_lift(_ buf: RustBuffer) throws -> NfcTagDriverPurpose {
    return try FfiConverterTypeNFCTagDriverPurpose.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNFCTagDriverPurpose_lower(_ value: NfcTagDriverPurpose) -> RustBuffer {
    return FfiConverterTypeNFCTagDriverPurpose.lower(value)
}


extension NfcTagDriverPurpose: Sendable {} 
extension NfcTagDriverPurpose: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Reason why some FactorSource was neglected, either explicitly skipped by the user
 * or implicitly neglected due to failure.
 */

public enum NeglectFactorReason {
    
    /**
     * A FactorSource got neglected since user explicitly skipped it.
     */
    case userExplicitlySkipped
    /**
     * A FactorSource got neglected implicitly due to failure
     */
    case failure
    /**
     * A FactorSource got neglected implicitly since it is irrelevant,
     * all transactions which references the FactorSource have already
     * failed, thus pointless in using it.
     */
    case irrelevant
    /**
     * We simulate neglect in order to see what the status of petitions
     * would be if a FactorSource would be neglected.
     */
    case simulation
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNeglectFactorReason: FfiConverterRustBuffer {
    typealias SwiftType = NeglectFactorReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NeglectFactorReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .userExplicitlySkipped
        
        case 2: return .failure
        
        case 3: return .irrelevant
        
        case 4: return .simulation
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NeglectFactorReason, into buf: inout [UInt8]) {
        switch value {
        
        
        case .userExplicitlySkipped:
            writeInt(&buf, Int32(1))
        
        
        case .failure:
            writeInt(&buf, Int32(2))
        
        
        case .irrelevant:
            writeInt(&buf, Int32(3))
        
        
        case .simulation:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNeglectFactorReason_lift(_ buf: RustBuffer) throws -> NeglectFactorReason {
    return try FfiConverterTypeNeglectFactorReason.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNeglectFactorReason_lower(_ value: NeglectFactorReason) -> RustBuffer {
    return FfiConverterTypeNeglectFactorReason.lower(value)
}


extension NeglectFactorReason: Sendable {} 
extension NeglectFactorReason: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NetworkId : UInt8 {
    
    /**
     * Mainnet (0x01 / 0d01)
     *
     * The Radix public network.
     *
     * https://github.com/radixdlt/radixdlt-scrypto/blob/v1.0.1/radix-engine-common/src/network/mod.rs#L79
     */
    case mainnet = 1
    /**
     * Stokenet (0x02 / 0d02)
     *
     * The public testnet for Radix.
     *
     * https://github.com/radixdlt/radixdlt-scrypto/blob/v1.0.1/radix-engine-common/src/network/mod.rs#L71
     */
    case stokenet = 2
    /**
     * Adapanet (0x0a / 0d10
     */
    case adapanet = 10
    /**
     * Nebunet (0x0b / 0d11 )
     *
     * The first Betanet of Babylon
     */
    case nebunet = 11
    /**
     * Kisharnet (0x0c / 0d12)
     *
     * The first release candidate of Babylon (RCnet v1)
     */
    case kisharnet = 12
    /**
     * Ansharnet (0x0d / 0d13)
     *
     * The second release candidate of Babylon (RCnet v2)
     */
    case ansharnet = 13
    /**
     * Zabanet (0x0e / 0d14)
     *
     * The third release candidate of Babylon (RCnet v3)
     */
    case zabanet = 14
    /**
     * Enkinet (0x21 / 0d33)
     *
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L94
     */
    case enkinet = 33
    /**
     * Hammunet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L95
     * Decimal value: 34
     */
    case hammunet = 34
    /**
     * Nergalnet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L96
     * Decimal value: 35
     */
    case nergalnet = 35
    /**
     * Mardunet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L97
     * Decimal value: 36
     */
    case mardunet = 36
    /**
     * Simulator (0xf2 / 0d242)
     */
    case simulator = 242
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetworkID: FfiConverterRustBuffer {
    typealias SwiftType = NetworkId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mainnet
        
        case 2: return .stokenet
        
        case 3: return .adapanet
        
        case 4: return .nebunet
        
        case 5: return .kisharnet
        
        case 6: return .ansharnet
        
        case 7: return .zabanet
        
        case 8: return .enkinet
        
        case 9: return .hammunet
        
        case 10: return .nergalnet
        
        case 11: return .mardunet
        
        case 12: return .simulator
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NetworkId, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mainnet:
            writeInt(&buf, Int32(1))
        
        
        case .stokenet:
            writeInt(&buf, Int32(2))
        
        
        case .adapanet:
            writeInt(&buf, Int32(3))
        
        
        case .nebunet:
            writeInt(&buf, Int32(4))
        
        
        case .kisharnet:
            writeInt(&buf, Int32(5))
        
        
        case .ansharnet:
            writeInt(&buf, Int32(6))
        
        
        case .zabanet:
            writeInt(&buf, Int32(7))
        
        
        case .enkinet:
            writeInt(&buf, Int32(8))
        
        
        case .hammunet:
            writeInt(&buf, Int32(9))
        
        
        case .nergalnet:
            writeInt(&buf, Int32(10))
        
        
        case .mardunet:
            writeInt(&buf, Int32(11))
        
        
        case .simulator:
            writeInt(&buf, Int32(12))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkID_lift(_ buf: RustBuffer) throws -> NetworkId {
    return try FfiConverterTypeNetworkID.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkID_lower(_ value: NetworkId) -> RustBuffer {
    return FfiConverterTypeNetworkID.lower(value)
}


extension NetworkId: Sendable {} 
extension NetworkId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NetworkMethod {
    
    case post
    case get
    case head
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetworkMethod: FfiConverterRustBuffer {
    typealias SwiftType = NetworkMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .post
        
        case 2: return .get
        
        case 3: return .head
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NetworkMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .post:
            writeInt(&buf, Int32(1))
        
        
        case .get:
            writeInt(&buf, Int32(2))
        
        
        case .head:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkMethod_lift(_ buf: RustBuffer) throws -> NetworkMethod {
    return try FfiConverterTypeNetworkMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetworkMethod_lower(_ value: NetworkMethod) -> RustBuffer {
    return FfiConverterTypeNetworkMethod.lower(value)
}


extension NetworkMethod: Sendable {} 
extension NetworkMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NonFungibleLocalId {
    
    /**
     * Unsigned integers, up to u64.
     *
     * Create using `NonFungibleLocalId::integer(...)`.
     */
    case integer(value: UInt64
    )
    /**
     * String matching `[_0-9a-zA-Z]{1,64}`.
     *
     * Create using `NonFungibleLocalId::string(...).unwrap()`.
     */
    case str(value: NonFungibleLocalIdString
    )
    /**
     * Bytes, of length between 1 and 64.
     *
     * Create using `NonFungibleLocalId::bytes(...).unwrap()`.
     */
    case bytes(value: NonEmptyMax64Bytes
    )
    /**
     * RUID, v4, variant 1, big endian. See https://www.rfc-editor.org/rfc/rfc4122
     *
     * Create using `NonFungibleLocalId::ruid(...).unwrap()`.
     */
    case ruid(value: Exactly32Bytes
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleLocalId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .integer(value: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .str(value: try FfiConverterTypeNonFungibleLocalIdString.read(from: &buf)
        )
        
        case 3: return .bytes(value: try FfiConverterTypeNonEmptyMax64Bytes.read(from: &buf)
        )
        
        case 4: return .ruid(value: try FfiConverterTypeExactly32Bytes.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleLocalId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .integer(value):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(value, into: &buf)
            
        
        case let .str(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNonFungibleLocalIdString.write(value, into: &buf)
            
        
        case let .bytes(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNonEmptyMax64Bytes.write(value, into: &buf)
            
        
        case let .ruid(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeExactly32Bytes.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonFungibleLocalId_lift(_ buf: RustBuffer) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonFungibleLocalId_lower(_ value: NonFungibleLocalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalId.lower(value)
}


extension NonFungibleLocalId: Sendable {} 
extension NonFungibleLocalId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NonFungibleResourceIndicator {
    
    case guaranteed(ids: [NonFungibleLocalId]
    )
    case predicted(predictedIds: PredictedNonFungibleLocalIds
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNonFungibleResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .guaranteed(ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        case 2: return .predicted(predictedIds: try FfiConverterTypePredictedNonFungibleLocalIds.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .guaranteed(ids):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        
        case let .predicted(predictedIds):
            writeInt(&buf, Int32(2))
            FfiConverterTypePredictedNonFungibleLocalIds.write(predictedIds, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonFungibleResourceIndicator_lift(_ buf: RustBuffer) throws -> NonFungibleResourceIndicator {
    return try FfiConverterTypeNonFungibleResourceIndicator.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNonFungibleResourceIndicator_lower(_ value: NonFungibleResourceIndicator) -> RustBuffer {
    return FfiConverterTypeNonFungibleResourceIndicator.lower(value)
}


extension NonFungibleResourceIndicator: Sendable {} 
extension NonFungibleResourceIndicator: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PersonaDataNameVariant {
    
    case western
    case eastern
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersonaDataNameVariant: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataNameVariant

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataNameVariant {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .western
        
        case 2: return .eastern
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PersonaDataNameVariant, into buf: inout [UInt8]) {
        switch value {
        
        
        case .western:
            writeInt(&buf, Int32(1))
        
        
        case .eastern:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataNameVariant_lift(_ buf: RustBuffer) throws -> PersonaDataNameVariant {
    return try FfiConverterTypePersonaDataNameVariant.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataNameVariant_lower(_ value: PersonaDataNameVariant) -> RustBuffer {
    return FfiConverterTypePersonaDataNameVariant.lower(value)
}


extension PersonaDataNameVariant: Sendable {} 
extension PersonaDataNameVariant: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The kind of the Pool, either One, Two or Multi resources.
 */

public enum PoolKind {
    
    /**
     * A Pool to which user can contribute liquidity of a single
     * resource kind.
     */
    case oneResource
    /**
     * A Pool to which user can contribute liquidity of two different
     * resources
     */
    case twoResources
    /**
     * A Pool to which user can contribute liquidity of many different
     * resources
     */
    case multiResources
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePoolKind: FfiConverterRustBuffer {
    typealias SwiftType = PoolKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PoolKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .oneResource
        
        case 2: return .twoResources
        
        case 3: return .multiResources
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PoolKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .oneResource:
            writeInt(&buf, Int32(1))
        
        
        case .twoResources:
            writeInt(&buf, Int32(2))
        
        
        case .multiResources:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoolKind_lift(_ buf: RustBuffer) throws -> PoolKind {
    return try FfiConverterTypePoolKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePoolKind_lower(_ value: PoolKind) -> RustBuffer {
    return FfiConverterTypePoolKind.lower(value)
}


extension PoolKind: Sendable {} 
extension PoolKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * This is the result of the Pre-Auth preview analysis.
 * It contains all the information needed to compute and display the transaction details to the user.
 */

public enum PreAuthToReview {
    
    case `open`(PreAuthOpenManifest
    )
    case enclosed(PreAuthEnclosedManifest
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePreAuthToReview: FfiConverterRustBuffer {
    typealias SwiftType = PreAuthToReview

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreAuthToReview {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`open`(try FfiConverterTypePreAuthOpenManifest.read(from: &buf)
        )
        
        case 2: return .enclosed(try FfiConverterTypePreAuthEnclosedManifest.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PreAuthToReview, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`open`(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypePreAuthOpenManifest.write(v1, into: &buf)
            
        
        case let .enclosed(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypePreAuthEnclosedManifest.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreAuthToReview_lift(_ buf: RustBuffer) throws -> PreAuthToReview {
    return try FfiConverterTypePreAuthToReview.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreAuthToReview_lower(_ value: PreAuthToReview) -> RustBuffer {
    return FfiConverterTypePreAuthToReview.lower(value)
}


extension PreAuthToReview: Sendable {} 
extension PreAuthToReview: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * This is the result of the Pre-Authorization status polling for a given Subintent.
 */

public enum PreAuthorizationStatus {
    
    /**
     * The Pre-Authorization has successfully been submitted in a transaction with the given intent hash.
     */
    case success(intentHash: TransactionIntentHash
    )
    /**
     * The Pre-Authorization has expired before being successfully submitted.
     */
    case expired
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePreAuthorizationStatus: FfiConverterRustBuffer {
    typealias SwiftType = PreAuthorizationStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreAuthorizationStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .success(intentHash: try FfiConverterTypeTransactionIntentHash.read(from: &buf)
        )
        
        case 2: return .expired
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PreAuthorizationStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .success(intentHash):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTransactionIntentHash.write(intentHash, into: &buf)
            
        
        case .expired:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreAuthorizationStatus_lift(_ buf: RustBuffer) throws -> PreAuthorizationStatus {
    return try FfiConverterTypePreAuthorizationStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePreAuthorizationStatus_lower(_ value: PreAuthorizationStatus) -> RustBuffer {
    return FfiConverterTypePreAuthorizationStatus.lower(value)
}


extension PreAuthorizationStatus: Sendable {} 
extension PreAuthorizationStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of analyzing a file (bytes), containing either a Profile
 * which we were able to successfully JSON deserialize from the bytes,
 * or EncryptedProfile for which wallets will continue prompting the
 * user for an encryption password and then call JSON deserialize
 * of `EncryptedProfileSnapshot` using [`Profile::new_from_encryption_bytes`](Profile::new_from_encryption_bytes)
 * or if we failed to parse as Profile and `EncryptedProfileSnapshot`
 * then `NotProfile` is used, indicating that the bytes is not at all
 * a Profile.
 */

public enum ProfileFileContents {
    
    /**
     * The JSON deserialized Profile from some bytes.
     */
    case plaintextProfile(Profile
    )
    /**
     * We successfully JSON deserialized the bytes into
     * `EncryptedProfileSnapshot`, the wallets should proceed
     * with asking the user for the decryption password.
     */
    case encryptedProfile
    /**
     * The bytes is neither a valid `Profile` nor `EncryptedProfile`,
     * it is either a corrupt file or it is not at all a Profile file,
     * contrary to the users beliefs (or the user accidentally selected
     * a random file...)
     */
    case notProfile
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProfileFileContents: FfiConverterRustBuffer {
    typealias SwiftType = ProfileFileContents

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileFileContents {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .plaintextProfile(try FfiConverterTypeProfile.read(from: &buf)
        )
        
        case 2: return .encryptedProfile
        
        case 3: return .notProfile
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileFileContents, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .plaintextProfile(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeProfile.write(v1, into: &buf)
            
        
        case .encryptedProfile:
            writeInt(&buf, Int32(2))
        
        
        case .notProfile:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileFileContents_lift(_ buf: RustBuffer) throws -> ProfileFileContents {
    return try FfiConverterTypeProfileFileContents.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileFileContents_lower(_ value: ProfileFileContents) -> RustBuffer {
    return FfiConverterTypeProfileFileContents.lower(value)
}


extension ProfileFileContents: Sendable {} 
extension ProfileFileContents: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The version of the Profile Snapshot data format (JSON).
 */

public enum ProfileSnapshotVersion : UInt16 {
    
    /**
     * The version we went live with on Babylon mainnet 2023-09-28,
     * shipped with iOS 1.0.0 (7) and Android v 1.0.0.
     */
    case v100 = 100
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProfileSnapshotVersion: FfiConverterRustBuffer {
    typealias SwiftType = ProfileSnapshotVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileSnapshotVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v100
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileSnapshotVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v100:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileSnapshotVersion_lift(_ buf: RustBuffer) throws -> ProfileSnapshotVersion {
    return try FfiConverterTypeProfileSnapshotVersion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileSnapshotVersion_lower(_ value: ProfileSnapshotVersion) -> RustBuffer {
    return FfiConverterTypeProfileSnapshotVersion.lower(value)
}


extension ProfileSnapshotVersion: Sendable {} 
extension ProfileSnapshotVersion: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ProfileState {
    
    /**
     * When no profile exists in secure storage when OS is booted.
     */
    case none
    /**
     * When the profile snapshot retrieved from secure storage failed to convert into a
     * valid Profile.
     */
    case incompatible(CommonError
    )
    /**
     * When a valid 'Profile' exists. This can either happen when the os boots, or a profile is
     * restored, or the user creates a new profile.
     */
    case loaded(Profile
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProfileState: FfiConverterRustBuffer {
    typealias SwiftType = ProfileState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .incompatible(try FfiConverterTypeCommonError.read(from: &buf)
        )
        
        case 3: return .loaded(try FfiConverterTypeProfile.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case let .incompatible(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeCommonError.write(v1, into: &buf)
            
        
        case let .loaded(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeProfile.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileState_lift(_ buf: RustBuffer) throws -> ProfileState {
    return try FfiConverterTypeProfileState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileState_lower(_ value: ProfileState) -> RustBuffer {
    return FfiConverterTypeProfileState.lower(value)
}


extension ProfileState: Sendable {} 
extension ProfileState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The Profile to which we want to check the entities linked to a factor source.
 */

public enum ProfileToCheck {
    
    /**
     * We should check against the current Profile.
     */
    case current
    /**
     * We should check against a specific Profile.
     * Useful when we are in the Import Mnenmonics flow.
     */
    case specific(Profile
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProfileToCheck: FfiConverterRustBuffer {
    typealias SwiftType = ProfileToCheck

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileToCheck {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .current
        
        case 2: return .specific(try FfiConverterTypeProfile.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileToCheck, into buf: inout [UInt8]) {
        switch value {
        
        
        case .current:
            writeInt(&buf, Int32(1))
        
        
        case let .specific(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeProfile.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileToCheck_lift(_ buf: RustBuffer) throws -> ProfileToCheck {
    return try FfiConverterTypeProfileToCheck.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileToCheck_lower(_ value: ProfileToCheck) -> RustBuffer {
    return FfiConverterTypeProfileToCheck.lower(value)
}


extension ProfileToCheck: Sendable {} 
extension ProfileToCheck: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Intermediary state of changing the security structure of an entity.
 * Only a single variant for now but we might update it later. E.g.
 * we could have one state for when user has selected a shield but not
 * derived the factor instances yet.
 */

public enum ProvisionalSecurifiedConfig {
    
    /**
     * User has fully prepared a `SecurityStructureOfFactorInstances` but
     * not made a transaction to apply it to the entity yet.
     */
    case factorInstancesDerived(value: SecurityStructureOfFactorInstances
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProvisionalSecurifiedConfig: FfiConverterRustBuffer {
    typealias SwiftType = ProvisionalSecurifiedConfig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProvisionalSecurifiedConfig {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .factorInstancesDerived(value: try FfiConverterTypeSecurityStructureOfFactorInstances.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProvisionalSecurifiedConfig, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .factorInstancesDerived(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecurityStructureOfFactorInstances.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalSecurifiedConfig_lift(_ buf: RustBuffer) throws -> ProvisionalSecurifiedConfig {
    return try FfiConverterTypeProvisionalSecurifiedConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProvisionalSecurifiedConfig_lower(_ value: ProvisionalSecurifiedConfig) -> RustBuffer {
    return FfiConverterTypeProvisionalSecurifiedConfig.lower(value)
}


extension ProvisionalSecurifiedConfig: Sendable {} 
extension ProvisionalSecurifiedConfig: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of supported public keys on different curves, supported
 * curves are `secp256k1` and `Curve25519`
 */

public enum PublicKey {
    
    /**
     * An Ed25519 public key used to verify cryptographic signatures.
     */
    case ed25519(Ed25519PublicKey
    )
    /**
     * A secp256k1 public key used to verify cryptographic signatures (ECDSA signatures).
     */
    case secp256k1(Secp256k1PublicKey
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ed25519(try FfiConverterTypeEd25519PublicKey.read(from: &buf)
        )
        
        case 2: return .secp256k1(try FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ed25519(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEd25519PublicKey.write(v1, into: &buf)
            
        
        case let .secp256k1(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecp256k1PublicKey.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicKey_lift(_ buf: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}


extension PublicKey: Sendable {} 
extension PublicKey: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Hashes of public keys, either Ed25519PublicKey or Secp256k1PublicKey
 */

public enum PublicKeyHash {
    
    case ed25519(value: Exactly29Bytes
    )
    case secp256k1(value: Exactly29Bytes
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = PublicKeyHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKeyHash {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ed25519(value: try FfiConverterTypeExactly29Bytes.read(from: &buf)
        )
        
        case 2: return .secp256k1(value: try FfiConverterTypeExactly29Bytes.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKeyHash, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ed25519(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeExactly29Bytes.write(value, into: &buf)
            
        
        case let .secp256k1(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeExactly29Bytes.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicKeyHash_lift(_ buf: RustBuffer) throws -> PublicKeyHash {
    return try FfiConverterTypePublicKeyHash.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicKeyHash_lower(_ value: PublicKeyHash) -> RustBuffer {
    return FfiConverterTypePublicKeyHash.lower(value)
}


extension PublicKeyHash: Sendable {} 
extension PublicKeyHash: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
 * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
 * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
 */

public enum RadixConnectPurpose {
    
    case general
    case unknown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRadixConnectPurpose: FfiConverterRustBuffer {
    typealias SwiftType = RadixConnectPurpose

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectPurpose {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .general
        
        case 2: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RadixConnectPurpose, into buf: inout [UInt8]) {
        switch value {
        
        
        case .general:
            writeInt(&buf, Int32(1))
        
        
        case .unknown:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixConnectPurpose_lift(_ buf: RustBuffer) throws -> RadixConnectPurpose {
    return try FfiConverterTypeRadixConnectPurpose.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRadixConnectPurpose_lower(_ value: RadixConnectPurpose) -> RustBuffer {
    return FfiConverterTypeRadixConnectPurpose.lower(value)
}


extension RadixConnectPurpose: Sendable {} 
extension RadixConnectPurpose: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A quantifier of a quantity, either `atLeast` or `exactly`, as in
 * "I want AT LEAST 3" or "I want EXACTLY 10".
 *
 * This is typically sent by a Dapp when requesting access to accounts
 * or PersonaData.
 */

public enum RequestedNumberQuantifier {
    
    /**
     * (Request access to) *exactly* N many of something, where quantity `N` is
     * not part of this enum, e.g. "I want EXACTLY 2 accounts"
     */
    case exactly
    /**
     * (Request access to) *at least* N many of something, where quantity `N` is
     * not part of this enum, e.g. "I want AT LEAST 3 accounts"
     */
    case atLeast
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestedNumberQuantifier: FfiConverterRustBuffer {
    typealias SwiftType = RequestedNumberQuantifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedNumberQuantifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .exactly
        
        case 2: return .atLeast
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestedNumberQuantifier, into buf: inout [UInt8]) {
        switch value {
        
        
        case .exactly:
            writeInt(&buf, Int32(1))
        
        
        case .atLeast:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedNumberQuantifier_lift(_ buf: RustBuffer) throws -> RequestedNumberQuantifier {
    return try FfiConverterTypeRequestedNumberQuantifier.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedNumberQuantifier_lower(_ value: RequestedNumberQuantifier) -> RustBuffer {
    return FfiConverterTypeRequestedNumberQuantifier.lower(value)
}


extension RequestedNumberQuantifier: Sendable {} 
extension RequestedNumberQuantifier: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The set of instructions that is only allowed in manifests created by the
 * wallet itself.
 */

public enum ReservedInstruction {
    
    case accountLockFee
    case accountSecurify
    case identitySecurify
    case accessControllerMethod
    case accountLockOwnerKeysMetadataField
    case accountUpdateOwnerKeysMetadataField
    case identityLockOwnerKeysMetadataField
    case identityUpdateOwnerKeysMetadataField
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReservedInstruction: FfiConverterRustBuffer {
    typealias SwiftType = ReservedInstruction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReservedInstruction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .accountLockFee
        
        case 2: return .accountSecurify
        
        case 3: return .identitySecurify
        
        case 4: return .accessControllerMethod
        
        case 5: return .accountLockOwnerKeysMetadataField
        
        case 6: return .accountUpdateOwnerKeysMetadataField
        
        case 7: return .identityLockOwnerKeysMetadataField
        
        case 8: return .identityUpdateOwnerKeysMetadataField
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReservedInstruction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .accountLockFee:
            writeInt(&buf, Int32(1))
        
        
        case .accountSecurify:
            writeInt(&buf, Int32(2))
        
        
        case .identitySecurify:
            writeInt(&buf, Int32(3))
        
        
        case .accessControllerMethod:
            writeInt(&buf, Int32(4))
        
        
        case .accountLockOwnerKeysMetadataField:
            writeInt(&buf, Int32(5))
        
        
        case .accountUpdateOwnerKeysMetadataField:
            writeInt(&buf, Int32(6))
        
        
        case .identityLockOwnerKeysMetadataField:
            writeInt(&buf, Int32(7))
        
        
        case .identityUpdateOwnerKeysMetadataField:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReservedInstruction_lift(_ buf: RustBuffer) throws -> ReservedInstruction {
    return try FfiConverterTypeReservedInstruction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReservedInstruction_lower(_ value: ReservedInstruction) -> RustBuffer {
    return FfiConverterTypeReservedInstruction.lower(value)
}


extension ReservedInstruction: Sendable {} 
extension ReservedInstruction: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum representation of an resource for which the user can set up its preferences.
 */

public enum ResourceIdentifier {
    
    case fungible(ResourceAddress
    )
    case nonFungible(ResourceAddress
    )
    case poolUnit(PoolAddress
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResourceIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = ResourceIdentifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceIdentifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fungible(try FfiConverterTypeResourceAddress.read(from: &buf)
        )
        
        case 2: return .nonFungible(try FfiConverterTypeResourceAddress.read(from: &buf)
        )
        
        case 3: return .poolUnit(try FfiConverterTypePoolAddress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceIdentifier, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fungible(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(v1, into: &buf)
            
        
        case let .nonFungible(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(v1, into: &buf)
            
        
        case let .poolUnit(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypePoolAddress.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceIdentifier_lift(_ buf: RustBuffer) throws -> ResourceIdentifier {
    return try FfiConverterTypeResourceIdentifier.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceIdentifier_lower(_ value: ResourceIdentifier) -> RustBuffer {
    return FfiConverterTypeResourceIdentifier.lower(value)
}


extension ResourceIdentifier: Sendable {} 
extension ResourceIdentifier: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourceIndicator {
    
    case fungible(resourceAddress: ResourceAddress, indicator: FungibleResourceIndicator
    )
    case nonFungible(resourceAddress: ResourceAddress, indicator: NonFungibleResourceIndicator
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = ResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fungible(resourceAddress: try FfiConverterTypeResourceAddress.read(from: &buf), indicator: try FfiConverterTypeFungibleResourceIndicator.read(from: &buf)
        )
        
        case 2: return .nonFungible(resourceAddress: try FfiConverterTypeResourceAddress.read(from: &buf), indicator: try FfiConverterTypeNonFungibleResourceIndicator.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fungible(resourceAddress,indicator):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeFungibleResourceIndicator.write(indicator, into: &buf)
            
        
        case let .nonFungible(resourceAddress,indicator):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeNonFungibleResourceIndicator.write(indicator, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceIndicator_lift(_ buf: RustBuffer) throws -> ResourceIndicator {
    return try FfiConverterTypeResourceIndicator.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceIndicator_lower(_ value: ResourceIndicator) -> RustBuffer {
    return FfiConverterTypeResourceIndicator.lower(value)
}


extension ResourceIndicator: Sendable {} 
extension ResourceIndicator: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The addresses that can be added as exception to the `DepositRule`
 */

public enum ResourceOrNonFungible {
    
    case resource(value: ResourceAddress
    )
    case nonFungible(value: NonFungibleGlobalId
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = ResourceOrNonFungible

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceOrNonFungible {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .resource(value: try FfiConverterTypeResourceAddress.read(from: &buf)
        )
        
        case 2: return .nonFungible(value: try FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceOrNonFungible, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .resource(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(value, into: &buf)
            
        
        case let .nonFungible(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNonFungibleGlobalId.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceOrNonFungible_lift(_ buf: RustBuffer) throws -> ResourceOrNonFungible {
    return try FfiConverterTypeResourceOrNonFungible.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceOrNonFungible_lower(_ value: ResourceOrNonFungible) -> RustBuffer {
    return FfiConverterTypeResourceOrNonFungible.lower(value)
}


extension ResourceOrNonFungible: Sendable {} 
extension ResourceOrNonFungible: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourcePreference {
    
    case allowed
    case disallowed
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResourcePreference: FfiConverterRustBuffer {
    typealias SwiftType = ResourcePreference

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreference {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allowed
        
        case 2: return .disallowed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourcePreference, into buf: inout [UInt8]) {
        switch value {
        
        
        case .allowed:
            writeInt(&buf, Int32(1))
        
        
        case .disallowed:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourcePreference_lift(_ buf: RustBuffer) throws -> ResourcePreference {
    return try FfiConverterTypeResourcePreference.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourcePreference_lower(_ value: ResourcePreference) -> RustBuffer {
    return FfiConverterTypeResourcePreference.lower(value)
}


extension ResourcePreference: Sendable {} 
extension ResourcePreference: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourcePreferenceUpdate {
    
    case set(value: ResourcePreference
    )
    case remove
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    typealias SwiftType = ResourcePreferenceUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreferenceUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .set(value: try FfiConverterTypeResourcePreference.read(from: &buf)
        )
        
        case 2: return .remove
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourcePreferenceUpdate, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .set(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourcePreference.write(value, into: &buf)
            
        
        case .remove:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourcePreferenceUpdate_lift(_ buf: RustBuffer) throws -> ResourcePreferenceUpdate {
    return try FfiConverterTypeResourcePreferenceUpdate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourcePreferenceUpdate_lower(_ value: ResourcePreferenceUpdate) -> RustBuffer {
    return FfiConverterTypeResourcePreferenceUpdate.lower(value)
}


extension ResourcePreferenceUpdate: Sendable {} 
extension ResourcePreferenceUpdate: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourceSpecifier {
    
    case fungible(resourceAddress: ResourceAddress, amount: Decimal192
    )
    case nonFungible(resourceAddress: ResourceAddress, ids: [NonFungibleLocalId]
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResourceSpecifier: FfiConverterRustBuffer {
    typealias SwiftType = ResourceSpecifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceSpecifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fungible(resourceAddress: try FfiConverterTypeResourceAddress.read(from: &buf), amount: try FfiConverterTypeDecimal192.read(from: &buf)
        )
        
        case 2: return .nonFungible(resourceAddress: try FfiConverterTypeResourceAddress.read(from: &buf), ids: try FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceSpecifier, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fungible(resourceAddress,amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal192.write(amount, into: &buf)
            
        
        case let .nonFungible(resourceAddress,ids):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceSpecifier_lift(_ buf: RustBuffer) throws -> ResourceSpecifier {
    return try FfiConverterTypeResourceSpecifier.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceSpecifier_lower(_ value: ResourceSpecifier) -> RustBuffer {
    return FfiConverterTypeResourceSpecifier.lower(value)
}


extension ResourceSpecifier: Sendable {} 
extension ResourceSpecifier: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Indicates the visibility of a resource.
 */

public enum ResourceVisibility {
    
    case hidden
    case visible
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResourceVisibility: FfiConverterRustBuffer {
    typealias SwiftType = ResourceVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hidden
        
        case 2: return .visible
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceVisibility, into buf: inout [UInt8]) {
        switch value {
        
        
        case .hidden:
            writeInt(&buf, Int32(1))
        
        
        case .visible:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceVisibility_lift(_ buf: RustBuffer) throws -> ResourceVisibility {
    return try FfiConverterTypeResourceVisibility.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResourceVisibility_lower(_ value: ResourceVisibility) -> RustBuffer {
    return FfiConverterTypeResourceVisibility.lower(value)
}


extension ResourceVisibility: Sendable {} 
extension ResourceVisibility: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A discriminator of a role in a matrix of Factors.
 */

public enum RoleKind {
    
    /**
     * The primary role of some matrix of factors
     */
    case primary
    /**
     * The recovery role of some matrix of factors
     */
    case recovery
    /**
     * The confirmation role of some matrix of factors
     */
    case confirmation
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoleKind: FfiConverterRustBuffer {
    typealias SwiftType = RoleKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoleKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .primary
        
        case 2: return .recovery
        
        case 3: return .confirmation
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoleKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .primary:
            writeInt(&buf, Int32(1))
        
        
        case .recovery:
            writeInt(&buf, Int32(2))
        
        
        case .confirmation:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoleKind_lift(_ buf: RustBuffer) throws -> RoleKind {
    return try FfiConverterTypeRoleKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoleKind_lower(_ value: RoleKind) -> RustBuffer {
    return FfiConverterTypeRoleKind.lower(value)
}


extension RoleKind: Sendable {} 
extension RoleKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Defines the rounding strategy used when you round e.g. `Decimal192`.
 *
 * Following the same naming convention as https://docs.rs/rust_decimal/latest/rust_decimal/enum.RoundingStrategy.html.
 */

public enum RoundingMode {
    
    /**
     * The number is always rounded toward positive infinity, e.g. `3.1 -> 4`, `-3.1 -> -3`.
     */
    case toPositiveInfinity
    /**
     * The number is always rounded toward negative infinity, e.g. `3.1 -> 3`, `-3.1 -> -4`.
     */
    case toNegativeInfinity
    /**
     * The number is always rounded toward zero, e.g. `3.1 -> 3`, `-3.1 -> -3`.
     */
    case toZero
    /**
     * The number is always rounded away from zero, e.g. `3.1 -> 4`, `-3.1 -> -4`.
     */
    case awayFromZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded toward zero, e.g. `3.5 -> 3`, `-3.5 -> -3`.
     */
    case toNearestMidpointTowardZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded away from zero, e.g. `3.5 -> 4`, `-3.5 -> -4`.
     */
    case toNearestMidpointAwayFromZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded toward the nearest even number. Also known as "Bankers Rounding".
     */
    case toNearestMidpointToEven
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoundingMode: FfiConverterRustBuffer {
    typealias SwiftType = RoundingMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoundingMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .toPositiveInfinity
        
        case 2: return .toNegativeInfinity
        
        case 3: return .toZero
        
        case 4: return .awayFromZero
        
        case 5: return .toNearestMidpointTowardZero
        
        case 6: return .toNearestMidpointAwayFromZero
        
        case 7: return .toNearestMidpointToEven
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoundingMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .toPositiveInfinity:
            writeInt(&buf, Int32(1))
        
        
        case .toNegativeInfinity:
            writeInt(&buf, Int32(2))
        
        
        case .toZero:
            writeInt(&buf, Int32(3))
        
        
        case .awayFromZero:
            writeInt(&buf, Int32(4))
        
        
        case .toNearestMidpointTowardZero:
            writeInt(&buf, Int32(5))
        
        
        case .toNearestMidpointAwayFromZero:
            writeInt(&buf, Int32(6))
        
        
        case .toNearestMidpointToEven:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoundingMode_lift(_ buf: RustBuffer) throws -> RoundingMode {
    return try FfiConverterTypeRoundingMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoundingMode_lower(_ value: RoundingMode) -> RustBuffer {
    return FfiConverterTypeRoundingMode.lower(value)
}


extension RoundingMode: Sendable {} 
extension RoundingMode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Elliptic Curves which the SLIP10 derivation algorithm supports.
 *
 * We use SLIP10 for hierarchical deterministic derivation since we
 * prefer using Curve25519 - which is incompatible with BIP32 (BIP44).
 *
 * For for information see [SLIP10 reference](https://github.com/satoshilabs/slips/blob/master/slip-0010.md)
 */

public enum Slip10Curve {
    
    /**
     * Curve25519 which we use for Ed25519 for EdDSA signatures.
     */
    case curve25519
    /**
     * The bitcoin curve, used by Radix Olympia and still valid
     * to support legacy accounts.
     */
    case secp256k1
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSLIP10Curve: FfiConverterRustBuffer {
    typealias SwiftType = Slip10Curve

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Slip10Curve {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .curve25519
        
        case 2: return .secp256k1
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Slip10Curve, into buf: inout [UInt8]) {
        switch value {
        
        
        case .curve25519:
            writeInt(&buf, Int32(1))
        
        
        case .secp256k1:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSLIP10Curve_lift(_ buf: RustBuffer) throws -> Slip10Curve {
    return try FfiConverterTypeSLIP10Curve.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSLIP10Curve_lower(_ value: Slip10Curve) -> RustBuffer {
    return FfiConverterTypeSLIP10Curve.lower(value)
}


extension Slip10Curve: Sendable {} 
extension Slip10Curve: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An error kind that might be returned during access to secure storage driver. These errors are
 * android specific and are defined [here](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt#constants_1)
 * Hosts, can print the error message provided by the system, and can ignore the error if
 * it `is_manual_cancellation`.
 */

public enum SecureStorageAccessErrorKind {
    
    /**
     * The hardware is unavailable. Try again later.
     */
    case hardwareUnavailable
    /**
     * The sensor was unable to process the current image.
     */
    case unableToProcess
    /**
     * The current operation has been running too long and has timed out.
     */
    case timeout
    /**
     * The operation can't be completed because there is not enough device storage remaining.
     */
    case noSpace
    /**
     * The operation was canceled because the biometric sensor is unavailable.
     * This may happen when the user is switched, the device is locked, or another
     * pending operation prevents it.
     */
    case cancelled
    /**
     * The operation was canceled because the API is locked out due to too many attempts.
     * This occurs after 5 failed attempts, and lasts for 30 seconds.
     */
    case lockout
    /**
     * The operation failed due to a vendor-specific error.
     * This error kind may be used by hardware vendors to extend this list to cover
     * errors that don't fall under one of the other predefined categories. Vendors are
     * responsible for providing the strings for these errors.
     *
     * These messages are typically reserved for internal operations such as enrollment
     * but may be used to express any error that is not otherwise covered.
     * In this case, applications are expected to show the error message, but they are advised
     * not to rely on the message ID, since this may vary by vendor and device.
     */
    case vendor
    /**
     * The operation was canceled because `Lockout` occurred too many times. Biometric
     * authentication is disabled until the user unlocks with their device credential
     * (i.e. PIN, pattern, or password).
     */
    case lockoutPermanent
    /**
     * The user canceled the operation.
     * Upon receiving this, applications should use alternate authentication, such as a password.
     * The application should also provide the user a way of returning to biometric authentication,
     * such as a button.
     */
    case userCancelled
    /**
     * The user does not have any biometrics enrolled.
     */
    case noBiometrics
    /**
     * The device does not have the required authentication hardware.
     */
    case hardwareNotPresent
    /**
     * The user pressed the negative button.
     */
    case negativeButton
    /**
     * The device does not have pin, pattern, or password set up.
     */
    case noDeviceCredential
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecureStorageAccessErrorKind: FfiConverterRustBuffer {
    typealias SwiftType = SecureStorageAccessErrorKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageAccessErrorKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hardwareUnavailable
        
        case 2: return .unableToProcess
        
        case 3: return .timeout
        
        case 4: return .noSpace
        
        case 5: return .cancelled
        
        case 6: return .lockout
        
        case 7: return .vendor
        
        case 8: return .lockoutPermanent
        
        case 9: return .userCancelled
        
        case 10: return .noBiometrics
        
        case 11: return .hardwareNotPresent
        
        case 12: return .negativeButton
        
        case 13: return .noDeviceCredential
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecureStorageAccessErrorKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .hardwareUnavailable:
            writeInt(&buf, Int32(1))
        
        
        case .unableToProcess:
            writeInt(&buf, Int32(2))
        
        
        case .timeout:
            writeInt(&buf, Int32(3))
        
        
        case .noSpace:
            writeInt(&buf, Int32(4))
        
        
        case .cancelled:
            writeInt(&buf, Int32(5))
        
        
        case .lockout:
            writeInt(&buf, Int32(6))
        
        
        case .vendor:
            writeInt(&buf, Int32(7))
        
        
        case .lockoutPermanent:
            writeInt(&buf, Int32(8))
        
        
        case .userCancelled:
            writeInt(&buf, Int32(9))
        
        
        case .noBiometrics:
            writeInt(&buf, Int32(10))
        
        
        case .hardwareNotPresent:
            writeInt(&buf, Int32(11))
        
        
        case .negativeButton:
            writeInt(&buf, Int32(12))
        
        
        case .noDeviceCredential:
            writeInt(&buf, Int32(13))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecureStorageAccessErrorKind_lift(_ buf: RustBuffer) throws -> SecureStorageAccessErrorKind {
    return try FfiConverterTypeSecureStorageAccessErrorKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecureStorageAccessErrorKind_lower(_ value: SecureStorageAccessErrorKind) -> RustBuffer {
    return FfiConverterTypeSecureStorageAccessErrorKind.lower(value)
}


extension SecureStorageAccessErrorKind: Sendable {} 
extension SecureStorageAccessErrorKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SecureStorageKey {
    
    case hostId
    case deviceFactorSourceMnemonic(factorSourceId: FactorSourceIdFromHash
    )
    case profileSnapshot(profileId: ProfileId
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecureStorageKey: FfiConverterRustBuffer {
    typealias SwiftType = SecureStorageKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .hostId
        
        case 2: return .deviceFactorSourceMnemonic(factorSourceId: try FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
        )
        
        case 3: return .profileSnapshot(profileId: try FfiConverterTypeProfileID.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecureStorageKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case .hostId:
            writeInt(&buf, Int32(1))
        
        
        case let .deviceFactorSourceMnemonic(factorSourceId):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFactorSourceIDFromHash.write(factorSourceId, into: &buf)
            
        
        case let .profileSnapshot(profileId):
            writeInt(&buf, Int32(3))
            FfiConverterTypeProfileID.write(profileId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecureStorageKey_lift(_ buf: RustBuffer) throws -> SecureStorageKey {
    return try FfiConverterTypeSecureStorageKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecureStorageKey_lower(_ value: SecureStorageKey) -> RustBuffer {
    return FfiConverterTypeSecureStorageKey.lower(value)
}


extension SecureStorageKey: Sendable {} 
extension SecureStorageKey: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum describing each potential Security Problem the Wallet can encounter.
 *
 * See [the Confluence doc for details][doc].
 *
 * [doc]: https://radixdlt.atlassian.net/wiki/spaces/AT/pages/3392569357/Security-related+Problem+States+in+the+Wallet
 */

public enum SecurityProblem {
    
    /**
     * The given addresses of `accounts` and `personas` are unrecoverable if the user loses their phone, since their corresponding seed phrase has not been written down.
     * NOTE: This definition differs from the one at Confluence since we don't have shields implemented yet.
     */
    case problem3(addresses: AddressesOfEntitiesInBadState
    )
    /**
     * Wallet backups to the cloud arent working (wallet tried to do a backup, and it didnt work within, say, 5 minutes.)
     * This means that currently all accounts and personas are at risk of being practically unrecoverable if the user loses their phone.
     * Also they would lose all of their other non-security wallet settings and data.
     */
    case problem5
    /**
     * Cloud backups are turned off  and user has never done a manual file export. This means that currently all accounts and personas  are at risk of
     * being practically unrecoverable if the user loses their phone. Also, they would lose all of their other non-security wallet settings and data.
     */
    case problem6
    /**
     * Cloud backups are turned off and user previously did a manual file export, but has made a change and havent yet re-exported a file backup that
     * includes that change. This means that any changes made will be lost if the user loses their phone - including control of new accounts/personas theyve
     * created, as well as changed settings or changed/added data.
     */
    case problem7
    /**
     * User has gotten a new phone (and restored their wallet from backup) and the wallet sees that there are accounts without shields using a phone key,
     * meaning they can only be recovered with the seed phrase. (See problem 2) This would also be the state if a user disabled their PIN (and reenabled it), clearing phone keys.
     */
    case problem9(addresses: AddressesOfEntitiesInBadState
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityProblem: FfiConverterRustBuffer {
    typealias SwiftType = SecurityProblem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityProblem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .problem3(addresses: try FfiConverterTypeAddressesOfEntitiesInBadState.read(from: &buf)
        )
        
        case 2: return .problem5
        
        case 3: return .problem6
        
        case 4: return .problem7
        
        case 5: return .problem9(addresses: try FfiConverterTypeAddressesOfEntitiesInBadState.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecurityProblem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .problem3(addresses):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAddressesOfEntitiesInBadState.write(addresses, into: &buf)
            
        
        case .problem5:
            writeInt(&buf, Int32(2))
        
        
        case .problem6:
            writeInt(&buf, Int32(3))
        
        
        case .problem7:
            writeInt(&buf, Int32(4))
        
        
        case let .problem9(addresses):
            writeInt(&buf, Int32(5))
            FfiConverterTypeAddressesOfEntitiesInBadState.write(addresses, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityProblem_lift(_ buf: RustBuffer) throws -> SecurityProblem {
    return try FfiConverterTypeSecurityProblem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityProblem_lower(_ value: SecurityProblem) -> RustBuffer {
    return FfiConverterTypeSecurityProblem.lower(value)
}


extension SecurityProblem: Sendable {} 
extension SecurityProblem: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum describing the different types of Security Problems the Wallet can encounter.
 */

public enum SecurityProblemKind {
    
    case securityFactors
    case configurationBackup
    case securityShields
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityProblemKind: FfiConverterRustBuffer {
    typealias SwiftType = SecurityProblemKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityProblemKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .securityFactors
        
        case 2: return .configurationBackup
        
        case 3: return .securityShields
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecurityProblemKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .securityFactors:
            writeInt(&buf, Int32(1))
        
        
        case .configurationBackup:
            writeInt(&buf, Int32(2))
        
        
        case .securityShields:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityProblemKind_lift(_ buf: RustBuffer) throws -> SecurityProblemKind {
    return try FfiConverterTypeSecurityProblemKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityProblemKind_lower(_ value: SecurityProblemKind) -> RustBuffer {
    return FfiConverterTypeSecurityProblemKind.lower(value)
}


extension SecurityProblemKind: Sendable {} 
extension SecurityProblemKind: Equatable, Hashable {}




public enum SecurityShieldBuilderRuleViolation {

    
    
    case MissingAuthSigningFactor
    case ShieldNameInvalid
    case NumberOfDaysUntilTimeBasedConfirmationMustBeGreaterThanZero
    case RecoveryAndConfirmationFactorsOverlap
    case SingleFactorUsedInPrimaryMustNotBeUsedInAnyOtherRole
    case PrimaryRoleMustHaveAtLeastOneFactor
    case RecoveryRoleMustHaveAtLeastOneFactor
    case ConfirmationRoleMustHaveAtLeastOneFactor
    case PrimaryRoleWithPasswordInThresholdListMustHaveAnotherFactor
    case PrimaryRoleWithThresholdFactorsCannotHaveAThresholdValueOfZero
    case PrimaryRoleWithPasswordInThresholdListMustThresholdGreaterThanOne
    case ThresholdHigherThanThresholdFactorsLen
    case FactorSourceAlreadyPresent
    case PrimaryCannotHaveMultipleDevices
    case PrimaryCannotHavePasswordInOverrideList
    case PrimaryCannotContainSecurityQuestions
    case PrimaryCannotContainTrustedContact
    case RecoveryRoleSecurityQuestionsNotSupported
    case RecoveryRolePasswordNotSupported
    case ConfirmationRoleTrustedContactNotSupported
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityShieldBuilderRuleViolation: FfiConverterRustBuffer {
    typealias SwiftType = SecurityShieldBuilderRuleViolation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityShieldBuilderRuleViolation {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingAuthSigningFactor
        case 2: return .ShieldNameInvalid
        case 3: return .NumberOfDaysUntilTimeBasedConfirmationMustBeGreaterThanZero
        case 4: return .RecoveryAndConfirmationFactorsOverlap
        case 5: return .SingleFactorUsedInPrimaryMustNotBeUsedInAnyOtherRole
        case 6: return .PrimaryRoleMustHaveAtLeastOneFactor
        case 7: return .RecoveryRoleMustHaveAtLeastOneFactor
        case 8: return .ConfirmationRoleMustHaveAtLeastOneFactor
        case 9: return .PrimaryRoleWithPasswordInThresholdListMustHaveAnotherFactor
        case 10: return .PrimaryRoleWithThresholdFactorsCannotHaveAThresholdValueOfZero
        case 11: return .PrimaryRoleWithPasswordInThresholdListMustThresholdGreaterThanOne
        case 12: return .ThresholdHigherThanThresholdFactorsLen
        case 13: return .FactorSourceAlreadyPresent
        case 14: return .PrimaryCannotHaveMultipleDevices
        case 15: return .PrimaryCannotHavePasswordInOverrideList
        case 16: return .PrimaryCannotContainSecurityQuestions
        case 17: return .PrimaryCannotContainTrustedContact
        case 18: return .RecoveryRoleSecurityQuestionsNotSupported
        case 19: return .RecoveryRolePasswordNotSupported
        case 20: return .ConfirmationRoleTrustedContactNotSupported

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecurityShieldBuilderRuleViolation, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .MissingAuthSigningFactor:
            writeInt(&buf, Int32(1))
        
        
        case .ShieldNameInvalid:
            writeInt(&buf, Int32(2))
        
        
        case .NumberOfDaysUntilTimeBasedConfirmationMustBeGreaterThanZero:
            writeInt(&buf, Int32(3))
        
        
        case .RecoveryAndConfirmationFactorsOverlap:
            writeInt(&buf, Int32(4))
        
        
        case .SingleFactorUsedInPrimaryMustNotBeUsedInAnyOtherRole:
            writeInt(&buf, Int32(5))
        
        
        case .PrimaryRoleMustHaveAtLeastOneFactor:
            writeInt(&buf, Int32(6))
        
        
        case .RecoveryRoleMustHaveAtLeastOneFactor:
            writeInt(&buf, Int32(7))
        
        
        case .ConfirmationRoleMustHaveAtLeastOneFactor:
            writeInt(&buf, Int32(8))
        
        
        case .PrimaryRoleWithPasswordInThresholdListMustHaveAnotherFactor:
            writeInt(&buf, Int32(9))
        
        
        case .PrimaryRoleWithThresholdFactorsCannotHaveAThresholdValueOfZero:
            writeInt(&buf, Int32(10))
        
        
        case .PrimaryRoleWithPasswordInThresholdListMustThresholdGreaterThanOne:
            writeInt(&buf, Int32(11))
        
        
        case .ThresholdHigherThanThresholdFactorsLen:
            writeInt(&buf, Int32(12))
        
        
        case .FactorSourceAlreadyPresent:
            writeInt(&buf, Int32(13))
        
        
        case .PrimaryCannotHaveMultipleDevices:
            writeInt(&buf, Int32(14))
        
        
        case .PrimaryCannotHavePasswordInOverrideList:
            writeInt(&buf, Int32(15))
        
        
        case .PrimaryCannotContainSecurityQuestions:
            writeInt(&buf, Int32(16))
        
        
        case .PrimaryCannotContainTrustedContact:
            writeInt(&buf, Int32(17))
        
        
        case .RecoveryRoleSecurityQuestionsNotSupported:
            writeInt(&buf, Int32(18))
        
        
        case .RecoveryRolePasswordNotSupported:
            writeInt(&buf, Int32(19))
        
        
        case .ConfirmationRoleTrustedContactNotSupported:
            writeInt(&buf, Int32(20))
        
        }
    }
}


extension SecurityShieldBuilderRuleViolation: Equatable, Hashable {}



extension SecurityShieldBuilderRuleViolation: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the status of `SecurityShieldBuilder`.
 * Used for UI representation in host applications.
 */

public enum SecurityShieldBuilderStatus {
    
    /**
     * The selected factor sources form a strong combination
     * in the Security Shield building process.
     */
    case strong
    /**
     * The selected factor sources form a weak combination
     * in the Security Shield building process.
     */
    case weak(
        /**
         * The reason why the built shield would be weak.
         */reason: SecurityShieldBuilderRuleViolation
    )
    /**
     * The selected factor sources form an invalid combination
     * in the Security Shield building process.
     * Example: Each role must have at least one factor.
     */
    case invalid(reason: SecurityShieldBuilderStatusInvalidReason
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityShieldBuilderStatus: FfiConverterRustBuffer {
    typealias SwiftType = SecurityShieldBuilderStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityShieldBuilderStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .strong
        
        case 2: return .weak(reason: try FfiConverterTypeSecurityShieldBuilderRuleViolation.read(from: &buf)
        )
        
        case 3: return .invalid(reason: try FfiConverterTypeSecurityShieldBuilderStatusInvalidReason.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecurityShieldBuilderStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .strong:
            writeInt(&buf, Int32(1))
        
        
        case let .weak(reason):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecurityShieldBuilderRuleViolation.write(reason, into: &buf)
            
        
        case let .invalid(reason):
            writeInt(&buf, Int32(3))
            FfiConverterTypeSecurityShieldBuilderStatusInvalidReason.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityShieldBuilderStatus_lift(_ buf: RustBuffer) throws -> SecurityShieldBuilderStatus {
    return try FfiConverterTypeSecurityShieldBuilderStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityShieldBuilderStatus_lower(_ value: SecurityShieldBuilderStatus) -> RustBuffer {
    return FfiConverterTypeSecurityShieldBuilderStatus.lower(value)
}


extension SecurityShieldBuilderStatus: Sendable {} 
extension SecurityShieldBuilderStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum representing the status of the prerequisites for building a Security Shield.
 * This is, whether the user has the necessary factor sources to build a Security Shield.
 */

public enum SecurityShieldPrerequisitesStatus {
    
    /**
     * A Security Shield can be built with the current Factor Sources available.
     */
    case sufficient
    /**
     * At least one hardware Factor Source must be added in order to build a Shield.
     * Note: this doesn't mean that after adding a hardware Factor Source we would have `Sufficient` status.
     */
    case hardwareRequired
    /**
     * One more Factor Source, of any category, must be added in order to build a Shield.
     */
    case anyRequired
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityShieldPrerequisitesStatus: FfiConverterRustBuffer {
    typealias SwiftType = SecurityShieldPrerequisitesStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityShieldPrerequisitesStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sufficient
        
        case 2: return .hardwareRequired
        
        case 3: return .anyRequired
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecurityShieldPrerequisitesStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sufficient:
            writeInt(&buf, Int32(1))
        
        
        case .hardwareRequired:
            writeInt(&buf, Int32(2))
        
        
        case .anyRequired:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityShieldPrerequisitesStatus_lift(_ buf: RustBuffer) throws -> SecurityShieldPrerequisitesStatus {
    return try FfiConverterTypeSecurityShieldPrerequisitesStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityShieldPrerequisitesStatus_lower(_ value: SecurityShieldPrerequisitesStatus) -> RustBuffer {
    return FfiConverterTypeSecurityShieldPrerequisitesStatus.lower(value)
}


extension SecurityShieldPrerequisitesStatus: Sendable {} 
extension SecurityShieldPrerequisitesStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SecurityStructureFlag {
    
    /**
     * Used to mark a Security Shield as "main". We can only have one.
     */
    case main
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityStructureFlag: FfiConverterRustBuffer {
    typealias SwiftType = SecurityStructureFlag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureFlag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .main
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecurityStructureFlag, into buf: inout [UInt8]) {
        switch value {
        
        
        case .main:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityStructureFlag_lift(_ buf: RustBuffer) throws -> SecurityStructureFlag {
    return try FfiConverterTypeSecurityStructureFlag.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityStructureFlag_lower(_ value: SecurityStructureFlag) -> RustBuffer {
    return FfiConverterTypeSecurityStructureFlag.lower(value)
}


extension SecurityStructureFlag: Sendable {} 
extension SecurityStructureFlag: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the status of selected Primary Threshold factor sources in the Security Shield building process.
 * Primarily used for UI logic representation in host applications.
 */

public enum SelectedPrimaryThresholdFactorsStatus {
    
    /**
     * The selected factor sources are optimal
     * in the Security Shield building process.
     */
    case optimal
    /**
     * The selected factor sources are suboptimal
     * in the Security Shield building process.
     *
     * Note: Typically used in hosts as a warning message.
     */
    case suboptimal
    /**
     * The selected factor sources are insufficient
     * in the Security Shield building process.
     */
    case insufficient
    /**
     * The selected factor sources form an invalid combination
     * in the Security Shield building process.
     *
     * Example: A Password factor source cannot be used alone.
     */
    case invalid(
        /**
         * The reason why the selected factor sources are invalid.
         */reason: SelectedPrimaryThresholdFactorsStatusInvalidReason
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSelectedPrimaryThresholdFactorsStatus: FfiConverterRustBuffer {
    typealias SwiftType = SelectedPrimaryThresholdFactorsStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SelectedPrimaryThresholdFactorsStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .optimal
        
        case 2: return .suboptimal
        
        case 3: return .insufficient
        
        case 4: return .invalid(reason: try FfiConverterTypeSelectedPrimaryThresholdFactorsStatusInvalidReason.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SelectedPrimaryThresholdFactorsStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .optimal:
            writeInt(&buf, Int32(1))
        
        
        case .suboptimal:
            writeInt(&buf, Int32(2))
        
        
        case .insufficient:
            writeInt(&buf, Int32(3))
        
        
        case let .invalid(reason):
            writeInt(&buf, Int32(4))
            FfiConverterTypeSelectedPrimaryThresholdFactorsStatusInvalidReason.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectedPrimaryThresholdFactorsStatus_lift(_ buf: RustBuffer) throws -> SelectedPrimaryThresholdFactorsStatus {
    return try FfiConverterTypeSelectedPrimaryThresholdFactorsStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectedPrimaryThresholdFactorsStatus_lower(_ value: SelectedPrimaryThresholdFactorsStatus) -> RustBuffer {
    return FfiConverterTypeSelectedPrimaryThresholdFactorsStatus.lower(value)
}


extension SelectedPrimaryThresholdFactorsStatus: Sendable {} 
extension SelectedPrimaryThresholdFactorsStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the reason why the selected primary threshold factor sources are invalid.
 * Primarily used for UI logic representation in host applications.
 */

public enum SelectedPrimaryThresholdFactorsStatusInvalidReason {
    
    case cannotBeUsedAlone(factorSourceKind: FactorSourceKind
    )
    case other(underlying: SecurityShieldBuilderRuleViolation
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSelectedPrimaryThresholdFactorsStatusInvalidReason: FfiConverterRustBuffer {
    typealias SwiftType = SelectedPrimaryThresholdFactorsStatusInvalidReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SelectedPrimaryThresholdFactorsStatusInvalidReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .cannotBeUsedAlone(factorSourceKind: try FfiConverterTypeFactorSourceKind.read(from: &buf)
        )
        
        case 2: return .other(underlying: try FfiConverterTypeSecurityShieldBuilderRuleViolation.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SelectedPrimaryThresholdFactorsStatusInvalidReason, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .cannotBeUsedAlone(factorSourceKind):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFactorSourceKind.write(factorSourceKind, into: &buf)
            
        
        case let .other(underlying):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecurityShieldBuilderRuleViolation.write(underlying, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectedPrimaryThresholdFactorsStatusInvalidReason_lift(_ buf: RustBuffer) throws -> SelectedPrimaryThresholdFactorsStatusInvalidReason {
    return try FfiConverterTypeSelectedPrimaryThresholdFactorsStatusInvalidReason.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectedPrimaryThresholdFactorsStatusInvalidReason_lower(_ value: SelectedPrimaryThresholdFactorsStatusInvalidReason) -> RustBuffer {
    return FfiConverterTypeSelectedPrimaryThresholdFactorsStatusInvalidReason.lower(value)
}


extension SelectedPrimaryThresholdFactorsStatusInvalidReason: Sendable {} 
extension SelectedPrimaryThresholdFactorsStatusInvalidReason: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either a Signature on `Curve25519` or `Secp256k1`
 */

public enum Signature {
    
    case secp256k1(value: Secp256k1Signature
    )
    case ed25519(value: Ed25519Signature
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignature: FfiConverterRustBuffer {
    typealias SwiftType = Signature

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Signature {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .secp256k1(value: try FfiConverterTypeSecp256k1Signature.read(from: &buf)
        )
        
        case 2: return .ed25519(value: try FfiConverterTypeEd25519Signature.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Signature, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .secp256k1(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecp256k1Signature.write(value, into: &buf)
            
        
        case let .ed25519(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEd25519Signature.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignature_lift(_ buf: RustBuffer) throws -> Signature {
    return try FfiConverterTypeSignature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignature_lower(_ value: Signature) -> RustBuffer {
    return FfiConverterTypeSignature.lower(value)
}


extension Signature: Sendable {} 
extension Signature: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents any natively supported signature, including public key.
 */

public enum SignatureWithPublicKey {
    
    case secp256k1(publicKey: Secp256k1PublicKey, signature: Secp256k1Signature
    )
    case ed25519(publicKey: Ed25519PublicKey, signature: Ed25519Signature
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignatureWithPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = SignatureWithPublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureWithPublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .secp256k1(publicKey: try FfiConverterTypeSecp256k1PublicKey.read(from: &buf), signature: try FfiConverterTypeSecp256k1Signature.read(from: &buf)
        )
        
        case 2: return .ed25519(publicKey: try FfiConverterTypeEd25519PublicKey.read(from: &buf), signature: try FfiConverterTypeEd25519Signature.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureWithPublicKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .secp256k1(publicKey,signature):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecp256k1PublicKey.write(publicKey, into: &buf)
            FfiConverterTypeSecp256k1Signature.write(signature, into: &buf)
            
        
        case let .ed25519(publicKey,signature):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEd25519PublicKey.write(publicKey, into: &buf)
            FfiConverterTypeEd25519Signature.write(signature, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignatureWithPublicKey_lift(_ buf: RustBuffer) throws -> SignatureWithPublicKey {
    return try FfiConverterTypeSignatureWithPublicKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignatureWithPublicKey_lower(_ value: SignatureWithPublicKey) -> RustBuffer {
    return FfiConverterTypeSignatureWithPublicKey.lower(value)
}


extension SignatureWithPublicKey: Sendable {} 
extension SignatureWithPublicKey: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the bounds for a simple fungible resource, which can
 * be exact, at most, at least, between, or unknown amount.
 */

public enum SimpleCountedResourceBounds {
    
    case exact(amount: Decimal192
    )
    case atMost(amount: Decimal192
    )
    case atLeast(amount: Decimal192
    )
    case between(minAmount: Decimal192, maxAmount: Decimal192
    )
    case unknownAmount
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSimpleCountedResourceBounds: FfiConverterRustBuffer {
    typealias SwiftType = SimpleCountedResourceBounds

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleCountedResourceBounds {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .exact(amount: try FfiConverterTypeDecimal192.read(from: &buf)
        )
        
        case 2: return .atMost(amount: try FfiConverterTypeDecimal192.read(from: &buf)
        )
        
        case 3: return .atLeast(amount: try FfiConverterTypeDecimal192.read(from: &buf)
        )
        
        case 4: return .between(minAmount: try FfiConverterTypeDecimal192.read(from: &buf), maxAmount: try FfiConverterTypeDecimal192.read(from: &buf)
        )
        
        case 5: return .unknownAmount
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SimpleCountedResourceBounds, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .exact(amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal192.write(amount, into: &buf)
            
        
        case let .atMost(amount):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDecimal192.write(amount, into: &buf)
            
        
        case let .atLeast(amount):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDecimal192.write(amount, into: &buf)
            
        
        case let .between(minAmount,maxAmount):
            writeInt(&buf, Int32(4))
            FfiConverterTypeDecimal192.write(minAmount, into: &buf)
            FfiConverterTypeDecimal192.write(maxAmount, into: &buf)
            
        
        case .unknownAmount:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSimpleCountedResourceBounds_lift(_ buf: RustBuffer) throws -> SimpleCountedResourceBounds {
    return try FfiConverterTypeSimpleCountedResourceBounds.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSimpleCountedResourceBounds_lower(_ value: SimpleCountedResourceBounds) -> RustBuffer {
    return FfiConverterTypeSimpleCountedResourceBounds.lower(value)
}


extension SimpleCountedResourceBounds: Sendable {} 
extension SimpleCountedResourceBounds: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the bounds for a simple resource, which can be either fungible or non_fungible.
 */

public enum SimpleResourceBounds {
    
    case fungible(resourceAddress: ResourceAddress, bounds: SimpleCountedResourceBounds
    )
    case nonFungible(resourceAddress: ResourceAddress, bounds: SimpleNonFungibleResourceBounds
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSimpleResourceBounds: FfiConverterRustBuffer {
    typealias SwiftType = SimpleResourceBounds

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleResourceBounds {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fungible(resourceAddress: try FfiConverterTypeResourceAddress.read(from: &buf), bounds: try FfiConverterTypeSimpleCountedResourceBounds.read(from: &buf)
        )
        
        case 2: return .nonFungible(resourceAddress: try FfiConverterTypeResourceAddress.read(from: &buf), bounds: try FfiConverterTypeSimpleNonFungibleResourceBounds.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SimpleResourceBounds, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fungible(resourceAddress,bounds):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeSimpleCountedResourceBounds.write(bounds, into: &buf)
            
        
        case let .nonFungible(resourceAddress,bounds):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeSimpleNonFungibleResourceBounds.write(bounds, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSimpleResourceBounds_lift(_ buf: RustBuffer) throws -> SimpleResourceBounds {
    return try FfiConverterTypeSimpleResourceBounds.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSimpleResourceBounds_lower(_ value: SimpleResourceBounds) -> RustBuffer {
    return FfiConverterTypeSimpleResourceBounds.lower(value)
}


extension SimpleResourceBounds: Sendable {} 
extension SimpleResourceBounds: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum with the input to perform a spot check for a given `FactorSourceID`.
 * This is, to validate that the `FactorSourceID` was created with the same input that has been provided.
 */

public enum SpotCheckInput {
    
    /**
     * The user retrieved the id of a Ledger device.
     * Used for the identification of `LedgerHardwareWalletFactorSource`.
     */
    case ledger(id: Exactly32Bytes
    )
    /**
     * The user retrieved the `FactorSourceIdFromHash` that identified an Arculus card.
     * /// Used for the identification of `ArculusCardFactorSource`.
     */
    case arculusCard(id: FactorSourceIdFromHash
    )
    /**
     * The user retrieved a `MnemonicWithPassphrase`.
     * Used for the identification of any software `FactorSource`.
     */
    case software(mnemonicWithPassphrase: MnemonicWithPassphrase
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpotCheckInput: FfiConverterRustBuffer {
    typealias SwiftType = SpotCheckInput

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpotCheckInput {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ledger(id: try FfiConverterTypeExactly32Bytes.read(from: &buf)
        )
        
        case 2: return .arculusCard(id: try FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
        )
        
        case 3: return .software(mnemonicWithPassphrase: try FfiConverterTypeMnemonicWithPassphrase.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SpotCheckInput, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ledger(id):
            writeInt(&buf, Int32(1))
            FfiConverterTypeExactly32Bytes.write(id, into: &buf)
            
        
        case let .arculusCard(id):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFactorSourceIDFromHash.write(id, into: &buf)
            
        
        case let .software(mnemonicWithPassphrase):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMnemonicWithPassphrase.write(mnemonicWithPassphrase, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpotCheckInput_lift(_ buf: RustBuffer) throws -> SpotCheckInput {
    return try FfiConverterTypeSpotCheckInput.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpotCheckInput_lower(_ value: SpotCheckInput) -> RustBuffer {
    return FfiConverterTypeSpotCheckInput.lower(value)
}


extension SpotCheckInput: Sendable {} 
extension SpotCheckInput: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum indicating the result of a spot check.
 *
 * Note that there isn't a failure case since user never fails a spot check. It either:
 * - succeeds (`Valid` returned by host),
 * - skips (`Skipped` returned by host),
 * - aborts (`CommonError::HostInteractionAborted` thrown by host)
 */

public enum SpotCheckResponse {
    
    /**
     * The factor source was successfully validated.
     */
    case valid
    /**
     * The user skipped the spot check.
     */
    case skipped
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpotCheckResponse: FfiConverterRustBuffer {
    typealias SwiftType = SpotCheckResponse

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpotCheckResponse {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .valid
        
        case 2: return .skipped
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SpotCheckResponse, into buf: inout [UInt8]) {
        switch value {
        
        
        case .valid:
            writeInt(&buf, Int32(1))
        
        
        case .skipped:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpotCheckResponse_lift(_ buf: RustBuffer) throws -> SpotCheckResponse {
    return try FfiConverterTypeSpotCheckResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpotCheckResponse_lower(_ value: SpotCheckResponse) -> RustBuffer {
    return FfiConverterTypeSpotCheckResponse.lower(value)
}


extension SpotCheckResponse: Sendable {} 
extension SpotCheckResponse: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A kind of threshold, either All or a specific number of factors
 * must be used to perform some function with.
 */

public enum Threshold {
    
    /**
     * All factors in the threshold factors list must be used to perform some function with
     */
    case all
    /**
     * A specific number of factors in the threshold factors list must be used to perform some function with
     */
    case specific(UInt8
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeThreshold: FfiConverterRustBuffer {
    typealias SwiftType = Threshold

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Threshold {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .all
        
        case 2: return .specific(try FfiConverterUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Threshold, into buf: inout [UInt8]) {
        switch value {
        
        
        case .all:
            writeInt(&buf, Int32(1))
        
        
        case let .specific(v1):
            writeInt(&buf, Int32(2))
            FfiConverterUInt8.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThreshold_lift(_ buf: RustBuffer) throws -> Threshold {
    return try FfiConverterTypeThreshold.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThreshold_lower(_ value: Threshold) -> RustBuffer {
    return FfiConverterTypeThreshold.lower(value)
}


extension Threshold: Sendable {} 
extension Threshold: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A unit for the emergency fallback period.
 * Primarily used by hosts for UI representation.
 */

public enum TimePeriodUnit {
    
    case days
    case weeks
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimePeriodUnit: FfiConverterRustBuffer {
    typealias SwiftType = TimePeriodUnit

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimePeriodUnit {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .days
        
        case 2: return .weeks
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimePeriodUnit, into buf: inout [UInt8]) {
        switch value {
        
        
        case .days:
            writeInt(&buf, Int32(1))
        
        
        case .weeks:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimePeriodUnit_lift(_ buf: RustBuffer) throws -> TimePeriodUnit {
    return try FfiConverterTypeTimePeriodUnit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimePeriodUnit_lower(_ value: TimePeriodUnit) -> RustBuffer {
    return FfiConverterTypeTimePeriodUnit.lower(value)
}


extension TimePeriodUnit: Sendable {} 
extension TimePeriodUnit: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionStatus {
    
    /**
     * The transaction has been successfully processed and is now final.
     */
    case success
    /**
     * The transaction has been permanently rejected with the given `reason`.
     */
    case permanentlyRejected(reason: TransactionStatusReason
    )
    /**
     * The transaction has been temporarily rejected and may be processed in the future.
     */
    case temporarilyRejected(currentEpoch: Epoch
    )
    /**
     * The transaction has failed with the given `reason`.
     */
    case failed(reason: TransactionStatusReason
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionStatus: FfiConverterRustBuffer {
    typealias SwiftType = TransactionStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .success
        
        case 2: return .permanentlyRejected(reason: try FfiConverterTypeTransactionStatusReason.read(from: &buf)
        )
        
        case 3: return .temporarilyRejected(currentEpoch: try FfiConverterTypeEpoch.read(from: &buf)
        )
        
        case 4: return .failed(reason: try FfiConverterTypeTransactionStatusReason.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .success:
            writeInt(&buf, Int32(1))
        
        
        case let .permanentlyRejected(reason):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTransactionStatusReason.write(reason, into: &buf)
            
        
        case let .temporarilyRejected(currentEpoch):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEpoch.write(currentEpoch, into: &buf)
            
        
        case let .failed(reason):
            writeInt(&buf, Int32(4))
            FfiConverterTypeTransactionStatusReason.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionStatus_lift(_ buf: RustBuffer) throws -> TransactionStatus {
    return try FfiConverterTypeTransactionStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionStatus_lower(_ value: TransactionStatus) -> RustBuffer {
    return FfiConverterTypeTransactionStatus.lower(value)
}


extension TransactionStatus: Sendable {} 
extension TransactionStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionStatusReason {
    
    /**
     * The transaction was rejected for an unknown reason.
     */
    case unknown
    /**
     * The transaction was rejected because there was an application error in the worktop.
     */
    case worktopError
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionStatusReason: FfiConverterRustBuffer {
    typealias SwiftType = TransactionStatusReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionStatusReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .worktopError
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionStatusReason, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .worktopError:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionStatusReason_lift(_ buf: RustBuffer) throws -> TransactionStatusReason {
    return try FfiConverterTypeTransactionStatusReason.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionStatusReason_lower(_ value: TransactionStatusReason) -> RustBuffer {
    return FfiConverterTypeTransactionStatusReason.lower(value)
}


extension TransactionStatusReason: Sendable {} 
extension TransactionStatusReason: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransferRecipient {
    
    case profileAccount(value: AccountForDisplay
    )
    case addressOfExternalAccount(value: AccountAddress
    )
    case rnsDomain(value: RnsDomainConfiguredReceiver
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransferRecipient: FfiConverterRustBuffer {
    typealias SwiftType = TransferRecipient

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransferRecipient {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .profileAccount(value: try FfiConverterTypeAccountForDisplay.read(from: &buf)
        )
        
        case 2: return .addressOfExternalAccount(value: try FfiConverterTypeAccountAddress.read(from: &buf)
        )
        
        case 3: return .rnsDomain(value: try FfiConverterTypeRnsDomainConfiguredReceiver.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransferRecipient, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .profileAccount(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountForDisplay.write(value, into: &buf)
            
        
        case let .addressOfExternalAccount(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountAddress.write(value, into: &buf)
            
        
        case let .rnsDomain(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeRnsDomainConfiguredReceiver.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransferRecipient_lift(_ buf: RustBuffer) throws -> TransferRecipient {
    return try FfiConverterTypeTransferRecipient.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransferRecipient_lower(_ value: TransferRecipient) -> RustBuffer {
    return FfiConverterTypeTransferRecipient.lower(value)
}


extension TransferRecipient: Sendable {} 
extension TransferRecipient: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UnsafeStorageKey {
    
    case factorSourceUserHasWrittenDown
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsafeStorageKey: FfiConverterRustBuffer {
    typealias SwiftType = UnsafeStorageKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsafeStorageKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .factorSourceUserHasWrittenDown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UnsafeStorageKey, into buf: inout [UInt8]) {
        switch value {
        
        
        case .factorSourceUserHasWrittenDown:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsafeStorageKey_lift(_ buf: RustBuffer) throws -> UnsafeStorageKey {
    return try FfiConverterTypeUnsafeStorageKey.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsafeStorageKey_lower(_ value: UnsafeStorageKey) -> RustBuffer {
    return FfiConverterTypeUnsafeStorageKey.lower(value)
}


extension UnsafeStorageKey: Sendable {} 
extension UnsafeStorageKey: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Unsecurified {
    
    case unhardenedComponent(Unhardened
    )
    case hardenedComponent(UnsecurifiedHardened
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnsecurified: FfiConverterRustBuffer {
    typealias SwiftType = Unsecurified

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unsecurified {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unhardenedComponent(try FfiConverterTypeUnhardened.read(from: &buf)
        )
        
        case 2: return .hardenedComponent(try FfiConverterTypeUnsecurifiedHardened.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Unsecurified, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .unhardenedComponent(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUnhardened.write(v1, into: &buf)
            
        
        case let .hardenedComponent(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeUnsecurifiedHardened.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsecurified_lift(_ buf: RustBuffer) throws -> Unsecurified {
    return try FfiConverterTypeUnsecurified.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnsecurified_lower(_ value: Unsecurified) -> RustBuffer {
    return FfiConverterTypeUnsecurified.lower(value)
}


extension Unsecurified: Sendable {} 
extension Unsecurified: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents unspecified resources, which can be either none present or
 * may be present with a list of change sources.
 */

public enum UnspecifiedResources {
    
    /**
     * There are no unspecified resources present
     */
    case nonePresent
    /**
     * There might be non-zero balances of unspecified resources present
     */
    case mayBePresent
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnspecifiedResources: FfiConverterRustBuffer {
    typealias SwiftType = UnspecifiedResources

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnspecifiedResources {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nonePresent
        
        case 2: return .mayBePresent
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UnspecifiedResources, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nonePresent:
            writeInt(&buf, Int32(1))
        
        
        case .mayBePresent:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnspecifiedResources_lift(_ buf: RustBuffer) throws -> UnspecifiedResources {
    return try FfiConverterTypeUnspecifiedResources.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnspecifiedResources_lower(_ value: UnspecifiedResources) -> RustBuffer {
    return FfiConverterTypeUnspecifiedResources.lower(value)
}


extension UnspecifiedResources: Sendable {} 
extension UnspecifiedResources: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VectorImageType {
    
    case svg
    case pdf
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVectorImageType: FfiConverterRustBuffer {
    typealias SwiftType = VectorImageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VectorImageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .svg
        
        case 2: return .pdf
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VectorImageType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .svg:
            writeInt(&buf, Int32(1))
        
        
        case .pdf:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVectorImageType_lift(_ buf: RustBuffer) throws -> VectorImageType {
    return try FfiConverterTypeVectorImageType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVectorImageType_lower(_ value: VectorImageType) -> RustBuffer {
    return FfiConverterTypeVectorImageType.lower(value)
}


extension VectorImageType: Sendable {} 
extension VectorImageType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionAuthRequestResponseItem {
    
    case usePersona(WalletToDappInteractionAuthUsePersonaRequestResponseItem
    )
    case loginWithoutChallenge(WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem
    )
    case loginWithChallenge(WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionAuthRequestResponseItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthRequestResponseItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .usePersona(try FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.read(from: &buf)
        )
        
        case 2: return .loginWithoutChallenge(try FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.read(from: &buf)
        )
        
        case 3: return .loginWithChallenge(try FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionAuthRequestResponseItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .usePersona(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.write(v1, into: &buf)
            
        
        case let .loginWithoutChallenge(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.write(v1, into: &buf)
            
        
        case let .loginWithChallenge(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem_lower(_ value: WalletToDappInteractionAuthRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.lower(value)
}


extension WalletToDappInteractionAuthRequestResponseItem: Sendable {} 
extension WalletToDappInteractionAuthRequestResponseItem: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A proof of ownership of either an `Account` or a `Persona`.
 */

public enum WalletToDappInteractionProofOfOwnership {
    
    case account(WalletToDappInteractionAccountProof
    )
    case persona(WalletToDappInteractionPersonaProof
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionProofOfOwnership: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionProofOfOwnership

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionProofOfOwnership {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .account(try FfiConverterTypeWalletToDappInteractionAccountProof.read(from: &buf)
        )
        
        case 2: return .persona(try FfiConverterTypeWalletToDappInteractionPersonaProof.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionProofOfOwnership, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .account(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionAccountProof.write(v1, into: &buf)
            
        
        case let .persona(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionPersonaProof.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionProofOfOwnership_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionProofOfOwnership {
    return try FfiConverterTypeWalletToDappInteractionProofOfOwnership.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionProofOfOwnership_lower(_ value: WalletToDappInteractionProofOfOwnership) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionProofOfOwnership.lower(value)
}


extension WalletToDappInteractionProofOfOwnership: Sendable {} 
extension WalletToDappInteractionProofOfOwnership: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionResponse {
    
    case success(WalletToDappInteractionSuccessResponse
    )
    case failure(WalletToDappInteractionFailureResponse
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionResponse: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionResponse

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionResponse {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .success(try FfiConverterTypeWalletToDappInteractionSuccessResponse.read(from: &buf)
        )
        
        case 2: return .failure(try FfiConverterTypeWalletToDappInteractionFailureResponse.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionResponse, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .success(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionSuccessResponse.write(v1, into: &buf)
            
        
        case let .failure(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionFailureResponse.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionResponse {
    return try FfiConverterTypeWalletToDappInteractionResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionResponse_lower(_ value: WalletToDappInteractionResponse) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionResponse.lower(value)
}


extension WalletToDappInteractionResponse: Sendable {} 
extension WalletToDappInteractionResponse: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionResponseItems {
    
    case authorizedRequest(WalletToDappInteractionAuthorizedRequestResponseItems
    )
    case unauthorizedRequest(WalletToDappInteractionUnauthorizedRequestResponseItems
    )
    case transaction(WalletToDappInteractionTransactionResponseItems
    )
    case preAuthorization(WalletToDappInteractionPreAuthorizationResponseItems
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletToDappInteractionResponseItems: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionResponseItems

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionResponseItems {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .authorizedRequest(try FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.read(from: &buf)
        )
        
        case 2: return .unauthorizedRequest(try FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.read(from: &buf)
        )
        
        case 3: return .transaction(try FfiConverterTypeWalletToDappInteractionTransactionResponseItems.read(from: &buf)
        )
        
        case 4: return .preAuthorization(try FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionResponseItems, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .authorizedRequest(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.write(v1, into: &buf)
            
        
        case let .unauthorizedRequest(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.write(v1, into: &buf)
            
        
        case let .transaction(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletToDappInteractionTransactionResponseItems.write(v1, into: &buf)
            
        
        case let .preAuthorization(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionResponseItems {
    return try FfiConverterTypeWalletToDappInteractionResponseItems.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletToDappInteractionResponseItems_lower(_ value: WalletToDappInteractionResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionResponseItems.lower(value)
}


extension WalletToDappInteractionResponseItems: Sendable {} 
extension WalletToDappInteractionResponseItems: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAccountAddress: FfiConverterRustBuffer {
    typealias SwiftType = AccountAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAccountAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAccountAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeArculusWalletPointer: FfiConverterRustBuffer {
    typealias SwiftType = ArculusWalletPointer?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeArculusWalletPointer.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeArculusWalletPointer.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBackupResult: FfiConverterRustBuffer {
    typealias SwiftType = BackupResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBackupResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBackupResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBlogPost: FfiConverterRustBuffer {
    typealias SwiftType = BlogPost?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBlogPost.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBlogPost.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionAccountsRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionAccountsRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionPersonaDataRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDappToWalletInteractionProofOfOwnershipRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionProofOfOwnershipRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDappToWalletInteractionResetRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionResetRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionResetRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionResetRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDecimal192: FfiConverterRustBuffer {
    typealias SwiftType = Decimal192?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDecimal192.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDecimal192.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDisplayName: FfiConverterRustBuffer {
    typealias SwiftType = DisplayName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDisplayName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDisplayName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
    typealias SwiftType = HierarchicalDeterministicFactorInstance?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeIdentityAddress: FfiConverterRustBuffer {
    typealias SwiftType = IdentityAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIdentityAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIdentityAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeInstant: FfiConverterRustBuffer {
    typealias SwiftType = Instant?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInstant.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInstant.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePersonaData: FfiConverterRustBuffer {
    typealias SwiftType = PersonaData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePersonaDataEntryName: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataEntryName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataEntryName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataEntryName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePersonaDataIdentifiedName: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataIdentifiedName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataIdentifiedName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataIdentifiedName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRequestedQuantity: FfiConverterRustBuffer {
    typealias SwiftType = RequestedQuantity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRequestedQuantity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRequestedQuantity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses: FfiConverterRustBuffer {
    typealias SwiftType = SharedToDappWithPersonaAccountAddresses?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSharedToDappWithPersonaAccountAddresses.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSharedToDappWithPersonaAccountAddresses.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries: FfiConverterRustBuffer {
    typealias SwiftType = SharedToDappWithPersonaIDsOfPersonaDataEntries?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionAccountsRequestResponseItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionPersonaDataRequestResponseItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionProofOfOwnershipRequestResponseItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCommonError: FfiConverterRustBuffer {
    typealias SwiftType = CommonError?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCommonError.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCommonError.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDetailedManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = DetailedManifestClass?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDetailedManifestClass.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDetailedManifestClass.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFactorSourceID: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFactorSourceID.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFactorSourceID.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFactorSourceValidationStatusReasonIfInvalid: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceValidationStatusReasonIfInvalid?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFactorSourceValidationStatusReasonIfInvalid.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFactorSourceValidationStatusReasonIfInvalid.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeProvisionalSecurifiedConfig: FfiConverterRustBuffer {
    typealias SwiftType = ProvisionalSecurifiedConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeProvisionalSecurifiedConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeProvisionalSecurifiedConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSecurityShieldBuilderRuleViolation: FfiConverterRustBuffer {
    typealias SwiftType = SecurityShieldBuilderRuleViolation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSecurityShieldBuilderRuleViolation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSecurityShieldBuilderRuleViolation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSimpleCountedResourceBounds: FfiConverterRustBuffer {
    typealias SwiftType = SimpleCountedResourceBounds?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSimpleCountedResourceBounds.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSimpleCountedResourceBounds.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeAccountAddress: FfiConverterRustBuffer {
    typealias SwiftType = [AccountAddress]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAccountAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAccountAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeAccountForDisplay: FfiConverterRustBuffer {
    typealias SwiftType = [AccountForDisplay]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAccountForDisplay.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAccountForDisplay.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeAssetException: FfiConverterRustBuffer {
    typealias SwiftType = [AssetException]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAssetException.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAssetException.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [EmailAddress]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeEmailAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeEmailAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryPhoneNumber]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePersonaDataEntryPhoneNumber.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePersonaDataEntryPhoneNumber.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
    typealias SwiftType = [WalletToDappInteractionAccountProof]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeWalletToDappInteractionAccountProof.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeWalletToDappInteractionAccountProof.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceOrNonFungible]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeResourceOrNonFungible.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeBagOfBytes: FfiConverterRustBuffer {
    typealias SwiftType = [BagOfBytes]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeBagOfBytes.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeBagOfBytes.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBagOfBytes: FfiConverterRustBuffer {
    typealias SwiftType = BagOfBytes?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBagOfBytes.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionAuthChallengeNonce?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePersonaDataEntryID: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataEntryId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataEntryID.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataEntryID.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUrl: FfiConverterRustBuffer {
    typealias SwiftType = Url?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUrl.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUrl.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceInt8: FfiConverterRustBuffer {
    typealias SwiftType = [Int8]

    public static func write(_ value: [Int8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int8] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterInt8.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]

    public static func write(_ value: [UInt16], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt16.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt16] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt16]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt16.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAccount: FfiConverterRustBuffer {
    typealias SwiftType = [Account]

    public static func write(_ value: [Account], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Account] {
        let len: Int32 = try readInt(&buf)
        var seq = [Account]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAccount.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAccountAddress: FfiConverterRustBuffer {
    typealias SwiftType = [AccountAddress]

    public static func write(_ value: [AccountAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAccountAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAccountForDisplay: FfiConverterRustBuffer {
    typealias SwiftType = [AccountForDisplay]

    public static func write(_ value: [AccountForDisplay], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountForDisplay.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountForDisplay] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountForDisplay]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAccountForDisplay.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAppearanceID: FfiConverterRustBuffer {
    typealias SwiftType = [AppearanceId]

    public static func write(_ value: [AppearanceId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAppearanceID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AppearanceId] {
        let len: Int32 = try readInt(&buf)
        var seq = [AppearanceId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAppearanceID.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAssetException: FfiConverterRustBuffer {
    typealias SwiftType = [AssetException]

    public static func write(_ value: [AssetException], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAssetException.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetException] {
        let len: Int32 = try readInt(&buf)
        var seq = [AssetException]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAssetException.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAuthorizedDapp: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedDapp]

    public static func write(_ value: [AuthorizedDapp], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedDapp.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedDapp] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedDapp]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAuthorizedDapp.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAuthorizedPersonaDetailed: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedPersonaDetailed]

    public static func write(_ value: [AuthorizedPersonaDetailed], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedPersonaDetailed.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedPersonaDetailed] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedPersonaDetailed]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAuthorizedPersonaDetailed.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAuthorizedPersonaSimple: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedPersonaSimple]

    public static func write(_ value: [AuthorizedPersonaSimple], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedPersonaSimple.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedPersonaSimple] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedPersonaSimple]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAuthorizedPersonaSimple.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBIP39Word: FfiConverterRustBuffer {
    typealias SwiftType = [Bip39Word]

    public static func write(_ value: [Bip39Word], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBIP39Word.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip39Word] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bip39Word]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBIP39Word.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBlob: FfiConverterRustBuffer {
    typealias SwiftType = [Blob]

    public static func write(_ value: [Blob], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBlob.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Blob] {
        let len: Int32 = try readInt(&buf)
        var seq = [Blob]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBlob.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBlogPost: FfiConverterRustBuffer {
    typealias SwiftType = [BlogPost]

    public static func write(_ value: [BlogPost], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBlogPost.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BlogPost] {
        let len: Int32 = try readInt(&buf)
        var seq = [BlogPost]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBlogPost.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [EmailAddress]

    public static func write(_ value: [EmailAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEmailAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EmailAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [EmailAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEmailAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFactorInstance: FfiConverterRustBuffer {
    typealias SwiftType = [FactorInstance]

    public static func write(_ value: [FactorInstance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorInstance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorInstance] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorInstance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFactorInstance.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFactorInstanceForDebugPurposes: FfiConverterRustBuffer {
    typealias SwiftType = [FactorInstanceForDebugPurposes]

    public static func write(_ value: [FactorInstanceForDebugPurposes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorInstanceForDebugPurposes.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorInstanceForDebugPurposes] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorInstanceForDebugPurposes]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFactorInstanceForDebugPurposes.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFactorSourceIDFromHash: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSourceIdFromHash]

    public static func write(_ value: [FactorSourceIdFromHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSourceIDFromHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceIdFromHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSourceIdFromHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFactorSourceIDFromHash.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFactorSourceValidationStatus: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSourceValidationStatus]

    public static func write(_ value: [FactorSourceValidationStatus], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSourceValidationStatus.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceValidationStatus] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSourceValidationStatus]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFactorSourceValidationStatus.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGateway: FfiConverterRustBuffer {
    typealias SwiftType = [Gateway]

    public static func write(_ value: [Gateway], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGateway.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Gateway] {
        let len: Int32 = try readInt(&buf)
        var seq = [Gateway]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGateway.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHDSignatureOfAuthIntentHash: FfiConverterRustBuffer {
    typealias SwiftType = [HdSignatureOfAuthIntentHash]

    public static func write(_ value: [HdSignatureOfAuthIntentHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHDSignatureOfAuthIntentHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HdSignatureOfAuthIntentHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [HdSignatureOfAuthIntentHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHDSignatureOfAuthIntentHash.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHDSignatureOfSubintentHash: FfiConverterRustBuffer {
    typealias SwiftType = [HdSignatureOfSubintentHash]

    public static func write(_ value: [HdSignatureOfSubintentHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHDSignatureOfSubintentHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HdSignatureOfSubintentHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [HdSignatureOfSubintentHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHDSignatureOfSubintentHash.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHDSignatureOfTransactionIntentHash: FfiConverterRustBuffer {
    typealias SwiftType = [HdSignatureOfTransactionIntentHash]

    public static func write(_ value: [HdSignatureOfTransactionIntentHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHDSignatureOfTransactionIntentHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HdSignatureOfTransactionIntentHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [HdSignatureOfTransactionIntentHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHDSignatureOfTransactionIntentHash.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
    typealias SwiftType = [HierarchicalDeterministicFactorInstance]

    public static func write(_ value: [HierarchicalDeterministicFactorInstance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHierarchicalDeterministicFactorInstance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HierarchicalDeterministicFactorInstance] {
        let len: Int32 = try readInt(&buf)
        var seq = [HierarchicalDeterministicFactorInstance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHierarchicalDeterministicPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [HierarchicalDeterministicPublicKey]

    public static func write(_ value: [HierarchicalDeterministicPublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHierarchicalDeterministicPublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HierarchicalDeterministicPublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [HierarchicalDeterministicPublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeIdentityAddress: FfiConverterRustBuffer {
    typealias SwiftType = [IdentityAddress]

    public static func write(_ value: [IdentityAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIdentityAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IdentityAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [IdentityAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIdentityAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeIntentSignature: FfiConverterRustBuffer {
    typealias SwiftType = [IntentSignature]

    public static func write(_ value: [IntentSignature], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIntentSignature.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IntentSignature] {
        let len: Int32 = try readInt(&buf)
        var seq = [IntentSignature]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIntentSignature.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeIntentSignatureOfOwner: FfiConverterRustBuffer {
    typealias SwiftType = [IntentSignatureOfOwner]

    public static func write(_ value: [IntentSignatureOfOwner], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIntentSignatureOfOwner.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IntentSignatureOfOwner] {
        let len: Int32 = try readInt(&buf)
        var seq = [IntentSignatureOfOwner]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIntentSignatureOfOwner.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeInvalidTransactionIfNeglectedOfAuthIntentHash: FfiConverterRustBuffer {
    typealias SwiftType = [InvalidTransactionIfNeglectedOfAuthIntentHash]

    public static func write(_ value: [InvalidTransactionIfNeglectedOfAuthIntentHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeInvalidTransactionIfNeglectedOfAuthIntentHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [InvalidTransactionIfNeglectedOfAuthIntentHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [InvalidTransactionIfNeglectedOfAuthIntentHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeInvalidTransactionIfNeglectedOfAuthIntentHash.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeInvalidTransactionIfNeglectedOfSubintentHash: FfiConverterRustBuffer {
    typealias SwiftType = [InvalidTransactionIfNeglectedOfSubintentHash]

    public static func write(_ value: [InvalidTransactionIfNeglectedOfSubintentHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeInvalidTransactionIfNeglectedOfSubintentHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [InvalidTransactionIfNeglectedOfSubintentHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [InvalidTransactionIfNeglectedOfSubintentHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeInvalidTransactionIfNeglectedOfSubintentHash.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeInvalidTransactionIfNeglectedOfTransactionIntentHash: FfiConverterRustBuffer {
    typealias SwiftType = [InvalidTransactionIfNeglectedOfTransactionIntentHash]

    public static func write(_ value: [InvalidTransactionIfNeglectedOfTransactionIntentHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeInvalidTransactionIfNeglectedOfTransactionIntentHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [InvalidTransactionIfNeglectedOfTransactionIntentHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [InvalidTransactionIfNeglectedOfTransactionIntentHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeInvalidTransactionIfNeglectedOfTransactionIntentHash.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeKeyDerivationRequestPerFactorSource: FfiConverterRustBuffer {
    typealias SwiftType = [KeyDerivationRequestPerFactorSource]

    public static func write(_ value: [KeyDerivationRequestPerFactorSource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKeyDerivationRequestPerFactorSource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [KeyDerivationRequestPerFactorSource] {
        let len: Int32 = try readInt(&buf)
        var seq = [KeyDerivationRequestPerFactorSource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKeyDerivationRequestPerFactorSource.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeKeyDerivationResponsePerFactorSource: FfiConverterRustBuffer {
    typealias SwiftType = [KeyDerivationResponsePerFactorSource]

    public static func write(_ value: [KeyDerivationResponsePerFactorSource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKeyDerivationResponsePerFactorSource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [KeyDerivationResponsePerFactorSource] {
        let len: Int32 = try readInt(&buf)
        var seq = [KeyDerivationResponsePerFactorSource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKeyDerivationResponsePerFactorSource.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNonFungibleGlobalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleGlobalId]

    public static func write(_ value: [NonFungibleGlobalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleGlobalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleGlobalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNonFungibleGlobalId.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeOwnedFactorInstance: FfiConverterRustBuffer {
    typealias SwiftType = [OwnedFactorInstance]

    public static func write(_ value: [OwnedFactorInstance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOwnedFactorInstance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OwnedFactorInstance] {
        let len: Int32 = try readInt(&buf)
        var seq = [OwnedFactorInstance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOwnedFactorInstance.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeP2PLink: FfiConverterRustBuffer {
    typealias SwiftType = [P2pLink]

    public static func write(_ value: [P2pLink], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeP2PLink.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [P2pLink] {
        let len: Int32 = try readInt(&buf)
        var seq = [P2pLink]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeP2PLink.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerAssetFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetFungibleTransfer]

    public static func write(_ value: [PerAssetFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerAssetFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerAssetNonFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetNonFungibleTransfer]

    public static func write(_ value: [PerAssetNonFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetNonFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetNonFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetNonFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerAssetNonFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerAssetTransfersOfFungibleResource: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetTransfersOfFungibleResource]

    public static func write(_ value: [PerAssetTransfersOfFungibleResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetTransfersOfFungibleResource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetTransfersOfFungibleResource] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetTransfersOfFungibleResource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerAssetTransfersOfFungibleResource.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetTransfersOfNonFungibleResource]

    public static func write(_ value: [PerAssetTransfersOfNonFungibleResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetTransfersOfNonFungibleResource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetTransfersOfNonFungibleResource] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetTransfersOfNonFungibleResource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerAssetTransfersOfNonFungibleResource.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerFactorOutcomeOfAuthIntentHash: FfiConverterRustBuffer {
    typealias SwiftType = [PerFactorOutcomeOfAuthIntentHash]

    public static func write(_ value: [PerFactorOutcomeOfAuthIntentHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerFactorOutcomeOfAuthIntentHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerFactorOutcomeOfAuthIntentHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerFactorOutcomeOfAuthIntentHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerFactorOutcomeOfAuthIntentHash.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerFactorOutcomeOfSubintentHash: FfiConverterRustBuffer {
    typealias SwiftType = [PerFactorOutcomeOfSubintentHash]

    public static func write(_ value: [PerFactorOutcomeOfSubintentHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerFactorOutcomeOfSubintentHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerFactorOutcomeOfSubintentHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerFactorOutcomeOfSubintentHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerFactorOutcomeOfSubintentHash.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerFactorOutcomeOfTransactionIntentHash: FfiConverterRustBuffer {
    typealias SwiftType = [PerFactorOutcomeOfTransactionIntentHash]

    public static func write(_ value: [PerFactorOutcomeOfTransactionIntentHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerFactorOutcomeOfTransactionIntentHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerFactorOutcomeOfTransactionIntentHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerFactorOutcomeOfTransactionIntentHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerFactorOutcomeOfTransactionIntentHash.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerFactorSourceInputOfAuthIntent: FfiConverterRustBuffer {
    typealias SwiftType = [PerFactorSourceInputOfAuthIntent]

    public static func write(_ value: [PerFactorSourceInputOfAuthIntent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerFactorSourceInputOfAuthIntent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerFactorSourceInputOfAuthIntent] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerFactorSourceInputOfAuthIntent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerFactorSourceInputOfAuthIntent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerFactorSourceInputOfSubintent: FfiConverterRustBuffer {
    typealias SwiftType = [PerFactorSourceInputOfSubintent]

    public static func write(_ value: [PerFactorSourceInputOfSubintent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerFactorSourceInputOfSubintent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerFactorSourceInputOfSubintent] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerFactorSourceInputOfSubintent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerFactorSourceInputOfSubintent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerFactorSourceInputOfTransactionIntent: FfiConverterRustBuffer {
    typealias SwiftType = [PerFactorSourceInputOfTransactionIntent]

    public static func write(_ value: [PerFactorSourceInputOfTransactionIntent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerFactorSourceInputOfTransactionIntent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerFactorSourceInputOfTransactionIntent] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerFactorSourceInputOfTransactionIntent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerFactorSourceInputOfTransactionIntent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerRecipientAssetTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerRecipientAssetTransfer]

    public static func write(_ value: [PerRecipientAssetTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerRecipientAssetTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientAssetTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerRecipientAssetTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerRecipientAssetTransfer.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerRecipientFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerRecipientFungibleTransfer]

    public static func write(_ value: [PerRecipientFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerRecipientFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerRecipientFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerRecipientFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePerRecipientNonFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerRecipientNonFungibleTransfer]

    public static func write(_ value: [PerRecipientNonFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerRecipientNonFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientNonFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerRecipientNonFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerRecipientNonFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePersona: FfiConverterRustBuffer {
    typealias SwiftType = [Persona]

    public static func write(_ value: [Persona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Persona] {
        let len: Int32 = try readInt(&buf)
        var seq = [Persona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePersona.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryPhoneNumber]

    public static func write(_ value: [PersonaDataEntryPhoneNumber], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataEntryPhoneNumber.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataEntryPhoneNumber] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataEntryPhoneNumber]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePersonaDataEntryPhoneNumber.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataIdentifiedEmailAddress]

    public static func write(_ value: [PersonaDataIdentifiedEmailAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataIdentifiedEmailAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataIdentifiedEmailAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataIdentifiedEmailAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePersonaDataIdentifiedEmailAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataIdentifiedPhoneNumber]

    public static func write(_ value: [PersonaDataIdentifiedPhoneNumber], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataIdentifiedPhoneNumber.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataIdentifiedPhoneNumber] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataIdentifiedPhoneNumber]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePersonaDataIdentifiedPhoneNumber.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePoolAddress: FfiConverterRustBuffer {
    typealias SwiftType = [PoolAddress]

    public static func write(_ value: [PoolAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePoolAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PoolAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [PoolAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePoolAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeProfileNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [ProfileNetwork]

    public static func write(_ value: [ProfileNetwork], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProfileNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ProfileNetwork] {
        let len: Int32 = try readInt(&buf)
        var seq = [ProfileNetwork]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeProfileNetwork.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeResourceAddress: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceAddress]

    public static func write(_ value: [ResourceAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeResourceAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeResourceAppPreference: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceAppPreference]

    public static func write(_ value: [ResourceAppPreference], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceAppPreference.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAppPreference] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceAppPreference]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeResourceAppPreference.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityStructureOfFactorSourceIDs]

    public static func write(_ value: [SecurityStructureOfFactorSourceIDs], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurityStructureOfFactorSourceIDs.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityStructureOfFactorSourceIDs] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityStructureOfFactorSourceIDs]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSecurityStructureOfFactorSourceIDs.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSecurityStructureOfFactorSources: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityStructureOfFactorSources]

    public static func write(_ value: [SecurityStructureOfFactorSources], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurityStructureOfFactorSources.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityStructureOfFactorSources] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityStructureOfFactorSources]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSecurityStructureOfFactorSources.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeShieldForDisplay: FfiConverterRustBuffer {
    typealias SwiftType = [ShieldForDisplay]

    public static func write(_ value: [ShieldForDisplay], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeShieldForDisplay.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ShieldForDisplay] {
        let len: Int32 = try readInt(&buf)
        var seq = [ShieldForDisplay]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeShieldForDisplay.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeStakeClaim: FfiConverterRustBuffer {
    typealias SwiftType = [StakeClaim]

    public static func write(_ value: [StakeClaim], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStakeClaim.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [StakeClaim] {
        let len: Int32 = try readInt(&buf)
        var seq = [StakeClaim]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeStakeClaim.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTrackedPoolContribution: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedPoolContribution]

    public static func write(_ value: [TrackedPoolContribution], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedPoolContribution.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedPoolContribution] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedPoolContribution]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTrackedPoolContribution.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTrackedPoolRedemption: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedPoolRedemption]

    public static func write(_ value: [TrackedPoolRedemption], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedPoolRedemption.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedPoolRedemption] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedPoolRedemption]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTrackedPoolRedemption.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTrackedValidatorClaim: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedValidatorClaim]

    public static func write(_ value: [TrackedValidatorClaim], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedValidatorClaim.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorClaim] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedValidatorClaim]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTrackedValidatorClaim.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTrackedValidatorStake: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedValidatorStake]

    public static func write(_ value: [TrackedValidatorStake], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedValidatorStake.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorStake] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedValidatorStake]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTrackedValidatorStake.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTransactionGuarantee: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionGuarantee]

    public static func write(_ value: [TransactionGuarantee], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionGuarantee.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionGuarantee] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionGuarantee]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransactionGuarantee.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTransactionSignRequestInputOfAuthIntent: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionSignRequestInputOfAuthIntent]

    public static func write(_ value: [TransactionSignRequestInputOfAuthIntent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionSignRequestInputOfAuthIntent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionSignRequestInputOfAuthIntent] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionSignRequestInputOfAuthIntent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransactionSignRequestInputOfAuthIntent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTransactionSignRequestInputOfSubintent: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionSignRequestInputOfSubintent]

    public static func write(_ value: [TransactionSignRequestInputOfSubintent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionSignRequestInputOfSubintent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionSignRequestInputOfSubintent] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionSignRequestInputOfSubintent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransactionSignRequestInputOfSubintent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTransactionSignRequestInputOfTransactionIntent: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionSignRequestInputOfTransactionIntent]

    public static func write(_ value: [TransactionSignRequestInputOfTransactionIntent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionSignRequestInputOfTransactionIntent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionSignRequestInputOfTransactionIntent] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionSignRequestInputOfTransactionIntent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransactionSignRequestInputOfTransactionIntent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUnvalidatedTransactionManifest: FfiConverterRustBuffer {
    typealias SwiftType = [UnvalidatedTransactionManifest]

    public static func write(_ value: [UnvalidatedTransactionManifest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnvalidatedTransactionManifest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UnvalidatedTransactionManifest] {
        let len: Int32 = try readInt(&buf)
        var seq = [UnvalidatedTransactionManifest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnvalidatedTransactionManifest.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeValidatorAddress: FfiConverterRustBuffer {
    typealias SwiftType = [ValidatorAddress]

    public static func write(_ value: [ValidatorAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeValidatorAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ValidatorAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [ValidatorAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeValidatorAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWalletInteractionWalletAccount: FfiConverterRustBuffer {
    typealias SwiftType = [WalletInteractionWalletAccount]

    public static func write(_ value: [WalletInteractionWalletAccount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletInteractionWalletAccount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletInteractionWalletAccount] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletInteractionWalletAccount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWalletInteractionWalletAccount.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
    typealias SwiftType = [WalletToDappInteractionAccountProof]

    public static func write(_ value: [WalletToDappInteractionAccountProof], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletToDappInteractionAccountProof.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletToDappInteractionAccountProof] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletToDappInteractionAccountProof]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWalletToDappInteractionAccountProof.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAccountLockerClaimableResource: FfiConverterRustBuffer {
    typealias SwiftType = [AccountLockerClaimableResource]

    public static func write(_ value: [AccountLockerClaimableResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountLockerClaimableResource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountLockerClaimableResource] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountLockerClaimableResource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAccountLockerClaimableResource.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = [AccountOrPersona]

    public static func write(_ value: [AccountOrPersona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountOrPersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountOrPersona] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountOrPersona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAccountOrPersona.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAccountWithdraw: FfiConverterRustBuffer {
    typealias SwiftType = [AccountWithdraw]

    public static func write(_ value: [AccountWithdraw], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountWithdraw.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountWithdraw] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountWithdraw]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAccountWithdraw.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = [Address]

    public static func write(_ value: [Address], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Address] {
        let len: Int32 = try readInt(&buf)
        var seq = [Address]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAddressOfAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = [AddressOfAccountOrPersona]

    public static func write(_ value: [AddressOfAccountOrPersona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddressOfAccountOrPersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AddressOfAccountOrPersona] {
        let len: Int32 = try readInt(&buf)
        var seq = [AddressOfAccountOrPersona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAddressOfAccountOrPersona.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBIP39WordCount: FfiConverterRustBuffer {
    typealias SwiftType = [Bip39WordCount]

    public static func write(_ value: [Bip39WordCount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBIP39WordCount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip39WordCount] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bip39WordCount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBIP39WordCount.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDerivationPath: FfiConverterRustBuffer {
    typealias SwiftType = [DerivationPath]

    public static func write(_ value: [DerivationPath], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivationPath.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationPath] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivationPath]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDerivationPath.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDerivationPathScheme: FfiConverterRustBuffer {
    typealias SwiftType = [DerivationPathScheme]

    public static func write(_ value: [DerivationPathScheme], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivationPathScheme.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationPathScheme] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivationPathScheme]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDerivationPathScheme.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEntityFlag: FfiConverterRustBuffer {
    typealias SwiftType = [EntityFlag]

    public static func write(_ value: [EntityFlag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEntityFlag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityFlag] {
        let len: Int32 = try readInt(&buf)
        var seq = [EntityFlag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEntityFlag.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEntitySyncActionPerformed: FfiConverterRustBuffer {
    typealias SwiftType = [EntitySyncActionPerformed]

    public static func write(_ value: [EntitySyncActionPerformed], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEntitySyncActionPerformed.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntitySyncActionPerformed] {
        let len: Int32 = try readInt(&buf)
        var seq = [EntitySyncActionPerformed]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEntitySyncActionPerformed.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEventKind: FfiConverterRustBuffer {
    typealias SwiftType = [EventKind]

    public static func write(_ value: [EventKind], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEventKind.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EventKind] {
        let len: Int32 = try readInt(&buf)
        var seq = [EventKind]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEventKind.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFactorSource: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSource]

    public static func write(_ value: [FactorSource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSource] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFactorSource.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFactorSourceFlag: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSourceFlag]

    public static func write(_ value: [FactorSourceFlag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSourceFlag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceFlag] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSourceFlag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFactorSourceFlag.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFactorSourceID: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSourceId]

    public static func write(_ value: [FactorSourceId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSourceID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceId] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSourceId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFactorSourceID.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFactorSourceKind: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSourceKind]

    public static func write(_ value: [FactorSourceKind], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSourceKind.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceKind] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSourceKind]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFactorSourceKind.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHDPathComponent: FfiConverterRustBuffer {
    typealias SwiftType = [HdPathComponent]

    public static func write(_ value: [HdPathComponent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHDPathComponent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HdPathComponent] {
        let len: Int32 = try readInt(&buf)
        var seq = [HdPathComponent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHDPathComponent.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHomeCard: FfiConverterRustBuffer {
    typealias SwiftType = [HomeCard]

    public static func write(_ value: [HomeCard], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHomeCard.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HomeCard] {
        let len: Int32 = try readInt(&buf)
        var seq = [HomeCard]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHomeCard.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLogFilter: FfiConverterRustBuffer {
    typealias SwiftType = [LogFilter]

    public static func write(_ value: [LogFilter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLogFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LogFilter] {
        let len: Int32 = try readInt(&buf)
        var seq = [LogFilter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLogFilter.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = [LogLevel]

    public static func write(_ value: [LogLevel], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLogLevel.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LogLevel] {
        let len: Int32 = try readInt(&buf)
        var seq = [LogLevel]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLogLevel.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = [ManifestClass]

    public static func write(_ value: [ManifestClass], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeManifestClass.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestClass] {
        let len: Int32 = try readInt(&buf)
        var seq = [ManifestClass]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeManifestClass.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeManifestEncounteredComponentAddress: FfiConverterRustBuffer {
    typealias SwiftType = [ManifestEncounteredComponentAddress]

    public static func write(_ value: [ManifestEncounteredComponentAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeManifestEncounteredComponentAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestEncounteredComponentAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [ManifestEncounteredComponentAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeManifestEncounteredComponentAddress.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNetworkID: FfiConverterRustBuffer {
    typealias SwiftType = [NetworkId]

    public static func write(_ value: [NetworkId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNetworkID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NetworkId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NetworkId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNetworkID.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleLocalId]

    public static func write(_ value: [NonFungibleLocalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleLocalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleLocalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleLocalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNonFungibleLocalId.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKeyHash]

    public static func write(_ value: [PublicKeyHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKeyHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKeyHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKeyHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKeyHash.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeReservedInstruction: FfiConverterRustBuffer {
    typealias SwiftType = [ReservedInstruction]

    public static func write(_ value: [ReservedInstruction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReservedInstruction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReservedInstruction] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReservedInstruction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReservedInstruction.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeResourceIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceIdentifier]

    public static func write(_ value: [ResourceIdentifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceIdentifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceIdentifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceIdentifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeResourceIdentifier.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceIndicator]

    public static func write(_ value: [ResourceIndicator], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceIndicator.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceIndicator] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceIndicator]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeResourceIndicator.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceOrNonFungible]

    public static func write(_ value: [ResourceOrNonFungible], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceOrNonFungible.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceOrNonFungible] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceOrNonFungible]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeResourceOrNonFungible.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeResourceSpecifier: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceSpecifier]

    public static func write(_ value: [ResourceSpecifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceSpecifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceSpecifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceSpecifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeResourceSpecifier.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSLIP10Curve: FfiConverterRustBuffer {
    typealias SwiftType = [Slip10Curve]

    public static func write(_ value: [Slip10Curve], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSLIP10Curve.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Slip10Curve] {
        let len: Int32 = try readInt(&buf)
        var seq = [Slip10Curve]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSLIP10Curve.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSecurityProblem: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityProblem]

    public static func write(_ value: [SecurityProblem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurityProblem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityProblem] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityProblem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSecurityProblem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSecurityStructureFlag: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityStructureFlag]

    public static func write(_ value: [SecurityStructureFlag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurityStructureFlag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityStructureFlag] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityStructureFlag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSecurityStructureFlag.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSimpleResourceBounds: FfiConverterRustBuffer {
    typealias SwiftType = [SimpleResourceBounds]

    public static func write(_ value: [SimpleResourceBounds], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSimpleResourceBounds.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SimpleResourceBounds] {
        let len: Int32 = try readInt(&buf)
        var seq = [SimpleResourceBounds]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSimpleResourceBounds.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeThreshold: FfiConverterRustBuffer {
    typealias SwiftType = [Threshold]

    public static func write(_ value: [Threshold], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeThreshold.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Threshold] {
        let len: Int32 = try readInt(&buf)
        var seq = [Threshold]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeThreshold.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWalletToDappInteractionProofOfOwnership: FfiConverterRustBuffer {
    typealias SwiftType = [WalletToDappInteractionProofOfOwnership]

    public static func write(_ value: [WalletToDappInteractionProofOfOwnership], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletToDappInteractionProofOfOwnership.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletToDappInteractionProofOfOwnership] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletToDappInteractionProofOfOwnership]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWalletToDappInteractionProofOfOwnership.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceTypeFactorInstanceForDebugPurposes: FfiConverterRustBuffer {
    typealias SwiftType = [[FactorInstanceForDebugPurposes]]

    public static func write(_ value: [[FactorInstanceForDebugPurposes]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceTypeFactorInstanceForDebugPurposes.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[FactorInstanceForDebugPurposes]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[FactorInstanceForDebugPurposes]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceTypeFactorInstanceForDebugPurposes.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeBagOfBytes: FfiConverterRustBuffer {
    typealias SwiftType = [BagOfBytes]

    public static func write(_ value: [BagOfBytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBagOfBytes.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [BagOfBytes] {
        let len: Int32 = try readInt(&buf)
        var seq = [BagOfBytes]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeBagOfBytes.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePersonaDataEntryID: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryId]

    public static func write(_ value: [PersonaDataEntryId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataEntryID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataEntryId] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataEntryId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePersonaDataEntryID.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSecurityStructureID: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityStructureId]

    public static func write(_ value: [SecurityStructureId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurityStructureID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityStructureId] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityStructureId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSecurityStructureID.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryUInt16String: FfiConverterRustBuffer {
    public static func write(_ value: [UInt16: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterUInt16.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt16: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [UInt16: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterUInt16.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeAccountAddressBool: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeAccountAddressTypeAccountDeposits: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: AccountDeposits], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterTypeAccountDeposits.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: AccountDeposits] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: AccountDeposits]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterTypeAccountDeposits.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeAccountAddressTypeDepositRule: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: DepositRule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterTypeDepositRule.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: DepositRule] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: DepositRule]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterTypeDepositRule.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeAccountAddressSequenceTypeAccountWithdraw: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [AccountWithdraw]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterSequenceTypeAccountWithdraw.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [AccountWithdraw]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [AccountWithdraw]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterSequenceTypeAccountWithdraw.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [ResourceIndicator]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterSequenceTypeResourceIndicator.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceIndicator]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [ResourceIndicator]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceIndicator.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [ResourceOrNonFungible]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterSequenceTypeResourceOrNonFungible.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceOrNonFungible]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [ResourceOrNonFungible]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeFactorSourceIDFromHashSequenceSequenceTypeFactorInstanceForDebugPurposes: FfiConverterRustBuffer {
    public static func write(_ value: [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeFactorSourceIDFromHash.write(key, into: &buf)
            FfiConverterSequenceSequenceTypeFactorInstanceForDebugPurposes.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]] {
        let len: Int32 = try readInt(&buf)
        var dict = [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            let value = try FfiConverterSequenceSequenceTypeFactorInstanceForDebugPurposes.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData: FfiConverterRustBuffer {
    public static func write(_ value: [NonFungibleGlobalId: UnstakeData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeNonFungibleGlobalId.write(key, into: &buf)
            FfiConverterTypeUnstakeData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId: UnstakeData] {
        let len: Int32 = try readInt(&buf)
        var dict = [NonFungibleGlobalId: UnstakeData]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
            let value = try FfiConverterTypeUnstakeData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeResourceAddressTypeDecimal192: FfiConverterRustBuffer {
    public static func write(_ value: [ResourceAddress: Decimal192], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeResourceAddress.write(key, into: &buf)
            FfiConverterTypeDecimal192.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: Decimal192] {
        let len: Int32 = try readInt(&buf)
        var dict = [ResourceAddress: Decimal192]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeResourceAddress.read(from: &buf)
            let value = try FfiConverterTypeDecimal192.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource: FfiConverterRustBuffer {
    public static func write(_ value: [ResourceAddress: NewlyCreatedResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeResourceAddress.write(key, into: &buf)
            FfiConverterTypeNewlyCreatedResource.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: NewlyCreatedResource] {
        let len: Int32 = try readInt(&buf)
        var dict = [ResourceAddress: NewlyCreatedResource]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeResourceAddress.read(from: &buf)
            let value = try FfiConverterTypeNewlyCreatedResource.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    public static func write(_ value: [ResourceAddress: ResourcePreferenceUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeResourceAddress.write(key, into: &buf)
            FfiConverterTypeResourcePreferenceUpdate.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: ResourcePreferenceUpdate] {
        let len: Int32 = try readInt(&buf)
        var dict = [ResourceAddress: ResourcePreferenceUpdate]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeResourceAddress.read(from: &buf)
            let value = try FfiConverterTypeResourcePreferenceUpdate.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bip39Passphrase = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBIP39Passphrase: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Passphrase {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Bip39Passphrase, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bip39Passphrase {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Bip39Passphrase) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP39Passphrase_lift(_ value: RustBuffer) throws -> Bip39Passphrase {
    return try FfiConverterTypeBIP39Passphrase.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBIP39Passphrase_lower(_ value: Bip39Passphrase) -> RustBuffer {
    return FfiConverterTypeBIP39Passphrase.lower(value)
}





/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BagOfBytes = Data


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBagOfBytes: FfiConverter {

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BagOfBytes {
        let builtinValue = try FfiConverterSequenceInt8.read(from: &buf)
        return { Data(builtinValue.map({ i8 in UInt8(bitPattern: i8) })) }()
    }

    public static func write(_ value: BagOfBytes, into buf: inout [UInt8]) {
        let builtinValue = { value.map({ u8 in Int8(bitPattern: u8) }) }()
        return FfiConverterSequenceInt8.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BagOfBytes {
        let builtinValue = try FfiConverterSequenceInt8.lift(value)
        return { Data(builtinValue.map({ i8 in UInt8(bitPattern: i8) })) }()
    }

    public static func lower(_ value: BagOfBytes) -> RustBuffer {
        let builtinValue = { value.map({ u8 in Int8(bitPattern: u8) }) }()
        return FfiConverterSequenceInt8.lower(builtinValue)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBagOfBytes_lift(_ value: RustBuffer) throws -> BagOfBytes {
    return try FfiConverterTypeBagOfBytes.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBagOfBytes_lower(_ value: BagOfBytes) -> RustBuffer {
    return FfiConverterTypeBagOfBytes.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DappOrigin = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappOrigin: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappOrigin {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: DappOrigin, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DappOrigin {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: DappOrigin) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappOrigin_lift(_ value: RustBuffer) throws -> DappOrigin {
    return try FfiConverterTypeDappOrigin.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappOrigin_lower(_ value: DappOrigin) -> RustBuffer {
    return FfiConverterTypeDappOrigin.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DappToWalletInteractionAuthChallengeNonce = Exactly32Bytes

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDappToWalletInteractionAuthChallengeNonce: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthChallengeNonce {
        return try FfiConverterTypeExactly32Bytes.read(from: &buf)
    }

    public static func write(_ value: DappToWalletInteractionAuthChallengeNonce, into buf: inout [UInt8]) {
        return FfiConverterTypeExactly32Bytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DappToWalletInteractionAuthChallengeNonce {
        return try FfiConverterTypeExactly32Bytes.lift(value)
    }

    public static func lower(_ value: DappToWalletInteractionAuthChallengeNonce) -> RustBuffer {
        return FfiConverterTypeExactly32Bytes.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionAuthChallengeNonce_lift(_ value: RustBuffer) throws -> DappToWalletInteractionAuthChallengeNonce {
    return try FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDappToWalletInteractionAuthChallengeNonce_lower(_ value: DappToWalletInteractionAuthChallengeNonce) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DeviceId = Uuid

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDeviceID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: DeviceId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DeviceId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: DeviceId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceID_lift(_ value: RustBuffer) throws -> DeviceId {
    return try FfiConverterTypeDeviceID.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDeviceID_lower(_ value: DeviceId) -> RustBuffer {
    return FfiConverterTypeDeviceID.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Epoch = UInt64

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEpoch: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Epoch {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: Epoch, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> Epoch {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: Epoch) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEpoch_lift(_ value: UInt64) throws -> Epoch {
    return try FfiConverterTypeEpoch.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEpoch_lower(_ value: Epoch) -> UInt64 {
    return FfiConverterTypeEpoch.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PersonaDataEntryId = Uuid

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePersonaDataEntryID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: PersonaDataEntryId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PersonaDataEntryId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: PersonaDataEntryId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataEntryID_lift(_ value: RustBuffer) throws -> PersonaDataEntryId {
    return try FfiConverterTypePersonaDataEntryID.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePersonaDataEntryID_lower(_ value: PersonaDataEntryId) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryID.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ProfileId = Uuid

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProfileID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: ProfileId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ProfileId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: ProfileId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileID_lift(_ value: RustBuffer) throws -> ProfileId {
    return try FfiConverterTypeProfileID.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileID_lower(_ value: ProfileId) -> RustBuffer {
    return FfiConverterTypeProfileID.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias RnsDomain = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRnsDomain: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RnsDomain {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: RnsDomain, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> RnsDomain {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: RnsDomain) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRnsDomain_lift(_ value: RustBuffer) throws -> RnsDomain {
    return try FfiConverterTypeRnsDomain.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRnsDomain_lower(_ value: RnsDomain) -> RustBuffer {
    return FfiConverterTypeRnsDomain.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SecurityStructureId = Uuid

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecurityStructureID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: SecurityStructureId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> SecurityStructureId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: SecurityStructureId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityStructureID_lift(_ value: RustBuffer) throws -> SecurityStructureId {
    return try FfiConverterTypeSecurityStructureID.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecurityStructureID_lower(_ value: SecurityStructureId) -> RustBuffer {
    return FfiConverterTypeSecurityStructureID.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SessionId = Uuid

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: SessionId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> SessionId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: SessionId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionID_lift(_ value: RustBuffer) throws -> SessionId {
    return try FfiConverterTypeSessionID.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionID_lower(_ value: SessionId) -> RustBuffer {
    return FfiConverterTypeSessionID.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SubintentVersion = UInt64

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSubintentVersion: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubintentVersion {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: SubintentVersion, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> SubintentVersion {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: SubintentVersion) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubintentVersion_lift(_ value: UInt64) throws -> SubintentVersion {
    return try FfiConverterTypeSubintentVersion.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSubintentVersion_lower(_ value: SubintentVersion) -> UInt64 {
    return FfiConverterTypeSubintentVersion.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TxVersion = UInt64

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTXVersion: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxVersion {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: TxVersion, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> TxVersion {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: TxVersion) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTXVersion_lift(_ value: UInt64) throws -> TxVersion {
    return try FfiConverterTypeTXVersion.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTXVersion_lower(_ value: TxVersion) -> UInt64 {
    return FfiConverterTypeTXVersion.lower(value)
}





/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Timestamp = Date


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimestamp: FfiConverter {

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timestamp {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return {
    let stringToDeserialize = builtinValue // this is UniFFIs counterpart to `$0`
    let formatter = ISO8601DateFormatter()
    let formatOptionMS = ISO8601DateFormatter.Options.withFractionalSeconds
    formatter.formatOptions.insert(formatOptionMS)
    
    func format() -> Date? {
        formatter.date(from: stringToDeserialize)
    }
    
    if let date = format() {
        return date
    }
    
    // try without fractional seconds
    formatter.formatOptions.remove(formatOptionMS)
    return format()!
}()

    }

    public static func write(_ value: Timestamp, into buf: inout [UInt8]) {
        let builtinValue = { 
    let dateToSerialize = value // this is UniFFIs counterpart to `$0`
    let formatter = ISO8601DateFormatter()
    formatter.formatOptions.insert(.withFractionalSeconds)
    return formatter.string(from: dateToSerialize)
}()

        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Timestamp {
        let builtinValue = try FfiConverterString.lift(value)
        return {
    let stringToDeserialize = builtinValue // this is UniFFIs counterpart to `$0`
    let formatter = ISO8601DateFormatter()
    let formatOptionMS = ISO8601DateFormatter.Options.withFractionalSeconds
    formatter.formatOptions.insert(formatOptionMS)
    
    func format() -> Date? {
        formatter.date(from: stringToDeserialize)
    }
    
    if let date = format() {
        return date
    }
    
    // try without fractional seconds
    formatter.formatOptions.remove(formatOptionMS)
    return format()!
}()

    }

    public static func lower(_ value: Timestamp) -> RustBuffer {
        let builtinValue = { 
    let dateToSerialize = value // this is UniFFIs counterpart to `$0`
    let formatter = ISO8601DateFormatter()
    formatter.formatOptions.insert(.withFractionalSeconds)
    return formatter.string(from: dateToSerialize)
}()

        return FfiConverterString.lower(builtinValue)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimestamp_lift(_ value: RustBuffer) throws -> Timestamp {
    return try FfiConverterTypeTimestamp.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimestamp_lower(_ value: Timestamp) -> RustBuffer {
    return FfiConverterTypeTimestamp.lower(value)
}





/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Url = URL


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUrl: FfiConverter {

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Url {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return URL(string: builtinValue)!
    }

    public static func write(_ value: Url, into buf: inout [UInt8]) {
        let builtinValue = String(describing: value)
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Url {
        let builtinValue = try FfiConverterString.lift(value)
        return URL(string: builtinValue)!
    }

    public static func lower(_ value: Url) -> RustBuffer {
        let builtinValue = String(describing: value)
        return FfiConverterString.lower(builtinValue)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrl_lift(_ value: RustBuffer) throws -> Url {
    return try FfiConverterTypeUrl.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrl_lower(_ value: Url) -> RustBuffer {
    return FfiConverterTypeUrl.lower(value)
}





/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Uuid = UUID


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUuid: FfiConverter {

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return UUID(uuidString: builtinValue)!
    }

    public static func write(_ value: Uuid, into buf: inout [UInt8]) {
        let builtinValue = value.uuidString
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Uuid {
        let builtinValue = try FfiConverterString.lift(value)
        return UUID(uuidString: builtinValue)!
    }

    public static func lower(_ value: Uuid) -> RustBuffer {
        let builtinValue = value.uuidString
        return FfiConverterString.lower(builtinValue)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUuid_lift(_ value: RustBuffer) throws -> Uuid {
    return try FfiConverterTypeUuid.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUuid_lower(_ value: Uuid) -> RustBuffer {
    return FfiConverterTypeUuid.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletInteractionId = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletInteractionId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: WalletInteractionId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> WalletInteractionId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: WalletInteractionId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletInteractionId_lift(_ value: RustBuffer) throws -> WalletInteractionId {
    return try FfiConverterTypeWalletInteractionId.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletInteractionId_lower(_ value: WalletInteractionId) -> RustBuffer {
    return FfiConverterTypeWalletInteractionId.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletInteractionVersion = UInt64

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletInteractionVersion: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionVersion {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: WalletInteractionVersion, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> WalletInteractionVersion {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: WalletInteractionVersion) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletInteractionVersion_lift(_ value: UInt64) throws -> WalletInteractionVersion {
    return try FfiConverterTypeWalletInteractionVersion.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletInteractionVersion_lower(_ value: WalletInteractionVersion) -> UInt64 {
    return FfiConverterTypeWalletInteractionVersion.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate let UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountSargon() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
public func accessControllerAddressBech32Address(address: AccessControllerAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_access_controller_address_bech32_address(
        FfiConverterTypeAccessControllerAddress.lower(address),$0
    )
})
}
public func accessControllerAddressFormatted(address: AccessControllerAddress, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_access_controller_address_formatted(
        FfiConverterTypeAccessControllerAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func accessControllerAddressMapToNetwork(address: AccessControllerAddress, networkId: NetworkId) -> AccessControllerAddress  {
    return try!  FfiConverterTypeAccessControllerAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_access_controller_address_map_to_network(
        FfiConverterTypeAccessControllerAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func accessControllerAddressNetworkId(address: AccessControllerAddress) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_access_controller_address_network_id(
        FfiConverterTypeAccessControllerAddress.lower(address),$0
    )
})
}
public func accountAddressBech32Address(address: AccountAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_account_address_bech32_address(
        FfiConverterTypeAccountAddress.lower(address),$0
    )
})
}
public func accountAddressFormatted(address: AccountAddress, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_account_address_formatted(
        FfiConverterTypeAccountAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
/**
 * Returns `false` for all addresses created with `Ed25519PublicKey`s, i.e.
 * for all accounts created by the Babylon Radix Wallets.
 * Returns `true` for all addresses created with `Secp256k1PublicKey`s, i.e.
 * imported from the legacy Olympia desktop application.
 */
public func accountAddressIsLegacy(address: AccountAddress) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_account_address_is_legacy(
        FfiConverterTypeAccountAddress.lower(address),$0
    )
})
}
/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func accountAddressMapToNetwork(address: AccountAddress, networkId: NetworkId) -> AccountAddress  {
    return try!  FfiConverterTypeAccountAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_account_address_map_to_network(
        FfiConverterTypeAccountAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func accountAddressNetworkId(address: AccountAddress) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_account_address_network_id(
        FfiConverterTypeAccountAddress.lower(address),$0
    )
})
}
public func accountIsLegacy(account: Account) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_account_is_legacy(
        FfiConverterTypeAccount.lower(account),$0
    )
})
}
public func accountOrPersonaGetId(entity: AccountOrPersona) -> AddressOfAccountOrPersona  {
    return try!  FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_account_or_persona_get_id(
        FfiConverterTypeAccountOrPersona.lower(entity),$0
    )
})
}
public func accountUnsecuredControllingFactorInstance(account: Account) -> HierarchicalDeterministicFactorInstance?  {
    return try!  FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_account_unsecured_controlling_factor_instance(
        FfiConverterTypeAccount.lower(account),$0
    )
})
}
public func addressFormatted(address: Address, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_address_formatted(
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
public func addressMapToNetwork(address: Address, networkId: NetworkId) -> Address  {
    return try!  FfiConverterTypeAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_address_map_to_network(
        FfiConverterTypeAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func addressNetworkId(address: Address) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_address_network_id(
        FfiConverterTypeAddress.lower(address),$0
    )
})
}
public func addressOfAccountOrPersonaFormatted(address: AddressOfAccountOrPersona, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_formatted(
        FfiConverterTypeAddressOfAccountOrPersona.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
public func addressOfAccountOrPersonaMapToNetwork(address: AddressOfAccountOrPersona, networkId: NetworkId) -> AddressOfAccountOrPersona  {
    return try!  FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_map_to_network(
        FfiConverterTypeAddressOfAccountOrPersona.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func addressOfAccountOrPersonaNetworkId(address: AddressOfAccountOrPersona) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_network_id(
        FfiConverterTypeAddressOfAccountOrPersona.lower(address),$0
    )
})
}
public func addressOfAccountOrPersonaSampleValuesAll() -> [AddressOfAccountOrPersona]  {
    return try!  FfiConverterSequenceTypeAddressOfAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_sample_values_all($0
    )
})
}
public func addressOfAccountOrPersonaToString(address: AddressOfAccountOrPersona) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_to_string(
        FfiConverterTypeAddressOfAccountOrPersona.lower(address),$0
    )
})
}
public func addressSampleValuesAll() -> [Address]  {
    return try!  FfiConverterSequenceTypeAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_address_sample_values_all($0
    )
})
}
public func addressToString(address: Address) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_address_to_string(
        FfiConverterTypeAddress.lower(address),$0
    )
})
}
public func androidNotarizeHashWithPrivateKeyBytes(privateKeyBytes: Exactly32Bytes, signedIntentHash: SignedTransactionIntentHash)throws  -> NotarySignature  {
    return try  FfiConverterTypeNotarySignature.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_android_notarize_hash_with_private_key_bytes(
        FfiConverterTypeExactly32Bytes.lower(privateKeyBytes),
        FfiConverterTypeSignedTransactionIntentHash.lower(signedIntentHash),$0
    )
})
}
public func androidSecretKeyGetPublicKeyFromPrivateKeyBytes(privateKeyBytes: Exactly32Bytes)throws  -> Ed25519PublicKey  {
    return try  FfiConverterTypeEd25519PublicKey.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_android_secret_key_get_public_key_from_private_key_bytes(
        FfiConverterTypeExactly32Bytes.lower(privateKeyBytes),$0
    )
})
}
public func androidSignHashWithPrivateKeyBytes(privateKeyBytes: Exactly32Bytes, hash: Hash)throws  -> Ed25519Signature  {
    return try  FfiConverterTypeEd25519Signature.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_android_sign_hash_with_private_key_bytes(
        FfiConverterTypeExactly32Bytes.lower(privateKeyBytes),
        FfiConverterTypeHash.lower(hash),$0
    )
})
}
public func appPreferencesHasGatewayWithUrl(appPreferences: AppPreferences, url: FfiUrl) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_app_preferences_has_gateway_with_url(
        FfiConverterTypeAppPreferences.lower(appPreferences),
        FfiConverterTypeFfiUrl.lower(url),$0
    )
})
}
public func appearanceIdsAll() -> [AppearanceId]  {
    return try!  FfiConverterSequenceTypeAppearanceID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_appearance_ids_all($0
    )
})
}
public func arculusCardModelToString(model: ArculusCardModel) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_arculus_card_model_to_string(
        FfiConverterTypeArculusCardModel.lower(model),$0
    )
})
}
public func authIntentGetHash(authIntent: AuthIntent) -> AuthIntentHash  {
    return try!  FfiConverterTypeAuthIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_auth_intent_get_hash(
        FfiConverterTypeAuthIntent.lower(authIntent),$0
    )
})
}
public func authorizedDappToJsonBytes(authorizedDapp: AuthorizedDapp) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_authorized_dapp_to_json_bytes(
        FfiConverterTypeAuthorizedDapp.lower(authorizedDapp),$0
    )
})
}
public func bIP39SeedToBytes(bytes: Bip39Seed) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_b_i_p39_seed_to_bytes(
        FfiConverterTypeBIP39Seed.lower(bytes),$0
    )
})
}
public func bagOfBytesAppendCafe(to: BagOfBytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_bag_of_bytes_append_cafe(
        FfiConverterTypeBagOfBytes.lower(to),$0
    )
})
}
public func bagOfBytesAppendDeadbeef(to: BagOfBytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_bag_of_bytes_append_deadbeef(
        FfiConverterTypeBagOfBytes.lower(to),$0
    )
})
}
public func bagOfBytesPrependCafe(inFrontOf: BagOfBytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_bag_of_bytes_prepend_cafe(
        FfiConverterTypeBagOfBytes.lower(inFrontOf),$0
    )
})
}
public func bagOfBytesPrependDeadbeef(inFrontOf: BagOfBytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_bag_of_bytes_prepend_deadbeef(
        FfiConverterTypeBagOfBytes.lower(inFrontOf),$0
    )
})
}
public func bip32ConstantGlobalOffsetHardened() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_bip32_constant_global_offset_hardened($0
    )
})
}
public func bip32ConstantGlobalOffsetSecurified() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_bip32_constant_global_offset_securified($0
    )
})
}
public func bip39LanguageWordlist(language: Bip39Language) -> [Bip39Word]  {
    return try!  FfiConverterSequenceTypeBIP39Word.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_bip39_language_wordlist(
        FfiConverterTypeBIP39Language.lower(language),$0
    )
})
}
public func bip39WordCountAll() -> [Bip39WordCount]  {
    return try!  FfiConverterSequenceTypeBIP39WordCount.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_bip39_word_count_all($0
    )
})
}
public func bip44LikePathGetAddressIndex(path: Bip44LikePath) -> HdPathComponent  {
    return try!  FfiConverterTypeHDPathComponent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_bip44_like_path_get_address_index(
        FfiConverterTypeBIP44LikePath.lower(path),$0
    )
})
}
public func bip44LikePathToString(path: Bip44LikePath) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_bip44_like_path_to_string(
        FfiConverterTypeBIP44LikePath.lower(path),$0
    )
})
}
public func blobToBytes(blob: Blob) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_blob_to_bytes(
        FfiConverterTypeBlob.lower(blob),$0
    )
})
}
public func blobToString(blob: Blob) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_blob_to_string(
        FfiConverterTypeBlob.lower(blob),$0
    )
})
}
public func blobsListOfBlobs(blobs: Blobs) -> [Blob]  {
    return try!  FfiConverterSequenceTypeBlob.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_blobs_list_of_blobs(
        FfiConverterTypeBlobs.lower(blobs),$0
    )
})
}
public func buildInformation() -> SargonBuildInformation  {
    return try!  FfiConverterTypeSargonBuildInformation.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_build_information($0
    )
})
}
public func cap26EntityKindToString(kind: Cap26EntityKind) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_cap26_entity_kind_to_string(
        FfiConverterTypeCAP26EntityKind.lower(kind),$0
    )
})
}
public func checkIfEncryptedProfileJsonContainsLegacyP2pLinks(jsonStr: String, password: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_check_if_encrypted_profile_json_contains_legacy_p2p_links(
        FfiConverterString.lower(jsonStr),
        FfiConverterString.lower(password),$0
    )
})
}
public func checkIfProfileJsonContainsLegacyP2pLinks(jsonStr: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_check_if_profile_json_contains_legacy_p2p_links(
        FfiConverterString.lower(jsonStr),$0
    )
})
}
public func compiledNotarizedIntentGetBytes(compiledNotarizedIntent: CompiledNotarizedIntent) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_compiled_notarized_intent_get_bytes(
        FfiConverterTypeCompiledNotarizedIntent.lower(compiledNotarizedIntent),$0
    )
})
}
public func compiledSubintentBytes(compiledIntent: CompiledSubintent) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_compiled_subintent_bytes(
        FfiConverterTypeCompiledSubintent.lower(compiledIntent),$0
    )
})
}
public func compiledSubintentDecompile(compiledIntent: CompiledSubintent) -> Subintent  {
    return try!  FfiConverterTypeSubintent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_compiled_subintent_decompile(
        FfiConverterTypeCompiledSubintent.lower(compiledIntent),$0
    )
})
}
public func compiledTransactionIntentBytes(compiledIntent: CompiledTransactionIntent) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_compiled_transaction_intent_bytes(
        FfiConverterTypeCompiledTransactionIntent.lower(compiledIntent),$0
    )
})
}
public func compiledTransactionIntentDecompile(compiledIntent: CompiledTransactionIntent) -> TransactionIntent  {
    return try!  FfiConverterTypeTransactionIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_compiled_transaction_intent_decompile(
        FfiConverterTypeCompiledTransactionIntent.lower(compiledIntent),$0
    )
})
}
public func componentAddressBech32Address(address: ComponentAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_component_address_bech32_address(
        FfiConverterTypeComponentAddress.lower(address),$0
    )
})
}
public func componentAddressFormatted(address: ComponentAddress, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_component_address_formatted(
        FfiConverterTypeComponentAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
/**
 * Returns `true` if the ComponentAddress is `global` (i.e. not `internal`)
 */
public func componentAddressIsGlobal(address: ComponentAddress) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_component_address_is_global(
        FfiConverterTypeComponentAddress.lower(address),$0
    )
})
}
/**
 * Returns `true` if the ComponentAddress is `internal` (i.e. not `global`)
 */
public func componentAddressIsInternal(address: ComponentAddress) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_component_address_is_internal(
        FfiConverterTypeComponentAddress.lower(address),$0
    )
})
}
/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func componentAddressMapToNetwork(address: ComponentAddress, networkId: NetworkId) -> ComponentAddress  {
    return try!  FfiConverterTypeComponentAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_component_address_map_to_network(
        FfiConverterTypeComponentAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func componentAddressNetworkId(address: ComponentAddress) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_component_address_network_id(
        FfiConverterTypeComponentAddress.lower(address),$0
    )
})
}
public func constantDisplayNameMaxLength() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_constant_display_name_max_length($0
    )
})
}
public func constantEntityNameMaxLength() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_constant_entity_name_max_length($0
    )
})
}
public func constantMaxRecoveryConfirmationFallbackPeriodUnits() -> UInt16  {
    return try!  FfiConverterUInt16.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_constant_max_recovery_confirmation_fallback_period_units($0
    )
})
}
public func constantMinRequiredXrdForAccountDeletion() -> Double  {
    return try!  FfiConverterDouble.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_constant_min_required_xrd_for_account_deletion($0
    )
})
}
public func dappToWalletInteractionMetadataToJsonBytes(dappToWalletInteractionMetadata: DappToWalletInteractionMetadata) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_dapp_to_wallet_interaction_metadata_to_json_bytes(
        FfiConverterTypeDappToWalletInteractionMetadata.lower(dappToWalletInteractionMetadata),$0
    )
})
}
public func dappToWalletInteractionUnvalidatedToJsonBytes(dappToWalletInteractionUnvalidated: DappToWalletInteractionUnvalidated) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_dapp_to_wallet_interaction_unvalidated_to_json_bytes(
        FfiConverterTypeDappToWalletInteractionUnvalidated.lower(dappToWalletInteractionUnvalidated),$0
    )
})
}
public func dappToWalletInteractionUnvalidatedToJsonString(interactionUnvalidated: DappToWalletInteractionUnvalidated) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_dapp_to_wallet_interaction_unvalidated_to_json_string(
        FfiConverterTypeDappToWalletInteractionUnvalidated.lower(interactionUnvalidated),$0
    )
})
}
public func debugPrintCompiledNotarizedIntent(compiled: CompiledNotarizedIntent) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_debug_print_compiled_notarized_intent(
        FfiConverterTypeCompiledNotarizedIntent.lower(compiled),$0
    )
})
}
/**
 * Returns `decimal.abs()`, panics if `decimal` is `Decimal192::MIN`
 */
public func decimalAbs(decimal: Decimal192) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_abs(
        FfiConverterTypeDecimal192.lower(decimal),$0
    )
})
}
/**
 * `lhs + rhs``
 */
public func decimalAdd(lhs: Decimal192, rhs: Decimal192) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_add(
        FfiConverterTypeDecimal192.lower(lhs),
        FfiConverterTypeDecimal192.lower(rhs),$0
    )
})
}
/**
 * Clamps `decimal` to zero, i.e. `max(decimal, 0)`
 */
public func decimalClampedToZero(decimal: Decimal192) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_clamped_to_zero(
        FfiConverterTypeDecimal192.lower(decimal),$0
    )
})
}
/**
 * `lhs / rhs``
 */
public func decimalDiv(lhs: Decimal192, rhs: Decimal192) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_div(
        FfiConverterTypeDecimal192.lower(lhs),
        FfiConverterTypeDecimal192.lower(rhs),$0
    )
})
}
public func decimalFormatted(decimal: Decimal192, locale: LocaleConfig, totalPlaces: UInt8, useGroupingSeparator: Bool) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_formatted(
        FfiConverterTypeDecimal192.lower(decimal),
        FfiConverterTypeLocaleConfig.lower(locale),
        FfiConverterUInt8.lower(totalPlaces),
        FfiConverterBool.lower(useGroupingSeparator),$0
    )
})
}
/**
 * A human readable, locale respecting string. Does not perform any rounding or truncation.
 */
public func decimalFormattedPlain(decimal: Decimal192, locale: LocaleConfig, useGroupingSeparator: Bool) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_formatted_plain(
        FfiConverterTypeDecimal192.lower(decimal),
        FfiConverterTypeLocaleConfig.lower(locale),
        FfiConverterBool.lower(useGroupingSeparator),$0
    )
})
}
/**
 * `lhs > rhs`
 */
public func decimalGreaterThan(lhs: Decimal192, rhs: Decimal192) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_greater_than(
        FfiConverterTypeDecimal192.lower(lhs),
        FfiConverterTypeDecimal192.lower(rhs),$0
    )
})
}
/**
 * `lhs >= rhs`
 */
public func decimalGreaterThanOrEqual(lhs: Decimal192, rhs: Decimal192) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_greater_than_or_equal(
        FfiConverterTypeDecimal192.lower(lhs),
        FfiConverterTypeDecimal192.lower(rhs),$0
    )
})
}
/**
 * Whether this decimal is negative.
 */
public func decimalIsNegative(decimal: Decimal192) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_is_negative(
        FfiConverterTypeDecimal192.lower(decimal),$0
    )
})
}
/**
 * Whether this decimal is positive.
 */
public func decimalIsPositive(decimal: Decimal192) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_is_positive(
        FfiConverterTypeDecimal192.lower(decimal),$0
    )
})
}
/**
 * Whether this decimal is zero.
 */
public func decimalIsZero(decimal: Decimal192) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_is_zero(
        FfiConverterTypeDecimal192.lower(decimal),$0
    )
})
}
/**
 * `lhs < rhs`
 */
public func decimalLessThan(lhs: Decimal192, rhs: Decimal192) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_less_than(
        FfiConverterTypeDecimal192.lower(lhs),
        FfiConverterTypeDecimal192.lower(rhs),$0
    )
})
}
/**
 * `lhs <= rhs`
 */
public func decimalLessThanOrEqual(lhs: Decimal192, rhs: Decimal192) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_less_than_or_equal(
        FfiConverterTypeDecimal192.lower(lhs),
        FfiConverterTypeDecimal192.lower(rhs),$0
    )
})
}
/**
 * The maximum possible value of `Decimal192`, being:
 * `3138550867693340381917894711603833208051.177722232017256447`
 */
public func decimalMax() -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_max($0
    )
})
}
/**
 * The minimum possible value of `Decimal192`, being:
 * `-3138550867693340381917894711603833208051.177722232017256448`
 */
public func decimalMin() -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_min($0
    )
})
}
/**
 * `lhs * rhs``
 */
public func decimalMul(lhs: Decimal192, rhs: Decimal192) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_mul(
        FfiConverterTypeDecimal192.lower(lhs),
        FfiConverterTypeDecimal192.lower(rhs),$0
    )
})
}
/**
 * Negates the `decimal`
 */
public func decimalNeg(decimal: Decimal192) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_neg(
        FfiConverterTypeDecimal192.lower(decimal),$0
    )
})
}
/**
 * Rounds this number to the specified decimal places.
 *
 * # Panics
 * - Panic if the number of decimal places is not within [0..SCALE(=18)]
 */
public func decimalRound(decimal: Decimal192, decimalPlaces: UInt8, roundingMode: RoundingMode)throws  -> Decimal192  {
    return try  FfiConverterTypeDecimal192.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_decimal_round(
        FfiConverterTypeDecimal192.lower(decimal),
        FfiConverterUInt8.lower(decimalPlaces),
        FfiConverterTypeRoundingMode.lower(roundingMode),$0
    )
})
}
/**
 * `lhs - rhs``
 */
public func decimalSub(lhs: Decimal192, rhs: Decimal192) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_sub(
        FfiConverterTypeDecimal192.lower(lhs),
        FfiConverterTypeDecimal192.lower(rhs),$0
    )
})
}
/**
 * `decimal.to_string()`
 */
public func decimalToString(decimal: Decimal192) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_decimal_to_string(
        FfiConverterTypeDecimal192.lower(decimal),$0
    )
})
}
public func dependencyInformationToString(info: DependencyInformation) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_dependency_information_to_string(
        FfiConverterTypeDependencyInformation.lower(info),$0
    )
})
}
public func depositRuleToJsonString(depositRule: DepositRule) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_deposit_rule_to_json_string(
        FfiConverterTypeDepositRule.lower(depositRule),$0
    )
})
}
/**
 * String representation of the path using BIP32 notation.
 * In sargon, paths in the securified space are printed with the `S` notation after the index,
 * for readability purposes.
 *
 * The notation `{i}S` means `{i + 2^30}H`, and since `H` means `+ 2^31` we can
 * verbosely express `{i}S` as `{i + 2^30 + 2^31} (without the H)
 *
 * Such paths need to be on BIP32 notation meaning that
 * an index of `"{i}S"` => `"{i + 2^30}H"` when communication with other external APIs,
 * e.g. using Ledger hardware wallet or Arculus.
 */
public func derivationPathToBip32String(path: DerivationPath) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_derivation_path_to_bip32_string(
        FfiConverterTypeDerivationPath.lower(path),$0
    )
})
}
public func derivationPathToHdPath(path: DerivationPath) -> HdPath  {
    return try!  FfiConverterTypeHDPath.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_derivation_path_to_hd_path(
        FfiConverterTypeDerivationPath.lower(path),$0
    )
})
}
public func derivationPathToString(path: DerivationPath) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_derivation_path_to_string(
        FfiConverterTypeDerivationPath.lower(path),$0
    )
})
}
public func deviceInfoDescriptionToString(deviceInfoDescription: DeviceInfoDescription) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_device_info_description_to_string(
        FfiConverterTypeDeviceInfoDescription.lower(deviceInfoDescription),$0
    )
})
}
public func deviceInfoToJsonBytes(deviceInfo: DeviceInfo) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_device_info_to_json_bytes(
        FfiConverterTypeDeviceInfo.lower(deviceInfo),$0
    )
})
}
public func displayNameToJsonString(displayName: DisplayName) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_display_name_to_json_string(
        FfiConverterTypeDisplayName.lower(displayName),$0
    )
})
}
public func ed25519PublicKeyToBytes(publicKey: Ed25519PublicKey) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_ed25519_public_key_to_bytes(
        FfiConverterTypeEd25519PublicKey.lower(publicKey),$0
    )
})
}
/**
 * Encodes the `Ed25519PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"b7a3c12dc0c8c748ab07525b701122b88bd78f600c76342d27f25e5f92444cde"`
 */
public func ed25519PublicKeyToHex(publicKey: Ed25519PublicKey) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_ed25519_public_key_to_hex(
        FfiConverterTypeEd25519PublicKey.lower(publicKey),$0
    )
})
}
public func ed25519PublicKeyToJsonString(ed25519PublicKey: Ed25519PublicKey) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_ed25519_public_key_to_json_string(
        FfiConverterTypeEd25519PublicKey.lower(ed25519PublicKey),$0
    )
})
}
public func ed25519SignatureToJsonString(ed25519Signature: Ed25519Signature) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_ed25519_signature_to_json_string(
        FfiConverterTypeEd25519Signature.lower(ed25519Signature),$0
    )
})
}
public func ed25519SignatureToString(signature: Ed25519Signature) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_ed25519_signature_to_string(
        FfiConverterTypeEd25519Signature.lower(signature),$0
    )
})
}
public func entropy16BytesToBytes(bytes: Entropy16Bytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_entropy16_bytes_to_bytes(
        FfiConverterTypeEntropy16Bytes.lower(bytes),$0
    )
})
}
public func entropy20BytesToBytes(bytes: Entropy20Bytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_entropy20_bytes_to_bytes(
        FfiConverterTypeEntropy20Bytes.lower(bytes),$0
    )
})
}
public func entropy24BytesToBytes(bytes: Entropy24Bytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_entropy24_bytes_to_bytes(
        FfiConverterTypeEntropy24Bytes.lower(bytes),$0
    )
})
}
public func entropy28BytesToBytes(bytes: Entropy28Bytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_entropy28_bytes_to_bytes(
        FfiConverterTypeEntropy28Bytes.lower(bytes),$0
    )
})
}
public func entropy32BytesToBytes(bytes: Entropy32Bytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_entropy32_bytes_to_bytes(
        FfiConverterTypeEntropy32Bytes.lower(bytes),$0
    )
})
}
public func errorCodeFromError(error: CommonError) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_error_code_from_error(
        FfiConverterTypeCommonError.lower(error),$0
    )
})
}
public func errorMessageFromError(error: CommonError) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_error_message_from_error(
        FfiConverterTypeCommonError.lower(error),$0
    )
})
}
public func eventKind(event: Event) -> EventKind  {
    return try!  FfiConverterTypeEventKind.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_event_kind(
        FfiConverterTypeEvent.lower(event),$0
    )
})
}
public func eventKindAffectsCurrentAccounts(eventKind: EventKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_event_kind_affects_current_accounts(
        FfiConverterTypeEventKind.lower(eventKind),$0
    )
})
}
public func eventKindAffectsCurrentNetwork(eventKind: EventKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_event_kind_affects_current_network(
        FfiConverterTypeEventKind.lower(eventKind),$0
    )
})
}
public func eventKindAffectsFactorSources(eventKind: EventKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_event_kind_affects_factor_sources(
        FfiConverterTypeEventKind.lower(eventKind),$0
    )
})
}
public func eventKindAffectsSavedGateways(eventKind: EventKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_event_kind_affects_saved_gateways(
        FfiConverterTypeEventKind.lower(eventKind),$0
    )
})
}
public func eventKindAffectsSecurityStructures(eventKind: EventKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_event_kind_affects_security_structures(
        FfiConverterTypeEventKind.lower(eventKind),$0
    )
})
}
public func eventKindAll() -> [EventKind]  {
    return try!  FfiConverterSequenceTypeEventKind.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_event_kind_all($0
    )
})
}
public func exactly12BytesToJsonString(exactly12Bytes: Exactly12Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly12_bytes_to_json_string(
        FfiConverterTypeExactly12Bytes.lower(exactly12Bytes),$0
    )
})
}
public func exactly29BytesToJsonString(exactly29Bytes: Exactly29Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly29_bytes_to_json_string(
        FfiConverterTypeExactly29Bytes.lower(exactly29Bytes),$0
    )
})
}
public func exactly32BytesToJsonString(exactly32Bytes: Exactly32Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly32_bytes_to_json_string(
        FfiConverterTypeExactly32Bytes.lower(exactly32Bytes),$0
    )
})
}
public func exactly33BytesToJsonString(exactly33Bytes: Exactly33Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly33_bytes_to_json_string(
        FfiConverterTypeExactly33Bytes.lower(exactly33Bytes),$0
    )
})
}
public func exactly60BytesToJsonString(exactly60Bytes: Exactly60Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly60_bytes_to_json_string(
        FfiConverterTypeExactly60Bytes.lower(exactly60Bytes),$0
    )
})
}
public func exactly64BytesToJsonString(exactly64Bytes: Exactly64Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly64_bytes_to_json_string(
        FfiConverterTypeExactly64Bytes.lower(exactly64Bytes),$0
    )
})
}
public func exactly65BytesToJsonString(exactly65Bytes: Exactly65Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly65_bytes_to_json_string(
        FfiConverterTypeExactly65Bytes.lower(exactly65Bytes),$0
    )
})
}
public func exactly12BytesToBytes(bytes: Exactly12Bytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_12_bytes_to_bytes(
        FfiConverterTypeExactly12Bytes.lower(bytes),$0
    )
})
}
public func exactly12BytesToHex(bytes: Exactly12Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_12_bytes_to_hex(
        FfiConverterTypeExactly12Bytes.lower(bytes),$0
    )
})
}
public func exactly29BytesToBytes(bytes: Exactly29Bytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_29_bytes_to_bytes(
        FfiConverterTypeExactly29Bytes.lower(bytes),$0
    )
})
}
public func exactly29BytesToHex(bytes: Exactly29Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_29_bytes_to_hex(
        FfiConverterTypeExactly29Bytes.lower(bytes),$0
    )
})
}
public func exactly32BytesToBytes(bytes: Exactly32Bytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_32_bytes_to_bytes(
        FfiConverterTypeExactly32Bytes.lower(bytes),$0
    )
})
}
public func exactly32BytesToHex(bytes: Exactly32Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_32_bytes_to_hex(
        FfiConverterTypeExactly32Bytes.lower(bytes),$0
    )
})
}
public func exactly33BytesToBytes(bytes: Exactly33Bytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_33_bytes_to_bytes(
        FfiConverterTypeExactly33Bytes.lower(bytes),$0
    )
})
}
public func exactly33BytesToHex(bytes: Exactly33Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_33_bytes_to_hex(
        FfiConverterTypeExactly33Bytes.lower(bytes),$0
    )
})
}
public func exactly60BytesToBytes(bytes: Exactly60Bytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_60_bytes_to_bytes(
        FfiConverterTypeExactly60Bytes.lower(bytes),$0
    )
})
}
public func exactly60BytesToHex(bytes: Exactly60Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_60_bytes_to_hex(
        FfiConverterTypeExactly60Bytes.lower(bytes),$0
    )
})
}
public func exactly64BytesToBytes(bytes: Exactly64Bytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_64_bytes_to_bytes(
        FfiConverterTypeExactly64Bytes.lower(bytes),$0
    )
})
}
public func exactly64BytesToHex(bytes: Exactly64Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_64_bytes_to_hex(
        FfiConverterTypeExactly64Bytes.lower(bytes),$0
    )
})
}
public func exactly65BytesToBytes(bytes: Exactly65Bytes) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_65_bytes_to_bytes(
        FfiConverterTypeExactly65Bytes.lower(bytes),$0
    )
})
}
public func exactly65BytesToHex(bytes: Exactly65Bytes) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_exactly_65_bytes_to_hex(
        FfiConverterTypeExactly65Bytes.lower(bytes),$0
    )
})
}
public func factorSourceCryptoParametersSupportsBabylon(parameters: FactorSourceCryptoParameters) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_crypto_parameters_supports_babylon(
        FfiConverterTypeFactorSourceCryptoParameters.lower(parameters),$0
    )
})
}
public func factorSourceCryptoParametersSupportsOlympia(parameters: FactorSourceCryptoParameters) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_crypto_parameters_supports_olympia(
        FfiConverterTypeFactorSourceCryptoParameters.lower(parameters),$0
    )
})
}
public func factorSourceIDFromAddressToJsonBytes(factorSourceIDFromAddress: FactorSourceIdFromAddress) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_i_d_from_address_to_json_bytes(
        FfiConverterTypeFactorSourceIDFromAddress.lower(factorSourceIDFromAddress),$0
    )
})
}
public func factorSourceIDFromHashToJsonBytes(factorSourceIDFromHash: FactorSourceIdFromHash) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_i_d_from_hash_to_json_bytes(
        FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceIDFromHash),$0
    )
})
}
public func factorSourceIDToJsonBytes(factorSourceID: FactorSourceId) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_i_d_to_json_bytes(
        FfiConverterTypeFactorSourceID.lower(factorSourceID),$0
    )
})
}
public func factorSourceIdFromAddressToString(factorSourceId: FactorSourceIdFromAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_id_from_address_to_string(
        FfiConverterTypeFactorSourceIDFromAddress.lower(factorSourceId),$0
    )
})
}
public func factorSourceIdFromHashPerformSpotCheck(factorSourceIdFromHash: FactorSourceIdFromHash, input: SpotCheckInput) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_id_from_hash_perform_spot_check(
        FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceIdFromHash),
        FfiConverterTypeSpotCheckInput.lower(input),$0
    )
})
}
public func factorSourceIdFromHashToString(factorSourceId: FactorSourceIdFromHash) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_id_from_hash_to_string(
        FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceId),$0
    )
})
}
public func factorSourceIdPerformSpotCheck(factorSourceId: FactorSourceId, input: SpotCheckInput) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_id_perform_spot_check(
        FfiConverterTypeFactorSourceID.lower(factorSourceId),
        FfiConverterTypeSpotCheckInput.lower(input),$0
    )
})
}
public func factorSourceIdToString(factorSourceId: FactorSourceId) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_id_to_string(
        FfiConverterTypeFactorSourceID.lower(factorSourceId),$0
    )
})
}
public func factorSourceKindToString(kind: FactorSourceKind) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_kind_to_string(
        FfiConverterTypeFactorSourceKind.lower(kind),$0
    )
})
}
public func factorSourceName(factorSource: FactorSource) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_name(
        FfiConverterTypeFactorSource.lower(factorSource),$0
    )
})
}
public func factorSourcePerformSpotCheck(factorSource: FactorSource, input: SpotCheckInput) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_perform_spot_check(
        FfiConverterTypeFactorSource.lower(factorSource),
        FfiConverterTypeSpotCheckInput.lower(input),$0
    )
})
}
public func factorSourceSupportsBabylon(factorSource: FactorSource) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_supports_babylon(
        FfiConverterTypeFactorSource.lower(factorSource),$0
    )
})
}
public func factorSourceSupportsOlympia(factorSource: FactorSource) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_supports_olympia(
        FfiConverterTypeFactorSource.lower(factorSource),$0
    )
})
}
public func factorSourceToString(factorSource: FactorSource) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_source_to_string(
        FfiConverterTypeFactorSource.lower(factorSource),$0
    )
})
}
public func factorSourcesAllSampleValues() -> [FactorSource]  {
    return try!  FfiConverterSequenceTypeFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_factor_sources_all_sample_values($0
    )
})
}
public func ffiUrlGetUrl(ffiUrl: FfiUrl) -> Url  {
    return try!  FfiConverterTypeUrl.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_ffi_url_get_url(
        FfiConverterTypeFfiUrl.lower(ffiUrl),$0
    )
})
}
public func fiatCurrencyToJsonString(fiatCurrency: FiatCurrency) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_fiat_currency_to_json_string(
        FfiConverterTypeFiatCurrency.lower(fiatCurrency),$0
    )
})
}
public func fungibleResourceIndicatorGetAmount(indicator: FungibleResourceIndicator) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_fungible_resource_indicator_get_amount(
        FfiConverterTypeFungibleResourceIndicator.lower(indicator),$0
    )
})
}
public func gatewayId(gateway: Gateway) -> Url  {
    return try!  FfiConverterTypeUrl.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_gateway_id(
        FfiConverterTypeGateway.lower(gateway),$0
    )
})
}
public func gatewayIsWellknown(gateway: Gateway) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_gateway_is_wellknown(
        FfiConverterTypeGateway.lower(gateway),$0
    )
})
}
public func gatewayMainnet() -> Gateway  {
    return try!  FfiConverterTypeGateway.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_gateway_mainnet($0
    )
})
}
public func gatewayStokenet() -> Gateway  {
    return try!  FfiConverterTypeGateway.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_gateway_stokenet($0
    )
})
}
public func gatewayToString(gateway: Gateway) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_gateway_to_string(
        FfiConverterTypeGateway.lower(gateway),$0
    )
})
}
public func gatewayWellknownGateways() -> [Gateway]  {
    return try!  FfiConverterSequenceTypeGateway.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_gateway_wellknown_gateways($0
    )
})
}
public func getSubintentExpirationStatus(expiration: DappToWalletInteractionSubintentExpiration) -> DappToWalletInteractionSubintentExpirationStatus  {
    return try!  FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_get_subintent_expiration_status(
        FfiConverterTypeDappToWalletInteractionSubintentExpiration.lower(expiration),$0
    )
})
}
public func hash(data: BagOfBytes) -> Hash  {
    return try!  FfiConverterTypeHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_hash(
        FfiConverterTypeBagOfBytes.lower(data),$0
    )
})
}
public func hashGetBytes(hash: Hash) -> Exactly32Bytes  {
    return try!  FfiConverterTypeExactly32Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_hash_get_bytes(
        FfiConverterTypeHash.lower(hash),$0
    )
})
}
public func hdPathComponentGetKeySpace(component: HdPathComponent) -> KeySpace  {
    return try!  FfiConverterTypeKeySpace.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_hd_path_component_get_key_space(
        FfiConverterTypeHDPathComponent.lower(component),$0
    )
})
}
public func hdPathComponentIndexInGlobalKeySpace(component: HdPathComponent) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_hd_path_component_index_in_global_key_space(
        FfiConverterTypeHDPathComponent.lower(component),$0
    )
})
}
public func hdPathComponentIndexInLocalKeySpace(component: HdPathComponent) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_hd_path_component_index_in_local_key_space(
        FfiConverterTypeHDPathComponent.lower(component),$0
    )
})
}
public func hdPathComponentToBip32String(component: HdPathComponent) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_hd_path_component_to_bip32_string(
        FfiConverterTypeHDPathComponent.lower(component),$0
    )
})
}
public func hdPathComponentToBip32StringDebug(component: HdPathComponent) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_hd_path_component_to_bip32_string_debug(
        FfiConverterTypeHDPathComponent.lower(component),$0
    )
})
}
public func hdPathComponentToHardened(component: HdPathComponent)throws  -> Hardened  {
    return try  FfiConverterTypeHardened.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_hd_path_component_to_hardened(
        FfiConverterTypeHDPathComponent.lower(component),$0
    )
})
}
public func headerToJsonBytes(header: Header) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_header_to_json_bytes(
        FfiConverterTypeHeader.lower(header),$0
    )
})
}
public func hierarchicalDeterministicPublicKeyIsValidSignatureForHash(key: HierarchicalDeterministicPublicKey, signature: Signature, hash: Hash) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_hierarchical_deterministic_public_key_is_valid_signature_for_hash(
        FfiConverterTypeHierarchicalDeterministicPublicKey.lower(key),
        FfiConverterTypeSignature.lower(signature),
        FfiConverterTypeHash.lower(hash),$0
    )
})
}
public func hostIdToJsonBytes(hostId: HostId) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_host_id_to_json_bytes(
        FfiConverterTypeHostId.lower(hostId),$0
    )
})
}
public func hostOsGetName(hostOs: HostOs) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_host_os_get_name(
        FfiConverterTypeHostOS.lower(hostOs),$0
    )
})
}
public func hostOsGetVendor(hostOs: HostOs) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_host_os_get_vendor(
        FfiConverterTypeHostOS.lower(hostOs),$0
    )
})
}
public func hostOsGetVersion(hostOs: HostOs) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_host_os_get_version(
        FfiConverterTypeHostOS.lower(hostOs),$0
    )
})
}
public func identityAddressBech32Address(address: IdentityAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_identity_address_bech32_address(
        FfiConverterTypeIdentityAddress.lower(address),$0
    )
})
}
public func identityAddressFormatted(address: IdentityAddress, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_identity_address_formatted(
        FfiConverterTypeIdentityAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func identityAddressMapToNetwork(address: IdentityAddress, networkId: NetworkId) -> IdentityAddress  {
    return try!  FfiConverterTypeIdentityAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_identity_address_map_to_network(
        FfiConverterTypeIdentityAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func identityAddressNetworkId(address: IdentityAddress) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_identity_address_network_id(
        FfiConverterTypeIdentityAddress.lower(address),$0
    )
})
}
public func imageUrlUtilsIsVectorImage(url: String, imageType: VectorImageType) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_image_url_utils_is_vector_image(
        FfiConverterString.lower(url),
        FfiConverterTypeVectorImageType.lower(imageType),$0
    )
})
}
public func imageUrlUtilsMakeImageUrl(url: String, imageServiceUrl: String, width: UInt32, height: UInt32)throws  -> Url  {
    return try  FfiConverterTypeUrl.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_image_url_utils_make_image_url(
        FfiConverterString.lower(url),
        FfiConverterString.lower(imageServiceUrl),
        FfiConverterUInt32.lower(width),
        FfiConverterUInt32.lower(height),$0
    )
})
}
public func intentDiscriminatorGetValue(intentDiscriminator: IntentDiscriminator) -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_intent_discriminator_get_value(
        FfiConverterTypeIntentDiscriminator.lower(intentDiscriminator),$0
    )
})
}
public func intentSignatureGetSignatureWithPublicKey(intentSignature: IntentSignature) -> SignatureWithPublicKey  {
    return try!  FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_intent_signature_get_signature_with_public_key(
        FfiConverterTypeIntentSignature.lower(intentSignature),$0
    )
})
}
public func isSafeToShowErrorMessageFromError(error: CommonError) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_is_safe_to_show_error_message_from_error(
        FfiConverterTypeCommonError.lower(error),$0
    )
})
}
/**
 * Returns the public key on **compressed** form (33 bytes)
 */
public func keyAgreementPublicKeyToBytes(publicKey: KeyAgreementPublicKey) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_key_agreement_public_key_to_bytes(
        FfiConverterTypeKeyAgreementPublicKey.lower(publicKey),$0
    )
})
}
/**
 * Encodes the compressed form (33 bytes) of a `Secp256k1PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"033083620d1596d3f8988ff3270e42970dd2a031e2b9b6488052a4170ff999f3e8"`
 */
public func keyAgreementPublicKeyToHex(publicKey: KeyAgreementPublicKey) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_key_agreement_public_key_to_hex(
        FfiConverterTypeKeyAgreementPublicKey.lower(publicKey),$0
    )
})
}
public func ledgerHwWalletModelToString(model: LedgerHardwareWalletModel) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_ledger_hw_wallet_model_to_string(
        FfiConverterTypeLedgerHardwareWalletModel.lower(model),$0
    )
})
}
public func legacyOlympiaAccountAddressFormatted(address: LegacyOlympiaAccountAddress, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_legacy_olympia_account_address_formatted(
        FfiConverterTypeLegacyOlympiaAccountAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
public func legacyOlympiaAccountAddressIsLegacyOfBabylon(legacyOlympiaAddress: LegacyOlympiaAccountAddress, babylonAccountAddress: AccountAddress) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_legacy_olympia_account_address_is_legacy_of_babylon(
        FfiConverterTypeLegacyOlympiaAccountAddress.lower(legacyOlympiaAddress),
        FfiConverterTypeAccountAddress.lower(babylonAccountAddress),$0
    )
})
}
public func legacyOlympiaAccountAddressToBabylonAccountAddress(address: LegacyOlympiaAccountAddress) -> AccountAddress  {
    return try!  FfiConverterTypeAccountAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_legacy_olympia_account_address_to_babylon_account_address(
        FfiConverterTypeLegacyOlympiaAccountAddress.lower(address),$0
    )
})
}
public func legacyOlympiaAccountAddressToString(address: LegacyOlympiaAccountAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_legacy_olympia_account_address_to_string(
        FfiConverterTypeLegacyOlympiaAccountAddress.lower(address),$0
    )
})
}
public func linkConnectionQRDataToJsonBytes(linkConnectionQRData: LinkConnectionQrData) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_link_connection_q_r_data_to_json_bytes(
        FfiConverterTypeLinkConnectionQRData.lower(linkConnectionQRData),$0
    )
})
}
public func lockerAddressBech32Address(address: LockerAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_locker_address_bech32_address(
        FfiConverterTypeLockerAddress.lower(address),$0
    )
})
}
public func lockerAddressFormatted(address: LockerAddress, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_locker_address_formatted(
        FfiConverterTypeLockerAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func lockerAddressMapToNetwork(address: LockerAddress, networkId: NetworkId) -> LockerAddress  {
    return try!  FfiConverterTypeLockerAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_locker_address_map_to_network(
        FfiConverterTypeLockerAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func lockerAddressNetworkId(address: LockerAddress) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_locker_address_network_id(
        FfiConverterTypeLockerAddress.lower(address),$0
    )
})
}
public func manifestAccountLockerClaim(lockerAddress: LockerAddress, claimant: AccountAddress, claimableResources: [AccountLockerClaimableResource]) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_account_locker_claim(
        FfiConverterTypeLockerAddress.lower(lockerAddress),
        FfiConverterTypeAccountAddress.lower(claimant),
        FfiConverterSequenceTypeAccountLockerClaimableResource.lower(claimableResources),$0
    )
})
}
public func manifestCreateFungibleToken(addressOfOwner: AccountAddress) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_create_fungible_token(
        FfiConverterTypeAccountAddress.lower(addressOfOwner),$0
    )
})
}
public func manifestCreateFungibleTokenWithMetadata(addressOfOwner: AccountAddress, initialSupply: Decimal192, metadata: TokenDefinitionMetadata) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_create_fungible_token_with_metadata(
        FfiConverterTypeAccountAddress.lower(addressOfOwner),
        FfiConverterTypeDecimal192.lower(initialSupply),
        FfiConverterTypeTokenDefinitionMetadata.lower(metadata),$0
    )
})
}
/**
 * Creates many fungible tokens, with initial supply, to be owned by `address_of_owner`.
 *
 * # Panics
 * Panics if `address_of_owner` is on `Mainnet`, use a testnet instead.
 * Panics if `count` is zero or is greater than the number of token metadata defined in `sample_resource_definition_metadata` (25)
 */
public func manifestCreateMultipleFungibleTokens(addressOfOwner: AccountAddress, count: UInt8?) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_create_multiple_fungible_tokens(
        FfiConverterTypeAccountAddress.lower(addressOfOwner),
        FfiConverterOptionUInt8.lower(count),$0
    )
})
}
public func manifestCreateMultipleNonFungibleTokens(addressOfOwner: AccountAddress, collectionCount: UInt8?, nftsPerCollection: UInt8?) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_create_multiple_non_fungible_tokens(
        FfiConverterTypeAccountAddress.lower(addressOfOwner),
        FfiConverterOptionUInt8.lower(collectionCount),
        FfiConverterOptionUInt8.lower(nftsPerCollection),$0
    )
})
}
public func manifestCreateNonFungibleToken(addressOfOwner: AccountAddress, nftsPerCollection: UInt8?) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_create_non_fungible_token(
        FfiConverterTypeAccountAddress.lower(addressOfOwner),
        FfiConverterOptionUInt8.lower(nftsPerCollection),$0
    )
})
}
public func manifestEncounteredComponentAddressFormatted(address: ManifestEncounteredComponentAddress, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_formatted(
        FfiConverterTypeManifestEncounteredComponentAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
public func manifestEncounteredComponentAddressMapToNetwork(address: ManifestEncounteredComponentAddress, networkId: NetworkId) -> ManifestEncounteredComponentAddress  {
    return try!  FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_map_to_network(
        FfiConverterTypeManifestEncounteredComponentAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func manifestEncounteredComponentAddressNetworkId(address: ManifestEncounteredComponentAddress) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_network_id(
        FfiConverterTypeManifestEncounteredComponentAddress.lower(address),$0
    )
})
}
public func manifestEncounteredComponentAddressSampleValuesAll() -> [ManifestEncounteredComponentAddress]  {
    return try!  FfiConverterSequenceTypeManifestEncounteredComponentAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_sample_values_all($0
    )
})
}
public func manifestEncounteredComponentAddressToString(address: ManifestEncounteredComponentAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_to_string(
        FfiConverterTypeManifestEncounteredComponentAddress.lower(address),$0
    )
})
}
public func manifestForFaucet(includeLockFeeInstruction: Bool, addressOfReceivingAccount: AccountAddress) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_for_faucet(
        FfiConverterBool.lower(includeLockFeeInstruction),
        FfiConverterTypeAccountAddress.lower(addressOfReceivingAccount),$0
    )
})
}
public func manifestMarkingAccountAsDappDefinitionType(accountAddress: AccountAddress) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_marking_account_as_dapp_definition_type(
        FfiConverterTypeAccountAddress.lower(accountAddress),$0
    )
})
}
public func manifestPerAssetTransfers(transfers: PerAssetTransfers) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_per_asset_transfers(
        FfiConverterTypePerAssetTransfers.lower(transfers),$0
    )
})
}
/**
 * Uses `per_asset_transfers` after having transposed the `PerRecipientAssetTransfers`
 * into `PerAssetTransfers`. We always use `PerAssetTransfers` when building the manifest
 * since it is more efficient (allows a single withdraw per resource) => fewer instruction =>
 * cheaper TX fee for user.
 */
public func manifestPerRecipientTransfers(transfers: PerRecipientAssetTransfers) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_per_recipient_transfers(
        FfiConverterTypePerRecipientAssetTransfers.lower(transfers),$0
    )
})
}
public func manifestSetOwnerKeysHashes(addressOfAccountOrPersona: AddressOfAccountOrPersona, ownerKeyHashes: [PublicKeyHash]) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_set_owner_keys_hashes(
        FfiConverterTypeAddressOfAccountOrPersona.lower(addressOfAccountOrPersona),
        FfiConverterSequenceTypePublicKeyHash.lower(ownerKeyHashes),$0
    )
})
}
public func manifestStakesClaim(accountAddress: AccountAddress, stakeClaims: [StakeClaim]) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_stakes_claim(
        FfiConverterTypeAccountAddress.lower(accountAddress),
        FfiConverterSequenceTypeStakeClaim.lower(stakeClaims),$0
    )
})
}
public func manifestThirdPartyDepositUpdate(accountAddress: AccountAddress, from: ThirdPartyDeposits, to: ThirdPartyDeposits) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_manifest_third_party_deposit_update(
        FfiConverterTypeAccountAddress.lower(accountAddress),
        FfiConverterTypeThirdPartyDeposits.lower(from),
        FfiConverterTypeThirdPartyDeposits.lower(to),$0
    )
})
}
public func messageAsPlaintext(message: Message) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_message_as_plaintext(
        FfiConverterTypeMessage.lower(message),$0
    )
})
}
public func messageV2AsPlaintext(message: MessageV2) -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_message_v2_as_plaintext(
        FfiConverterTypeMessageV2.lower(message),$0
    )
})
}
/**
 * Returns the words of a mnemonic as a String joined by spaces, e.g. "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong"
 */
public func mnemonicPhrase(from: Mnemonic) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_mnemonic_phrase(
        FfiConverterTypeMnemonic.lower(from),$0
    )
})
}
public func mnemonicWithPassphraseDerivePublicKeys(mnemonicWithPassphrase: MnemonicWithPassphrase, derivationPaths: [DerivationPath]) -> [HierarchicalDeterministicPublicKey]  {
    return try!  FfiConverterSequenceTypeHierarchicalDeterministicPublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_mnemonic_with_passphrase_derive_public_keys(
        FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
        FfiConverterSequenceTypeDerivationPath.lower(derivationPaths),$0
    )
})
}
public func mnemonicWithPassphraseSign(mnemonicWithPassphrase: MnemonicWithPassphrase, derivationPath: DerivationPath, hashToSign: Hash) -> SignatureWithPublicKey  {
    return try!  FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_mnemonic_with_passphrase_sign(
        FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
        FfiConverterTypeDerivationPath.lower(derivationPath),
        FfiConverterTypeHash.lower(hashToSign),$0
    )
})
}
public func mnemonicWithPassphraseToJsonBytes(mnemonicWithPassphrase: MnemonicWithPassphrase) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_mnemonic_with_passphrase_to_json_bytes(
        FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),$0
    )
})
}
/**
 * Returns `true` if this MnemonicWithPassphrase successfully validates all `hd_keys`, that is to say,
 * that all the HierarchicalDeterministicPublicKey were indeed crated by this MnemonicWithPassphrase.
 */
public func mnemonicWithPassphraseValidatePublicKeys(mnemonicWithPassphrase: MnemonicWithPassphrase, hdKeys: [HierarchicalDeterministicPublicKey]) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_mnemonic_with_passphrase_validate_public_keys(
        FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
        FfiConverterSequenceTypeHierarchicalDeterministicPublicKey.lower(hdKeys),$0
    )
})
}
/**
 * Modifies `manifest` by inserting transaction "guarantees", which is the wallet
 * term for `assert_worktop_contains`.
 */
public func modifyManifestAddGuarantees(manifest: TransactionManifest, guarantees: [TransactionGuarantee])throws  -> TransactionManifest  {
    return try  FfiConverterTypeTransactionManifest.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_modify_manifest_add_guarantees(
        FfiConverterTypeTransactionManifest.lower(manifest),
        FfiConverterSequenceTypeTransactionGuarantee.lower(guarantees),$0
    )
})
}
public func modifyManifestLockFee(manifest: TransactionManifest, addressOfFeePayer: AccountAddress, fee: Decimal192?) -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_modify_manifest_lock_fee(
        FfiConverterTypeTransactionManifest.lower(manifest),
        FfiConverterTypeAccountAddress.lower(addressOfFeePayer),
        FfiConverterOptionTypeDecimal192.lower(fee),$0
    )
})
}
public func networkIdDiscriminant(id: NetworkId) -> UInt8  {
    return try!  FfiConverterUInt8.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_network_id_discriminant(
        FfiConverterTypeNetworkID.lower(id),$0
    )
})
}
public func networkIdToString(id: NetworkId) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_network_id_to_string(
        FfiConverterTypeNetworkID.lower(id),$0
    )
})
}
public func networkIdsAll() -> [NetworkId]  {
    return try!  FfiConverterSequenceTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_network_ids_all($0
    )
})
}
public func networkMethodToString(method: NetworkMethod) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_network_method_to_string(
        FfiConverterTypeNetworkMethod.lower(method),$0
    )
})
}
public func newAccessControllerAddress(bech32: String)throws  -> AccessControllerAddress  {
    return try  FfiConverterTypeAccessControllerAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_access_controller_address(
        FfiConverterString.lower(bech32),$0
    )
})
}
/**
 * Returns a random address in `network_id` as Network
 */
public func newAccessControllerAddressRandom(networkId: NetworkId) -> AccessControllerAddress  {
    return try!  FfiConverterTypeAccessControllerAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_access_controller_address_random(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func newAccessControllerAddressSampleMainnet() -> AccessControllerAddress  {
    return try!  FfiConverterTypeAccessControllerAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_access_controller_address_sample_mainnet($0
    )
})
}
public func newAccessControllerAddressSampleMainnetOther() -> AccessControllerAddress  {
    return try!  FfiConverterTypeAccessControllerAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_access_controller_address_sample_mainnet_other($0
    )
})
}
public func newAccessControllerAddressSampleStokenet() -> AccessControllerAddress  {
    return try!  FfiConverterTypeAccessControllerAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_access_controller_address_sample_stokenet($0
    )
})
}
public func newAccessControllerAddressSampleStokenetOther() -> AccessControllerAddress  {
    return try!  FfiConverterTypeAccessControllerAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_access_controller_address_sample_stokenet_other($0
    )
})
}
public func newAccountAddress(bech32: String)throws  -> AccountAddress  {
    return try  FfiConverterTypeAccountAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_account_address(
        FfiConverterString.lower(bech32),$0
    )
})
}
public func newAccountAddressFrom(publicKey: PublicKey, networkId: NetworkId) -> AccountAddress  {
    return try!  FfiConverterTypeAccountAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_address_from(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
/**
 * Returns a random address in `network_id` as Network
 */
public func newAccountAddressRandom(networkId: NetworkId) -> AccountAddress  {
    return try!  FfiConverterTypeAccountAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_address_random(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func newAccountAddressSampleMainnet() -> AccountAddress  {
    return try!  FfiConverterTypeAccountAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_address_sample_mainnet($0
    )
})
}
public func newAccountAddressSampleMainnetOther() -> AccountAddress  {
    return try!  FfiConverterTypeAccountAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_address_sample_mainnet_other($0
    )
})
}
public func newAccountAddressSampleStokenet() -> AccountAddress  {
    return try!  FfiConverterTypeAccountAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_address_sample_stokenet($0
    )
})
}
public func newAccountAddressSampleStokenetOther() -> AccountAddress  {
    return try!  FfiConverterTypeAccountAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_address_sample_stokenet_other($0
    )
})
}
public func newAccountForDisplayFromAccount(account: Account) -> AccountForDisplay  {
    return try!  FfiConverterTypeAccountForDisplay.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_for_display_from_account(
        FfiConverterTypeAccount.lower(account),$0
    )
})
}
public func newAccountForDisplaySample() -> AccountForDisplay  {
    return try!  FfiConverterTypeAccountForDisplay.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_for_display_sample($0
    )
})
}
public func newAccountForDisplaySampleOther() -> AccountForDisplay  {
    return try!  FfiConverterTypeAccountForDisplay.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_for_display_sample_other($0
    )
})
}
public func newAccountLockerClaimableResourceSample() -> AccountLockerClaimableResource  {
    return try!  FfiConverterTypeAccountLockerClaimableResource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_locker_claimable_resource_sample($0
    )
})
}
public func newAccountLockerClaimableResourceSampleOther() -> AccountLockerClaimableResource  {
    return try!  FfiConverterTypeAccountLockerClaimableResource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_locker_claimable_resource_sample_other($0
    )
})
}
public func newAccountOrAddressOfSample() -> TransferRecipient  {
    return try!  FfiConverterTypeTransferRecipient.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_or_address_of_sample($0
    )
})
}
public func newAccountOrAddressOfSampleOther() -> TransferRecipient  {
    return try!  FfiConverterTypeTransferRecipient.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_or_address_of_sample_other($0
    )
})
}
public func newAccountOrPersonaSampleMainnet() -> AccountOrPersona  {
    return try!  FfiConverterTypeAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_mainnet($0
    )
})
}
public func newAccountOrPersonaSampleMainnetOther() -> AccountOrPersona  {
    return try!  FfiConverterTypeAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_mainnet_other($0
    )
})
}
public func newAccountOrPersonaSampleMainnetThird() -> AccountOrPersona  {
    return try!  FfiConverterTypeAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_mainnet_third($0
    )
})
}
public func newAccountOrPersonaSampleStokenet() -> AccountOrPersona  {
    return try!  FfiConverterTypeAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_stokenet($0
    )
})
}
public func newAccountOrPersonaSampleStokenetOther() -> AccountOrPersona  {
    return try!  FfiConverterTypeAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_stokenet_other($0
    )
})
}
public func newAccountOrPersonaSampleStokenetThird() -> AccountOrPersona  {
    return try!  FfiConverterTypeAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_stokenet_third($0
    )
})
}
public func newAccountPath(networkId: NetworkId, keyKind: Cap26KeyKind, index: Hardened) -> AccountPath  {
    return try!  FfiConverterTypeAccountPath.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_path(
        FfiConverterTypeNetworkID.lower(networkId),
        FfiConverterTypeCAP26KeyKind.lower(keyKind),
        FfiConverterTypeHardened.lower(index),$0
    )
})
}
public func newAccountPathSample() -> AccountPath  {
    return try!  FfiConverterTypeAccountPath.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_path_sample($0
    )
})
}
public func newAccountPathSampleOther() -> AccountPath  {
    return try!  FfiConverterTypeAccountPath.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_path_sample_other($0
    )
})
}
public func newAccountSampleMainnetAlice() -> Account  {
    return try!  FfiConverterTypeAccount.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_sample_mainnet_alice($0
    )
})
}
public func newAccountSampleMainnetBob() -> Account  {
    return try!  FfiConverterTypeAccount.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_sample_mainnet_bob($0
    )
})
}
public func newAccountSampleMainnetCarol() -> Account  {
    return try!  FfiConverterTypeAccount.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_sample_mainnet_carol($0
    )
})
}
public func newAccountSampleMainnetDiana() -> Account  {
    return try!  FfiConverterTypeAccount.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_sample_mainnet_diana($0
    )
})
}
public func newAccountSampleStokenetNadia() -> Account  {
    return try!  FfiConverterTypeAccount.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_sample_stokenet_nadia($0
    )
})
}
public func newAccountSampleStokenetOlivia() -> Account  {
    return try!  FfiConverterTypeAccount.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_sample_stokenet_olivia($0
    )
})
}
public func newAccountSampleStokenetPaige() -> Account  {
    return try!  FfiConverterTypeAccount.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_account_sample_stokenet_paige($0
    )
})
}
public func newAccountsForDisplaySample() -> [AccountForDisplay]  {
    return try!  FfiConverterSequenceTypeAccountForDisplay.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_accounts_for_display_sample($0
    )
})
}
public func newAccountsForDisplaySampleOther() -> [AccountForDisplay]  {
    return try!  FfiConverterSequenceTypeAccountForDisplay.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_accounts_for_display_sample_other($0
    )
})
}
public func newAccountsOrPersonasSample() -> [AccountOrPersona]  {
    return try!  FfiConverterSequenceTypeAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_accounts_or_personas_sample($0
    )
})
}
public func newAccountsOrPersonasSampleOther() -> [AccountOrPersona]  {
    return try!  FfiConverterSequenceTypeAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_accounts_or_personas_sample_other($0
    )
})
}
public func newAccountsSample() -> [Account]  {
    return try!  FfiConverterSequenceTypeAccount.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_accounts_sample($0
    )
})
}
public func newAccountsSampleOther() -> [Account]  {
    return try!  FfiConverterSequenceTypeAccount.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_accounts_sample_other($0
    )
})
}
public func newAddressFromBech32(string: String)throws  -> Address  {
    return try  FfiConverterTypeAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_address_from_bech32(
        FfiConverterString.lower(string),$0
    )
})
}
public func newAddressOfAccountOrPersonaFromBech32(string: String)throws  -> AddressOfAccountOrPersona  {
    return try  FfiConverterTypeAddressOfAccountOrPersona.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_from_bech32(
        FfiConverterString.lower(string),$0
    )
})
}
public func newAddressOfAccountOrPersonaSampleMainnet() -> AddressOfAccountOrPersona  {
    return try!  FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_sample_mainnet($0
    )
})
}
public func newAddressOfAccountOrPersonaSampleMainnetOther() -> AddressOfAccountOrPersona  {
    return try!  FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_sample_mainnet_other($0
    )
})
}
public func newAddressOfAccountOrPersonaSampleStokenet() -> AddressOfAccountOrPersona  {
    return try!  FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_sample_stokenet($0
    )
})
}
public func newAddressOfAccountOrPersonaSampleStokenetOther() -> AddressOfAccountOrPersona  {
    return try!  FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_sample_stokenet_other($0
    )
})
}
public func newAddressSampleMainnet() -> Address  {
    return try!  FfiConverterTypeAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_address_sample_mainnet($0
    )
})
}
public func newAddressSampleMainnetOther() -> Address  {
    return try!  FfiConverterTypeAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_address_sample_mainnet_other($0
    )
})
}
public func newAddressSampleStokenet() -> Address  {
    return try!  FfiConverterTypeAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_address_sample_stokenet($0
    )
})
}
public func newAddressSampleStokenetOther() -> Address  {
    return try!  FfiConverterTypeAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_address_sample_stokenet_other($0
    )
})
}
public func newAppPreferencesDefault() -> AppPreferences  {
    return try!  FfiConverterTypeAppPreferences.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_app_preferences_default($0
    )
})
}
public func newAppPreferencesSample() -> AppPreferences  {
    return try!  FfiConverterTypeAppPreferences.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_app_preferences_sample($0
    )
})
}
public func newAppPreferencesSampleOther() -> AppPreferences  {
    return try!  FfiConverterTypeAppPreferences.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_app_preferences_sample_other($0
    )
})
}
public func newAppearanceId(validating: UInt8)throws  -> AppearanceId  {
    return try  FfiConverterTypeAppearanceID.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_appearance_id(
        FfiConverterUInt8.lower(validating),$0
    )
})
}
public func newAppearanceIdFromNumberOfAccountsOnNetwork(count: UInt64) -> AppearanceId  {
    return try!  FfiConverterTypeAppearanceID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_appearance_id_from_number_of_accounts_on_network(
        FfiConverterUInt64.lower(count),$0
    )
})
}
public func newAppearanceIdSample() -> AppearanceId  {
    return try!  FfiConverterTypeAppearanceID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_appearance_id_sample($0
    )
})
}
public func newAppearanceIdSampleOther() -> AppearanceId  {
    return try!  FfiConverterTypeAppearanceID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_appearance_id_sample_other($0
    )
})
}
public func newArculusCardFactorSourceFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: ArculusCardHint) -> ArculusCardFactorSource  {
    return try!  FfiConverterTypeArculusCardFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_arculus_card_factor_source_from_mnemonic_with_passphrase(
        FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
        FfiConverterTypeArculusCardHint.lower(hint),$0
    )
})
}
public func newArculusCardFactorSourceSample() -> ArculusCardFactorSource  {
    return try!  FfiConverterTypeArculusCardFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_arculus_card_factor_source_sample($0
    )
})
}
public func newArculusCardFactorSourceSampleOther() -> ArculusCardFactorSource  {
    return try!  FfiConverterTypeArculusCardFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_arculus_card_factor_source_sample_other($0
    )
})
}
public func newAssetExceptionSample() -> AssetException  {
    return try!  FfiConverterTypeAssetException.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_asset_exception_sample($0
    )
})
}
public func newAssetExceptionSampleOther() -> AssetException  {
    return try!  FfiConverterTypeAssetException.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_asset_exception_sample_other($0
    )
})
}
public func newAssetsExceptionListSample() -> [AssetException]  {
    return try!  FfiConverterSequenceTypeAssetException.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_assets_exception_list_sample($0
    )
})
}
public func newAssetsExceptionListSampleOther() -> [AssetException]  {
    return try!  FfiConverterSequenceTypeAssetException.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_assets_exception_list_sample_other($0
    )
})
}
public func newAuthIntentFromRequest(challengeNonce: DappToWalletInteractionAuthChallengeNonce, metadata: DappToWalletInteractionMetadata, entitiesToSign: [AddressOfAccountOrPersona])throws  -> AuthIntent  {
    return try  FfiConverterTypeAuthIntent.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_auth_intent_from_request(
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.lower(challengeNonce),
        FfiConverterTypeDappToWalletInteractionMetadata.lower(metadata),
        FfiConverterSequenceTypeAddressOfAccountOrPersona.lower(entitiesToSign),$0
    )
})
}
public func newAuthIntentHashSample() -> AuthIntentHash  {
    return try!  FfiConverterTypeAuthIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_auth_intent_hash_sample($0
    )
})
}
public func newAuthIntentHashSampleOther() -> AuthIntentHash  {
    return try!  FfiConverterTypeAuthIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_auth_intent_hash_sample_other($0
    )
})
}
public func newAuthIntentSample() -> AuthIntent  {
    return try!  FfiConverterTypeAuthIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_auth_intent_sample($0
    )
})
}
public func newAuthIntentSampleOther() -> AuthIntent  {
    return try!  FfiConverterTypeAuthIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_auth_intent_sample_other($0
    )
})
}
public func newAuthorizedDappDetailedSample() -> AuthorizedDappDetailed  {
    return try!  FfiConverterTypeAuthorizedDappDetailed.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_dapp_detailed_sample($0
    )
})
}
public func newAuthorizedDappDetailedSampleOther() -> AuthorizedDappDetailed  {
    return try!  FfiConverterTypeAuthorizedDappDetailed.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_dapp_detailed_sample_other($0
    )
})
}
public func newAuthorizedDappFromJsonBytes(jsonBytes: BagOfBytes)throws  -> AuthorizedDapp  {
    return try  FfiConverterTypeAuthorizedDapp.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_authorized_dapp_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newAuthorizedDappSampleMainnetDashboard() -> AuthorizedDapp  {
    return try!  FfiConverterTypeAuthorizedDapp.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_dapp_sample_mainnet_dashboard($0
    )
})
}
public func newAuthorizedDappSampleMainnetGumballclub() -> AuthorizedDapp  {
    return try!  FfiConverterTypeAuthorizedDapp.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_dapp_sample_mainnet_gumballclub($0
    )
})
}
public func newAuthorizedDappSampleStokenetDevconsole() -> AuthorizedDapp  {
    return try!  FfiConverterTypeAuthorizedDapp.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_dapp_sample_stokenet_devconsole($0
    )
})
}
public func newAuthorizedDappSampleStokenetSandbox() -> AuthorizedDapp  {
    return try!  FfiConverterTypeAuthorizedDapp.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_dapp_sample_stokenet_sandbox($0
    )
})
}
public func newAuthorizedDappsSample() -> [AuthorizedDapp]  {
    return try!  FfiConverterSequenceTypeAuthorizedDapp.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_dapps_sample($0
    )
})
}
public func newAuthorizedDappsSampleOther() -> [AuthorizedDapp]  {
    return try!  FfiConverterSequenceTypeAuthorizedDapp.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_dapps_sample_other($0
    )
})
}
public func newAuthorizedPersonaDetailedSample() -> AuthorizedPersonaDetailed  {
    return try!  FfiConverterTypeAuthorizedPersonaDetailed.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_persona_detailed_sample($0
    )
})
}
public func newAuthorizedPersonaDetailedSampleOther() -> AuthorizedPersonaDetailed  {
    return try!  FfiConverterTypeAuthorizedPersonaDetailed.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_persona_detailed_sample_other($0
    )
})
}
public func newAuthorizedPersonaSimpleSampleMainnet() -> AuthorizedPersonaSimple  {
    return try!  FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_persona_simple_sample_mainnet($0
    )
})
}
public func newAuthorizedPersonaSimpleSampleMainnetOther() -> AuthorizedPersonaSimple  {
    return try!  FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_persona_simple_sample_mainnet_other($0
    )
})
}
public func newAuthorizedPersonaSimpleSampleStokenet() -> AuthorizedPersonaSimple  {
    return try!  FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_persona_simple_sample_stokenet($0
    )
})
}
public func newAuthorizedPersonaSimpleSampleStokenetOther() -> AuthorizedPersonaSimple  {
    return try!  FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_authorized_persona_simple_sample_stokenet_other($0
    )
})
}
public func newBIP39SeedFromBytes(bytes: BagOfBytes)throws  -> Bip39Seed  {
    return try  FfiConverterTypeBIP39Seed.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_b_i_p39_seed_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newBIP39SeedSample() -> Bip39Seed  {
    return try!  FfiConverterTypeBIP39Seed.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_b_i_p39_seed_sample($0
    )
})
}
public func newBIP39SeedSampleOther() -> Bip39Seed  {
    return try!  FfiConverterTypeBIP39Seed.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_b_i_p39_seed_sample_other($0
    )
})
}
public func newBagOfBytesFrom(bytes: Data) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_from(
        FfiConverterData.lower(bytes),$0
    )
})
}
public func newBagOfBytesSampleAced() -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_aced($0
    )
})
}
public func newBagOfBytesSampleBabe() -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_babe($0
    )
})
}
public func newBagOfBytesSampleCafe() -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_cafe($0
    )
})
}
public func newBagOfBytesSampleDead() -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_dead($0
    )
})
}
public func newBagOfBytesSampleEcad() -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_ecad($0
    )
})
}
public func newBagOfBytesSampleFade() -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_fade($0
    )
})
}
public func newBip39LanguageSample() -> Bip39Language  {
    return try!  FfiConverterTypeBIP39Language.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bip39_language_sample($0
    )
})
}
public func newBip39LanguageSampleOther() -> Bip39Language  {
    return try!  FfiConverterTypeBIP39Language.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bip39_language_sample_other($0
    )
})
}
public func newBip39WordSample() -> Bip39Word  {
    return try!  FfiConverterTypeBIP39Word.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bip39_word_sample($0
    )
})
}
public func newBip39WordSampleOther() -> Bip39Word  {
    return try!  FfiConverterTypeBIP39Word.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bip39_word_sample_other($0
    )
})
}
public func newBip44LikePathFromIndex(index: HdPathComponent) -> Bip44LikePath  {
    return try!  FfiConverterTypeBIP44LikePath.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bip44_like_path_from_index(
        FfiConverterTypeHDPathComponent.lower(index),$0
    )
})
}
public func newBip44LikePathFromString(string: String)throws  -> Bip44LikePath  {
    return try  FfiConverterTypeBIP44LikePath.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_bip44_like_path_from_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newBip44LikePathSample() -> Bip44LikePath  {
    return try!  FfiConverterTypeBIP44LikePath.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bip44_like_path_sample($0
    )
})
}
public func newBip44LikePathSampleOther() -> Bip44LikePath  {
    return try!  FfiConverterTypeBIP44LikePath.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_bip44_like_path_sample_other($0
    )
})
}
public func newBlobFromBytes(bytes: BagOfBytes) -> Blob  {
    return try!  FfiConverterTypeBlob.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_blob_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newBlobsFromBlobList(blobs: [Blob]) -> Blobs  {
    return try!  FfiConverterTypeBlobs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_blobs_from_blob_list(
        FfiConverterSequenceTypeBlob.lower(blobs),$0
    )
})
}
public func newBlobsSample() -> Blobs  {
    return try!  FfiConverterTypeBlobs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_blobs_sample($0
    )
})
}
public func newBlobsSampleOther() -> Blobs  {
    return try!  FfiConverterTypeBlobs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_blobs_sample_other($0
    )
})
}
public func newCompiledNotarizedIntentSample() -> CompiledNotarizedIntent  {
    return try!  FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_compiled_notarized_intent_sample($0
    )
})
}
public func newCompiledNotarizedIntentSampleOther() -> CompiledNotarizedIntent  {
    return try!  FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_compiled_notarized_intent_sample_other($0
    )
})
}
public func newCompiledSubintentSample() -> CompiledSubintent  {
    return try!  FfiConverterTypeCompiledSubintent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_compiled_subintent_sample($0
    )
})
}
public func newCompiledSubintentSampleOther() -> CompiledSubintent  {
    return try!  FfiConverterTypeCompiledSubintent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_compiled_subintent_sample_other($0
    )
})
}
public func newCompiledTransactionIntentSample() -> CompiledTransactionIntent  {
    return try!  FfiConverterTypeCompiledTransactionIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_compiled_transaction_intent_sample($0
    )
})
}
public func newCompiledTransactionIntentSampleOther() -> CompiledTransactionIntent  {
    return try!  FfiConverterTypeCompiledTransactionIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_compiled_transaction_intent_sample_other($0
    )
})
}
public func newComponentAddress(bech32: String)throws  -> ComponentAddress  {
    return try  FfiConverterTypeComponentAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_component_address(
        FfiConverterString.lower(bech32),$0
    )
})
}
/**
 * Returns a random address in `network_id` as Network
 */
public func newComponentAddressRandom(networkId: NetworkId) -> ComponentAddress  {
    return try!  FfiConverterTypeComponentAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_component_address_random(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
/**
 * Sample to a mainnet ComponentAddress (global)
 */
public func newComponentAddressSampleMainnetGlobal() -> ComponentAddress  {
    return try!  FfiConverterTypeComponentAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_component_address_sample_mainnet_global($0
    )
})
}
/**
 * Sample to a mainnet ComponentAddress (internal)
 */
public func newComponentAddressSampleMainnetInternal() -> ComponentAddress  {
    return try!  FfiConverterTypeComponentAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_component_address_sample_mainnet_internal($0
    )
})
}
/**
 * Sample to a stokenet ComponentAddress (global)
 */
public func newComponentAddressSampleStokenetGlobal() -> ComponentAddress  {
    return try!  FfiConverterTypeComponentAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_component_address_sample_stokenet_global($0
    )
})
}
/**
 * Sample to a stokenet ComponentAddress (internal)
 */
public func newComponentAddressSampleStokenetInternal() -> ComponentAddress  {
    return try!  FfiConverterTypeComponentAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_component_address_sample_stokenet_internal($0
    )
})
}
public func newConfirmationRoleWithFactorInstancesSample() -> ConfirmationRoleWithFactorInstances  {
    return try!  FfiConverterTypeConfirmationRoleWithFactorInstances.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_confirmation_role_with_factor_instances_sample($0
    )
})
}
public func newConfirmationRoleWithFactorInstancesSampleOther() -> ConfirmationRoleWithFactorInstances  {
    return try!  FfiConverterTypeConfirmationRoleWithFactorInstances.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_confirmation_role_with_factor_instances_sample_other($0
    )
})
}
public func newConfirmationRoleWithFactorSourceIDsSample() -> ConfirmationRoleWithFactorSourceIDs  {
    return try!  FfiConverterTypeConfirmationRoleWithFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_confirmation_role_with_factor_source_i_ds_sample($0
    )
})
}
public func newConfirmationRoleWithFactorSourceIDsSampleOther() -> ConfirmationRoleWithFactorSourceIDs  {
    return try!  FfiConverterTypeConfirmationRoleWithFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_confirmation_role_with_factor_source_i_ds_sample_other($0
    )
})
}
public func newConfirmationRoleWithFactorSourcesSample() -> ConfirmationRoleWithFactorSources  {
    return try!  FfiConverterTypeConfirmationRoleWithFactorSources.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_confirmation_role_with_factor_sources_sample($0
    )
})
}
public func newConfirmationRoleWithFactorSourcesSampleOther() -> ConfirmationRoleWithFactorSources  {
    return try!  FfiConverterTypeConfirmationRoleWithFactorSources.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_confirmation_role_with_factor_sources_sample_other($0
    )
})
}
public func newDappToWalletInteractionMetadataFromJsonBytes(jsonBytes: BagOfBytes)throws  -> DappToWalletInteractionMetadata  {
    return try  FfiConverterTypeDappToWalletInteractionMetadata.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_metadata_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newDappToWalletInteractionMetadataSample() -> DappToWalletInteractionMetadata  {
    return try!  FfiConverterTypeDappToWalletInteractionMetadata.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_metadata_sample($0
    )
})
}
public func newDappToWalletInteractionMetadataSampleOther() -> DappToWalletInteractionMetadata  {
    return try!  FfiConverterTypeDappToWalletInteractionMetadata.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_metadata_sample_other($0
    )
})
}
public func newDappToWalletInteractionUnvalidatedFromJsonBytes(jsonBytes: BagOfBytes)throws  -> DappToWalletInteractionUnvalidated  {
    return try  FfiConverterTypeDappToWalletInteractionUnvalidated.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_unvalidated_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newDappToWalletInteractionUnvalidatedFromJsonString(jsonStr: String)throws  -> DappToWalletInteractionUnvalidated  {
    return try  FfiConverterTypeDappToWalletInteractionUnvalidated.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_unvalidated_from_json_string(
        FfiConverterString.lower(jsonStr),$0
    )
})
}
public func newDappToWalletInteractionUnvalidatedSample() -> DappToWalletInteractionUnvalidated  {
    return try!  FfiConverterTypeDappToWalletInteractionUnvalidated.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_unvalidated_sample($0
    )
})
}
public func newDappToWalletInteractionUnvalidatedSampleOther() -> DappToWalletInteractionUnvalidated  {
    return try!  FfiConverterTypeDappToWalletInteractionUnvalidated.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_unvalidated_sample_other($0
    )
})
}
/**
 * Creates the Decimal192 `10^exponent`
 */
public func newDecimalExponent(exponent: UInt8) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_decimal_exponent(
        FfiConverterUInt8.lower(exponent),$0
    )
})
}
/**
 * Creates a new `Decimal192` from a f32 float. Will
 * fail if the f32 cannot be losslessly represented
 * by the underlying Decimal from Scrypto.
 *
 * ```
 * extern crate sargon_uniffi;
 * use sargon_uniffi::prelude::*;
 *
 * assert!(new_decimal_from_f32(208050.17).to_string() == "208050.17");
 *
 * assert!(new_decimal_from_f32(f32::MIN_POSITIVE).to_string() == "0");
 * ```
 */
public func newDecimalFromF32(value: Float) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_decimal_from_f32(
        FfiConverterFloat.lower(value),$0
    )
})
}
/**
 * Creates a new `Decimal192` from a f64 float. Will
 * fail if the f64 cannot be losslessly represented
 * by the underlying Decimal from Scrypto.
 *
 * ```
 * extern crate sargon_uniffi;
 * use sargon_uniffi::prelude::*;
 *
 * assert!(new_decimal_from_f64(208050.17).is_ok());
 *
 * assert!(new_decimal_from_f64(f64::MIN_POSITIVE).is_ok());
 * ```
 */
public func newDecimalFromF64(value: Double)throws  -> Decimal192  {
    return try  FfiConverterTypeDecimal192.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_decimal_from_f64(
        FfiConverterDouble.lower(value),$0
    )
})
}
/**
 * Tries to creates a new `Decimal192` from a formatted String for
 * a specific locale.
 */
public func newDecimalFromFormattedString(formattedString: String, locale: LocaleConfig)throws  -> Decimal192  {
    return try  FfiConverterTypeDecimal192.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_decimal_from_formatted_string(
        FfiConverterString.lower(formattedString),
        FfiConverterTypeLocaleConfig.lower(locale),$0
    )
})
}
/**
 * Creates a new `Decimal192` from a i32 integer.
 */
public func newDecimalFromI32(value: Int32) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_decimal_from_i32(
        FfiConverterInt32.lower(value),$0
    )
})
}
/**
 * Creates a new `Decimal192` from a i64 integer.
 */
public func newDecimalFromI64(value: Int64) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_decimal_from_i64(
        FfiConverterInt64.lower(value),$0
    )
})
}
/**
 * Tries to creates a new `Decimal192` from a String, throws a `CommonError`
 * if the `string` was not a valid Decimal192.
 */
public func newDecimalFromString(string: String)throws  -> Decimal192  {
    return try  FfiConverterTypeDecimal192.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_decimal_from_string(
        FfiConverterString.lower(string),$0
    )
})
}
/**
 * Creates a new `Decimal192` from a u32 integer.
 */
public func newDecimalFromU32(value: UInt32) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_decimal_from_u32(
        FfiConverterUInt32.lower(value),$0
    )
})
}
/**
 * Creates a new `Decimal192` from a u64 integer.
 */
public func newDecimalFromU64(value: UInt64) -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_decimal_from_u64(
        FfiConverterUInt64.lower(value),$0
    )
})
}
public func newDependencyInformationSample() -> DependencyInformation  {
    return try!  FfiConverterTypeDependencyInformation.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_dependency_information_sample($0
    )
})
}
public func newDependencyInformationSampleOther() -> DependencyInformation  {
    return try!  FfiConverterTypeDependencyInformation.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_dependency_information_sample_other($0
    )
})
}
public func newDepositRuleFromJsonString(jsonString: String)throws  -> DepositRule  {
    return try  FfiConverterTypeDepositRule.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_deposit_rule_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newDepositRuleSample() -> DepositRule  {
    return try!  FfiConverterTypeDepositRule.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_deposit_rule_sample($0
    )
})
}
public func newDepositRuleSampleOther() -> DepositRule  {
    return try!  FfiConverterTypeDepositRule.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_deposit_rule_sample_other($0
    )
})
}
public func newDepositorsAllowListSample() -> [ResourceOrNonFungible]  {
    return try!  FfiConverterSequenceTypeResourceOrNonFungible.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_depositors_allow_list_sample($0
    )
})
}
public func newDepositorsAllowListSampleOther() -> [ResourceOrNonFungible]  {
    return try!  FfiConverterSequenceTypeResourceOrNonFungible.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_depositors_allow_list_sample_other($0
    )
})
}
public func newDerivationPathFromString(string: String)throws  -> DerivationPath  {
    return try  FfiConverterTypeDerivationPath.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_derivation_path_from_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newDerivationPathSample() -> DerivationPath  {
    return try!  FfiConverterTypeDerivationPath.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_derivation_path_sample($0
    )
})
}
public func newDerivationPathSampleOther() -> DerivationPath  {
    return try!  FfiConverterTypeDerivationPath.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_derivation_path_sample_other($0
    )
})
}
public func newDetailedAuthorizedPersonasSample() -> [AuthorizedPersonaDetailed]  {
    return try!  FfiConverterSequenceTypeAuthorizedPersonaDetailed.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_detailed_authorized_personas_sample($0
    )
})
}
public func newDetailedAuthorizedPersonasSampleOther() -> [AuthorizedPersonaDetailed]  {
    return try!  FfiConverterSequenceTypeAuthorizedPersonaDetailed.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_detailed_authorized_personas_sample_other($0
    )
})
}
public func newDeviceFactorSourceBabylon(mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> DeviceFactorSource  {
    return try!  FfiConverterTypeDeviceFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_device_factor_source_babylon(
        FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
        FfiConverterTypeHostInfo.lower(hostInfo),$0
    )
})
}
public func newDeviceFactorSourceOlympia(mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> DeviceFactorSource  {
    return try!  FfiConverterTypeDeviceFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_device_factor_source_olympia(
        FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
        FfiConverterTypeHostInfo.lower(hostInfo),$0
    )
})
}
public func newDeviceFactorSourceSample() -> DeviceFactorSource  {
    return try!  FfiConverterTypeDeviceFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_device_factor_source_sample($0
    )
})
}
public func newDeviceFactorSourceSampleOther() -> DeviceFactorSource  {
    return try!  FfiConverterTypeDeviceFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_device_factor_source_sample_other($0
    )
})
}
public func newDeviceInfoDescriptionSample() -> DeviceInfoDescription  {
    return try!  FfiConverterTypeDeviceInfoDescription.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_device_info_description_sample($0
    )
})
}
public func newDeviceInfoDescriptionSampleOther() -> DeviceInfoDescription  {
    return try!  FfiConverterTypeDeviceInfoDescription.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_device_info_description_sample_other($0
    )
})
}
public func newDeviceInfoFromHostInfo(hostId: HostId, hostInfo: HostInfo) -> DeviceInfo  {
    return try!  FfiConverterTypeDeviceInfo.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_device_info_from_host_info(
        FfiConverterTypeHostId.lower(hostId),
        FfiConverterTypeHostInfo.lower(hostInfo),$0
    )
})
}
public func newDeviceInfoFromJsonBytes(jsonBytes: BagOfBytes)throws  -> DeviceInfo  {
    return try  FfiConverterTypeDeviceInfo.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_device_info_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newDeviceInfoSample() -> DeviceInfo  {
    return try!  FfiConverterTypeDeviceInfo.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_device_info_sample($0
    )
})
}
public func newDeviceInfoSampleOther() -> DeviceInfo  {
    return try!  FfiConverterTypeDeviceInfo.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_device_info_sample_other($0
    )
})
}
public func newDisplayName(name: String)throws  -> DisplayName  {
    return try  FfiConverterTypeDisplayName.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_display_name(
        FfiConverterString.lower(name),$0
    )
})
}
public func newDisplayNameFromJsonString(jsonString: String)throws  -> DisplayName  {
    return try  FfiConverterTypeDisplayName.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_display_name_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newDisplayNameSample() -> DisplayName  {
    return try!  FfiConverterTypeDisplayName.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_display_name_sample($0
    )
})
}
public func newDisplayNameSampleOther() -> DisplayName  {
    return try!  FfiConverterTypeDisplayName.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_display_name_sample_other($0
    )
})
}
public func newEd25519PublicKeyFromBytes(bytes: BagOfBytes)throws  -> Ed25519PublicKey  {
    return try  FfiConverterTypeEd25519PublicKey.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newEd25519PublicKeyFromHex(hex: String)throws  -> Ed25519PublicKey  {
    return try  FfiConverterTypeEd25519PublicKey.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_from_hex(
        FfiConverterString.lower(hex),$0
    )
})
}
public func newEd25519PublicKeyFromJsonString(jsonString: String)throws  -> Ed25519PublicKey  {
    return try  FfiConverterTypeEd25519PublicKey.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newEd25519PublicKeySample() -> Ed25519PublicKey  {
    return try!  FfiConverterTypeEd25519PublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_sample($0
    )
})
}
public func newEd25519PublicKeySampleOther() -> Ed25519PublicKey  {
    return try!  FfiConverterTypeEd25519PublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_sample_other($0
    )
})
}
public func newEd25519SignatureFromBytes(bytes: BagOfBytes)throws  -> Ed25519Signature  {
    return try  FfiConverterTypeEd25519Signature.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_ed25519_signature_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newEd25519SignatureFromExactly64Bytes(bytes: Exactly64Bytes) -> Ed25519Signature  {
    return try!  FfiConverterTypeEd25519Signature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_ed25519_signature_from_exactly_64_bytes(
        FfiConverterTypeExactly64Bytes.lower(bytes),$0
    )
})
}
public func newEd25519SignatureFromJsonString(jsonString: String)throws  -> Ed25519Signature  {
    return try  FfiConverterTypeEd25519Signature.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_ed25519_signature_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newEd25519SignatureSample() -> Ed25519Signature  {
    return try!  FfiConverterTypeEd25519Signature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_ed25519_signature_sample($0
    )
})
}
public func newEd25519SignatureSampleOther() -> Ed25519Signature  {
    return try!  FfiConverterTypeEd25519Signature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_ed25519_signature_sample_other($0
    )
})
}
public func newEmailAddressSample() -> EmailAddress  {
    return try!  FfiConverterTypeEmailAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_email_address_sample($0
    )
})
}
public func newEmailAddressSampleOther() -> EmailAddress  {
    return try!  FfiConverterTypeEmailAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_email_address_sample_other($0
    )
})
}
public func newEntityFlagSample() -> EntityFlag  {
    return try!  FfiConverterTypeEntityFlag.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entity_flag_sample($0
    )
})
}
public func newEntityFlagSampleOther() -> EntityFlag  {
    return try!  FfiConverterTypeEntityFlag.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entity_flag_sample_other($0
    )
})
}
public func newEntityFlagsSample() -> [EntityFlag]  {
    return try!  FfiConverterSequenceTypeEntityFlag.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entity_flags_sample($0
    )
})
}
public func newEntityFlagsSampleOther() -> [EntityFlag]  {
    return try!  FfiConverterSequenceTypeEntityFlag.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entity_flags_sample_other($0
    )
})
}
public func newEntitySecurityStateSample() -> EntitySecurityState  {
    return try!  FfiConverterTypeEntitySecurityState.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entity_security_state_sample($0
    )
})
}
public func newEntitySecurityStateSampleOther() -> EntitySecurityState  {
    return try!  FfiConverterTypeEntitySecurityState.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entity_security_state_sample_other($0
    )
})
}
public func newEntropy16BytesFromBytes(bytes: BagOfBytes)throws  -> Entropy16Bytes  {
    return try  FfiConverterTypeEntropy16Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_entropy16_bytes_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newEntropy16BytesSample() -> Entropy16Bytes  {
    return try!  FfiConverterTypeEntropy16Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entropy16_bytes_sample($0
    )
})
}
public func newEntropy16BytesSampleOther() -> Entropy16Bytes  {
    return try!  FfiConverterTypeEntropy16Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entropy16_bytes_sample_other($0
    )
})
}
public func newEntropy20BytesFromBytes(bytes: BagOfBytes)throws  -> Entropy20Bytes  {
    return try  FfiConverterTypeEntropy20Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_entropy20_bytes_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newEntropy20BytesSample() -> Entropy20Bytes  {
    return try!  FfiConverterTypeEntropy20Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entropy20_bytes_sample($0
    )
})
}
public func newEntropy20BytesSampleOther() -> Entropy20Bytes  {
    return try!  FfiConverterTypeEntropy20Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entropy20_bytes_sample_other($0
    )
})
}
public func newEntropy24BytesFromBytes(bytes: BagOfBytes)throws  -> Entropy24Bytes  {
    return try  FfiConverterTypeEntropy24Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_entropy24_bytes_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newEntropy24BytesSample() -> Entropy24Bytes  {
    return try!  FfiConverterTypeEntropy24Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entropy24_bytes_sample($0
    )
})
}
public func newEntropy24BytesSampleOther() -> Entropy24Bytes  {
    return try!  FfiConverterTypeEntropy24Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entropy24_bytes_sample_other($0
    )
})
}
public func newEntropy28BytesFromBytes(bytes: BagOfBytes)throws  -> Entropy28Bytes  {
    return try  FfiConverterTypeEntropy28Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_entropy28_bytes_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newEntropy28BytesSample() -> Entropy28Bytes  {
    return try!  FfiConverterTypeEntropy28Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entropy28_bytes_sample($0
    )
})
}
public func newEntropy28BytesSampleOther() -> Entropy28Bytes  {
    return try!  FfiConverterTypeEntropy28Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entropy28_bytes_sample_other($0
    )
})
}
public func newEntropy32BytesFromBytes(bytes: BagOfBytes)throws  -> Entropy32Bytes  {
    return try  FfiConverterTypeEntropy32Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_entropy32_bytes_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newEntropy32BytesSample() -> Entropy32Bytes  {
    return try!  FfiConverterTypeEntropy32Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entropy32_bytes_sample($0
    )
})
}
public func newEntropy32BytesSampleOther() -> Entropy32Bytes  {
    return try!  FfiConverterTypeEntropy32Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_entropy32_bytes_sample_other($0
    )
})
}
public func newExactly12BytesFromJsonString(jsonString: String)throws  -> Exactly12Bytes  {
    return try  FfiConverterTypeExactly12Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly12_bytes_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newExactly29BytesFromJsonString(jsonString: String)throws  -> Exactly29Bytes  {
    return try  FfiConverterTypeExactly29Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly29_bytes_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newExactly32BytesFromJsonString(jsonString: String)throws  -> Exactly32Bytes  {
    return try  FfiConverterTypeExactly32Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly32_bytes_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newExactly33BytesFromJsonString(jsonString: String)throws  -> Exactly33Bytes  {
    return try  FfiConverterTypeExactly33Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly33_bytes_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newExactly60BytesFromJsonString(jsonString: String)throws  -> Exactly60Bytes  {
    return try  FfiConverterTypeExactly60Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly60_bytes_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newExactly64BytesFromJsonString(jsonString: String)throws  -> Exactly64Bytes  {
    return try  FfiConverterTypeExactly64Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly64_bytes_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newExactly65BytesFromJsonString(jsonString: String)throws  -> Exactly65Bytes  {
    return try  FfiConverterTypeExactly65Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly65_bytes_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newExactly12Bytes(bytes: BagOfBytes)throws  -> Exactly12Bytes  {
    return try  FfiConverterTypeExactly12Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly_12_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newExactly12BytesSample() -> Exactly12Bytes  {
    return try!  FfiConverterTypeExactly12Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_12_bytes_sample($0
    )
})
}
public func newExactly12BytesSampleOther() -> Exactly12Bytes  {
    return try!  FfiConverterTypeExactly12Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_12_bytes_sample_other($0
    )
})
}
public func newExactly29Bytes(bytes: BagOfBytes)throws  -> Exactly29Bytes  {
    return try  FfiConverterTypeExactly29Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly_29_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newExactly29BytesSample() -> Exactly29Bytes  {
    return try!  FfiConverterTypeExactly29Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_29_bytes_sample($0
    )
})
}
public func newExactly29BytesSampleOther() -> Exactly29Bytes  {
    return try!  FfiConverterTypeExactly29Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_29_bytes_sample_other($0
    )
})
}
public func newExactly32Bytes(bytes: BagOfBytes)throws  -> Exactly32Bytes  {
    return try  FfiConverterTypeExactly32Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly_32_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newExactly32BytesSample() -> Exactly32Bytes  {
    return try!  FfiConverterTypeExactly32Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_32_bytes_sample($0
    )
})
}
public func newExactly32BytesSampleOther() -> Exactly32Bytes  {
    return try!  FfiConverterTypeExactly32Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_32_bytes_sample_other($0
    )
})
}
public func newExactly33Bytes(bytes: BagOfBytes)throws  -> Exactly33Bytes  {
    return try  FfiConverterTypeExactly33Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly_33_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newExactly33BytesSample() -> Exactly33Bytes  {
    return try!  FfiConverterTypeExactly33Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_33_bytes_sample($0
    )
})
}
public func newExactly33BytesSampleOther() -> Exactly33Bytes  {
    return try!  FfiConverterTypeExactly33Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_33_bytes_sample_other($0
    )
})
}
public func newExactly60Bytes(bytes: BagOfBytes)throws  -> Exactly60Bytes  {
    return try  FfiConverterTypeExactly60Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly_60_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newExactly60BytesSample() -> Exactly60Bytes  {
    return try!  FfiConverterTypeExactly60Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_60_bytes_sample($0
    )
})
}
public func newExactly60BytesSampleOther() -> Exactly60Bytes  {
    return try!  FfiConverterTypeExactly60Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_60_bytes_sample_other($0
    )
})
}
public func newExactly64Bytes(bytes: BagOfBytes)throws  -> Exactly64Bytes  {
    return try  FfiConverterTypeExactly64Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly_64_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newExactly64BytesSample() -> Exactly64Bytes  {
    return try!  FfiConverterTypeExactly64Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_64_bytes_sample($0
    )
})
}
public func newExactly64BytesSampleOther() -> Exactly64Bytes  {
    return try!  FfiConverterTypeExactly64Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_64_bytes_sample_other($0
    )
})
}
public func newExactly65Bytes(bytes: BagOfBytes)throws  -> Exactly65Bytes  {
    return try  FfiConverterTypeExactly65Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_exactly_65_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newExactly65BytesSample() -> Exactly65Bytes  {
    return try!  FfiConverterTypeExactly65Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_65_bytes_sample($0
    )
})
}
public func newExactly65BytesSampleOther() -> Exactly65Bytes  {
    return try!  FfiConverterTypeExactly65Bytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_exactly_65_bytes_sample_other($0
    )
})
}
public func newFactorSourceCommonBabylon() -> FactorSourceCommon  {
    return try!  FfiConverterTypeFactorSourceCommon.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_common_babylon($0
    )
})
}
public func newFactorSourceCommonBdfs() -> FactorSourceCommon  {
    return try!  FfiConverterTypeFactorSourceCommon.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_common_bdfs($0
    )
})
}
public func newFactorSourceCommonOlympia() -> FactorSourceCommon  {
    return try!  FfiConverterTypeFactorSourceCommon.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_common_olympia($0
    )
})
}
public func newFactorSourceCommonSample() -> FactorSourceCommon  {
    return try!  FfiConverterTypeFactorSourceCommon.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_common_sample($0
    )
})
}
public func newFactorSourceCommonSampleOther() -> FactorSourceCommon  {
    return try!  FfiConverterTypeFactorSourceCommon.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_common_sample_other($0
    )
})
}
public func newFactorSourceCryptoParametersPresetBabylonOlympiaCompatible() -> FactorSourceCryptoParameters  {
    return try!  FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_preset_babylon_olympia_compatible($0
    )
})
}
public func newFactorSourceCryptoParametersPresetBabylonOnly() -> FactorSourceCryptoParameters  {
    return try!  FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_preset_babylon_only($0
    )
})
}
public func newFactorSourceCryptoParametersPresetOlympiaOnly() -> FactorSourceCryptoParameters  {
    return try!  FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_preset_olympia_only($0
    )
})
}
public func newFactorSourceCryptoParametersSample() -> FactorSourceCryptoParameters  {
    return try!  FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_sample($0
    )
})
}
public func newFactorSourceCryptoParametersSampleOther() -> FactorSourceCryptoParameters  {
    return try!  FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_sample_other($0
    )
})
}
public func newFactorSourceIDFromAddressFromJsonBytes(jsonBytes: BagOfBytes)throws  -> FactorSourceIdFromAddress  {
    return try  FfiConverterTypeFactorSourceIDFromAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_factor_source_i_d_from_address_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newFactorSourceIDFromHashFromJsonBytes(jsonBytes: BagOfBytes)throws  -> FactorSourceIdFromHash  {
    return try  FfiConverterTypeFactorSourceIDFromHash.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_factor_source_i_d_from_hash_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newFactorSourceIDFromJsonBytes(jsonBytes: BagOfBytes)throws  -> FactorSourceId  {
    return try  FfiConverterTypeFactorSourceID.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_factor_source_i_d_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newFactorSourceIdFromAddressSample() -> FactorSourceIdFromAddress  {
    return try!  FfiConverterTypeFactorSourceIDFromAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_address_sample($0
    )
})
}
public func newFactorSourceIdFromAddressSampleOther() -> FactorSourceIdFromAddress  {
    return try!  FfiConverterTypeFactorSourceIDFromAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_address_sample_other($0
    )
})
}
public func newFactorSourceIdFromHashFromMnemonicWithPassphrase(factorSourceKind: FactorSourceKind, mnemonicWithPassphrase: MnemonicWithPassphrase) -> FactorSourceIdFromHash  {
    return try!  FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_hash_from_mnemonic_with_passphrase(
        FfiConverterTypeFactorSourceKind.lower(factorSourceKind),
        FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),$0
    )
})
}
public func newFactorSourceIdFromHashSample() -> FactorSourceIdFromHash  {
    return try!  FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_hash_sample($0
    )
})
}
public func newFactorSourceIdFromHashSampleOther() -> FactorSourceIdFromHash  {
    return try!  FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_hash_sample_other($0
    )
})
}
public func newFactorSourceIdSample() -> FactorSourceId  {
    return try!  FfiConverterTypeFactorSourceID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_id_sample($0
    )
})
}
public func newFactorSourceIdSampleOther() -> FactorSourceId  {
    return try!  FfiConverterTypeFactorSourceID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_id_sample_other($0
    )
})
}
public func newFactorSourceKindFromString(string: String)throws  -> FactorSourceKind  {
    return try  FfiConverterTypeFactorSourceKind.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_factor_source_kind_from_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newFactorSourceKindSample() -> FactorSourceKind  {
    return try!  FfiConverterTypeFactorSourceKind.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_kind_sample($0
    )
})
}
public func newFactorSourceKindSampleOther() -> FactorSourceKind  {
    return try!  FfiConverterTypeFactorSourceKind.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_kind_sample_other($0
    )
})
}
public func newFactorSourceSample() -> FactorSource  {
    return try!  FfiConverterTypeFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_sample($0
    )
})
}
public func newFactorSourceSampleOther() -> FactorSource  {
    return try!  FfiConverterTypeFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_source_sample_other($0
    )
})
}
public func newFactorSourcesSample() -> [FactorSource]  {
    return try!  FfiConverterSequenceTypeFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_sources_sample($0
    )
})
}
public func newFactorSourcesSampleOther() -> [FactorSource]  {
    return try!  FfiConverterSequenceTypeFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_factor_sources_sample_other($0
    )
})
}
public func newFailureFactorOutcomeOfAuthIntentHash(factorSourceId: FactorSourceIdFromHash) -> FactorOutcomeOfAuthIntentHash  {
    return try!  FfiConverterTypeFactorOutcomeOfAuthIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_failure_factor_outcome_of_auth_intent_hash(
        FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceId),$0
    )
})
}
public func newFailureFactorOutcomeOfSubintentHash(factorSourceId: FactorSourceIdFromHash) -> FactorOutcomeOfSubintentHash  {
    return try!  FfiConverterTypeFactorOutcomeOfSubintentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_failure_factor_outcome_of_subintent_hash(
        FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceId),$0
    )
})
}
public func newFailureFactorOutcomeOfTransactionIntentHash(factorSourceId: FactorSourceIdFromHash) -> FactorOutcomeOfTransactionIntentHash  {
    return try!  FfiConverterTypeFactorOutcomeOfTransactionIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_failure_factor_outcome_of_transaction_intent_hash(
        FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceId),$0
    )
})
}
public func newFiatCurrencyFromJsonString(jsonString: String)throws  -> FiatCurrency  {
    return try  FfiConverterTypeFiatCurrency.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_fiat_currency_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newFiatCurrencySample() -> FiatCurrency  {
    return try!  FfiConverterTypeFiatCurrency.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_fiat_currency_sample($0
    )
})
}
public func newFiatCurrencySampleOther() -> FiatCurrency  {
    return try!  FfiConverterTypeFiatCurrency.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_fiat_currency_sample_other($0
    )
})
}
public func newFungibleResourceIndicatorSample() -> FungibleResourceIndicator  {
    return try!  FfiConverterTypeFungibleResourceIndicator.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_fungible_resource_indicator_sample($0
    )
})
}
public func newFungibleResourceIndicatorSampleOther() -> FungibleResourceIndicator  {
    return try!  FfiConverterTypeFungibleResourceIndicator.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_fungible_resource_indicator_sample_other($0
    )
})
}
public func newGatewayForNetworkId(networkId: NetworkId) -> Gateway  {
    return try!  FfiConverterTypeGateway.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_gateway_for_network_id(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func newGatewaySample() -> Gateway  {
    return try!  FfiConverterTypeGateway.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_gateway_sample($0
    )
})
}
public func newGatewaySampleOther() -> Gateway  {
    return try!  FfiConverterTypeGateway.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_gateway_sample_other($0
    )
})
}
public func newGatewayWithUrlOnNetwork(url: String, networkId: NetworkId)throws  -> Gateway  {
    return try  FfiConverterTypeGateway.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_gateway_with_url_on_network(
        FfiConverterString.lower(url),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func newGatewaysSample() -> [Gateway]  {
    return try!  FfiConverterSequenceTypeGateway.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_gateways_sample($0
    )
})
}
public func newGatewaysSampleOther() -> [Gateway]  {
    return try!  FfiConverterSequenceTypeGateway.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_gateways_sample_other($0
    )
})
}
public func newHardenedSample() -> Hardened  {
    return try!  FfiConverterTypeHardened.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hardened_sample($0
    )
})
}
public func newHardenedSampleOther() -> Hardened  {
    return try!  FfiConverterTypeHardened.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hardened_sample_other($0
    )
})
}
public func newHashFromBytes(bytes: Exactly32Bytes) -> Hash  {
    return try!  FfiConverterTypeHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hash_from_bytes(
        FfiConverterTypeExactly32Bytes.lower(bytes),$0
    )
})
}
public func newHashFromString(string: String)throws  -> Hash  {
    return try  FfiConverterTypeHash.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_hash_from_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newHashSample() -> Hash  {
    return try!  FfiConverterTypeHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hash_sample($0
    )
})
}
public func newHashSampleOther() -> Hash  {
    return try!  FfiConverterTypeHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hash_sample_other($0
    )
})
}
public func newHdPathComponentFromGlobalKeySpace(value: UInt32) -> HdPathComponent  {
    return try!  FfiConverterTypeHDPathComponent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hd_path_component_from_global_key_space(
        FfiConverterUInt32.lower(value),$0
    )
})
}
public func newHdPathComponentFromLocalKeySpace(value: UInt32, keySpace: KeySpace)throws  -> HdPathComponent  {
    return try  FfiConverterTypeHDPathComponent.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_hd_path_component_from_local_key_space(
        FfiConverterUInt32.lower(value),
        FfiConverterTypeKeySpace.lower(keySpace),$0
    )
})
}
public func newHdPathComponentSample() -> HdPathComponent  {
    return try!  FfiConverterTypeHDPathComponent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hd_path_component_sample($0
    )
})
}
public func newHdPathComponentSampleOther() -> HdPathComponent  {
    return try!  FfiConverterTypeHDPathComponent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hd_path_component_sample_other($0
    )
})
}
public func newHeaderFromJsonBytes(jsonBytes: BagOfBytes)throws  -> Header  {
    return try  FfiConverterTypeHeader.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_header_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newHeaderSample() -> Header  {
    return try!  FfiConverterTypeHeader.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_header_sample($0
    )
})
}
public func newHeaderSampleOther() -> Header  {
    return try!  FfiConverterTypeHeader.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_header_sample_other($0
    )
})
}
/**
 * Instantiates a new `Header` with creating and last used on `DeviceInfo` with
 * "Unknown device" as description, and empty content hint
 */
public func newHeaderWithCreatingDevice(creatingDevice: DeviceInfo) -> Header  {
    return try!  FfiConverterTypeHeader.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_header_with_creating_device(
        FfiConverterTypeDeviceInfo.lower(creatingDevice),$0
    )
})
}
public func newHiddenResourcesSample() -> [ResourceIdentifier]  {
    return try!  FfiConverterSequenceTypeResourceIdentifier.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hidden_resources_sample($0
    )
})
}
public func newHiddenResourcesSampleOther() -> [ResourceIdentifier]  {
    return try!  FfiConverterSequenceTypeResourceIdentifier.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hidden_resources_sample_other($0
    )
})
}
public func newHierarchicalDeterministicFactorInstanceSample() -> HierarchicalDeterministicFactorInstance  {
    return try!  FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hierarchical_deterministic_factor_instance_sample($0
    )
})
}
public func newHierarchicalDeterministicFactorInstanceSampleOther() -> HierarchicalDeterministicFactorInstance  {
    return try!  FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hierarchical_deterministic_factor_instance_sample_other($0
    )
})
}
public func newHierarchicalDeterministicPublicKeySample() -> HierarchicalDeterministicPublicKey  {
    return try!  FfiConverterTypeHierarchicalDeterministicPublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hierarchical_deterministic_public_key_sample($0
    )
})
}
public func newHierarchicalDeterministicPublicKeySampleOther() -> HierarchicalDeterministicPublicKey  {
    return try!  FfiConverterTypeHierarchicalDeterministicPublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_hierarchical_deterministic_public_key_sample_other($0
    )
})
}
public func newHostIdFromJsonBytes(jsonBytes: BagOfBytes)throws  -> HostId  {
    return try  FfiConverterTypeHostId.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_host_id_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newHostIdSample() -> HostId  {
    return try!  FfiConverterTypeHostId.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_host_id_sample($0
    )
})
}
public func newHostIdSampleOther() -> HostId  {
    return try!  FfiConverterTypeHostId.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_host_id_sample_other($0
    )
})
}
public func newHostInfoSample() -> HostInfo  {
    return try!  FfiConverterTypeHostInfo.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_host_info_sample($0
    )
})
}
public func newHostInfoSampleOther() -> HostInfo  {
    return try!  FfiConverterTypeHostInfo.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_host_info_sample_other($0
    )
})
}
public func newHostOsAndroid(vendor: String, version: String) -> HostOs  {
    return try!  FfiConverterTypeHostOS.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_host_os_android(
        FfiConverterString.lower(vendor),
        FfiConverterString.lower(version),$0
    )
})
}
public func newHostOsIos(version: String) -> HostOs  {
    return try!  FfiConverterTypeHostOS.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_host_os_ios(
        FfiConverterString.lower(version),$0
    )
})
}
public func newHostOsOther(name: String, vendor: String, version: String) -> HostOs  {
    return try!  FfiConverterTypeHostOS.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_host_os_other(
        FfiConverterString.lower(name),
        FfiConverterString.lower(vendor),
        FfiConverterString.lower(version),$0
    )
})
}
public func newHostOsSample() -> HostOs  {
    return try!  FfiConverterTypeHostOS.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_host_os_sample($0
    )
})
}
public func newHostOsSampleOther() -> HostOs  {
    return try!  FfiConverterTypeHostOS.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_host_os_sample_other($0
    )
})
}
public func newIdentityAddress(bech32: String)throws  -> IdentityAddress  {
    return try  FfiConverterTypeIdentityAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_identity_address(
        FfiConverterString.lower(bech32),$0
    )
})
}
public func newIdentityAddressFrom(publicKey: PublicKey, networkId: NetworkId) -> IdentityAddress  {
    return try!  FfiConverterTypeIdentityAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_identity_address_from(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
/**
 * Returns a random address in `network_id` as Network
 */
public func newIdentityAddressRandom(networkId: NetworkId) -> IdentityAddress  {
    return try!  FfiConverterTypeIdentityAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_identity_address_random(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func newIdentityAddressSampleMainnet() -> IdentityAddress  {
    return try!  FfiConverterTypeIdentityAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_identity_address_sample_mainnet($0
    )
})
}
public func newIdentityAddressSampleMainnetOther() -> IdentityAddress  {
    return try!  FfiConverterTypeIdentityAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_identity_address_sample_mainnet_other($0
    )
})
}
public func newIdentityAddressSampleStokenet() -> IdentityAddress  {
    return try!  FfiConverterTypeIdentityAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_identity_address_sample_stokenet($0
    )
})
}
public func newIdentityAddressSampleStokenetOther() -> IdentityAddress  {
    return try!  FfiConverterTypeIdentityAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_identity_address_sample_stokenet_other($0
    )
})
}
public func newIdentityPath(networkId: NetworkId, keyKind: Cap26KeyKind, index: Hardened) -> IdentityPath  {
    return try!  FfiConverterTypeIdentityPath.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_identity_path(
        FfiConverterTypeNetworkID.lower(networkId),
        FfiConverterTypeCAP26KeyKind.lower(keyKind),
        FfiConverterTypeHardened.lower(index),$0
    )
})
}
public func newIdentityPathSample() -> IdentityPath  {
    return try!  FfiConverterTypeIdentityPath.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_identity_path_sample($0
    )
})
}
public func newIdentityPathSampleOther() -> IdentityPath  {
    return try!  FfiConverterTypeIdentityPath.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_identity_path_sample_other($0
    )
})
}
public func newIntentDiscriminatorFromU64(value: UInt64) -> IntentDiscriminator  {
    return try!  FfiConverterTypeIntentDiscriminator.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_intent_discriminator_from_u64(
        FfiConverterUInt64.lower(value),$0
    )
})
}
public func newIntentDiscriminatorRandom() -> IntentDiscriminator  {
    return try!  FfiConverterTypeIntentDiscriminator.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_intent_discriminator_random($0
    )
})
}
public func newIntentDiscriminatorSample() -> IntentDiscriminator  {
    return try!  FfiConverterTypeIntentDiscriminator.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_intent_discriminator_sample($0
    )
})
}
public func newIntentDiscriminatorSampleOther() -> IntentDiscriminator  {
    return try!  FfiConverterTypeIntentDiscriminator.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_intent_discriminator_sample_other($0
    )
})
}
public func newIntentHeaderV2Sample() -> IntentHeaderV2  {
    return try!  FfiConverterTypeIntentHeaderV2.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_intent_header_v2_sample($0
    )
})
}
public func newIntentHeaderV2SampleOther() -> IntentHeaderV2  {
    return try!  FfiConverterTypeIntentHeaderV2.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_intent_header_v2_sample_other($0
    )
})
}
public func newIntentSignatureFromSignatureWithPublicKey(signatureWithPublicKey: SignatureWithPublicKey) -> IntentSignature  {
    return try!  FfiConverterTypeIntentSignature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_intent_signature_from_signature_with_public_key(
        FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey),$0
    )
})
}
public func newIntentSignatureSample() -> IntentSignature  {
    return try!  FfiConverterTypeIntentSignature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_intent_signature_sample($0
    )
})
}
public func newIntentSignatureSampleOther() -> IntentSignature  {
    return try!  FfiConverterTypeIntentSignature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_intent_signature_sample_other($0
    )
})
}
/**
 * Creates a Secp256k1PublicKey from either compressed form (33 bytes) or
 * from uncompressed form (65 bytes).
 */
public func newKeyAgreementPublicKeyFromBytes(bytes: BagOfBytes)throws  -> KeyAgreementPublicKey  {
    return try  FfiConverterTypeKeyAgreementPublicKey.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_key_agreement_public_key_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newKeyAgreementPublicKeyFromHex(hex: String)throws  -> KeyAgreementPublicKey  {
    return try  FfiConverterTypeKeyAgreementPublicKey.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_key_agreement_public_key_from_hex(
        FfiConverterString.lower(hex),$0
    )
})
}
public func newKeyAgreementPublicKeySample() -> KeyAgreementPublicKey  {
    return try!  FfiConverterTypeKeyAgreementPublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_key_agreement_public_key_sample($0
    )
})
}
public func newKeyAgreementPublicKeySampleOther() -> KeyAgreementPublicKey  {
    return try!  FfiConverterTypeKeyAgreementPublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_key_agreement_public_key_sample_other($0
    )
})
}
public func newKeySpaceSample() -> KeySpace  {
    return try!  FfiConverterTypeKeySpace.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_key_space_sample($0
    )
})
}
public func newKeySpaceSampleOther() -> KeySpace  {
    return try!  FfiConverterTypeKeySpace.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_key_space_sample_other($0
    )
})
}
public func newLedgerHardwareWalletFactorSourceSample() -> LedgerHardwareWalletFactorSource  {
    return try!  FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_ledger_hardware_wallet_factor_source_sample($0
    )
})
}
public func newLedgerHardwareWalletFactorSourceSampleOther() -> LedgerHardwareWalletFactorSource  {
    return try!  FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_ledger_hardware_wallet_factor_source_sample_other($0
    )
})
}
public func newLedgerHardwareWalletFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: LedgerHardwareWalletHint, common: FactorSourceCommon) -> LedgerHardwareWalletFactorSource  {
    return try!  FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_ledger_hardware_wallet_from_mnemonic_with_passphrase(
        FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
        FfiConverterTypeLedgerHardwareWalletHint.lower(hint),
        FfiConverterTypeFactorSourceCommon.lower(common),$0
    )
})
}
public func newLedgerHwWalletModelFromString(string: String)throws  -> LedgerHardwareWalletModel  {
    return try  FfiConverterTypeLedgerHardwareWalletModel.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_ledger_hw_wallet_model_from_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newLedgerHwWalletModelSample() -> LedgerHardwareWalletModel  {
    return try!  FfiConverterTypeLedgerHardwareWalletModel.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_ledger_hw_wallet_model_sample($0
    )
})
}
public func newLedgerHwWalletModelSampleOther() -> LedgerHardwareWalletModel  {
    return try!  FfiConverterTypeLedgerHardwareWalletModel.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_ledger_hw_wallet_model_sample_other($0
    )
})
}
public func newLegacyOlympiaAccountAddressFromPublicKey(publicKey: Secp256k1PublicKey) -> LegacyOlympiaAccountAddress  {
    return try!  FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_legacy_olympia_account_address_from_public_key(
        FfiConverterTypeSecp256k1PublicKey.lower(publicKey),$0
    )
})
}
public func newLegacyOlympiaAccountAddressFromString(string: String)throws  -> LegacyOlympiaAccountAddress  {
    return try  FfiConverterTypeLegacyOlympiaAccountAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_legacy_olympia_account_address_from_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newLegacyOlympiaAccountAddressSample() -> LegacyOlympiaAccountAddress  {
    return try!  FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_legacy_olympia_account_address_sample($0
    )
})
}
public func newLegacyOlympiaAccountAddressSampleOther() -> LegacyOlympiaAccountAddress  {
    return try!  FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_legacy_olympia_account_address_sample_other($0
    )
})
}
public func newLinkConnectionQRDataFromJsonBytes(jsonBytes: BagOfBytes)throws  -> LinkConnectionQrData  {
    return try  FfiConverterTypeLinkConnectionQRData.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_link_connection_q_r_data_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newLinkConnectionQrDataSample() -> LinkConnectionQrData  {
    return try!  FfiConverterTypeLinkConnectionQRData.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_link_connection_qr_data_sample($0
    )
})
}
public func newLinkConnectionQrDataSampleOther() -> LinkConnectionQrData  {
    return try!  FfiConverterTypeLinkConnectionQRData.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_link_connection_qr_data_sample_other($0
    )
})
}
public func newLockerAddress(bech32: String)throws  -> LockerAddress  {
    return try  FfiConverterTypeLockerAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_locker_address(
        FfiConverterString.lower(bech32),$0
    )
})
}
/**
 * Returns a random address in `network_id` as Network
 */
public func newLockerAddressRandom(networkId: NetworkId) -> LockerAddress  {
    return try!  FfiConverterTypeLockerAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_locker_address_random(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func newLockerAddressSampleMainnet() -> LockerAddress  {
    return try!  FfiConverterTypeLockerAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_locker_address_sample_mainnet($0
    )
})
}
public func newLockerAddressSampleMainnetOther() -> LockerAddress  {
    return try!  FfiConverterTypeLockerAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_locker_address_sample_mainnet_other($0
    )
})
}
public func newLockerAddressSampleStokenet() -> LockerAddress  {
    return try!  FfiConverterTypeLockerAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_locker_address_sample_stokenet($0
    )
})
}
public func newLockerAddressSampleStokenetOther() -> LockerAddress  {
    return try!  FfiConverterTypeLockerAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_locker_address_sample_stokenet_other($0
    )
})
}
public func newManifestEncounteredComponentAddressFromBech32(string: String)throws  -> ManifestEncounteredComponentAddress  {
    return try  FfiConverterTypeManifestEncounteredComponentAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_from_bech32(
        FfiConverterString.lower(string),$0
    )
})
}
public func newManifestEncounteredComponentAddressSampleMainnet() -> ManifestEncounteredComponentAddress  {
    return try!  FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_sample_mainnet($0
    )
})
}
public func newManifestEncounteredComponentAddressSampleMainnetOther() -> ManifestEncounteredComponentAddress  {
    return try!  FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_sample_mainnet_other($0
    )
})
}
public func newManifestEncounteredComponentAddressSampleStokenet() -> ManifestEncounteredComponentAddress  {
    return try!  FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_sample_stokenet($0
    )
})
}
public func newManifestEncounteredComponentAddressSampleStokenetOther() -> ManifestEncounteredComponentAddress  {
    return try!  FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_sample_stokenet_other($0
    )
})
}
public func newMatrixOfFactorInstancesSample() -> MatrixOfFactorInstances  {
    return try!  FfiConverterTypeMatrixOfFactorInstances.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_matrix_of_factor_instances_sample($0
    )
})
}
public func newMatrixOfFactorInstancesSampleOther() -> MatrixOfFactorInstances  {
    return try!  FfiConverterTypeMatrixOfFactorInstances.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_matrix_of_factor_instances_sample_other($0
    )
})
}
public func newMatrixOfFactorSourceIDsSample() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_matrix_of_factor_source_i_ds_sample($0
    )
})
}
public func newMatrixOfFactorSourceIDsSampleOther() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_matrix_of_factor_source_i_ds_sample_other($0
    )
})
}
public func newMatrixOfFactorSourcesSample() -> MatrixOfFactorSources  {
    return try!  FfiConverterTypeMatrixOfFactorSources.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_matrix_of_factor_sources_sample($0
    )
})
}
public func newMatrixOfFactorSourcesSampleOther() -> MatrixOfFactorSources  {
    return try!  FfiConverterTypeMatrixOfFactorSources.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_matrix_of_factor_sources_sample_other($0
    )
})
}
public func newMessagePlaintextSample() -> Message  {
    return try!  FfiConverterTypeMessage.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_message_plaintext_sample($0
    )
})
}
public func newMessagePlaintextSampleOther() -> Message  {
    return try!  FfiConverterTypeMessage.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_message_plaintext_sample_other($0
    )
})
}
public func newMessagePlaintextString(string: String) -> Message  {
    return try!  FfiConverterTypeMessage.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_message_plaintext_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newMessageV2PlaintextSample() -> MessageV2  {
    return try!  FfiConverterTypeMessageV2.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_message_v2_plaintext_sample($0
    )
})
}
public func newMessageV2PlaintextSampleOther() -> MessageV2  {
    return try!  FfiConverterTypeMessageV2.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_message_v2_plaintext_sample_other($0
    )
})
}
public func newMessageV2PlaintextString(string: String) -> MessageV2  {
    return try!  FfiConverterTypeMessageV2.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_message_v2_plaintext_string(
        FfiConverterString.lower(string),$0
    )
})
}
/**
 * Returns new mnemonic from a string of words
 */
public func newMnemonicFromPhrase(phrase: String)throws  -> Mnemonic  {
    return try  FfiConverterTypeMnemonic.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_from_phrase(
        FfiConverterString.lower(phrase),$0
    )
})
}
public func newMnemonicFromPhraseLanguage(phrase: String, language: Bip39Language)throws  -> Mnemonic  {
    return try  FfiConverterTypeMnemonic.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_from_phrase_language(
        FfiConverterString.lower(phrase),
        FfiConverterTypeBIP39Language.lower(language),$0
    )
})
}
public func newMnemonicFromWords(words: [Bip39Word])throws  -> Mnemonic  {
    return try  FfiConverterTypeMnemonic.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_from_words(
        FfiConverterSequenceTypeBIP39Word.lower(words),$0
    )
})
}
public func newMnemonicGenerateWithEntropy(entropy: Bip39Entropy, language: Bip39Language) -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_generate_with_entropy(
        FfiConverterTypeBIP39Entropy.lower(entropy),
        FfiConverterTypeBIP39Language.lower(language),$0
    )
})
}
public func newMnemonicSample() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample($0
    )
})
}
public func newMnemonicSampleArculus() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_arculus($0
    )
})
}
public func newMnemonicSampleArculusOther() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_arculus_other($0
    )
})
}
public func newMnemonicSampleDevice() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_device($0
    )
})
}
public func newMnemonicSampleDevice12Words() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_device_12_words($0
    )
})
}
public func newMnemonicSampleDevice12WordsOther() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_device_12_words_other($0
    )
})
}
public func newMnemonicSampleDeviceOther() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_device_other($0
    )
})
}
public func newMnemonicSampleLedger() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_ledger($0
    )
})
}
public func newMnemonicSampleLedgerOther() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_ledger_other($0
    )
})
}
public func newMnemonicSampleOffDevice() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_off_device($0
    )
})
}
public func newMnemonicSampleOffDeviceOther() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_off_device_other($0
    )
})
}
public func newMnemonicSampleOther() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_other($0
    )
})
}
public func newMnemonicSamplePassword() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_password($0
    )
})
}
public func newMnemonicSamplePasswordOther() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_password_other($0
    )
})
}
public func newMnemonicSampleSecurityQuestions() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_security_questions($0
    )
})
}
public func newMnemonicSampleSecurityQuestionsOther() -> Mnemonic  {
    return try!  FfiConverterTypeMnemonic.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_security_questions_other($0
    )
})
}
public func newMnemonicWithPassphraseFromJsonBytes(jsonBytes: BagOfBytes)throws  -> MnemonicWithPassphrase  {
    return try  FfiConverterTypeMnemonicWithPassphrase.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_with_passphrase_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newMnemonicWithPassphraseSample() -> MnemonicWithPassphrase  {
    return try!  FfiConverterTypeMnemonicWithPassphrase.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_with_passphrase_sample($0
    )
})
}
public func newMnemonicWithPassphraseSampleOther() -> MnemonicWithPassphrase  {
    return try!  FfiConverterTypeMnemonicWithPassphrase.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_mnemonic_with_passphrase_sample_other($0
    )
})
}
public func newNetworkDefinitionLookupByName(logicalName: String)throws  -> NetworkDefinition  {
    return try  FfiConverterTypeNetworkDefinition.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_network_definition_lookup_by_name(
        FfiConverterString.lower(logicalName),$0
    )
})
}
public func newNetworkDefinitionSample() -> NetworkDefinition  {
    return try!  FfiConverterTypeNetworkDefinition.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_network_definition_sample($0
    )
})
}
public func newNetworkDefinitionSampleOther() -> NetworkDefinition  {
    return try!  FfiConverterTypeNetworkDefinition.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_network_definition_sample_other($0
    )
})
}
public func newNetworkIdFromDiscriminant(discriminant: UInt8)throws  -> NetworkId  {
    return try  FfiConverterTypeNetworkID.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_network_id_from_discriminant(
        FfiConverterUInt8.lower(discriminant),$0
    )
})
}
public func newNetworkMethodSample() -> NetworkMethod  {
    return try!  FfiConverterTypeNetworkMethod.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_network_method_sample($0
    )
})
}
public func newNetworkMethodSampleOther() -> NetworkMethod  {
    return try!  FfiConverterTypeNetworkMethod.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_network_method_sample_other($0
    )
})
}
public func newNetworkRequestSample() -> NetworkRequest  {
    return try!  FfiConverterTypeNetworkRequest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_network_request_sample($0
    )
})
}
public func newNetworkRequestSampleOther() -> NetworkRequest  {
    return try!  FfiConverterTypeNetworkRequest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_network_request_sample_other($0
    )
})
}
public func newNonEmptyMax32Bytes(bagOfBytes: BagOfBytes)throws  -> NonEmptyMax32Bytes  {
    return try  FfiConverterTypeNonEmptyMax32Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_non_empty_max_32_bytes(
        FfiConverterTypeBagOfBytes.lower(bagOfBytes),$0
    )
})
}
public func newNonEmptyMax64Bytes(bagOfBytes: BagOfBytes)throws  -> NonEmptyMax64Bytes  {
    return try  FfiConverterTypeNonEmptyMax64Bytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_non_empty_max_64_bytes(
        FfiConverterTypeBagOfBytes.lower(bagOfBytes),$0
    )
})
}
public func newNonFungibleGlobalIdFromString(string: String)throws  -> NonFungibleGlobalId  {
    return try  FfiConverterTypeNonFungibleGlobalId.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_global_id_from_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newNonFungibleGlobalIdSample() -> NonFungibleGlobalId  {
    return try!  FfiConverterTypeNonFungibleGlobalId.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_global_id_sample($0
    )
})
}
public func newNonFungibleGlobalIdSampleOther() -> NonFungibleGlobalId  {
    return try!  FfiConverterTypeNonFungibleGlobalId.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_global_id_sample_other($0
    )
})
}
public func newNonFungibleLocalIdBytes(bytes: BagOfBytes)throws  -> NonFungibleLocalId  {
    return try  FfiConverterTypeNonFungibleLocalId.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newNonFungibleLocalIdFromString(localId: String)throws  -> NonFungibleLocalId  {
    return try  FfiConverterTypeNonFungibleLocalId.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_from_string(
        FfiConverterString.lower(localId),$0
    )
})
}
public func newNonFungibleLocalIdInt(value: UInt64) -> NonFungibleLocalId  {
    return try!  FfiConverterTypeNonFungibleLocalId.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_int(
        FfiConverterUInt64.lower(value),$0
    )
})
}
public func newNonFungibleLocalIdRandom() -> NonFungibleLocalId  {
    return try!  FfiConverterTypeNonFungibleLocalId.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_random($0
    )
})
}
public func newNonFungibleLocalIdRuid(bytes: BagOfBytes)throws  -> NonFungibleLocalId  {
    return try  FfiConverterTypeNonFungibleLocalId.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_ruid(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newNonFungibleLocalIdSample() -> NonFungibleLocalId  {
    return try!  FfiConverterTypeNonFungibleLocalId.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_sample($0
    )
})
}
public func newNonFungibleLocalIdSampleOther() -> NonFungibleLocalId  {
    return try!  FfiConverterTypeNonFungibleLocalId.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_sample_other($0
    )
})
}
public func newNonFungibleLocalIdString(string: String)throws  -> NonFungibleLocalId  {
    return try  FfiConverterTypeNonFungibleLocalId.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newNonFungibleLocalIdStringFromStr(string: String)throws  -> NonFungibleLocalIdString  {
    return try  FfiConverterTypeNonFungibleLocalIdString.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_string_from_str(
        FfiConverterString.lower(string),$0
    )
})
}
/**
 * Tries to bech32 decode the string into a specialized address.
 */
public func newNonFungibleResourceAddress(bech32: String)throws  -> NonFungibleResourceAddress  {
    return try  FfiConverterTypeNonFungibleResourceAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address(
        FfiConverterString.lower(bech32),$0
    )
})
}
/**
 * Returns a random address in `network_id` as Network
 */
public func newNonFungibleResourceAddressRandom(networkId: NetworkId) -> NonFungibleResourceAddress  {
    return try!  FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_random(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func newNonFungibleResourceAddressSampleMainnet() -> NonFungibleResourceAddress  {
    return try!  FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_sample_mainnet($0
    )
})
}
public func newNonFungibleResourceAddressSampleMainnetOther() -> NonFungibleResourceAddress  {
    return try!  FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_sample_mainnet_other($0
    )
})
}
public func newNonFungibleResourceAddressSampleStokenet() -> NonFungibleResourceAddress  {
    return try!  FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_sample_stokenet($0
    )
})
}
public func newNonFungibleResourceAddressSampleStokenetOther() -> NonFungibleResourceAddress  {
    return try!  FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_sample_stokenet_other($0
    )
})
}
public func newNonFungibleResourceIndicatorSample() -> NonFungibleResourceIndicator  {
    return try!  FfiConverterTypeNonFungibleResourceIndicator.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_indicator_sample($0
    )
})
}
public func newNonFungibleResourceIndicatorSampleOther() -> NonFungibleResourceIndicator  {
    return try!  FfiConverterTypeNonFungibleResourceIndicator.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_indicator_sample_other($0
    )
})
}
public func newNonceFromU32(value: UInt32) -> Nonce  {
    return try!  FfiConverterTypeNonce.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_nonce_from_u32(
        FfiConverterUInt32.lower(value),$0
    )
})
}
public func newNonceRandom() -> Nonce  {
    return try!  FfiConverterTypeNonce.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_nonce_random($0
    )
})
}
public func newNonceSample() -> Nonce  {
    return try!  FfiConverterTypeNonce.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_nonce_sample($0
    )
})
}
public func newNonceSampleOther() -> Nonce  {
    return try!  FfiConverterTypeNonce.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_nonce_sample_other($0
    )
})
}
public func newNotarizedTransactionSample() -> NotarizedTransaction  {
    return try!  FfiConverterTypeNotarizedTransaction.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_notarized_transaction_sample($0
    )
})
}
public func newNotarizedTransactionSampleOther() -> NotarizedTransaction  {
    return try!  FfiConverterTypeNotarizedTransaction.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_notarized_transaction_sample_other($0
    )
})
}
public func newNotarySignature(signature: Signature) -> NotarySignature  {
    return try!  FfiConverterTypeNotarySignature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_notary_signature(
        FfiConverterTypeSignature.lower(signature),$0
    )
})
}
public func newNotarySignatureSample() -> NotarySignature  {
    return try!  FfiConverterTypeNotarySignature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_notary_signature_sample($0
    )
})
}
public func newNotarySignatureSampleOther() -> NotarySignature  {
    return try!  FfiConverterTypeNotarySignature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_notary_signature_sample_other($0
    )
})
}
public func newOffDeviceMnemonicFactorSourceFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: OffDeviceMnemonicHint) -> OffDeviceMnemonicFactorSource  {
    return try!  FfiConverterTypeOffDeviceMnemonicFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_off_device_mnemonic_factor_source_from_mnemonic_with_passphrase(
        FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
        FfiConverterTypeOffDeviceMnemonicHint.lower(hint),$0
    )
})
}
public func newOffDeviceMnemonicFactorSourceSample() -> OffDeviceMnemonicFactorSource  {
    return try!  FfiConverterTypeOffDeviceMnemonicFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_off_device_mnemonic_factor_source_sample($0
    )
})
}
public func newOffDeviceMnemonicFactorSourceSampleOther() -> OffDeviceMnemonicFactorSource  {
    return try!  FfiConverterTypeOffDeviceMnemonicFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_off_device_mnemonic_factor_source_sample_other($0
    )
})
}
public func newOnLedgerSettingsDefault() -> OnLedgerSettings  {
    return try!  FfiConverterTypeOnLedgerSettings.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_on_ledger_settings_default($0
    )
})
}
public func newOnLedgerSettingsSample() -> OnLedgerSettings  {
    return try!  FfiConverterTypeOnLedgerSettings.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_on_ledger_settings_sample($0
    )
})
}
public func newOnLedgerSettingsSampleOther() -> OnLedgerSettings  {
    return try!  FfiConverterTypeOnLedgerSettings.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_on_ledger_settings_sample_other($0
    )
})
}
public func newP2PLinkFromJsonBytes(jsonBytes: BagOfBytes)throws  -> P2pLink  {
    return try  FfiConverterTypeP2PLink.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_p2_p_link_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newP2PLinksSample() -> [P2pLink]  {
    return try!  FfiConverterSequenceTypeP2PLink.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_p2_p_links_sample($0
    )
})
}
public func newP2PLinksSampleOther() -> [P2pLink]  {
    return try!  FfiConverterSequenceTypeP2PLink.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_p2_p_links_sample_other($0
    )
})
}
public func newP2pLinkSample() -> P2pLink  {
    return try!  FfiConverterTypeP2PLink.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_p2p_link_sample($0
    )
})
}
public func newP2pLinkSampleOther() -> P2pLink  {
    return try!  FfiConverterTypeP2PLink.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_p2p_link_sample_other($0
    )
})
}
public func newP2pLinksFromJsonBytes(jsonBytes: BagOfBytes)throws  -> [P2pLink]  {
    return try  FfiConverterSequenceTypeP2PLink.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_p2p_links_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newPackageAddress(bech32: String)throws  -> PackageAddress  {
    return try  FfiConverterTypePackageAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_package_address(
        FfiConverterString.lower(bech32),$0
    )
})
}
/**
 * Returns a random address in `network_id` as Network
 */
public func newPackageAddressRandom(networkId: NetworkId) -> PackageAddress  {
    return try!  FfiConverterTypePackageAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_package_address_random(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func newPackageAddressSampleMainnet() -> PackageAddress  {
    return try!  FfiConverterTypePackageAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_package_address_sample_mainnet($0
    )
})
}
public func newPackageAddressSampleMainnetOther() -> PackageAddress  {
    return try!  FfiConverterTypePackageAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_package_address_sample_mainnet_other($0
    )
})
}
public func newPackageAddressSampleStokenet() -> PackageAddress  {
    return try!  FfiConverterTypePackageAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_package_address_sample_stokenet($0
    )
})
}
public func newPackageAddressSampleStokenetOther() -> PackageAddress  {
    return try!  FfiConverterTypePackageAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_package_address_sample_stokenet_other($0
    )
})
}
public func newPasswordFactorSourceFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: PasswordFactorSourceHint) -> PasswordFactorSource  {
    return try!  FfiConverterTypePasswordFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_password_factor_source_from_mnemonic_with_passphrase(
        FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
        FfiConverterTypePasswordFactorSourceHint.lower(hint),$0
    )
})
}
public func newPasswordFactorSourceSample() -> PasswordFactorSource  {
    return try!  FfiConverterTypePasswordFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_password_factor_source_sample($0
    )
})
}
public func newPasswordFactorSourceSampleOther() -> PasswordFactorSource  {
    return try!  FfiConverterTypePasswordFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_password_factor_source_sample_other($0
    )
})
}
public func newPerAssetTransfersSample() -> PerAssetTransfers  {
    return try!  FfiConverterTypePerAssetTransfers.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_per_asset_transfers_sample($0
    )
})
}
public func newPerAssetTransfersSampleOther() -> PerAssetTransfers  {
    return try!  FfiConverterTypePerAssetTransfers.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_per_asset_transfers_sample_other($0
    )
})
}
public func newPersonaDataEntryEmailAddressFromJsonString(jsonString: String)throws  -> EmailAddress  {
    return try  FfiConverterTypeEmailAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_persona_data_entry_email_address_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newPersonaDataEntryEmailAddressSample() -> EmailAddress  {
    return try!  FfiConverterTypeEmailAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_data_entry_email_address_sample($0
    )
})
}
public func newPersonaDataEntryEmailAddressSampleOther() -> EmailAddress  {
    return try!  FfiConverterTypeEmailAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_data_entry_email_address_sample_other($0
    )
})
}
public func newPersonaDataEntryNameFromJsonBytes(jsonBytes: BagOfBytes)throws  -> PersonaDataEntryName  {
    return try  FfiConverterTypePersonaDataEntryName.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_persona_data_entry_name_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newPersonaDataEntryNameSample() -> PersonaDataEntryName  {
    return try!  FfiConverterTypePersonaDataEntryName.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_data_entry_name_sample($0
    )
})
}
public func newPersonaDataEntryNameSampleOther() -> PersonaDataEntryName  {
    return try!  FfiConverterTypePersonaDataEntryName.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_data_entry_name_sample_other($0
    )
})
}
public func newPersonaDataEntryPhoneNumberFromJsonString(jsonString: String)throws  -> PersonaDataEntryPhoneNumber  {
    return try  FfiConverterTypePersonaDataEntryPhoneNumber.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_persona_data_entry_phone_number_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newPersonaDataEntryPhoneNumberSample() -> PersonaDataEntryPhoneNumber  {
    return try!  FfiConverterTypePersonaDataEntryPhoneNumber.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_data_entry_phone_number_sample($0
    )
})
}
public func newPersonaDataEntryPhoneNumberSampleOther() -> PersonaDataEntryPhoneNumber  {
    return try!  FfiConverterTypePersonaDataEntryPhoneNumber.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_data_entry_phone_number_sample_other($0
    )
})
}
public func newPersonaDataSample() -> PersonaData  {
    return try!  FfiConverterTypePersonaData.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_data_sample($0
    )
})
}
public func newPersonaDataSampleOther() -> PersonaData  {
    return try!  FfiConverterTypePersonaData.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_data_sample_other($0
    )
})
}
public func newPersonaSample() -> Persona  {
    return try!  FfiConverterTypePersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_sample($0
    )
})
}
public func newPersonaSampleMainnetBatman() -> Persona  {
    return try!  FfiConverterTypePersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_sample_mainnet_batman($0
    )
})
}
public func newPersonaSampleMainnetRipley() -> Persona  {
    return try!  FfiConverterTypePersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_sample_mainnet_ripley($0
    )
})
}
public func newPersonaSampleMainnetSatoshi() -> Persona  {
    return try!  FfiConverterTypePersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_sample_mainnet_satoshi($0
    )
})
}
public func newPersonaSampleMainnetTuring() -> Persona  {
    return try!  FfiConverterTypePersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_sample_mainnet_turing($0
    )
})
}
public func newPersonaSampleOther() -> Persona  {
    return try!  FfiConverterTypePersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_sample_other($0
    )
})
}
public func newPersonaSampleStokenetConnor() -> Persona  {
    return try!  FfiConverterTypePersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_sample_stokenet_connor($0
    )
})
}
public func newPersonaSampleStokenetHermione() -> Persona  {
    return try!  FfiConverterTypePersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_sample_stokenet_hermione($0
    )
})
}
public func newPersonaSampleStokenetLeiaSkywalker() -> Persona  {
    return try!  FfiConverterTypePersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_persona_sample_stokenet_leia_skywalker($0
    )
})
}
public func newPersonasSample() -> [Persona]  {
    return try!  FfiConverterSequenceTypePersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_personas_sample($0
    )
})
}
public func newPersonasSampleOther() -> [Persona]  {
    return try!  FfiConverterSequenceTypePersona.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_personas_sample_other($0
    )
})
}
public func newPoolAddress(bech32: String)throws  -> PoolAddress  {
    return try  FfiConverterTypePoolAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_pool_address(
        FfiConverterString.lower(bech32),$0
    )
})
}
/**
 * Returns a random address in `network_id` as Network
 */
public func newPoolAddressRandom(networkId: NetworkId) -> PoolAddress  {
    return try!  FfiConverterTypePoolAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_pool_address_random(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
/**
 * Sample to a mainnet PoolAddress with three resources.
 */
public func newPoolAddressSampleMainnetMulti() -> PoolAddress  {
    return try!  FfiConverterTypePoolAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_pool_address_sample_mainnet_multi($0
    )
})
}
/**
 * Sample to a mainnet PoolAddress with single resource.
 */
public func newPoolAddressSampleMainnetSingle() -> PoolAddress  {
    return try!  FfiConverterTypePoolAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_pool_address_sample_mainnet_single($0
    )
})
}
/**
 * Sample to a mainnet PoolAddress with two resources.
 */
public func newPoolAddressSampleMainnetTwo() -> PoolAddress  {
    return try!  FfiConverterTypePoolAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_pool_address_sample_mainnet_two($0
    )
})
}
/**
 * Sample to a stokenet PoolAddress with three resources.
 */
public func newPoolAddressSampleStokenetMulti() -> PoolAddress  {
    return try!  FfiConverterTypePoolAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_pool_address_sample_stokenet_multi($0
    )
})
}
/**
 * Sample to a stokenet PoolAddress with single resource.
 */
public func newPoolAddressSampleStokenetSingle() -> PoolAddress  {
    return try!  FfiConverterTypePoolAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_pool_address_sample_stokenet_single($0
    )
})
}
/**
 * Sample to a stokenet PoolAddress with two resources.
 */
public func newPoolAddressSampleStokenetTwo() -> PoolAddress  {
    return try!  FfiConverterTypePoolAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_pool_address_sample_stokenet_two($0
    )
})
}
public func newPrimaryRoleWithFactorInstancesSample() -> PrimaryRoleWithFactorInstances  {
    return try!  FfiConverterTypePrimaryRoleWithFactorInstances.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_primary_role_with_factor_instances_sample($0
    )
})
}
public func newPrimaryRoleWithFactorInstancesSampleOther() -> PrimaryRoleWithFactorInstances  {
    return try!  FfiConverterTypePrimaryRoleWithFactorInstances.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_primary_role_with_factor_instances_sample_other($0
    )
})
}
public func newPrimaryRoleWithFactorSourceIDsSample() -> PrimaryRoleWithFactorSourceIDs  {
    return try!  FfiConverterTypePrimaryRoleWithFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_primary_role_with_factor_source_i_ds_sample($0
    )
})
}
public func newPrimaryRoleWithFactorSourceIDsSampleOther() -> PrimaryRoleWithFactorSourceIDs  {
    return try!  FfiConverterTypePrimaryRoleWithFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_primary_role_with_factor_source_i_ds_sample_other($0
    )
})
}
public func newPrimaryRoleWithFactorSourcesSample() -> PrimaryRoleWithFactorSources  {
    return try!  FfiConverterTypePrimaryRoleWithFactorSources.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_primary_role_with_factor_sources_sample($0
    )
})
}
public func newPrimaryRoleWithFactorSourcesSampleOther() -> PrimaryRoleWithFactorSources  {
    return try!  FfiConverterTypePrimaryRoleWithFactorSources.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_primary_role_with_factor_sources_sample_other($0
    )
})
}
public func newPrivateHdFactorSourceBabylon(entropy: NonEmptyMax32Bytes, hostInfo: HostInfo)throws  -> PrivateHierarchicalDeterministicFactorSource  {
    return try  FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_babylon(
        FfiConverterTypeNonEmptyMax32Bytes.lower(entropy),
        FfiConverterTypeHostInfo.lower(hostInfo),$0
    )
})
}
public func newPrivateHdFactorSourceBabylonFromMnemonicWithPassphrase(mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> PrivateHierarchicalDeterministicFactorSource  {
    return try!  FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_babylon_from_mnemonic_with_passphrase(
        FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
        FfiConverterTypeHostInfo.lower(hostInfo),$0
    )
})
}
public func newPrivateHdFactorSourceOlympiaFromMnemonicWithPassphrase(mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> PrivateHierarchicalDeterministicFactorSource  {
    return try!  FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_olympia_from_mnemonic_with_passphrase(
        FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
        FfiConverterTypeHostInfo.lower(hostInfo),$0
    )
})
}
public func newPrivateHdFactorSourceSample() -> PrivateHierarchicalDeterministicFactorSource  {
    return try!  FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_sample($0
    )
})
}
public func newPrivateHdFactorSourceSampleOther() -> PrivateHierarchicalDeterministicFactorSource  {
    return try!  FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_sample_other($0
    )
})
}
/**
 * # Panics
 * Panics if `device_factor_source` is not a main BDFS.
 */
public func newProfile(deviceFactorSource: DeviceFactorSource, hostId: HostId, hostInfo: HostInfo) -> Profile  {
    return try!  FfiConverterTypeProfile.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_profile(
        FfiConverterTypeDeviceFactorSource.lower(deviceFactorSource),
        FfiConverterTypeHostId.lower(hostId),
        FfiConverterTypeHostInfo.lower(hostInfo),$0
    )
})
}
public func newProfileFileContentsSample() -> ProfileFileContents  {
    return try!  FfiConverterTypeProfileFileContents.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_profile_file_contents_sample($0
    )
})
}
public func newProfileFileContentsSampleOther() -> ProfileFileContents  {
    return try!  FfiConverterTypeProfileFileContents.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_profile_file_contents_sample_other($0
    )
})
}
public func newProfileFromEncryptionBytes(jsonString: String, decryptionPassword: String)throws  -> Profile  {
    return try  FfiConverterTypeProfile.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_profile_from_encryption_bytes(
        FfiConverterString.lower(jsonString),
        FfiConverterString.lower(decryptionPassword),$0
    )
})
}
public func newProfileFromJsonString(jsonStr: String)throws  -> Profile  {
    return try  FfiConverterTypeProfile.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_profile_from_json_string(
        FfiConverterString.lower(jsonStr),$0
    )
})
}
public func newProfileIdSample() -> ProfileId  {
    return try!  FfiConverterTypeProfileID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_profile_id_sample($0
    )
})
}
public func newProfileIdSampleOther() -> ProfileId  {
    return try!  FfiConverterTypeProfileID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_profile_id_sample_other($0
    )
})
}
public func newProfileNetworkSample() -> ProfileNetwork  {
    return try!  FfiConverterTypeProfileNetwork.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_profile_network_sample($0
    )
})
}
public func newProfileNetworkSampleOther() -> ProfileNetwork  {
    return try!  FfiConverterTypeProfileNetwork.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_profile_network_sample_other($0
    )
})
}
public func newProfileNetworksSample() -> [ProfileNetwork]  {
    return try!  FfiConverterSequenceTypeProfileNetwork.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_profile_networks_sample($0
    )
})
}
public func newProfileNetworksSampleOther() -> [ProfileNetwork]  {
    return try!  FfiConverterSequenceTypeProfileNetwork.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_profile_networks_sample_other($0
    )
})
}
public func newProfileSample() -> Profile  {
    return try!  FfiConverterTypeProfile.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_profile_sample($0
    )
})
}
public func newProfileSampleOther() -> Profile  {
    return try!  FfiConverterTypeProfile.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_profile_sample_other($0
    )
})
}
public func newProfileWithMnemonic(mnemonic: Mnemonic, hostId: HostId, hostInfo: HostInfo) -> Profile  {
    return try!  FfiConverterTypeProfile.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_profile_with_mnemonic(
        FfiConverterTypeMnemonic.lower(mnemonic),
        FfiConverterTypeHostId.lower(hostId),
        FfiConverterTypeHostInfo.lower(hostInfo),$0
    )
})
}
/**
 * Tries to create a PublicKey from the bytes
 */
public func newPublicKeyFromBytes(bagOfBytes: BagOfBytes)throws  -> PublicKey  {
    return try  FfiConverterTypePublicKey.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_public_key_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bagOfBytes),$0
    )
})
}
/**
 * Tries to create a PublicKey from the hex string
 */
public func newPublicKeyFromHex(hex: String)throws  -> PublicKey  {
    return try  FfiConverterTypePublicKey.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_public_key_from_hex(
        FfiConverterString.lower(hex),$0
    )
})
}
public func newPublicKeyHashOfKey(publicKey: PublicKey) -> PublicKeyHash  {
    return try!  FfiConverterTypePublicKeyHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_public_key_hash_of_key(
        FfiConverterTypePublicKey.lower(publicKey),$0
    )
})
}
public func newPublicKeyHashSample() -> PublicKeyHash  {
    return try!  FfiConverterTypePublicKeyHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_public_key_hash_sample($0
    )
})
}
public func newPublicKeyHashSampleOther() -> PublicKeyHash  {
    return try!  FfiConverterTypePublicKeyHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_public_key_hash_sample_other($0
    )
})
}
public func newPublicKeySample() -> PublicKey  {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_public_key_sample($0
    )
})
}
public func newPublicKeySampleOther() -> PublicKey  {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_public_key_sample_other($0
    )
})
}
public func newRadixConnectMobileSessionRequestFromJsonBytes(jsonBytes: BagOfBytes)throws  -> RadixConnectMobileSessionRequest  {
    return try  FfiConverterTypeRadixConnectMobileSessionRequest.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_radix_connect_mobile_session_request_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newRadixConnectMobileSessionRequestSample() -> RadixConnectMobileSessionRequest  {
    return try!  FfiConverterTypeRadixConnectMobileSessionRequest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_radix_connect_mobile_session_request_sample($0
    )
})
}
public func newRadixConnectMobileSessionRequestSampleOther() -> RadixConnectMobileSessionRequest  {
    return try!  FfiConverterTypeRadixConnectMobileSessionRequest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_radix_connect_mobile_session_request_sample_other($0
    )
})
}
public func newRadixConnectPassword(bytes: Exactly32Bytes) -> RadixConnectPassword  {
    return try!  FfiConverterTypeRadixConnectPassword.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_radix_connect_password(
        FfiConverterTypeExactly32Bytes.lower(bytes),$0
    )
})
}
public func newRadixConnectPasswordFromJsonString(jsonString: String)throws  -> RadixConnectPassword  {
    return try  FfiConverterTypeRadixConnectPassword.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_radix_connect_password_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newRadixConnectPasswordSample() -> RadixConnectPassword  {
    return try!  FfiConverterTypeRadixConnectPassword.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_radix_connect_password_sample($0
    )
})
}
public func newRadixConnectPasswordSampleOther() -> RadixConnectPassword  {
    return try!  FfiConverterTypeRadixConnectPassword.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_radix_connect_password_sample_other($0
    )
})
}
public func newRadixConnectPurposeFromJsonString(jsonString: String)throws  -> RadixConnectPurpose  {
    return try  FfiConverterTypeRadixConnectPurpose.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_radix_connect_purpose_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newRadixConnectPurposeFromString(string: String) -> RadixConnectPurpose  {
    return try!  FfiConverterTypeRadixConnectPurpose.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_radix_connect_purpose_from_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newRadixConnectPurposeSample() -> RadixConnectPurpose  {
    return try!  FfiConverterTypeRadixConnectPurpose.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_radix_connect_purpose_sample($0
    )
})
}
public func newRadixConnectPurposeSampleOther() -> RadixConnectPurpose  {
    return try!  FfiConverterTypeRadixConnectPurpose.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_radix_connect_purpose_sample_other($0
    )
})
}
public func newRecoveryRoleWithFactorInstancesSample() -> RecoveryRoleWithFactorInstances  {
    return try!  FfiConverterTypeRecoveryRoleWithFactorInstances.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_recovery_role_with_factor_instances_sample($0
    )
})
}
public func newRecoveryRoleWithFactorInstancesSampleOther() -> RecoveryRoleWithFactorInstances  {
    return try!  FfiConverterTypeRecoveryRoleWithFactorInstances.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_recovery_role_with_factor_instances_sample_other($0
    )
})
}
public func newRecoveryRoleWithFactorSourceIDsSample() -> RecoveryRoleWithFactorSourceIDs  {
    return try!  FfiConverterTypeRecoveryRoleWithFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_recovery_role_with_factor_source_i_ds_sample($0
    )
})
}
public func newRecoveryRoleWithFactorSourceIDsSampleOther() -> RecoveryRoleWithFactorSourceIDs  {
    return try!  FfiConverterTypeRecoveryRoleWithFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_recovery_role_with_factor_source_i_ds_sample_other($0
    )
})
}
public func newRecoveryRoleWithFactorSourcesSample() -> RecoveryRoleWithFactorSources  {
    return try!  FfiConverterTypeRecoveryRoleWithFactorSources.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_recovery_role_with_factor_sources_sample($0
    )
})
}
public func newRecoveryRoleWithFactorSourcesSampleOther() -> RecoveryRoleWithFactorSources  {
    return try!  FfiConverterTypeRecoveryRoleWithFactorSources.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_recovery_role_with_factor_sources_sample_other($0
    )
})
}
public func newReferencesToAuthorizedPersonasSample() -> [AuthorizedPersonaSimple]  {
    return try!  FfiConverterSequenceTypeAuthorizedPersonaSimple.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_references_to_authorized_personas_sample($0
    )
})
}
public func newReferencesToAuthorizedPersonasSampleOther() -> [AuthorizedPersonaSimple]  {
    return try!  FfiConverterSequenceTypeAuthorizedPersonaSimple.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_references_to_authorized_personas_sample_other($0
    )
})
}
public func newRequestedQuantityFromJsonBytes(jsonBytes: BagOfBytes)throws  -> RequestedQuantity  {
    return try  FfiConverterTypeRequestedQuantity.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_requested_quantity_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newRequestedQuantitySample() -> RequestedQuantity  {
    return try!  FfiConverterTypeRequestedQuantity.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_requested_quantity_sample($0
    )
})
}
public func newRequestedQuantitySampleOther() -> RequestedQuantity  {
    return try!  FfiConverterTypeRequestedQuantity.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_requested_quantity_sample_other($0
    )
})
}
public func newResourceAddress(bech32: String)throws  -> ResourceAddress  {
    return try  FfiConverterTypeResourceAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_resource_address(
        FfiConverterString.lower(bech32),$0
    )
})
}
/**
 * Returns a random address in `network_id` as Network
 */
public func newResourceAddressRandom(networkId: NetworkId) -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_address_random(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func newResourceAddressSampleMainnetCandy() -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_address_sample_mainnet_candy($0
    )
})
}
public func newResourceAddressSampleMainnetNftGcMembership() -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_address_sample_mainnet_nft_gc_membership($0
    )
})
}
public func newResourceAddressSampleMainnetXrd() -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_address_sample_mainnet_xrd($0
    )
})
}
public func newResourceAddressSampleStokenetCandy() -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_address_sample_stokenet_candy($0
    )
})
}
public func newResourceAddressSampleStokenetGcTokens() -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_address_sample_stokenet_gc_tokens($0
    )
})
}
public func newResourceAddressSampleStokenetGum() -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_address_sample_stokenet_gum($0
    )
})
}
public func newResourceAddressSampleStokenetXrd() -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_address_sample_stokenet_xrd($0
    )
})
}
public func newResourceIndicatorSample() -> ResourceIndicator  {
    return try!  FfiConverterTypeResourceIndicator.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_indicator_sample($0
    )
})
}
public func newResourceIndicatorSampleOther() -> ResourceIndicator  {
    return try!  FfiConverterTypeResourceIndicator.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_indicator_sample_other($0
    )
})
}
public func newResourceOrNonFungibleSample() -> ResourceOrNonFungible  {
    return try!  FfiConverterTypeResourceOrNonFungible.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_or_non_fungible_sample($0
    )
})
}
public func newResourceOrNonFungibleSampleOther() -> ResourceOrNonFungible  {
    return try!  FfiConverterTypeResourceOrNonFungible.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_or_non_fungible_sample_other($0
    )
})
}
public func newResourcePreferencesSample() -> [ResourceAppPreference]  {
    return try!  FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_preferences_sample($0
    )
})
}
public func newResourcePreferencesSampleOther() -> [ResourceAppPreference]  {
    return try!  FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_preferences_sample_other($0
    )
})
}
public func newResourceSpecifierSample() -> ResourceSpecifier  {
    return try!  FfiConverterTypeResourceSpecifier.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_specifier_sample($0
    )
})
}
public func newResourceSpecifierSampleOther() -> ResourceSpecifier  {
    return try!  FfiConverterTypeResourceSpecifier.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_resource_specifier_sample_other($0
    )
})
}
public func newSLIP10CurveFromJsonString(jsonString: String)throws  -> Slip10Curve  {
    return try  FfiConverterTypeSLIP10Curve.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_s_l_i_p10_curve_from_json_string(
        FfiConverterString.lower(jsonString),$0
    )
})
}
public func newSampleConfig11() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_1_1($0
    )
})
}
public func newSampleConfig12() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_1_2($0
    )
})
}
public func newSampleConfig13() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_1_3($0
    )
})
}
public func newSampleConfig14() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_1_4($0
    )
})
}
public func newSampleConfig15() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_1_5($0
    )
})
}
public func newSampleConfig21() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_2_1($0
    )
})
}
public func newSampleConfig22() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_2_2($0
    )
})
}
public func newSampleConfig23() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_2_3($0
    )
})
}
public func newSampleConfig24() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_2_4($0
    )
})
}
public func newSampleConfig30() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_3_0($0
    )
})
}
public func newSampleConfig40() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_4_0($0
    )
})
}
public func newSampleConfig51() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_5_1($0
    )
})
}
public func newSampleConfig52() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_5_2($0
    )
})
}
public func newSampleConfig60() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_6_0($0
    )
})
}
public func newSampleConfig70() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_7_0($0
    )
})
}
public func newSampleConfig80() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_8_0($0
    )
})
}
public func newSampleConfig90() -> MatrixOfFactorSourceIDs  {
    return try!  FfiConverterTypeMatrixOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sample_config_9_0($0
    )
})
}
public func newSargonBuildInformationSample() -> SargonBuildInformation  {
    return try!  FfiConverterTypeSargonBuildInformation.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sargon_build_information_sample($0
    )
})
}
public func newSargonBuildInformationSampleOther() -> SargonBuildInformation  {
    return try!  FfiConverterTypeSargonBuildInformation.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sargon_build_information_sample_other($0
    )
})
}
/**
 * Constructs `Gateways` with `current` set as active Gateway.
 */
public func newSavedGateways(current: Gateway) -> SavedGateways  {
    return try!  FfiConverterTypeSavedGateways.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_saved_gateways(
        FfiConverterTypeGateway.lower(current),$0
    )
})
}
public func newSavedGatewaysChangingCurrent(to: Gateway, gateways: SavedGateways)throws  -> SavedGateways  {
    return try  FfiConverterTypeSavedGateways.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_saved_gateways_changing_current(
        FfiConverterTypeGateway.lower(to),
        FfiConverterTypeSavedGateways.lower(gateways),$0
    )
})
}
/**
 * Constructs `Gateways` with default preset values.
 */
public func newSavedGatewaysDefault() -> SavedGateways  {
    return try!  FfiConverterTypeSavedGateways.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_saved_gateways_default($0
    )
})
}
/**
 * A sample value useful for tests and previews.
 */
public func newSavedGatewaysSample() -> SavedGateways  {
    return try!  FfiConverterTypeSavedGateways.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_saved_gateways_sample($0
    )
})
}
/**
 * A sample value useful for tests and previews.
 */
public func newSavedGatewaysSampleOther() -> SavedGateways  {
    return try!  FfiConverterTypeSavedGateways.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_saved_gateways_sample_other($0
    )
})
}
/**
 * Creates a Secp256k1PublicKey from either compressed form (33 bytes) or
 * from uncompressed form (65 bytes).
 */
public func newSecp256k1PublicKeyFromBytes(bytes: BagOfBytes)throws  -> Secp256k1PublicKey  {
    return try  FfiConverterTypeSecp256k1PublicKey.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_secp256k1_public_key_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newSecp256k1PublicKeyFromHex(hex: String)throws  -> Secp256k1PublicKey  {
    return try  FfiConverterTypeSecp256k1PublicKey.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_secp256k1_public_key_from_hex(
        FfiConverterString.lower(hex),$0
    )
})
}
public func newSecp256k1PublicKeySample() -> Secp256k1PublicKey  {
    return try!  FfiConverterTypeSecp256k1PublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_secp256k1_public_key_sample($0
    )
})
}
public func newSecp256k1PublicKeySampleOther() -> Secp256k1PublicKey  {
    return try!  FfiConverterTypeSecp256k1PublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_secp256k1_public_key_sample_other($0
    )
})
}
public func newSecp256k1SignatureFromBytes(bytes: BagOfBytes)throws  -> Secp256k1Signature  {
    return try  FfiConverterTypeSecp256k1Signature.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_secp256k1_signature_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newSecp256k1SignatureFromExactly65Bytes(bytes: Exactly65Bytes) -> Secp256k1Signature  {
    return try!  FfiConverterTypeSecp256k1Signature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_secp256k1_signature_from_exactly_65_bytes(
        FfiConverterTypeExactly65Bytes.lower(bytes),$0
    )
})
}
public func newSecp256k1SignatureSample() -> Secp256k1Signature  {
    return try!  FfiConverterTypeSecp256k1Signature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_secp256k1_signature_sample($0
    )
})
}
public func newSecp256k1SignatureSampleOther() -> Secp256k1Signature  {
    return try!  FfiConverterTypeSecp256k1Signature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_secp256k1_signature_sample_other($0
    )
})
}
public func newSecuredEntityControlSample() -> SecuredEntityControl  {
    return try!  FfiConverterTypeSecuredEntityControl.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_secured_entity_control_sample($0
    )
})
}
public func newSecuredEntityControlSampleOther() -> SecuredEntityControl  {
    return try!  FfiConverterTypeSecuredEntityControl.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_secured_entity_control_sample_other($0
    )
})
}
public func newSecurified(u30: U30) -> SecurifiedU30  {
    return try!  FfiConverterTypeSecurifiedU30.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_securified(
        FfiConverterTypeU30.lower(u30),$0
    )
})
}
public func newSecurifiedFromGlobalKeySpace(value: UInt32)throws  -> SecurifiedU30  {
    return try  FfiConverterTypeSecurifiedU30.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_securified_from_global_key_space(
        FfiConverterUInt32.lower(value),$0
    )
})
}
public func newSecurifiedFromLocalKeySpace(value: UInt32)throws  -> SecurifiedU30  {
    return try  FfiConverterTypeSecurifiedU30.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_securified_from_local_key_space(
        FfiConverterUInt32.lower(value),$0
    )
})
}
public func newSecurifiedSample() -> SecurifiedU30  {
    return try!  FfiConverterTypeSecurifiedU30.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_securified_sample($0
    )
})
}
public func newSecurifiedSampleOther() -> SecurifiedU30  {
    return try!  FfiConverterTypeSecurifiedU30.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_securified_sample_other($0
    )
})
}
public func newSecurityStructureMetadataNamed(name: DisplayName) -> SecurityStructureMetadata  {
    return try!  FfiConverterTypeSecurityStructureMetadata.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_security_structure_metadata_named(
        FfiConverterTypeDisplayName.lower(name),$0
    )
})
}
public func newSecurityStructureMetadataSample() -> SecurityStructureMetadata  {
    return try!  FfiConverterTypeSecurityStructureMetadata.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_security_structure_metadata_sample($0
    )
})
}
public func newSecurityStructureMetadataSampleOther() -> SecurityStructureMetadata  {
    return try!  FfiConverterTypeSecurityStructureMetadata.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_security_structure_metadata_sample_other($0
    )
})
}
public func newSecurityStructureOfFactorInstancesSample() -> SecurityStructureOfFactorInstances  {
    return try!  FfiConverterTypeSecurityStructureOfFactorInstances.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_instances_sample($0
    )
})
}
public func newSecurityStructureOfFactorInstancesSampleOther() -> SecurityStructureOfFactorInstances  {
    return try!  FfiConverterTypeSecurityStructureOfFactorInstances.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_instances_sample_other($0
    )
})
}
public func newSecurityStructureOfFactorSourceIdsSample() -> SecurityStructureOfFactorSourceIDs  {
    return try!  FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_source_ids_sample($0
    )
})
}
public func newSecurityStructureOfFactorSourceIdsSampleOther() -> SecurityStructureOfFactorSourceIDs  {
    return try!  FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_source_ids_sample_other($0
    )
})
}
public func newSecurityStructureOfFactorSourcesSample() -> SecurityStructureOfFactorSources  {
    return try!  FfiConverterTypeSecurityStructureOfFactorSources.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_sources_sample($0
    )
})
}
public func newSecurityStructureOfFactorSourcesSampleOther() -> SecurityStructureOfFactorSources  {
    return try!  FfiConverterTypeSecurityStructureOfFactorSources.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_sources_sample_other($0
    )
})
}
public func newSecurityStructuresOfFactorSourceIDsSample() -> [SecurityStructureOfFactorSourceIDs]  {
    return try!  FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_security_structures_of_factor_source_i_ds_sample($0
    )
})
}
public func newSecurityStructuresOfFactorSourceIDsSampleOther() -> [SecurityStructureOfFactorSourceIDs]  {
    return try!  FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_security_structures_of_factor_source_i_ds_sample_other($0
    )
})
}
public func newSharedPersonaDataSample() -> SharedPersonaData  {
    return try!  FfiConverterTypeSharedPersonaData.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_shared_persona_data_sample($0
    )
})
}
public func newSharedPersonaDataSampleOther() -> SharedPersonaData  {
    return try!  FfiConverterTypeSharedPersonaData.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_shared_persona_data_sample_other($0
    )
})
}
public func newShieldForDisplaySample() -> ShieldForDisplay  {
    return try!  FfiConverterTypeShieldForDisplay.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_shield_for_display_sample($0
    )
})
}
public func newShieldForDisplaySampleOther() -> ShieldForDisplay  {
    return try!  FfiConverterTypeShieldForDisplay.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_shield_for_display_sample_other($0
    )
})
}
public func newShieldsForDisplaySample() -> [ShieldForDisplay]  {
    return try!  FfiConverterSequenceTypeShieldForDisplay.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_shields_for_display_sample($0
    )
})
}
public func newShieldsForDisplaySampleOther() -> [ShieldForDisplay]  {
    return try!  FfiConverterSequenceTypeShieldForDisplay.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_shields_for_display_sample_other($0
    )
})
}
public func newSignRequestOfAuthIntentSample() -> SignRequestOfAuthIntent  {
    return try!  FfiConverterTypeSignRequestOfAuthIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sign_request_of_auth_intent_sample($0
    )
})
}
public func newSignRequestOfAuthIntentSampleOther() -> SignRequestOfAuthIntent  {
    return try!  FfiConverterTypeSignRequestOfAuthIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sign_request_of_auth_intent_sample_other($0
    )
})
}
public func newSignRequestOfSubintentSample() -> SignRequestOfSubintent  {
    return try!  FfiConverterTypeSignRequestOfSubintent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sign_request_of_subintent_sample($0
    )
})
}
public func newSignRequestOfSubintentSampleOther() -> SignRequestOfSubintent  {
    return try!  FfiConverterTypeSignRequestOfSubintent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sign_request_of_subintent_sample_other($0
    )
})
}
public func newSignRequestOfTransactionIntentSample() -> SignRequestOfTransactionIntent  {
    return try!  FfiConverterTypeSignRequestOfTransactionIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sign_request_of_transaction_intent_sample($0
    )
})
}
public func newSignRequestOfTransactionIntentSampleOther() -> SignRequestOfTransactionIntent  {
    return try!  FfiConverterTypeSignRequestOfTransactionIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sign_request_of_transaction_intent_sample_other($0
    )
})
}
public func newSignResponseOfAuthIntentHashFromOutcomes(outcomes: [PerFactorOutcomeOfAuthIntentHash])throws  -> SignResponseOfAuthIntentHash  {
    return try  FfiConverterTypeSignResponseOfAuthIntentHash.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_sign_response_of_auth_intent_hash_from_outcomes(
        FfiConverterSequenceTypePerFactorOutcomeOfAuthIntentHash.lower(outcomes),$0
    )
})
}
public func newSignResponseOfAuthIntentHashFromSkippingFactors(factors: [FactorSourceIdFromHash]) -> SignResponseOfAuthIntentHash  {
    return try!  FfiConverterTypeSignResponseOfAuthIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sign_response_of_auth_intent_hash_from_skipping_factors(
        FfiConverterSequenceTypeFactorSourceIDFromHash.lower(factors),$0
    )
})
}
public func newSignResponseOfSubintentHashFromOutcomes(outcomes: [PerFactorOutcomeOfSubintentHash])throws  -> SignResponseOfSubintentHash  {
    return try  FfiConverterTypeSignResponseOfSubintentHash.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_sign_response_of_subintent_hash_from_outcomes(
        FfiConverterSequenceTypePerFactorOutcomeOfSubintentHash.lower(outcomes),$0
    )
})
}
public func newSignResponseOfSubintentHashFromSkippingFactors(factors: [FactorSourceIdFromHash]) -> SignResponseOfSubintentHash  {
    return try!  FfiConverterTypeSignResponseOfSubintentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sign_response_of_subintent_hash_from_skipping_factors(
        FfiConverterSequenceTypeFactorSourceIDFromHash.lower(factors),$0
    )
})
}
public func newSignResponseOfTransactionIntentHashFromOutcomes(outcomes: [PerFactorOutcomeOfTransactionIntentHash])throws  -> SignResponseOfTransactionIntentHash  {
    return try  FfiConverterTypeSignResponseOfTransactionIntentHash.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_sign_response_of_transaction_intent_hash_from_outcomes(
        FfiConverterSequenceTypePerFactorOutcomeOfTransactionIntentHash.lower(outcomes),$0
    )
})
}
public func newSignResponseOfTransactionIntentHashFromSkippingFactors(factors: [FactorSourceIdFromHash]) -> SignResponseOfTransactionIntentHash  {
    return try!  FfiConverterTypeSignResponseOfTransactionIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_sign_response_of_transaction_intent_hash_from_skipping_factors(
        FfiConverterSequenceTypeFactorSourceIDFromHash.lower(factors),$0
    )
})
}
public func newSignatureFromBytes(bytes: BagOfBytes)throws  -> Signature  {
    return try  FfiConverterTypeSignature.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_signature_from_bytes(
        FfiConverterTypeBagOfBytes.lower(bytes),$0
    )
})
}
public func newSignatureSample() -> Signature  {
    return try!  FfiConverterTypeSignature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_signature_sample($0
    )
})
}
public func newSignatureSampleOther() -> Signature  {
    return try!  FfiConverterTypeSignature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_signature_sample_other($0
    )
})
}
public func newSignatureWithPublicKeySample() -> SignatureWithPublicKey  {
    return try!  FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_signature_with_public_key_sample($0
    )
})
}
public func newSignatureWithPublicKeySampleOther() -> SignatureWithPublicKey  {
    return try!  FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_signature_with_public_key_sample_other($0
    )
})
}
public func newSignedAuthIntentSample() -> SignedAuthIntent  {
    return try!  FfiConverterTypeSignedAuthIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_signed_auth_intent_sample($0
    )
})
}
public func newSignedAuthIntentSampleOther() -> SignedAuthIntent  {
    return try!  FfiConverterTypeSignedAuthIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_signed_auth_intent_sample_other($0
    )
})
}
public func newSignedFactorOutcomeOfAuthIntentHash(producedSignatures: [HdSignatureOfAuthIntentHash])throws  -> FactorOutcomeOfAuthIntentHash  {
    return try  FfiConverterTypeFactorOutcomeOfAuthIntentHash.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_signed_factor_outcome_of_auth_intent_hash(
        FfiConverterSequenceTypeHDSignatureOfAuthIntentHash.lower(producedSignatures),$0
    )
})
}
public func newSignedFactorOutcomeOfSubintentHash(producedSignatures: [HdSignatureOfSubintentHash])throws  -> FactorOutcomeOfSubintentHash  {
    return try  FfiConverterTypeFactorOutcomeOfSubintentHash.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_signed_factor_outcome_of_subintent_hash(
        FfiConverterSequenceTypeHDSignatureOfSubintentHash.lower(producedSignatures),$0
    )
})
}
public func newSignedFactorOutcomeOfTransactionIntentHash(producedSignatures: [HdSignatureOfTransactionIntentHash])throws  -> FactorOutcomeOfTransactionIntentHash  {
    return try  FfiConverterTypeFactorOutcomeOfTransactionIntentHash.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_signed_factor_outcome_of_transaction_intent_hash(
        FfiConverterSequenceTypeHDSignatureOfTransactionIntentHash.lower(producedSignatures),$0
    )
})
}
public func newSignedIntentHashSample() -> SignedTransactionIntentHash  {
    return try!  FfiConverterTypeSignedTransactionIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_signed_intent_hash_sample($0
    )
})
}
public func newSignedIntentHashSampleOther() -> SignedTransactionIntentHash  {
    return try!  FfiConverterTypeSignedTransactionIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_signed_intent_hash_sample_other($0
    )
})
}
public func newSignedIntentSample() -> SignedIntent  {
    return try!  FfiConverterTypeSignedIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_signed_intent_sample($0
    )
})
}
public func newSignedIntentSampleOther() -> SignedIntent  {
    return try!  FfiConverterTypeSignedIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_signed_intent_sample_other($0
    )
})
}
public func newSignedTransactionIntentHashFromString(string: String)throws  -> SignedTransactionIntentHash  {
    return try  FfiConverterTypeSignedTransactionIntentHash.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_signed_transaction_intent_hash_from_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newSkippedFactorOutcomeOfAuthIntentHash(factorSourceId: FactorSourceIdFromHash) -> FactorOutcomeOfAuthIntentHash  {
    return try!  FfiConverterTypeFactorOutcomeOfAuthIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_skipped_factor_outcome_of_auth_intent_hash(
        FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceId),$0
    )
})
}
public func newSkippedFactorOutcomeOfSubintentHash(factorSourceId: FactorSourceIdFromHash) -> FactorOutcomeOfSubintentHash  {
    return try!  FfiConverterTypeFactorOutcomeOfSubintentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_skipped_factor_outcome_of_subintent_hash(
        FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceId),$0
    )
})
}
public func newSkippedFactorOutcomeOfTransactionIntentHash(factorSourceId: FactorSourceIdFromHash) -> FactorOutcomeOfTransactionIntentHash  {
    return try!  FfiConverterTypeFactorOutcomeOfTransactionIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_skipped_factor_outcome_of_transaction_intent_hash(
        FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceId),$0
    )
})
}
public func newSlip10CurveFromString(curve: String)throws  -> Slip10Curve  {
    return try  FfiConverterTypeSLIP10Curve.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_slip10_curve_from_string(
        FfiConverterString.lower(curve),$0
    )
})
}
public func newStakeClaimSample() -> StakeClaim  {
    return try!  FfiConverterTypeStakeClaim.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_stake_claim_sample($0
    )
})
}
public func newStakeClaimSampleOther() -> StakeClaim  {
    return try!  FfiConverterTypeStakeClaim.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_stake_claim_sample_other($0
    )
})
}
public func newSubintent(header: IntentHeaderV2, manifest: SubintentManifest, message: MessageV2)throws  -> Subintent  {
    return try  FfiConverterTypeSubintent.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_subintent(
        FfiConverterTypeIntentHeaderV2.lower(header),
        FfiConverterTypeSubintentManifest.lower(manifest),
        FfiConverterTypeMessageV2.lower(message),$0
    )
})
}
public func newSubintentHashFromString(string: String)throws  -> SubintentHash  {
    return try  FfiConverterTypeSubintentHash.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_subintent_hash_from_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newSubintentHashSample() -> SubintentHash  {
    return try!  FfiConverterTypeSubintentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_subintent_hash_sample($0
    )
})
}
public func newSubintentHashSampleOther() -> SubintentHash  {
    return try!  FfiConverterTypeSubintentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_subintent_hash_sample_other($0
    )
})
}
public func newSubintentManifestSample() -> SubintentManifest  {
    return try!  FfiConverterTypeSubintentManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_subintent_manifest_sample($0
    )
})
}
public func newSubintentManifestSampleOther() -> SubintentManifest  {
    return try!  FfiConverterTypeSubintentManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_subintent_manifest_sample_other($0
    )
})
}
public func newSubintentSample() -> Subintent  {
    return try!  FfiConverterTypeSubintent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_subintent_sample($0
    )
})
}
public func newSubintentSampleOther() -> Subintent  {
    return try!  FfiConverterTypeSubintent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_subintent_sample_other($0
    )
})
}
public func newSupportedCurvesSample() -> [Slip10Curve]  {
    return try!  FfiConverterSequenceTypeSLIP10Curve.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_supported_curves_sample($0
    )
})
}
public func newSupportedCurvesSampleOther() -> [Slip10Curve]  {
    return try!  FfiConverterSequenceTypeSLIP10Curve.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_supported_curves_sample_other($0
    )
})
}
public func newThirdPartyDepositsDefault() -> ThirdPartyDeposits  {
    return try!  FfiConverterTypeThirdPartyDeposits.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_third_party_deposits_default($0
    )
})
}
public func newThirdPartyDepositsSample() -> ThirdPartyDeposits  {
    return try!  FfiConverterTypeThirdPartyDeposits.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_third_party_deposits_sample($0
    )
})
}
public func newThirdPartyDepositsSampleOther() -> ThirdPartyDeposits  {
    return try!  FfiConverterTypeThirdPartyDeposits.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_third_party_deposits_sample_other($0
    )
})
}
public func newThresholdSample() -> Threshold  {
    return try!  FfiConverterTypeThreshold.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_threshold_sample($0
    )
})
}
public func newThresholdSampleOther() -> Threshold  {
    return try!  FfiConverterTypeThreshold.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_threshold_sample_other($0
    )
})
}
public func newTimePeriodSample() -> TimePeriod  {
    return try!  FfiConverterTypeTimePeriod.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_time_period_sample($0
    )
})
}
public func newTimePeriodSampleOther() -> TimePeriod  {
    return try!  FfiConverterTypeTimePeriod.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_time_period_sample_other($0
    )
})
}
public func newTimePeriodWithDays(value: UInt16) -> TimePeriod  {
    return try!  FfiConverterTypeTimePeriod.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_time_period_with_days(
        FfiConverterUInt16.lower(value),$0
    )
})
}
public func newTransactionHeaderSample() -> TransactionHeader  {
    return try!  FfiConverterTypeTransactionHeader.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_transaction_header_sample($0
    )
})
}
public func newTransactionHeaderSampleOther() -> TransactionHeader  {
    return try!  FfiConverterTypeTransactionHeader.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_transaction_header_sample_other($0
    )
})
}
public func newTransactionIntentHashFromString(string: String)throws  -> TransactionIntentHash  {
    return try  FfiConverterTypeTransactionIntentHash.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_transaction_intent_hash_from_string(
        FfiConverterString.lower(string),$0
    )
})
}
public func newTransactionIntentHashSample() -> TransactionIntentHash  {
    return try!  FfiConverterTypeTransactionIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_transaction_intent_hash_sample($0
    )
})
}
public func newTransactionIntentHashSampleOther() -> TransactionIntentHash  {
    return try!  FfiConverterTypeTransactionIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_transaction_intent_hash_sample_other($0
    )
})
}
public func newTransactionIntentSample() -> TransactionIntent  {
    return try!  FfiConverterTypeTransactionIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_transaction_intent_sample($0
    )
})
}
public func newTransactionIntentSampleOther() -> TransactionIntent  {
    return try!  FfiConverterTypeTransactionIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_transaction_intent_sample_other($0
    )
})
}
public func newTransactionManifestFromInstructionsStringAndBlobs(instructionsString: String, networkId: NetworkId, blobs: Blobs)throws  -> TransactionManifest  {
    return try  FfiConverterTypeTransactionManifest.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_transaction_manifest_from_instructions_string_and_blobs(
        FfiConverterString.lower(instructionsString),
        FfiConverterTypeNetworkID.lower(networkId),
        FfiConverterTypeBlobs.lower(blobs),$0
    )
})
}
public func newTransactionManifestFromUnvalidatedTransactionManifest(unvalidatedTransactionManifest: UnvalidatedTransactionManifest, networkId: NetworkId)throws  -> TransactionManifest  {
    return try  FfiConverterTypeTransactionManifest.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_transaction_manifest_from_unvalidated_transaction_manifest(
        FfiConverterTypeUnvalidatedTransactionManifest.lower(unvalidatedTransactionManifest),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func newTransactionManifestSample() -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_transaction_manifest_sample($0
    )
})
}
public func newTransactionManifestSampleOther() -> TransactionManifest  {
    return try!  FfiConverterTypeTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_transaction_manifest_sample_other($0
    )
})
}
public func newTransactionManifestV2Sample() -> TransactionManifestV2  {
    return try!  FfiConverterTypeTransactionManifestV2.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_transaction_manifest_v2_sample($0
    )
})
}
public func newTransactionManifestV2SampleOther() -> TransactionManifestV2  {
    return try!  FfiConverterTypeTransactionManifestV2.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_transaction_manifest_v2_sample_other($0
    )
})
}
public func newU30(value: UInt32)throws  -> U30  {
    return try  FfiConverterTypeU30.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_u30(
        FfiConverterUInt32.lower(value),$0
    )
})
}
public func newU30Sample() -> U30  {
    return try!  FfiConverterTypeU30.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_u30_sample($0
    )
})
}
public func newU30SampleOther() -> U30  {
    return try!  FfiConverterTypeU30.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_u30_sample_other($0
    )
})
}
public func newU31(value: UInt32)throws  -> U31  {
    return try  FfiConverterTypeU31.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_u31(
        FfiConverterUInt32.lower(value),$0
    )
})
}
public func newU31Sample() -> U31  {
    return try!  FfiConverterTypeU31.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_u31_sample($0
    )
})
}
public func newU31SampleOther() -> U31  {
    return try!  FfiConverterTypeU31.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_u31_sample_other($0
    )
})
}
public func newUnhardened(u31: U31) -> Unhardened  {
    return try!  FfiConverterTypeUnhardened.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unhardened(
        FfiConverterTypeU31.lower(u31),$0
    )
})
}
public func newUnhardenedFromGlobalKeySpace(value: UInt32)throws  -> Unhardened  {
    return try  FfiConverterTypeUnhardened.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_unhardened_from_global_key_space(
        FfiConverterUInt32.lower(value),$0
    )
})
}
public func newUnhardenedFromLocalKeySpace(value: UInt32)throws  -> Unhardened  {
    return try  FfiConverterTypeUnhardened.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_unhardened_from_local_key_space(
        FfiConverterUInt32.lower(value),$0
    )
})
}
public func newUnhardenedSample() -> Unhardened  {
    return try!  FfiConverterTypeUnhardened.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unhardened_sample($0
    )
})
}
public func newUnhardenedSampleOther() -> Unhardened  {
    return try!  FfiConverterTypeUnhardened.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unhardened_sample_other($0
    )
})
}
public func newUnsecuredEntityControlSample() -> UnsecuredEntityControl  {
    return try!  FfiConverterTypeUnsecuredEntityControl.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unsecured_entity_control_sample($0
    )
})
}
public func newUnsecuredEntityControlSampleOther() -> UnsecuredEntityControl  {
    return try!  FfiConverterTypeUnsecuredEntityControl.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unsecured_entity_control_sample_other($0
    )
})
}
public func newUnsecurifiedHardened(u30: U30) -> UnsecurifiedHardened  {
    return try!  FfiConverterTypeUnsecurifiedHardened.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened(
        FfiConverterTypeU30.lower(u30),$0
    )
})
}
public func newUnsecurifiedHardenedFromGlobalKeySpace(value: UInt32)throws  -> UnsecurifiedHardened  {
    return try  FfiConverterTypeUnsecurifiedHardened.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened_from_global_key_space(
        FfiConverterUInt32.lower(value),$0
    )
})
}
public func newUnsecurifiedHardenedFromLocalKeySpace(value: UInt32)throws  -> UnsecurifiedHardened  {
    return try  FfiConverterTypeUnsecurifiedHardened.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened_from_local_key_space(
        FfiConverterUInt32.lower(value),$0
    )
})
}
public func newUnsecurifiedHardenedSample() -> UnsecurifiedHardened  {
    return try!  FfiConverterTypeUnsecurifiedHardened.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened_sample($0
    )
})
}
public func newUnsecurifiedHardenedSampleOther() -> UnsecurifiedHardened  {
    return try!  FfiConverterTypeUnsecurifiedHardened.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened_sample_other($0
    )
})
}
public func newUnsecurifiedSample() -> Unsecurified  {
    return try!  FfiConverterTypeUnsecurified.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unsecurified_sample($0
    )
})
}
public func newUnsecurifiedSampleOther() -> Unsecurified  {
    return try!  FfiConverterTypeUnsecurified.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unsecurified_sample_other($0
    )
})
}
public func newUnvalidatedSubintentManifestFromSubintentManifest(subintentManifest: SubintentManifest) -> UnvalidatedSubintentManifest  {
    return try!  FfiConverterTypeUnvalidatedSubintentManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unvalidated_subintent_manifest_from_subintent_manifest(
        FfiConverterTypeSubintentManifest.lower(subintentManifest),$0
    )
})
}
public func newUnvalidatedSubintentManifestSample() -> UnvalidatedSubintentManifest  {
    return try!  FfiConverterTypeUnvalidatedSubintentManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unvalidated_subintent_manifest_sample($0
    )
})
}
public func newUnvalidatedSubintentManifestSampleOther() -> UnvalidatedSubintentManifest  {
    return try!  FfiConverterTypeUnvalidatedSubintentManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unvalidated_subintent_manifest_sample_other($0
    )
})
}
public func newUnvalidatedTransactionManifestFromTransactionManifest(transactionManifest: TransactionManifest) -> UnvalidatedTransactionManifest  {
    return try!  FfiConverterTypeUnvalidatedTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unvalidated_transaction_manifest_from_transaction_manifest(
        FfiConverterTypeTransactionManifest.lower(transactionManifest),$0
    )
})
}
public func newUnvalidatedTransactionManifestSample() -> UnvalidatedTransactionManifest  {
    return try!  FfiConverterTypeUnvalidatedTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unvalidated_transaction_manifest_sample($0
    )
})
}
public func newUnvalidatedTransactionManifestSampleOther() -> UnvalidatedTransactionManifest  {
    return try!  FfiConverterTypeUnvalidatedTransactionManifest.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_unvalidated_transaction_manifest_sample_other($0
    )
})
}
public func newValidatorAddress(bech32: String)throws  -> ValidatorAddress  {
    return try  FfiConverterTypeValidatorAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_validator_address(
        FfiConverterString.lower(bech32),$0
    )
})
}
/**
 * Returns a random address in `network_id` as Network
 */
public func newValidatorAddressRandom(networkId: NetworkId) -> ValidatorAddress  {
    return try!  FfiConverterTypeValidatorAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_validator_address_random(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func newValidatorAddressSampleMainnet() -> ValidatorAddress  {
    return try!  FfiConverterTypeValidatorAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_validator_address_sample_mainnet($0
    )
})
}
public func newValidatorAddressSampleMainnetOther() -> ValidatorAddress  {
    return try!  FfiConverterTypeValidatorAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_validator_address_sample_mainnet_other($0
    )
})
}
public func newValidatorAddressSampleStokenet() -> ValidatorAddress  {
    return try!  FfiConverterTypeValidatorAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_validator_address_sample_stokenet($0
    )
})
}
public func newValidatorAddressSampleStokenetOther() -> ValidatorAddress  {
    return try!  FfiConverterTypeValidatorAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_validator_address_sample_stokenet_other($0
    )
})
}
public func newVaultAddress(bech32: String)throws  -> VaultAddress  {
    return try  FfiConverterTypeVaultAddress.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_vault_address(
        FfiConverterString.lower(bech32),$0
    )
})
}
/**
 * Returns a random address in `network_id` as Network
 */
public func newVaultAddressRandom(networkId: NetworkId) -> VaultAddress  {
    return try!  FfiConverterTypeVaultAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_vault_address_random(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func newVaultAddressSampleMainnetFungible() -> VaultAddress  {
    return try!  FfiConverterTypeVaultAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_vault_address_sample_mainnet_fungible($0
    )
})
}
public func newVaultAddressSampleMainnetNonFungible() -> VaultAddress  {
    return try!  FfiConverterTypeVaultAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_vault_address_sample_mainnet_non_fungible($0
    )
})
}
public func newVaultAddressSampleStokenetFungible() -> VaultAddress  {
    return try!  FfiConverterTypeVaultAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_vault_address_sample_stokenet_fungible($0
    )
})
}
public func newVaultAddressSampleStokenetNonFungible() -> VaultAddress  {
    return try!  FfiConverterTypeVaultAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_vault_address_sample_stokenet_non_fungible($0
    )
})
}
public func newVecOfFactorSourceIdFromHashFromJson(jsonBytes: BagOfBytes)throws  -> [FactorSourceIdFromHash]  {
    return try  FfiConverterSequenceTypeFactorSourceIDFromHash.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_vec_of_factor_source_id_from_hash_from_json(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newVectorImageTypeSample() -> VectorImageType  {
    return try!  FfiConverterTypeVectorImageType.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_vector_image_type_sample($0
    )
})
}
public func newVectorImageTypeSampleOther() -> VectorImageType  {
    return try!  FfiConverterTypeVectorImageType.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_vector_image_type_sample_other($0
    )
})
}
public func newWalletInteractionVersionCurrent() -> WalletInteractionVersion  {
    return try!  FfiConverterTypeWalletInteractionVersion.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_wallet_interaction_version_current($0
    )
})
}
public func newWalletInteractionWalletAccountFromJsonBytes(jsonBytes: BagOfBytes)throws  -> WalletInteractionWalletAccount  {
    return try  FfiConverterTypeWalletInteractionWalletAccount.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_wallet_interaction_wallet_account_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newWalletInteractionWalletAccountSample() -> WalletInteractionWalletAccount  {
    return try!  FfiConverterTypeWalletInteractionWalletAccount.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_wallet_interaction_wallet_account_sample($0
    )
})
}
public func newWalletInteractionWalletAccountSampleOther() -> WalletInteractionWalletAccount  {
    return try!  FfiConverterTypeWalletInteractionWalletAccount.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_wallet_interaction_wallet_account_sample_other($0
    )
})
}
public func newWalletToDappInteractionAuthProofFromSignatureWithPublicKey(signatureWithPublicKey: SignatureWithPublicKey) -> WalletToDappInteractionAuthProof  {
    return try!  FfiConverterTypeWalletToDappInteractionAuthProof.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_auth_proof_from_signature_with_public_key(
        FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey),$0
    )
})
}
public func newWalletToDappInteractionPreAuthorizationResponseItems(signedSubintent: SignedSubintent) -> WalletToDappInteractionPreAuthorizationResponseItems  {
    return try!  FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_pre_authorization_response_items(
        FfiConverterTypeSignedSubintent.lower(signedSubintent),$0
    )
})
}
public func newWalletToDappInteractionProofOfOwnershipFromIntentSignatureOfOwner(intentSignatureOfOwner: IntentSignatureOfOwner) -> WalletToDappInteractionProofOfOwnership  {
    return try!  FfiConverterTypeWalletToDappInteractionProofOfOwnership.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_proof_of_ownership_from_intent_signature_of_owner(
        FfiConverterTypeIntentSignatureOfOwner.lower(intentSignatureOfOwner),$0
    )
})
}
public func newWalletToDappInteractionResponseFromJsonBytes(jsonBytes: BagOfBytes)throws  -> WalletToDappInteractionResponse  {
    return try  FfiConverterTypeWalletToDappInteractionResponse.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_response_from_json_bytes(
        FfiConverterTypeBagOfBytes.lower(jsonBytes),$0
    )
})
}
public func newWalletToDappInteractionResponseSample() -> WalletToDappInteractionResponse  {
    return try!  FfiConverterTypeWalletToDappInteractionResponse.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_response_sample($0
    )
})
}
public func newWalletToDappInteractionResponseSampleOther() -> WalletToDappInteractionResponse  {
    return try!  FfiConverterTypeWalletToDappInteractionResponse.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_response_sample_other($0
    )
})
}
public func nonFungibleGlobalIdFormatted(globalId: NonFungibleGlobalId, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_non_fungible_global_id_formatted(
        FfiConverterTypeNonFungibleGlobalId.lower(globalId),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
public func nonFungibleGlobalIdToString(globalId: NonFungibleGlobalId) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_non_fungible_global_id_to_string(
        FfiConverterTypeNonFungibleGlobalId.lower(globalId),$0
    )
})
}
public func nonFungibleLocalIdAsStr(id: NonFungibleLocalId) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_non_fungible_local_id_as_str(
        FfiConverterTypeNonFungibleLocalId.lower(id),$0
    )
})
}
public func nonFungibleLocalIdFormatted(id: NonFungibleLocalId, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_non_fungible_local_id_formatted(
        FfiConverterTypeNonFungibleLocalId.lower(id),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
public func nonFungibleLocalIdToUserFacingString(id: NonFungibleLocalId) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_non_fungible_local_id_to_user_facing_string(
        FfiConverterTypeNonFungibleLocalId.lower(id),$0
    )
})
}
/**
 * Returns the base address of this specialized address.
 */
public func nonFungibleResourceAddressAsResourceAddress(address: NonFungibleResourceAddress) -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_non_fungible_resource_address_as_resource_address(
        FfiConverterTypeNonFungibleResourceAddress.lower(address),$0
    )
})
}
/**
 * Returns the bech32 encoding of this address
 */
public func nonFungibleResourceAddressBech32Address(address: NonFungibleResourceAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_non_fungible_resource_address_bech32_address(
        FfiConverterTypeNonFungibleResourceAddress.lower(address),$0
    )
})
}
/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func nonFungibleResourceAddressMapToNetwork(address: NonFungibleResourceAddress, networkId: NetworkId) -> NonFungibleResourceAddress  {
    return try!  FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_non_fungible_resource_address_map_to_network(
        FfiConverterTypeNonFungibleResourceAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
/**
 * Returns the network id this address
 */
public func nonFungibleResourceAddressNetworkId(address: NonFungibleResourceAddress) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_non_fungible_resource_address_network_id(
        FfiConverterTypeNonFungibleResourceAddress.lower(address),$0
    )
})
}
public func nonFungibleResourceIndicatorGetIds(indicator: NonFungibleResourceIndicator) -> [NonFungibleLocalId]  {
    return try!  FfiConverterSequenceTypeNonFungibleLocalId.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_non_fungible_resource_indicator_get_ids(
        FfiConverterTypeNonFungibleResourceIndicator.lower(indicator),$0
    )
})
}
public func nonceGetValue(nonce: Nonce) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_nonce_get_value(
        FfiConverterTypeNonce.lower(nonce),$0
    )
})
}
public func notarizedTransactionCompile(notarizedTransaction: NotarizedTransaction) -> CompiledNotarizedIntent  {
    return try!  FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_notarized_transaction_compile(
        FfiConverterTypeNotarizedTransaction.lower(notarizedTransaction),$0
    )
})
}
public func notarySignatureGetSignature(notarySignature: NotarySignature) -> Signature  {
    return try!  FfiConverterTypeSignature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_notary_signature_get_signature(
        FfiConverterTypeNotarySignature.lower(notarySignature),$0
    )
})
}
public func p2PLinkToJsonBytes(p2PLink: P2pLink) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_p2_p_link_to_json_bytes(
        FfiConverterTypeP2PLink.lower(p2PLink),$0
    )
})
}
public func p2pLinkId(link: P2pLink) -> PublicKeyHash  {
    return try!  FfiConverterTypePublicKeyHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_p2p_link_id(
        FfiConverterTypeP2PLink.lower(link),$0
    )
})
}
public func p2pLinksToJsonBytes(p2pLinks: [P2pLink]) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_p2p_links_to_json_bytes(
        FfiConverterSequenceTypeP2PLink.lower(p2pLinks),$0
    )
})
}
public func packageAddressBech32Address(address: PackageAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_package_address_bech32_address(
        FfiConverterTypePackageAddress.lower(address),$0
    )
})
}
public func packageAddressFormatted(address: PackageAddress, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_package_address_formatted(
        FfiConverterTypePackageAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func packageAddressMapToNetwork(address: PackageAddress, networkId: NetworkId) -> PackageAddress  {
    return try!  FfiConverterTypePackageAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_package_address_map_to_network(
        FfiConverterTypePackageAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func packageAddressNetworkId(address: PackageAddress) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_package_address_network_id(
        FfiConverterTypePackageAddress.lower(address),$0
    )
})
}
public func personaDataEntryEmailAddressToJsonString(personaDataEntryEmailAddress: EmailAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_persona_data_entry_email_address_to_json_string(
        FfiConverterTypeEmailAddress.lower(personaDataEntryEmailAddress),$0
    )
})
}
public func personaDataEntryNameToJsonBytes(personaDataEntryName: PersonaDataEntryName) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_persona_data_entry_name_to_json_bytes(
        FfiConverterTypePersonaDataEntryName.lower(personaDataEntryName),$0
    )
})
}
public func personaDataEntryPhoneNumberToJsonString(personaDataEntryPhoneNumber: PersonaDataEntryPhoneNumber) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_persona_data_entry_phone_number_to_json_string(
        FfiConverterTypePersonaDataEntryPhoneNumber.lower(personaDataEntryPhoneNumber),$0
    )
})
}
public func personaDataIdentifiedEmailAddressSample() -> PersonaDataIdentifiedEmailAddress  {
    return try!  FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_persona_data_identified_email_address_sample($0
    )
})
}
public func personaDataIdentifiedEmailAddressSampleOther() -> PersonaDataIdentifiedEmailAddress  {
    return try!  FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_persona_data_identified_email_address_sample_other($0
    )
})
}
public func personaDataIdentifiedNameSample() -> PersonaDataIdentifiedName  {
    return try!  FfiConverterTypePersonaDataIdentifiedName.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_persona_data_identified_name_sample($0
    )
})
}
public func personaDataIdentifiedNameSampleOther() -> PersonaDataIdentifiedName  {
    return try!  FfiConverterTypePersonaDataIdentifiedName.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_persona_data_identified_name_sample_other($0
    )
})
}
public func personaDataIdentifiedPhoneNumberSample() -> PersonaDataIdentifiedPhoneNumber  {
    return try!  FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_persona_data_identified_phone_number_sample($0
    )
})
}
public func personaDataIdentifiedPhoneNumberSampleOther() -> PersonaDataIdentifiedPhoneNumber  {
    return try!  FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_persona_data_identified_phone_number_sample_other($0
    )
})
}
public func personaUnsecuredControllingFactorInstance(persona: Persona) -> HierarchicalDeterministicFactorInstance?  {
    return try!  FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_persona_unsecured_controlling_factor_instance(
        FfiConverterTypePersona.lower(persona),$0
    )
})
}
public func poolAddressBech32Address(address: PoolAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_pool_address_bech32_address(
        FfiConverterTypePoolAddress.lower(address),$0
    )
})
}
public func poolAddressFormatted(address: PoolAddress, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_pool_address_formatted(
        FfiConverterTypePoolAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
/**
 * Returns the kind of pool, either 1, 2 or Multi resources.
 */
public func poolAddressKind(address: PoolAddress) -> PoolKind  {
    return try!  FfiConverterTypePoolKind.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_pool_address_kind(
        FfiConverterTypePoolAddress.lower(address),$0
    )
})
}
/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func poolAddressMapToNetwork(address: PoolAddress, networkId: NetworkId) -> PoolAddress  {
    return try!  FfiConverterTypePoolAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_pool_address_map_to_network(
        FfiConverterTypePoolAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func poolAddressNetworkId(address: PoolAddress) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_pool_address_network_id(
        FfiConverterTypePoolAddress.lower(address),$0
    )
})
}
public func profileAnalyzeContentsOfFile(contents: String) -> ProfileFileContents  {
    return try!  FfiConverterTypeProfileFileContents.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_profile_analyze_contents_of_file(
        FfiConverterString.lower(contents),$0
    )
})
}
public func profileEncryptWithPassword(profile: Profile, encryptionPassword: String) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_profile_encrypt_with_password(
        FfiConverterTypeProfile.lower(profile),
        FfiConverterString.lower(encryptionPassword),$0
    )
})
}
public func profileNetworkDetailsForAuthorizedDapp(profileNetwork: ProfileNetwork, dapp: AuthorizedDapp)throws  -> AuthorizedDappDetailed  {
    return try  FfiConverterTypeAuthorizedDappDetailed.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_profile_network_details_for_authorized_dapp(
        FfiConverterTypeProfileNetwork.lower(profileNetwork),
        FfiConverterTypeAuthorizedDapp.lower(dapp),$0
    )
})
}
public func profileToDebugString(profile: Profile) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_profile_to_debug_string(
        FfiConverterTypeProfile.lower(profile),$0
    )
})
}
public func profileToJsonString(profile: Profile, prettyPrinted: Bool) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_profile_to_json_string(
        FfiConverterTypeProfile.lower(profile),
        FfiConverterBool.lower(prettyPrinted),$0
    )
})
}
public func profileToString(profile: Profile) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_profile_to_string(
        FfiConverterTypeProfile.lower(profile),$0
    )
})
}
/**
 * Verifies an Elliptic Curve signature over either Curve25519 or Secp256k1
 */
public func publicKeyIsValidSignatureForHash(publicKey: PublicKey, signature: Signature, hash: Hash) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_public_key_is_valid_signature_for_hash(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterTypeSignature.lower(signature),
        FfiConverterTypeHash.lower(hash),$0
    )
})
}
public func publicKeyToBytes(publicKey: PublicKey) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_public_key_to_bytes(
        FfiConverterTypePublicKey.lower(publicKey),$0
    )
})
}
public func publicKeyToHex(publicKey: PublicKey) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_public_key_to_hex(
        FfiConverterTypePublicKey.lower(publicKey),$0
    )
})
}
public func radixConnectMobileSessionRequestToJsonBytes(radixConnectMobileSessionRequest: RadixConnectMobileSessionRequest) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_radix_connect_mobile_session_request_to_json_bytes(
        FfiConverterTypeRadixConnectMobileSessionRequest.lower(radixConnectMobileSessionRequest),$0
    )
})
}
public func radixConnectPasswordMessageHash(password: RadixConnectPassword) -> Hash  {
    return try!  FfiConverterTypeHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_radix_connect_password_message_hash(
        FfiConverterTypeRadixConnectPassword.lower(password),$0
    )
})
}
public func radixConnectPasswordToJsonString(radixConnectPassword: RadixConnectPassword) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_radix_connect_password_to_json_string(
        FfiConverterTypeRadixConnectPassword.lower(radixConnectPassword),$0
    )
})
}
public func radixConnectPurposeToJsonString(radixConnectPurpose: RadixConnectPurpose) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_radix_connect_purpose_to_json_string(
        FfiConverterTypeRadixConnectPurpose.lower(radixConnectPurpose),$0
    )
})
}
/**
 * Checks `number_of_ids` can fulfill the [`RequestedQuantity`] (self), `number_of_ids` is
 * considered to be fulfilling the requested quantity:
 * * if: quantifier == ::Exactly && number_of_ids == quantity //  fulfills
 * * else if: quantifier == ::AtLeast && number_of_ids >= quantity //  fulfills
 * * else false //  does NOT fulfill
 */
public func requestedQuantityIsFulfilledByIds(requestedQuantity: RequestedQuantity, numberOfIds: UInt64) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_requested_quantity_is_fulfilled_by_ids(
        FfiConverterTypeRequestedQuantity.lower(requestedQuantity),
        FfiConverterUInt64.lower(numberOfIds),$0
    )
})
}
public func requestedQuantityIsValid(requestedQuantity: RequestedQuantity) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_requested_quantity_is_valid(
        FfiConverterTypeRequestedQuantity.lower(requestedQuantity),$0
    )
})
}
public func requestedQuantityToJsonBytes(requestedQuantity: RequestedQuantity) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_requested_quantity_to_json_bytes(
        FfiConverterTypeRequestedQuantity.lower(requestedQuantity),$0
    )
})
}
public func resourceAddressBech32Address(address: ResourceAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_resource_address_bech32_address(
        FfiConverterTypeResourceAddress.lower(address),$0
    )
})
}
public func resourceAddressFormatted(address: ResourceAddress, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_resource_address_formatted(
        FfiConverterTypeResourceAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
public func resourceAddressIsFungible(address: ResourceAddress) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_resource_address_is_fungible(
        FfiConverterTypeResourceAddress.lower(address),$0
    )
})
}
public func resourceAddressIsNonFungible(address: ResourceAddress) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_resource_address_is_non_fungible(
        FfiConverterTypeResourceAddress.lower(address),$0
    )
})
}
/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func resourceAddressMapToNetwork(address: ResourceAddress, networkId: NetworkId) -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_resource_address_map_to_network(
        FfiConverterTypeResourceAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func resourceAddressNetworkId(address: ResourceAddress) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_resource_address_network_id(
        FfiConverterTypeResourceAddress.lower(address),$0
    )
})
}
public func resourceIndicatorGetAddress(indicator: ResourceIndicator) -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_resource_indicator_get_address(
        FfiConverterTypeResourceIndicator.lower(indicator),$0
    )
})
}
public func resourcePreferencesGetHiddenResources(resourcePreferences: [ResourceAppPreference]) -> [ResourceIdentifier]  {
    return try!  FfiConverterSequenceTypeResourceIdentifier.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_resource_preferences_get_hidden_resources(
        FfiConverterSequenceTypeResourceAppPreference.lower(resourcePreferences),$0
    )
})
}
public func resourcePreferencesHideResource(resourcePreferences: [ResourceAppPreference], resource: ResourceIdentifier) -> [ResourceAppPreference]  {
    return try!  FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_resource_preferences_hide_resource(
        FfiConverterSequenceTypeResourceAppPreference.lower(resourcePreferences),
        FfiConverterTypeResourceIdentifier.lower(resource),$0
    )
})
}
public func resourcePreferencesUnhideResource(resourcePreferences: [ResourceAppPreference], resource: ResourceIdentifier) -> [ResourceAppPreference]  {
    return try!  FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_resource_preferences_unhide_resource(
        FfiConverterSequenceTypeResourceAppPreference.lower(resourcePreferences),
        FfiConverterTypeResourceIdentifier.lower(resource),$0
    )
})
}
public func resourceSpecifierGetAddress(specifier: ResourceSpecifier) -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_resource_specifier_get_address(
        FfiConverterTypeResourceSpecifier.lower(specifier),$0
    )
})
}
public func rnsDomainValidated(domain: RnsDomain)throws  -> RnsDomain  {
    return try  FfiConverterTypeRnsDomain.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_rns_domain_validated(
        FfiConverterTypeRnsDomain.lower(domain),$0
    )
})
}
/**
 * Returns every supported LogFilter
 */
public func rustLoggerGetAllFilters() -> [LogFilter]  {
    return try!  FfiConverterSequenceTypeLogFilter.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_rust_logger_get_all_filters($0
    )
})
}
/**
 * Returns every supported LogLevel
 */
public func rustLoggerGetAllLevels() -> [LogLevel]  {
    return try!  FfiConverterSequenceTypeLogLevel.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_rust_logger_get_all_levels($0
    )
})
}
public func rustLoggerGetLevel() -> LogFilter  {
    return try!  FfiConverterTypeLogFilter.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_rust_logger_get_level($0
    )
})
}
public func rustLoggerLogAtEveryLevel()  {try! rustCall() {
    uniffi_sargon_uniffi_fn_func_rust_logger_log_at_every_level($0
    )
}
}
public func rustLoggerSetLevel(level: LogFilter)  {try! rustCall() {
    uniffi_sargon_uniffi_fn_func_rust_logger_set_level(
        FfiConverterTypeLogFilter.lower(level),$0
    )
}
}
public func sLIP10CurveToJsonString(sLIP10Curve: Slip10Curve) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_s_l_i_p10_curve_to_json_string(
        FfiConverterTypeSLIP10Curve.lower(sLIP10Curve),$0
    )
})
}
/**
 * Returns the current and the other gateways of `gateways`.
 */
public func savedGatewaysGetAllElements(gateways: SavedGateways) -> [Gateway]  {
    return try!  FfiConverterSequenceTypeGateway.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_saved_gateways_get_all_elements(
        FfiConverterTypeSavedGateways.lower(gateways),$0
    )
})
}
/**
 * Returns the public key on **compressed** form (33 bytes)
 */
public func secp256k1PublicKeyToBytes(publicKey: Secp256k1PublicKey) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_secp256k1_public_key_to_bytes(
        FfiConverterTypeSecp256k1PublicKey.lower(publicKey),$0
    )
})
}
/**
 * Returns the public key on **uncompressed** form (65 bytes)
 */
public func secp256k1PublicKeyToBytesUncompressed(publicKey: Secp256k1PublicKey) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_secp256k1_public_key_to_bytes_uncompressed(
        FfiConverterTypeSecp256k1PublicKey.lower(publicKey),$0
    )
})
}
/**
 * Encodes the compressed form (33 bytes) of a `Secp256k1PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"033083620d1596d3f8988ff3270e42970dd2a031e2b9b6488052a4170ff999f3e8"`
 */
public func secp256k1PublicKeyToHex(publicKey: Secp256k1PublicKey) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_secp256k1_public_key_to_hex(
        FfiConverterTypeSecp256k1PublicKey.lower(publicKey),$0
    )
})
}
public func secp256k1SignatureToString(signature: Secp256k1Signature) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_secp256k1_signature_to_string(
        FfiConverterTypeSecp256k1Signature.lower(signature),$0
    )
})
}
public func secureStorageAccessErrorKindIsManualCancellation(kind: SecureStorageAccessErrorKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_secure_storage_access_error_kind_is_manual_cancellation(
        FfiConverterTypeSecureStorageAccessErrorKind.lower(kind),$0
    )
})
}
public func secureStorageAccessErrorKindToString(kind: SecureStorageAccessErrorKind) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_secure_storage_access_error_kind_to_string(
        FfiConverterTypeSecureStorageAccessErrorKind.lower(kind),$0
    )
})
}
public func secureStorageKeyIdentifier(key: SecureStorageKey) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_secure_storage_key_identifier(
        FfiConverterTypeSecureStorageKey.lower(key),$0
    )
})
}
public func securifiedIndexInGlobalKeySpace(securified: SecurifiedU30) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_securified_index_in_global_key_space(
        FfiConverterTypeSecurifiedU30.lower(securified),$0
    )
})
}
public func securifiedIndexInLocalKeySpace(securified: SecurifiedU30) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_securified_index_in_local_key_space(
        FfiConverterTypeSecurifiedU30.lower(securified),$0
    )
})
}
public func securityProblemId(value: SecurityProblem) -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_security_problem_id(
        FfiConverterTypeSecurityProblem.lower(value),$0
    )
})
}
public func securityProblemKind(value: SecurityProblem) -> SecurityProblemKind  {
    return try!  FfiConverterTypeSecurityProblemKind.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_security_problem_kind(
        FfiConverterTypeSecurityProblem.lower(value),$0
    )
})
}
public func securityStructureMetadataIsMain(securityStructureMetadata: SecurityStructureMetadata) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_security_structure_metadata_is_main(
        FfiConverterTypeSecurityStructureMetadata.lower(securityStructureMetadata),$0
    )
})
}
public func signatureToBytes(signature: Signature) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_signature_to_bytes(
        FfiConverterTypeSignature.lower(signature),$0
    )
})
}
public func signatureToString(signature: Signature) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_signature_to_string(
        FfiConverterTypeSignature.lower(signature),$0
    )
})
}
public func signatureWithPublicKeyGetPublicKey(signatureWithPublicKey: SignatureWithPublicKey) -> PublicKey  {
    return try!  FfiConverterTypePublicKey.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_signature_with_public_key_get_public_key(
        FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey),$0
    )
})
}
public func signatureWithPublicKeyGetSignature(signatureWithPublicKey: SignatureWithPublicKey) -> Signature  {
    return try!  FfiConverterTypeSignature.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_signature_with_public_key_get_signature(
        FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey),$0
    )
})
}
public func signatureWithPublicKeyIsValid(signatureWithPublicKey: SignatureWithPublicKey, forHash: Hash) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_signature_with_public_key_is_valid(
        FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey),
        FfiConverterTypeHash.lower(forHash),$0
    )
})
}
public func signedIntentHash(signedIntent: SignedIntent) -> SignedTransactionIntentHash  {
    return try!  FfiConverterTypeSignedTransactionIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_signed_intent_hash(
        FfiConverterTypeSignedIntent.lower(signedIntent),$0
    )
})
}
public func signedTransactionIntentHashFormatted(address: SignedTransactionIntentHash, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_signed_transaction_intent_hash_formatted(
        FfiConverterTypeSignedTransactionIntentHash.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
public func slip10CurveToString(curve: Slip10Curve) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_slip10_curve_to_string(
        FfiConverterTypeSLIP10Curve.lower(curve),$0
    )
})
}
public func subintentCompile(subintent: Subintent) -> CompiledSubintent  {
    return try!  FfiConverterTypeCompiledSubintent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_subintent_compile(
        FfiConverterTypeSubintent.lower(subintent),$0
    )
})
}
public func subintentHash(subintent: Subintent) -> SubintentHash  {
    return try!  FfiConverterTypeSubintentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_subintent_hash(
        FfiConverterTypeSubintent.lower(subintent),$0
    )
})
}
public func subintentHashFormatted(address: SubintentHash, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_subintent_hash_formatted(
        FfiConverterTypeSubintentHash.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
public func subintentManifestBlobs(manifest: SubintentManifest) -> Blobs  {
    return try!  FfiConverterTypeBlobs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_subintent_manifest_blobs(
        FfiConverterTypeSubintentManifest.lower(manifest),$0
    )
})
}
public func subintentManifestInvolvedPoolAddresses(manifest: SubintentManifest) -> [PoolAddress]  {
    return try!  FfiConverterSequenceTypePoolAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_subintent_manifest_involved_pool_addresses(
        FfiConverterTypeSubintentManifest.lower(manifest),$0
    )
})
}
public func subintentManifestInvolvedResourceAddresses(manifest: SubintentManifest) -> [ResourceAddress]  {
    return try!  FfiConverterSequenceTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_subintent_manifest_involved_resource_addresses(
        FfiConverterTypeSubintentManifest.lower(manifest),$0
    )
})
}
public func subintentManifestNetworkId(manifest: SubintentManifest) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_subintent_manifest_network_id(
        FfiConverterTypeSubintentManifest.lower(manifest),$0
    )
})
}
public func subintentManifestString(manifest: SubintentManifest) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_subintent_manifest_string(
        FfiConverterTypeSubintentManifest.lower(manifest),$0
    )
})
}
public func subintentManifestSummary(manifest: SubintentManifest) -> ManifestSummary  {
    return try!  FfiConverterTypeManifestSummary.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_subintent_manifest_summary(
        FfiConverterTypeSubintentManifest.lower(manifest),$0
    )
})
}
public func timePeriodToDays(timePeriod: TimePeriod) -> UInt16  {
    return try!  FfiConverterUInt16.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_time_period_to_days(
        FfiConverterTypeTimePeriod.lower(timePeriod),$0
    )
})
}
/**
 * The standard transaction fee
 */
public func transactionFeePreset() -> Decimal192  {
    return try!  FfiConverterTypeDecimal192.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_fee_preset($0
    )
})
}
public func transactionIntentCompile(intent: TransactionIntent) -> CompiledTransactionIntent  {
    return try!  FfiConverterTypeCompiledTransactionIntent.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_intent_compile(
        FfiConverterTypeTransactionIntent.lower(intent),$0
    )
})
}
public func transactionIntentHash(intent: TransactionIntent) -> TransactionIntentHash  {
    return try!  FfiConverterTypeTransactionIntentHash.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_intent_hash(
        FfiConverterTypeTransactionIntent.lower(intent),$0
    )
})
}
public func transactionIntentHashFormatted(address: TransactionIntentHash, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_intent_hash_formatted(
        FfiConverterTypeTransactionIntentHash.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
public func transactionManifestBlobs(manifest: TransactionManifest) -> Blobs  {
    return try!  FfiConverterTypeBlobs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_blobs(
        FfiConverterTypeTransactionManifest.lower(manifest),$0
    )
})
}
public func transactionManifestBlobsV2(manifest: TransactionManifestV2) -> Blobs  {
    return try!  FfiConverterTypeBlobs.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_blobs_v2(
        FfiConverterTypeTransactionManifestV2.lower(manifest),$0
    )
})
}
public func transactionManifestInstructionsString(manifest: TransactionManifest) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_instructions_string(
        FfiConverterTypeTransactionManifest.lower(manifest),$0
    )
})
}
public func transactionManifestInvolvedPoolAddresses(manifest: TransactionManifest) -> [PoolAddress]  {
    return try!  FfiConverterSequenceTypePoolAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_involved_pool_addresses(
        FfiConverterTypeTransactionManifest.lower(manifest),$0
    )
})
}
public func transactionManifestInvolvedPoolAddressesV2(manifest: TransactionManifestV2) -> [PoolAddress]  {
    return try!  FfiConverterSequenceTypePoolAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_involved_pool_addresses_v2(
        FfiConverterTypeTransactionManifestV2.lower(manifest),$0
    )
})
}
public func transactionManifestInvolvedResourceAddresses(manifest: TransactionManifest) -> [ResourceAddress]  {
    return try!  FfiConverterSequenceTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_involved_resource_addresses(
        FfiConverterTypeTransactionManifest.lower(manifest),$0
    )
})
}
public func transactionManifestInvolvedResourceAddressesV2(manifest: TransactionManifestV2) -> [ResourceAddress]  {
    return try!  FfiConverterSequenceTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_involved_resource_addresses_v2(
        FfiConverterTypeTransactionManifestV2.lower(manifest),$0
    )
})
}
public func transactionManifestNetworkId(manifest: TransactionManifest) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_network_id(
        FfiConverterTypeTransactionManifest.lower(manifest),$0
    )
})
}
public func transactionManifestNetworkIdV2(manifest: TransactionManifestV2) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_network_id_v2(
        FfiConverterTypeTransactionManifestV2.lower(manifest),$0
    )
})
}
public func transactionManifestString(manifest: TransactionManifest) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_string(
        FfiConverterTypeTransactionManifest.lower(manifest),$0
    )
})
}
public func transactionManifestStringV2(manifest: TransactionManifestV2) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_string_v2(
        FfiConverterTypeTransactionManifestV2.lower(manifest),$0
    )
})
}
public func transactionManifestSummary(manifest: TransactionManifest) -> ManifestSummary  {
    return try!  FfiConverterTypeManifestSummary.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_summary(
        FfiConverterTypeTransactionManifest.lower(manifest),$0
    )
})
}
public func transactionManifestSummaryV2(manifest: TransactionManifestV2)throws  -> ManifestSummary  {
    return try  FfiConverterTypeManifestSummary.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_transaction_manifest_summary_v2(
        FfiConverterTypeTransactionManifestV2.lower(manifest),$0
    )
})
}
public func transferRecipientAddress(recipient: TransferRecipient) -> AccountAddress  {
    return try!  FfiConverterTypeAccountAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_transfer_recipient_address(
        FfiConverterTypeTransferRecipient.lower(recipient),$0
    )
})
}
public func u30GetValue(u30: U30) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_u30_get_value(
        FfiConverterTypeU30.lower(u30),$0
    )
})
}
public func u31GetValue(u31: U31) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_u31_get_value(
        FfiConverterTypeU31.lower(u31),$0
    )
})
}
public func unhardenedIndexInGlobalKeySpace(unhardened: Unhardened) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_unhardened_index_in_global_key_space(
        FfiConverterTypeUnhardened.lower(unhardened),$0
    )
})
}
public func unhardenedIndexInLocalKeySpace(unhardened: Unhardened) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_unhardened_index_in_local_key_space(
        FfiConverterTypeUnhardened.lower(unhardened),$0
    )
})
}
public func unsafeStorageKeyIdentifier(key: UnsafeStorageKey) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_unsafe_storage_key_identifier(
        FfiConverterTypeUnsafeStorageKey.lower(key),$0
    )
})
}
public func unsecurifiedHardenedIndexInGlobalKeySpace(unsecurifiedHardened: UnsecurifiedHardened) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_unsecurified_hardened_index_in_global_key_space(
        FfiConverterTypeUnsecurifiedHardened.lower(unsecurifiedHardened),$0
    )
})
}
public func unsecurifiedHardenedIndexInLocalKeySpace(unsecurifiedHardened: UnsecurifiedHardened) -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_unsecurified_hardened_index_in_local_key_space(
        FfiConverterTypeUnsecurifiedHardened.lower(unsecurifiedHardened),$0
    )
})
}
public func validatorAddressBech32Address(address: ValidatorAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_validator_address_bech32_address(
        FfiConverterTypeValidatorAddress.lower(address),$0
    )
})
}
public func validatorAddressFormatted(address: ValidatorAddress, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_validator_address_formatted(
        FfiConverterTypeValidatorAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func validatorAddressMapToNetwork(address: ValidatorAddress, networkId: NetworkId) -> ValidatorAddress  {
    return try!  FfiConverterTypeValidatorAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_validator_address_map_to_network(
        FfiConverterTypeValidatorAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func validatorAddressNetworkId(address: ValidatorAddress) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_validator_address_network_id(
        FfiConverterTypeValidatorAddress.lower(address),$0
    )
})
}
public func vaultAddressBech32Address(address: VaultAddress) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_vault_address_bech32_address(
        FfiConverterTypeVaultAddress.lower(address),$0
    )
})
}
public func vaultAddressFormatted(address: VaultAddress, format: AddressFormat) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_vault_address_formatted(
        FfiConverterTypeVaultAddress.lower(address),
        FfiConverterTypeAddressFormat.lower(format),$0
    )
})
}
public func vaultAddressIsFungible(address: VaultAddress) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_vault_address_is_fungible(
        FfiConverterTypeVaultAddress.lower(address),$0
    )
})
}
public func vaultAddressIsNonFungible(address: VaultAddress) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_vault_address_is_non_fungible(
        FfiConverterTypeVaultAddress.lower(address),$0
    )
})
}
/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func vaultAddressMapToNetwork(address: VaultAddress, networkId: NetworkId) -> VaultAddress  {
    return try!  FfiConverterTypeVaultAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_vault_address_map_to_network(
        FfiConverterTypeVaultAddress.lower(address),
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}
public func vaultAddressNetworkId(address: VaultAddress) -> NetworkId  {
    return try!  FfiConverterTypeNetworkID.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_vault_address_network_id(
        FfiConverterTypeVaultAddress.lower(address),$0
    )
})
}
public func vecOfFactorSourceIdFromHashToJson(ids: [FactorSourceIdFromHash])throws  -> BagOfBytes  {
    return try  FfiConverterTypeBagOfBytes.lift(try rustCallWithError(FfiConverterTypeCommonError.lift) {
    uniffi_sargon_uniffi_fn_func_vec_of_factor_source_id_from_hash_to_json(
        FfiConverterSequenceTypeFactorSourceIDFromHash.lower(ids),$0
    )
})
}
public func vectorImageTypeDataUrlType(imageType: VectorImageType) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_vector_image_type_data_url_type(
        FfiConverterTypeVectorImageType.lower(imageType),$0
    )
})
}
public func vectorImageTypeUrlExtension(imageType: VectorImageType) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_vector_image_type_url_extension(
        FfiConverterTypeVectorImageType.lower(imageType),$0
    )
})
}
public func walletInteractionWalletAccountToJsonBytes(walletInteractionWalletAccount: WalletInteractionWalletAccount) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_wallet_interaction_wallet_account_to_json_bytes(
        FfiConverterTypeWalletInteractionWalletAccount.lower(walletInteractionWalletAccount),$0
    )
})
}
public func walletToDappInteractionResponseToJsonBytes(walletToDappInteractionResponse: WalletToDappInteractionResponse) -> BagOfBytes  {
    return try!  FfiConverterTypeBagOfBytes.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_wallet_to_dapp_interaction_response_to_json_bytes(
        FfiConverterTypeWalletToDappInteractionResponse.lower(walletToDappInteractionResponse),$0
    )
})
}
public func xrdAddressOfNetwork(networkId: NetworkId) -> ResourceAddress  {
    return try!  FfiConverterTypeResourceAddress.lift(try! rustCall() {
    uniffi_sargon_uniffi_fn_func_xrd_address_of_network(
        FfiConverterTypeNetworkID.lower(networkId),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_sargon_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_access_controller_address_bech32_address() != 16739) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_access_controller_address_formatted() != 5192) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_access_controller_address_map_to_network() != 7986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_access_controller_address_network_id() != 20657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_account_address_bech32_address() != 41480) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_account_address_formatted() != 36270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_account_address_is_legacy() != 9809) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_account_address_map_to_network() != 36939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_account_address_network_id() != 25986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_account_is_legacy() != 36588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_account_or_persona_get_id() != 53085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_account_unsecured_controlling_factor_instance() != 41190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_address_formatted() != 51517) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_address_map_to_network() != 36071) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_address_network_id() != 58584) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_formatted() != 44847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_map_to_network() != 5970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_network_id() != 33299) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_sample_values_all() != 42804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_to_string() != 54683) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_address_sample_values_all() != 26979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_address_to_string() != 39924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_android_notarize_hash_with_private_key_bytes() != 11907) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_android_secret_key_get_public_key_from_private_key_bytes() != 5694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_android_sign_hash_with_private_key_bytes() != 43322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_app_preferences_has_gateway_with_url() != 26937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_appearance_ids_all() != 47723) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_arculus_card_model_to_string() != 6670) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_auth_intent_get_hash() != 43440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_authorized_dapp_to_json_bytes() != 4956) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_b_i_p39_seed_to_bytes() != 31312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_bag_of_bytes_append_cafe() != 7653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_bag_of_bytes_append_deadbeef() != 18671) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_bag_of_bytes_prepend_cafe() != 12603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_bag_of_bytes_prepend_deadbeef() != 11612) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_bip32_constant_global_offset_hardened() != 56838) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_bip32_constant_global_offset_securified() != 26205) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_bip39_language_wordlist() != 53356) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_bip39_word_count_all() != 21883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_bip44_like_path_get_address_index() != 14802) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_bip44_like_path_to_string() != 64740) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_blob_to_bytes() != 2709) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_blob_to_string() != 56091) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_blobs_list_of_blobs() != 58647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_build_information() != 25206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_cap26_entity_kind_to_string() != 47972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_check_if_encrypted_profile_json_contains_legacy_p2p_links() != 56950) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_check_if_profile_json_contains_legacy_p2p_links() != 13443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_compiled_notarized_intent_get_bytes() != 35568) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_compiled_subintent_bytes() != 55048) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_compiled_subintent_decompile() != 22909) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_compiled_transaction_intent_bytes() != 5074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_compiled_transaction_intent_decompile() != 5413) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_component_address_bech32_address() != 19756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_component_address_formatted() != 14442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_component_address_is_global() != 49734) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_component_address_is_internal() != 48259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_component_address_map_to_network() != 27675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_component_address_network_id() != 51835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_constant_display_name_max_length() != 22299) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_constant_entity_name_max_length() != 19522) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_constant_max_recovery_confirmation_fallback_period_units() != 28180) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_constant_min_required_xrd_for_account_deletion() != 45958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_dapp_to_wallet_interaction_metadata_to_json_bytes() != 57190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_dapp_to_wallet_interaction_unvalidated_to_json_bytes() != 61820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_dapp_to_wallet_interaction_unvalidated_to_json_string() != 63502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_debug_print_compiled_notarized_intent() != 16677) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_abs() != 29764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_add() != 32856) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_clamped_to_zero() != 27082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_div() != 51913) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_formatted() != 34425) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_formatted_plain() != 59743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_greater_than() != 8443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_greater_than_or_equal() != 20591) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_is_negative() != 12023) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_is_positive() != 31461) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_is_zero() != 7222) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_less_than() != 3979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_less_than_or_equal() != 14807) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_max() != 18055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_min() != 41483) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_mul() != 7996) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_neg() != 25523) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_round() != 34421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_sub() != 16671) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_decimal_to_string() != 36217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_dependency_information_to_string() != 39562) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_deposit_rule_to_json_string() != 9778) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_derivation_path_to_bip32_string() != 1914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_derivation_path_to_hd_path() != 40437) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_derivation_path_to_string() != 62433) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_device_info_description_to_string() != 41352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_device_info_to_json_bytes() != 65074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_display_name_to_json_string() != 21695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_ed25519_public_key_to_bytes() != 32366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_ed25519_public_key_to_hex() != 56150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_ed25519_public_key_to_json_string() != 45791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_ed25519_signature_to_json_string() != 34112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_ed25519_signature_to_string() != 3491) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_entropy16_bytes_to_bytes() != 10147) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_entropy20_bytes_to_bytes() != 6787) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_entropy24_bytes_to_bytes() != 2461) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_entropy28_bytes_to_bytes() != 261) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_entropy32_bytes_to_bytes() != 52294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_error_code_from_error() != 29726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_error_message_from_error() != 21055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_event_kind() != 60428) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_event_kind_affects_current_accounts() != 42399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_event_kind_affects_current_network() != 33132) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_event_kind_affects_factor_sources() != 48330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_event_kind_affects_saved_gateways() != 55144) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_event_kind_affects_security_structures() != 29273) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_event_kind_all() != 41590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly12_bytes_to_json_string() != 53379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly29_bytes_to_json_string() != 40034) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly32_bytes_to_json_string() != 25695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly33_bytes_to_json_string() != 49844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly60_bytes_to_json_string() != 61148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly64_bytes_to_json_string() != 15251) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly65_bytes_to_json_string() != 35639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_12_bytes_to_bytes() != 1500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_12_bytes_to_hex() != 46640) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_29_bytes_to_bytes() != 43740) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_29_bytes_to_hex() != 11033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_32_bytes_to_bytes() != 30445) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_32_bytes_to_hex() != 21548) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_33_bytes_to_bytes() != 32587) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_33_bytes_to_hex() != 35227) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_60_bytes_to_bytes() != 21333) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_60_bytes_to_hex() != 34978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_64_bytes_to_bytes() != 41324) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_64_bytes_to_hex() != 4596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_65_bytes_to_bytes() != 38987) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_exactly_65_bytes_to_hex() != 59590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_crypto_parameters_supports_babylon() != 19739) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_crypto_parameters_supports_olympia() != 46978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_i_d_from_address_to_json_bytes() != 28180) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_i_d_from_hash_to_json_bytes() != 50855) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_i_d_to_json_bytes() != 47589) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_id_from_address_to_string() != 15403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_id_from_hash_perform_spot_check() != 48443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_id_from_hash_to_string() != 2950) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_id_perform_spot_check() != 41326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_id_to_string() != 26529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_kind_to_string() != 30143) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_name() != 15981) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_perform_spot_check() != 22594) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_supports_babylon() != 5064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_supports_olympia() != 44230) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_source_to_string() != 23127) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_factor_sources_all_sample_values() != 29519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_ffi_url_get_url() != 13501) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_fiat_currency_to_json_string() != 29262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_fungible_resource_indicator_get_amount() != 57502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_gateway_id() != 62787) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_gateway_is_wellknown() != 12190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_gateway_mainnet() != 50357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_gateway_stokenet() != 60555) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_gateway_to_string() != 45466) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_gateway_wellknown_gateways() != 24662) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_get_subintent_expiration_status() != 706) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_hash() != 40399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_hash_get_bytes() != 17430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_hd_path_component_get_key_space() != 16341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_hd_path_component_index_in_global_key_space() != 2568) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_hd_path_component_index_in_local_key_space() != 1876) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_hd_path_component_to_bip32_string() != 11237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_hd_path_component_to_bip32_string_debug() != 39488) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_hd_path_component_to_hardened() != 60319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_header_to_json_bytes() != 30120) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_hierarchical_deterministic_public_key_is_valid_signature_for_hash() != 44394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_host_id_to_json_bytes() != 46400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_host_os_get_name() != 65043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_host_os_get_vendor() != 52670) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_host_os_get_version() != 50713) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_identity_address_bech32_address() != 6747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_identity_address_formatted() != 57900) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_identity_address_map_to_network() != 21479) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_identity_address_network_id() != 22178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_image_url_utils_is_vector_image() != 7296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_image_url_utils_make_image_url() != 11016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_intent_discriminator_get_value() != 49816) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_intent_signature_get_signature_with_public_key() != 55591) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_is_safe_to_show_error_message_from_error() != 48490) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_key_agreement_public_key_to_bytes() != 27363) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_key_agreement_public_key_to_hex() != 57749) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_ledger_hw_wallet_model_to_string() != 6623) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_legacy_olympia_account_address_formatted() != 37355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_legacy_olympia_account_address_is_legacy_of_babylon() != 12089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_legacy_olympia_account_address_to_babylon_account_address() != 64098) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_legacy_olympia_account_address_to_string() != 586) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_link_connection_q_r_data_to_json_bytes() != 19222) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_locker_address_bech32_address() != 37513) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_locker_address_formatted() != 24320) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_locker_address_map_to_network() != 24957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_locker_address_network_id() != 17185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_account_locker_claim() != 51896) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_create_fungible_token() != 53492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_create_fungible_token_with_metadata() != 24893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_create_multiple_fungible_tokens() != 21380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_create_multiple_non_fungible_tokens() != 43838) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_create_non_fungible_token() != 3479) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_formatted() != 23567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_map_to_network() != 58015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_network_id() != 10681) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_sample_values_all() != 52471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_to_string() != 44296) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_for_faucet() != 39443) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_marking_account_as_dapp_definition_type() != 54702) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_per_asset_transfers() != 20320) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_per_recipient_transfers() != 29446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_set_owner_keys_hashes() != 19176) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_stakes_claim() != 28927) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_manifest_third_party_deposit_update() != 44888) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_message_as_plaintext() != 37029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_message_v2_as_plaintext() != 5171) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_mnemonic_phrase() != 26344) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_mnemonic_with_passphrase_derive_public_keys() != 51123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_mnemonic_with_passphrase_sign() != 60558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_mnemonic_with_passphrase_to_json_bytes() != 43384) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_mnemonic_with_passphrase_validate_public_keys() != 42595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_modify_manifest_add_guarantees() != 54480) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_modify_manifest_lock_fee() != 37364) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_network_id_discriminant() != 60399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_network_id_to_string() != 9901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_network_ids_all() != 12196) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_network_method_to_string() != 56251) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_access_controller_address() != 43372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_access_controller_address_random() != 53067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_access_controller_address_sample_mainnet() != 55321) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_access_controller_address_sample_mainnet_other() != 53259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_access_controller_address_sample_stokenet() != 62042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_access_controller_address_sample_stokenet_other() != 48145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_address() != 65018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_address_from() != 13571) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_address_random() != 62190) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_address_sample_mainnet() != 22922) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_address_sample_mainnet_other() != 53879) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_address_sample_stokenet() != 13145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_address_sample_stokenet_other() != 3741) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_for_display_from_account() != 54146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_for_display_sample() != 46449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_for_display_sample_other() != 25799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_locker_claimable_resource_sample() != 44473) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_locker_claimable_resource_sample_other() != 49877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_or_address_of_sample() != 20244) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_or_address_of_sample_other() != 16700) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_mainnet() != 20540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_mainnet_other() != 19137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_mainnet_third() != 55355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_stokenet() != 30858) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_stokenet_other() != 22043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_stokenet_third() != 61696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_path() != 60462) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_path_sample() != 54597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_path_sample_other() != 39697) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_sample_mainnet_alice() != 25345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_sample_mainnet_bob() != 29866) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_sample_mainnet_carol() != 42248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_sample_mainnet_diana() != 36079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_sample_stokenet_nadia() != 30043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_sample_stokenet_olivia() != 27591) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_account_sample_stokenet_paige() != 5383) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_accounts_for_display_sample() != 58677) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_accounts_for_display_sample_other() != 27502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_accounts_or_personas_sample() != 12183) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_accounts_or_personas_sample_other() != 58257) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_accounts_sample() != 56236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_accounts_sample_other() != 6814) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_address_from_bech32() != 21331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_from_bech32() != 21850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_sample_mainnet() != 33734) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_sample_mainnet_other() != 6476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_sample_stokenet() != 64912) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_sample_stokenet_other() != 51988) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_address_sample_mainnet() != 7887) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_address_sample_mainnet_other() != 61417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_address_sample_stokenet() != 19240) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_address_sample_stokenet_other() != 6756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_app_preferences_default() != 14693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_app_preferences_sample() != 54060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_app_preferences_sample_other() != 4957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_appearance_id() != 45858) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_appearance_id_from_number_of_accounts_on_network() != 17795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_appearance_id_sample() != 30621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_appearance_id_sample_other() != 52854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_arculus_card_factor_source_from_mnemonic_with_passphrase() != 63140) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_arculus_card_factor_source_sample() != 59637) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_arculus_card_factor_source_sample_other() != 30228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_asset_exception_sample() != 55301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_asset_exception_sample_other() != 55082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_assets_exception_list_sample() != 47074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_assets_exception_list_sample_other() != 39085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_auth_intent_from_request() != 4329) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_auth_intent_hash_sample() != 10479) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_auth_intent_hash_sample_other() != 56221) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_auth_intent_sample() != 29611) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_auth_intent_sample_other() != 10209) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_detailed_sample() != 38954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_detailed_sample_other() != 11486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_from_json_bytes() != 10178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_sample_mainnet_dashboard() != 54023) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_sample_mainnet_gumballclub() != 62709) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_sample_stokenet_devconsole() != 45066) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_sample_stokenet_sandbox() != 14923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_dapps_sample() != 40678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_dapps_sample_other() != 44743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_persona_detailed_sample() != 22358) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_persona_detailed_sample_other() != 16247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_persona_simple_sample_mainnet() != 5111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_persona_simple_sample_mainnet_other() != 4841) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_persona_simple_sample_stokenet() != 17795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_authorized_persona_simple_sample_stokenet_other() != 33729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_b_i_p39_seed_from_bytes() != 22381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_b_i_p39_seed_sample() != 61518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_b_i_p39_seed_sample_other() != 21682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_from() != 2776) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_aced() != 16822) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_babe() != 63067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_cafe() != 19146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_dead() != 30477) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_ecad() != 8414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_fade() != 25865) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bip39_language_sample() != 35094) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bip39_language_sample_other() != 12099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bip39_word_sample() != 36954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bip39_word_sample_other() != 21194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bip44_like_path_from_index() != 41704) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bip44_like_path_from_string() != 38941) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bip44_like_path_sample() != 62302) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_bip44_like_path_sample_other() != 53938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_blob_from_bytes() != 4046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_blobs_from_blob_list() != 47310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_blobs_sample() != 51393) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_blobs_sample_other() != 1358) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_compiled_notarized_intent_sample() != 351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_compiled_notarized_intent_sample_other() != 30738) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_compiled_subintent_sample() != 50175) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_compiled_subintent_sample_other() != 29258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_compiled_transaction_intent_sample() != 25544) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_compiled_transaction_intent_sample_other() != 35639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_component_address() != 6748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_component_address_random() != 166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_component_address_sample_mainnet_global() != 62491) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_component_address_sample_mainnet_internal() != 12637) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_component_address_sample_stokenet_global() != 18747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_component_address_sample_stokenet_internal() != 50419) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_confirmation_role_with_factor_instances_sample() != 44679) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_confirmation_role_with_factor_instances_sample_other() != 12712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_confirmation_role_with_factor_source_i_ds_sample() != 62876) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_confirmation_role_with_factor_source_i_ds_sample_other() != 28973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_confirmation_role_with_factor_sources_sample() != 8927) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_confirmation_role_with_factor_sources_sample_other() != 13979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_metadata_from_json_bytes() != 50550) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_metadata_sample() != 62982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_metadata_sample_other() != 7528) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_unvalidated_from_json_bytes() != 30691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_unvalidated_from_json_string() != 6002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_unvalidated_sample() != 7739) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_unvalidated_sample_other() != 25552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_decimal_exponent() != 12846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_decimal_from_f32() != 53578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_decimal_from_f64() != 53652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_decimal_from_formatted_string() != 42489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_decimal_from_i32() != 16943) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_decimal_from_i64() != 31040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_decimal_from_string() != 33537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_decimal_from_u32() != 19405) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_decimal_from_u64() != 36062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_dependency_information_sample() != 49066) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_dependency_information_sample_other() != 43626) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_deposit_rule_from_json_string() != 25423) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_deposit_rule_sample() != 8201) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_deposit_rule_sample_other() != 54410) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_depositors_allow_list_sample() != 8727) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_depositors_allow_list_sample_other() != 7481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_derivation_path_from_string() != 11067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_derivation_path_sample() != 60817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_derivation_path_sample_other() != 4393) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_detailed_authorized_personas_sample() != 46157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_detailed_authorized_personas_sample_other() != 58210) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_device_factor_source_babylon() != 38090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_device_factor_source_olympia() != 17238) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_device_factor_source_sample() != 7799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_device_factor_source_sample_other() != 21308) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_device_info_description_sample() != 45889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_device_info_description_sample_other() != 48984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_device_info_from_host_info() != 29629) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_device_info_from_json_bytes() != 20094) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_device_info_sample() != 39892) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_device_info_sample_other() != 57142) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_display_name() != 39164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_display_name_from_json_string() != 65092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_display_name_sample() != 29614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_display_name_sample_other() != 43371) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_from_bytes() != 14056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_from_hex() != 48187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_from_json_string() != 53635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_sample() != 8979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_sample_other() != 31532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_from_bytes() != 14357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_from_exactly_64_bytes() != 61100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_from_json_string() != 47403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_sample() != 35097) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_sample_other() != 29669) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_email_address_sample() != 52899) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_email_address_sample_other() != 53375) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entity_flag_sample() != 53250) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entity_flag_sample_other() != 46309) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entity_flags_sample() != 40234) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entity_flags_sample_other() != 6490) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entity_security_state_sample() != 1724) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entity_security_state_sample_other() != 54559) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy16_bytes_from_bytes() != 3405) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy16_bytes_sample() != 63418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy16_bytes_sample_other() != 10505) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy20_bytes_from_bytes() != 56880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy20_bytes_sample() != 15341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy20_bytes_sample_other() != 44987) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy24_bytes_from_bytes() != 13630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy24_bytes_sample() != 56974) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy24_bytes_sample_other() != 27016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy28_bytes_from_bytes() != 47298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy28_bytes_sample() != 22081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy28_bytes_sample_other() != 56854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy32_bytes_from_bytes() != 23680) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy32_bytes_sample() != 42841) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_entropy32_bytes_sample_other() != 48183) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly12_bytes_from_json_string() != 39752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly29_bytes_from_json_string() != 52829) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly32_bytes_from_json_string() != 24841) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly33_bytes_from_json_string() != 46155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly60_bytes_from_json_string() != 41288) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly64_bytes_from_json_string() != 62020) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly65_bytes_from_json_string() != 64582) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_12_bytes() != 53376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_12_bytes_sample() != 12822) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_12_bytes_sample_other() != 28820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_29_bytes() != 51192) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_29_bytes_sample() != 53557) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_29_bytes_sample_other() != 47703) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_32_bytes() != 64310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_32_bytes_sample() != 45472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_32_bytes_sample_other() != 18845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_33_bytes() != 52850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_33_bytes_sample() != 2208) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_33_bytes_sample_other() != 63205) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_60_bytes() != 6398) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_60_bytes_sample() != 9877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_60_bytes_sample_other() != 65036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_64_bytes() != 45996) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_64_bytes_sample() != 33155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_64_bytes_sample_other() != 39984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_65_bytes() != 61939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_65_bytes_sample() != 36105) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_exactly_65_bytes_sample_other() != 14805) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_common_babylon() != 60986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_common_bdfs() != 35421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_common_olympia() != 55674) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_common_sample() != 18551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_common_sample_other() != 15753) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_preset_babylon_olympia_compatible() != 46508) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_preset_babylon_only() != 34472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_preset_olympia_only() != 15990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_sample() != 7491) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_sample_other() != 4781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_i_d_from_address_from_json_bytes() != 28530) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_i_d_from_hash_from_json_bytes() != 30633) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_i_d_from_json_bytes() != 56035) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_address_sample() != 21401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_address_sample_other() != 31544) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_hash_from_mnemonic_with_passphrase() != 21191) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_hash_sample() != 11669) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_hash_sample_other() != 60302) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_id_sample() != 22280) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_id_sample_other() != 40497) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_kind_from_string() != 5930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_kind_sample() != 29958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_kind_sample_other() != 57561) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_sample() != 48469) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_source_sample_other() != 42128) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_sources_sample() != 54455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_factor_sources_sample_other() != 15671) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_failure_factor_outcome_of_auth_intent_hash() != 15327) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_failure_factor_outcome_of_subintent_hash() != 29500) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_failure_factor_outcome_of_transaction_intent_hash() != 38999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_fiat_currency_from_json_string() != 31917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_fiat_currency_sample() != 44623) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_fiat_currency_sample_other() != 47859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_fungible_resource_indicator_sample() != 32253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_fungible_resource_indicator_sample_other() != 1830) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_gateway_for_network_id() != 2039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_gateway_sample() != 65248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_gateway_sample_other() != 19812) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_gateway_with_url_on_network() != 34352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_gateways_sample() != 26136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_gateways_sample_other() != 14701) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hardened_sample() != 23609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hardened_sample_other() != 12456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hash_from_bytes() != 53909) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hash_from_string() != 29142) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hash_sample() != 14961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hash_sample_other() != 44845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hd_path_component_from_global_key_space() != 15222) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hd_path_component_from_local_key_space() != 37980) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hd_path_component_sample() != 35319) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hd_path_component_sample_other() != 21010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_header_from_json_bytes() != 60561) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_header_sample() != 26875) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_header_sample_other() != 21914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_header_with_creating_device() != 23900) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hidden_resources_sample() != 13060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hidden_resources_sample_other() != 27518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hierarchical_deterministic_factor_instance_sample() != 19729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hierarchical_deterministic_factor_instance_sample_other() != 59419) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hierarchical_deterministic_public_key_sample() != 17515) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_hierarchical_deterministic_public_key_sample_other() != 45174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_host_id_from_json_bytes() != 50705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_host_id_sample() != 14792) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_host_id_sample_other() != 15608) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_host_info_sample() != 55060) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_host_info_sample_other() != 32825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_host_os_android() != 64596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_host_os_ios() != 47748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_host_os_other() != 18747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_host_os_sample() != 43842) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_host_os_sample_other() != 49140) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_identity_address() != 37512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_identity_address_from() != 6311) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_identity_address_random() != 3026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_identity_address_sample_mainnet() != 10751) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_identity_address_sample_mainnet_other() != 52448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_identity_address_sample_stokenet() != 20666) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_identity_address_sample_stokenet_other() != 29131) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_identity_path() != 34862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_identity_path_sample() != 10679) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_identity_path_sample_other() != 9827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_intent_discriminator_from_u64() != 53541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_intent_discriminator_random() != 38983) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_intent_discriminator_sample() != 36765) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_intent_discriminator_sample_other() != 27108) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_intent_header_v2_sample() != 62553) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_intent_header_v2_sample_other() != 52012) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_intent_signature_from_signature_with_public_key() != 17724) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_intent_signature_sample() != 32994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_intent_signature_sample_other() != 32199) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_key_agreement_public_key_from_bytes() != 57828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_key_agreement_public_key_from_hex() != 26295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_key_agreement_public_key_sample() != 28131) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_key_agreement_public_key_sample_other() != 3360) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_key_space_sample() != 47298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_key_space_sample_other() != 16330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ledger_hardware_wallet_factor_source_sample() != 48515) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ledger_hardware_wallet_factor_source_sample_other() != 51985) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ledger_hardware_wallet_from_mnemonic_with_passphrase() != 44413) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ledger_hw_wallet_model_from_string() != 37370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ledger_hw_wallet_model_sample() != 17004) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_ledger_hw_wallet_model_sample_other() != 18014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_legacy_olympia_account_address_from_public_key() != 49238) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_legacy_olympia_account_address_from_string() != 51151) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_legacy_olympia_account_address_sample() != 51720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_legacy_olympia_account_address_sample_other() != 2909) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_link_connection_q_r_data_from_json_bytes() != 63075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_link_connection_qr_data_sample() != 390) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_link_connection_qr_data_sample_other() != 48462) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_locker_address() != 41694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_locker_address_random() != 47028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_locker_address_sample_mainnet() != 41128) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_locker_address_sample_mainnet_other() != 15582) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_locker_address_sample_stokenet() != 22220) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_locker_address_sample_stokenet_other() != 49931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_from_bech32() != 20959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_sample_mainnet() != 18081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_sample_mainnet_other() != 42631) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_sample_stokenet() != 16081) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_sample_stokenet_other() != 59943) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_matrix_of_factor_instances_sample() != 6613) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_matrix_of_factor_instances_sample_other() != 17962) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_matrix_of_factor_source_i_ds_sample() != 63671) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_matrix_of_factor_source_i_ds_sample_other() != 12905) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_matrix_of_factor_sources_sample() != 44278) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_matrix_of_factor_sources_sample_other() != 20016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_message_plaintext_sample() != 5016) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_message_plaintext_sample_other() != 22181) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_message_plaintext_string() != 61136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_message_v2_plaintext_sample() != 23768) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_message_v2_plaintext_sample_other() != 16) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_message_v2_plaintext_string() != 27580) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_from_phrase() != 56600) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_from_phrase_language() != 4694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_from_words() != 65034) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_generate_with_entropy() != 60360) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample() != 488) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_arculus() != 22101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_arculus_other() != 16183) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_device() != 9748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_device_12_words() != 400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_device_12_words_other() != 11940) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_device_other() != 18760) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_ledger() != 29417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_ledger_other() != 44988) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_off_device() != 58644) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_off_device_other() != 36452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_other() != 10990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_password() != 50279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_password_other() != 10212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_security_questions() != 29566) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_security_questions_other() != 40755) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_with_passphrase_from_json_bytes() != 33065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_with_passphrase_sample() != 13986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_mnemonic_with_passphrase_sample_other() != 44196) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_network_definition_lookup_by_name() != 20559) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_network_definition_sample() != 6748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_network_definition_sample_other() != 20321) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_network_id_from_discriminant() != 40833) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_network_method_sample() != 61115) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_network_method_sample_other() != 7620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_network_request_sample() != 44220) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_network_request_sample_other() != 35449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_empty_max_32_bytes() != 10326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_empty_max_64_bytes() != 6712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_global_id_from_string() != 8625) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_global_id_sample() != 14915) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_global_id_sample_other() != 31589) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_bytes() != 7239) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_from_string() != 17202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_int() != 24222) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_random() != 7654) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_ruid() != 28939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_sample() != 56159) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_sample_other() != 35518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_string() != 14957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_string_from_str() != 8847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address() != 8188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_random() != 56930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_sample_mainnet() != 1509) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_sample_mainnet_other() != 61508) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_sample_stokenet() != 32156) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_sample_stokenet_other() != 50028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_indicator_sample() != 20517) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_indicator_sample_other() != 15310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_nonce_from_u32() != 6600) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_nonce_random() != 3824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_nonce_sample() != 50716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_nonce_sample_other() != 11696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_notarized_transaction_sample() != 3580) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_notarized_transaction_sample_other() != 8227) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_notary_signature() != 8639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_notary_signature_sample() != 25191) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_notary_signature_sample_other() != 9617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_off_device_mnemonic_factor_source_from_mnemonic_with_passphrase() != 53315) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_off_device_mnemonic_factor_source_sample() != 7141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_off_device_mnemonic_factor_source_sample_other() != 60614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_on_ledger_settings_default() != 27043) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_on_ledger_settings_sample() != 61885) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_on_ledger_settings_sample_other() != 12898) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_p2_p_link_from_json_bytes() != 16669) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_p2_p_links_sample() != 37944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_p2_p_links_sample_other() != 23031) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_p2p_link_sample() != 51168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_p2p_link_sample_other() != 60728) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_p2p_links_from_json_bytes() != 5830) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_package_address() != 28930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_package_address_random() != 41825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_package_address_sample_mainnet() != 37012) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_package_address_sample_mainnet_other() != 13811) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_package_address_sample_stokenet() != 49912) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_package_address_sample_stokenet_other() != 2264) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_password_factor_source_from_mnemonic_with_passphrase() != 37893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_password_factor_source_sample() != 38800) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_password_factor_source_sample_other() != 45162) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_per_asset_transfers_sample() != 57477) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_per_asset_transfers_sample_other() != 54472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_email_address_from_json_string() != 17266) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_email_address_sample() != 16240) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_email_address_sample_other() != 31225) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_name_from_json_bytes() != 48047) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_name_sample() != 31330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_name_sample_other() != 45091) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_phone_number_from_json_string() != 63307) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_phone_number_sample() != 23998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_phone_number_sample_other() != 64155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_data_sample() != 15395) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_data_sample_other() != 17421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_sample() != 11862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_sample_mainnet_batman() != 60447) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_sample_mainnet_ripley() != 15174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_sample_mainnet_satoshi() != 57136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_sample_mainnet_turing() != 64235) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_sample_other() != 52731) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_sample_stokenet_connor() != 12681) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_sample_stokenet_hermione() != 43143) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_persona_sample_stokenet_leia_skywalker() != 32626) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_personas_sample() != 41264) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_personas_sample_other() != 59167) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_pool_address() != 37194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_pool_address_random() != 2609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_mainnet_multi() != 60014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_mainnet_single() != 56079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_mainnet_two() != 49886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_stokenet_multi() != 13647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_stokenet_single() != 22732) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_stokenet_two() != 26088) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_primary_role_with_factor_instances_sample() != 62932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_primary_role_with_factor_instances_sample_other() != 59507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_primary_role_with_factor_source_i_ds_sample() != 19953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_primary_role_with_factor_source_i_ds_sample_other() != 18652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_primary_role_with_factor_sources_sample() != 45123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_primary_role_with_factor_sources_sample_other() != 51185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_babylon() != 53596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_babylon_from_mnemonic_with_passphrase() != 37396) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_olympia_from_mnemonic_with_passphrase() != 18078) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_sample() != 32540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_sample_other() != 12390) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile() != 58363) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_file_contents_sample() != 61888) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_file_contents_sample_other() != 16774) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_from_encryption_bytes() != 50411) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_from_json_string() != 61261) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_id_sample() != 20711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_id_sample_other() != 44986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_network_sample() != 47064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_network_sample_other() != 25587) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_networks_sample() != 59335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_networks_sample_other() != 2779) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_sample() != 23215) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_sample_other() != 52859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_profile_with_mnemonic() != 25823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_public_key_from_bytes() != 13924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_public_key_from_hex() != 37374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_public_key_hash_of_key() != 59602) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_public_key_hash_sample() != 42850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_public_key_hash_sample_other() != 38629) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_public_key_sample() != 31874) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_public_key_sample_other() != 61084) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_radix_connect_mobile_session_request_from_json_bytes() != 572) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_radix_connect_mobile_session_request_sample() != 10993) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_radix_connect_mobile_session_request_sample_other() != 14869) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_radix_connect_password() != 20733) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_radix_connect_password_from_json_string() != 12504) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_radix_connect_password_sample() != 48289) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_radix_connect_password_sample_other() != 55376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_radix_connect_purpose_from_json_string() != 6704) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_radix_connect_purpose_from_string() != 53702) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_radix_connect_purpose_sample() != 40644) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_radix_connect_purpose_sample_other() != 6326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_recovery_role_with_factor_instances_sample() != 64759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_recovery_role_with_factor_instances_sample_other() != 31368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_recovery_role_with_factor_source_i_ds_sample() != 55820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_recovery_role_with_factor_source_i_ds_sample_other() != 3579) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_recovery_role_with_factor_sources_sample() != 54541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_recovery_role_with_factor_sources_sample_other() != 40836) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_references_to_authorized_personas_sample() != 64338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_references_to_authorized_personas_sample_other() != 58733) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_requested_quantity_from_json_bytes() != 63420) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_requested_quantity_sample() != 4279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_requested_quantity_sample_other() != 8374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_address() != 38401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_address_random() != 16846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_mainnet_candy() != 21546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_mainnet_nft_gc_membership() != 41107) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_mainnet_xrd() != 19705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_stokenet_candy() != 20717) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_stokenet_gc_tokens() != 62696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_stokenet_gum() != 7006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_stokenet_xrd() != 6601) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_indicator_sample() != 45770) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_indicator_sample_other() != 28357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_or_non_fungible_sample() != 62731) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_or_non_fungible_sample_other() != 60028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_preferences_sample() != 782) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_preferences_sample_other() != 39619) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_specifier_sample() != 58427) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_resource_specifier_sample_other() != 8185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_s_l_i_p10_curve_from_json_string() != 20445) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_1_1() != 27136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_1_2() != 7149) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_1_3() != 47555) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_1_4() != 36370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_1_5() != 45021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_2_1() != 57329) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_2_2() != 7142) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_2_3() != 6725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_2_4() != 11794) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_3_0() != 6804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_4_0() != 41940) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_5_1() != 9189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_5_2() != 29170) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_6_0() != 8906) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_7_0() != 42505) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_8_0() != 47613) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sample_config_9_0() != 2990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sargon_build_information_sample() != 41647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sargon_build_information_sample_other() != 25347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_saved_gateways() != 44618) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_saved_gateways_changing_current() != 3541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_saved_gateways_default() != 14470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_saved_gateways_sample() != 46435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_saved_gateways_sample_other() != 36343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_secp256k1_public_key_from_bytes() != 56517) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_secp256k1_public_key_from_hex() != 19768) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_secp256k1_public_key_sample() != 32902) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_secp256k1_public_key_sample_other() != 15984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_secp256k1_signature_from_bytes() != 14670) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_secp256k1_signature_from_exactly_65_bytes() != 49202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_secp256k1_signature_sample() != 25467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_secp256k1_signature_sample_other() != 17125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_secured_entity_control_sample() != 22581) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_secured_entity_control_sample_other() != 38923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_securified() != 35174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_securified_from_global_key_space() != 4183) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_securified_from_local_key_space() != 19115) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_securified_sample() != 29424) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_securified_sample_other() != 29224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_security_structure_metadata_named() != 59028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_security_structure_metadata_sample() != 45001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_security_structure_metadata_sample_other() != 16304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_instances_sample() != 55024) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_instances_sample_other() != 16171) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_source_ids_sample() != 15528) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_source_ids_sample_other() != 9760) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_sources_sample() != 11104) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_sources_sample_other() != 49794) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_security_structures_of_factor_source_i_ds_sample() != 8648) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_security_structures_of_factor_source_i_ds_sample_other() != 52262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_shared_persona_data_sample() != 52679) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_shared_persona_data_sample_other() != 27739) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_shield_for_display_sample() != 16881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_shield_for_display_sample_other() != 63362) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_shields_for_display_sample() != 26320) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_shields_for_display_sample_other() != 54165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sign_request_of_auth_intent_sample() != 64977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sign_request_of_auth_intent_sample_other() != 17055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sign_request_of_subintent_sample() != 49531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sign_request_of_subintent_sample_other() != 5992) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sign_request_of_transaction_intent_sample() != 15348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sign_request_of_transaction_intent_sample_other() != 22569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sign_response_of_auth_intent_hash_from_outcomes() != 33224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sign_response_of_auth_intent_hash_from_skipping_factors() != 3867) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sign_response_of_subintent_hash_from_outcomes() != 17418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sign_response_of_subintent_hash_from_skipping_factors() != 33476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sign_response_of_transaction_intent_hash_from_outcomes() != 36642) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_sign_response_of_transaction_intent_hash_from_skipping_factors() != 15527) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signature_from_bytes() != 61714) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signature_sample() != 41998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signature_sample_other() != 19832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signature_with_public_key_sample() != 50602) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signature_with_public_key_sample_other() != 24400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signed_auth_intent_sample() != 56537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signed_auth_intent_sample_other() != 33402) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signed_factor_outcome_of_auth_intent_hash() != 7449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signed_factor_outcome_of_subintent_hash() != 40096) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signed_factor_outcome_of_transaction_intent_hash() != 54675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signed_intent_hash_sample() != 33808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signed_intent_hash_sample_other() != 11367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signed_intent_sample() != 52370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signed_intent_sample_other() != 19689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_signed_transaction_intent_hash_from_string() != 52650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_skipped_factor_outcome_of_auth_intent_hash() != 45583) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_skipped_factor_outcome_of_subintent_hash() != 36352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_skipped_factor_outcome_of_transaction_intent_hash() != 18543) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_slip10_curve_from_string() != 17182) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_stake_claim_sample() != 50908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_stake_claim_sample_other() != 20345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_subintent() != 21688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_subintent_hash_from_string() != 27930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_subintent_hash_sample() != 20745) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_subintent_hash_sample_other() != 42752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_subintent_manifest_sample() != 40795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_subintent_manifest_sample_other() != 21745) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_subintent_sample() != 41412) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_subintent_sample_other() != 56550) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_supported_curves_sample() != 27270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_supported_curves_sample_other() != 38978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_third_party_deposits_default() != 64655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_third_party_deposits_sample() != 43880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_third_party_deposits_sample_other() != 8564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_threshold_sample() != 59367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_threshold_sample_other() != 10815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_time_period_sample() != 31728) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_time_period_sample_other() != 16449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_time_period_with_days() != 29192) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_header_sample() != 8723) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_header_sample_other() != 30841) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_intent_hash_from_string() != 22744) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_intent_hash_sample() != 57397) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_intent_hash_sample_other() != 46815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_intent_sample() != 10516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_intent_sample_other() != 3301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_from_instructions_string_and_blobs() != 47709) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_from_unvalidated_transaction_manifest() != 17099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_sample() != 45718) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_sample_other() != 25709) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_v2_sample() != 55947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_v2_sample_other() != 20151) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_u30() != 20628) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_u30_sample() != 63676) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_u30_sample_other() != 28749) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_u31() != 39523) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_u31_sample() != 46555) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_u31_sample_other() != 18620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unhardened() != 42441) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unhardened_from_global_key_space() != 17468) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unhardened_from_local_key_space() != 50711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unhardened_sample() != 4452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unhardened_sample_other() != 27835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unsecured_entity_control_sample() != 42906) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unsecured_entity_control_sample_other() != 44199) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened() != 9613) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened_from_global_key_space() != 34523) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened_from_local_key_space() != 30021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened_sample() != 22376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened_sample_other() != 47742) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unsecurified_sample() != 15554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unsecurified_sample_other() != 42044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unvalidated_subintent_manifest_from_subintent_manifest() != 11045) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unvalidated_subintent_manifest_sample() != 19014) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unvalidated_subintent_manifest_sample_other() != 53324) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unvalidated_transaction_manifest_from_transaction_manifest() != 60621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unvalidated_transaction_manifest_sample() != 3220) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_unvalidated_transaction_manifest_sample_other() != 19780) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_validator_address() != 7330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_validator_address_random() != 17013) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_validator_address_sample_mainnet() != 1396) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_validator_address_sample_mainnet_other() != 60189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_validator_address_sample_stokenet() != 6182) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_validator_address_sample_stokenet_other() != 59150) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_vault_address() != 46722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_vault_address_random() != 5168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_vault_address_sample_mainnet_fungible() != 59977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_vault_address_sample_mainnet_non_fungible() != 3625) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_vault_address_sample_stokenet_fungible() != 35213) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_vault_address_sample_stokenet_non_fungible() != 40105) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_vec_of_factor_source_id_from_hash_from_json() != 35879) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_vector_image_type_sample() != 35643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_vector_image_type_sample_other() != 15343) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_wallet_interaction_version_current() != 1306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_wallet_interaction_wallet_account_from_json_bytes() != 8284) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_wallet_interaction_wallet_account_sample() != 28027) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_wallet_interaction_wallet_account_sample_other() != 51107) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_auth_proof_from_signature_with_public_key() != 54001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_pre_authorization_response_items() != 17346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_proof_of_ownership_from_intent_signature_of_owner() != 755) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_response_from_json_bytes() != 18042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_response_sample() != 43665) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_response_sample_other() != 7044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_non_fungible_global_id_formatted() != 44995) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_non_fungible_global_id_to_string() != 65080) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_non_fungible_local_id_as_str() != 50881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_non_fungible_local_id_formatted() != 4044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_non_fungible_local_id_to_user_facing_string() != 11431) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_non_fungible_resource_address_as_resource_address() != 12948) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_non_fungible_resource_address_bech32_address() != 2811) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_non_fungible_resource_address_map_to_network() != 21266) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_non_fungible_resource_address_network_id() != 64552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_non_fungible_resource_indicator_get_ids() != 31374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_nonce_get_value() != 20204) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_notarized_transaction_compile() != 55244) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_notary_signature_get_signature() != 60673) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_p2_p_link_to_json_bytes() != 41559) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_p2p_link_id() != 17801) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_p2p_links_to_json_bytes() != 51949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_package_address_bech32_address() != 48492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_package_address_formatted() != 56063) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_package_address_map_to_network() != 54791) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_package_address_network_id() != 60577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_persona_data_entry_email_address_to_json_string() != 24703) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_persona_data_entry_name_to_json_bytes() != 805) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_persona_data_entry_phone_number_to_json_string() != 38100) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_persona_data_identified_email_address_sample() != 27809) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_persona_data_identified_email_address_sample_other() != 10133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_persona_data_identified_name_sample() != 41542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_persona_data_identified_name_sample_other() != 34961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_persona_data_identified_phone_number_sample() != 42681) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_persona_data_identified_phone_number_sample_other() != 35376) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_persona_unsecured_controlling_factor_instance() != 12710) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_pool_address_bech32_address() != 21761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_pool_address_formatted() != 34929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_pool_address_kind() != 51942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_pool_address_map_to_network() != 48099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_pool_address_network_id() != 15737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_profile_analyze_contents_of_file() != 20322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_profile_encrypt_with_password() != 56521) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_profile_network_details_for_authorized_dapp() != 61437) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_profile_to_debug_string() != 61571) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_profile_to_json_string() != 5512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_profile_to_string() != 33764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_public_key_is_valid_signature_for_hash() != 41618) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_public_key_to_bytes() != 19143) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_public_key_to_hex() != 1275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_radix_connect_mobile_session_request_to_json_bytes() != 26170) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_radix_connect_password_message_hash() != 9189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_radix_connect_password_to_json_string() != 43380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_radix_connect_purpose_to_json_string() != 38744) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_requested_quantity_is_fulfilled_by_ids() != 17442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_requested_quantity_is_valid() != 38263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_requested_quantity_to_json_bytes() != 42575) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_resource_address_bech32_address() != 38422) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_resource_address_formatted() != 46367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_resource_address_is_fungible() != 43471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_resource_address_is_non_fungible() != 12360) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_resource_address_map_to_network() != 45971) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_resource_address_network_id() != 50531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_resource_indicator_get_address() != 46615) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_resource_preferences_get_hidden_resources() != 50458) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_resource_preferences_hide_resource() != 58708) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_resource_preferences_unhide_resource() != 26953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_resource_specifier_get_address() != 40064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_rns_domain_validated() != 54953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_rust_logger_get_all_filters() != 59506) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_rust_logger_get_all_levels() != 43258) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_rust_logger_get_level() != 10949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_rust_logger_log_at_every_level() != 22900) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_rust_logger_set_level() != 59954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_s_l_i_p10_curve_to_json_string() != 1233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_saved_gateways_get_all_elements() != 41603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_secp256k1_public_key_to_bytes() != 2554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_secp256k1_public_key_to_bytes_uncompressed() != 53526) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_secp256k1_public_key_to_hex() != 38671) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_secp256k1_signature_to_string() != 25123) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_secure_storage_access_error_kind_is_manual_cancellation() != 13245) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_secure_storage_access_error_kind_to_string() != 16079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_secure_storage_key_identifier() != 23785) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_securified_index_in_global_key_space() != 28299) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_securified_index_in_local_key_space() != 30746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_security_problem_id() != 24325) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_security_problem_kind() != 35955) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_security_structure_metadata_is_main() != 25976) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_signature_to_bytes() != 49339) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_signature_to_string() != 22537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_signature_with_public_key_get_public_key() != 61540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_signature_with_public_key_get_signature() != 9548) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_signature_with_public_key_is_valid() != 107) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_signed_intent_hash() != 57483) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_signed_transaction_intent_hash_formatted() != 46686) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_slip10_curve_to_string() != 16528) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_subintent_compile() != 36589) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_subintent_hash() != 30194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_subintent_hash_formatted() != 8825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_subintent_manifest_blobs() != 54689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_subintent_manifest_involved_pool_addresses() != 17290) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_subintent_manifest_involved_resource_addresses() != 4954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_subintent_manifest_network_id() != 60401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_subintent_manifest_string() != 25812) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_subintent_manifest_summary() != 62264) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_time_period_to_days() != 40744) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_fee_preset() != 28642) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_intent_compile() != 55102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_intent_hash() != 16628) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_intent_hash_formatted() != 35303) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_blobs() != 28370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_blobs_v2() != 40013) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_instructions_string() != 59187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_involved_pool_addresses() != 8119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_involved_pool_addresses_v2() != 10052) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_involved_resource_addresses() != 33205) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_involved_resource_addresses_v2() != 44106) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_network_id() != 55152) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_network_id_v2() != 22658) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_string() != 62178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_string_v2() != 20762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_summary() != 11082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transaction_manifest_summary_v2() != 46195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_transfer_recipient_address() != 42394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_u30_get_value() != 3367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_u31_get_value() != 47596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_unhardened_index_in_global_key_space() != 4106) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_unhardened_index_in_local_key_space() != 2650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_unsafe_storage_key_identifier() != 18953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_unsecurified_hardened_index_in_global_key_space() != 33739) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_unsecurified_hardened_index_in_local_key_space() != 42716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_validator_address_bech32_address() != 3797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_validator_address_formatted() != 45882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_validator_address_map_to_network() != 18403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_validator_address_network_id() != 28726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_vault_address_bech32_address() != 3749) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_vault_address_formatted() != 13985) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_vault_address_is_fungible() != 5264) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_vault_address_is_non_fungible() != 49838) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_vault_address_map_to_network() != 13880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_vault_address_network_id() != 60554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_vec_of_factor_source_id_from_hash_to_json() != 8556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_vector_image_type_data_url_type() != 50668) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_vector_image_type_url_extension() != 62035) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_wallet_interaction_wallet_account_to_json_bytes() != 29015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_wallet_to_dapp_interaction_response_to_json_bytes() != 1762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_func_xrd_address_of_network() != 54555) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_wallet_init() != 11885) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_wallet_free() != 25527) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_select_wallet_request() != 46618) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_select_wallet_response() != 57577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_create_wallet_seed_request() != 14108) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_create_wallet_seed_response() != 19593) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_seed_phrase_from_mnemonic_sentence() != 24408) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_init_recover_wallet_request() != 23438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_init_recover_wallet_response() != 23471) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_finish_recover_wallet_request() != 39717) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_finish_recover_wallet_response() != 27824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_reset_wallet_request() != 37653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_reset_wallet_response() != 52028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_get_gguid_request() != 2952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_get_gguid_response() != 9757) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_get_firmware_version_request() != 6830) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_get_firmware_version_response() != 12136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_store_data_pin_request() != 34643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_store_data_pin_response() != 24055) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_verify_pin_request() != 42026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_verify_pin_response() != 20211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_init_encrypted_session_request() != 9853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_init_encrypted_session_response() != 26588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_get_public_key_by_path_request() != 6266) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_get_public_key_by_path_response() != 35563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_sign_hash_path_request() != 10031) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_arculuscsdkdriver_sign_hash_path_response() != 64298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_blogpostsclient_get_blog_posts() != 49413) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_entropyproviderdriver_generate_secure_random_bytes() != 51230) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_eventbusdriver_handle_event_notification() != 37374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_filesystemdriver_writable_app_dir_path() != 57918) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_filesystemdriver_load_from_file() != 11291) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_filesystemdriver_save_to_file() != 18612) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_filesystemdriver_delete_file() != 25840) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_homecardsmanager_bootstrap() != 47142) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_homecardsmanager_card_dismissed() != 31707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_homecardsmanager_deferred_deep_link_received() != 22766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_homecardsmanager_wallet_created() != 15111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_homecardsmanager_wallet_reset() != 17223) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_homecardsmanager_wallet_restored() != 49189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_homecardsobserver_handle_cards_update() != 48356) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_homecardsstorage_save_cards() != 64998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_homecardsstorage_load_cards() != 44873) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_homecardsstorage_save_dismissed_cards() != 38122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_homecardsstorage_load_dismissed_cards() != 39131) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_hostinfodriver_host_os() != 34576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_hostinfodriver_host_device_name() != 1219) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_hostinfodriver_host_app_version() != 51009) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_hostinfodriver_host_device_model() != 4852) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_hostinteractor_sign_transactions() != 23359) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_hostinteractor_sign_subintents() != 56973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_hostinteractor_derive_keys() != 60195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_hostinteractor_sign_auth() != 47368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_hostinteractor_request_authorization() != 3148) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_hostinteractor_spot_check() != 32089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_loggingdriver_log() != 28387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_mnemonicbuilder_create_mnemonic_from_words() != 21418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_mnemonicbuilder_generate_new_mnemonic() != 14379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_mnemonicbuilder_get_factor_source_id() != 64647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_mnemonicbuilder_get_indices_in_mnemonic_of_words_to_confirm() != 53970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_mnemonicbuilder_get_mnemonic_with_passphrase() != 27348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_mnemonicbuilder_get_words() != 33418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_mnemonicbuilder_validate_words() != 22458) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_nfctagdriver_start_session() != 20647) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_nfctagdriver_end_session() != 1028) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_nfctagdriver_send_receive() != 6883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_nfctagdriver_send_receive_command_chain() != 53755) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_nfctagdriver_set_progress() != 36526) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_networkingdriver_execute_network_request() != 8345) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_profilestatechangedriver_handle_profile_state_change() != 36142) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_radixconnectmobile_handle_deep_link() != 23213) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_radixconnectmobile_send_dapp_interaction_response() != 58808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_radixconnectmobilesessionstorage_save_session() != 63828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_radixconnectmobilesessionstorage_load_session() != 30386) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_radixnameservice_resolve_receiver_account_for_domain() != 4692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos___debug_factor_instances_in_cache() != 37483) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_add_account() != 33935) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_add_accounts() != 9567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_add_factor_source() != 9597) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_add_factor_sources() != 28512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_add_new_mnemonic_factor_source() != 28860) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_add_security_structure_of_factor_source_ids() != 60321) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_analyse_pre_auth_preview() != 17171) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_analyse_transaction_preview() != 50307) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_append_crypto_parameters_to_factor_source() != 38699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_apply_security_shield_with_id_to_entities() != 52605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_arculus_card_configure_with_mnemonic() != 39161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_arculus_card_derive_public_keys() != 17002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_arculus_card_reset() != 33820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_arculus_card_restore_pin() != 29879) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_arculus_card_sign_auth() != 9750) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_arculus_card_sign_subintent() != 12714) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_arculus_card_sign_transaction() != 48894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_arculus_card_validate_min_firmware_version() != 61121) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_change_current_gateway() != 14313) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_check_accounts_deleted_on_ledger() != 10981) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_check_security_problems() != 63317) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_claim_profile() != 2102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_create_and_save_new_account_with_factor_source() != 18384) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_create_and_save_new_persona_with_factor_source() != 13133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_create_delete_account_manifest() != 35129) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_create_device_factor_source() != 5029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_create_subintent() != 23952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_current_gateway() != 45208) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_current_network() != 40067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_current_network_id() != 22921) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_debug_add_all_sample_factors() != 44243) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_delete_wallet() != 60762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_derive_public_keys() != 5512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_entities_linked_to_factor_source() != 3655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_entities_linked_to_security_structure() != 59283) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_factor_source_integrity() != 52194) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_factor_sources() != 27882) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_gateways() != 28077) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_get_shields_for_display() != 22347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_has_any_account_on_any_network() != 7423) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_has_any_network() != 24883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_host_id() != 43722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_import_profile() != 20464) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_import_wallet() != 47395) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_is_factor_source_already_in_use() != 55580) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_load_private_device_factor_source_by_id() != 39798) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_make_interaction_for_applying_security_shield() != 45086) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_mark_account_as_hidden() != 1751) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_mark_account_as_tombstoned() != 45283) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_mark_entities_as_securified() != 25227) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_new_wallet() != 13860) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_new_wallet_with_derived_bdfs() != 32247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_poll_pre_authorization_status() != 9304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_poll_transaction_status() != 29304) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_profile() != 35851) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_rename_security_structure() != 37963) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_resolve_host_info() != 61481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_security_shield_prerequisites_status() != 27312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_security_structure_of_factor_source_ids_by_security_structure_id() != 51109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_security_structure_of_factor_sources_from_security_structure_of_factor_source_ids() != 60940) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_security_structures_of_factor_source_ids() != 9607) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_security_structures_of_factor_sources() != 63952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_set_card_pin() != 33022) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_set_main_security_structure() != 22367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_set_profile() != 55953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_sign_auth_accounts() != 8822) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_sign_auth_persona() != 27523) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_sign_subintent() != 54509) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_sign_transaction() != 18554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_submit_transaction() != 2200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_sync_accounts_deleted_on_ledger() != 59978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_trigger_spot_check() != 28146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_update_account() != 47089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_update_factor_source() != 2367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_update_factor_source_name() != 49252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_update_security_structure_of_factor_source_ids() != 25733) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_verify_card_pin() != 48969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_sargonos_wip_sync_entities_state_on_ledger() != 45373) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securestoragedriver_load_data() != 39397) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securestoragedriver_save_data() != 9973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securestoragedriver_delete_data_for_key() != 20787) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securestoragedriver_contains_data_for_key() != 41267) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_add_factor_source_to_confirmation_override() != 21485) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_add_factor_source_to_primary_override() != 34472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_add_factor_source_to_primary_threshold() != 64633) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_add_factor_source_to_recovery_override() != 51453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_confirmation_is_fully_valid() != 45912) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_confirmation_is_valid_or_can_be() != 43339) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_primary_override_is_fully_valid() != 38547) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_primary_override_is_valid_or_can_be() != 17523) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_primary_threshold_is_fully_valid() != 34981) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_primary_threshold_is_valid_or_can_be() != 42340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_recovery_is_fully_valid() != 41763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_addition_of_factor_source_of_kind_to_recovery_is_valid_or_can_be() != 58743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_allowed_factor_source_kinds_for_authentication_signing() != 49845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_auto_assign_factors_to_recovery_and_confirmation_based_on_primary() != 41053) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_build() != 13569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_disallowed_factor_source_kinds_for_authentication_signing() != 25660) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_get_authentication_signing_factor() != 64215) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_get_confirmation_factors() != 30541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_get_name() != 43257) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_get_primary_override_factors() != 34052) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_get_primary_threshold() != 16928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_get_primary_threshold_factors() != 19620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_get_primary_threshold_values() != 10944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_get_recovery_factors() != 53541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_get_time_until_timed_confirmation_is_callable() != 10638) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_is_allowed_factor_source_kind_for_authentication_signing() != 3041) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_remove_all_factors_from_primary_override() != 12261) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_remove_factor_from_all_roles() != 1613) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_remove_factor_from_confirmation() != 56693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_remove_factor_from_primary() != 58447) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_remove_factor_from_recovery() != 4549) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_reset_recovery_and_confirmation_role_state() != 1359) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_selected_primary_threshold_factors_status() != 43793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_set_authentication_signing_factor() != 20564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_set_name() != 19341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_set_threshold() != 47199) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_set_time_until_delayed_confirmation_is_callable() != 15474) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_sorted_factor_sources_for_primary_threshold_selection() != 38091) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_status() != 40048) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_validate_role_in_isolation() != 50793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_validation_for_addition_of_factor_source_to_confirmation_override_for_each() != 43988) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_validation_for_addition_of_factor_source_to_primary_override_for_each() != 53) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_validation_for_addition_of_factor_source_to_primary_threshold_for_each() != 26126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_securityshieldbuilder_validation_for_addition_of_factor_source_to_recovery_override_for_each() != 31151) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_unsafestoragedriver_load_data() != 30438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_unsafestoragedriver_save_data() != 2167) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_method_unsafestoragedriver_delete_data_for_key() != 25005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_constructor_bios_new() != 55108) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_constructor_blogpostsclient_new() != 14391) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_constructor_drivers_new() != 16991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_constructor_ffiurl_new() != 15814) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_constructor_homecardsmanager_new() != 28682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_constructor_mnemonicbuilder_new() != 5477) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_constructor_radixconnectmobile_new() != 51477) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_constructor_radixnameservice_new() != 15745) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_constructor_sargonos_boot() != 6911) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_constructor_securityshieldbuilder_new() != 55293) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_sargon_uniffi_checksum_constructor_securityshieldbuilder_with_security_structure_of_factor_source_ids() != 30338) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitArculusCSDKDriver()
    uniffiCallbackInitEntropyProviderDriver()
    uniffiCallbackInitEventBusDriver()
    uniffiCallbackInitFileSystemDriver()
    uniffiCallbackInitHomeCardsObserver()
    uniffiCallbackInitHomeCardsStorage()
    uniffiCallbackInitHostInfoDriver()
    uniffiCallbackInitHostInteractor()
    uniffiCallbackInitLoggingDriver()
    uniffiCallbackInitNFCTagDriver()
    uniffiCallbackInitNetworkingDriver()
    uniffiCallbackInitProfileStateChangeDriver()
    uniffiCallbackInitRadixConnectMobileSessionStorage()
    uniffiCallbackInitSecureStorageDriver()
    uniffiCallbackInitUnsafeStorageDriver()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all