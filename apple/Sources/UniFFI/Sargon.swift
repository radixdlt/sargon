// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(SargonFFI)
    import SargonFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len: 0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_sargon_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_sargon_uniffi_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_UNEXPECTED_ERROR:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void
) {
    do {
        try writeReturn(makeCall())
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void,
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

    func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        map.count
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt8: FfiConverterPrimitive {
    typealias FfiType = Int8
    typealias SwiftType = Int8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

private struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

private struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return try Data(readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

public protocol BiosProtocol: AnyObject {}

open class Bios:
    BiosProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_bios(self.pointer, $0) }
    }

    public convenience init(drivers: Drivers) {
        let pointer =
            try! rustCall {
                uniffi_sargon_uniffi_fn_constructor_bios_new(
                    FfiConverterTypeDrivers.lower(drivers), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_bios(pointer, $0) }
    }
}

public struct FfiConverterTypeBios: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Bios

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Bios {
        return Bios(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Bios) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bios {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Bios, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeBios_lift(_ pointer: UnsafeMutableRawPointer) throws -> Bios {
    return try FfiConverterTypeBios.lift(pointer)
}

public func FfiConverterTypeBios_lower(_ value: Bios) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBios.lower(value)
}

public protocol DriversProtocol: AnyObject {}

open class Drivers:
    DriversProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_drivers(self.pointer, $0) }
    }

    public convenience init(networking: NetworkingDriver, secureStorage: SecureStorageDriver, entropyProvider: EntropyProviderDriver, hostInfo: HostInfoDriver, logging: LoggingDriver, eventBus: EventBusDriver, fileSystem: FileSystemDriver, unsafeStorage: UnsafeStorageDriver, profileStateChangeDriver: ProfileStateChangeDriver) {
        let pointer =
            try! rustCall {
                uniffi_sargon_uniffi_fn_constructor_drivers_new(
                    FfiConverterTypeNetworkingDriver.lower(networking),
                    FfiConverterTypeSecureStorageDriver.lower(secureStorage),
                    FfiConverterTypeEntropyProviderDriver.lower(entropyProvider),
                    FfiConverterTypeHostInfoDriver.lower(hostInfo),
                    FfiConverterTypeLoggingDriver.lower(logging),
                    FfiConverterTypeEventBusDriver.lower(eventBus),
                    FfiConverterTypeFileSystemDriver.lower(fileSystem),
                    FfiConverterTypeUnsafeStorageDriver.lower(unsafeStorage),
                    FfiConverterTypeProfileStateChangeDriver.lower(profileStateChangeDriver), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_drivers(pointer, $0) }
    }
}

public struct FfiConverterTypeDrivers: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Drivers

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Drivers {
        return Drivers(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Drivers) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Drivers {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Drivers, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeDrivers_lift(_ pointer: UnsafeMutableRawPointer) throws -> Drivers {
    return try FfiConverterTypeDrivers.lift(pointer)
}

public func FfiConverterTypeDrivers_lower(_ value: Drivers) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDrivers.lower(value)
}

public protocol EntropyProviderDriver: AnyObject {
    func generateSecureRandomBytes() -> Entropy32Bytes
}

open class EntropyProviderDriverImpl:
    EntropyProviderDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_entropyproviderdriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_entropyproviderdriver(pointer, $0) }
    }

    open func generateSecureRandomBytes() -> Entropy32Bytes {
        return try! FfiConverterTypeEntropy32Bytes.lift(try! rustCall {
            uniffi_sargon_uniffi_fn_method_entropyproviderdriver_generate_secure_random_bytes(self.uniffiClonePointer(), $0)
        })
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceEntropyProviderDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceEntropyProviderDriver = .init(
        generateSecureRandomBytes: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Entropy32Bytes in
                guard let uniffiObj = try? FfiConverterTypeEntropyProviderDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.generateSecureRandomBytes(
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeEntropy32Bytes.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeEntropyProviderDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EntropyProviderDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitEntropyProviderDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_entropyproviderdriver(&UniffiCallbackInterfaceEntropyProviderDriver.vtable)
}

public struct FfiConverterTypeEntropyProviderDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<EntropyProviderDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EntropyProviderDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EntropyProviderDriver {
        return EntropyProviderDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EntropyProviderDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntropyProviderDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EntropyProviderDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeEntropyProviderDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> EntropyProviderDriver {
    return try FfiConverterTypeEntropyProviderDriver.lift(pointer)
}

public func FfiConverterTypeEntropyProviderDriver_lower(_ value: EntropyProviderDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEntropyProviderDriver.lower(value)
}

/**
 * A driver which received and asynchronously *handles* event notifications
 * emitted by the `SargonOS`. Letting the method be async allows for Rust side
 * to wait for host clients to complete something which might require user
 * attention. E.g. presentation of an alert and await user input.
 *
 * Due to limitations in UniFFI and lack of first class citizen support of
 * async sequences (like we have in Swift) we cannot export an accessor of the
 * received events here. Instead implementing types on the FFI side SHOULD
 * create the driver as a singleton object they can reference later and build
 * async streams in that implementing type.
 *
 * See Swifts EventBus implementation for more details.
 */
public protocol EventBusDriver: AnyObject {
    /**
     * Asynchronously *handles* event notifications
     * emitted by the `SargonOS`. Letting the method be async allows for Rust side
     * to wait for host clients to complete something which might require user
     * attention. E.g. presentation of an alert and await user input.
     */
    func handleEventNotification(eventNotification: EventNotification) async
}

/**
 * A driver which received and asynchronously *handles* event notifications
 * emitted by the `SargonOS`. Letting the method be async allows for Rust side
 * to wait for host clients to complete something which might require user
 * attention. E.g. presentation of an alert and await user input.
 *
 * Due to limitations in UniFFI and lack of first class citizen support of
 * async sequences (like we have in Swift) we cannot export an accessor of the
 * received events here. Instead implementing types on the FFI side SHOULD
 * create the driver as a singleton object they can reference later and build
 * async streams in that implementing type.
 *
 * See Swifts EventBus implementation for more details.
 */
open class EventBusDriverImpl:
    EventBusDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_eventbusdriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_eventbusdriver(pointer, $0) }
    }

    /**
     * Asynchronously *handles* event notifications
     * emitted by the `SargonOS`. Letting the method be async allows for Rust side
     * to wait for host clients to complete something which might require user
     * attention. E.g. presentation of an alert and await user input.
     */
    open func handleEventNotification(eventNotification: EventNotification) async {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_eventbusdriver_handle_event_notification(
                        self.uniffiClonePointer(),
                        FfiConverterTypeEventNotification.lower(eventNotification)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: nil
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceEventBusDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceEventBusDriver = .init(
        handleEventNotification: { (
            uniffiHandle: UInt64,
            eventNotification: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeEventBusDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.handleEventNotification(
                    eventNotification: FfiConverterTypeEventNotification.lift(eventNotification)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeEventBusDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EventBusDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitEventBusDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_eventbusdriver(&UniffiCallbackInterfaceEventBusDriver.vtable)
}

public struct FfiConverterTypeEventBusDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<EventBusDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventBusDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBusDriver {
        return EventBusDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventBusDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventBusDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventBusDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeEventBusDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBusDriver {
    return try FfiConverterTypeEventBusDriver.lift(pointer)
}

public func FfiConverterTypeEventBusDriver_lower(_ value: EventBusDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventBusDriver.lower(value)
}

/**
 * A wrapper around `Url` that allows us to safely deal with Urls generated on hosts.
 *
 * Context: We have defined a custom type conversion between Rust's `Url` and the hosts analogues.
 * However, a Url could be considered valid on host but not on Rust. For example, Swift allows to build a Url
 * from string `"invalid input"`, while Rust doesn't.
 *
 * Therefore, if a given Rust function expects a `Url` as param and is sent one from host side which is invalid,
 * the code will panic. However, if we send the wrapper instead, we make sure the conversion is safely done on the
 * host side, dealing with the failing conversion properly rather than panicking.
 */
public protocol FfiUrlProtocol: AnyObject {}

/**
 * A wrapper around `Url` that allows us to safely deal with Urls generated on hosts.
 *
 * Context: We have defined a custom type conversion between Rust's `Url` and the hosts analogues.
 * However, a Url could be considered valid on host but not on Rust. For example, Swift allows to build a Url
 * from string `"invalid input"`, while Rust doesn't.
 *
 * Therefore, if a given Rust function expects a `Url` as param and is sent one from host side which is invalid,
 * the code will panic. However, if we send the wrapper instead, we make sure the conversion is safely done on the
 * host side, dealing with the failing conversion properly rather than panicking.
 */
open class FfiUrl:
    CustomDebugStringConvertible,
    CustomStringConvertible,
    Equatable,
    Hashable,
    FfiUrlProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_ffiurl(self.pointer, $0) }
    }

    public convenience init(urlPath: String) throws {
        let pointer =
            try rustCallWithError(FfiConverterTypeCommonError.lift) {
                uniffi_sargon_uniffi_fn_constructor_ffiurl_new(
                    FfiConverterString.lower(urlPath), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_ffiurl(pointer, $0) }
    }

    open var debugDescription: String {
        return try! FfiConverterString.lift(
            try! rustCall {
                uniffi_sargon_uniffi_fn_method_ffiurl_uniffi_trait_debug(self.uniffiClonePointer(), $0)
            }
        )
    }

    open var description: String {
        return try! FfiConverterString.lift(
            try! rustCall {
                uniffi_sargon_uniffi_fn_method_ffiurl_uniffi_trait_display(self.uniffiClonePointer(), $0)
            }
        )
    }

    public static func == (self: FfiUrl, other: FfiUrl) -> Bool {
        return try! FfiConverterBool.lift(
            try! rustCall {
                uniffi_sargon_uniffi_fn_method_ffiurl_uniffi_trait_eq_eq(self.uniffiClonePointer(),
                                                                         FfiConverterTypeFfiUrl.lower(other), $0)
            }
        )
    }

    open func hash(into hasher: inout Hasher) {
        let val = try! FfiConverterUInt64.lift(
            try! rustCall {
                uniffi_sargon_uniffi_fn_method_ffiurl_uniffi_trait_hash(self.uniffiClonePointer(), $0)
            }
        )
        hasher.combine(val)
    }
}

public struct FfiConverterTypeFfiUrl: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiUrl

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUrl {
        return FfiUrl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiUrl) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiUrl {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiUrl, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFfiUrl_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiUrl {
    return try FfiConverterTypeFfiUrl.lift(pointer)
}

public func FfiConverterTypeFfiUrl_lower(_ value: FfiUrl) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiUrl.lower(value)
}

public protocol FileSystemDriver: AnyObject {
    func writableAppDirPath() async throws -> String

    func loadFromFile(path: String) async throws -> BagOfBytes?

    func saveToFile(path: String, data: BagOfBytes, isAllowedToOverwrite: Bool) async throws

    func deleteFile(path: String) async throws
}

open class FileSystemDriverImpl:
    FileSystemDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_filesystemdriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_filesystemdriver(pointer, $0) }
    }

    open func writableAppDirPath() async throws -> String {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_filesystemdriver_writable_app_dir_path(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterString.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func loadFromFile(path: String) async throws -> BagOfBytes? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_filesystemdriver_load_from_file(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(path)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func saveToFile(path: String, data: BagOfBytes, isAllowedToOverwrite: Bool) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_filesystemdriver_save_to_file(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(path), FfiConverterTypeBagOfBytes.lower(data), FfiConverterBool.lower(isAllowedToOverwrite)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func deleteFile(path: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_filesystemdriver_delete_file(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(path)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceFileSystemDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceFileSystemDriver = .init(
        writableAppDirPath: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.writableAppDirPath(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        loadFromFile: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadFromFile(
                    path: FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        saveToFile: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            data: RustBuffer,
            isAllowedToOverwrite: Int8,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveToFile(
                    path: FfiConverterString.lift(path),
                    data: FfiConverterTypeBagOfBytes.lift(data),
                    isAllowedToOverwrite: FfiConverterBool.lift(isAllowedToOverwrite)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteFile: { (
            uniffiHandle: UInt64,
            path: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeFileSystemDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteFile(
                    path: FfiConverterString.lift(path)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeFileSystemDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FileSystemDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitFileSystemDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_filesystemdriver(&UniffiCallbackInterfaceFileSystemDriver.vtable)
}

public struct FfiConverterTypeFileSystemDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<FileSystemDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FileSystemDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FileSystemDriver {
        return FileSystemDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FileSystemDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileSystemDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FileSystemDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeFileSystemDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> FileSystemDriver {
    return try FfiConverterTypeFileSystemDriver.lift(pointer)
}

public func FfiConverterTypeFileSystemDriver_lower(_ value: FileSystemDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFileSystemDriver.lower(value)
}

/**
 * Manages the home cards by handling storage, parsing, and updating operations.
 * Call `bootstrap` before invoking any other public functions.
 */
public protocol HomeCardsManagerProtocol: AnyObject {
    /**
     * Initializes `HomeCards` by loading from storage.
     * This function should be called before invoking any other public functions.
     * Notifies `HomeCardsObserver`.
     */
    func bootstrap() async throws

    /**
     * Dismisses a specified `HomeCard` by removing it from `HomeCardsStorage`.
     * Notifies `HomeCardsObserver`.
     */
    func cardDismissed(card: HomeCard) async throws

    /**
     * Handles a deferred deep link by parsing it and saving the generated `HomeCards` to `HomeCardsStorage`.
     * `HomeCard::ContinueRadQuest` if found in the link parsing result, replaces `HomeCard::StartRadQuest`.
     * Notifies `HomeCardsObserver`.
     */
    func deferredDeepLinkReceived(encodedValue: String) async throws

    /**
     * Initializes and saves to storage default `HomeCards`.
     * Marks the wallet creation and populates the set of cards required for a new wallet.
     * Notifies `HomeCardsObserver`.
     */
    func walletCreated() async throws

    /**
     * Clears the home cards from the `HomeCardsStorage`.
     * Notifies `HomeCardsObserver`.
     */
    func walletReset() async throws

    /**
     * Marks the wallet restoration.
     * Ensures only the expected `HomeCards` remain in `HomeCardsStorage` - currently none.
     * Notifies `HomeCardsObserver`.
     */
    func walletRestored() async throws
}

/**
 * Manages the home cards by handling storage, parsing, and updating operations.
 * Call `bootstrap` before invoking any other public functions.
 */
open class HomeCardsManager:
    HomeCardsManagerProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_homecardsmanager(self.pointer, $0) }
    }

    public convenience init(networkingDriver: NetworkingDriver, networkId: NetworkId, cardsStorage: HomeCardsStorage, observer: HomeCardsObserver) {
        let pointer =
            try! rustCall {
                uniffi_sargon_uniffi_fn_constructor_homecardsmanager_new(
                    FfiConverterTypeNetworkingDriver.lower(networkingDriver),
                    FfiConverterTypeNetworkID.lower(networkId),
                    FfiConverterTypeHomeCardsStorage.lower(cardsStorage),
                    FfiConverterTypeHomeCardsObserver.lower(observer), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_homecardsmanager(pointer, $0) }
    }

    /**
     * Initializes `HomeCards` by loading from storage.
     * This function should be called before invoking any other public functions.
     * Notifies `HomeCardsObserver`.
     */
    open func bootstrap() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_homecardsmanager_bootstrap(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Dismisses a specified `HomeCard` by removing it from `HomeCardsStorage`.
     * Notifies `HomeCardsObserver`.
     */
    open func cardDismissed(card: HomeCard) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_homecardsmanager_card_dismissed(
                        self.uniffiClonePointer(),
                        FfiConverterTypeHomeCard.lower(card)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Handles a deferred deep link by parsing it and saving the generated `HomeCards` to `HomeCardsStorage`.
     * `HomeCard::ContinueRadQuest` if found in the link parsing result, replaces `HomeCard::StartRadQuest`.
     * Notifies `HomeCardsObserver`.
     */
    open func deferredDeepLinkReceived(encodedValue: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_homecardsmanager_deferred_deep_link_received(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(encodedValue)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Initializes and saves to storage default `HomeCards`.
     * Marks the wallet creation and populates the set of cards required for a new wallet.
     * Notifies `HomeCardsObserver`.
     */
    open func walletCreated() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_homecardsmanager_wallet_created(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Clears the home cards from the `HomeCardsStorage`.
     * Notifies `HomeCardsObserver`.
     */
    open func walletReset() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_homecardsmanager_wallet_reset(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Marks the wallet restoration.
     * Ensures only the expected `HomeCards` remain in `HomeCardsStorage` - currently none.
     * Notifies `HomeCardsObserver`.
     */
    open func walletRestored() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_homecardsmanager_wallet_restored(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

public struct FfiConverterTypeHomeCardsManager: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeCardsManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsManager {
        return HomeCardsManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeCardsManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCardsManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeCardsManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeHomeCardsManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsManager {
    return try FfiConverterTypeHomeCardsManager.lift(pointer)
}

public func FfiConverterTypeHomeCardsManager_lower(_ value: HomeCardsManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeCardsManager.lower(value)
}

/**
 * Trait for observing home cards updates.
 * Defines a method for handling updates to home cards.
 */
public protocol HomeCardsObserver: AnyObject {
    /**
     * Handles updates to the home cards.
     */
    func handleCardsUpdate(cards: [HomeCard])
}

/**
 * Trait for observing home cards updates.
 * Defines a method for handling updates to home cards.
 */
open class HomeCardsObserverImpl:
    HomeCardsObserver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_homecardsobserver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_homecardsobserver(pointer, $0) }
    }

    /**
     * Handles updates to the home cards.
     */
    open func handleCardsUpdate(cards: [HomeCard]) { try! rustCall {
        uniffi_sargon_uniffi_fn_method_homecardsobserver_handle_cards_update(self.uniffiClonePointer(),
                                                                             FfiConverterSequenceTypeHomeCard.lower(cards), $0)
    }
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceHomeCardsObserver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceHomeCardsObserver = .init(
        handleCardsUpdate: { (
            uniffiHandle: UInt64,
            cards: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterTypeHomeCardsObserver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.handleCardsUpdate(
                    cards: FfiConverterSequenceTypeHomeCard.lift(cards)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeHomeCardsObserver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HomeCardsObserver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitHomeCardsObserver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_homecardsobserver(&UniffiCallbackInterfaceHomeCardsObserver.vtable)
}

public struct FfiConverterTypeHomeCardsObserver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<HomeCardsObserver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeCardsObserver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsObserver {
        return HomeCardsObserverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeCardsObserver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCardsObserver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeCardsObserver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeHomeCardsObserver_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsObserver {
    return try FfiConverterTypeHomeCardsObserver.lift(pointer)
}

public func FfiConverterTypeHomeCardsObserver_lower(_ value: HomeCardsObserver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeCardsObserver.lower(value)
}

/**
 * A trait for storing and loading home cards.
 * Defines asynchronous methods for saving and loading encoded home cards.
 */
public protocol HomeCardsStorage: AnyObject {
    /**
     * Saves the encoded home cards to the storage.
     */
    func saveCards(encodedCards: BagOfBytes) async throws

    /**
     * Loads the encoded home cards from the storage.
     */
    func loadCards() async throws -> BagOfBytes?
}

/**
 * A trait for storing and loading home cards.
 * Defines asynchronous methods for saving and loading encoded home cards.
 */
open class HomeCardsStorageImpl:
    HomeCardsStorage
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_homecardsstorage(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_homecardsstorage(pointer, $0) }
    }

    /**
     * Saves the encoded home cards to the storage.
     */
    open func saveCards(encodedCards: BagOfBytes) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_homecardsstorage_save_cards(
                        self.uniffiClonePointer(),
                        FfiConverterTypeBagOfBytes.lower(encodedCards)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Loads the encoded home cards from the storage.
     */
    open func loadCards() async throws -> BagOfBytes? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_homecardsstorage_load_cards(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceHomeCardsStorage {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceHomeCardsStorage = .init(
        saveCards: { (
            uniffiHandle: UInt64,
            encodedCards: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeHomeCardsStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveCards(
                    encodedCards: FfiConverterTypeBagOfBytes.lift(encodedCards)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        loadCards: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeHomeCardsStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadCards(
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeHomeCardsStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HomeCardsStorage: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitHomeCardsStorage() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_homecardsstorage(&UniffiCallbackInterfaceHomeCardsStorage.vtable)
}

public struct FfiConverterTypeHomeCardsStorage: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<HomeCardsStorage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HomeCardsStorage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsStorage {
        return HomeCardsStorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HomeCardsStorage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCardsStorage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HomeCardsStorage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeHomeCardsStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> HomeCardsStorage {
    return try FfiConverterTypeHomeCardsStorage.lift(pointer)
}

public func FfiConverterTypeHomeCardsStorage_lower(_ value: HomeCardsStorage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHomeCardsStorage.lower(value)
}

public protocol HostInfoDriver: AnyObject {
    /**
     * The **current** device's operating system, e.g. "iOS 17.4.1"
     */
    func hostOs() async -> HostOs

    /**
     * The name of the host device (iPhone/Android), e.g. "My Red iPhone"
     */
    func hostDeviceName() async -> String

    /**
     * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1".
     */
    func hostAppVersion() async -> String

    /**
     * The model of the host device (iPhone/Android), .e.g. "iPhone SE 2nd Gen"
     */
    func hostDeviceModel() async -> String
}

open class HostInfoDriverImpl:
    HostInfoDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_hostinfodriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_hostinfodriver(pointer, $0) }
    }

    /**
     * The **current** device's operating system, e.g. "iOS 17.4.1"
     */
    open func hostOs() async -> HostOs {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_hostinfodriver_host_os(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeHostOS.lift,
                errorHandler: nil
            )
    }

    /**
     * The name of the host device (iPhone/Android), e.g. "My Red iPhone"
     */
    open func hostDeviceName() async -> String {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_hostinfodriver_host_device_name(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterString.lift,
                errorHandler: nil
            )
    }

    /**
     * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1".
     */
    open func hostAppVersion() async -> String {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_hostinfodriver_host_app_version(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterString.lift,
                errorHandler: nil
            )
    }

    /**
     * The model of the host device (iPhone/Android), .e.g. "iPhone SE 2nd Gen"
     */
    open func hostDeviceModel() async -> String {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_hostinfodriver_host_device_model(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterString.lift,
                errorHandler: nil
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceHostInfoDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceHostInfoDriver = .init(
        hostOs: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> HostOs in
                guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hostOs(
                )
            }

            let uniffiHandleSuccess = { (returnValue: HostOs) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeHostOS.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        hostDeviceName: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hostDeviceName(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        hostAppVersion: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hostAppVersion(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        hostDeviceModel: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterTypeHostInfoDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.hostDeviceModel(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeHostInfoDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HostInfoDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitHostInfoDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_hostinfodriver(&UniffiCallbackInterfaceHostInfoDriver.vtable)
}

public struct FfiConverterTypeHostInfoDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<HostInfoDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HostInfoDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HostInfoDriver {
        return HostInfoDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HostInfoDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostInfoDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HostInfoDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeHostInfoDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> HostInfoDriver {
    return try FfiConverterTypeHostInfoDriver.lift(pointer)
}

public func FfiConverterTypeHostInfoDriver_lower(_ value: HostInfoDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHostInfoDriver.lower(value)
}

/**
 * * Trace
 * * Debug
 * * Info
 * * Warning
 * * Error
 */
public protocol LoggingDriver: AnyObject {
    func log(level: LogLevel, msg: String)
}

/**
 * * Trace
 * * Debug
 * * Info
 * * Warning
 * * Error
 */
open class LoggingDriverImpl:
    LoggingDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_loggingdriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_loggingdriver(pointer, $0) }
    }

    open func log(level: LogLevel, msg: String) { try! rustCall {
        uniffi_sargon_uniffi_fn_method_loggingdriver_log(self.uniffiClonePointer(),
                                                         FfiConverterTypeLogLevel.lower(level),
                                                         FfiConverterString.lower(msg), $0)
    }
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceLoggingDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceLoggingDriver = .init(
        log: { (
            uniffiHandle: UInt64,
            level: RustBuffer,
            msg: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterTypeLoggingDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.log(
                    level: FfiConverterTypeLogLevel.lift(level),
                    msg: FfiConverterString.lift(msg)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeLoggingDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface LoggingDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitLoggingDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_loggingdriver(&UniffiCallbackInterfaceLoggingDriver.vtable)
}

public struct FfiConverterTypeLoggingDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<LoggingDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LoggingDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LoggingDriver {
        return LoggingDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LoggingDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoggingDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LoggingDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeLoggingDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> LoggingDriver {
    return try FfiConverterTypeLoggingDriver.lift(pointer)
}

public func FfiConverterTypeLoggingDriver_lower(_ value: LoggingDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLoggingDriver.lower(value)
}

/**
 * Trait for executing network requests, to be implemented by hosts, so that
 * Sargon can make network requests with some HTTP client.
 */
public protocol NetworkingDriver: AnyObject {
    /**
     * Method invoked by Sargon Rust side, telling an implementing type to
     * execute a `NetworkRequest` and pass the Result back to Sargon Rust side.
     *
     * Either: `Err` or `Ok(NetworkResponse)`.
     */
    func executeNetworkRequest(request: NetworkRequest) async throws -> NetworkResponse
}

/**
 * Trait for executing network requests, to be implemented by hosts, so that
 * Sargon can make network requests with some HTTP client.
 */
open class NetworkingDriverImpl:
    NetworkingDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_networkingdriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_networkingdriver(pointer, $0) }
    }

    /**
     * Method invoked by Sargon Rust side, telling an implementing type to
     * execute a `NetworkRequest` and pass the Result back to Sargon Rust side.
     *
     * Either: `Err` or `Ok(NetworkResponse)`.
     */
    open func executeNetworkRequest(request: NetworkRequest) async throws -> NetworkResponse {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_networkingdriver_execute_network_request(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNetworkRequest.lower(request)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeNetworkResponse.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceNetworkingDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceNetworkingDriver = .init(
        executeNetworkRequest: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> NetworkResponse in
                guard let uniffiObj = try? FfiConverterTypeNetworkingDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.executeNetworkRequest(
                    request: FfiConverterTypeNetworkRequest.lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: NetworkResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeNetworkResponse.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeNetworkingDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface NetworkingDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitNetworkingDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_networkingdriver(&UniffiCallbackInterfaceNetworkingDriver.vtable)
}

public struct FfiConverterTypeNetworkingDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<NetworkingDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NetworkingDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkingDriver {
        return NetworkingDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NetworkingDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkingDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NetworkingDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeNetworkingDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> NetworkingDriver {
    return try FfiConverterTypeNetworkingDriver.lift(pointer)
}

public func FfiConverterTypeNetworkingDriver_lower(_ value: NetworkingDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNetworkingDriver.lower(value)
}

public protocol ProfileStateChangeDriver: AnyObject {
    func handleProfileStateChange(changedProfileState: ProfileState) async
}

open class ProfileStateChangeDriverImpl:
    ProfileStateChangeDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_profilestatechangedriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_profilestatechangedriver(pointer, $0) }
    }

    open func handleProfileStateChange(changedProfileState: ProfileState) async {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_profilestatechangedriver_handle_profile_state_change(
                        self.uniffiClonePointer(),
                        FfiConverterTypeProfileState.lower(changedProfileState)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: nil
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceProfileStateChangeDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceProfileStateChangeDriver = .init(
        handleProfileStateChange: { (
            uniffiHandle: UInt64,
            changedProfileState: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeProfileStateChangeDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.handleProfileStateChange(
                    changedProfileState: FfiConverterTypeProfileState.lift(changedProfileState)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeProfileStateChangeDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface ProfileStateChangeDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitProfileStateChangeDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_profilestatechangedriver(&UniffiCallbackInterfaceProfileStateChangeDriver.vtable)
}

public struct FfiConverterTypeProfileStateChangeDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<ProfileStateChangeDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ProfileStateChangeDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ProfileStateChangeDriver {
        return ProfileStateChangeDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ProfileStateChangeDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileStateChangeDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ProfileStateChangeDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeProfileStateChangeDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> ProfileStateChangeDriver {
    return try FfiConverterTypeProfileStateChangeDriver.lift(pointer)
}

public func FfiConverterTypeProfileStateChangeDriver_lower(_ value: ProfileStateChangeDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeProfileStateChangeDriver.lower(value)
}

/**
 * The Radix Connect Mobile client that handles the interaction with dApps on mobile through deepLinks.
 */
public protocol RadixConnectMobileProtocol: AnyObject {
    /**
     * Try to parse the deep link and create a RadixConnectMobileDappRequest.
     * This is a stateful operation as it will create an in flight session, that needs to be validated by the user.
     */
    func handleDeepLink(url: String) async throws -> RadixConnectMobileSessionRequest

    /**
     * Send the Host's response to the dApp.
     * This is a stateful operation as it will save the session in the secure storage if the user validated the session.
     */
    func sendDappInteractionResponse(walletResponse: RadixConnectMobileWalletResponse) async throws
}

/**
 * The Radix Connect Mobile client that handles the interaction with dApps on mobile through deepLinks.
 */
open class RadixConnectMobile:
    RadixConnectMobileProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_radixconnectmobile(self.pointer, $0) }
    }

    public convenience init(networkingDriver: NetworkingDriver, sessionStorage: RadixConnectMobileSessionStorage) {
        let pointer =
            try! rustCall {
                uniffi_sargon_uniffi_fn_constructor_radixconnectmobile_new(
                    FfiConverterTypeNetworkingDriver.lower(networkingDriver),
                    FfiConverterTypeRadixConnectMobileSessionStorage.lower(sessionStorage), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_radixconnectmobile(pointer, $0) }
    }

    /**
     * Try to parse the deep link and create a RadixConnectMobileDappRequest.
     * This is a stateful operation as it will create an in flight session, that needs to be validated by the user.
     */
    open func handleDeepLink(url: String) async throws -> RadixConnectMobileSessionRequest {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_radixconnectmobile_handle_deep_link(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(url)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeRadixConnectMobileSessionRequest.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Send the Host's response to the dApp.
     * This is a stateful operation as it will save the session in the secure storage if the user validated the session.
     */
    open func sendDappInteractionResponse(walletResponse: RadixConnectMobileWalletResponse) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_radixconnectmobile_send_dapp_interaction_response(
                        self.uniffiClonePointer(),
                        FfiConverterTypeRadixConnectMobileWalletResponse.lower(walletResponse)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

public struct FfiConverterTypeRadixConnectMobile: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RadixConnectMobile

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobile {
        return RadixConnectMobile(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RadixConnectMobile) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobile {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RadixConnectMobile, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeRadixConnectMobile_lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobile {
    return try FfiConverterTypeRadixConnectMobile.lift(pointer)
}

public func FfiConverterTypeRadixConnectMobile_lower(_ value: RadixConnectMobile) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRadixConnectMobile.lower(value)
}

/**
 * A trait for storing and loading Radix Connect Mobile sessions.
 */
public protocol RadixConnectMobileSessionStorage: AnyObject {
    /**
     * Saves the session to the storage identified by the session id.
     */
    func saveSession(sessionId: SessionId, encodedSession: BagOfBytes) async throws

    /**
     * Loads the session from the storage identified by the session id.
     */
    func loadSession(sessionId: SessionId) async throws -> BagOfBytes?
}

/**
 * A trait for storing and loading Radix Connect Mobile sessions.
 */
open class RadixConnectMobileSessionStorageImpl:
    RadixConnectMobileSessionStorage
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_radixconnectmobilesessionstorage(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_radixconnectmobilesessionstorage(pointer, $0) }
    }

    /**
     * Saves the session to the storage identified by the session id.
     */
    open func saveSession(sessionId: SessionId, encodedSession: BagOfBytes) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_radixconnectmobilesessionstorage_save_session(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSessionID.lower(sessionId), FfiConverterTypeBagOfBytes.lower(encodedSession)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Loads the session from the storage identified by the session id.
     */
    open func loadSession(sessionId: SessionId) async throws -> BagOfBytes? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_radixconnectmobilesessionstorage_load_session(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSessionID.lower(sessionId)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceRadixConnectMobileSessionStorage {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceRadixConnectMobileSessionStorage = .init(
        saveSession: { (
            uniffiHandle: UInt64,
            sessionId: RustBuffer,
            encodedSession: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeRadixConnectMobileSessionStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveSession(
                    sessionId: FfiConverterTypeSessionID.lift(sessionId),
                    encodedSession: FfiConverterTypeBagOfBytes.lift(encodedSession)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        loadSession: { (
            uniffiHandle: UInt64,
            sessionId: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeRadixConnectMobileSessionStorage.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadSession(
                    sessionId: FfiConverterTypeSessionID.lift(sessionId)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeRadixConnectMobileSessionStorage.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface RadixConnectMobileSessionStorage: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitRadixConnectMobileSessionStorage() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_radixconnectmobilesessionstorage(&UniffiCallbackInterfaceRadixConnectMobileSessionStorage.vtable)
}

public struct FfiConverterTypeRadixConnectMobileSessionStorage: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<RadixConnectMobileSessionStorage>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RadixConnectMobileSessionStorage

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobileSessionStorage {
        return RadixConnectMobileSessionStorageImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RadixConnectMobileSessionStorage) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileSessionStorage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RadixConnectMobileSessionStorage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeRadixConnectMobileSessionStorage_lift(_ pointer: UnsafeMutableRawPointer) throws -> RadixConnectMobileSessionStorage {
    return try FfiConverterTypeRadixConnectMobileSessionStorage.lift(pointer)
}

public func FfiConverterTypeRadixConnectMobileSessionStorage_lower(_ value: RadixConnectMobileSessionStorage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRadixConnectMobileSessionStorage.lower(value)
}

/**
 * The Sargon "Operating System" is the root "manager" of the Sargon library
 * which holds an in-memory Profile and a collection of "clients" which are
 * created from "drivers" which the hosts (iOS/Android wallets) "installs"
 * during app launch, enabling the  Sargon "Operating System" to e.g read/write
 * to secure storage and make use of the network connection of the iPhone/Android
 * phone.
 */
public protocol SargonOsProtocol: AnyObject {
    func debugFactorInstancesInCache() async -> [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]]

    /**
     * Looks up the account by account address, returns Err if the account is
     * unknown, will return a hidden account if queried for.
     */
    func accountByAddress(address: AccountAddress) throws -> Account

    /**
     * Returns the non-hidden accounts on the current network as `AccountForDisplay`
     */
    func accountsForDisplayOnCurrentNetwork() throws -> [AccountForDisplay]

    /**
     * Returns the non-hidden accounts on the current network, empty if no accounts
     * on the network
     */
    func accountsOnCurrentNetwork() throws -> [Account]

    /**
     * Add the `account` to active profile and **saves** the updated profile to
     * secure storage.
     *
     * Returns `Ok(())` if the `account` was new and successfully added. If
     * saving failed or if the account was already present in Profile, an
     * error is returned.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
     */
    func addAccount(account: Account) async throws

    /**
     * Adds the `accounts` to active profile and **saves** the updated profile to
     * secure storage.
     *
     * Returns `Ok(())` if the `accounts` were new and successfully added. If
     * saving failed or if the accounts were already present in Profile, an
     * error is returned.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
     */
    func addAccounts(accounts: [Account]) async throws

    /**
     * Returns `Ok(false)` if the Profile already contained a factor source with the
     * same id (Profile unchanged occurred).
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceAdded }`
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
     * if the newly added FactorSource is a new **main** flag, then we remove the
     * main flag from the old BDFS.
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    func addFactorSource(factorSource: FactorSource) async throws -> Bool

    /**
     * Adds all of the provided `factor_sources` to Profile in one single go.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourcesAdded }`
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
     * if the newly added FactorSource is a new **main** flag, then we remove the
     * main flag from the old BDFS.
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    func addFactorSources(factorSources: [FactorSource]) async throws -> [FactorSourceId]

    /**
     * Adds the security structureof factor sources to Profile if none with the
     * same ID already exists, and if all factors it references are found in Profile.
     *
     * If `structure` references a FactorSource by ID which is unknown to Profile,
     * `Err(CommonError::StructureReferencesUnknownFactorSource)` is returned.
     *
     * If Profile already contains a structure with the same ID, `Ok(false)` is
     * returned **without** modifying the existing one.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::SecurityStructureAdded { id } }`
     */
    func addSecurityStructureOfFactorSources(structure: SecurityStructureOfFactorSources) async throws -> Bool

    /**
     * Performs initial transaction analysis for a given raw manifest, including:
     * 1. Creating the SubintentManifest.
     * 2. Validating if the manifest is open or enclosed.
     * 3. If open, the manifest with its summary is returned.
     * 4. If enclosed, it extracts the transaction signers and then transaction preview GW request is executed.
     * 3. The execution summary is created with the manifest and receipt.
     *
     * Maps relevant errors to ensure proper handling by the hosts.
     */
    func analysePreAuthPreview(instructions: String, blobs: Blobs, nonce: Nonce, notaryPublicKey: PublicKey) async throws -> PreAuthToReview

    /**
     * Performs initial transaction analysis for a given raw manifest, including:
     * 1. Extracting the transaction signers.
     * 2. Executing the transaction preview GW request.
     * 3. Running the execution summary with the manifest and receipt.
     *
     * Maps relevant errors to ensure proper handling by the hosts.
     */
    func analyseTransactionPreview(instructions: String, blobs: Blobs, areInstructionsOriginatingFromHost: Bool, nonce: Nonce, notaryPublicKey: PublicKey) async throws -> TransactionToReview

    /**
     * The account names will be `<name_prefix> <index>`
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    func batchCreateManyAccountsThenSaveOnce(count: UInt16, networkId: NetworkId, namePrefix: String) async throws

    /**
     * Creates many new non securified accounts **WITHOUT** add them to Profile, using the *main* "Babylon"
     * `DeviceFactorSource` and the "next" indices for this FactorSource as derivation paths.
     *
     * If you want to add them to Profile, call `add_accounts(accounts)`
     *
     * # Emits Event
     * Emits `Event::FactorSourceUpdated { id: FactorSourceID }` since the date in
     * `factor_source.common.last_used` is updated.
     */
    func batchCreateUnsavedAccounts(networkId: NetworkId, count: UInt16, namePrefix: String) async throws -> [Account]

    /**
     * Returns the "main Babylon" `DeviceFactorSource` of the current account as
     * a `DeviceFactorSource`.
     */
    func bdfs() throws -> DeviceFactorSource

    /**
     * Changes the current Gateway to `to`, if it is not already the current.
     * Returns the outcome of the change, if we did in fact switch (current != to),
     * and if we switched then if `to` is new.
     *
     * If we did in fact change current, an `EventNotification` is emitted.
     *
     * # Emits Event
     * Emits `Event::GatewayChangedCurrent` if we changed the gateway.
     */
    func changeCurrentGateway(to: Gateway) async throws -> ChangeGatewayOutcome

    /**
     * Queries all `account_addresses` on ledger and checks reports which one is deleted.
     *
     * Returns an array of the account addresses along with a `bool` being true if that account
     * is deleted
     */
    func checkAccountsDeletedOnLedger(networkId: NetworkId, accountAddresses: [AccountAddress]) async throws -> [AccountAddress: Bool]

    /**
     * Create a new Account and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    func createAndSaveNewAccount(networkId: NetworkId, name: DisplayName) async throws -> Account

    /**
     * Create a new mainnet Account and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    func createAndSaveNewMainnetAccount(name: DisplayName) async throws -> Account

    /**
     * Create a new mainnet Account named "Unnamed" and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    func createAndSaveNewUnnamedMainnetAccount() async throws -> Account

    /**
     * Creates the `TransactionManifest` for deleting the given `account_address`. If a
     * `recipient_account_address` is provided, the manifest will also send all the resources from
     * the deleted account to the recipient one.
     */
    func createDeleteAccountManifest(accountAddress: AccountAddress, recipientAccountAddress: AccountAddress?) async throws -> CreateDeleteAccountManifestOutcome

    /**
     * Creates a new unsaved DeviceFactorSource from the provided `mnemonic_with_passphrase`,
     * either a "BDFS" or an "Olympia" one.
     */
    func createDeviceFactorSource(mnemonicWithPassphrase: MnemonicWithPassphrase, factorType: DeviceFactorSourceType) async throws -> DeviceFactorSource

    /**
     * Creates a Subintent given its discriminator, manifest and expiration.
     */
    func createSubintent(intentDiscriminator: IntentDiscriminator, subintentManifest: SubintentManifest, expiration: DappToWalletInteractionSubintentExpiration, message: String?) async throws -> Subintent

    /**
     * Creates a new non securified account **WITHOUT** adding it to Profile,
     * using the *main* "Babylon" `DeviceFactorSource` and the "next" index for
     * this FactorSource as derivation path.
     *
     * If you want to add it to Profile, call `os.add_account(account)`.
     *
     * # Emits Event
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage, since the `last_used_on` date
     * of the factor source has been updated.
     *
     * Also emits `EventNotification::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
     */
    func createUnsavedAccount(networkId: NetworkId, name: DisplayName) async throws -> Account

    /**
     * Uses `create_unsaved_account` specifying `NetworkID::Mainnet`.
     */
    func createUnsavedMainnetAccount(name: DisplayName) async throws -> Account

    /**
     * Creates a new unsaved mainnet account named "Unnamed {N}", where `N` is the
     * index of the next account for the BDFS.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`
     */
    func createUnsavedUnnamedMainnetAccount() async throws -> Account

    /**
     * The current gateway host client is using, which affects `current_network_id`.
     * All Network Requests reading from Radix ledger and submission of new
     * transactions will go the the Radix Network of the current Gateway.
     */
    func currentGateway() throws -> Gateway

    /**
     * Returns the `ProfileNetwork` corresponding to the network ID set by the
     * current gateway.
     */
    func currentNetwork() throws -> ProfileNetwork

    /**
     * Returns the id of the Network of the current Gateway set in AppPreferences
     * of the active Profile. This is the canonical value of "current network",
     * which affects which accounts host clients display to end user and to
     * which network transactions are submitted, amongst other behaviors.
     */
    func currentNetworkId() throws -> NetworkId

    func debugAddAllSampleFactors() async throws -> [FactorSourceId]

    func deleteWallet() async throws

    /**
     * Returns all the factor sources
     */
    func factorSources() throws -> [FactorSource]

    /**
     * Returns the `gateways` values of the current Profile.
     */
    func gateways() throws -> SavedGateways

    /**
     * Has **any** account, at all, including hidden, on any network.
     */
    func hasAnyAccountOnAnyNetwork() throws -> Bool

    /**
     * Checks if current Profile contains any `ProfileNetwork`s.
     */
    func hasAnyNetwork() throws -> Bool

    /**
     * Imports the `profile`, claims it, set it as active (current) one and
     * saves it into secure storage (with the claim modification).
     *
     * # Emits Event
     * Emits `EventNotification::new(Event::ProfileImported))` event if successful.
     */
    func importProfile(profile: Profile) async throws

    func importWallet(profile: Profile, bdfsSkipped: Bool) async throws

    /**
     * Loads a `MnemonicWithPassphrase` with the `id` of `device_factor_source`,
     * from SecureStorage, and returns a `PrivateHierarchicalDeterministicFactorSource`
     * built from both.
     *
     * Useful for when you will want to sign transactions or derive public keys for
     * creation of new entities.
     *
     * Returns `Err` if loading or decoding of `MnemonicWithPassphrase` from
     * SecureStorage fails.
     */
    func loadPrivateDeviceFactorSourceById(id: FactorSourceIdFromHash) async throws -> PrivateHierarchicalDeterministicFactorSource

    /**
     * Updates the profile by marking the account with `account_address` as hidden.
     */
    func markAccountAsHidden(accountAddress: AccountAddress) async throws

    /**
     * Updates the profile by marking the account with `account_address` as tombstoned.
     */
    func markAccountAsTombstoned(accountAddress: AccountAddress) async throws

    func newWallet(shouldPreDeriveInstances: Bool) async throws

    func newWalletWithDerivedBdfs(hdFactorSource: PrivateHierarchicalDeterministicFactorSource, accounts: [Account]) async throws

    /**
     * Polls the status of a `SubintentHash` until it is either `Success` or `Expired`.
     */
    func pollPreAuthorizationStatus(intentHash: SubintentHash, expirationTimestamp: Timestamp) async throws -> PreAuthorizationStatus

    /**
     * Polls the state of a Transaction until we can determine its `TransactionStatus`.
     */
    func pollTransactionStatus(intentHash: TransactionIntentHash) async throws -> TransactionStatus

    func profile() throws -> Profile

    func resolveHostId() async throws -> HostId

    func resolveHostInfo() async -> HostInfo

    /**
     * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
     * in profile.
     */
    func securityStructureOfFactorSourcesFromSecurityStructureOfFactorSourceIds(structureOfIds: SecurityStructureOfFactorSourceIDs) throws -> SecurityStructureOfFactorSources

    /**
     * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
     * in profile.
     */
    func securityStructuresOfFactorSourceIds() throws -> [SecurityStructureOfFactorSourceIDs]

    /**
     * Returns all the SecurityStructuresOfFactorSources,
     * by trying to map FactorSourceID level -> FactorSource Level
     */
    func securityStructuresOfFactorSources() throws -> [SecurityStructureOfFactorSources]

    func setProfile(profile: Profile) async throws

    /**
     * Submits a notarized transaction payload to the network.
     */
    func submitTransaction(notarizedTransaction: NotarizedTransaction) async throws -> TransactionIntentHash

    /**
     * Checks all active accounts in current network on ledger, if any of them are deleted.
     * Any deleted account is marked as tombstoned in profile.
     *
     * Returns true if any account became tombstoned.
     */
    func syncAccountsDeletedOnLedger() async throws -> Bool

    /**
     * Updates the account `updated` by mutating current profile and persisting
     * the change to secure storage. Throws `UnknownAccount` error if the account
     * is not found.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountUpdated { address } }`
     */
    func updateAccount(updated: Account) async throws

    /**
     * Updates the factor source `updated` by mutating current profile and persisting
     * the change to secure storage. Throws `UpdateFactorSourceMutateFailed` error if the
     * factor source is not found.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
     */
    func updateFactorSource(updated: FactorSource) async throws
}

/**
 * The Sargon "Operating System" is the root "manager" of the Sargon library
 * which holds an in-memory Profile and a collection of "clients" which are
 * created from "drivers" which the hosts (iOS/Android wallets) "installs"
 * during app launch, enabling the  Sargon "Operating System" to e.g read/write
 * to secure storage and make use of the network connection of the iPhone/Android
 * phone.
 */
open class SargonOs:
    SargonOsProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_sargonos(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_sargonos(pointer, $0) }
    }

    public static func boot(bios: Bios) async -> SargonOs {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_constructor_sargonos_boot(FfiConverterTypeBios.lower(bios)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_pointer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_pointer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_pointer,
                liftFunc: FfiConverterTypeSargonOS.lift,
                errorHandler: nil
            )
    }

    open func debugFactorInstancesInCache() async -> [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]] {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos___debug_factor_instances_in_cache(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterDictionaryTypeFactorSourceIDFromHashSequenceSequenceTypeFactorInstanceForDebugPurposes.lift,
                errorHandler: nil
            )
    }

    /**
     * Looks up the account by account address, returns Err if the account is
     * unknown, will return a hidden account if queried for.
     */
    open func accountByAddress(address: AccountAddress) throws -> Account {
        return try FfiConverterTypeAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_account_by_address(self.uniffiClonePointer(),
                                                                       FfiConverterTypeAccountAddress.lower(address), $0)
        })
    }

    /**
     * Returns the non-hidden accounts on the current network as `AccountForDisplay`
     */
    open func accountsForDisplayOnCurrentNetwork() throws -> [AccountForDisplay] {
        return try FfiConverterSequenceTypeAccountForDisplay.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_accounts_for_display_on_current_network(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the non-hidden accounts on the current network, empty if no accounts
     * on the network
     */
    open func accountsOnCurrentNetwork() throws -> [Account] {
        return try FfiConverterSequenceTypeAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_accounts_on_current_network(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Add the `account` to active profile and **saves** the updated profile to
     * secure storage.
     *
     * Returns `Ok(())` if the `account` was new and successfully added. If
     * saving failed or if the account was already present in Profile, an
     * error is returned.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
     */
    open func addAccount(account: Account) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_add_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeAccount.lower(account)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Adds the `accounts` to active profile and **saves** the updated profile to
     * secure storage.
     *
     * Returns `Ok(())` if the `accounts` were new and successfully added. If
     * saving failed or if the accounts were already present in Profile, an
     * error is returned.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::AccountsAdded { addresses } }`
     */
    open func addAccounts(accounts: [Account]) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_add_accounts(
                        self.uniffiClonePointer(),
                        FfiConverterSequenceTypeAccount.lower(accounts)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Returns `Ok(false)` if the Profile already contained a factor source with the
     * same id (Profile unchanged occurred).
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceAdded }`
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
     * if the newly added FactorSource is a new **main** flag, then we remove the
     * main flag from the old BDFS.
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    open func addFactorSource(factorSource: FactorSource) async throws -> Bool {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_add_factor_source(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFactorSource.lower(factorSource)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_i8,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_i8,
                freeFunc: ffi_sargon_uniffi_rust_future_free_i8,
                liftFunc: FfiConverterBool.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Adds all of the provided `factor_sources` to Profile in one single go.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourcesAdded }`
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`,
     * if the newly added FactorSource is a new **main** flag, then we remove the
     * main flag from the old BDFS.
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    open func addFactorSources(factorSources: [FactorSource]) async throws -> [FactorSourceId] {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_add_factor_sources(
                        self.uniffiClonePointer(),
                        FfiConverterSequenceTypeFactorSource.lower(factorSources)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterSequenceTypeFactorSourceID.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Adds the security structureof factor sources to Profile if none with the
     * same ID already exists, and if all factors it references are found in Profile.
     *
     * If `structure` references a FactorSource by ID which is unknown to Profile,
     * `Err(CommonError::StructureReferencesUnknownFactorSource)` is returned.
     *
     * If Profile already contains a structure with the same ID, `Ok(false)` is
     * returned **without** modifying the existing one.
     *
     * # Emits Events
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     *
     * And also emits `Event::ProfileModified { change: EventProfileModified::SecurityStructureAdded { id } }`
     */
    open func addSecurityStructureOfFactorSources(structure: SecurityStructureOfFactorSources) async throws -> Bool {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_add_security_structure_of_factor_sources(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSecurityStructureOfFactorSources.lower(structure)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_i8,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_i8,
                freeFunc: ffi_sargon_uniffi_rust_future_free_i8,
                liftFunc: FfiConverterBool.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Performs initial transaction analysis for a given raw manifest, including:
     * 1. Creating the SubintentManifest.
     * 2. Validating if the manifest is open or enclosed.
     * 3. If open, the manifest with its summary is returned.
     * 4. If enclosed, it extracts the transaction signers and then transaction preview GW request is executed.
     * 3. The execution summary is created with the manifest and receipt.
     *
     * Maps relevant errors to ensure proper handling by the hosts.
     */
    open func analysePreAuthPreview(instructions: String, blobs: Blobs, nonce: Nonce, notaryPublicKey: PublicKey) async throws -> PreAuthToReview {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_analyse_pre_auth_preview(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(instructions), FfiConverterTypeBlobs.lower(blobs), FfiConverterTypeNonce.lower(nonce), FfiConverterTypePublicKey.lower(notaryPublicKey)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypePreAuthToReview.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Performs initial transaction analysis for a given raw manifest, including:
     * 1. Extracting the transaction signers.
     * 2. Executing the transaction preview GW request.
     * 3. Running the execution summary with the manifest and receipt.
     *
     * Maps relevant errors to ensure proper handling by the hosts.
     */
    open func analyseTransactionPreview(instructions: String, blobs: Blobs, areInstructionsOriginatingFromHost: Bool, nonce: Nonce, notaryPublicKey: PublicKey) async throws -> TransactionToReview {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_analyse_transaction_preview(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(instructions), FfiConverterTypeBlobs.lower(blobs), FfiConverterBool.lower(areInstructionsOriginatingFromHost), FfiConverterTypeNonce.lower(nonce), FfiConverterTypePublicKey.lower(notaryPublicKey)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeTransactionToReview.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * The account names will be `<name_prefix> <index>`
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     *
     * And also emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage.
     */
    open func batchCreateManyAccountsThenSaveOnce(count: UInt16, networkId: NetworkId, namePrefix: String) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_batch_create_many_accounts_then_save_once(
                        self.uniffiClonePointer(),
                        FfiConverterUInt16.lower(count), FfiConverterTypeNetworkID.lower(networkId), FfiConverterString.lower(namePrefix)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Creates many new non securified accounts **WITHOUT** add them to Profile, using the *main* "Babylon"
     * `DeviceFactorSource` and the "next" indices for this FactorSource as derivation paths.
     *
     * If you want to add them to Profile, call `add_accounts(accounts)`
     *
     * # Emits Event
     * Emits `Event::FactorSourceUpdated { id: FactorSourceID }` since the date in
     * `factor_source.common.last_used` is updated.
     */
    open func batchCreateUnsavedAccounts(networkId: NetworkId, count: UInt16, namePrefix: String) async throws -> [Account] {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_batch_create_unsaved_accounts(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNetworkID.lower(networkId), FfiConverterUInt16.lower(count), FfiConverterString.lower(namePrefix)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterSequenceTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Returns the "main Babylon" `DeviceFactorSource` of the current account as
     * a `DeviceFactorSource`.
     */
    open func bdfs() throws -> DeviceFactorSource {
        return try FfiConverterTypeDeviceFactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_bdfs(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Changes the current Gateway to `to`, if it is not already the current.
     * Returns the outcome of the change, if we did in fact switch (current != to),
     * and if we switched then if `to` is new.
     *
     * If we did in fact change current, an `EventNotification` is emitted.
     *
     * # Emits Event
     * Emits `Event::GatewayChangedCurrent` if we changed the gateway.
     */
    open func changeCurrentGateway(to: Gateway) async throws -> ChangeGatewayOutcome {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_change_current_gateway(
                        self.uniffiClonePointer(),
                        FfiConverterTypeGateway.lower(to)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeChangeGatewayOutcome.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Queries all `account_addresses` on ledger and checks reports which one is deleted.
     *
     * Returns an array of the account addresses along with a `bool` being true if that account
     * is deleted
     */
    open func checkAccountsDeletedOnLedger(networkId: NetworkId, accountAddresses: [AccountAddress]) async throws -> [AccountAddress: Bool] {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_check_accounts_deleted_on_ledger(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNetworkID.lower(networkId), FfiConverterSequenceTypeAccountAddress.lower(accountAddresses)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterDictionaryTypeAccountAddressBool.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Create a new Account and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    open func createAndSaveNewAccount(networkId: NetworkId, name: DisplayName) async throws -> Account {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_create_and_save_new_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNetworkID.lower(networkId), FfiConverterTypeDisplayName.lower(name)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Create a new mainnet Account and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    open func createAndSaveNewMainnetAccount(name: DisplayName) async throws -> Account {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_create_and_save_new_mainnet_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeDisplayName.lower(name)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Create a new mainnet Account named "Unnamed" and adds it to the active Profile.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountAdded }`
     */
    open func createAndSaveNewUnnamedMainnetAccount() async throws -> Account {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_create_and_save_new_unnamed_mainnet_account(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Creates the `TransactionManifest` for deleting the given `account_address`. If a
     * `recipient_account_address` is provided, the manifest will also send all the resources from
     * the deleted account to the recipient one.
     */
    open func createDeleteAccountManifest(accountAddress: AccountAddress, recipientAccountAddress: AccountAddress?) async throws -> CreateDeleteAccountManifestOutcome {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_create_delete_account_manifest(
                        self.uniffiClonePointer(),
                        FfiConverterTypeAccountAddress.lower(accountAddress), FfiConverterOptionTypeAccountAddress.lower(recipientAccountAddress)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeCreateDeleteAccountManifestOutcome.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Creates a new unsaved DeviceFactorSource from the provided `mnemonic_with_passphrase`,
     * either a "BDFS" or an "Olympia" one.
     */
    open func createDeviceFactorSource(mnemonicWithPassphrase: MnemonicWithPassphrase, factorType: DeviceFactorSourceType) async throws -> DeviceFactorSource {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_create_device_factor_source(
                        self.uniffiClonePointer(),
                        FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase), FfiConverterTypeDeviceFactorSourceType.lower(factorType)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeDeviceFactorSource.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Creates a Subintent given its discriminator, manifest and expiration.
     */
    open func createSubintent(intentDiscriminator: IntentDiscriminator, subintentManifest: SubintentManifest, expiration: DappToWalletInteractionSubintentExpiration, message: String?) async throws -> Subintent {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_create_subintent(
                        self.uniffiClonePointer(),
                        FfiConverterTypeIntentDiscriminator.lower(intentDiscriminator), FfiConverterTypeSubintentManifest.lower(subintentManifest), FfiConverterTypeDappToWalletInteractionSubintentExpiration.lower(expiration), FfiConverterOptionString.lower(message)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeSubintent.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Creates a new non securified account **WITHOUT** adding it to Profile,
     * using the *main* "Babylon" `DeviceFactorSource` and the "next" index for
     * this FactorSource as derivation path.
     *
     * If you want to add it to Profile, call `os.add_account(account)`.
     *
     * # Emits Event
     * Emits `Event::ProfileSaved` after having successfully written the JSON
     * of the active profile to secure storage, since the `last_used_on` date
     * of the factor source has been updated.
     *
     * Also emits `EventNotification::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
     */
    open func createUnsavedAccount(networkId: NetworkId, name: DisplayName) async throws -> Account {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_create_unsaved_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNetworkID.lower(networkId), FfiConverterTypeDisplayName.lower(name)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Uses `create_unsaved_account` specifying `NetworkID::Mainnet`.
     */
    open func createUnsavedMainnetAccount(name: DisplayName) async throws -> Account {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_create_unsaved_mainnet_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeDisplayName.lower(name)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Creates a new unsaved mainnet account named "Unnamed {N}", where `N` is the
     * index of the next account for the BDFS.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated }`
     */
    open func createUnsavedUnnamedMainnetAccount() async throws -> Account {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_create_unsaved_unnamed_mainnet_account(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeAccount.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * The current gateway host client is using, which affects `current_network_id`.
     * All Network Requests reading from Radix ledger and submission of new
     * transactions will go the the Radix Network of the current Gateway.
     */
    open func currentGateway() throws -> Gateway {
        return try FfiConverterTypeGateway.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_current_gateway(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the `ProfileNetwork` corresponding to the network ID set by the
     * current gateway.
     */
    open func currentNetwork() throws -> ProfileNetwork {
        return try FfiConverterTypeProfileNetwork.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_current_network(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the id of the Network of the current Gateway set in AppPreferences
     * of the active Profile. This is the canonical value of "current network",
     * which affects which accounts host clients display to end user and to
     * which network transactions are submitted, amongst other behaviors.
     */
    open func currentNetworkId() throws -> NetworkId {
        return try FfiConverterTypeNetworkID.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_current_network_id(self.uniffiClonePointer(), $0)
        })
    }

    open func debugAddAllSampleFactors() async throws -> [FactorSourceId] {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_debug_add_all_sample_factors(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterSequenceTypeFactorSourceID.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func deleteWallet() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_delete_wallet(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Returns all the factor sources
     */
    open func factorSources() throws -> [FactorSource] {
        return try FfiConverterSequenceTypeFactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_factor_sources(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the `gateways` values of the current Profile.
     */
    open func gateways() throws -> SavedGateways {
        return try FfiConverterTypeSavedGateways.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_gateways(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Has **any** account, at all, including hidden, on any network.
     */
    open func hasAnyAccountOnAnyNetwork() throws -> Bool {
        return try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_has_any_account_on_any_network(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Checks if current Profile contains any `ProfileNetwork`s.
     */
    open func hasAnyNetwork() throws -> Bool {
        return try FfiConverterBool.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_has_any_network(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Imports the `profile`, claims it, set it as active (current) one and
     * saves it into secure storage (with the claim modification).
     *
     * # Emits Event
     * Emits `EventNotification::new(Event::ProfileImported))` event if successful.
     */
    open func importProfile(profile: Profile) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_import_profile(
                        self.uniffiClonePointer(),
                        FfiConverterTypeProfile.lower(profile)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func importWallet(profile: Profile, bdfsSkipped: Bool) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_import_wallet(
                        self.uniffiClonePointer(),
                        FfiConverterTypeProfile.lower(profile), FfiConverterBool.lower(bdfsSkipped)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Loads a `MnemonicWithPassphrase` with the `id` of `device_factor_source`,
     * from SecureStorage, and returns a `PrivateHierarchicalDeterministicFactorSource`
     * built from both.
     *
     * Useful for when you will want to sign transactions or derive public keys for
     * creation of new entities.
     *
     * Returns `Err` if loading or decoding of `MnemonicWithPassphrase` from
     * SecureStorage fails.
     */
    open func loadPrivateDeviceFactorSourceById(id: FactorSourceIdFromHash) async throws -> PrivateHierarchicalDeterministicFactorSource {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_load_private_device_factor_source_by_id(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFactorSourceIDFromHash.lower(id)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Updates the profile by marking the account with `account_address` as hidden.
     */
    open func markAccountAsHidden(accountAddress: AccountAddress) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_mark_account_as_hidden(
                        self.uniffiClonePointer(),
                        FfiConverterTypeAccountAddress.lower(accountAddress)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Updates the profile by marking the account with `account_address` as tombstoned.
     */
    open func markAccountAsTombstoned(accountAddress: AccountAddress) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_mark_account_as_tombstoned(
                        self.uniffiClonePointer(),
                        FfiConverterTypeAccountAddress.lower(accountAddress)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func newWallet(shouldPreDeriveInstances: Bool) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_new_wallet(
                        self.uniffiClonePointer(),
                        FfiConverterBool.lower(shouldPreDeriveInstances)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func newWalletWithDerivedBdfs(hdFactorSource: PrivateHierarchicalDeterministicFactorSource, accounts: [Account]) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_new_wallet_with_derived_bdfs(
                        self.uniffiClonePointer(),
                        FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lower(hdFactorSource), FfiConverterSequenceTypeAccount.lower(accounts)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Polls the status of a `SubintentHash` until it is either `Success` or `Expired`.
     */
    open func pollPreAuthorizationStatus(intentHash: SubintentHash, expirationTimestamp: Timestamp) async throws -> PreAuthorizationStatus {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_poll_pre_authorization_status(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSubintentHash.lower(intentHash), FfiConverterTypeTimestamp.lower(expirationTimestamp)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypePreAuthorizationStatus.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Polls the state of a Transaction until we can determine its `TransactionStatus`.
     */
    open func pollTransactionStatus(intentHash: TransactionIntentHash) async throws -> TransactionStatus {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_poll_transaction_status(
                        self.uniffiClonePointer(),
                        FfiConverterTypeTransactionIntentHash.lower(intentHash)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeTransactionStatus.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func profile() throws -> Profile {
        return try FfiConverterTypeProfile.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_profile(self.uniffiClonePointer(), $0)
        })
    }

    open func resolveHostId() async throws -> HostId {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_resolve_host_id(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeHostId.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func resolveHostInfo() async -> HostInfo {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_resolve_host_info(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeHostInfo.lift,
                errorHandler: nil
            )
    }

    /**
     * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
     * in profile.
     */
    open func securityStructureOfFactorSourcesFromSecurityStructureOfFactorSourceIds(structureOfIds: SecurityStructureOfFactorSourceIDs) throws -> SecurityStructureOfFactorSources {
        return try FfiConverterTypeSecurityStructureOfFactorSources.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_security_structure_of_factor_sources_from_security_structure_of_factor_source_ids(self.uniffiClonePointer(),
                                                                                                                                      FfiConverterTypeSecurityStructureOfFactorSourceIDs.lower(structureOfIds), $0)
        })
    }

    /**
     * Returns all the `SecurityStructuresOfFactorSourceIDs` which are stored
     * in profile.
     */
    open func securityStructuresOfFactorSourceIds() throws -> [SecurityStructureOfFactorSourceIDs] {
        return try FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_security_structures_of_factor_source_ids(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns all the SecurityStructuresOfFactorSources,
     * by trying to map FactorSourceID level -> FactorSource Level
     */
    open func securityStructuresOfFactorSources() throws -> [SecurityStructureOfFactorSources] {
        return try FfiConverterSequenceTypeSecurityStructureOfFactorSources.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
            uniffi_sargon_uniffi_fn_method_sargonos_security_structures_of_factor_sources(self.uniffiClonePointer(), $0)
        })
    }

    open func setProfile(profile: Profile) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_set_profile(
                        self.uniffiClonePointer(),
                        FfiConverterTypeProfile.lower(profile)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Submits a notarized transaction payload to the network.
     */
    open func submitTransaction(notarizedTransaction: NotarizedTransaction) async throws -> TransactionIntentHash {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_submit_transaction(
                        self.uniffiClonePointer(),
                        FfiConverterTypeNotarizedTransaction.lower(notarizedTransaction)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeTransactionIntentHash.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Checks all active accounts in current network on ledger, if any of them are deleted.
     * Any deleted account is marked as tombstoned in profile.
     *
     * Returns true if any account became tombstoned.
     */
    open func syncAccountsDeletedOnLedger() async throws -> Bool {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_sync_accounts_deleted_on_ledger(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_i8,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_i8,
                freeFunc: ffi_sargon_uniffi_rust_future_free_i8,
                liftFunc: FfiConverterBool.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Updates the account `updated` by mutating current profile and persisting
     * the change to secure storage. Throws `UnknownAccount` error if the account
     * is not found.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::AccountUpdated { address } }`
     */
    open func updateAccount(updated: Account) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_update_account(
                        self.uniffiClonePointer(),
                        FfiConverterTypeAccount.lower(updated)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    /**
     * Updates the factor source `updated` by mutating current profile and persisting
     * the change to secure storage. Throws `UpdateFactorSourceMutateFailed` error if the
     * factor source is not found.
     *
     * # Emits Event
     * Emits `Event::ProfileModified { change: EventProfileModified::FactorSourceUpdated { id } }`
     */
    open func updateFactorSource(updated: FactorSource) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_sargonos_update_factor_source(
                        self.uniffiClonePointer(),
                        FfiConverterTypeFactorSource.lower(updated)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

public struct FfiConverterTypeSargonOS: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SargonOs

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SargonOs {
        return SargonOs(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SargonOs) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonOs {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SargonOs, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeSargonOS_lift(_ pointer: UnsafeMutableRawPointer) throws -> SargonOs {
    return try FfiConverterTypeSargonOS.lift(pointer)
}

public func FfiConverterTypeSargonOS_lower(_ value: SargonOs) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSargonOS.lower(value)
}

public protocol SecureStorageDriver: AnyObject {
    func loadData(key: SecureStorageKey) async throws -> BagOfBytes?

    func saveData(key: SecureStorageKey, data: BagOfBytes) async throws

    func deleteDataForKey(key: SecureStorageKey) async throws
}

open class SecureStorageDriverImpl:
    SecureStorageDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_securestoragedriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_securestoragedriver(pointer, $0) }
    }

    open func loadData(key: SecureStorageKey) async throws -> BagOfBytes? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_securestoragedriver_load_data(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSecureStorageKey.lower(key)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func saveData(key: SecureStorageKey, data: BagOfBytes) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_securestoragedriver_save_data(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSecureStorageKey.lower(key), FfiConverterTypeBagOfBytes.lower(data)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func deleteDataForKey(key: SecureStorageKey) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_securestoragedriver_delete_data_for_key(
                        self.uniffiClonePointer(),
                        FfiConverterTypeSecureStorageKey.lower(key)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceSecureStorageDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSecureStorageDriver = .init(
        loadData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadData(
                    key: FfiConverterTypeSecureStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        saveData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            data: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveData(
                    key: FfiConverterTypeSecureStorageKey.lift(key),
                    data: FfiConverterTypeBagOfBytes.lift(data)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteDataForKey: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeSecureStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteDataForKey(
                    key: FfiConverterTypeSecureStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeSecureStorageDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SecureStorageDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSecureStorageDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_securestoragedriver(&UniffiCallbackInterfaceSecureStorageDriver.vtable)
}

public struct FfiConverterTypeSecureStorageDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<SecureStorageDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SecureStorageDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecureStorageDriver {
        return SecureStorageDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SecureStorageDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SecureStorageDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeSecureStorageDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecureStorageDriver {
    return try FfiConverterTypeSecureStorageDriver.lift(pointer)
}

public func FfiConverterTypeSecureStorageDriver_lower(_ value: SecureStorageDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSecureStorageDriver.lower(value)
}

public protocol UnsafeStorageDriver: AnyObject {
    func loadData(key: UnsafeStorageKey) async throws -> BagOfBytes?

    func saveData(key: UnsafeStorageKey, data: BagOfBytes) async throws

    func deleteDataForKey(key: UnsafeStorageKey) async throws
}

open class UnsafeStorageDriverImpl:
    UnsafeStorageDriver
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    /// This constructor can be used to instantiate a fake object.
    /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    ///
    /// - Warning:
    ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_sargon_uniffi_fn_clone_unsafestoragedriver(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_sargon_uniffi_fn_free_unsafestoragedriver(pointer, $0) }
    }

    open func loadData(key: UnsafeStorageKey) async throws -> BagOfBytes? {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_unsafestoragedriver_load_data(
                        self.uniffiClonePointer(),
                        FfiConverterTypeUnsafeStorageKey.lower(key)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_rust_buffer,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_rust_buffer,
                freeFunc: ffi_sargon_uniffi_rust_future_free_rust_buffer,
                liftFunc: FfiConverterOptionTypeBagOfBytes.lift,
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func saveData(key: UnsafeStorageKey, data: BagOfBytes) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_unsafestoragedriver_save_data(
                        self.uniffiClonePointer(),
                        FfiConverterTypeUnsafeStorageKey.lower(key), FfiConverterTypeBagOfBytes.lower(data)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }

    open func deleteDataForKey(key: UnsafeStorageKey) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_sargon_uniffi_fn_method_unsafestoragedriver_delete_data_for_key(
                        self.uniffiClonePointer(),
                        FfiConverterTypeUnsafeStorageKey.lower(key)
                    )
                },
                pollFunc: ffi_sargon_uniffi_rust_future_poll_void,
                completeFunc: ffi_sargon_uniffi_rust_future_complete_void,
                freeFunc: ffi_sargon_uniffi_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeCommonError.lift
            )
    }
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceUnsafeStorageDriver {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceUnsafeStorageDriver = .init(
        loadData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> BagOfBytes? in
                guard let uniffiObj = try? FfiConverterTypeUnsafeStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.loadData(
                    key: FfiConverterTypeUnsafeStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: BagOfBytes?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeBagOfBytes.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        saveData: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            data: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeUnsafeStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.saveData(
                    key: FfiConverterTypeUnsafeStorageKey.lift(key),
                    data: FfiConverterTypeBagOfBytes.lift(data)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        deleteDataForKey: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws in
                guard let uniffiObj = try? FfiConverterTypeUnsafeStorageDriver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.deleteDataForKey(
                    key: FfiConverterTypeUnsafeStorageKey.lift(key)
                )
            }

            let uniffiHandleSuccess = { (_: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { statusCode, errorBuf in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeCommonError.lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterTypeUnsafeStorageDriver.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface UnsafeStorageDriver: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitUnsafeStorageDriver() {
    uniffi_sargon_uniffi_fn_init_callback_vtable_unsafestoragedriver(&UniffiCallbackInterfaceUnsafeStorageDriver.vtable)
}

public struct FfiConverterTypeUnsafeStorageDriver: FfiConverter {
    fileprivate static var handleMap = UniffiHandleMap<UnsafeStorageDriver>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnsafeStorageDriver

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsafeStorageDriver {
        return UnsafeStorageDriverImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnsafeStorageDriver) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsafeStorageDriver {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnsafeStorageDriver, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

public func FfiConverterTypeUnsafeStorageDriver_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsafeStorageDriver {
    return try FfiConverterTypeUnsafeStorageDriver.lift(pointer)
}

public func FfiConverterTypeUnsafeStorageDriver_lower(_ value: UnsafeStorageDriver) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnsafeStorageDriver.lower(value)
}

/**
 * Address to an AccessController that controls an Account or Identity (Persona),
 * it said entity has been "securified", e.g.:
 * `"accesscontroller_rdx1c0duj4lq0dc3cpl8qd420fpn5eckh8ljeysvjm894lyl5ja5yq6y5a"`
 *
 * When a user applies a SecurityStructureConfiguration for the first time on a
 * non-securified entity (and signs and submit the resulting TX) said entity is
 * "assigned" an AccessControllerAddress by the network.
 *
 * An `AccessControllerAddress` has the [Scrypto's `EntityType`][entt] `GlobalAccessController`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalAccessControllerAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L247-L248
 */
public struct AccessControllerAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}

extension AccessControllerAddress: Sendable {}
extension AccessControllerAddress: Equatable, Hashable {
    public static func == (lhs: AccessControllerAddress, rhs: AccessControllerAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeAccessControllerAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccessControllerAddress {
        return
            try AccessControllerAddress(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: AccessControllerAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeAccessControllerAddress_lift(_ buf: RustBuffer) throws -> AccessControllerAddress {
    return try FfiConverterTypeAccessControllerAddress.lift(buf)
}

public func FfiConverterTypeAccessControllerAddress_lower(_ value: AccessControllerAddress) -> RustBuffer {
    return FfiConverterTypeAccessControllerAddress.lower(value)
}

/**
 * A network unique account with a unique public address and a set of cryptographic
 * factors used to control it.
 *
 * Used to own and control assets on the radix network. Uniquely identified by an
 * account address, e.g.
 *
 * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
 *
 * But most commonly users see the address on its abbreviated form:
 *
 * `acco...nvjdwr`
 *
 * Accounts have a display name and an appearance id.
 *
 * An account can be either controlled by a "Babylon" DeviceFactorSource or a
 * Legacy one imported from Olympia, or a Ledger hardware wallet, which too might
 * have been imported from Olympia.
 */
public struct Account {
    /**
     * The ID of the network this account can be used with.
     */
    public var networkId: NetworkId
    /**
     * A globally unique identifier of this account, being a human readable
     * address of an account. Always starts with `"account_"``, for example:
     *
     * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
     *
     * Most commonly the user will see this address in its abbreviated
     * form which is:
     *
     * `acco...nvjdwr`
     *
     * No two addresses will ever be the same even for the same factor source
     * but on different networks, since the public keys controlling the
     * accounts depend on the network id.
     */
    public var address: AccountAddress
    /**
     * An off-ledger display name or description chosen by the user when she
     * created this account.
     */
    public var displayName: DisplayName
    /**
     * Security state of this account, either "securified" or not.
     */
    public var securityState: EntitySecurityState
    /**
     * The visual cue user learns to associated this account with, typically
     * a beautiful colorful gradient.
     */
    public var appearanceId: AppearanceId
    /**
     * An order set of `EntityFlag`s used to describe certain Off-ledger
     * user state about Accounts or Personas, such as if an entity is
     * marked as hidden or not.
     */
    public var flags: [EntityFlag]
    /**
     * The on ledger synced settings for this account, contains e.g.
     * ThirdPartyDeposit settings, with deposit rules for assets.
     */
    public var onLedgerSettings: OnLedgerSettings

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network this account can be used with.
         */ networkId: NetworkId,
        /**
            * A globally unique identifier of this account, being a human readable
            * address of an account. Always starts with `"account_"``, for example:
            *
            * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
            *
            * Most commonly the user will see this address in its abbreviated
            * form which is:
            *
            * `acco...nvjdwr`
            *
            * No two addresses will ever be the same even for the same factor source
            * but on different networks, since the public keys controlling the
            * accounts depend on the network id.
            */ address: AccountAddress,
        /**
            * An off-ledger display name or description chosen by the user when she
            * created this account.
            */ displayName: DisplayName,
        /**
            * Security state of this account, either "securified" or not.
            */ securityState: EntitySecurityState,
        /**
            * The visual cue user learns to associated this account with, typically
            * a beautiful colorful gradient.
            */ appearanceId: AppearanceId,
        /**
            * An order set of `EntityFlag`s used to describe certain Off-ledger
            * user state about Accounts or Personas, such as if an entity is
            * marked as hidden or not.
            */ flags: [EntityFlag],
        /**
            * The on ledger synced settings for this account, contains e.g.
            * ThirdPartyDeposit settings, with deposit rules for assets.
            */ onLedgerSettings: OnLedgerSettings
    ) {
        self.networkId = networkId
        self.address = address
        self.displayName = displayName
        self.securityState = securityState
        self.appearanceId = appearanceId
        self.flags = flags
        self.onLedgerSettings = onLedgerSettings
    }
}

extension Account: Sendable {}
extension Account: Equatable, Hashable {
    public static func == (lhs: Account, rhs: Account) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.securityState != rhs.securityState {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        if lhs.onLedgerSettings != rhs.onLedgerSettings {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(securityState)
        hasher.combine(appearanceId)
        hasher.combine(flags)
        hasher.combine(onLedgerSettings)
    }
}

public struct FfiConverterTypeAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Account {
        return
            try Account(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                address: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                securityState: FfiConverterTypeEntitySecurityState.read(from: &buf),
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf),
                flags: FfiConverterSequenceTypeEntityFlag.read(from: &buf),
                onLedgerSettings: FfiConverterTypeOnLedgerSettings.read(from: &buf)
            )
    }

    public static func write(_ value: Account, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeEntitySecurityState.write(value.securityState, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
        FfiConverterSequenceTypeEntityFlag.write(value.flags, into: &buf)
        FfiConverterTypeOnLedgerSettings.write(value.onLedgerSettings, into: &buf)
    }
}

public func FfiConverterTypeAccount_lift(_ buf: RustBuffer) throws -> Account {
    return try FfiConverterTypeAccount.lift(buf)
}

public func FfiConverterTypeAccount_lower(_ value: Account) -> RustBuffer {
    return FfiConverterTypeAccount.lower(value)
}

/**
 * Human readable address of an account. Always starts with `"account_"``, for example:
 *
 * `account_rdx128y6j78mt0aqv6372evz28hrxp8mn06ccddkr7xppc88hyvynvjdwr`
 *
 * Most commonly the user will see this address in its abbreviated
 * form which is:
 *
 * `acco...nvjdwr`
 *
 * Addresses are checksummed, as per Bech32. **Only** *Account* addresses starts with
 * the prefix `account_`.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of AccountAddresses:
 * * GlobalAccount
 * * GlobalVirtualSecp256k1Account
 * * GlobalVirtualEd25519Account
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalAccountAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L224-L228
 */
public struct AccountAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}

extension AccountAddress: Sendable {}
extension AccountAddress: Equatable, Hashable {
    public static func == (lhs: AccountAddress, rhs: AccountAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeAccountAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountAddress {
        return
            try AccountAddress(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: AccountAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeAccountAddress_lift(_ buf: RustBuffer) throws -> AccountAddress {
    return try FfiConverterTypeAccountAddress.lift(buf)
}

public func FfiConverterTypeAccountAddress_lower(_ value: AccountAddress) -> RustBuffer {
    return FfiConverterTypeAccountAddress.lower(value)
}

/**
 * Represents an account deposit, which includes specified and unspecified resources.
 */
public struct AccountDeposits {
    public var specifiedResources: [SimpleResourceBounds]
    public var unspecifiedResources: UnspecifiedResources

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(specifiedResources: [SimpleResourceBounds], unspecifiedResources: UnspecifiedResources) {
        self.specifiedResources = specifiedResources
        self.unspecifiedResources = unspecifiedResources
    }
}

extension AccountDeposits: Sendable {}
extension AccountDeposits: Equatable, Hashable {
    public static func == (lhs: AccountDeposits, rhs: AccountDeposits) -> Bool {
        if lhs.specifiedResources != rhs.specifiedResources {
            return false
        }
        if lhs.unspecifiedResources != rhs.unspecifiedResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(specifiedResources)
        hasher.combine(unspecifiedResources)
    }
}

public struct FfiConverterTypeAccountDeposits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountDeposits {
        return
            try AccountDeposits(
                specifiedResources: FfiConverterSequenceTypeSimpleResourceBounds.read(from: &buf),
                unspecifiedResources: FfiConverterTypeUnspecifiedResources.read(from: &buf)
            )
    }

    public static func write(_ value: AccountDeposits, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeSimpleResourceBounds.write(value.specifiedResources, into: &buf)
        FfiConverterTypeUnspecifiedResources.write(value.unspecifiedResources, into: &buf)
    }
}

public func FfiConverterTypeAccountDeposits_lift(_ buf: RustBuffer) throws -> AccountDeposits {
    return try FfiConverterTypeAccountDeposits.lift(buf)
}

public func FfiConverterTypeAccountDeposits_lower(_ value: AccountDeposits) -> RustBuffer {
    return FfiConverterTypeAccountDeposits.lower(value)
}

/**
 * A minimal version of an [`Account`] meant for
 * display purposes within wallet
 */
public struct AccountForDisplay {
    public var address: AccountAddress
    public var displayName: DisplayName
    public var appearanceId: AppearanceId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: AccountAddress, displayName: DisplayName, appearanceId: AppearanceId) {
        self.address = address
        self.displayName = displayName
        self.appearanceId = appearanceId
    }
}

extension AccountForDisplay: Sendable {}
extension AccountForDisplay: Equatable, Hashable {
    public static func == (lhs: AccountForDisplay, rhs: AccountForDisplay) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(appearanceId)
    }
}

public struct FfiConverterTypeAccountForDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountForDisplay {
        return
            try AccountForDisplay(
                address: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf)
            )
    }

    public static func write(_ value: AccountForDisplay, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
    }
}

public func FfiConverterTypeAccountForDisplay_lift(_ buf: RustBuffer) throws -> AccountForDisplay {
    return try FfiConverterTypeAccountForDisplay.lift(buf)
}

public func FfiConverterTypeAccountForDisplay_lower(_ value: AccountForDisplay) -> RustBuffer {
    return FfiConverterTypeAccountForDisplay.lower(value)
}

public struct AccountPath {
    public var networkId: NetworkId
    public var keyKind: Cap26KeyKind
    public var index: Hardened

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, keyKind: Cap26KeyKind, index: Hardened) {
        self.networkId = networkId
        self.keyKind = keyKind
        self.index = index
    }
}

extension AccountPath: Sendable {}
extension AccountPath: Equatable, Hashable {
    public static func == (lhs: AccountPath, rhs: AccountPath) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.keyKind != rhs.keyKind {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(keyKind)
        hasher.combine(index)
    }
}

public struct FfiConverterTypeAccountPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountPath {
        return
            try AccountPath(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                keyKind: FfiConverterTypeCAP26KeyKind.read(from: &buf),
                index: FfiConverterTypeHardened.read(from: &buf)
            )
    }

    public static func write(_ value: AccountPath, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeCAP26KeyKind.write(value.keyKind, into: &buf)
        FfiConverterTypeHardened.write(value.index, into: &buf)
    }
}

public func FfiConverterTypeAccountPath_lift(_ buf: RustBuffer) throws -> AccountPath {
    return try FfiConverterTypeAccountPath.lift(buf)
}

public func FfiConverterTypeAccountPath_lower(_ value: AccountPath) -> RustBuffer {
    return FfiConverterTypeAccountPath.lower(value)
}

/**
 * AES GCM 256 encryption
 */
public struct AesGcm256 {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension AesGcm256: Sendable {}
extension AesGcm256: Equatable, Hashable {
    public static func == (_: AesGcm256, _: AesGcm256) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeAesGcm256: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> AesGcm256 {
        return
            AesGcm256()
    }

    public static func write(_: AesGcm256, into _: inout [UInt8]) {}
}

public func FfiConverterTypeAesGcm256_lift(_ buf: RustBuffer) throws -> AesGcm256 {
    return try FfiConverterTypeAesGcm256.lift(buf)
}

public func FfiConverterTypeAesGcm256_lower(_ value: AesGcm256) -> RustBuffer {
    return FfiConverterTypeAesGcm256.lower(value)
}

/**
 * Settings related to displaying of information to the user inside the app.
 *
 * **N.B. neither of these settings are in fact not yet used by clients.**
 */
public struct AppDisplay {
    /**
     * If we should show the aggregate value of users portfolio in fiat currency
     * of hide it.
     */
    public var isCurrencyAmountVisible: Bool
    /**
     * Which fiat currency the prices are measured in.
     */
    public var fiatCurrencyPriceTarget: FiatCurrency

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If we should show the aggregate value of users portfolio in fiat currency
         * of hide it.
         */ isCurrencyAmountVisible: Bool,
        /**
            * Which fiat currency the prices are measured in.
            */ fiatCurrencyPriceTarget: FiatCurrency
    ) {
        self.isCurrencyAmountVisible = isCurrencyAmountVisible
        self.fiatCurrencyPriceTarget = fiatCurrencyPriceTarget
    }
}

extension AppDisplay: Sendable {}
extension AppDisplay: Equatable, Hashable {
    public static func == (lhs: AppDisplay, rhs: AppDisplay) -> Bool {
        if lhs.isCurrencyAmountVisible != rhs.isCurrencyAmountVisible {
            return false
        }
        if lhs.fiatCurrencyPriceTarget != rhs.fiatCurrencyPriceTarget {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCurrencyAmountVisible)
        hasher.combine(fiatCurrencyPriceTarget)
    }
}

public struct FfiConverterTypeAppDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppDisplay {
        return
            try AppDisplay(
                isCurrencyAmountVisible: FfiConverterBool.read(from: &buf),
                fiatCurrencyPriceTarget: FfiConverterTypeFiatCurrency.read(from: &buf)
            )
    }

    public static func write(_ value: AppDisplay, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCurrencyAmountVisible, into: &buf)
        FfiConverterTypeFiatCurrency.write(value.fiatCurrencyPriceTarget, into: &buf)
    }
}

public func FfiConverterTypeAppDisplay_lift(_ buf: RustBuffer) throws -> AppDisplay {
    return try FfiConverterTypeAppDisplay.lift(buf)
}

public func FfiConverterTypeAppDisplay_lower(_ value: AppDisplay) -> RustBuffer {
    return FfiConverterTypeAppDisplay.lower(value)
}

/**
 * Collection of all settings, preferences and configuration related to how the wallet
 * behaves and looks.
 *
 * Current and other saved Gateways, security settings,
 * App Display settings and preferences for transaction.
 */
public struct AppPreferences {
    /**
     * Display settings in the wallet app, such as appearances, currency etc.
     */
    public var display: AppDisplay
    /**
     * The gateway of the active network and collection of other saved gateways.
     */
    public var gateways: SavedGateways
    /**
     * Controls e.g. if Profile Snapshot gets synced to iCloud/Google backup or not.
     */
    public var security: Security
    /**
     * Default config related to making of transactions
     */
    public var transaction: TransactionPreferences

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Display settings in the wallet app, such as appearances, currency etc.
         */ display: AppDisplay,
        /**
            * The gateway of the active network and collection of other saved gateways.
            */ gateways: SavedGateways,
        /**
            * Controls e.g. if Profile Snapshot gets synced to iCloud/Google backup or not.
            */ security: Security,
        /**
            * Default config related to making of transactions
            */ transaction: TransactionPreferences
    ) {
        self.display = display
        self.gateways = gateways
        self.security = security
        self.transaction = transaction
    }
}

extension AppPreferences: Sendable {}
extension AppPreferences: Equatable, Hashable {
    public static func == (lhs: AppPreferences, rhs: AppPreferences) -> Bool {
        if lhs.display != rhs.display {
            return false
        }
        if lhs.gateways != rhs.gateways {
            return false
        }
        if lhs.security != rhs.security {
            return false
        }
        if lhs.transaction != rhs.transaction {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(display)
        hasher.combine(gateways)
        hasher.combine(security)
        hasher.combine(transaction)
    }
}

public struct FfiConverterTypeAppPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppPreferences {
        return
            try AppPreferences(
                display: FfiConverterTypeAppDisplay.read(from: &buf),
                gateways: FfiConverterTypeSavedGateways.read(from: &buf),
                security: FfiConverterTypeSecurity.read(from: &buf),
                transaction: FfiConverterTypeTransactionPreferences.read(from: &buf)
            )
    }

    public static func write(_ value: AppPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeAppDisplay.write(value.display, into: &buf)
        FfiConverterTypeSavedGateways.write(value.gateways, into: &buf)
        FfiConverterTypeSecurity.write(value.security, into: &buf)
        FfiConverterTypeTransactionPreferences.write(value.transaction, into: &buf)
    }
}

public func FfiConverterTypeAppPreferences_lift(_ buf: RustBuffer) throws -> AppPreferences {
    return try FfiConverterTypeAppPreferences.lift(buf)
}

public func FfiConverterTypeAppPreferences_lower(_ value: AppPreferences) -> RustBuffer {
    return FfiConverterTypeAppPreferences.lower(value)
}

public struct AppearanceId {
    public var value: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: UInt8) {
        self.value = value
    }
}

extension AppearanceId: Sendable {}
extension AppearanceId: Equatable, Hashable {
    public static func == (lhs: AppearanceId, rhs: AppearanceId) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeAppearanceID: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AppearanceId {
        return
            try AppearanceId(
                value: FfiConverterUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: AppearanceId, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeAppearanceID_lift(_ buf: RustBuffer) throws -> AppearanceId {
    return try FfiConverterTypeAppearanceID.lift(buf)
}

public func FfiConverterTypeAppearanceID_lower(_ value: AppearanceId) -> RustBuffer {
    return FfiConverterTypeAppearanceID.lower(value)
}

/**
 * An Arculus card, a hierarchal deterministic wallet capable of CAP26 derivation
 * which users interact with by placing it near their host device, which
 * communicates with the card over NFC.
 */
public struct ArculusCardFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic,
     * that is secured by the Arculus Card.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a ArculusCardFactorSource to help user disambiguate
     * between it and another one.
     */
    public var hint: ArculusCardHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic,
         * that is secured by the Arculus Card.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon,
        /**
            * Properties describing a ArculusCardFactorSource to help user disambiguate
            * between it and another one.
            */ hint: ArculusCardHint
    ) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}

extension ArculusCardFactorSource: Sendable {}
extension ArculusCardFactorSource: Equatable, Hashable {
    public static func == (lhs: ArculusCardFactorSource, rhs: ArculusCardFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}

public struct FfiConverterTypeArculusCardFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCardFactorSource {
        return
            try ArculusCardFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                hint: FfiConverterTypeArculusCardHint.read(from: &buf)
            )
    }

    public static func write(_ value: ArculusCardFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeArculusCardHint.write(value.hint, into: &buf)
    }
}

public func FfiConverterTypeArculusCardFactorSource_lift(_ buf: RustBuffer) throws -> ArculusCardFactorSource {
    return try FfiConverterTypeArculusCardFactorSource.lift(buf)
}

public func FfiConverterTypeArculusCardFactorSource_lower(_ value: ArculusCardFactorSource) -> RustBuffer {
    return FfiConverterTypeArculusCardFactorSource.lower(value)
}

public struct ArculusCardHint {
    /**
     * E.g. "Black" or "Silver"
     */
    public var name: String
    public var model: ArculusCardModel

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * E.g. "Black" or "Silver"
         */ name: String, model: ArculusCardModel
    ) {
        self.name = name
        self.model = model
    }
}

extension ArculusCardHint: Sendable {}
extension ArculusCardHint: Equatable, Hashable {
    public static func == (lhs: ArculusCardHint, rhs: ArculusCardHint) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
    }
}

public struct FfiConverterTypeArculusCardHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCardHint {
        return
            try ArculusCardHint(
                name: FfiConverterString.read(from: &buf),
                model: FfiConverterTypeArculusCardModel.read(from: &buf)
            )
    }

    public static func write(_ value: ArculusCardHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeArculusCardModel.write(value.model, into: &buf)
    }
}

public func FfiConverterTypeArculusCardHint_lift(_ buf: RustBuffer) throws -> ArculusCardHint {
    return try FfiConverterTypeArculusCardHint.lift(buf)
}

public func FfiConverterTypeArculusCardHint_lower(_ value: ArculusCardHint) -> RustBuffer {
    return FfiConverterTypeArculusCardHint.lower(value)
}

/**
 * The specific Asset exception rule, which overrides the general
 * `deposit_rule` of a `ThirdPartyDeposits` settings.
 */
public struct AssetException {
    /**
     * Address of an asset to either deny or allow, as an exception overriding the `ThirdPartyDeposits`'s general `deposit_rule`.
     */
    public var address: ResourceAddress
    /**
     * Either deny or allow the `address`.
     */
    public var exceptionRule: DepositAddressExceptionRule

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Address of an asset to either deny or allow, as an exception overriding the `ThirdPartyDeposits`'s general `deposit_rule`.
         */ address: ResourceAddress,
        /**
            * Either deny or allow the `address`.
            */ exceptionRule: DepositAddressExceptionRule
    ) {
        self.address = address
        self.exceptionRule = exceptionRule
    }
}

extension AssetException: Sendable {}
extension AssetException: Equatable, Hashable {
    public static func == (lhs: AssetException, rhs: AssetException) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.exceptionRule != rhs.exceptionRule {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(exceptionRule)
    }
}

public struct FfiConverterTypeAssetException: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetException {
        return
            try AssetException(
                address: FfiConverterTypeResourceAddress.read(from: &buf),
                exceptionRule: FfiConverterTypeDepositAddressExceptionRule.read(from: &buf)
            )
    }

    public static func write(_ value: AssetException, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.address, into: &buf)
        FfiConverterTypeDepositAddressExceptionRule.write(value.exceptionRule, into: &buf)
    }
}

public func FfiConverterTypeAssetException_lift(_ buf: RustBuffer) throws -> AssetException {
    return try FfiConverterTypeAssetException.lift(buf)
}

public func FfiConverterTypeAssetException_lower(_ value: AssetException) -> RustBuffer {
    return FfiConverterTypeAssetException.lower(value)
}

/**
 * A connection made between a Radix Dapp and the user.
 */
public struct AuthorizedDapp {
    /**
     * The ID of the network the authorized Dapp is on.
     */
    public var networkId: NetworkId
    /**
     * A `DappDefinitionAddress` is in fact just an alias for
     * [`AccountAddress`], it is the address of the account
     * which owns controls the Dapp.
     */
    public var dappDefinitionAddress: AccountAddress
    /**
     * The Display name as sent by the Dapp in any interaction
     * request (CAP21), e.g. "Radix Dashboard".
     */
    public var displayName: String?
    /**
     * An order set of `AuthorizedPersonaSimple`s, which is a collection of all
     * the Personas the user has used to interact with this Dapp, it is called
     * "references to", since the Personas are not stored in full, that would be
     * bad duplication of data (which might go stale), instead we refer to the
     * necessary data by IDs.
     */
    public var referencesToAuthorizedPersonas: [AuthorizedPersonaSimple]
    /**
     * The preferences the user has configured for this Dapp.
     */
    public var preferences: AuthorizedDappPreferences

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network the authorized Dapp is on.
         */ networkId: NetworkId,
        /**
            * A `DappDefinitionAddress` is in fact just an alias for
            * [`AccountAddress`], it is the address of the account
            * which owns controls the Dapp.
            */ dappDefinitionAddress: AccountAddress,
        /**
            * The Display name as sent by the Dapp in any interaction
            * request (CAP21), e.g. "Radix Dashboard".
            */ displayName: String?,
        /**
            * An order set of `AuthorizedPersonaSimple`s, which is a collection of all
            * the Personas the user has used to interact with this Dapp, it is called
            * "references to", since the Personas are not stored in full, that would be
            * bad duplication of data (which might go stale), instead we refer to the
            * necessary data by IDs.
            */ referencesToAuthorizedPersonas: [AuthorizedPersonaSimple],
        /**
            * The preferences the user has configured for this Dapp.
            */ preferences: AuthorizedDappPreferences
    ) {
        self.networkId = networkId
        self.dappDefinitionAddress = dappDefinitionAddress
        self.displayName = displayName
        self.referencesToAuthorizedPersonas = referencesToAuthorizedPersonas
        self.preferences = preferences
    }
}

extension AuthorizedDapp: Sendable {}
extension AuthorizedDapp: Equatable, Hashable {
    public static func == (lhs: AuthorizedDapp, rhs: AuthorizedDapp) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.referencesToAuthorizedPersonas != rhs.referencesToAuthorizedPersonas {
            return false
        }
        if lhs.preferences != rhs.preferences {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(dappDefinitionAddress)
        hasher.combine(displayName)
        hasher.combine(referencesToAuthorizedPersonas)
        hasher.combine(preferences)
    }
}

public struct FfiConverterTypeAuthorizedDapp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDapp {
        return
            try AuthorizedDapp(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterOptionString.read(from: &buf),
                referencesToAuthorizedPersonas: FfiConverterSequenceTypeAuthorizedPersonaSimple.read(from: &buf),
                preferences: FfiConverterTypeAuthorizedDappPreferences.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedDapp, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterSequenceTypeAuthorizedPersonaSimple.write(value.referencesToAuthorizedPersonas, into: &buf)
        FfiConverterTypeAuthorizedDappPreferences.write(value.preferences, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedDapp_lift(_ buf: RustBuffer) throws -> AuthorizedDapp {
    return try FfiConverterTypeAuthorizedDapp.lift(buf)
}

public func FfiConverterTypeAuthorizedDapp_lower(_ value: AuthorizedDapp) -> RustBuffer {
    return FfiConverterTypeAuthorizedDapp.lower(value)
}

public struct AuthorizedDappDetailed {
    public var networkId: NetworkId
    public var dappDefinitionAddress: AccountAddress
    public var displayName: DisplayName?
    public var detailedAuthorizedPersonas: [AuthorizedPersonaDetailed]
    public var preferences: AuthorizedDappPreferences

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, dappDefinitionAddress: AccountAddress, displayName: DisplayName?, detailedAuthorizedPersonas: [AuthorizedPersonaDetailed], preferences: AuthorizedDappPreferences) {
        self.networkId = networkId
        self.dappDefinitionAddress = dappDefinitionAddress
        self.displayName = displayName
        self.detailedAuthorizedPersonas = detailedAuthorizedPersonas
        self.preferences = preferences
    }
}

extension AuthorizedDappDetailed: Sendable {}
extension AuthorizedDappDetailed: Equatable, Hashable {
    public static func == (lhs: AuthorizedDappDetailed, rhs: AuthorizedDappDetailed) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.detailedAuthorizedPersonas != rhs.detailedAuthorizedPersonas {
            return false
        }
        if lhs.preferences != rhs.preferences {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(dappDefinitionAddress)
        hasher.combine(displayName)
        hasher.combine(detailedAuthorizedPersonas)
        hasher.combine(preferences)
    }
}

public struct FfiConverterTypeAuthorizedDappDetailed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappDetailed {
        return
            try AuthorizedDappDetailed(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf),
                displayName: FfiConverterOptionTypeDisplayName.read(from: &buf),
                detailedAuthorizedPersonas: FfiConverterSequenceTypeAuthorizedPersonaDetailed.read(from: &buf),
                preferences: FfiConverterTypeAuthorizedDappPreferences.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedDappDetailed, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
        FfiConverterOptionTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterSequenceTypeAuthorizedPersonaDetailed.write(value.detailedAuthorizedPersonas, into: &buf)
        FfiConverterTypeAuthorizedDappPreferences.write(value.preferences, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedDappDetailed_lift(_ buf: RustBuffer) throws -> AuthorizedDappDetailed {
    return try FfiConverterTypeAuthorizedDappDetailed.lift(buf)
}

public func FfiConverterTypeAuthorizedDappDetailed_lower(_ value: AuthorizedDappDetailed) -> RustBuffer {
    return FfiConverterTypeAuthorizedDappDetailed.lower(value)
}

/**
 * The preferences the user has configured off-ledger for a given `AuthorizedDapp`.
 * Allows users, for example, to hide direct deposit claims for a given Dapp.
 */
public struct AuthorizedDappPreferences {
    public var deposits: AuthorizedDappPreferenceDeposits

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(deposits: AuthorizedDappPreferenceDeposits) {
        self.deposits = deposits
    }
}

extension AuthorizedDappPreferences: Sendable {}
extension AuthorizedDappPreferences: Equatable, Hashable {
    public static func == (lhs: AuthorizedDappPreferences, rhs: AuthorizedDappPreferences) -> Bool {
        if lhs.deposits != rhs.deposits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(deposits)
    }
}

public struct FfiConverterTypeAuthorizedDappPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappPreferences {
        return
            try AuthorizedDappPreferences(
                deposits: FfiConverterTypeAuthorizedDappPreferenceDeposits.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedDappPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeAuthorizedDappPreferenceDeposits.write(value.deposits, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedDappPreferences_lift(_ buf: RustBuffer) throws -> AuthorizedDappPreferences {
    return try FfiConverterTypeAuthorizedDappPreferences.lift(buf)
}

public func FfiConverterTypeAuthorizedDappPreferences_lower(_ value: AuthorizedDappPreferences) -> RustBuffer {
    return FfiConverterTypeAuthorizedDappPreferences.lower(value)
}

public struct AuthorizedPersonaDetailed {
    /**
     * Address that globally and uniquely identifies this Persona.
     */
    public var identityAddress: IdentityAddress
    /**
     * The display name of the Persona, as stored in `Persona`
     */
    public var displayName: DisplayName
    /**
     * Information of accounts the user has given the Dapp access to,
     * being the triple `(accountAddress, displayName, appearanceID)`
     */
    public var simpleAccounts: [AccountForDisplay]?
    /**
     * The persona data that the user has given the Dapp access to
     */
    public var sharedPersonaData: PersonaData
    /**
     * If this persona has an auth sign key created
     */
    public var hasAuthenticationSigningKey: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Address that globally and uniquely identifies this Persona.
         */ identityAddress: IdentityAddress,
        /**
            * The display name of the Persona, as stored in `Persona`
            */ displayName: DisplayName,
        /**
            * Information of accounts the user has given the Dapp access to,
            * being the triple `(accountAddress, displayName, appearanceID)`
            */ simpleAccounts: [AccountForDisplay]?,
        /**
            * The persona data that the user has given the Dapp access to
            */ sharedPersonaData: PersonaData,
        /**
            * If this persona has an auth sign key created
            */ hasAuthenticationSigningKey: Bool
    ) {
        self.identityAddress = identityAddress
        self.displayName = displayName
        self.simpleAccounts = simpleAccounts
        self.sharedPersonaData = sharedPersonaData
        self.hasAuthenticationSigningKey = hasAuthenticationSigningKey
    }
}

extension AuthorizedPersonaDetailed: Sendable {}
extension AuthorizedPersonaDetailed: Equatable, Hashable {
    public static func == (lhs: AuthorizedPersonaDetailed, rhs: AuthorizedPersonaDetailed) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.simpleAccounts != rhs.simpleAccounts {
            return false
        }
        if lhs.sharedPersonaData != rhs.sharedPersonaData {
            return false
        }
        if lhs.hasAuthenticationSigningKey != rhs.hasAuthenticationSigningKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(displayName)
        hasher.combine(simpleAccounts)
        hasher.combine(sharedPersonaData)
        hasher.combine(hasAuthenticationSigningKey)
    }
}

public struct FfiConverterTypeAuthorizedPersonaDetailed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedPersonaDetailed {
        return
            try AuthorizedPersonaDetailed(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                simpleAccounts: FfiConverterOptionSequenceTypeAccountForDisplay.read(from: &buf),
                sharedPersonaData: FfiConverterTypePersonaData.read(from: &buf),
                hasAuthenticationSigningKey: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedPersonaDetailed, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterOptionSequenceTypeAccountForDisplay.write(value.simpleAccounts, into: &buf)
        FfiConverterTypePersonaData.write(value.sharedPersonaData, into: &buf)
        FfiConverterBool.write(value.hasAuthenticationSigningKey, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedPersonaDetailed_lift(_ buf: RustBuffer) throws -> AuthorizedPersonaDetailed {
    return try FfiConverterTypeAuthorizedPersonaDetailed.lift(buf)
}

public func FfiConverterTypeAuthorizedPersonaDetailed_lower(_ value: AuthorizedPersonaDetailed) -> RustBuffer {
    return FfiConverterTypeAuthorizedPersonaDetailed.lower(value)
}

/**
 * Simple data representation of a Persona the user has shared with a Dapp.
 * Simple meaning "the bare minimum amount of data" that enabled `Sargon` to
 * be able to reconstruct a `AuthorizedPersonaDetailed` value, used to populate
 * views.
 *
 * N.B. as of 2024-01-31 of `Sargon` we have not yet implemented the struct
 * `AuthorizedPersonaDetailed` since it is not JSON, but logic, and we have yet
 * to migrate `Sargon` into iOS/Android clients, thus we will defer the work
 * of mapping `AuthorizedPersonaSimple` -> `AuthorizedPersonaDetailed`.
 */
public struct AuthorizedPersonaSimple {
    /**
     * The globally unique identifier of a Persona is its address, used
     * to lookup persona
     */
    public var identityAddress: IdentityAddress
    /**
     * Date of last login for this persona.
     */
    public var lastLogin: Timestamp
    /**
     * List of "ongoing accountAddresses" that user given the dApp access to.
     */
    public var sharedAccounts: SharedToDappWithPersonaAccountAddresses?
    /**
     * ID to PersonaData entries to user has shared with a Dapp.
     */
    public var sharedPersonaData: SharedPersonaData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The globally unique identifier of a Persona is its address, used
         * to lookup persona
         */ identityAddress: IdentityAddress,
        /**
            * Date of last login for this persona.
            */ lastLogin: Timestamp,
        /**
            * List of "ongoing accountAddresses" that user given the dApp access to.
            */ sharedAccounts: SharedToDappWithPersonaAccountAddresses?,
        /**
            * ID to PersonaData entries to user has shared with a Dapp.
            */ sharedPersonaData: SharedPersonaData
    ) {
        self.identityAddress = identityAddress
        self.lastLogin = lastLogin
        self.sharedAccounts = sharedAccounts
        self.sharedPersonaData = sharedPersonaData
    }
}

extension AuthorizedPersonaSimple: Sendable {}
extension AuthorizedPersonaSimple: Equatable, Hashable {
    public static func == (lhs: AuthorizedPersonaSimple, rhs: AuthorizedPersonaSimple) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.lastLogin != rhs.lastLogin {
            return false
        }
        if lhs.sharedAccounts != rhs.sharedAccounts {
            return false
        }
        if lhs.sharedPersonaData != rhs.sharedPersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(lastLogin)
        hasher.combine(sharedAccounts)
        hasher.combine(sharedPersonaData)
    }
}

public struct FfiConverterTypeAuthorizedPersonaSimple: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedPersonaSimple {
        return
            try AuthorizedPersonaSimple(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
                lastLogin: FfiConverterTypeTimestamp.read(from: &buf),
                sharedAccounts: FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses.read(from: &buf),
                sharedPersonaData: FfiConverterTypeSharedPersonaData.read(from: &buf)
            )
    }

    public static func write(_ value: AuthorizedPersonaSimple, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastLogin, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses.write(value.sharedAccounts, into: &buf)
        FfiConverterTypeSharedPersonaData.write(value.sharedPersonaData, into: &buf)
    }
}

public func FfiConverterTypeAuthorizedPersonaSimple_lift(_ buf: RustBuffer) throws -> AuthorizedPersonaSimple {
    return try FfiConverterTypeAuthorizedPersonaSimple.lift(buf)
}

public func FfiConverterTypeAuthorizedPersonaSimple_lower(_ value: AuthorizedPersonaSimple) -> RustBuffer {
    return FfiConverterTypeAuthorizedPersonaSimple.lower(value)
}

/**
 * A BIP39 seed for hierarchal deterministic wallets, as per the [BIP39 standard][doc].
 *
 * We typically obtain this by calling [`to_seed` on `MnemonicWithPassphrase`][MnemonicWithPassphrase::to_seed].
 *
 * [doc]: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#user-content-From_mnemonic_to_seed
 */
public struct Bip39Seed {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Bip39Seed: Sendable {}
extension Bip39Seed: Equatable, Hashable {
    public static func == (lhs: Bip39Seed, rhs: Bip39Seed) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeBIP39Seed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Seed {
        return
            try Bip39Seed(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Bip39Seed, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeBIP39Seed_lift(_ buf: RustBuffer) throws -> Bip39Seed {
    return try FfiConverterTypeBIP39Seed.lift(buf)
}

public func FfiConverterTypeBIP39Seed_lower(_ value: Bip39Seed) -> RustBuffer {
    return FfiConverterTypeBIP39Seed.lower(value)
}

/**
 * A word in the BIP39 word list of `language` at known `index` (0-2047).
 */
public struct Bip39Word {
    public var word: String
    public var index: U11
    public var language: Bip39Language

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(word: String, index: U11, language: Bip39Language) {
        self.word = word
        self.index = index
        self.language = language
    }
}

extension Bip39Word: Sendable {}
extension Bip39Word: Equatable, Hashable {
    public static func == (lhs: Bip39Word, rhs: Bip39Word) -> Bool {
        if lhs.word != rhs.word {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(word)
        hasher.combine(index)
        hasher.combine(language)
    }
}

public struct FfiConverterTypeBIP39Word: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Word {
        return
            try Bip39Word(
                word: FfiConverterString.read(from: &buf),
                index: FfiConverterTypeU11.read(from: &buf),
                language: FfiConverterTypeBIP39Language.read(from: &buf)
            )
    }

    public static func write(_ value: Bip39Word, into buf: inout [UInt8]) {
        FfiConverterString.write(value.word, into: &buf)
        FfiConverterTypeU11.write(value.index, into: &buf)
        FfiConverterTypeBIP39Language.write(value.language, into: &buf)
    }
}

public func FfiConverterTypeBIP39Word_lift(_ buf: RustBuffer) throws -> Bip39Word {
    return try FfiConverterTypeBIP39Word.lift(buf)
}

public func FfiConverterTypeBIP39Word_lower(_ value: Bip39Word) -> RustBuffer {
    return FfiConverterTypeBIP39Word.lower(value)
}

/**
 * Either a canonical BIP44 derivation path like so:
 *
 * `m / purpose' / coin_type' / account' / change / address_index`
 *
 * Or an Radix Olympia BIP44 "like" path, where the `address_index` accidentally
 * was made hardened, i.e.:
 *
 * `m / purpose' / coin_type' / account' / change / address_index'`
 *
 * This was a mistake made during implementation of Radix Olympia.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * fn parse(s: &str) -> Result<BIP44LikePath> {
 * s.parse::<BIP44LikePath>()
 * }
 *
 * assert!(parse("m/44'/1022'/0'/0/0").is_ok()); // Canonical BIP44
 * assert!(parse("m/44'/1022'/0'/0/0'").is_ok()); // BIP44 like
 *
 * assert_eq!(parse("m/44'/1022'/0'/0'/0"), Err(CommonError::InvalidBIP44LikePathChangeWasUnexpectedlyHardened));
 * assert_eq!(parse("m/44'/1022'/0'/0'/0'"), Err(CommonError::InvalidBIP44LikePathChangeWasUnexpectedlyHardened));
 * assert_eq!(parse("m/44'/0'/0'/0/0'"), Err(CommonError::CoinTypeNotFound { bad_value: 0 }));
 * ```
 */
public struct Bip44LikePath {
    public var account: HdPathComponent
    public var change: HdPathComponent
    public var index: HdPathComponent

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(account: HdPathComponent, change: HdPathComponent, index: HdPathComponent) {
        self.account = account
        self.change = change
        self.index = index
    }
}

extension Bip44LikePath: Sendable {}
extension Bip44LikePath: Equatable, Hashable {
    public static func == (lhs: Bip44LikePath, rhs: Bip44LikePath) -> Bool {
        if lhs.account != rhs.account {
            return false
        }
        if lhs.change != rhs.change {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(account)
        hasher.combine(change)
        hasher.combine(index)
    }
}

public struct FfiConverterTypeBIP44LikePath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip44LikePath {
        return
            try Bip44LikePath(
                account: FfiConverterTypeHDPathComponent.read(from: &buf),
                change: FfiConverterTypeHDPathComponent.read(from: &buf),
                index: FfiConverterTypeHDPathComponent.read(from: &buf)
            )
    }

    public static func write(_ value: Bip44LikePath, into buf: inout [UInt8]) {
        FfiConverterTypeHDPathComponent.write(value.account, into: &buf)
        FfiConverterTypeHDPathComponent.write(value.change, into: &buf)
        FfiConverterTypeHDPathComponent.write(value.index, into: &buf)
    }
}

public func FfiConverterTypeBIP44LikePath_lift(_ buf: RustBuffer) throws -> Bip44LikePath {
    return try FfiConverterTypeBIP44LikePath.lift(buf)
}

public func FfiConverterTypeBIP44LikePath_lower(_ value: Bip44LikePath) -> RustBuffer {
    return FfiConverterTypeBIP44LikePath.lower(value)
}

/**
 * Blob is a wrapper a bag of bytes
 */
public struct Blob {
    fileprivate let secretMagic: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BagOfBytes) {
        self.secretMagic = secretMagic
    }
}

extension Blob: Sendable {}
extension Blob: Equatable, Hashable {
    public static func == (lhs: Blob, rhs: Blob) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeBlob: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Blob {
        return
            try Blob(
                secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Blob, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeBlob_lift(_ buf: RustBuffer) throws -> Blob {
    return try FfiConverterTypeBlob.lift(buf)
}

public func FfiConverterTypeBlob_lower(_ value: Blob) -> RustBuffer {
    return FfiConverterTypeBlob.lower(value)
}

/**
 * Vec of Blobs
 */
public struct Blobs {
    fileprivate let secretMagic: [Blob]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: [Blob]) {
        self.secretMagic = secretMagic
    }
}

extension Blobs: Sendable {}
extension Blobs: Equatable, Hashable {
    public static func == (lhs: Blobs, rhs: Blobs) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeBlobs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Blobs {
        return
            try Blobs(
                secretMagic: FfiConverterSequenceTypeBlob.read(from: &buf)
            )
    }

    public static func write(_ value: Blobs, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBlob.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeBlobs_lift(_ buf: RustBuffer) throws -> Blobs {
    return try FfiConverterTypeBlobs.lift(buf)
}

public func FfiConverterTypeBlobs_lower(_ value: Blobs) -> RustBuffer {
    return FfiConverterTypeBlobs.lower(value)
}

/**
 * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
 * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
 * contain elements with the same value, but under different IDs.
 */
public struct CollectionOfEmailAddresses {
    public var collection: [PersonaDataIdentifiedEmailAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(collection: [PersonaDataIdentifiedEmailAddress]) {
        self.collection = collection
    }
}

extension CollectionOfEmailAddresses: Sendable {}
extension CollectionOfEmailAddresses: Equatable, Hashable {
    public static func == (lhs: CollectionOfEmailAddresses, rhs: CollectionOfEmailAddresses) -> Bool {
        if lhs.collection != rhs.collection {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(collection)
    }
}

public struct FfiConverterTypeCollectionOfEmailAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionOfEmailAddresses {
        return
            try CollectionOfEmailAddresses(
                collection: FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress.read(from: &buf)
            )
    }

    public static func write(_ value: CollectionOfEmailAddresses, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress.write(value.collection, into: &buf)
    }
}

public func FfiConverterTypeCollectionOfEmailAddresses_lift(_ buf: RustBuffer) throws -> CollectionOfEmailAddresses {
    return try FfiConverterTypeCollectionOfEmailAddresses.lift(buf)
}

public func FfiConverterTypeCollectionOfEmailAddresses_lower(_ value: CollectionOfEmailAddresses) -> RustBuffer {
    return FfiConverterTypeCollectionOfEmailAddresses.lower(value)
}

/**
 * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
 * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
 * contain elements with the same value, but under different IDs.
 */
public struct CollectionOfPhoneNumbers {
    public var collection: [PersonaDataIdentifiedPhoneNumber]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(collection: [PersonaDataIdentifiedPhoneNumber]) {
        self.collection = collection
    }
}

extension CollectionOfPhoneNumbers: Sendable {}
extension CollectionOfPhoneNumbers: Equatable, Hashable {
    public static func == (lhs: CollectionOfPhoneNumbers, rhs: CollectionOfPhoneNumbers) -> Bool {
        if lhs.collection != rhs.collection {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(collection)
    }
}

public struct FfiConverterTypeCollectionOfPhoneNumbers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionOfPhoneNumbers {
        return
            try CollectionOfPhoneNumbers(
                collection: FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber.read(from: &buf)
            )
    }

    public static func write(_ value: CollectionOfPhoneNumbers, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber.write(value.collection, into: &buf)
    }
}

public func FfiConverterTypeCollectionOfPhoneNumbers_lift(_ buf: RustBuffer) throws -> CollectionOfPhoneNumbers {
    return try FfiConverterTypeCollectionOfPhoneNumbers.lift(buf)
}

public func FfiConverterTypeCollectionOfPhoneNumbers_lower(_ value: CollectionOfPhoneNumbers) -> RustBuffer {
    return FfiConverterTypeCollectionOfPhoneNumbers.lower(value)
}

public struct CompiledNotarizedIntent {
    fileprivate let secretMagic: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BagOfBytes) {
        self.secretMagic = secretMagic
    }
}

extension CompiledNotarizedIntent: Sendable {}
extension CompiledNotarizedIntent: Equatable, Hashable {
    public static func == (lhs: CompiledNotarizedIntent, rhs: CompiledNotarizedIntent) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeCompiledNotarizedIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompiledNotarizedIntent {
        return
            try CompiledNotarizedIntent(
                secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: CompiledNotarizedIntent, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeCompiledNotarizedIntent_lift(_ buf: RustBuffer) throws -> CompiledNotarizedIntent {
    return try FfiConverterTypeCompiledNotarizedIntent.lift(buf)
}

public func FfiConverterTypeCompiledNotarizedIntent_lower(_ value: CompiledNotarizedIntent) -> RustBuffer {
    return FfiConverterTypeCompiledNotarizedIntent.lower(value)
}

public struct CompiledSubintent {
    /**
     * A base-64 encoded version of the compiled subintent
     */
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A base-64 encoded version of the compiled subintent
         */ secretMagic: String
    ) {
        self.secretMagic = secretMagic
    }
}

extension CompiledSubintent: Sendable {}
extension CompiledSubintent: Equatable, Hashable {
    public static func == (lhs: CompiledSubintent, rhs: CompiledSubintent) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeCompiledSubintent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompiledSubintent {
        return
            try CompiledSubintent(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: CompiledSubintent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeCompiledSubintent_lift(_ buf: RustBuffer) throws -> CompiledSubintent {
    return try FfiConverterTypeCompiledSubintent.lift(buf)
}

public func FfiConverterTypeCompiledSubintent_lower(_ value: CompiledSubintent) -> RustBuffer {
    return FfiConverterTypeCompiledSubintent.lower(value)
}

public struct CompiledTransactionIntent {
    /**
     * A base-64 encoded version of the compiled intent
     */
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A base-64 encoded version of the compiled intent
         */ secretMagic: String
    ) {
        self.secretMagic = secretMagic
    }
}

extension CompiledTransactionIntent: Sendable {}
extension CompiledTransactionIntent: Equatable, Hashable {
    public static func == (lhs: CompiledTransactionIntent, rhs: CompiledTransactionIntent) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeCompiledTransactionIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CompiledTransactionIntent {
        return
            try CompiledTransactionIntent(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: CompiledTransactionIntent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeCompiledTransactionIntent_lift(_ buf: RustBuffer) throws -> CompiledTransactionIntent {
    return try FfiConverterTypeCompiledTransactionIntent.lift(buf)
}

public func FfiConverterTypeCompiledTransactionIntent_lower(_ value: CompiledTransactionIntent) -> RustBuffer {
    return FfiConverterTypeCompiledTransactionIntent.lower(value)
}

/**
 * An address to some On-Ledger (OnNetwork) component, e.g. a Dapp, being an instantiation
 * of some Scrypto blueprint, e.g:
 * `"component_rdx1cptxxxxxxxxxfaucetxxxxxxxxx000527798379xxxxxxxxxfaucet"`
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of ComponentAddress:
 * * GlobalGenericComponent
 * * InternalGenericComponent
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalComponentAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L243-L246
 */
public struct ComponentAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}

extension ComponentAddress: Sendable {}
extension ComponentAddress: Equatable, Hashable {
    public static func == (lhs: ComponentAddress, rhs: ComponentAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeComponentAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComponentAddress {
        return
            try ComponentAddress(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: ComponentAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeComponentAddress_lift(_ buf: RustBuffer) throws -> ComponentAddress {
    return try FfiConverterTypeComponentAddress.lift(buf)
}

public func FfiConverterTypeComponentAddress_lower(_ value: ComponentAddress) -> RustBuffer {
    return FfiConverterTypeComponentAddress.lower(value)
}

/**
 * ConfirmationRole is used to confirm recovery.
 */
public struct ConfirmationRoleWithFactorInstances {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorInstance]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorInstance],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorInstance]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension ConfirmationRoleWithFactorInstances: Sendable {}
extension ConfirmationRoleWithFactorInstances: Equatable, Hashable {
    public static func == (lhs: ConfirmationRoleWithFactorInstances, rhs: ConfirmationRoleWithFactorInstances) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypeConfirmationRoleWithFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationRoleWithFactorInstances {
        return
            try ConfirmationRoleWithFactorInstances(
                thresholdFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf)
            )
    }

    public static func write(_ value: ConfirmationRoleWithFactorInstances, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorInstance.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorInstance.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypeConfirmationRoleWithFactorInstances_lift(_ buf: RustBuffer) throws -> ConfirmationRoleWithFactorInstances {
    return try FfiConverterTypeConfirmationRoleWithFactorInstances.lift(buf)
}

public func FfiConverterTypeConfirmationRoleWithFactorInstances_lower(_ value: ConfirmationRoleWithFactorInstances) -> RustBuffer {
    return FfiConverterTypeConfirmationRoleWithFactorInstances.lower(value)
}

/**
 * ConfirmationRole is used to confirm recovery.
 */
public struct ConfirmationRoleWithFactorSourceIDs {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorSourceId]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSourceId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorSourceId],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorSourceId]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension ConfirmationRoleWithFactorSourceIDs: Sendable {}
extension ConfirmationRoleWithFactorSourceIDs: Equatable, Hashable {
    public static func == (lhs: ConfirmationRoleWithFactorSourceIDs, rhs: ConfirmationRoleWithFactorSourceIDs) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypeConfirmationRoleWithFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationRoleWithFactorSourceIDs {
        return
            try ConfirmationRoleWithFactorSourceIDs(
                thresholdFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
            )
    }

    public static func write(_ value: ConfirmationRoleWithFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorSourceID.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSourceID.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypeConfirmationRoleWithFactorSourceIDs_lift(_ buf: RustBuffer) throws -> ConfirmationRoleWithFactorSourceIDs {
    return try FfiConverterTypeConfirmationRoleWithFactorSourceIDs.lift(buf)
}

public func FfiConverterTypeConfirmationRoleWithFactorSourceIDs_lower(_ value: ConfirmationRoleWithFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypeConfirmationRoleWithFactorSourceIDs.lower(value)
}

/**
 * ConfirmationRole is used to confirm recovery.
 */
public struct ConfirmationRoleWithFactorSources {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorSource]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorSource],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorSource]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension ConfirmationRoleWithFactorSources: Sendable {}
extension ConfirmationRoleWithFactorSources: Equatable, Hashable {
    public static func == (lhs: ConfirmationRoleWithFactorSources, rhs: ConfirmationRoleWithFactorSources) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypeConfirmationRoleWithFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfirmationRoleWithFactorSources {
        return
            try ConfirmationRoleWithFactorSources(
                thresholdFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf)
            )
    }

    public static func write(_ value: ConfirmationRoleWithFactorSources, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorSource.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypeConfirmationRoleWithFactorSources_lift(_ buf: RustBuffer) throws -> ConfirmationRoleWithFactorSources {
    return try FfiConverterTypeConfirmationRoleWithFactorSources.lift(buf)
}

public func FfiConverterTypeConfirmationRoleWithFactorSources_lower(_ value: ConfirmationRoleWithFactorSources) -> RustBuffer {
    return FfiConverterTypeConfirmationRoleWithFactorSources.lower(value)
}

/**
 * A hint describing the contents of a Profile, acting as a
 * summary of a Profile used by a ProfileSnapshot Header.
 *
 * Important to know that this is just a **hint**, the values
 * SHOULD be kept up to date, might might not be, since they
 * are stored values which must be kept in sync.
 */
public struct ContentHint {
    /**
     * The total number of accounts on all networks.
     *
     * Important to remember that this is a counter inside a
     * content **hint**. This counter SHOULD be update when
     * new accounts are created, but failing to do is of no
     * real consequence.
     *
     * This counter includes any by user hidden accounts.
     */
    public var numberOfAccountsOnAllNetworksInTotal: UInt16
    /**
     * The total number of personas on all networks.
     *
     * Important to remember that this is a counter inside a
     * content **hint**. This counter SHOULD be update when
     * new accounts are created, but failing to do is of no
     * real consequence.
     *
     * This counter includes any by user hidden personas.
     */
    public var numberOfPersonasOnAllNetworksInTotal: UInt16
    /**
     * The total number of networks that the user has used, i.e.
     * on which she has any accounts or personas.
     */
    public var numberOfNetworks: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The total number of accounts on all networks.
         *
         * Important to remember that this is a counter inside a
         * content **hint**. This counter SHOULD be update when
         * new accounts are created, but failing to do is of no
         * real consequence.
         *
         * This counter includes any by user hidden accounts.
         */ numberOfAccountsOnAllNetworksInTotal: UInt16,
        /**
            * The total number of personas on all networks.
            *
            * Important to remember that this is a counter inside a
            * content **hint**. This counter SHOULD be update when
            * new accounts are created, but failing to do is of no
            * real consequence.
            *
            * This counter includes any by user hidden personas.
            */ numberOfPersonasOnAllNetworksInTotal: UInt16,
        /**
            * The total number of networks that the user has used, i.e.
            * on which she has any accounts or personas.
            */ numberOfNetworks: UInt16
    ) {
        self.numberOfAccountsOnAllNetworksInTotal = numberOfAccountsOnAllNetworksInTotal
        self.numberOfPersonasOnAllNetworksInTotal = numberOfPersonasOnAllNetworksInTotal
        self.numberOfNetworks = numberOfNetworks
    }
}

extension ContentHint: Sendable {}
extension ContentHint: Equatable, Hashable {
    public static func == (lhs: ContentHint, rhs: ContentHint) -> Bool {
        if lhs.numberOfAccountsOnAllNetworksInTotal != rhs.numberOfAccountsOnAllNetworksInTotal {
            return false
        }
        if lhs.numberOfPersonasOnAllNetworksInTotal != rhs.numberOfPersonasOnAllNetworksInTotal {
            return false
        }
        if lhs.numberOfNetworks != rhs.numberOfNetworks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numberOfAccountsOnAllNetworksInTotal)
        hasher.combine(numberOfPersonasOnAllNetworksInTotal)
        hasher.combine(numberOfNetworks)
    }
}

public struct FfiConverterTypeContentHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContentHint {
        return
            try ContentHint(
                numberOfAccountsOnAllNetworksInTotal: FfiConverterUInt16.read(from: &buf),
                numberOfPersonasOnAllNetworksInTotal: FfiConverterUInt16.read(from: &buf),
                numberOfNetworks: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: ContentHint, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.numberOfAccountsOnAllNetworksInTotal, into: &buf)
        FfiConverterUInt16.write(value.numberOfPersonasOnAllNetworksInTotal, into: &buf)
        FfiConverterUInt16.write(value.numberOfNetworks, into: &buf)
    }
}

public func FfiConverterTypeContentHint_lift(_ buf: RustBuffer) throws -> ContentHint {
    return try FfiConverterTypeContentHint.lift(buf)
}

public func FfiConverterTypeContentHint_lower(_ value: ContentHint) -> RustBuffer {
    return FfiConverterTypeContentHint.lower(value)
}

public struct CreateDeleteAccountManifestOutcome {
    public var manifest: TransactionManifest
    public var nonTransferableResources: [ResourceAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(manifest: TransactionManifest, nonTransferableResources: [ResourceAddress]) {
        self.manifest = manifest
        self.nonTransferableResources = nonTransferableResources
    }
}

extension CreateDeleteAccountManifestOutcome: Sendable {}
extension CreateDeleteAccountManifestOutcome: Equatable, Hashable {
    public static func == (lhs: CreateDeleteAccountManifestOutcome, rhs: CreateDeleteAccountManifestOutcome) -> Bool {
        if lhs.manifest != rhs.manifest {
            return false
        }
        if lhs.nonTransferableResources != rhs.nonTransferableResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(manifest)
        hasher.combine(nonTransferableResources)
    }
}

public struct FfiConverterTypeCreateDeleteAccountManifestOutcome: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateDeleteAccountManifestOutcome {
        return
            try CreateDeleteAccountManifestOutcome(
                manifest: FfiConverterTypeTransactionManifest.read(from: &buf),
                nonTransferableResources: FfiConverterSequenceTypeResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: CreateDeleteAccountManifestOutcome, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionManifest.write(value.manifest, into: &buf)
        FfiConverterSequenceTypeResourceAddress.write(value.nonTransferableResources, into: &buf)
    }
}

public func FfiConverterTypeCreateDeleteAccountManifestOutcome_lift(_ buf: RustBuffer) throws -> CreateDeleteAccountManifestOutcome {
    return try FfiConverterTypeCreateDeleteAccountManifestOutcome.lift(buf)
}

public func FfiConverterTypeCreateDeleteAccountManifestOutcome_lower(_ value: CreateDeleteAccountManifestOutcome) -> RustBuffer {
    return FfiConverterTypeCreateDeleteAccountManifestOutcome.lower(value)
}

public struct DappToWalletInteraction {
    public var interactionId: WalletInteractionId
    public var items: DappToWalletInteractionItems
    public var metadata: DappToWalletInteractionMetadata

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, items: DappToWalletInteractionItems, metadata: DappToWalletInteractionMetadata) {
        self.interactionId = interactionId
        self.items = items
        self.metadata = metadata
    }
}

extension DappToWalletInteraction: Sendable {}
extension DappToWalletInteraction: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteraction, rhs: DappToWalletInteraction) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(items)
        hasher.combine(metadata)
    }
}

public struct FfiConverterTypeDappToWalletInteraction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteraction {
        return
            try DappToWalletInteraction(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                items: FfiConverterTypeDappToWalletInteractionItems.read(from: &buf),
                metadata: FfiConverterTypeDappToWalletInteractionMetadata.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteraction, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeDappToWalletInteractionItems.write(value.items, into: &buf)
        FfiConverterTypeDappToWalletInteractionMetadata.write(value.metadata, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteraction_lift(_ buf: RustBuffer) throws -> DappToWalletInteraction {
    return try FfiConverterTypeDappToWalletInteraction.lift(buf)
}

public func FfiConverterTypeDappToWalletInteraction_lower(_ value: DappToWalletInteraction) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteraction.lower(value)
}

public struct DappToWalletInteractionAccountsRequestItem {
    public var numberOfAccounts: RequestedQuantity
    public var challenge: DappToWalletInteractionAuthChallengeNonce?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(numberOfAccounts: RequestedQuantity, challenge: DappToWalletInteractionAuthChallengeNonce?) {
        self.numberOfAccounts = numberOfAccounts
        self.challenge = challenge
    }
}

extension DappToWalletInteractionAccountsRequestItem: Sendable {}
extension DappToWalletInteractionAccountsRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionAccountsRequestItem, rhs: DappToWalletInteractionAccountsRequestItem) -> Bool {
        if lhs.numberOfAccounts != rhs.numberOfAccounts {
            return false
        }
        if lhs.challenge != rhs.challenge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(numberOfAccounts)
        hasher.combine(challenge)
    }
}

public struct FfiConverterTypeDappToWalletInteractionAccountsRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAccountsRequestItem {
        return
            try DappToWalletInteractionAccountsRequestItem(
                numberOfAccounts: FfiConverterTypeRequestedQuantity.read(from: &buf),
                challenge: FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionAccountsRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.numberOfAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionAccountsRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAccountsRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAccountsRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAccountsRequestItem_lower(_ value: DappToWalletInteractionAccountsRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAccountsRequestItem.lower(value)
}

public struct DappToWalletInteractionAuthLoginWithChallengeRequestItem {
    public var challenge: DappToWalletInteractionAuthChallengeNonce

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(challenge: DappToWalletInteractionAuthChallengeNonce) {
        self.challenge = challenge
    }
}

extension DappToWalletInteractionAuthLoginWithChallengeRequestItem: Sendable {}
extension DappToWalletInteractionAuthLoginWithChallengeRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionAuthLoginWithChallengeRequestItem, rhs: DappToWalletInteractionAuthLoginWithChallengeRequestItem) -> Bool {
        if lhs.challenge != rhs.challenge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challenge)
    }
}

public struct FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthLoginWithChallengeRequestItem {
        return
            try DappToWalletInteractionAuthLoginWithChallengeRequestItem(
                challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionAuthLoginWithChallengeRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthLoginWithChallengeRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem_lower(_ value: DappToWalletInteractionAuthLoginWithChallengeRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.lower(value)
}

public struct DappToWalletInteractionAuthUsePersonaRequestItem {
    public var identityAddress: IdentityAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityAddress: IdentityAddress) {
        self.identityAddress = identityAddress
    }
}

extension DappToWalletInteractionAuthUsePersonaRequestItem: Sendable {}
extension DappToWalletInteractionAuthUsePersonaRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionAuthUsePersonaRequestItem, rhs: DappToWalletInteractionAuthUsePersonaRequestItem) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
    }
}

public struct FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthUsePersonaRequestItem {
        return
            try DappToWalletInteractionAuthUsePersonaRequestItem(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionAuthUsePersonaRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthUsePersonaRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem_lower(_ value: DappToWalletInteractionAuthUsePersonaRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.lower(value)
}

public struct DappToWalletInteractionAuthorizedRequestItems {
    public var auth: DappToWalletInteractionAuthRequestItem
    public var reset: DappToWalletInteractionResetRequestItem?
    public var ongoingAccounts: DappToWalletInteractionAccountsRequestItem?
    public var ongoingPersonaData: DappToWalletInteractionPersonaDataRequestItem?
    public var oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?
    public var oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?
    public var proofOfOwnership: DappToWalletInteractionProofOfOwnershipRequestItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(auth: DappToWalletInteractionAuthRequestItem, reset: DappToWalletInteractionResetRequestItem?, ongoingAccounts: DappToWalletInteractionAccountsRequestItem?, ongoingPersonaData: DappToWalletInteractionPersonaDataRequestItem?, oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?, oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?, proofOfOwnership: DappToWalletInteractionProofOfOwnershipRequestItem?) {
        self.auth = auth
        self.reset = reset
        self.ongoingAccounts = ongoingAccounts
        self.ongoingPersonaData = ongoingPersonaData
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
        self.proofOfOwnership = proofOfOwnership
    }
}

extension DappToWalletInteractionAuthorizedRequestItems: Sendable {}
extension DappToWalletInteractionAuthorizedRequestItems: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionAuthorizedRequestItems, rhs: DappToWalletInteractionAuthorizedRequestItems) -> Bool {
        if lhs.auth != rhs.auth {
            return false
        }
        if lhs.reset != rhs.reset {
            return false
        }
        if lhs.ongoingAccounts != rhs.ongoingAccounts {
            return false
        }
        if lhs.ongoingPersonaData != rhs.ongoingPersonaData {
            return false
        }
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        if lhs.proofOfOwnership != rhs.proofOfOwnership {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(auth)
        hasher.combine(reset)
        hasher.combine(ongoingAccounts)
        hasher.combine(ongoingPersonaData)
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
        hasher.combine(proofOfOwnership)
    }
}

public struct FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthorizedRequestItems {
        return
            try DappToWalletInteractionAuthorizedRequestItems(
                auth: FfiConverterTypeDappToWalletInteractionAuthRequestItem.read(from: &buf),
                reset: FfiConverterOptionTypeDappToWalletInteractionResetRequestItem.read(from: &buf),
                ongoingAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf),
                ongoingPersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf),
                oneTimeAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf),
                oneTimePersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf),
                proofOfOwnership: FfiConverterOptionTypeDappToWalletInteractionProofOfOwnershipRequestItem.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionAuthorizedRequestItems, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionAuthRequestItem.write(value.auth, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionResetRequestItem.write(value.reset, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.ongoingAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.ongoingPersonaData, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.oneTimePersonaData, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionProofOfOwnershipRequestItem.write(value.proofOfOwnership, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthorizedRequestItems {
    return try FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems_lower(_ value: DappToWalletInteractionAuthorizedRequestItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.lower(value)
}

public struct DappToWalletInteractionMetadata {
    public var version: WalletInteractionVersion
    public var networkId: NetworkId
    public var origin: DappOrigin
    public var dappDefinitionAddress: AccountAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: WalletInteractionVersion, networkId: NetworkId, origin: DappOrigin, dappDefinitionAddress: AccountAddress) {
        self.version = version
        self.networkId = networkId
        self.origin = origin
        self.dappDefinitionAddress = dappDefinitionAddress
    }
}

extension DappToWalletInteractionMetadata: Sendable {}
extension DappToWalletInteractionMetadata: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionMetadata, rhs: DappToWalletInteractionMetadata) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(networkId)
        hasher.combine(origin)
        hasher.combine(dappDefinitionAddress)
    }
}

public struct FfiConverterTypeDappToWalletInteractionMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionMetadata {
        return
            try DappToWalletInteractionMetadata(
                version: FfiConverterTypeWalletInteractionVersion.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                origin: FfiConverterTypeDappOrigin.read(from: &buf),
                dappDefinitionAddress: FfiConverterTypeAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionVersion.write(value.version, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
        FfiConverterTypeAccountAddress.write(value.dappDefinitionAddress, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionMetadata_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionMetadata {
    return try FfiConverterTypeDappToWalletInteractionMetadata.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionMetadata_lower(_ value: DappToWalletInteractionMetadata) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionMetadata.lower(value)
}

public struct DappToWalletInteractionMetadataUnvalidated {
    public var version: WalletInteractionVersion
    public var networkId: NetworkId
    public var origin: DappOrigin
    public var dappDefinitionAddress: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: WalletInteractionVersion, networkId: NetworkId, origin: DappOrigin, dappDefinitionAddress: String) {
        self.version = version
        self.networkId = networkId
        self.origin = origin
        self.dappDefinitionAddress = dappDefinitionAddress
    }
}

extension DappToWalletInteractionMetadataUnvalidated: Sendable {}
extension DappToWalletInteractionMetadataUnvalidated: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionMetadataUnvalidated, rhs: DappToWalletInteractionMetadataUnvalidated) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.dappDefinitionAddress != rhs.dappDefinitionAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(networkId)
        hasher.combine(origin)
        hasher.combine(dappDefinitionAddress)
    }
}

public struct FfiConverterTypeDappToWalletInteractionMetadataUnvalidated: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionMetadataUnvalidated {
        return
            try DappToWalletInteractionMetadataUnvalidated(
                version: FfiConverterTypeWalletInteractionVersion.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                origin: FfiConverterTypeDappOrigin.read(from: &buf),
                dappDefinitionAddress: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionMetadataUnvalidated, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionVersion.write(value.version, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
        FfiConverterString.write(value.dappDefinitionAddress, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionMetadataUnvalidated_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionMetadataUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionMetadataUnvalidated_lower(_ value: DappToWalletInteractionMetadataUnvalidated) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.lower(value)
}

public struct DappToWalletInteractionPersonaDataRequestItem {
    public var isRequestingName: Bool?
    public var numberOfRequestedEmailAddresses: RequestedQuantity?
    public var numberOfRequestedPhoneNumbers: RequestedQuantity?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isRequestingName: Bool?, numberOfRequestedEmailAddresses: RequestedQuantity?, numberOfRequestedPhoneNumbers: RequestedQuantity?) {
        self.isRequestingName = isRequestingName
        self.numberOfRequestedEmailAddresses = numberOfRequestedEmailAddresses
        self.numberOfRequestedPhoneNumbers = numberOfRequestedPhoneNumbers
    }
}

extension DappToWalletInteractionPersonaDataRequestItem: Sendable {}
extension DappToWalletInteractionPersonaDataRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionPersonaDataRequestItem, rhs: DappToWalletInteractionPersonaDataRequestItem) -> Bool {
        if lhs.isRequestingName != rhs.isRequestingName {
            return false
        }
        if lhs.numberOfRequestedEmailAddresses != rhs.numberOfRequestedEmailAddresses {
            return false
        }
        if lhs.numberOfRequestedPhoneNumbers != rhs.numberOfRequestedPhoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isRequestingName)
        hasher.combine(numberOfRequestedEmailAddresses)
        hasher.combine(numberOfRequestedPhoneNumbers)
    }
}

public struct FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionPersonaDataRequestItem {
        return
            try DappToWalletInteractionPersonaDataRequestItem(
                isRequestingName: FfiConverterOptionBool.read(from: &buf),
                numberOfRequestedEmailAddresses: FfiConverterOptionTypeRequestedQuantity.read(from: &buf),
                numberOfRequestedPhoneNumbers: FfiConverterOptionTypeRequestedQuantity.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionPersonaDataRequestItem, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.isRequestingName, into: &buf)
        FfiConverterOptionTypeRequestedQuantity.write(value.numberOfRequestedEmailAddresses, into: &buf)
        FfiConverterOptionTypeRequestedQuantity.write(value.numberOfRequestedPhoneNumbers, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionPersonaDataRequestItem {
    return try FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem_lower(_ value: DappToWalletInteractionPersonaDataRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.lower(value)
}

public struct DappToWalletInteractionPreAuthorizationItems {
    public var request: DappToWalletInteractionSubintentRequestItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(request: DappToWalletInteractionSubintentRequestItem) {
        self.request = request
    }
}

extension DappToWalletInteractionPreAuthorizationItems: Sendable {}
extension DappToWalletInteractionPreAuthorizationItems: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionPreAuthorizationItems, rhs: DappToWalletInteractionPreAuthorizationItems) -> Bool {
        if lhs.request != rhs.request {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(request)
    }
}

public struct FfiConverterTypeDappToWalletInteractionPreAuthorizationItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionPreAuthorizationItems {
        return
            try DappToWalletInteractionPreAuthorizationItems(
                request: FfiConverterTypeDappToWalletInteractionSubintentRequestItem.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionPreAuthorizationItems, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionSubintentRequestItem.write(value.request, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionPreAuthorizationItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionPreAuthorizationItems {
    return try FfiConverterTypeDappToWalletInteractionPreAuthorizationItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionPreAuthorizationItems_lower(_ value: DappToWalletInteractionPreAuthorizationItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionPreAuthorizationItems.lower(value)
}

/**
 * A request to prove ownership of `Accounts` and/or a `Persona`.
 */
public struct DappToWalletInteractionProofOfOwnershipRequestItem {
    /**
     * The challenge that must be signed to prove ownership.
     */
    public var challenge: DappToWalletInteractionAuthChallengeNonce
    /**
     * The list of `AccountAddress`es for which the wallet must prove ownership.
     */
    public var accountAddresses: [AccountAddress]?
    /**
     * The `IdentityAddress` for which the wallet must prove ownership.
     */
    public var identityAddress: IdentityAddress?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The challenge that must be signed to prove ownership.
         */ challenge: DappToWalletInteractionAuthChallengeNonce,
        /**
            * The list of `AccountAddress`es for which the wallet must prove ownership.
            */ accountAddresses: [AccountAddress]?,
        /**
            * The `IdentityAddress` for which the wallet must prove ownership.
            */ identityAddress: IdentityAddress?
    ) {
        self.challenge = challenge
        self.accountAddresses = accountAddresses
        self.identityAddress = identityAddress
    }
}

extension DappToWalletInteractionProofOfOwnershipRequestItem: Sendable {}
extension DappToWalletInteractionProofOfOwnershipRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionProofOfOwnershipRequestItem, rhs: DappToWalletInteractionProofOfOwnershipRequestItem) -> Bool {
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.accountAddresses != rhs.accountAddresses {
            return false
        }
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challenge)
        hasher.combine(accountAddresses)
        hasher.combine(identityAddress)
    }
}

public struct FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionProofOfOwnershipRequestItem {
        return
            try DappToWalletInteractionProofOfOwnershipRequestItem(
                challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf),
                accountAddresses: FfiConverterOptionSequenceTypeAccountAddress.read(from: &buf),
                identityAddress: FfiConverterOptionTypeIdentityAddress.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionProofOfOwnershipRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
        FfiConverterOptionSequenceTypeAccountAddress.write(value.accountAddresses, into: &buf)
        FfiConverterOptionTypeIdentityAddress.write(value.identityAddress, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionProofOfOwnershipRequestItem {
    return try FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem_lower(_ value: DappToWalletInteractionProofOfOwnershipRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem.lower(value)
}

public struct DappToWalletInteractionResetRequestItem {
    public var accounts: Bool
    public var personaData: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accounts: Bool, personaData: Bool) {
        self.accounts = accounts
        self.personaData = personaData
    }
}

extension DappToWalletInteractionResetRequestItem: Sendable {}
extension DappToWalletInteractionResetRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionResetRequestItem, rhs: DappToWalletInteractionResetRequestItem) -> Bool {
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.personaData != rhs.personaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accounts)
        hasher.combine(personaData)
    }
}

public struct FfiConverterTypeDappToWalletInteractionResetRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionResetRequestItem {
        return
            try DappToWalletInteractionResetRequestItem(
                accounts: FfiConverterBool.read(from: &buf),
                personaData: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionResetRequestItem, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.accounts, into: &buf)
        FfiConverterBool.write(value.personaData, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionResetRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionResetRequestItem {
    return try FfiConverterTypeDappToWalletInteractionResetRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionResetRequestItem_lower(_ value: DappToWalletInteractionResetRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionResetRequestItem.lower(value)
}

public struct DappToWalletInteractionSendTransactionItem {
    public var unvalidatedManifest: UnvalidatedTransactionManifest
    public var version: TxVersion
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(unvalidatedManifest: UnvalidatedTransactionManifest, version: TxVersion, message: String?) {
        self.unvalidatedManifest = unvalidatedManifest
        self.version = version
        self.message = message
    }
}

extension DappToWalletInteractionSendTransactionItem: Sendable {}
extension DappToWalletInteractionSendTransactionItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionSendTransactionItem, rhs: DappToWalletInteractionSendTransactionItem) -> Bool {
        if lhs.unvalidatedManifest != rhs.unvalidatedManifest {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(unvalidatedManifest)
        hasher.combine(version)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeDappToWalletInteractionSendTransactionItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSendTransactionItem {
        return
            try DappToWalletInteractionSendTransactionItem(
                unvalidatedManifest: FfiConverterTypeUnvalidatedTransactionManifest.read(from: &buf),
                version: FfiConverterTypeTXVersion.read(from: &buf),
                message: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionSendTransactionItem, into buf: inout [UInt8]) {
        FfiConverterTypeUnvalidatedTransactionManifest.write(value.unvalidatedManifest, into: &buf)
        FfiConverterTypeTXVersion.write(value.version, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionSendTransactionItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSendTransactionItem {
    return try FfiConverterTypeDappToWalletInteractionSendTransactionItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSendTransactionItem_lower(_ value: DappToWalletInteractionSendTransactionItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSendTransactionItem.lower(value)
}

/**
 * Suggests that the subintent's expiry timestamp is set to `current_time + expire_after_seconds`
 * at the last moment, right before the intent is fixed for signing.
 */
public struct DappToWalletInteractionSubintentExpireAfterDelay {
    /**
     * The time (in seconds) after the subintent is signed that it will expire.
     */
    public var expireAfterSeconds: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The time (in seconds) after the subintent is signed that it will expire.
         */ expireAfterSeconds: UInt64
    ) {
        self.expireAfterSeconds = expireAfterSeconds
    }
}

extension DappToWalletInteractionSubintentExpireAfterDelay: Sendable {}
extension DappToWalletInteractionSubintentExpireAfterDelay: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionSubintentExpireAfterDelay, rhs: DappToWalletInteractionSubintentExpireAfterDelay) -> Bool {
        if lhs.expireAfterSeconds != rhs.expireAfterSeconds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(expireAfterSeconds)
    }
}

public struct FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentExpireAfterDelay {
        return
            try DappToWalletInteractionSubintentExpireAfterDelay(
                expireAfterSeconds: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionSubintentExpireAfterDelay, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.expireAfterSeconds, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentExpireAfterDelay {
    return try FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay_lower(_ value: DappToWalletInteractionSubintentExpireAfterDelay) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay.lower(value)
}

/**
 * The subintent expires at a specific fixed timestamp
 */
public struct DappToWalletInteractionSubintentExpireAtTime {
    /**
     * The unix timestamp in seconds when the subintent expires.
     */
    public var unixTimestampSeconds: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The unix timestamp in seconds when the subintent expires.
         */ unixTimestampSeconds: UInt64
    ) {
        self.unixTimestampSeconds = unixTimestampSeconds
    }
}

extension DappToWalletInteractionSubintentExpireAtTime: Sendable {}
extension DappToWalletInteractionSubintentExpireAtTime: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionSubintentExpireAtTime, rhs: DappToWalletInteractionSubintentExpireAtTime) -> Bool {
        if lhs.unixTimestampSeconds != rhs.unixTimestampSeconds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(unixTimestampSeconds)
    }
}

public struct FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentExpireAtTime {
        return
            try DappToWalletInteractionSubintentExpireAtTime(
                unixTimestampSeconds: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionSubintentExpireAtTime, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.unixTimestampSeconds, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentExpireAtTime {
    return try FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime_lower(_ value: DappToWalletInteractionSubintentExpireAtTime) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime.lower(value)
}

public struct DappToWalletInteractionSubintentRequestItem {
    public var version: SubintentVersion
    public var unvalidatedManifest: UnvalidatedSubintentManifest
    public var message: String?
    public var expiration: DappToWalletInteractionSubintentExpiration

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(version: SubintentVersion, unvalidatedManifest: UnvalidatedSubintentManifest, message: String?, expiration: DappToWalletInteractionSubintentExpiration) {
        self.version = version
        self.unvalidatedManifest = unvalidatedManifest
        self.message = message
        self.expiration = expiration
    }
}

extension DappToWalletInteractionSubintentRequestItem: Sendable {}
extension DappToWalletInteractionSubintentRequestItem: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionSubintentRequestItem, rhs: DappToWalletInteractionSubintentRequestItem) -> Bool {
        if lhs.version != rhs.version {
            return false
        }
        if lhs.unvalidatedManifest != rhs.unvalidatedManifest {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.expiration != rhs.expiration {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(version)
        hasher.combine(unvalidatedManifest)
        hasher.combine(message)
        hasher.combine(expiration)
    }
}

public struct FfiConverterTypeDappToWalletInteractionSubintentRequestItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentRequestItem {
        return
            try DappToWalletInteractionSubintentRequestItem(
                version: FfiConverterTypeSubintentVersion.read(from: &buf),
                unvalidatedManifest: FfiConverterTypeUnvalidatedSubintentManifest.read(from: &buf),
                message: FfiConverterOptionString.read(from: &buf),
                expiration: FfiConverterTypeDappToWalletInteractionSubintentExpiration.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionSubintentRequestItem, into buf: inout [UInt8]) {
        FfiConverterTypeSubintentVersion.write(value.version, into: &buf)
        FfiConverterTypeUnvalidatedSubintentManifest.write(value.unvalidatedManifest, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterTypeDappToWalletInteractionSubintentExpiration.write(value.expiration, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionSubintentRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentRequestItem {
    return try FfiConverterTypeDappToWalletInteractionSubintentRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSubintentRequestItem_lower(_ value: DappToWalletInteractionSubintentRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSubintentRequestItem.lower(value)
}

public struct DappToWalletInteractionTransactionItems {
    public var send: DappToWalletInteractionSendTransactionItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(send: DappToWalletInteractionSendTransactionItem) {
        self.send = send
    }
}

extension DappToWalletInteractionTransactionItems: Sendable {}
extension DappToWalletInteractionTransactionItems: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionTransactionItems, rhs: DappToWalletInteractionTransactionItems) -> Bool {
        if lhs.send != rhs.send {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(send)
    }
}

public struct FfiConverterTypeDappToWalletInteractionTransactionItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionTransactionItems {
        return
            try DappToWalletInteractionTransactionItems(
                send: FfiConverterTypeDappToWalletInteractionSendTransactionItem.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionTransactionItems, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionSendTransactionItem.write(value.send, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionTransactionItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionTransactionItems {
    return try FfiConverterTypeDappToWalletInteractionTransactionItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionTransactionItems_lower(_ value: DappToWalletInteractionTransactionItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionTransactionItems.lower(value)
}

public struct DappToWalletInteractionUnauthorizedRequestItems {
    public var oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?
    public var oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(oneTimeAccounts: DappToWalletInteractionAccountsRequestItem?, oneTimePersonaData: DappToWalletInteractionPersonaDataRequestItem?) {
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
    }
}

extension DappToWalletInteractionUnauthorizedRequestItems: Sendable {}
extension DappToWalletInteractionUnauthorizedRequestItems: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionUnauthorizedRequestItems, rhs: DappToWalletInteractionUnauthorizedRequestItems) -> Bool {
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
    }
}

public struct FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionUnauthorizedRequestItems {
        return
            try DappToWalletInteractionUnauthorizedRequestItems(
                oneTimeAccounts: FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf),
                oneTimePersonaData: FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionUnauthorizedRequestItems, into buf: inout [UInt8]) {
        FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem.write(value.oneTimePersonaData, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionUnauthorizedRequestItems {
    return try FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems_lower(_ value: DappToWalletInteractionUnauthorizedRequestItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.lower(value)
}

public struct DappToWalletInteractionUnvalidated {
    public var interactionId: WalletInteractionId
    public var items: DappToWalletInteractionItems
    public var metadata: DappToWalletInteractionMetadataUnvalidated

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, items: DappToWalletInteractionItems, metadata: DappToWalletInteractionMetadataUnvalidated) {
        self.interactionId = interactionId
        self.items = items
        self.metadata = metadata
    }
}

extension DappToWalletInteractionUnvalidated: Sendable {}
extension DappToWalletInteractionUnvalidated: Equatable, Hashable {
    public static func == (lhs: DappToWalletInteractionUnvalidated, rhs: DappToWalletInteractionUnvalidated) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(items)
        hasher.combine(metadata)
    }
}

public struct FfiConverterTypeDappToWalletInteractionUnvalidated: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionUnvalidated {
        return
            try DappToWalletInteractionUnvalidated(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                items: FfiConverterTypeDappToWalletInteractionItems.read(from: &buf),
                metadata: FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.read(from: &buf)
            )
    }

    public static func write(_ value: DappToWalletInteractionUnvalidated, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeDappToWalletInteractionItems.write(value.items, into: &buf)
        FfiConverterTypeDappToWalletInteractionMetadataUnvalidated.write(value.metadata, into: &buf)
    }
}

public func FfiConverterTypeDappToWalletInteractionUnvalidated_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionUnvalidated.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionUnvalidated_lower(_ value: DappToWalletInteractionUnvalidated) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionUnvalidated.lower(value)
}

public struct DappWalletInteractionPersona {
    public var identityAddress: IdentityAddress
    public var label: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityAddress: IdentityAddress, label: String) {
        self.identityAddress = identityAddress
        self.label = label
    }
}

extension DappWalletInteractionPersona: Sendable {}
extension DappWalletInteractionPersona: Equatable, Hashable {
    public static func == (lhs: DappWalletInteractionPersona, rhs: DappWalletInteractionPersona) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(label)
    }
}

public struct FfiConverterTypeDappWalletInteractionPersona: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappWalletInteractionPersona {
        return
            try DappWalletInteractionPersona(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
                label: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DappWalletInteractionPersona, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
    }
}

public func FfiConverterTypeDappWalletInteractionPersona_lift(_ buf: RustBuffer) throws -> DappWalletInteractionPersona {
    return try FfiConverterTypeDappWalletInteractionPersona.lift(buf)
}

public func FfiConverterTypeDappWalletInteractionPersona_lower(_ value: DappWalletInteractionPersona) -> RustBuffer {
    return FfiConverterTypeDappWalletInteractionPersona.lower(value)
}

/**
 * `Decimal192` represents a 192 bit representation of a fixed-scale decimal number.
 *
 * The finite set of values are of the form `m / 10^18`, where `m` is
 * an integer such that `-2^(192 - 1) <= m < 2^(192 - 1)`.
 *
 * Fractional part: ~60 bits/18 digits
 * Integer part   : 132 bits /40 digits
 * Max            :  3138550867693340381917894711603833208051.177722232017256447
 * Min            : -3138550867693340381917894711603833208051.177722232017256448
 *
 * Unless otherwise specified, all operations will panic if underflow/overflow.
 *
 * Powering it is the [Scrypto Decimal type, see docs][scrypto].
 *
 * Note: This type cannot be called `Decimal`, since it results in naming collision
 * in the Swift land (clash with `Foundation.Decimal`) instead we have created a
 * type alias `Decimal = Decimal192` which we use in Rust land.
 *
 * [scrypto]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/math/decimal.rs#L42
 */
public struct Decimal192 {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}

extension Decimal192: Sendable {}
extension Decimal192: Equatable, Hashable {
    public static func == (lhs: Decimal192, rhs: Decimal192) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeDecimal192: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Decimal192 {
        return
            try Decimal192(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: Decimal192, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeDecimal192_lift(_ buf: RustBuffer) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(buf)
}

public func FfiConverterTypeDecimal192_lower(_ value: Decimal192) -> RustBuffer {
    return FfiConverterTypeDecimal192.lower(value)
}

/**
 * A factor source representing the host device which SargonOS runs on, typically
 * an iPhone or Android device.
 *
 * This is the initial factor source of
 * all new Accounts and Personas. Users authenticate signing by authorizing
 * the host to access a mnemonic stored in secure storage on
 * the device.
 */
public struct DeviceFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a DeviceFactorSource to help user disambiguate between it and another one.
     */
    public var hint: DeviceFactorSourceHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon,
        /**
            * Properties describing a DeviceFactorSource to help user disambiguate between it and another one.
            */ hint: DeviceFactorSourceHint
    ) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}

extension DeviceFactorSource: Sendable {}
extension DeviceFactorSource: Equatable, Hashable {
    public static func == (lhs: DeviceFactorSource, rhs: DeviceFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}

public struct FfiConverterTypeDeviceFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSource {
        return
            try DeviceFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                hint: FfiConverterTypeDeviceFactorSourceHint.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeDeviceFactorSourceHint.write(value.hint, into: &buf)
    }
}

public func FfiConverterTypeDeviceFactorSource_lift(_ buf: RustBuffer) throws -> DeviceFactorSource {
    return try FfiConverterTypeDeviceFactorSource.lift(buf)
}

public func FfiConverterTypeDeviceFactorSource_lower(_ value: DeviceFactorSource) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSource.lower(value)
}

/**
 * Properties describing a DeviceFactorSource to help user disambiguate between
 * it and another one.
 */
public struct DeviceFactorSourceHint {
    /**
     * "iPhone RED"
     */
    public var name: String
    /**
     * "iPhone SE 2nd gen"
     */
    public var model: String
    /**
     * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
     * standard, a multiple of 3, from 12 to 24 words.
     */
    public var mnemonicWordCount: Bip39WordCount
    /**
     * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
     *
     * It is possible that the host device has been updated to a new
     * version than recorded here, but Sargon or host clients might
     * just not have updated this value here.
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var systemVersion: String?
    /**
     * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
     *
     * It is possible that the host device has been updated to a new
     * version than recorded here, but Sargon or host clients might
     * just not have updated this value here.
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var hostAppVersion: String?
    /**
     * The vendor of the device host, e.g. "Apple" or "Samsung".
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var hostVendor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * "iPhone RED"
         */ name: String,
        /**
            * "iPhone SE 2nd gen"
            */ model: String,
        /**
            * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
            * standard, a multiple of 3, from 12 to 24 words.
            */ mnemonicWordCount: Bip39WordCount,
        /**
            * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
            *
            * It is possible that the host device has been updated to a new
            * version than recorded here, but Sargon or host clients might
            * just not have updated this value here.
            *
            * MUST be optional since this was added on 2024-05-03 and
            * was not present in earlier version of wallet (pre 1.6.0).
            */ systemVersion: String?,
        /**
            * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
            *
            * It is possible that the host device has been updated to a new
            * version than recorded here, but Sargon or host clients might
            * just not have updated this value here.
            *
            * MUST be optional since this was added on 2024-05-03 and
            * was not present in earlier version of wallet (pre 1.6.0).
            */ hostAppVersion: String?,
        /**
            * The vendor of the device host, e.g. "Apple" or "Samsung".
            *
            * MUST be optional since this was added on 2024-05-03 and
            * was not present in earlier version of wallet (pre 1.6.0).
            */ hostVendor: String?
    ) {
        self.name = name
        self.model = model
        self.mnemonicWordCount = mnemonicWordCount
        self.systemVersion = systemVersion
        self.hostAppVersion = hostAppVersion
        self.hostVendor = hostVendor
    }
}

extension DeviceFactorSourceHint: Sendable {}
extension DeviceFactorSourceHint: Equatable, Hashable {
    public static func == (lhs: DeviceFactorSourceHint, rhs: DeviceFactorSourceHint) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        if lhs.mnemonicWordCount != rhs.mnemonicWordCount {
            return false
        }
        if lhs.systemVersion != rhs.systemVersion {
            return false
        }
        if lhs.hostAppVersion != rhs.hostAppVersion {
            return false
        }
        if lhs.hostVendor != rhs.hostVendor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
        hasher.combine(mnemonicWordCount)
        hasher.combine(systemVersion)
        hasher.combine(hostAppVersion)
        hasher.combine(hostVendor)
    }
}

public struct FfiConverterTypeDeviceFactorSourceHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSourceHint {
        return
            try DeviceFactorSourceHint(
                name: FfiConverterString.read(from: &buf),
                model: FfiConverterString.read(from: &buf),
                mnemonicWordCount: FfiConverterTypeBIP39WordCount.read(from: &buf),
                systemVersion: FfiConverterOptionString.read(from: &buf),
                hostAppVersion: FfiConverterOptionString.read(from: &buf),
                hostVendor: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceFactorSourceHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.model, into: &buf)
        FfiConverterTypeBIP39WordCount.write(value.mnemonicWordCount, into: &buf)
        FfiConverterOptionString.write(value.systemVersion, into: &buf)
        FfiConverterOptionString.write(value.hostAppVersion, into: &buf)
        FfiConverterOptionString.write(value.hostVendor, into: &buf)
    }
}

public func FfiConverterTypeDeviceFactorSourceHint_lift(_ buf: RustBuffer) throws -> DeviceFactorSourceHint {
    return try FfiConverterTypeDeviceFactorSourceHint.lift(buf)
}

public func FfiConverterTypeDeviceFactorSourceHint_lower(_ value: DeviceFactorSourceHint) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSourceHint.lower(value)
}

/**
 * A short summary of a device the Profile is being used
 * on, typically an iPhone or an Android phone.
 */
public struct DeviceInfo {
    /**
     * A best effort stable and unique identifier of this
     * device.
     *
     * Apple has made it so that iOS devices cannot
     * query iOS for a unique identifier of the device, thus
     * the iOS team has made their own impl of a best effort
     * stable identifier.
     */
    public var id: DeviceId
    /**
     * The date this description of the device was made, might
     * be equal to when the app was first ever launched on the
     * device.
     */
    public var date: Timestamp
    /**
     * A short description of the device, we devices should
     * read the device model and a given name from the device
     * if they are able to.
     */
    public var description: String
    /**
     * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
     *
     * It is possible that the host device has been updated to a new
     * version than recorded here, but Sargon or host clients might
     * just not have updated this value here.
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var systemVersion: String?
    /**
     * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
     *
     * It is possible that the host device has been updated to a new
     * version than recorded here, but Sargon or host clients might
     * just not have updated this value here.
     *
     * MUST be optional since this was added on 2024-05-03 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var hostAppVersion: String?
    /**
     * The vendor of the host client, e.g. "Apple" for iPhone clients,
     * or "Samsung" for Android clients.
     *
     * MUST be optional since this was added on 2024-05-16 and
     * was not present in earlier version of wallet (pre 1.6.0).
     */
    public var hostVendor: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A best effort stable and unique identifier of this
         * device.
         *
         * Apple has made it so that iOS devices cannot
         * query iOS for a unique identifier of the device, thus
         * the iOS team has made their own impl of a best effort
         * stable identifier.
         */ id: DeviceId,
        /**
            * The date this description of the device was made, might
            * be equal to when the app was first ever launched on the
            * device.
            */ date: Timestamp,
        /**
            * A short description of the device, we devices should
            * read the device model and a given name from the device
            * if they are able to.
            */ description: String,
        /**
            * The **last known** version of the device's operating system, e.g. "iOS 17.4.1".
            *
            * It is possible that the host device has been updated to a new
            * version than recorded here, but Sargon or host clients might
            * just not have updated this value here.
            *
            * MUST be optional since this was added on 2024-05-03 and
            * was not present in earlier version of wallet (pre 1.6.0).
            */ systemVersion: String?,
        /**
            * The **last known** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
            *
            * It is possible that the host device has been updated to a new
            * version than recorded here, but Sargon or host clients might
            * just not have updated this value here.
            *
            * MUST be optional since this was added on 2024-05-03 and
            * was not present in earlier version of wallet (pre 1.6.0).
            */ hostAppVersion: String?,
        /**
            * The vendor of the host client, e.g. "Apple" for iPhone clients,
            * or "Samsung" for Android clients.
            *
            * MUST be optional since this was added on 2024-05-16 and
            * was not present in earlier version of wallet (pre 1.6.0).
            */ hostVendor: String?
    ) {
        self.id = id
        self.date = date
        self.description = description
        self.systemVersion = systemVersion
        self.hostAppVersion = hostAppVersion
        self.hostVendor = hostVendor
    }
}

extension DeviceInfo: Sendable {}
extension DeviceInfo: Equatable, Hashable {
    public static func == (lhs: DeviceInfo, rhs: DeviceInfo) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.date != rhs.date {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.systemVersion != rhs.systemVersion {
            return false
        }
        if lhs.hostAppVersion != rhs.hostAppVersion {
            return false
        }
        if lhs.hostVendor != rhs.hostVendor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(date)
        hasher.combine(description)
        hasher.combine(systemVersion)
        hasher.combine(hostAppVersion)
        hasher.combine(hostVendor)
    }
}

public struct FfiConverterTypeDeviceInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceInfo {
        return
            try DeviceInfo(
                id: FfiConverterTypeDeviceID.read(from: &buf),
                date: FfiConverterTypeTimestamp.read(from: &buf),
                description: FfiConverterString.read(from: &buf),
                systemVersion: FfiConverterOptionString.read(from: &buf),
                hostAppVersion: FfiConverterOptionString.read(from: &buf),
                hostVendor: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceInfo, into buf: inout [UInt8]) {
        FfiConverterTypeDeviceID.write(value.id, into: &buf)
        FfiConverterTypeTimestamp.write(value.date, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.systemVersion, into: &buf)
        FfiConverterOptionString.write(value.hostAppVersion, into: &buf)
        FfiConverterOptionString.write(value.hostVendor, into: &buf)
    }
}

public func FfiConverterTypeDeviceInfo_lift(_ buf: RustBuffer) throws -> DeviceInfo {
    return try FfiConverterTypeDeviceInfo.lift(buf)
}

public func FfiConverterTypeDeviceInfo_lower(_ value: DeviceInfo) -> RustBuffer {
    return FfiConverterTypeDeviceInfo.lower(value)
}

/**
 * A name and model of a host device.
 *
 * This used to be a String only in Pre 1.6.0 wallets, so
 * we have a custom Deserialize impl of it.
 */
public struct DeviceInfoDescription {
    /**
     * Host device name, e.g. "My Precious"
     */
    public var name: String
    /**
     * Host device model, e.g. "iPhone 15 Pro"
     */
    public var model: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Host device name, e.g. "My Precious"
         */ name: String,
        /**
            * Host device model, e.g. "iPhone 15 Pro"
            */ model: String
    ) {
        self.name = name
        self.model = model
    }
}

extension DeviceInfoDescription: Sendable {}
extension DeviceInfoDescription: Equatable, Hashable {
    public static func == (lhs: DeviceInfoDescription, rhs: DeviceInfoDescription) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
    }
}

public struct FfiConverterTypeDeviceInfoDescription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceInfoDescription {
        return
            try DeviceInfoDescription(
                name: FfiConverterString.read(from: &buf),
                model: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DeviceInfoDescription, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.model, into: &buf)
    }
}

public func FfiConverterTypeDeviceInfoDescription_lift(_ buf: RustBuffer) throws -> DeviceInfoDescription {
    return try FfiConverterTypeDeviceInfoDescription.lift(buf)
}

public func FfiConverterTypeDeviceInfoDescription_lower(_ value: DeviceInfoDescription) -> RustBuffer {
    return FfiConverterTypeDeviceInfoDescription.lower(value)
}

/**
 * A max 30 chars long string used for display purposes, e.g.
 * the name of an Account or Persona.
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 * #[allow(clippy::upper_case_acronyms)]
 * type SUT = DisplayName;
 *
 * assert_eq!(SUT::MAX_LEN, 30);
 * assert_eq!("Satoshi".parse::<SUT>().unwrap().to_string(), "Satoshi");
 * ```
 *
 * Names with longer than 30 chars are trimmed.
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 * #[allow(clippy::upper_case_acronyms)]
 * type SUT = DisplayName;
 * assert_eq!("A very big name that is over than 30 characters long".parse::<SUT>().unwrap().to_string(), "A very big name that is over t");
 * ```

 */
public struct DisplayName {
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: String) {
        self.value = value
    }
}

extension DisplayName: Sendable {}
extension DisplayName: Equatable, Hashable {
    public static func == (lhs: DisplayName, rhs: DisplayName) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeDisplayName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DisplayName {
        return
            try DisplayName(
                value: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: DisplayName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeDisplayName_lift(_ buf: RustBuffer) throws -> DisplayName {
    return try FfiConverterTypeDisplayName.lift(buf)
}

public func FfiConverterTypeDisplayName_lower(_ value: DisplayName) -> RustBuffer {
    return FfiConverterTypeDisplayName.lower(value)
}

/**
 * An Ed25519 public key used to verify cryptographic signatures (EdDSA signatures).
 */
public struct Ed25519PublicKey {
    fileprivate let secretMagic: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BagOfBytes) {
        self.secretMagic = secretMagic
    }
}

extension Ed25519PublicKey: Sendable {}
extension Ed25519PublicKey: Equatable, Hashable {
    public static func == (lhs: Ed25519PublicKey, rhs: Ed25519PublicKey) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeEd25519PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519PublicKey {
        return
            try Ed25519PublicKey(
                secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Ed25519PublicKey, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeEd25519PublicKey_lift(_ buf: RustBuffer) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(buf)
}

public func FfiConverterTypeEd25519PublicKey_lower(_ value: Ed25519PublicKey) -> RustBuffer {
    return FfiConverterTypeEd25519PublicKey.lower(value)
}

/**
 * Represents an ED25519 signature.
 */
public struct Ed25519Signature {
    public var bytes: Exactly64Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Exactly64Bytes) {
        self.bytes = bytes
    }
}

extension Ed25519Signature: Sendable {}
extension Ed25519Signature: Equatable, Hashable {
    public static func == (lhs: Ed25519Signature, rhs: Ed25519Signature) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}

public struct FfiConverterTypeEd25519Signature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519Signature {
        return
            try Ed25519Signature(
                bytes: FfiConverterTypeExactly64Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: Ed25519Signature, into buf: inout [UInt8]) {
        FfiConverterTypeExactly64Bytes.write(value.bytes, into: &buf)
    }
}

public func FfiConverterTypeEd25519Signature_lift(_ buf: RustBuffer) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(buf)
}

public func FfiConverterTypeEd25519Signature_lower(_ value: Ed25519Signature) -> RustBuffer {
    return FfiConverterTypeEd25519Signature.lower(value)
}

/**
 * An email address.
 *
 * Current implementation does not validate the email address other than it
 * cannot be empty (in the future we might add some simple validation).
 */
public struct EmailAddress {
    public var email: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(email: String) {
        self.email = email
    }
}

extension EmailAddress: Sendable {}
extension EmailAddress: Equatable, Hashable {
    public static func == (lhs: EmailAddress, rhs: EmailAddress) -> Bool {
        if lhs.email != rhs.email {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(email)
    }
}

public struct FfiConverterTypeEmailAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmailAddress {
        return
            try EmailAddress(
                email: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: EmailAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.email, into: &buf)
    }
}

public func FfiConverterTypeEmailAddress_lift(_ buf: RustBuffer) throws -> EmailAddress {
    return try FfiConverterTypeEmailAddress.lift(buf)
}

public func FfiConverterTypeEmailAddress_lower(_ value: EmailAddress) -> RustBuffer {
    return FfiConverterTypeEmailAddress.lower(value)
}

public struct Entropy16Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Entropy16Bytes: Sendable {}
extension Entropy16Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy16Bytes, rhs: Entropy16Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeEntropy16Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy16Bytes {
        return
            try Entropy16Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy16Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeEntropy16Bytes_lift(_ buf: RustBuffer) throws -> Entropy16Bytes {
    return try FfiConverterTypeEntropy16Bytes.lift(buf)
}

public func FfiConverterTypeEntropy16Bytes_lower(_ value: Entropy16Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy16Bytes.lower(value)
}

public struct Entropy20Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Entropy20Bytes: Sendable {}
extension Entropy20Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy20Bytes, rhs: Entropy20Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeEntropy20Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy20Bytes {
        return
            try Entropy20Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy20Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeEntropy20Bytes_lift(_ buf: RustBuffer) throws -> Entropy20Bytes {
    return try FfiConverterTypeEntropy20Bytes.lift(buf)
}

public func FfiConverterTypeEntropy20Bytes_lower(_ value: Entropy20Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy20Bytes.lower(value)
}

public struct Entropy24Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Entropy24Bytes: Sendable {}
extension Entropy24Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy24Bytes, rhs: Entropy24Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeEntropy24Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy24Bytes {
        return
            try Entropy24Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy24Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeEntropy24Bytes_lift(_ buf: RustBuffer) throws -> Entropy24Bytes {
    return try FfiConverterTypeEntropy24Bytes.lift(buf)
}

public func FfiConverterTypeEntropy24Bytes_lower(_ value: Entropy24Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy24Bytes.lower(value)
}

public struct Entropy28Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Entropy28Bytes: Sendable {}
extension Entropy28Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy28Bytes, rhs: Entropy28Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeEntropy28Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy28Bytes {
        return
            try Entropy28Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy28Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeEntropy28Bytes_lift(_ buf: RustBuffer) throws -> Entropy28Bytes {
    return try FfiConverterTypeEntropy28Bytes.lift(buf)
}

public func FfiConverterTypeEntropy28Bytes_lower(_ value: Entropy28Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy28Bytes.lower(value)
}

public struct Entropy32Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Entropy32Bytes: Sendable {}
extension Entropy32Bytes: Equatable, Hashable {
    public static func == (lhs: Entropy32Bytes, rhs: Entropy32Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeEntropy32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Entropy32Bytes {
        return
            try Entropy32Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Entropy32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeEntropy32Bytes_lift(_ buf: RustBuffer) throws -> Entropy32Bytes {
    return try FfiConverterTypeEntropy32Bytes.lift(buf)
}

public func FfiConverterTypeEntropy32Bytes_lower(_ value: Entropy32Bytes) -> RustBuffer {
    return FfiConverterTypeEntropy32Bytes.lower(value)
}

/**
 * A notification containing a timestamped and unique `event`, host client
 * can subscribe to these notifications by using the EventBusDriver.
 */
public struct EventNotification {
    public var id: Uuid
    public var event: Event
    public var timestamp: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Uuid, event: Event, timestamp: Timestamp) {
        self.id = id
        self.event = event
        self.timestamp = timestamp
    }
}

extension EventNotification: Sendable {}
extension EventNotification: Equatable, Hashable {
    public static func == (lhs: EventNotification, rhs: EventNotification) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.event != rhs.event {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(event)
        hasher.combine(timestamp)
    }
}

public struct FfiConverterTypeEventNotification: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventNotification {
        return
            try EventNotification(
                id: FfiConverterTypeUuid.read(from: &buf),
                event: FfiConverterTypeEvent.read(from: &buf),
                timestamp: FfiConverterTypeTimestamp.read(from: &buf)
            )
    }

    public static func write(_ value: EventNotification, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeEvent.write(value.event, into: &buf)
        FfiConverterTypeTimestamp.write(value.timestamp, into: &buf)
    }
}

public func FfiConverterTypeEventNotification_lift(_ buf: RustBuffer) throws -> EventNotification {
    return try FfiConverterTypeEventNotification.lift(buf)
}

public func FfiConverterTypeEventNotification_lower(_ value: EventNotification) -> RustBuffer {
    return FfiConverterTypeEventNotification.lower(value)
}

/**
 * 12 bytes, used by AES encryption, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly12Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Exactly12Bytes: Sendable {}
extension Exactly12Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly12Bytes, rhs: Exactly12Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeExactly12Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly12Bytes {
        return
            try Exactly12Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly12Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeExactly12Bytes_lift(_ buf: RustBuffer) throws -> Exactly12Bytes {
    return try FfiConverterTypeExactly12Bytes.lift(buf)
}

public func FfiConverterTypeExactly12Bytes_lower(_ value: Exactly12Bytes) -> RustBuffer {
    return FfiConverterTypeExactly12Bytes.lower(value)
}

/**
 * 29 bytes, typically used as PublicKeyHash, or otherwise NodeId payload,
 * implementation wise those bytes are stored inside a `BagOfBytes`
 * (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly29Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Exactly29Bytes: Sendable {}
extension Exactly29Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly29Bytes, rhs: Exactly29Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeExactly29Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly29Bytes {
        return
            try Exactly29Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly29Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeExactly29Bytes_lift(_ buf: RustBuffer) throws -> Exactly29Bytes {
    return try FfiConverterTypeExactly29Bytes.lift(buf)
}

public func FfiConverterTypeExactly29Bytes_lower(_ value: Exactly29Bytes) -> RustBuffer {
    return FfiConverterTypeExactly29Bytes.lower(value)
}

/**
 * 32 bytes, most commonly used fixed length bytes, used by PrivateKeys,
 * Ed25519PublicKey, and BIP39 entropy, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly32Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Exactly32Bytes: Sendable {}
extension Exactly32Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly32Bytes, rhs: Exactly32Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeExactly32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly32Bytes {
        return
            try Exactly32Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeExactly32Bytes_lift(_ buf: RustBuffer) throws -> Exactly32Bytes {
    return try FfiConverterTypeExactly32Bytes.lift(buf)
}

public func FfiConverterTypeExactly32Bytes_lower(_ value: Exactly32Bytes) -> RustBuffer {
    return FfiConverterTypeExactly32Bytes.lower(value)
}

/**
 * 33 bytes, used by Secp256k1PublicKeys, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly33Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Exactly33Bytes: Sendable {}
extension Exactly33Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly33Bytes, rhs: Exactly33Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeExactly33Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly33Bytes {
        return
            try Exactly33Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly33Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeExactly33Bytes_lift(_ buf: RustBuffer) throws -> Exactly33Bytes {
    return try FfiConverterTypeExactly33Bytes.lift(buf)
}

public func FfiConverterTypeExactly33Bytes_lower(_ value: Exactly33Bytes) -> RustBuffer {
    return FfiConverterTypeExactly33Bytes.lower(value)
}

/**
 * 60 bytes, used as encrypted mnemonic for security questions factor
 * source. 32 bytes mnemonic when encrypted results in exactly this length.
 */
public struct Exactly60Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Exactly60Bytes: Sendable {}
extension Exactly60Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly60Bytes, rhs: Exactly60Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeExactly60Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly60Bytes {
        return
            try Exactly60Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly60Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeExactly60Bytes_lift(_ buf: RustBuffer) throws -> Exactly60Bytes {
    return try FfiConverterTypeExactly60Bytes.lift(buf)
}

public func FfiConverterTypeExactly60Bytes_lower(_ value: Exactly60Bytes) -> RustBuffer {
    return FfiConverterTypeExactly60Bytes.lower(value)
}

/**
 * 64 bytes, used by Ed25519Signatures, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly64Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Exactly64Bytes: Sendable {}
extension Exactly64Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly64Bytes, rhs: Exactly64Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeExactly64Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly64Bytes {
        return
            try Exactly64Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly64Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeExactly64Bytes_lift(_ buf: RustBuffer) throws -> Exactly64Bytes {
    return try FfiConverterTypeExactly64Bytes.lift(buf)
}

public func FfiConverterTypeExactly64Bytes_lower(_ value: Exactly64Bytes) -> RustBuffer {
    return FfiConverterTypeExactly64Bytes.lower(value)
}

/**
 * 65 bytes, used by Secp256k1Signatures, implementation wise those bytes are
 * stored inside a `BagOfBytes` (wrapper of `Vec<u8>`) for UniFFI compat.
 */
public struct Exactly65Bytes {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension Exactly65Bytes: Sendable {}
extension Exactly65Bytes: Equatable, Hashable {
    public static func == (lhs: Exactly65Bytes, rhs: Exactly65Bytes) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeExactly65Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Exactly65Bytes {
        return
            try Exactly65Bytes(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Exactly65Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeExactly65Bytes_lift(_ buf: RustBuffer) throws -> Exactly65Bytes {
    return try FfiConverterTypeExactly65Bytes.lift(buf)
}

public func FfiConverterTypeExactly65Bytes_lower(_ value: Exactly65Bytes) -> RustBuffer {
    return FfiConverterTypeExactly65Bytes.lower(value)
}

/**
 * A summary of the execution of the manifest and the information that helps
 * wallets present the contents of a transaction.
 */
public struct ExecutionSummary {
    /**
     * Per account, a list of all token balances that has been withdrawn from that account.
     */
    public var withdrawals: [AccountAddress: [ResourceIndicator]]
    /**
     * Per account, a list of all token balances that has been deposited into that account.
     */
    public var deposits: [AccountAddress: [ResourceIndicator]]
    /**
     * Addresses of accounts encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the accounts of all those addresses, which might be multiple
     * signatures per Account, if MFA has been setup.
     */
    public var addressesOfAccountsRequiringAuth: [AccountAddress]
    /**
     * Addresses of identities (Personas) encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the identities of all those addresses, which might be multiple
     * signatures per Persona, if MFA has been setup.
     */
    public var addressesOfIdentitiesRequiringAuth: [IdentityAddress]
    /**
     * Information on the global entities created in the transaction.
     */
    public var newEntities: NewEntities
    /**
     * The various classifications that this manifest matched against. Note
     * that an empty set means that the manifest is non-conforming.
     */
    public var detailedClassification: [DetailedManifestClass]
    /**
     * List of newly created Non-Fungibles during this transaction.
     */
    public var newlyCreatedNonFungibles: [NonFungibleGlobalId]
    /**
     * The set of instructions encountered in the manifest that are reserved
     * and can only be included in the manifest by the wallet itself.
     */
    public var reservedInstructions: [ReservedInstruction]
    /**
     * The list of the resources of proofs that were presented in the manifest.
     */
    public var presentedProofs: [ResourceSpecifier]
    /**
     * The set of all the encountered `ManifestEncounteredComponentAddress`es` in the manifest. This is
     * to be primarily used for the "using dApps" section of the wallet's tx
     * review screen.
     */
    public var encounteredAddresses: [ManifestEncounteredComponentAddress]
    /**
     * Information on how much fees were contingent and how much were not.
     */
    public var feeLocks: FeeLocks
    /**
     * Detailed information on the amount of cost units consumed.
     */
    public var feeSummary: FeeSummary

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Per account, a list of all token balances that has been withdrawn from that account.
         */ withdrawals: [AccountAddress: [ResourceIndicator]],
        /**
            * Per account, a list of all token balances that has been deposited into that account.
            */ deposits: [AccountAddress: [ResourceIndicator]],
        /**
            * Addresses of accounts encountered in the manifest where privileged
            * methods were called. The wallets will need to collect signatures
            * of the accounts of all those addresses, which might be multiple
            * signatures per Account, if MFA has been setup.
            */ addressesOfAccountsRequiringAuth: [AccountAddress],
        /**
            * Addresses of identities (Personas) encountered in the manifest where privileged
            * methods were called. The wallets will need to collect signatures
            * of the identities of all those addresses, which might be multiple
            * signatures per Persona, if MFA has been setup.
            */ addressesOfIdentitiesRequiringAuth: [IdentityAddress],
        /**
            * Information on the global entities created in the transaction.
            */ newEntities: NewEntities,
        /**
            * The various classifications that this manifest matched against. Note
            * that an empty set means that the manifest is non-conforming.
            */ detailedClassification: [DetailedManifestClass],
        /**
            * List of newly created Non-Fungibles during this transaction.
            */ newlyCreatedNonFungibles: [NonFungibleGlobalId],
        /**
            * The set of instructions encountered in the manifest that are reserved
            * and can only be included in the manifest by the wallet itself.
            */ reservedInstructions: [ReservedInstruction],
        /**
            * The list of the resources of proofs that were presented in the manifest.
            */ presentedProofs: [ResourceSpecifier],
        /**
            * The set of all the encountered `ManifestEncounteredComponentAddress`es` in the manifest. This is
            * to be primarily used for the "using dApps" section of the wallet's tx
            * review screen.
            */ encounteredAddresses: [ManifestEncounteredComponentAddress],
        /**
            * Information on how much fees were contingent and how much were not.
            */ feeLocks: FeeLocks,
        /**
            * Detailed information on the amount of cost units consumed.
            */ feeSummary: FeeSummary
    ) {
        self.withdrawals = withdrawals
        self.deposits = deposits
        self.addressesOfAccountsRequiringAuth = addressesOfAccountsRequiringAuth
        self.addressesOfIdentitiesRequiringAuth = addressesOfIdentitiesRequiringAuth
        self.newEntities = newEntities
        self.detailedClassification = detailedClassification
        self.newlyCreatedNonFungibles = newlyCreatedNonFungibles
        self.reservedInstructions = reservedInstructions
        self.presentedProofs = presentedProofs
        self.encounteredAddresses = encounteredAddresses
        self.feeLocks = feeLocks
        self.feeSummary = feeSummary
    }
}

extension ExecutionSummary: Sendable {}
extension ExecutionSummary: Equatable, Hashable {
    public static func == (lhs: ExecutionSummary, rhs: ExecutionSummary) -> Bool {
        if lhs.withdrawals != rhs.withdrawals {
            return false
        }
        if lhs.deposits != rhs.deposits {
            return false
        }
        if lhs.addressesOfAccountsRequiringAuth != rhs.addressesOfAccountsRequiringAuth {
            return false
        }
        if lhs.addressesOfIdentitiesRequiringAuth != rhs.addressesOfIdentitiesRequiringAuth {
            return false
        }
        if lhs.newEntities != rhs.newEntities {
            return false
        }
        if lhs.detailedClassification != rhs.detailedClassification {
            return false
        }
        if lhs.newlyCreatedNonFungibles != rhs.newlyCreatedNonFungibles {
            return false
        }
        if lhs.reservedInstructions != rhs.reservedInstructions {
            return false
        }
        if lhs.presentedProofs != rhs.presentedProofs {
            return false
        }
        if lhs.encounteredAddresses != rhs.encounteredAddresses {
            return false
        }
        if lhs.feeLocks != rhs.feeLocks {
            return false
        }
        if lhs.feeSummary != rhs.feeSummary {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(withdrawals)
        hasher.combine(deposits)
        hasher.combine(addressesOfAccountsRequiringAuth)
        hasher.combine(addressesOfIdentitiesRequiringAuth)
        hasher.combine(newEntities)
        hasher.combine(detailedClassification)
        hasher.combine(newlyCreatedNonFungibles)
        hasher.combine(reservedInstructions)
        hasher.combine(presentedProofs)
        hasher.combine(encounteredAddresses)
        hasher.combine(feeLocks)
        hasher.combine(feeSummary)
    }
}

public struct FfiConverterTypeExecutionSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExecutionSummary {
        return
            try ExecutionSummary(
                withdrawals: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.read(from: &buf),
                deposits: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.read(from: &buf),
                addressesOfAccountsRequiringAuth: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
                addressesOfIdentitiesRequiringAuth: FfiConverterSequenceTypeIdentityAddress.read(from: &buf),
                newEntities: FfiConverterTypeNewEntities.read(from: &buf),
                detailedClassification: FfiConverterSequenceTypeDetailedManifestClass.read(from: &buf),
                newlyCreatedNonFungibles: FfiConverterSequenceTypeNonFungibleGlobalId.read(from: &buf),
                reservedInstructions: FfiConverterSequenceTypeReservedInstruction.read(from: &buf),
                presentedProofs: FfiConverterSequenceTypeResourceSpecifier.read(from: &buf),
                encounteredAddresses: FfiConverterSequenceTypeManifestEncounteredComponentAddress.read(from: &buf),
                feeLocks: FfiConverterTypeFeeLocks.read(from: &buf),
                feeSummary: FfiConverterTypeFeeSummary.read(from: &buf)
            )
    }

    public static func write(_ value: ExecutionSummary, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.write(value.withdrawals, into: &buf)
        FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator.write(value.deposits, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsRequiringAuth, into: &buf)
        FfiConverterSequenceTypeIdentityAddress.write(value.addressesOfIdentitiesRequiringAuth, into: &buf)
        FfiConverterTypeNewEntities.write(value.newEntities, into: &buf)
        FfiConverterSequenceTypeDetailedManifestClass.write(value.detailedClassification, into: &buf)
        FfiConverterSequenceTypeNonFungibleGlobalId.write(value.newlyCreatedNonFungibles, into: &buf)
        FfiConverterSequenceTypeReservedInstruction.write(value.reservedInstructions, into: &buf)
        FfiConverterSequenceTypeResourceSpecifier.write(value.presentedProofs, into: &buf)
        FfiConverterSequenceTypeManifestEncounteredComponentAddress.write(value.encounteredAddresses, into: &buf)
        FfiConverterTypeFeeLocks.write(value.feeLocks, into: &buf)
        FfiConverterTypeFeeSummary.write(value.feeSummary, into: &buf)
    }
}

public func FfiConverterTypeExecutionSummary_lift(_ buf: RustBuffer) throws -> ExecutionSummary {
    return try FfiConverterTypeExecutionSummary.lift(buf)
}

public func FfiConverterTypeExecutionSummary_lower(_ value: ExecutionSummary) -> RustBuffer {
    return FfiConverterTypeExecutionSummary.lower(value)
}

public struct FactorInstance {
    /**
     * The ID of the `FactorSource` that was used to produce this
     * factor instance. We will lookup the `FactorSource` in the
     * `Profile` and can present user with instruction to re-access
     * this factor source in order control the `badge`.
     */
    public var factorSourceId: FactorSourceId
    /**
     * Either a "physical" badge (NFT) or some source for recreation of a producer
     * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
     * is derived which produces virtual badges (signatures).
     */
    public var badge: FactorInstanceBadge

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the `FactorSource` that was used to produce this
         * factor instance. We will lookup the `FactorSource` in the
         * `Profile` and can present user with instruction to re-access
         * this factor source in order control the `badge`.
         */ factorSourceId: FactorSourceId,
        /**
            * Either a "physical" badge (NFT) or some source for recreation of a producer
            * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
            * is derived which produces virtual badges (signatures).
            */ badge: FactorInstanceBadge
    ) {
        self.factorSourceId = factorSourceId
        self.badge = badge
    }
}

extension FactorInstance: Sendable {}
extension FactorInstance: Equatable, Hashable {
    public static func == (lhs: FactorInstance, rhs: FactorInstance) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.badge != rhs.badge {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(badge)
    }
}

public struct FfiConverterTypeFactorInstance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstance {
        return
            try FactorInstance(
                factorSourceId: FfiConverterTypeFactorSourceID.read(from: &buf),
                badge: FfiConverterTypeFactorInstanceBadge.read(from: &buf)
            )
    }

    public static func write(_ value: FactorInstance, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceID.write(value.factorSourceId, into: &buf)
        FfiConverterTypeFactorInstanceBadge.write(value.badge, into: &buf)
    }
}

public func FfiConverterTypeFactorInstance_lift(_ buf: RustBuffer) throws -> FactorInstance {
    return try FfiConverterTypeFactorInstance.lift(buf)
}

public func FfiConverterTypeFactorInstance_lower(_ value: FactorInstance) -> RustBuffer {
    return FfiConverterTypeFactorInstance.lower(value)
}

public struct FactorInstanceForDebugPurposes {
    public var derivationPathFull: String
    public var indexAgnosticDerivationPath: String
    public var publicKeyHex: String
    public var factorSourceId: String
    public var derivationEntityIndex: UInt32
    public var factorSourceKind: FactorSourceKind

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(derivationPathFull: String, indexAgnosticDerivationPath: String, publicKeyHex: String, factorSourceId: String, derivationEntityIndex: UInt32, factorSourceKind: FactorSourceKind) {
        self.derivationPathFull = derivationPathFull
        self.indexAgnosticDerivationPath = indexAgnosticDerivationPath
        self.publicKeyHex = publicKeyHex
        self.factorSourceId = factorSourceId
        self.derivationEntityIndex = derivationEntityIndex
        self.factorSourceKind = factorSourceKind
    }
}

extension FactorInstanceForDebugPurposes: Sendable {}
extension FactorInstanceForDebugPurposes: Equatable, Hashable {
    public static func == (lhs: FactorInstanceForDebugPurposes, rhs: FactorInstanceForDebugPurposes) -> Bool {
        if lhs.derivationPathFull != rhs.derivationPathFull {
            return false
        }
        if lhs.indexAgnosticDerivationPath != rhs.indexAgnosticDerivationPath {
            return false
        }
        if lhs.publicKeyHex != rhs.publicKeyHex {
            return false
        }
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.derivationEntityIndex != rhs.derivationEntityIndex {
            return false
        }
        if lhs.factorSourceKind != rhs.factorSourceKind {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(derivationPathFull)
        hasher.combine(indexAgnosticDerivationPath)
        hasher.combine(publicKeyHex)
        hasher.combine(factorSourceId)
        hasher.combine(derivationEntityIndex)
        hasher.combine(factorSourceKind)
    }
}

public struct FfiConverterTypeFactorInstanceForDebugPurposes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceForDebugPurposes {
        return
            try FactorInstanceForDebugPurposes(
                derivationPathFull: FfiConverterString.read(from: &buf),
                indexAgnosticDerivationPath: FfiConverterString.read(from: &buf),
                publicKeyHex: FfiConverterString.read(from: &buf),
                factorSourceId: FfiConverterString.read(from: &buf),
                derivationEntityIndex: FfiConverterUInt32.read(from: &buf),
                factorSourceKind: FfiConverterTypeFactorSourceKind.read(from: &buf)
            )
    }

    public static func write(_ value: FactorInstanceForDebugPurposes, into buf: inout [UInt8]) {
        FfiConverterString.write(value.derivationPathFull, into: &buf)
        FfiConverterString.write(value.indexAgnosticDerivationPath, into: &buf)
        FfiConverterString.write(value.publicKeyHex, into: &buf)
        FfiConverterString.write(value.factorSourceId, into: &buf)
        FfiConverterUInt32.write(value.derivationEntityIndex, into: &buf)
        FfiConverterTypeFactorSourceKind.write(value.factorSourceKind, into: &buf)
    }
}

public func FfiConverterTypeFactorInstanceForDebugPurposes_lift(_ buf: RustBuffer) throws -> FactorInstanceForDebugPurposes {
    return try FfiConverterTypeFactorInstanceForDebugPurposes.lift(buf)
}

public func FfiConverterTypeFactorInstanceForDebugPurposes_lower(_ value: FactorInstanceForDebugPurposes) -> RustBuffer {
    return FfiConverterTypeFactorInstanceForDebugPurposes.lower(value)
}

/**
 * Common properties shared between FactorSources of different kinds, describing
 * its state, when added, and supported cryptographic parameters.
 */
public struct FactorSourceCommon {
    /**
     * Cryptographic parameters a certain FactorSource supports, e.g. Elliptic Curves.
     *
     * Since Radix Wallet App version 1.3.0, it is possible to add crypto
     * parameters to a FactorSource, e.g. when a user with a DeviceFactorSource
     * with babylon crypto parameters, lets call it `B`, with mnemonic `M` adds
     * `M` again but as an "Olympia" factor source, then the olympia crypto
     * parameters are added to `B`.
     */
    public var cryptoParameters: FactorSourceCryptoParameters
    /**
     * When this factor source for originally added by the user.
     */
    public var addedOn: Timestamp
    /**
     * Date of last usage of this factor source
     *
     * This is the only mutable property, it is mutable
     * since we will update it every time this FactorSource
     * is used.
     */
    public var lastUsedOn: Timestamp
    /**
     * Flags which describe a certain state a FactorSource might be in, e.g. `Main` (BDFS).
     */
    public var flags: [FactorSourceFlag]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Cryptographic parameters a certain FactorSource supports, e.g. Elliptic Curves.
         *
         * Since Radix Wallet App version 1.3.0, it is possible to add crypto
         * parameters to a FactorSource, e.g. when a user with a DeviceFactorSource
         * with babylon crypto parameters, lets call it `B`, with mnemonic `M` adds
         * `M` again but as an "Olympia" factor source, then the olympia crypto
         * parameters are added to `B`.
         */ cryptoParameters: FactorSourceCryptoParameters,
        /**
            * When this factor source for originally added by the user.
            */ addedOn: Timestamp,
        /**
            * Date of last usage of this factor source
            *
            * This is the only mutable property, it is mutable
            * since we will update it every time this FactorSource
            * is used.
            */ lastUsedOn: Timestamp,
        /**
            * Flags which describe a certain state a FactorSource might be in, e.g. `Main` (BDFS).
            */ flags: [FactorSourceFlag]
    ) {
        self.cryptoParameters = cryptoParameters
        self.addedOn = addedOn
        self.lastUsedOn = lastUsedOn
        self.flags = flags
    }
}

extension FactorSourceCommon: Sendable {}
extension FactorSourceCommon: Equatable, Hashable {
    public static func == (lhs: FactorSourceCommon, rhs: FactorSourceCommon) -> Bool {
        if lhs.cryptoParameters != rhs.cryptoParameters {
            return false
        }
        if lhs.addedOn != rhs.addedOn {
            return false
        }
        if lhs.lastUsedOn != rhs.lastUsedOn {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cryptoParameters)
        hasher.combine(addedOn)
        hasher.combine(lastUsedOn)
        hasher.combine(flags)
    }
}

public struct FfiConverterTypeFactorSourceCommon: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceCommon {
        return
            try FactorSourceCommon(
                cryptoParameters: FfiConverterTypeFactorSourceCryptoParameters.read(from: &buf),
                addedOn: FfiConverterTypeTimestamp.read(from: &buf),
                lastUsedOn: FfiConverterTypeTimestamp.read(from: &buf),
                flags: FfiConverterSequenceTypeFactorSourceFlag.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceCommon, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceCryptoParameters.write(value.cryptoParameters, into: &buf)
        FfiConverterTypeTimestamp.write(value.addedOn, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastUsedOn, into: &buf)
        FfiConverterSequenceTypeFactorSourceFlag.write(value.flags, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceCommon_lift(_ buf: RustBuffer) throws -> FactorSourceCommon {
    return try FfiConverterTypeFactorSourceCommon.lift(buf)
}

public func FfiConverterTypeFactorSourceCommon_lower(_ value: FactorSourceCommon) -> RustBuffer {
    return FfiConverterTypeFactorSourceCommon.lower(value)
}

/**
 * Cryptographic parameters a certain FactorSource supports, e.g. which Elliptic Curves
 * it supports and which Hierarchical Deterministic (HD) derivations schemes it supports,
 * if any.
 */
public struct FactorSourceCryptoParameters {
    /**
     * Describes with which Elliptic Curves a Factor Source can be used, e.g. a
     * "Babylon" `DeviceFactorSource` is not capable of deriving keys on the curve
     * `secp256k1` - only Olympia imported FactorSources can do that.
     *
     * Either `[curve25519]` or `[secp256k1, curve25519]`
     *
     * Must not be empty.
     */
    public var supportedCurves: [Slip10Curve]
    /**
     * If not empty: Describes which kind of Hierarchical Deterministic (HD)
     * derivations a FactorSource is capable of doing - if empty: the
     * FactorSource does not support HD derivation.
     *
     * Either BIP44 or CAP26 (SLIP10)
     */
    public var supportedDerivationPathSchemes: [DerivationPathScheme]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Describes with which Elliptic Curves a Factor Source can be used, e.g. a
         * "Babylon" `DeviceFactorSource` is not capable of deriving keys on the curve
         * `secp256k1` - only Olympia imported FactorSources can do that.
         *
         * Either `[curve25519]` or `[secp256k1, curve25519]`
         *
         * Must not be empty.
         */ supportedCurves: [Slip10Curve],
        /**
            * If not empty: Describes which kind of Hierarchical Deterministic (HD)
            * derivations a FactorSource is capable of doing - if empty: the
            * FactorSource does not support HD derivation.
            *
            * Either BIP44 or CAP26 (SLIP10)
            */ supportedDerivationPathSchemes: [DerivationPathScheme]
    ) {
        self.supportedCurves = supportedCurves
        self.supportedDerivationPathSchemes = supportedDerivationPathSchemes
    }
}

extension FactorSourceCryptoParameters: Sendable {}
extension FactorSourceCryptoParameters: Equatable, Hashable {
    public static func == (lhs: FactorSourceCryptoParameters, rhs: FactorSourceCryptoParameters) -> Bool {
        if lhs.supportedCurves != rhs.supportedCurves {
            return false
        }
        if lhs.supportedDerivationPathSchemes != rhs.supportedDerivationPathSchemes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(supportedCurves)
        hasher.combine(supportedDerivationPathSchemes)
    }
}

public struct FfiConverterTypeFactorSourceCryptoParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceCryptoParameters {
        return
            try FactorSourceCryptoParameters(
                supportedCurves: FfiConverterSequenceTypeSLIP10Curve.read(from: &buf),
                supportedDerivationPathSchemes: FfiConverterSequenceTypeDerivationPathScheme.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceCryptoParameters, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeSLIP10Curve.write(value.supportedCurves, into: &buf)
        FfiConverterSequenceTypeDerivationPathScheme.write(value.supportedDerivationPathSchemes, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceCryptoParameters_lift(_ buf: RustBuffer) throws -> FactorSourceCryptoParameters {
    return try FfiConverterTypeFactorSourceCryptoParameters.lift(buf)
}

public func FfiConverterTypeFactorSourceCryptoParameters_lower(_ value: FactorSourceCryptoParameters) -> RustBuffer {
    return FfiConverterTypeFactorSourceCryptoParameters.lower(value)
}

/**
 * FactorSourceID from an AccountAddress, typically used by `trustedContact` FactorSource.
 */
public struct FactorSourceIdFromAddress {
    /**
     * The kind of the FactorSource this ID refers to, typically `trustedContact`.
     */
    public var kind: FactorSourceKind
    /**
     * An account address which the FactorSource this ID refers uses/needs.
     */
    public var body: AccountAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The kind of the FactorSource this ID refers to, typically `trustedContact`.
         */ kind: FactorSourceKind,
        /**
            * An account address which the FactorSource this ID refers uses/needs.
            */ body: AccountAddress
    ) {
        self.kind = kind
        self.body = body
    }
}

extension FactorSourceIdFromAddress: Sendable {}
extension FactorSourceIdFromAddress: Equatable, Hashable {
    public static func == (lhs: FactorSourceIdFromAddress, rhs: FactorSourceIdFromAddress) -> Bool {
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kind)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeFactorSourceIDFromAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIdFromAddress {
        return
            try FactorSourceIdFromAddress(
                kind: FfiConverterTypeFactorSourceKind.read(from: &buf),
                body: FfiConverterTypeAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceIdFromAddress, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.kind, into: &buf)
        FfiConverterTypeAccountAddress.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceIDFromAddress_lift(_ buf: RustBuffer) throws -> FactorSourceIdFromAddress {
    return try FfiConverterTypeFactorSourceIDFromAddress.lift(buf)
}

public func FfiConverterTypeFactorSourceIDFromAddress_lower(_ value: FactorSourceIdFromAddress) -> RustBuffer {
    return FfiConverterTypeFactorSourceIDFromAddress.lower(value)
}

/**
 * FactorSourceID from the blake2b hash of the special HD public key derived at `CAP26::GetID`,
 * for a certain `FactorSourceKind`
 */
public struct FactorSourceIdFromHash {
    /**
     * The kind of the FactorSource this ID refers to, typically `device` or `ledger`.
     */
    public var kind: FactorSourceKind
    /**
     * The blake2b hash of the special HD public key derived at `CAP26::GetID`.
     */
    public var body: Exactly32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The kind of the FactorSource this ID refers to, typically `device` or `ledger`.
         */ kind: FactorSourceKind,
        /**
            * The blake2b hash of the special HD public key derived at `CAP26::GetID`.
            */ body: Exactly32Bytes
    ) {
        self.kind = kind
        self.body = body
    }
}

extension FactorSourceIdFromHash: Sendable {}
extension FactorSourceIdFromHash: Equatable, Hashable {
    public static func == (lhs: FactorSourceIdFromHash, rhs: FactorSourceIdFromHash) -> Bool {
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kind)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeFactorSourceIDFromHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceIdFromHash {
        return
            try FactorSourceIdFromHash(
                kind: FfiConverterTypeFactorSourceKind.read(from: &buf),
                body: FfiConverterTypeExactly32Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: FactorSourceIdFromHash, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceKind.write(value.kind, into: &buf)
        FfiConverterTypeExactly32Bytes.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeFactorSourceIDFromHash_lift(_ buf: RustBuffer) throws -> FactorSourceIdFromHash {
    return try FfiConverterTypeFactorSourceIDFromHash.lift(buf)
}

public func FfiConverterTypeFactorSourceIDFromHash_lower(_ value: FactorSourceIdFromHash) -> RustBuffer {
    return FfiConverterTypeFactorSourceIDFromHash.lower(value)
}

/**
 * Information on how much fees were contingent and how much were not.
 */
public struct FeeLocks {
    public var lock: Decimal192
    public var contingentLock: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lock: Decimal192, contingentLock: Decimal192) {
        self.lock = lock
        self.contingentLock = contingentLock
    }
}

extension FeeLocks: Sendable {}
extension FeeLocks: Equatable, Hashable {
    public static func == (lhs: FeeLocks, rhs: FeeLocks) -> Bool {
        if lhs.lock != rhs.lock {
            return false
        }
        if lhs.contingentLock != rhs.contingentLock {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lock)
        hasher.combine(contingentLock)
    }
}

public struct FfiConverterTypeFeeLocks: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeLocks {
        return
            try FeeLocks(
                lock: FfiConverterTypeDecimal192.read(from: &buf),
                contingentLock: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: FeeLocks, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.lock, into: &buf)
        FfiConverterTypeDecimal192.write(value.contingentLock, into: &buf)
    }
}

public func FfiConverterTypeFeeLocks_lift(_ buf: RustBuffer) throws -> FeeLocks {
    return try FfiConverterTypeFeeLocks.lift(buf)
}

public func FfiConverterTypeFeeLocks_lower(_ value: FeeLocks) -> RustBuffer {
    return FfiConverterTypeFeeLocks.lower(value)
}

/**
 * Detailed information on the amount of cost units consumed.
 */
public struct FeeSummary {
    public var executionCost: Decimal192
    public var finalizationCost: Decimal192
    public var royaltyCost: Decimal192
    public var storageExpansionCost: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(executionCost: Decimal192, finalizationCost: Decimal192, royaltyCost: Decimal192, storageExpansionCost: Decimal192) {
        self.executionCost = executionCost
        self.finalizationCost = finalizationCost
        self.royaltyCost = royaltyCost
        self.storageExpansionCost = storageExpansionCost
    }
}

extension FeeSummary: Sendable {}
extension FeeSummary: Equatable, Hashable {
    public static func == (lhs: FeeSummary, rhs: FeeSummary) -> Bool {
        if lhs.executionCost != rhs.executionCost {
            return false
        }
        if lhs.finalizationCost != rhs.finalizationCost {
            return false
        }
        if lhs.royaltyCost != rhs.royaltyCost {
            return false
        }
        if lhs.storageExpansionCost != rhs.storageExpansionCost {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(executionCost)
        hasher.combine(finalizationCost)
        hasher.combine(royaltyCost)
        hasher.combine(storageExpansionCost)
    }
}

public struct FfiConverterTypeFeeSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSummary {
        return
            try FeeSummary(
                executionCost: FfiConverterTypeDecimal192.read(from: &buf),
                finalizationCost: FfiConverterTypeDecimal192.read(from: &buf),
                royaltyCost: FfiConverterTypeDecimal192.read(from: &buf),
                storageExpansionCost: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: FeeSummary, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.executionCost, into: &buf)
        FfiConverterTypeDecimal192.write(value.finalizationCost, into: &buf)
        FfiConverterTypeDecimal192.write(value.royaltyCost, into: &buf)
        FfiConverterTypeDecimal192.write(value.storageExpansionCost, into: &buf)
    }
}

public func FfiConverterTypeFeeSummary_lift(_ buf: RustBuffer) throws -> FeeSummary {
    return try FfiConverterTypeFeeSummary.lift(buf)
}

public func FfiConverterTypeFeeSummary_lower(_ value: FeeSummary) -> RustBuffer {
    return FfiConverterTypeFeeSummary.lower(value)
}

/**
 * A gateway to some Radix Network, which is a high level REST API which clients (wallets) can
 * consume in order to query asset balances and submit transactions.
 */
public struct Gateway {
    /**
     * The Radix network the API is a Gateway to.
     */
    public var network: NetworkDefinition
    /**
     * The URL to the gateways API endpoint
     */
    public var url: Url

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The Radix network the API is a Gateway to.
         */ network: NetworkDefinition,
        /**
            * The URL to the gateways API endpoint
            */ url: Url
    ) {
        self.network = network
        self.url = url
    }
}

extension Gateway: Sendable {}
extension Gateway: Equatable, Hashable {
    public static func == (lhs: Gateway, rhs: Gateway) -> Bool {
        if lhs.network != rhs.network {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(network)
        hasher.combine(url)
    }
}

public struct FfiConverterTypeGateway: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Gateway {
        return
            try Gateway(
                network: FfiConverterTypeNetworkDefinition.read(from: &buf),
                url: FfiConverterTypeUrl.read(from: &buf)
            )
    }

    public static func write(_ value: Gateway, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkDefinition.write(value.network, into: &buf)
        FfiConverterTypeUrl.write(value.url, into: &buf)
    }
}

public func FfiConverterTypeGateway_lift(_ buf: RustBuffer) throws -> Gateway {
    return try FfiConverterTypeGateway.lift(buf)
}

public func FfiConverterTypeGateway_lower(_ value: Gateway) -> RustBuffer {
    return FfiConverterTypeGateway.lower(value)
}

public struct HdPath {
    public var components: [HdPathComponent]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(components: [HdPathComponent]) {
        self.components = components
    }
}

extension HdPath: Sendable {}
extension HdPath: Equatable, Hashable {
    public static func == (lhs: HdPath, rhs: HdPath) -> Bool {
        if lhs.components != rhs.components {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(components)
    }
}

public struct FfiConverterTypeHDPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdPath {
        return
            try HdPath(
                components: FfiConverterSequenceTypeHDPathComponent.read(from: &buf)
            )
    }

    public static func write(_ value: HdPath, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeHDPathComponent.write(value.components, into: &buf)
    }
}

public func FfiConverterTypeHDPath_lift(_ buf: RustBuffer) throws -> HdPath {
    return try FfiConverterTypeHDPath.lift(buf)
}

public func FfiConverterTypeHDPath_lower(_ value: HdPath) -> RustBuffer {
    return FfiConverterTypeHDPath.lower(value)
}

/**
 * Represents a 32-byte hash digest.
 *
 * Made UniFFI convertible via HashSecretMagic,
 * exposed in Swift/Kotlin as its own struct/data class, with
 * hidden secret magic.
 */
public struct Hash {
    public var value: Exactly32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Exactly32Bytes) {
        self.value = value
    }
}

extension Hash: Sendable {}
extension Hash: Equatable, Hashable {
    public static func == (lhs: Hash, rhs: Hash) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hash {
        return
            try Hash(
                value: FfiConverterTypeExactly32Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: Hash, into buf: inout [UInt8]) {
        FfiConverterTypeExactly32Bytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeHash_lift(_ buf: RustBuffer) throws -> Hash {
    return try FfiConverterTypeHash.lift(buf)
}

public func FfiConverterTypeHash_lower(_ value: Hash) -> RustBuffer {
    return FfiConverterTypeHash.lower(value)
}

/**
 * The header of a Profile(Snapshot) contains crucial metadata
 * about this Profile, such as which JSON data format it is
 * compatible with and which device was used to create it and
 * a hint about its contents.
 */
public struct Header {
    /**
     * A versioning number that is increased when breaking
     * changes is made to ProfileSnapshot JSON data format.
     */
    public var snapshotVersion: ProfileSnapshotVersion
    /**
     * An immutable and unique identifier of a Profile.
     */
    public var id: ProfileId
    /**
     * The device which was used to create the Profile.
     */
    public var creatingDevice: DeviceInfo
    /**
     * The device on which the profile was last used.
     */
    public var lastUsedOnDevice: DeviceInfo
    /**
     * When the Profile was last modified.
     */
    public var lastModified: Timestamp
    /**
     * Hint about the contents of the profile, e.g. number of Accounts and Personas.
     */
    public var contentHint: ContentHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A versioning number that is increased when breaking
         * changes is made to ProfileSnapshot JSON data format.
         */ snapshotVersion: ProfileSnapshotVersion,
        /**
            * An immutable and unique identifier of a Profile.
            */ id: ProfileId,
        /**
            * The device which was used to create the Profile.
            */ creatingDevice: DeviceInfo,
        /**
            * The device on which the profile was last used.
            */ lastUsedOnDevice: DeviceInfo,
        /**
            * When the Profile was last modified.
            */ lastModified: Timestamp,
        /**
            * Hint about the contents of the profile, e.g. number of Accounts and Personas.
            */ contentHint: ContentHint
    ) {
        self.snapshotVersion = snapshotVersion
        self.id = id
        self.creatingDevice = creatingDevice
        self.lastUsedOnDevice = lastUsedOnDevice
        self.lastModified = lastModified
        self.contentHint = contentHint
    }
}

extension Header: Sendable {}
extension Header: Equatable, Hashable {
    public static func == (lhs: Header, rhs: Header) -> Bool {
        if lhs.snapshotVersion != rhs.snapshotVersion {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.creatingDevice != rhs.creatingDevice {
            return false
        }
        if lhs.lastUsedOnDevice != rhs.lastUsedOnDevice {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.contentHint != rhs.contentHint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(snapshotVersion)
        hasher.combine(id)
        hasher.combine(creatingDevice)
        hasher.combine(lastUsedOnDevice)
        hasher.combine(lastModified)
        hasher.combine(contentHint)
    }
}

public struct FfiConverterTypeHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Header {
        return
            try Header(
                snapshotVersion: FfiConverterTypeProfileSnapshotVersion.read(from: &buf),
                id: FfiConverterTypeProfileID.read(from: &buf),
                creatingDevice: FfiConverterTypeDeviceInfo.read(from: &buf),
                lastUsedOnDevice: FfiConverterTypeDeviceInfo.read(from: &buf),
                lastModified: FfiConverterTypeTimestamp.read(from: &buf),
                contentHint: FfiConverterTypeContentHint.read(from: &buf)
            )
    }

    public static func write(_ value: Header, into buf: inout [UInt8]) {
        FfiConverterTypeProfileSnapshotVersion.write(value.snapshotVersion, into: &buf)
        FfiConverterTypeProfileID.write(value.id, into: &buf)
        FfiConverterTypeDeviceInfo.write(value.creatingDevice, into: &buf)
        FfiConverterTypeDeviceInfo.write(value.lastUsedOnDevice, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastModified, into: &buf)
        FfiConverterTypeContentHint.write(value.contentHint, into: &buf)
    }
}

public func FfiConverterTypeHeader_lift(_ buf: RustBuffer) throws -> Header {
    return try FfiConverterTypeHeader.lift(buf)
}

public func FfiConverterTypeHeader_lower(_ value: Header) -> RustBuffer {
    return FfiConverterTypeHeader.lower(value)
}

public struct HiddenConstructor {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension HiddenConstructor: Sendable {}
extension HiddenConstructor: Equatable, Hashable {
    public static func == (_: HiddenConstructor, _: HiddenConstructor) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeHiddenConstructor: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> HiddenConstructor {
        return
            HiddenConstructor()
    }

    public static func write(_: HiddenConstructor, into _: inout [UInt8]) {}
}

public func FfiConverterTypeHiddenConstructor_lift(_ buf: RustBuffer) throws -> HiddenConstructor {
    return try FfiConverterTypeHiddenConstructor.lift(buf)
}

public func FfiConverterTypeHiddenConstructor_lower(_ value: HiddenConstructor) -> RustBuffer {
    return FfiConverterTypeHiddenConstructor.lower(value)
}

/**
 * A virtual hierarchical deterministic `FactorInstance`
 */
public struct HierarchicalDeterministicFactorInstance {
    public var factorSourceId: FactorSourceIdFromHash
    public var publicKey: HierarchicalDeterministicPublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(factorSourceId: FactorSourceIdFromHash, publicKey: HierarchicalDeterministicPublicKey) {
        self.factorSourceId = factorSourceId
        self.publicKey = publicKey
    }
}

extension HierarchicalDeterministicFactorInstance: Sendable {}
extension HierarchicalDeterministicFactorInstance: Equatable, Hashable {
    public static func == (lhs: HierarchicalDeterministicFactorInstance, rhs: HierarchicalDeterministicFactorInstance) -> Bool {
        if lhs.factorSourceId != rhs.factorSourceId {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(factorSourceId)
        hasher.combine(publicKey)
    }
}

public struct FfiConverterTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HierarchicalDeterministicFactorInstance {
        return
            try HierarchicalDeterministicFactorInstance(
                factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                publicKey: FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: HierarchicalDeterministicFactorInstance, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.factorSourceId, into: &buf)
        FfiConverterTypeHierarchicalDeterministicPublicKey.write(value.publicKey, into: &buf)
    }
}

public func FfiConverterTypeHierarchicalDeterministicFactorInstance_lift(_ buf: RustBuffer) throws -> HierarchicalDeterministicFactorInstance {
    return try FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(buf)
}

public func FfiConverterTypeHierarchicalDeterministicFactorInstance_lower(_ value: HierarchicalDeterministicFactorInstance) -> RustBuffer {
    return FfiConverterTypeHierarchicalDeterministicFactorInstance.lower(value)
}

/**
 * The **source** of a virtual hierarchical deterministic badge, contains a
 * derivation path and public key, from which a private key is derived which
 * produces virtual badges (signatures).
 *
 * The `.device` `FactorSource` produces `FactorInstance`s with this kind if badge source.
 */
public struct HierarchicalDeterministicPublicKey {
    /**
     * The expected public key of the private key derived at `derivationPath`
     */
    public var publicKey: PublicKey
    /**
     * The HD derivation path for the key pair which produces virtual badges (signatures).
     */
    public var derivationPath: DerivationPath

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The expected public key of the private key derived at `derivationPath`
         */ publicKey: PublicKey,
        /**
            * The HD derivation path for the key pair which produces virtual badges (signatures).
            */ derivationPath: DerivationPath
    ) {
        self.publicKey = publicKey
        self.derivationPath = derivationPath
    }
}

extension HierarchicalDeterministicPublicKey: Sendable {}
extension HierarchicalDeterministicPublicKey: Equatable, Hashable {
    public static func == (lhs: HierarchicalDeterministicPublicKey, rhs: HierarchicalDeterministicPublicKey) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.derivationPath != rhs.derivationPath {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(derivationPath)
    }
}

public struct FfiConverterTypeHierarchicalDeterministicPublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HierarchicalDeterministicPublicKey {
        return
            try HierarchicalDeterministicPublicKey(
                publicKey: FfiConverterTypePublicKey.read(from: &buf),
                derivationPath: FfiConverterTypeDerivationPath.read(from: &buf)
            )
    }

    public static func write(_ value: HierarchicalDeterministicPublicKey, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterTypeDerivationPath.write(value.derivationPath, into: &buf)
    }
}

public func FfiConverterTypeHierarchicalDeterministicPublicKey_lift(_ buf: RustBuffer) throws -> HierarchicalDeterministicPublicKey {
    return try FfiConverterTypeHierarchicalDeterministicPublicKey.lift(buf)
}

public func FfiConverterTypeHierarchicalDeterministicPublicKey_lower(_ value: HierarchicalDeterministicPublicKey) -> RustBuffer {
    return FfiConverterTypeHierarchicalDeterministicPublicKey.lower(value)
}

public struct HostId {
    /**
     * A best effort stable and unique identifier of this
     * host's device.
     */
    public var id: DeviceId
    /**
     * The date this id of the device was generated, might
     * be equal to when the app was first ever launched on the
     * device.
     */
    public var generatedAt: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A best effort stable and unique identifier of this
         * host's device.
         */ id: DeviceId,
        /**
            * The date this id of the device was generated, might
            * be equal to when the app was first ever launched on the
            * device.
            */ generatedAt: Timestamp
    ) {
        self.id = id
        self.generatedAt = generatedAt
    }
}

extension HostId: Sendable {}
extension HostId: Equatable, Hashable {
    public static func == (lhs: HostId, rhs: HostId) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.generatedAt != rhs.generatedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(generatedAt)
    }
}

public struct FfiConverterTypeHostId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostId {
        return
            try HostId(
                id: FfiConverterTypeDeviceID.read(from: &buf),
                generatedAt: FfiConverterTypeTimestamp.read(from: &buf)
            )
    }

    public static func write(_ value: HostId, into buf: inout [UInt8]) {
        FfiConverterTypeDeviceID.write(value.id, into: &buf)
        FfiConverterTypeTimestamp.write(value.generatedAt, into: &buf)
    }
}

public func FfiConverterTypeHostId_lift(_ buf: RustBuffer) throws -> HostId {
    return try FfiConverterTypeHostId.lift(buf)
}

public func FfiConverterTypeHostId_lower(_ value: HostId) -> RustBuffer {
    return FfiConverterTypeHostId.lower(value)
}

public struct HostInfo {
    /**
     * A short description of the device. The host should
     * read the device model and a given name from the device
     * if they are able to.
     */
    public var description: DeviceInfoDescription
    /**
     * The **current** os and version of the device's operating system, e.g. "iOS 17.4.1".
     */
    public var hostOs: HostOs
    /**
     * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
     */
    public var hostAppVersion: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A short description of the device. The host should
         * read the device model and a given name from the device
         * if they are able to.
         */ description: DeviceInfoDescription,
        /**
            * The **current** os and version of the device's operating system, e.g. "iOS 17.4.1".
            */ hostOs: HostOs,
        /**
            * The **current** version of the host app, for example the Radix iOS Wallet version - e.g. "1.6.1"
            */ hostAppVersion: String
    ) {
        self.description = description
        self.hostOs = hostOs
        self.hostAppVersion = hostAppVersion
    }
}

extension HostInfo: Sendable {}
extension HostInfo: Equatable, Hashable {
    public static func == (lhs: HostInfo, rhs: HostInfo) -> Bool {
        if lhs.description != rhs.description {
            return false
        }
        if lhs.hostOs != rhs.hostOs {
            return false
        }
        if lhs.hostAppVersion != rhs.hostAppVersion {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(description)
        hasher.combine(hostOs)
        hasher.combine(hostAppVersion)
    }
}

public struct FfiConverterTypeHostInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostInfo {
        return
            try HostInfo(
                description: FfiConverterTypeDeviceInfoDescription.read(from: &buf),
                hostOs: FfiConverterTypeHostOS.read(from: &buf),
                hostAppVersion: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: HostInfo, into buf: inout [UInt8]) {
        FfiConverterTypeDeviceInfoDescription.write(value.description, into: &buf)
        FfiConverterTypeHostOS.write(value.hostOs, into: &buf)
        FfiConverterString.write(value.hostAppVersion, into: &buf)
    }
}

public func FfiConverterTypeHostInfo_lift(_ buf: RustBuffer) throws -> HostInfo {
    return try FfiConverterTypeHostInfo.lift(buf)
}

public func FfiConverterTypeHostInfo_lower(_ value: HostInfo) -> RustBuffer {
    return FfiConverterTypeHostInfo.lower(value)
}

/**
 * Human readable address of an identity, which are used by Personas. Always starts with
 * the prefix `"identity_"`, for example:
 *
 * `identity_rdx12tgzjrz9u0xz4l28vf04hz87eguclmfaq4d2p8f8lv7zg9ssnzku8j`
 *
 * Addresses are checksummed, as per Bech32. **Only** *Identity* addresses starts with
 * the prefix `"identity_"`.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of IdentityAddresses:
 * * GlobalIdentity,
 * * GlobalVirtualSecp256k1Identity,
 * * GlobalVirtualEd25519Identity
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert_eq!(
 * "identity_rdx12tgzjrz9u0xz4l28vf04hz87eguclmfaq4d2p8f8lv7zg9ssnzku8j".parse::<IdentityAddress>().unwrap().network_id(),
 * NetworkID::Mainnet
 * );
 * ```
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalIdentityAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L229-L234
 */
public struct IdentityAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}

extension IdentityAddress: Sendable {}
extension IdentityAddress: Equatable, Hashable {
    public static func == (lhs: IdentityAddress, rhs: IdentityAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeIdentityAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityAddress {
        return
            try IdentityAddress(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: IdentityAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeIdentityAddress_lift(_ buf: RustBuffer) throws -> IdentityAddress {
    return try FfiConverterTypeIdentityAddress.lift(buf)
}

public func FfiConverterTypeIdentityAddress_lower(_ value: IdentityAddress) -> RustBuffer {
    return FfiConverterTypeIdentityAddress.lower(value)
}

public struct IdentityPath {
    public var networkId: NetworkId
    public var keyKind: Cap26KeyKind
    public var index: Hardened

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, keyKind: Cap26KeyKind, index: Hardened) {
        self.networkId = networkId
        self.keyKind = keyKind
        self.index = index
    }
}

extension IdentityPath: Sendable {}
extension IdentityPath: Equatable, Hashable {
    public static func == (lhs: IdentityPath, rhs: IdentityPath) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.keyKind != rhs.keyKind {
            return false
        }
        if lhs.index != rhs.index {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(keyKind)
        hasher.combine(index)
    }
}

public struct FfiConverterTypeIdentityPath: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityPath {
        return
            try IdentityPath(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                keyKind: FfiConverterTypeCAP26KeyKind.read(from: &buf),
                index: FfiConverterTypeHardened.read(from: &buf)
            )
    }

    public static func write(_ value: IdentityPath, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeCAP26KeyKind.write(value.keyKind, into: &buf)
        FfiConverterTypeHardened.write(value.index, into: &buf)
    }
}

public func FfiConverterTypeIdentityPath_lift(_ buf: RustBuffer) throws -> IdentityPath {
    return try FfiConverterTypeIdentityPath.lift(buf)
}

public func FfiConverterTypeIdentityPath_lower(_ value: IdentityPath) -> RustBuffer {
    return FfiConverterTypeIdentityPath.lower(value)
}

/**
 * Represents a Unix timestamp, capturing the seconds since the unix epoch.
 */
public struct Instant {
    public var secondsSinceUnixEpoch: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(secondsSinceUnixEpoch: Int64) {
        self.secondsSinceUnixEpoch = secondsSinceUnixEpoch
    }
}

extension Instant: Sendable {}
extension Instant: Equatable, Hashable {
    public static func == (lhs: Instant, rhs: Instant) -> Bool {
        if lhs.secondsSinceUnixEpoch != rhs.secondsSinceUnixEpoch {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secondsSinceUnixEpoch)
    }
}

public struct FfiConverterTypeInstant: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Instant {
        return
            try Instant(
                secondsSinceUnixEpoch: FfiConverterInt64.read(from: &buf)
            )
    }

    public static func write(_ value: Instant, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.secondsSinceUnixEpoch, into: &buf)
    }
}

public func FfiConverterTypeInstant_lift(_ buf: RustBuffer) throws -> Instant {
    return try FfiConverterTypeInstant.lift(buf)
}

public func FfiConverterTypeInstant_lower(_ value: Instant) -> RustBuffer {
    return FfiConverterTypeInstant.lower(value)
}

public struct Instructions {
    fileprivate let secretMagic: String
    public var networkId: NetworkId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String, networkId: NetworkId) {
        self.secretMagic = secretMagic
        self.networkId = networkId
    }
}

extension Instructions: Sendable {}
extension Instructions: Equatable, Hashable {
    public static func == (lhs: Instructions, rhs: Instructions) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
        hasher.combine(networkId)
    }
}

public struct FfiConverterTypeInstructions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Instructions {
        return
            try Instructions(
                secretMagic: FfiConverterString.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
            )
    }

    public static func write(_ value: Instructions, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
    }
}

public func FfiConverterTypeInstructions_lift(_ buf: RustBuffer) throws -> Instructions {
    return try FfiConverterTypeInstructions.lift(buf)
}

public func FfiConverterTypeInstructions_lower(_ value: Instructions) -> RustBuffer {
    return FfiConverterTypeInstructions.lower(value)
}

/**
 * A random number generated part of an intent header,
 * ensuring every intent is unique even though its
 * transaction manifest might be equal. This intent discriminator is
 * generated by wallets for incoming intents.
 *
 * `IntentDiscriminator` is similar to the `Nonce` used in `TransactionHeader`.
 */
public struct IntentDiscriminator {
    fileprivate let secretMagic: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: UInt64) {
        self.secretMagic = secretMagic
    }
}

extension IntentDiscriminator: Sendable {}
extension IntentDiscriminator: Equatable, Hashable {
    public static func == (lhs: IntentDiscriminator, rhs: IntentDiscriminator) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeIntentDiscriminator: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentDiscriminator {
        return
            try IntentDiscriminator(
                secretMagic: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: IntentDiscriminator, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeIntentDiscriminator_lift(_ buf: RustBuffer) throws -> IntentDiscriminator {
    return try FfiConverterTypeIntentDiscriminator.lift(buf)
}

public func FfiConverterTypeIntentDiscriminator_lower(_ value: IntentDiscriminator) -> RustBuffer {
    return FfiConverterTypeIntentDiscriminator.lower(value)
}

/**
 * Represents the header of an intent in V2, containing network ID,
 * epoch range, optional proposer timestamps, and an intent discriminator.
 */
public struct IntentHeaderV2 {
    public var networkId: NetworkId
    public var startEpochInclusive: Epoch
    public var endEpochExclusive: Epoch
    public var minProposerTimestampInclusive: Instant?
    public var maxProposerTimestampExclusive: Instant?
    /**
     * This field is intended to enable a network user to generate an identical intent with
     * a new hash. Users can simply set this randomly if they wish to. A u64 is large
     * enough to avoid any risk of collision over the course of a single epoch anyway.
     *
     * This field's name intent_discriminator is the new name for what was the nonce field in
     * IntentV1. This was poorly named, as it caused confusion with an Ethereum-style nonce.
     */
    public var intentDiscriminator: IntentDiscriminator

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, startEpochInclusive: Epoch, endEpochExclusive: Epoch, minProposerTimestampInclusive: Instant?, maxProposerTimestampExclusive: Instant?,
                /**
                    * This field is intended to enable a network user to generate an identical intent with
                    * a new hash. Users can simply set this randomly if they wish to. A u64 is large
                    * enough to avoid any risk of collision over the course of a single epoch anyway.
                    *
                    * This field's name intent_discriminator is the new name for what was the nonce field in
                    * IntentV1. This was poorly named, as it caused confusion with an Ethereum-style nonce.
                    */ intentDiscriminator: IntentDiscriminator)
    {
        self.networkId = networkId
        self.startEpochInclusive = startEpochInclusive
        self.endEpochExclusive = endEpochExclusive
        self.minProposerTimestampInclusive = minProposerTimestampInclusive
        self.maxProposerTimestampExclusive = maxProposerTimestampExclusive
        self.intentDiscriminator = intentDiscriminator
    }
}

extension IntentHeaderV2: Sendable {}
extension IntentHeaderV2: Equatable, Hashable {
    public static func == (lhs: IntentHeaderV2, rhs: IntentHeaderV2) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.startEpochInclusive != rhs.startEpochInclusive {
            return false
        }
        if lhs.endEpochExclusive != rhs.endEpochExclusive {
            return false
        }
        if lhs.minProposerTimestampInclusive != rhs.minProposerTimestampInclusive {
            return false
        }
        if lhs.maxProposerTimestampExclusive != rhs.maxProposerTimestampExclusive {
            return false
        }
        if lhs.intentDiscriminator != rhs.intentDiscriminator {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(startEpochInclusive)
        hasher.combine(endEpochExclusive)
        hasher.combine(minProposerTimestampInclusive)
        hasher.combine(maxProposerTimestampExclusive)
        hasher.combine(intentDiscriminator)
    }
}

public struct FfiConverterTypeIntentHeaderV2: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentHeaderV2 {
        return
            try IntentHeaderV2(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                startEpochInclusive: FfiConverterTypeEpoch.read(from: &buf),
                endEpochExclusive: FfiConverterTypeEpoch.read(from: &buf),
                minProposerTimestampInclusive: FfiConverterOptionTypeInstant.read(from: &buf),
                maxProposerTimestampExclusive: FfiConverterOptionTypeInstant.read(from: &buf),
                intentDiscriminator: FfiConverterTypeIntentDiscriminator.read(from: &buf)
            )
    }

    public static func write(_ value: IntentHeaderV2, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeEpoch.write(value.startEpochInclusive, into: &buf)
        FfiConverterTypeEpoch.write(value.endEpochExclusive, into: &buf)
        FfiConverterOptionTypeInstant.write(value.minProposerTimestampInclusive, into: &buf)
        FfiConverterOptionTypeInstant.write(value.maxProposerTimestampExclusive, into: &buf)
        FfiConverterTypeIntentDiscriminator.write(value.intentDiscriminator, into: &buf)
    }
}

public func FfiConverterTypeIntentHeaderV2_lift(_ buf: RustBuffer) throws -> IntentHeaderV2 {
    return try FfiConverterTypeIntentHeaderV2.lift(buf)
}

public func FfiConverterTypeIntentHeaderV2_lower(_ value: IntentHeaderV2) -> RustBuffer {
    return FfiConverterTypeIntentHeaderV2.lower(value)
}

public struct IntentSignature {
    public var value: SignatureWithPublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: SignatureWithPublicKey) {
        self.value = value
    }
}

extension IntentSignature: Sendable {}
extension IntentSignature: Equatable, Hashable {
    public static func == (lhs: IntentSignature, rhs: IntentSignature) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeIntentSignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentSignature {
        return
            try IntentSignature(
                value: FfiConverterTypeSignatureWithPublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: IntentSignature, into buf: inout [UInt8]) {
        FfiConverterTypeSignatureWithPublicKey.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeIntentSignature_lift(_ buf: RustBuffer) throws -> IntentSignature {
    return try FfiConverterTypeIntentSignature.lift(buf)
}

public func FfiConverterTypeIntentSignature_lower(_ value: IntentSignature) -> RustBuffer {
    return FfiConverterTypeIntentSignature.lower(value)
}

public struct IntentSignatures {
    public var signatures: [IntentSignature]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signatures: [IntentSignature]) {
        self.signatures = signatures
    }
}

extension IntentSignatures: Sendable {}
extension IntentSignatures: Equatable, Hashable {
    public static func == (lhs: IntentSignatures, rhs: IntentSignatures) -> Bool {
        if lhs.signatures != rhs.signatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signatures)
    }
}

public struct FfiConverterTypeIntentSignatures: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IntentSignatures {
        return
            try IntentSignatures(
                signatures: FfiConverterSequenceTypeIntentSignature.read(from: &buf)
            )
    }

    public static func write(_ value: IntentSignatures, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeIntentSignature.write(value.signatures, into: &buf)
    }
}

public func FfiConverterTypeIntentSignatures_lift(_ buf: RustBuffer) throws -> IntentSignatures {
    return try FfiConverterTypeIntentSignatures.lift(buf)
}

public func FfiConverterTypeIntentSignatures_lower(_ value: IntentSignatures) -> RustBuffer {
    return FfiConverterTypeIntentSignatures.lower(value)
}

/**
 * PublicKey on Curve25519 used for key agreement (ECDH) with some `KeyAgreementPrivateKey`.
 */
public struct KeyAgreementPublicKey {
    public var value: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: BagOfBytes) {
        self.value = value
    }
}

extension KeyAgreementPublicKey: Sendable {}
extension KeyAgreementPublicKey: Equatable, Hashable {
    public static func == (lhs: KeyAgreementPublicKey, rhs: KeyAgreementPublicKey) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeKeyAgreementPublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyAgreementPublicKey {
        return
            try KeyAgreementPublicKey(
                value: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: KeyAgreementPublicKey, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeKeyAgreementPublicKey_lift(_ buf: RustBuffer) throws -> KeyAgreementPublicKey {
    return try FfiConverterTypeKeyAgreementPublicKey.lift(buf)
}

public func FfiConverterTypeKeyAgreementPublicKey_lower(_ value: KeyAgreementPublicKey) -> RustBuffer {
    return FfiConverterTypeKeyAgreementPublicKey.lower(value)
}

public struct LedgerHardwareWalletFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic,
     * that is secured by the Ledger Hardware Wallet device.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a LedgerHardwareWalletFactorSource to help user disambiguate between it and another one.
     */
    public var hint: LedgerHardwareWalletHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic,
         * that is secured by the Ledger Hardware Wallet device.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon,
        /**
            * Properties describing a LedgerHardwareWalletFactorSource to help user disambiguate between it and another one.
            */ hint: LedgerHardwareWalletHint
    ) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}

extension LedgerHardwareWalletFactorSource: Sendable {}
extension LedgerHardwareWalletFactorSource: Equatable, Hashable {
    public static func == (lhs: LedgerHardwareWalletFactorSource, rhs: LedgerHardwareWalletFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}

public struct FfiConverterTypeLedgerHardwareWalletFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletFactorSource {
        return
            try LedgerHardwareWalletFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                hint: FfiConverterTypeLedgerHardwareWalletHint.read(from: &buf)
            )
    }

    public static func write(_ value: LedgerHardwareWalletFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeLedgerHardwareWalletHint.write(value.hint, into: &buf)
    }
}

public func FfiConverterTypeLedgerHardwareWalletFactorSource_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletFactorSource {
    return try FfiConverterTypeLedgerHardwareWalletFactorSource.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletFactorSource_lower(_ value: LedgerHardwareWalletFactorSource) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletFactorSource.lower(value)
}

public struct LedgerHardwareWalletHint {
    /**
     * "Orange, scratched"
     */
    public var name: String
    /**
     * E.g. `nanoS+`
     */
    public var model: LedgerHardwareWalletModel

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * "Orange, scratched"
         */ name: String,
        /**
            * E.g. `nanoS+`
            */ model: LedgerHardwareWalletModel
    ) {
        self.name = name
        self.model = model
    }
}

extension LedgerHardwareWalletHint: Sendable {}
extension LedgerHardwareWalletHint: Equatable, Hashable {
    public static func == (lhs: LedgerHardwareWalletHint, rhs: LedgerHardwareWalletHint) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(model)
    }
}

public struct FfiConverterTypeLedgerHardwareWalletHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletHint {
        return
            try LedgerHardwareWalletHint(
                name: FfiConverterString.read(from: &buf),
                model: FfiConverterTypeLedgerHardwareWalletModel.read(from: &buf)
            )
    }

    public static func write(_ value: LedgerHardwareWalletHint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeLedgerHardwareWalletModel.write(value.model, into: &buf)
    }
}

public func FfiConverterTypeLedgerHardwareWalletHint_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletHint {
    return try FfiConverterTypeLedgerHardwareWalletHint.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletHint_lower(_ value: LedgerHardwareWalletHint) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletHint.lower(value)
}

public struct LegacyOlympiaAccountAddress {
    public var value: Secp256k1PublicKey

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Secp256k1PublicKey) {
        self.value = value
    }
}

extension LegacyOlympiaAccountAddress: Sendable {}
extension LegacyOlympiaAccountAddress: Equatable, Hashable {
    public static func == (lhs: LegacyOlympiaAccountAddress, rhs: LegacyOlympiaAccountAddress) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeLegacyOlympiaAccountAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LegacyOlympiaAccountAddress {
        return
            try LegacyOlympiaAccountAddress(
                value: FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
            )
    }

    public static func write(_ value: LegacyOlympiaAccountAddress, into buf: inout [UInt8]) {
        FfiConverterTypeSecp256k1PublicKey.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeLegacyOlympiaAccountAddress_lift(_ buf: RustBuffer) throws -> LegacyOlympiaAccountAddress {
    return try FfiConverterTypeLegacyOlympiaAccountAddress.lift(buf)
}

public func FfiConverterTypeLegacyOlympiaAccountAddress_lower(_ value: LegacyOlympiaAccountAddress) -> RustBuffer {
    return FfiConverterTypeLegacyOlympiaAccountAddress.lower(value)
}

/**
 * The QR code data scanned from the Connector Extension
 */
public struct LinkConnectionQrData {
    /**
     * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
     * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
     * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
     */
    public var purpose: RadixConnectPurpose
    /**
     * Used to be able to re-establish the P2P connection
     */
    public var password: RadixConnectPassword
    /**
     * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
     * Each client keeps a record of linked clients' public keys to prevent duplicate links.
     * This is the public key of the other client and it also serves as the seed for the link `ID`.
     */
    public var publicKeyOfOtherParty: Ed25519PublicKey
    /**
     * Represents a signature produced by Connector Extension by signing the hash of the `password`
     * with the private key of the `public_key_of_other_party`.
     */
    public var signature: Ed25519Signature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
         * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
         * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
         */ purpose: RadixConnectPurpose,
        /**
            * Used to be able to re-establish the P2P connection
            */ password: RadixConnectPassword,
        /**
            * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
            * Each client keeps a record of linked clients' public keys to prevent duplicate links.
            * This is the public key of the other client and it also serves as the seed for the link `ID`.
            */ publicKeyOfOtherParty: Ed25519PublicKey,
        /**
            * Represents a signature produced by Connector Extension by signing the hash of the `password`
            * with the private key of the `public_key_of_other_party`.
            */ signature: Ed25519Signature
    ) {
        self.purpose = purpose
        self.password = password
        self.publicKeyOfOtherParty = publicKeyOfOtherParty
        self.signature = signature
    }
}

extension LinkConnectionQrData: Sendable {}
extension LinkConnectionQrData: Equatable, Hashable {
    public static func == (lhs: LinkConnectionQrData, rhs: LinkConnectionQrData) -> Bool {
        if lhs.purpose != rhs.purpose {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.publicKeyOfOtherParty != rhs.publicKeyOfOtherParty {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(purpose)
        hasher.combine(password)
        hasher.combine(publicKeyOfOtherParty)
        hasher.combine(signature)
    }
}

public struct FfiConverterTypeLinkConnectionQRData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LinkConnectionQrData {
        return
            try LinkConnectionQrData(
                purpose: FfiConverterTypeRadixConnectPurpose.read(from: &buf),
                password: FfiConverterTypeRadixConnectPassword.read(from: &buf),
                publicKeyOfOtherParty: FfiConverterTypeEd25519PublicKey.read(from: &buf),
                signature: FfiConverterTypeEd25519Signature.read(from: &buf)
            )
    }

    public static func write(_ value: LinkConnectionQrData, into buf: inout [UInt8]) {
        FfiConverterTypeRadixConnectPurpose.write(value.purpose, into: &buf)
        FfiConverterTypeRadixConnectPassword.write(value.password, into: &buf)
        FfiConverterTypeEd25519PublicKey.write(value.publicKeyOfOtherParty, into: &buf)
        FfiConverterTypeEd25519Signature.write(value.signature, into: &buf)
    }
}

public func FfiConverterTypeLinkConnectionQRData_lift(_ buf: RustBuffer) throws -> LinkConnectionQrData {
    return try FfiConverterTypeLinkConnectionQRData.lift(buf)
}

public func FfiConverterTypeLinkConnectionQRData_lower(_ value: LinkConnectionQrData) -> RustBuffer {
    return FfiConverterTypeLinkConnectionQRData.lower(value)
}

public struct LocaleConfig {
    public var decimalSeparator: String?
    public var groupingSeparator: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(decimalSeparator: String?, groupingSeparator: String?) {
        self.decimalSeparator = decimalSeparator
        self.groupingSeparator = groupingSeparator
    }
}

extension LocaleConfig: Sendable {}
extension LocaleConfig: Equatable, Hashable {
    public static func == (lhs: LocaleConfig, rhs: LocaleConfig) -> Bool {
        if lhs.decimalSeparator != rhs.decimalSeparator {
            return false
        }
        if lhs.groupingSeparator != rhs.groupingSeparator {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(decimalSeparator)
        hasher.combine(groupingSeparator)
    }
}

public struct FfiConverterTypeLocaleConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocaleConfig {
        return
            try LocaleConfig(
                decimalSeparator: FfiConverterOptionString.read(from: &buf),
                groupingSeparator: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: LocaleConfig, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.decimalSeparator, into: &buf)
        FfiConverterOptionString.write(value.groupingSeparator, into: &buf)
    }
}

public func FfiConverterTypeLocaleConfig_lift(_ buf: RustBuffer) throws -> LocaleConfig {
    return try FfiConverterTypeLocaleConfig.lift(buf)
}

public func FfiConverterTypeLocaleConfig_lower(_ value: LocaleConfig) -> RustBuffer {
    return FfiConverterTypeLocaleConfig.lower(value)
}

/**
 * Addresses to a specific locker, owned by a dApp, holding assets, either fungible or non_fungible,
 * that can be claimed by destined account addresses.
 * Identities cannot own assets so they do not have vaults, but Accounts do, e.g.:
 * e.g.:
 * `"locker_rdx1tz474x29nxxd4k2p2reete9xyz4apawv63dphxkr00qt23vyju49fq"`
 *
 * A `LockerAddress` has the [Scrypto's `EntityType`][entt] `GlobalAccountLocker`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalLockerAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radix-engine-toolkit/blob/476d779fee08ed1e561ac8fc8730a2a404b7de79/crates/radix-engine-toolkit-uniffi/src/common/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/476d779fee08ed1e561ac8fc8730a2a404b7de79/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L262-L265
 */
public struct LockerAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}

extension LockerAddress: Sendable {}
extension LockerAddress: Equatable, Hashable {
    public static func == (lhs: LockerAddress, rhs: LockerAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeLockerAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LockerAddress {
        return
            try LockerAddress(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: LockerAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeLockerAddress_lift(_ buf: RustBuffer) throws -> LockerAddress {
    return try FfiConverterTypeLockerAddress.lift(buf)
}

public func FfiConverterTypeLockerAddress_lower(_ value: LockerAddress) -> RustBuffer {
    return FfiConverterTypeLockerAddress.lower(value)
}

/**
 * A summary of the manifest
 */
public struct ManifestSummary {
    /**
     * The withdrawals done in the manifest.
     */
    public var accountWithdrawals: [AccountAddress: [AccountWithdraw]]
    /**
     * The deposits done in the manifest.
     */
    public var accountDeposits: [AccountAddress: AccountDeposits]
    /**
     * The list of the resources of proofs that were presented in the manifest.
     */
    public var presentedProofs: [ResourceSpecifier]
    /**
     * Addresses of accounts withdrawn from in the manifest.
     */
    public var addressesOfAccountsWithdrawnFrom: [AccountAddress]
    /**
     * Addresses of accounts deposited into in the manifest.
     */
    public var addressesOfAccountsDepositedInto: [AccountAddress]
    /**
     * The set of all the global entities encountered in the manifest. This is
     * to be primarily used for the "using dApps" section of the wallet's tx
     * review screen.
     */
    public var encounteredEntities: [ManifestEncounteredComponentAddress]
    /**
     * Addresses of accounts encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the accounts of all those addresses, which might be multiple
     * signatures per Account, if MFA has been setup.
     */
    public var addressesOfAccountsRequiringAuth: [AccountAddress]
    /**
     * Addresses of identities (Personas) encountered in the manifest where privileged
     * methods were called. The wallets will need to collect signatures
     * of the identities of all those addresses, which might be multiple
     * signatures per Persona, if MFA has been setup.
     */
    public var addressesOfPersonasRequiringAuth: [IdentityAddress]
    /**
     * The set of instructions encountered in the manifest that are reserved
     * and can only be included in the manifest by the wallet itself.
     */
    public var reservedInstructions: [ReservedInstruction]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The withdrawals done in the manifest.
         */ accountWithdrawals: [AccountAddress: [AccountWithdraw]],
        /**
            * The deposits done in the manifest.
            */ accountDeposits: [AccountAddress: AccountDeposits],
        /**
            * The list of the resources of proofs that were presented in the manifest.
            */ presentedProofs: [ResourceSpecifier],
        /**
            * Addresses of accounts withdrawn from in the manifest.
            */ addressesOfAccountsWithdrawnFrom: [AccountAddress],
        /**
            * Addresses of accounts deposited into in the manifest.
            */ addressesOfAccountsDepositedInto: [AccountAddress],
        /**
            * The set of all the global entities encountered in the manifest. This is
            * to be primarily used for the "using dApps" section of the wallet's tx
            * review screen.
            */ encounteredEntities: [ManifestEncounteredComponentAddress],
        /**
            * Addresses of accounts encountered in the manifest where privileged
            * methods were called. The wallets will need to collect signatures
            * of the accounts of all those addresses, which might be multiple
            * signatures per Account, if MFA has been setup.
            */ addressesOfAccountsRequiringAuth: [AccountAddress],
        /**
            * Addresses of identities (Personas) encountered in the manifest where privileged
            * methods were called. The wallets will need to collect signatures
            * of the identities of all those addresses, which might be multiple
            * signatures per Persona, if MFA has been setup.
            */ addressesOfPersonasRequiringAuth: [IdentityAddress],
        /**
            * The set of instructions encountered in the manifest that are reserved
            * and can only be included in the manifest by the wallet itself.
            */ reservedInstructions: [ReservedInstruction]
    ) {
        self.accountWithdrawals = accountWithdrawals
        self.accountDeposits = accountDeposits
        self.presentedProofs = presentedProofs
        self.addressesOfAccountsWithdrawnFrom = addressesOfAccountsWithdrawnFrom
        self.addressesOfAccountsDepositedInto = addressesOfAccountsDepositedInto
        self.encounteredEntities = encounteredEntities
        self.addressesOfAccountsRequiringAuth = addressesOfAccountsRequiringAuth
        self.addressesOfPersonasRequiringAuth = addressesOfPersonasRequiringAuth
        self.reservedInstructions = reservedInstructions
    }
}

extension ManifestSummary: Sendable {}
extension ManifestSummary: Equatable, Hashable {
    public static func == (lhs: ManifestSummary, rhs: ManifestSummary) -> Bool {
        if lhs.accountWithdrawals != rhs.accountWithdrawals {
            return false
        }
        if lhs.accountDeposits != rhs.accountDeposits {
            return false
        }
        if lhs.presentedProofs != rhs.presentedProofs {
            return false
        }
        if lhs.addressesOfAccountsWithdrawnFrom != rhs.addressesOfAccountsWithdrawnFrom {
            return false
        }
        if lhs.addressesOfAccountsDepositedInto != rhs.addressesOfAccountsDepositedInto {
            return false
        }
        if lhs.encounteredEntities != rhs.encounteredEntities {
            return false
        }
        if lhs.addressesOfAccountsRequiringAuth != rhs.addressesOfAccountsRequiringAuth {
            return false
        }
        if lhs.addressesOfPersonasRequiringAuth != rhs.addressesOfPersonasRequiringAuth {
            return false
        }
        if lhs.reservedInstructions != rhs.reservedInstructions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountWithdrawals)
        hasher.combine(accountDeposits)
        hasher.combine(presentedProofs)
        hasher.combine(addressesOfAccountsWithdrawnFrom)
        hasher.combine(addressesOfAccountsDepositedInto)
        hasher.combine(encounteredEntities)
        hasher.combine(addressesOfAccountsRequiringAuth)
        hasher.combine(addressesOfPersonasRequiringAuth)
        hasher.combine(reservedInstructions)
    }
}

public struct FfiConverterTypeManifestSummary: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestSummary {
        return
            try ManifestSummary(
                accountWithdrawals: FfiConverterDictionaryTypeAccountAddressSequenceTypeAccountWithdraw.read(from: &buf),
                accountDeposits: FfiConverterDictionaryTypeAccountAddressTypeAccountDeposits.read(from: &buf),
                presentedProofs: FfiConverterSequenceTypeResourceSpecifier.read(from: &buf),
                addressesOfAccountsWithdrawnFrom: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
                addressesOfAccountsDepositedInto: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
                encounteredEntities: FfiConverterSequenceTypeManifestEncounteredComponentAddress.read(from: &buf),
                addressesOfAccountsRequiringAuth: FfiConverterSequenceTypeAccountAddress.read(from: &buf),
                addressesOfPersonasRequiringAuth: FfiConverterSequenceTypeIdentityAddress.read(from: &buf),
                reservedInstructions: FfiConverterSequenceTypeReservedInstruction.read(from: &buf)
            )
    }

    public static func write(_ value: ManifestSummary, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeAccountAddressSequenceTypeAccountWithdraw.write(value.accountWithdrawals, into: &buf)
        FfiConverterDictionaryTypeAccountAddressTypeAccountDeposits.write(value.accountDeposits, into: &buf)
        FfiConverterSequenceTypeResourceSpecifier.write(value.presentedProofs, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsWithdrawnFrom, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsDepositedInto, into: &buf)
        FfiConverterSequenceTypeManifestEncounteredComponentAddress.write(value.encounteredEntities, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.addressesOfAccountsRequiringAuth, into: &buf)
        FfiConverterSequenceTypeIdentityAddress.write(value.addressesOfPersonasRequiringAuth, into: &buf)
        FfiConverterSequenceTypeReservedInstruction.write(value.reservedInstructions, into: &buf)
    }
}

public func FfiConverterTypeManifestSummary_lift(_ buf: RustBuffer) throws -> ManifestSummary {
    return try FfiConverterTypeManifestSummary.lift(buf)
}

public func FfiConverterTypeManifestSummary_lower(_ value: ManifestSummary) -> RustBuffer {
    return FfiConverterTypeManifestSummary.lower(value)
}

/**
 * A matrix of FactorInstances
 */
public struct MatrixOfFactorInstances {
    /**
     * Used for Signing transactions
     */
    public var primaryRole: PrimaryRoleWithFactorInstances
    /**
     * Used to initiate recovery - resetting the used Security Shield
     * of an entity.
     */
    public var recoveryRole: RecoveryRoleWithFactorInstances
    /**
     * To confirm recovery.
     */
    public var confirmationRole: ConfirmationRoleWithFactorInstances

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Used for Signing transactions
         */ primaryRole: PrimaryRoleWithFactorInstances,
        /**
            * Used to initiate recovery - resetting the used Security Shield
            * of an entity.
            */ recoveryRole: RecoveryRoleWithFactorInstances,
        /**
            * To confirm recovery.
            */ confirmationRole: ConfirmationRoleWithFactorInstances
    ) {
        self.primaryRole = primaryRole
        self.recoveryRole = recoveryRole
        self.confirmationRole = confirmationRole
    }
}

extension MatrixOfFactorInstances: Sendable {}
extension MatrixOfFactorInstances: Equatable, Hashable {
    public static func == (lhs: MatrixOfFactorInstances, rhs: MatrixOfFactorInstances) -> Bool {
        if lhs.primaryRole != rhs.primaryRole {
            return false
        }
        if lhs.recoveryRole != rhs.recoveryRole {
            return false
        }
        if lhs.confirmationRole != rhs.confirmationRole {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(primaryRole)
        hasher.combine(recoveryRole)
        hasher.combine(confirmationRole)
    }
}

public struct FfiConverterTypeMatrixOfFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixOfFactorInstances {
        return
            try MatrixOfFactorInstances(
                primaryRole: FfiConverterTypePrimaryRoleWithFactorInstances.read(from: &buf),
                recoveryRole: FfiConverterTypeRecoveryRoleWithFactorInstances.read(from: &buf),
                confirmationRole: FfiConverterTypeConfirmationRoleWithFactorInstances.read(from: &buf)
            )
    }

    public static func write(_ value: MatrixOfFactorInstances, into buf: inout [UInt8]) {
        FfiConverterTypePrimaryRoleWithFactorInstances.write(value.primaryRole, into: &buf)
        FfiConverterTypeRecoveryRoleWithFactorInstances.write(value.recoveryRole, into: &buf)
        FfiConverterTypeConfirmationRoleWithFactorInstances.write(value.confirmationRole, into: &buf)
    }
}

public func FfiConverterTypeMatrixOfFactorInstances_lift(_ buf: RustBuffer) throws -> MatrixOfFactorInstances {
    return try FfiConverterTypeMatrixOfFactorInstances.lift(buf)
}

public func FfiConverterTypeMatrixOfFactorInstances_lower(_ value: MatrixOfFactorInstances) -> RustBuffer {
    return FfiConverterTypeMatrixOfFactorInstances.lower(value)
}

public struct MatrixOfFactorSourceIDs {
    /**
     * Used for Signing transactions
     */
    public var primaryRole: PrimaryRoleWithFactorSourceIDs
    /**
     * Used to initiate recovery - resetting the used Security Shield
     * of an entity.
     */
    public var recoveryRole: RecoveryRoleWithFactorSourceIDs
    /**
     * To confirm recovery.
     */
    public var confirmationRole: ConfirmationRoleWithFactorSourceIDs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Used for Signing transactions
         */ primaryRole: PrimaryRoleWithFactorSourceIDs,
        /**
            * Used to initiate recovery - resetting the used Security Shield
            * of an entity.
            */ recoveryRole: RecoveryRoleWithFactorSourceIDs,
        /**
            * To confirm recovery.
            */ confirmationRole: ConfirmationRoleWithFactorSourceIDs
    ) {
        self.primaryRole = primaryRole
        self.recoveryRole = recoveryRole
        self.confirmationRole = confirmationRole
    }
}

extension MatrixOfFactorSourceIDs: Sendable {}
extension MatrixOfFactorSourceIDs: Equatable, Hashable {
    public static func == (lhs: MatrixOfFactorSourceIDs, rhs: MatrixOfFactorSourceIDs) -> Bool {
        if lhs.primaryRole != rhs.primaryRole {
            return false
        }
        if lhs.recoveryRole != rhs.recoveryRole {
            return false
        }
        if lhs.confirmationRole != rhs.confirmationRole {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(primaryRole)
        hasher.combine(recoveryRole)
        hasher.combine(confirmationRole)
    }
}

public struct FfiConverterTypeMatrixOfFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixOfFactorSourceIDs {
        return
            try MatrixOfFactorSourceIDs(
                primaryRole: FfiConverterTypePrimaryRoleWithFactorSourceIDs.read(from: &buf),
                recoveryRole: FfiConverterTypeRecoveryRoleWithFactorSourceIDs.read(from: &buf),
                confirmationRole: FfiConverterTypeConfirmationRoleWithFactorSourceIDs.read(from: &buf)
            )
    }

    public static func write(_ value: MatrixOfFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterTypePrimaryRoleWithFactorSourceIDs.write(value.primaryRole, into: &buf)
        FfiConverterTypeRecoveryRoleWithFactorSourceIDs.write(value.recoveryRole, into: &buf)
        FfiConverterTypeConfirmationRoleWithFactorSourceIDs.write(value.confirmationRole, into: &buf)
    }
}

public func FfiConverterTypeMatrixOfFactorSourceIDs_lift(_ buf: RustBuffer) throws -> MatrixOfFactorSourceIDs {
    return try FfiConverterTypeMatrixOfFactorSourceIDs.lift(buf)
}

public func FfiConverterTypeMatrixOfFactorSourceIDs_lower(_ value: MatrixOfFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypeMatrixOfFactorSourceIDs.lower(value)
}

public struct MatrixOfFactorSources {
    /**
     * Used for Signing transactions
     */
    public var primaryRole: PrimaryRoleWithFactorSources
    /**
     * Used to initiate recovery - resetting the used Security Shield
     * of an entity.
     */
    public var recoveryRole: RecoveryRoleWithFactorSources
    /**
     * To confirm recovery.
     */
    public var confirmationRole: ConfirmationRoleWithFactorSources

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Used for Signing transactions
         */ primaryRole: PrimaryRoleWithFactorSources,
        /**
            * Used to initiate recovery - resetting the used Security Shield
            * of an entity.
            */ recoveryRole: RecoveryRoleWithFactorSources,
        /**
            * To confirm recovery.
            */ confirmationRole: ConfirmationRoleWithFactorSources
    ) {
        self.primaryRole = primaryRole
        self.recoveryRole = recoveryRole
        self.confirmationRole = confirmationRole
    }
}

extension MatrixOfFactorSources: Sendable {}
extension MatrixOfFactorSources: Equatable, Hashable {
    public static func == (lhs: MatrixOfFactorSources, rhs: MatrixOfFactorSources) -> Bool {
        if lhs.primaryRole != rhs.primaryRole {
            return false
        }
        if lhs.recoveryRole != rhs.recoveryRole {
            return false
        }
        if lhs.confirmationRole != rhs.confirmationRole {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(primaryRole)
        hasher.combine(recoveryRole)
        hasher.combine(confirmationRole)
    }
}

public struct FfiConverterTypeMatrixOfFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixOfFactorSources {
        return
            try MatrixOfFactorSources(
                primaryRole: FfiConverterTypePrimaryRoleWithFactorSources.read(from: &buf),
                recoveryRole: FfiConverterTypeRecoveryRoleWithFactorSources.read(from: &buf),
                confirmationRole: FfiConverterTypeConfirmationRoleWithFactorSources.read(from: &buf)
            )
    }

    public static func write(_ value: MatrixOfFactorSources, into buf: inout [UInt8]) {
        FfiConverterTypePrimaryRoleWithFactorSources.write(value.primaryRole, into: &buf)
        FfiConverterTypeRecoveryRoleWithFactorSources.write(value.recoveryRole, into: &buf)
        FfiConverterTypeConfirmationRoleWithFactorSources.write(value.confirmationRole, into: &buf)
    }
}

public func FfiConverterTypeMatrixOfFactorSources_lift(_ buf: RustBuffer) throws -> MatrixOfFactorSources {
    return try FfiConverterTypeMatrixOfFactorSources.lift(buf)
}

public func FfiConverterTypeMatrixOfFactorSources_lower(_ value: MatrixOfFactorSources) -> RustBuffer {
    return FfiConverterTypeMatrixOfFactorSources.lower(value)
}

public struct Mnemonic {
    public var words: [Bip39Word]
    public var wordCount: Bip39WordCount
    public var language: Bip39Language

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(words: [Bip39Word], wordCount: Bip39WordCount, language: Bip39Language) {
        self.words = words
        self.wordCount = wordCount
        self.language = language
    }
}

extension Mnemonic: Sendable {}
extension Mnemonic: Equatable, Hashable {
    public static func == (lhs: Mnemonic, rhs: Mnemonic) -> Bool {
        if lhs.words != rhs.words {
            return false
        }
        if lhs.wordCount != rhs.wordCount {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(words)
        hasher.combine(wordCount)
        hasher.combine(language)
    }
}

public struct FfiConverterTypeMnemonic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mnemonic {
        return
            try Mnemonic(
                words: FfiConverterSequenceTypeBIP39Word.read(from: &buf),
                wordCount: FfiConverterTypeBIP39WordCount.read(from: &buf),
                language: FfiConverterTypeBIP39Language.read(from: &buf)
            )
    }

    public static func write(_ value: Mnemonic, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeBIP39Word.write(value.words, into: &buf)
        FfiConverterTypeBIP39WordCount.write(value.wordCount, into: &buf)
        FfiConverterTypeBIP39Language.write(value.language, into: &buf)
    }
}

public func FfiConverterTypeMnemonic_lift(_ buf: RustBuffer) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(buf)
}

public func FfiConverterTypeMnemonic_lower(_ value: Mnemonic) -> RustBuffer {
    return FfiConverterTypeMnemonic.lower(value)
}

/**
 * A BIP39 Mnemonic and BIP39 passphrase - aka "25th word" tuple,
 * from which we can derive a HD Root used for derivation.
 */
public struct MnemonicWithPassphrase {
    public var mnemonic: Mnemonic
    public var passphrase: Bip39Passphrase

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonic: Mnemonic, passphrase: Bip39Passphrase) {
        self.mnemonic = mnemonic
        self.passphrase = passphrase
    }
}

extension MnemonicWithPassphrase: Sendable {}
extension MnemonicWithPassphrase: Equatable, Hashable {
    public static func == (lhs: MnemonicWithPassphrase, rhs: MnemonicWithPassphrase) -> Bool {
        if lhs.mnemonic != rhs.mnemonic {
            return false
        }
        if lhs.passphrase != rhs.passphrase {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonic)
        hasher.combine(passphrase)
    }
}

public struct FfiConverterTypeMnemonicWithPassphrase: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MnemonicWithPassphrase {
        return
            try MnemonicWithPassphrase(
                mnemonic: FfiConverterTypeMnemonic.read(from: &buf),
                passphrase: FfiConverterTypeBIP39Passphrase.read(from: &buf)
            )
    }

    public static func write(_ value: MnemonicWithPassphrase, into buf: inout [UInt8]) {
        FfiConverterTypeMnemonic.write(value.mnemonic, into: &buf)
        FfiConverterTypeBIP39Passphrase.write(value.passphrase, into: &buf)
    }
}

public func FfiConverterTypeMnemonicWithPassphrase_lift(_ buf: RustBuffer) throws -> MnemonicWithPassphrase {
    return try FfiConverterTypeMnemonicWithPassphrase.lift(buf)
}

public func FfiConverterTypeMnemonicWithPassphrase_lower(_ value: MnemonicWithPassphrase) -> RustBuffer {
    return FfiConverterTypeMnemonicWithPassphrase.lower(value)
}

/**
 * A version of the Radix Network, for a NetworkID with an identifier (name) and display description (display name)
 */
public struct NetworkDefinition {
    /**
     * A String identifier (always lowercase) with the name of the Network that MUST match what Gateway returns.
     */
    public var logicalName: String
    /**
     * The canonical identifier of this network.
     */
    public var id: NetworkId
    /**
     * A name of the network intended for display purposes only.
     */
    public var displayDescription: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A String identifier (always lowercase) with the name of the Network that MUST match what Gateway returns.
         */ logicalName: String,
        /**
            * The canonical identifier of this network.
            */ id: NetworkId,
        /**
            * A name of the network intended for display purposes only.
            */ displayDescription: String
    ) {
        self.logicalName = logicalName
        self.id = id
        self.displayDescription = displayDescription
    }
}

extension NetworkDefinition: Sendable {}
extension NetworkDefinition: Equatable, Hashable {
    public static func == (lhs: NetworkDefinition, rhs: NetworkDefinition) -> Bool {
        if lhs.logicalName != rhs.logicalName {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.displayDescription != rhs.displayDescription {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(logicalName)
        hasher.combine(id)
        hasher.combine(displayDescription)
    }
}

public struct FfiConverterTypeNetworkDefinition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkDefinition {
        return
            try NetworkDefinition(
                logicalName: FfiConverterString.read(from: &buf),
                id: FfiConverterTypeNetworkID.read(from: &buf),
                displayDescription: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: NetworkDefinition, into buf: inout [UInt8]) {
        FfiConverterString.write(value.logicalName, into: &buf)
        FfiConverterTypeNetworkID.write(value.id, into: &buf)
        FfiConverterString.write(value.displayDescription, into: &buf)
    }
}

public func FfiConverterTypeNetworkDefinition_lift(_ buf: RustBuffer) throws -> NetworkDefinition {
    return try FfiConverterTypeNetworkDefinition.lift(buf)
}

public func FfiConverterTypeNetworkDefinition_lower(_ value: NetworkDefinition) -> RustBuffer {
    return FfiConverterTypeNetworkDefinition.lower(value)
}

public struct NetworkRequest {
    public var url: Url
    public var method: NetworkMethod
    public var headers: [String: String]
    public var body: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: Url, method: NetworkMethod, headers: [String: String], body: BagOfBytes) {
        self.url = url
        self.method = method
        self.headers = headers
        self.body = body
    }
}

extension NetworkRequest: Sendable {}
extension NetworkRequest: Equatable, Hashable {
    public static func == (lhs: NetworkRequest, rhs: NetworkRequest) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(method)
        hasher.combine(headers)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeNetworkRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkRequest {
        return
            try NetworkRequest(
                url: FfiConverterTypeUrl.read(from: &buf),
                method: FfiConverterTypeNetworkMethod.read(from: &buf),
                headers: FfiConverterDictionaryStringString.read(from: &buf),
                body: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: NetworkRequest, into buf: inout [UInt8]) {
        FfiConverterTypeUrl.write(value.url, into: &buf)
        FfiConverterTypeNetworkMethod.write(value.method, into: &buf)
        FfiConverterDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterTypeBagOfBytes.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeNetworkRequest_lift(_ buf: RustBuffer) throws -> NetworkRequest {
    return try FfiConverterTypeNetworkRequest.lift(buf)
}

public func FfiConverterTypeNetworkRequest_lower(_ value: NetworkRequest) -> RustBuffer {
    return FfiConverterTypeNetworkRequest.lower(value)
}

public struct NetworkResponse {
    public var statusCode: UInt16
    /**
     * Can be empty.
     */
    public var body: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(statusCode: UInt16,
                /**
                    * Can be empty.
                    */ body: BagOfBytes)
    {
        self.statusCode = statusCode
        self.body = body
    }
}

extension NetworkResponse: Sendable {}
extension NetworkResponse: Equatable, Hashable {
    public static func == (lhs: NetworkResponse, rhs: NetworkResponse) -> Bool {
        if lhs.statusCode != rhs.statusCode {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(statusCode)
        hasher.combine(body)
    }
}

public struct FfiConverterTypeNetworkResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkResponse {
        return
            try NetworkResponse(
                statusCode: FfiConverterUInt16.read(from: &buf),
                body: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: NetworkResponse, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.statusCode, into: &buf)
        FfiConverterTypeBagOfBytes.write(value.body, into: &buf)
    }
}

public func FfiConverterTypeNetworkResponse_lift(_ buf: RustBuffer) throws -> NetworkResponse {
    return try FfiConverterTypeNetworkResponse.lift(buf)
}

public func FfiConverterTypeNetworkResponse_lower(_ value: NetworkResponse) -> RustBuffer {
    return FfiConverterTypeNetworkResponse.lower(value)
}

/**
 * Information on the global entities created in the transaction.
 */
public struct NewEntities {
    public var metadata: [ResourceAddress: NewlyCreatedResource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(metadata: [ResourceAddress: NewlyCreatedResource]) {
        self.metadata = metadata
    }
}

extension NewEntities: Sendable {}
extension NewEntities: Equatable, Hashable {
    public static func == (lhs: NewEntities, rhs: NewEntities) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
    }
}

public struct FfiConverterTypeNewEntities: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewEntities {
        return
            try NewEntities(
                metadata: FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource.read(from: &buf)
            )
    }

    public static func write(_ value: NewEntities, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource.write(value.metadata, into: &buf)
    }
}

public func FfiConverterTypeNewEntities_lift(_ buf: RustBuffer) throws -> NewEntities {
    return try FfiConverterTypeNewEntities.lift(buf)
}

public func FfiConverterTypeNewEntities_lower(_ value: NewEntities) -> RustBuffer {
    return FfiConverterTypeNewEntities.lower(value)
}

/**
 * Metadata about a newly created Resource
 */
public struct NewlyCreatedResource {
    public var name: String?
    public var symbol: String?
    public var description: String?
    public var iconUrl: String?
    public var tags: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String?, symbol: String?, description: String?, iconUrl: String?, tags: [String]) {
        self.name = name
        self.symbol = symbol
        self.description = description
        self.iconUrl = iconUrl
        self.tags = tags
    }
}

extension NewlyCreatedResource: Sendable {}
extension NewlyCreatedResource: Equatable, Hashable {
    public static func == (lhs: NewlyCreatedResource, rhs: NewlyCreatedResource) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.iconUrl != rhs.iconUrl {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(symbol)
        hasher.combine(description)
        hasher.combine(iconUrl)
        hasher.combine(tags)
    }
}

public struct FfiConverterTypeNewlyCreatedResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewlyCreatedResource {
        return
            try NewlyCreatedResource(
                name: FfiConverterOptionString.read(from: &buf),
                symbol: FfiConverterOptionString.read(from: &buf),
                description: FfiConverterOptionString.read(from: &buf),
                iconUrl: FfiConverterOptionString.read(from: &buf),
                tags: FfiConverterSequenceString.read(from: &buf)
            )
    }

    public static func write(_ value: NewlyCreatedResource, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.symbol, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.iconUrl, into: &buf)
        FfiConverterSequenceString.write(value.tags, into: &buf)
    }
}

public func FfiConverterTypeNewlyCreatedResource_lift(_ buf: RustBuffer) throws -> NewlyCreatedResource {
    return try FfiConverterTypeNewlyCreatedResource.lift(buf)
}

public func FfiConverterTypeNewlyCreatedResource_lower(_ value: NewlyCreatedResource) -> RustBuffer {
    return FfiConverterTypeNewlyCreatedResource.lower(value)
}

/**
 * 32 bytes, typically used as entropy for Mnemonics.
 */
public struct NonEmptyMax32Bytes {
    public var bagOfBytes: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bagOfBytes: BagOfBytes) {
        self.bagOfBytes = bagOfBytes
    }
}

extension NonEmptyMax32Bytes: Sendable {}
extension NonEmptyMax32Bytes: Equatable, Hashable {
    public static func == (lhs: NonEmptyMax32Bytes, rhs: NonEmptyMax32Bytes) -> Bool {
        if lhs.bagOfBytes != rhs.bagOfBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bagOfBytes)
    }
}

public struct FfiConverterTypeNonEmptyMax32Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonEmptyMax32Bytes {
        return
            try NonEmptyMax32Bytes(
                bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: NonEmptyMax32Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
    }
}

public func FfiConverterTypeNonEmptyMax32Bytes_lift(_ buf: RustBuffer) throws -> NonEmptyMax32Bytes {
    return try FfiConverterTypeNonEmptyMax32Bytes.lift(buf)
}

public func FfiConverterTypeNonEmptyMax32Bytes_lower(_ value: NonEmptyMax32Bytes) -> RustBuffer {
    return FfiConverterTypeNonEmptyMax32Bytes.lower(value)
}

/**
 * 64 bytes, typically used by NonFungibleLocalId::Bytes
 */
public struct NonEmptyMax64Bytes {
    public var bagOfBytes: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bagOfBytes: BagOfBytes) {
        self.bagOfBytes = bagOfBytes
    }
}

extension NonEmptyMax64Bytes: Sendable {}
extension NonEmptyMax64Bytes: Equatable, Hashable {
    public static func == (lhs: NonEmptyMax64Bytes, rhs: NonEmptyMax64Bytes) -> Bool {
        if lhs.bagOfBytes != rhs.bagOfBytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bagOfBytes)
    }
}

public struct FfiConverterTypeNonEmptyMax64Bytes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonEmptyMax64Bytes {
        return
            try NonEmptyMax64Bytes(
                bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: NonEmptyMax64Bytes, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.bagOfBytes, into: &buf)
    }
}

public func FfiConverterTypeNonEmptyMax64Bytes_lift(_ buf: RustBuffer) throws -> NonEmptyMax64Bytes {
    return try FfiConverterTypeNonEmptyMax64Bytes.lift(buf)
}

public func FfiConverterTypeNonEmptyMax64Bytes_lower(_ value: NonEmptyMax64Bytes) -> RustBuffer {
    return FfiConverterTypeNonEmptyMax64Bytes.lower(value)
}

public struct NonFungibleGlobalId {
    public var resourceAddress: ResourceAddress
    public var nonFungibleLocalId: NonFungibleLocalId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: ResourceAddress, nonFungibleLocalId: NonFungibleLocalId) {
        self.resourceAddress = resourceAddress
        self.nonFungibleLocalId = nonFungibleLocalId
    }
}

extension NonFungibleGlobalId: Sendable {}
extension NonFungibleGlobalId: Equatable, Hashable {
    public static func == (lhs: NonFungibleGlobalId, rhs: NonFungibleGlobalId) -> Bool {
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.nonFungibleLocalId != rhs.nonFungibleLocalId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resourceAddress)
        hasher.combine(nonFungibleLocalId)
    }
}

public struct FfiConverterTypeNonFungibleGlobalId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleGlobalId {
        return
            try NonFungibleGlobalId(
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                nonFungibleLocalId: FfiConverterTypeNonFungibleLocalId.read(from: &buf)
            )
    }

    public static func write(_ value: NonFungibleGlobalId, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterTypeNonFungibleLocalId.write(value.nonFungibleLocalId, into: &buf)
    }
}

public func FfiConverterTypeNonFungibleGlobalId_lift(_ buf: RustBuffer) throws -> NonFungibleGlobalId {
    return try FfiConverterTypeNonFungibleGlobalId.lift(buf)
}

public func FfiConverterTypeNonFungibleGlobalId_lower(_ value: NonFungibleGlobalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleGlobalId.lower(value)
}

/**
 * A string matching `[_0-9a-zA-Z]{1,64}`.
 *
 * This is an internal wrapping of Scrypto's `StringNonFungibleLocalId`
 * with a UniFFI custom converter using `String` as `Builtin`.
 *
 * Using this type instead of `String` directly in `NonFungibleLocalId::Str`,
 * allows us to do impl `From<NonFungibleLocalId> for NonFungibleLocalId` instead
 * of `TryFrom<NonFungibleLocalId>`.
 */
public struct NonFungibleLocalIdString {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}

extension NonFungibleLocalIdString: Sendable {}
extension NonFungibleLocalIdString: Equatable, Hashable {
    public static func == (lhs: NonFungibleLocalIdString, rhs: NonFungibleLocalIdString) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeNonFungibleLocalIdString: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalIdString {
        return
            try NonFungibleLocalIdString(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: NonFungibleLocalIdString, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeNonFungibleLocalIdString_lift(_ buf: RustBuffer) throws -> NonFungibleLocalIdString {
    return try FfiConverterTypeNonFungibleLocalIdString.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalIdString_lower(_ value: NonFungibleLocalIdString) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalIdString.lower(value)
}

/**
 * NonFungibleResourceAddress is a specialized ResourceAddress for resources
 * which are non fungible, it ALWAYS has an `'n'` after bech32 separator `'1'`, e.g.:
 * `"resource_rdx1nfyg2f68jw7hfdlg5hzvd8ylsa7e0kjl68t5t62v3ttamtejc9wlxa"`.
 *
 * As opposed to a fungible resource address, e.g. that of XRD which has `'t'`
 * after bech32 separator `'1'`, see:
 * `"resource_rdx1tknxxxxxxxxxradxrdxxxxxxxxx009923554798xxxxxxxxxradxrd"`
 *
 * This means that given an instance of `NonFungibleResourceAddress`, it is
 * guaranteed that its entity type is [`::GlobalNonFungibleResourceManager`],
 * and not `::GlobalFungibleResourceManager`.
 *
 * This type can safely be used with [`StakeClaim`]s, unfortunately since Radix Engine
 * and/or network does not validate the resource address of a `NonFungibleGlobalId`,
 * we cannot use this for that type.
 */
public struct NonFungibleResourceAddress {
    public var value: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: ResourceAddress) {
        self.value = value
    }
}

extension NonFungibleResourceAddress: Sendable {}
extension NonFungibleResourceAddress: Equatable, Hashable {
    public static func == (lhs: NonFungibleResourceAddress, rhs: NonFungibleResourceAddress) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeNonFungibleResourceAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleResourceAddress {
        return
            try NonFungibleResourceAddress(
                value: FfiConverterTypeResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: NonFungibleResourceAddress, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeNonFungibleResourceAddress_lift(_ buf: RustBuffer) throws -> NonFungibleResourceAddress {
    return try FfiConverterTypeNonFungibleResourceAddress.lift(buf)
}

public func FfiConverterTypeNonFungibleResourceAddress_lower(_ value: NonFungibleResourceAddress) -> RustBuffer {
    return FfiConverterTypeNonFungibleResourceAddress.lower(value)
}

public struct Nonce {
    fileprivate let secretMagic: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: UInt32) {
        self.secretMagic = secretMagic
    }
}

extension Nonce: Sendable {}
extension Nonce: Equatable, Hashable {
    public static func == (lhs: Nonce, rhs: Nonce) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeNonce: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nonce {
        return
            try Nonce(
                secretMagic: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: Nonce, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeNonce_lift(_ buf: RustBuffer) throws -> Nonce {
    return try FfiConverterTypeNonce.lift(buf)
}

public func FfiConverterTypeNonce_lower(_ value: Nonce) -> RustBuffer {
    return FfiConverterTypeNonce.lower(value)
}

public struct NotarizedTransaction {
    public var signedIntent: SignedIntent
    public var notarySignature: NotarySignature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signedIntent: SignedIntent, notarySignature: NotarySignature) {
        self.signedIntent = signedIntent
        self.notarySignature = notarySignature
    }
}

extension NotarizedTransaction: Sendable {}
extension NotarizedTransaction: Equatable, Hashable {
    public static func == (lhs: NotarizedTransaction, rhs: NotarizedTransaction) -> Bool {
        if lhs.signedIntent != rhs.signedIntent {
            return false
        }
        if lhs.notarySignature != rhs.notarySignature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signedIntent)
        hasher.combine(notarySignature)
    }
}

public struct FfiConverterTypeNotarizedTransaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarizedTransaction {
        return
            try NotarizedTransaction(
                signedIntent: FfiConverterTypeSignedIntent.read(from: &buf),
                notarySignature: FfiConverterTypeNotarySignature.read(from: &buf)
            )
    }

    public static func write(_ value: NotarizedTransaction, into buf: inout [UInt8]) {
        FfiConverterTypeSignedIntent.write(value.signedIntent, into: &buf)
        FfiConverterTypeNotarySignature.write(value.notarySignature, into: &buf)
    }
}

public func FfiConverterTypeNotarizedTransaction_lift(_ buf: RustBuffer) throws -> NotarizedTransaction {
    return try FfiConverterTypeNotarizedTransaction.lift(buf)
}

public func FfiConverterTypeNotarizedTransaction_lower(_ value: NotarizedTransaction) -> RustBuffer {
    return FfiConverterTypeNotarizedTransaction.lower(value)
}

public struct NotarySignature {
    fileprivate let secretMagic: Signature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: Signature) {
        self.secretMagic = secretMagic
    }
}

extension NotarySignature: Sendable {}
extension NotarySignature: Equatable, Hashable {
    public static func == (lhs: NotarySignature, rhs: NotarySignature) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeNotarySignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotarySignature {
        return
            try NotarySignature(
                secretMagic: FfiConverterTypeSignature.read(from: &buf)
            )
    }

    public static func write(_ value: NotarySignature, into buf: inout [UInt8]) {
        FfiConverterTypeSignature.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeNotarySignature_lift(_ buf: RustBuffer) throws -> NotarySignature {
    return try FfiConverterTypeNotarySignature.lift(buf)
}

public func FfiConverterTypeNotarySignature_lower(_ value: NotarySignature) -> RustBuffer {
    return FfiConverterTypeNotarySignature.lower(value)
}

/**
 * A factor source representing a Mnemonic the user has to input every time
 * the use the factor source, since it is not saved on the device, it is said
 * to be "off device".
 */
public struct OffDeviceMnemonicFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * Properties describing a OffDeviceMnemonicFactorSource to help user
     * disambiguate between it and another one.
     */
    public var hint: OffDeviceMnemonicHint

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon,
        /**
            * Properties describing a OffDeviceMnemonicFactorSource to help user
            * disambiguate between it and another one.
            */ hint: OffDeviceMnemonicHint
    ) {
        self.id = id
        self.common = common
        self.hint = hint
    }
}

extension OffDeviceMnemonicFactorSource: Sendable {}
extension OffDeviceMnemonicFactorSource: Equatable, Hashable {
    public static func == (lhs: OffDeviceMnemonicFactorSource, rhs: OffDeviceMnemonicFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.hint != rhs.hint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(hint)
    }
}

public struct FfiConverterTypeOffDeviceMnemonicFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OffDeviceMnemonicFactorSource {
        return
            try OffDeviceMnemonicFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                hint: FfiConverterTypeOffDeviceMnemonicHint.read(from: &buf)
            )
    }

    public static func write(_ value: OffDeviceMnemonicFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeOffDeviceMnemonicHint.write(value.hint, into: &buf)
    }
}

public func FfiConverterTypeOffDeviceMnemonicFactorSource_lift(_ buf: RustBuffer) throws -> OffDeviceMnemonicFactorSource {
    return try FfiConverterTypeOffDeviceMnemonicFactorSource.lift(buf)
}

public func FfiConverterTypeOffDeviceMnemonicFactorSource_lower(_ value: OffDeviceMnemonicFactorSource) -> RustBuffer {
    return FfiConverterTypeOffDeviceMnemonicFactorSource.lower(value)
}

/**
 * Properties describing a DeviceFactorSource to help user disambiguate between
 * it and another one.
 */
public struct OffDeviceMnemonicHint {
    public var displayName: DisplayName

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(displayName: DisplayName) {
        self.displayName = displayName
    }
}

extension OffDeviceMnemonicHint: Sendable {}
extension OffDeviceMnemonicHint: Equatable, Hashable {
    public static func == (lhs: OffDeviceMnemonicHint, rhs: OffDeviceMnemonicHint) -> Bool {
        if lhs.displayName != rhs.displayName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(displayName)
    }
}

public struct FfiConverterTypeOffDeviceMnemonicHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OffDeviceMnemonicHint {
        return
            try OffDeviceMnemonicHint(
                displayName: FfiConverterTypeDisplayName.read(from: &buf)
            )
    }

    public static func write(_ value: OffDeviceMnemonicHint, into buf: inout [UInt8]) {
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
    }
}

public func FfiConverterTypeOffDeviceMnemonicHint_lift(_ buf: RustBuffer) throws -> OffDeviceMnemonicHint {
    return try FfiConverterTypeOffDeviceMnemonicHint.lift(buf)
}

public func FfiConverterTypeOffDeviceMnemonicHint_lower(_ value: OffDeviceMnemonicHint) -> RustBuffer {
    return FfiConverterTypeOffDeviceMnemonicHint.lower(value)
}

/**
 * Account settings that user has set on the account component
 * On-Ledger, that is set via a transaction mutating the state
 * on the network.
 *
 * This settings include third-party deposits, controlling who
 * can send which assets to this account.
 *
 * These settings SHOULD be kept in sync between local state
 * (in Profile) and On-Ledger.
 */
public struct OnLedgerSettings {
    /**
     * Controls the ability of third-parties to deposit into this account
     */
    public var thirdPartyDeposits: ThirdPartyDeposits

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Controls the ability of third-parties to deposit into this account
         */ thirdPartyDeposits: ThirdPartyDeposits
    ) {
        self.thirdPartyDeposits = thirdPartyDeposits
    }
}

extension OnLedgerSettings: Sendable {}
extension OnLedgerSettings: Equatable, Hashable {
    public static func == (lhs: OnLedgerSettings, rhs: OnLedgerSettings) -> Bool {
        if lhs.thirdPartyDeposits != rhs.thirdPartyDeposits {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thirdPartyDeposits)
    }
}

public struct FfiConverterTypeOnLedgerSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OnLedgerSettings {
        return
            try OnLedgerSettings(
                thirdPartyDeposits: FfiConverterTypeThirdPartyDeposits.read(from: &buf)
            )
    }

    public static func write(_ value: OnLedgerSettings, into buf: inout [UInt8]) {
        FfiConverterTypeThirdPartyDeposits.write(value.thirdPartyDeposits, into: &buf)
    }
}

public func FfiConverterTypeOnLedgerSettings_lift(_ buf: RustBuffer) throws -> OnLedgerSettings {
    return try FfiConverterTypeOnLedgerSettings.lift(buf)
}

public func FfiConverterTypeOnLedgerSettings_lower(_ value: OnLedgerSettings) -> RustBuffer {
    return FfiConverterTypeOnLedgerSettings.lower(value)
}

/**
 * A client the user have connected P2P with, typically a WebRTC connection with the dApp or Connector Extension.
 * Each client generates a curve25119 keypair. The public key is used as an identifier for the client.
 * The hash of the connection password is used to establish the P2P connection.
 * There can be multiple types of links (trusted vs untrusted) differentiated by `RadixConnectPurpose`.
 * Here are the [CAP-36][doc] requirements.
 *
 * [doc]: https://radixdlt.atlassian.net/wiki/spaces/AT/pages/3251863610/CAP-36+WebRTC+Clients+Protocol
 */
public struct P2pLink {
    /**
     * The most important property of this struct, the `RadixConnectPassword`,
     * is used to be able to re-establish the P2P connection
     */
    public var connectionPassword: RadixConnectPassword
    /**
     * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
     * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
     * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
     */
    public var connectionPurpose: RadixConnectPurpose
    /**
     * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
     * Each client keeps a record of linked clients' public keys to prevent duplicate links.
     * This is the public key of the other client and it also serves as the seed for the link `ID`.
     */
    public var publicKey: Ed25519PublicKey
    /**
     * Client name, e.g. "Chrome on Macbook" or "My work Android" or "My wifes iPhone SE".
     */
    public var displayName: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The most important property of this struct, the `RadixConnectPassword`,
         * is used to be able to re-establish the P2P connection
         */ connectionPassword: RadixConnectPassword,
        /**
            * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
            * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
            * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
            */ connectionPurpose: RadixConnectPurpose,
        /**
            * Each client generates a curve25119 keypair. The public key will be used as an identifier for the client.
            * Each client keeps a record of linked clients' public keys to prevent duplicate links.
            * This is the public key of the other client and it also serves as the seed for the link `ID`.
            */ publicKey: Ed25519PublicKey,
        /**
            * Client name, e.g. "Chrome on Macbook" or "My work Android" or "My wifes iPhone SE".
            */ displayName: String
    ) {
        self.connectionPassword = connectionPassword
        self.connectionPurpose = connectionPurpose
        self.publicKey = publicKey
        self.displayName = displayName
    }
}

extension P2pLink: Sendable {}
extension P2pLink: Equatable, Hashable {
    public static func == (lhs: P2pLink, rhs: P2pLink) -> Bool {
        if lhs.connectionPassword != rhs.connectionPassword {
            return false
        }
        if lhs.connectionPurpose != rhs.connectionPurpose {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(connectionPassword)
        hasher.combine(connectionPurpose)
        hasher.combine(publicKey)
        hasher.combine(displayName)
    }
}

public struct FfiConverterTypeP2PLink: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> P2pLink {
        return
            try P2pLink(
                connectionPassword: FfiConverterTypeRadixConnectPassword.read(from: &buf),
                connectionPurpose: FfiConverterTypeRadixConnectPurpose.read(from: &buf),
                publicKey: FfiConverterTypeEd25519PublicKey.read(from: &buf),
                displayName: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: P2pLink, into buf: inout [UInt8]) {
        FfiConverterTypeRadixConnectPassword.write(value.connectionPassword, into: &buf)
        FfiConverterTypeRadixConnectPurpose.write(value.connectionPurpose, into: &buf)
        FfiConverterTypeEd25519PublicKey.write(value.publicKey, into: &buf)
        FfiConverterString.write(value.displayName, into: &buf)
    }
}

public func FfiConverterTypeP2PLink_lift(_ buf: RustBuffer) throws -> P2pLink {
    return try FfiConverterTypeP2PLink.lift(buf)
}

public func FfiConverterTypeP2PLink_lower(_ value: P2pLink) -> RustBuffer {
    return FfiConverterTypeP2PLink.lower(value)
}

/**
 * The unique address identifying a package - which is a collection of blueprints on Ledger, e.g.:
 * `"package_rdx1pkgxxxxxxxxxfaucetxxxxxxxxx000034355863xxxxxxxxxfaucet"`
 *
 * PackageAddress has [Scrypto's `EntityType`][entt] type `GlobalPackage`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalPackageAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L241C29-L241C42
 */
public struct PackageAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}

extension PackageAddress: Sendable {}
extension PackageAddress: Equatable, Hashable {
    public static func == (lhs: PackageAddress, rhs: PackageAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypePackageAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PackageAddress {
        return
            try PackageAddress(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PackageAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypePackageAddress_lift(_ buf: RustBuffer) throws -> PackageAddress {
    return try FfiConverterTypePackageAddress.lift(buf)
}

public func FfiConverterTypePackageAddress_lower(_ value: PackageAddress) -> RustBuffer {
    return FfiConverterTypePackageAddress.lower(value)
}

/**
 * NOT IMPLEMENTED NOR USED YET
 *
 * A passphrase based FactorSource is essentially a Input Key Material based Mnemonic,
 * user needs to input the passphrase - key material - every time they use this factor source
 */
public struct PassphraseFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon
    ) {
        self.id = id
        self.common = common
    }
}

extension PassphraseFactorSource: Sendable {}
extension PassphraseFactorSource: Equatable, Hashable {
    public static func == (lhs: PassphraseFactorSource, rhs: PassphraseFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
    }
}

public struct FfiConverterTypePassphraseFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PassphraseFactorSource {
        return
            try PassphraseFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf)
            )
    }

    public static func write(_ value: PassphraseFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
    }
}

public func FfiConverterTypePassphraseFactorSource_lift(_ buf: RustBuffer) throws -> PassphraseFactorSource {
    return try FfiConverterTypePassphraseFactorSource.lift(buf)
}

public func FfiConverterTypePassphraseFactorSource_lower(_ value: PassphraseFactorSource) -> RustBuffer {
    return FfiConverterTypePassphraseFactorSource.lower(value)
}

public struct PerAssetFungibleResource {
    public var resourceAddress: ResourceAddress
    public var divisibility: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resourceAddress: ResourceAddress, divisibility: UInt8?) {
        self.resourceAddress = resourceAddress
        self.divisibility = divisibility
    }
}

extension PerAssetFungibleResource: Sendable {}
extension PerAssetFungibleResource: Equatable, Hashable {
    public static func == (lhs: PerAssetFungibleResource, rhs: PerAssetFungibleResource) -> Bool {
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.divisibility != rhs.divisibility {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resourceAddress)
        hasher.combine(divisibility)
    }
}

public struct FfiConverterTypePerAssetFungibleResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetFungibleResource {
        return
            try PerAssetFungibleResource(
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                divisibility: FfiConverterOptionUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetFungibleResource, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterOptionUInt8.write(value.divisibility, into: &buf)
    }
}

public func FfiConverterTypePerAssetFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetFungibleResource {
    return try FfiConverterTypePerAssetFungibleResource.lift(buf)
}

public func FfiConverterTypePerAssetFungibleResource_lower(_ value: PerAssetFungibleResource) -> RustBuffer {
    return FfiConverterTypePerAssetFungibleResource.lower(value)
}

/**
 * A fungible transfer to `recipient`, with a specified amount of tokens to send.
 */
public struct PerAssetFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * Amount
     */
    public var amount: Decimal192
    /**
     * The account or account address to send the tokens to.
     */
    public var recipient: AccountOrAddressOf

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */ useTryDepositOrAbort: Bool,
        /**
            * Amount
            */ amount: Decimal192,
        /**
            * The account or account address to send the tokens to.
            */ recipient: AccountOrAddressOf
    ) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.amount = amount
        self.recipient = recipient
    }
}

extension PerAssetFungibleTransfer: Sendable {}
extension PerAssetFungibleTransfer: Equatable, Hashable {
    public static func == (lhs: PerAssetFungibleTransfer, rhs: PerAssetFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.recipient != rhs.recipient {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(amount)
        hasher.combine(recipient)
    }
}

public struct FfiConverterTypePerAssetFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetFungibleTransfer {
        return
            try PerAssetFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
                amount: FfiConverterTypeDecimal192.read(from: &buf),
                recipient: FfiConverterTypeAccountOrAddressOf.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterTypeAccountOrAddressOf.write(value.recipient, into: &buf)
    }
}

public func FfiConverterTypePerAssetFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerAssetFungibleTransfer {
    return try FfiConverterTypePerAssetFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerAssetFungibleTransfer_lower(_ value: PerAssetFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerAssetFungibleTransfer.lower(value)
}

/**
 * A non fungible transfer to `recipient`, with specified Local IDs to send.
 */
public struct PerAssetNonFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * Amount
     */
    public var nonFungibleLocalIds: [NonFungibleLocalId]
    /**
     * The account or account address to send the tokens to.
     */
    public var recipient: AccountOrAddressOf

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */ useTryDepositOrAbort: Bool,
        /**
            * Amount
            */ nonFungibleLocalIds: [NonFungibleLocalId],
        /**
            * The account or account address to send the tokens to.
            */ recipient: AccountOrAddressOf
    ) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.nonFungibleLocalIds = nonFungibleLocalIds
        self.recipient = recipient
    }
}

extension PerAssetNonFungibleTransfer: Sendable {}
extension PerAssetNonFungibleTransfer: Equatable, Hashable {
    public static func == (lhs: PerAssetNonFungibleTransfer, rhs: PerAssetNonFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.nonFungibleLocalIds != rhs.nonFungibleLocalIds {
            return false
        }
        if lhs.recipient != rhs.recipient {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(nonFungibleLocalIds)
        hasher.combine(recipient)
    }
}

public struct FfiConverterTypePerAssetNonFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetNonFungibleTransfer {
        return
            try PerAssetNonFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
                nonFungibleLocalIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                recipient: FfiConverterTypeAccountOrAddressOf.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetNonFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.nonFungibleLocalIds, into: &buf)
        FfiConverterTypeAccountOrAddressOf.write(value.recipient, into: &buf)
    }
}

public func FfiConverterTypePerAssetNonFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerAssetNonFungibleTransfer {
    return try FfiConverterTypePerAssetNonFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerAssetNonFungibleTransfer_lower(_ value: PerAssetNonFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerAssetNonFungibleTransfer.lower(value)
}

public struct PerAssetTransfers {
    public var fromAccount: AccountAddress
    public var fungibleResources: [PerAssetTransfersOfFungibleResource]
    public var nonFungibleResources: [PerAssetTransfersOfNonFungibleResource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fromAccount: AccountAddress, fungibleResources: [PerAssetTransfersOfFungibleResource], nonFungibleResources: [PerAssetTransfersOfNonFungibleResource]) {
        self.fromAccount = fromAccount
        self.fungibleResources = fungibleResources
        self.nonFungibleResources = nonFungibleResources
    }
}

extension PerAssetTransfers: Sendable {}
extension PerAssetTransfers: Equatable, Hashable {
    public static func == (lhs: PerAssetTransfers, rhs: PerAssetTransfers) -> Bool {
        if lhs.fromAccount != rhs.fromAccount {
            return false
        }
        if lhs.fungibleResources != rhs.fungibleResources {
            return false
        }
        if lhs.nonFungibleResources != rhs.nonFungibleResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fromAccount)
        hasher.combine(fungibleResources)
        hasher.combine(nonFungibleResources)
    }
}

public struct FfiConverterTypePerAssetTransfers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfers {
        return
            try PerAssetTransfers(
                fromAccount: FfiConverterTypeAccountAddress.read(from: &buf),
                fungibleResources: FfiConverterSequenceTypePerAssetTransfersOfFungibleResource.read(from: &buf),
                nonFungibleResources: FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetTransfers, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.fromAccount, into: &buf)
        FfiConverterSequenceTypePerAssetTransfersOfFungibleResource.write(value.fungibleResources, into: &buf)
        FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource.write(value.nonFungibleResources, into: &buf)
    }
}

public func FfiConverterTypePerAssetTransfers_lift(_ buf: RustBuffer) throws -> PerAssetTransfers {
    return try FfiConverterTypePerAssetTransfers.lift(buf)
}

public func FfiConverterTypePerAssetTransfers_lower(_ value: PerAssetTransfers) -> RustBuffer {
    return FfiConverterTypePerAssetTransfers.lower(value)
}

public struct PerAssetTransfersOfFungibleResource {
    public var resource: PerAssetFungibleResource
    public var transfers: [PerAssetFungibleTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resource: PerAssetFungibleResource, transfers: [PerAssetFungibleTransfer]) {
        self.resource = resource
        self.transfers = transfers
    }
}

extension PerAssetTransfersOfFungibleResource: Sendable {}
extension PerAssetTransfersOfFungibleResource: Equatable, Hashable {
    public static func == (lhs: PerAssetTransfersOfFungibleResource, rhs: PerAssetTransfersOfFungibleResource) -> Bool {
        if lhs.resource != rhs.resource {
            return false
        }
        if lhs.transfers != rhs.transfers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resource)
        hasher.combine(transfers)
    }
}

public struct FfiConverterTypePerAssetTransfersOfFungibleResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfersOfFungibleResource {
        return
            try PerAssetTransfersOfFungibleResource(
                resource: FfiConverterTypePerAssetFungibleResource.read(from: &buf),
                transfers: FfiConverterSequenceTypePerAssetFungibleTransfer.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetTransfersOfFungibleResource, into buf: inout [UInt8]) {
        FfiConverterTypePerAssetFungibleResource.write(value.resource, into: &buf)
        FfiConverterSequenceTypePerAssetFungibleTransfer.write(value.transfers, into: &buf)
    }
}

public func FfiConverterTypePerAssetTransfersOfFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetTransfersOfFungibleResource {
    return try FfiConverterTypePerAssetTransfersOfFungibleResource.lift(buf)
}

public func FfiConverterTypePerAssetTransfersOfFungibleResource_lower(_ value: PerAssetTransfersOfFungibleResource) -> RustBuffer {
    return FfiConverterTypePerAssetTransfersOfFungibleResource.lower(value)
}

public struct PerAssetTransfersOfNonFungibleResource {
    public var resource: ResourceAddress
    public var transfers: [PerAssetNonFungibleTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(resource: ResourceAddress, transfers: [PerAssetNonFungibleTransfer]) {
        self.resource = resource
        self.transfers = transfers
    }
}

extension PerAssetTransfersOfNonFungibleResource: Sendable {}
extension PerAssetTransfersOfNonFungibleResource: Equatable, Hashable {
    public static func == (lhs: PerAssetTransfersOfNonFungibleResource, rhs: PerAssetTransfersOfNonFungibleResource) -> Bool {
        if lhs.resource != rhs.resource {
            return false
        }
        if lhs.transfers != rhs.transfers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resource)
        hasher.combine(transfers)
    }
}

public struct FfiConverterTypePerAssetTransfersOfNonFungibleResource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerAssetTransfersOfNonFungibleResource {
        return
            try PerAssetTransfersOfNonFungibleResource(
                resource: FfiConverterTypeResourceAddress.read(from: &buf),
                transfers: FfiConverterSequenceTypePerAssetNonFungibleTransfer.read(from: &buf)
            )
    }

    public static func write(_ value: PerAssetTransfersOfNonFungibleResource, into buf: inout [UInt8]) {
        FfiConverterTypeResourceAddress.write(value.resource, into: &buf)
        FfiConverterSequenceTypePerAssetNonFungibleTransfer.write(value.transfers, into: &buf)
    }
}

public func FfiConverterTypePerAssetTransfersOfNonFungibleResource_lift(_ buf: RustBuffer) throws -> PerAssetTransfersOfNonFungibleResource {
    return try FfiConverterTypePerAssetTransfersOfNonFungibleResource.lift(buf)
}

public func FfiConverterTypePerAssetTransfersOfNonFungibleResource_lower(_ value: PerAssetTransfersOfNonFungibleResource) -> RustBuffer {
    return FfiConverterTypePerAssetTransfersOfNonFungibleResource.lower(value)
}

public struct PerRecipientAssetTransfer {
    public var recipient: AccountOrAddressOf
    public var fungibles: [PerRecipientFungibleTransfer]
    public var nonFungibles: [PerRecipientNonFungibleTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(recipient: AccountOrAddressOf, fungibles: [PerRecipientFungibleTransfer], nonFungibles: [PerRecipientNonFungibleTransfer]) {
        self.recipient = recipient
        self.fungibles = fungibles
        self.nonFungibles = nonFungibles
    }
}

extension PerRecipientAssetTransfer: Sendable {}
extension PerRecipientAssetTransfer: Equatable, Hashable {
    public static func == (lhs: PerRecipientAssetTransfer, rhs: PerRecipientAssetTransfer) -> Bool {
        if lhs.recipient != rhs.recipient {
            return false
        }
        if lhs.fungibles != rhs.fungibles {
            return false
        }
        if lhs.nonFungibles != rhs.nonFungibles {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(recipient)
        hasher.combine(fungibles)
        hasher.combine(nonFungibles)
    }
}

public struct FfiConverterTypePerRecipientAssetTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientAssetTransfer {
        return
            try PerRecipientAssetTransfer(
                recipient: FfiConverterTypeAccountOrAddressOf.read(from: &buf),
                fungibles: FfiConverterSequenceTypePerRecipientFungibleTransfer.read(from: &buf),
                nonFungibles: FfiConverterSequenceTypePerRecipientNonFungibleTransfer.read(from: &buf)
            )
    }

    public static func write(_ value: PerRecipientAssetTransfer, into buf: inout [UInt8]) {
        FfiConverterTypeAccountOrAddressOf.write(value.recipient, into: &buf)
        FfiConverterSequenceTypePerRecipientFungibleTransfer.write(value.fungibles, into: &buf)
        FfiConverterSequenceTypePerRecipientNonFungibleTransfer.write(value.nonFungibles, into: &buf)
    }
}

public func FfiConverterTypePerRecipientAssetTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientAssetTransfer {
    return try FfiConverterTypePerRecipientAssetTransfer.lift(buf)
}

public func FfiConverterTypePerRecipientAssetTransfer_lower(_ value: PerRecipientAssetTransfer) -> RustBuffer {
    return FfiConverterTypePerRecipientAssetTransfer.lower(value)
}

public struct PerRecipientAssetTransfers {
    public var addressOfSender: AccountAddress
    public var transfers: [PerRecipientAssetTransfer]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addressOfSender: AccountAddress, transfers: [PerRecipientAssetTransfer]) {
        self.addressOfSender = addressOfSender
        self.transfers = transfers
    }
}

extension PerRecipientAssetTransfers: Sendable {}
extension PerRecipientAssetTransfers: Equatable, Hashable {
    public static func == (lhs: PerRecipientAssetTransfers, rhs: PerRecipientAssetTransfers) -> Bool {
        if lhs.addressOfSender != rhs.addressOfSender {
            return false
        }
        if lhs.transfers != rhs.transfers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addressOfSender)
        hasher.combine(transfers)
    }
}

public struct FfiConverterTypePerRecipientAssetTransfers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientAssetTransfers {
        return
            try PerRecipientAssetTransfers(
                addressOfSender: FfiConverterTypeAccountAddress.read(from: &buf),
                transfers: FfiConverterSequenceTypePerRecipientAssetTransfer.read(from: &buf)
            )
    }

    public static func write(_ value: PerRecipientAssetTransfers, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.addressOfSender, into: &buf)
        FfiConverterSequenceTypePerRecipientAssetTransfer.write(value.transfers, into: &buf)
    }
}

public func FfiConverterTypePerRecipientAssetTransfers_lift(_ buf: RustBuffer) throws -> PerRecipientAssetTransfers {
    return try FfiConverterTypePerRecipientAssetTransfers.lift(buf)
}

public func FfiConverterTypePerRecipientAssetTransfers_lower(_ value: PerRecipientAssetTransfers) -> RustBuffer {
    return FfiConverterTypePerRecipientAssetTransfers.lower(value)
}

/**
 * A fungible transfer of `resource_address` token, with a specified amount
 * of tokens and divisibility.
 */
public struct PerRecipientFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * Amount
     */
    public var amount: Decimal192
    public var divisibility: UInt8?
    /**
     * The address of the resource being sent
     */
    public var resourceAddress: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */ useTryDepositOrAbort: Bool,
        /**
            * Amount
            */ amount: Decimal192, divisibility: UInt8?,
        /**
            * The address of the resource being sent
            */ resourceAddress: ResourceAddress
    ) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.amount = amount
        self.divisibility = divisibility
        self.resourceAddress = resourceAddress
    }
}

extension PerRecipientFungibleTransfer: Sendable {}
extension PerRecipientFungibleTransfer: Equatable, Hashable {
    public static func == (lhs: PerRecipientFungibleTransfer, rhs: PerRecipientFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.divisibility != rhs.divisibility {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(amount)
        hasher.combine(divisibility)
        hasher.combine(resourceAddress)
    }
}

public struct FfiConverterTypePerRecipientFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientFungibleTransfer {
        return
            try PerRecipientFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
                amount: FfiConverterTypeDecimal192.read(from: &buf),
                divisibility: FfiConverterOptionUInt8.read(from: &buf),
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PerRecipientFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterOptionUInt8.write(value.divisibility, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
    }
}

public func FfiConverterTypePerRecipientFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientFungibleTransfer {
    return try FfiConverterTypePerRecipientFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerRecipientFungibleTransfer_lower(_ value: PerRecipientFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerRecipientFungibleTransfer.lower(value)
}

/**
 * A non fungible transfer of `resource_address` token, with specified Local IDs to send.
 */
public struct PerRecipientNonFungibleTransfer {
    /**
     * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
     * typically wallets sets this to try if and only if the recipient is a self-owned account
     * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
     * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
     * which resource is known (`resource_address` is owned or has been owned before).
     */
    public var useTryDepositOrAbort: Bool
    /**
     * The local IDS of the NonFungible tokens being sent
     */
    public var localIds: [NonFungibleLocalId]
    /**
     * The address of the resource being sent
     */
    public var resourceAddress: ResourceAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * If `true` the `try_deposit_batch_or_abort` method will be used instead of `deposit`,
         * typically wallets sets this to try if and only if the recipient is a self-owned account
         * (`AccountOrAddressOf::ProfileAccount`) controlled by a DeviceFactorSource thy have
         * access to and which third party deposit setting's `DepositRule` is `AcceptKnown` and
         * which resource is known (`resource_address` is owned or has been owned before).
         */ useTryDepositOrAbort: Bool,
        /**
            * The local IDS of the NonFungible tokens being sent
            */ localIds: [NonFungibleLocalId],
        /**
            * The address of the resource being sent
            */ resourceAddress: ResourceAddress
    ) {
        self.useTryDepositOrAbort = useTryDepositOrAbort
        self.localIds = localIds
        self.resourceAddress = resourceAddress
    }
}

extension PerRecipientNonFungibleTransfer: Sendable {}
extension PerRecipientNonFungibleTransfer: Equatable, Hashable {
    public static func == (lhs: PerRecipientNonFungibleTransfer, rhs: PerRecipientNonFungibleTransfer) -> Bool {
        if lhs.useTryDepositOrAbort != rhs.useTryDepositOrAbort {
            return false
        }
        if lhs.localIds != rhs.localIds {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(useTryDepositOrAbort)
        hasher.combine(localIds)
        hasher.combine(resourceAddress)
    }
}

public struct FfiConverterTypePerRecipientNonFungibleTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PerRecipientNonFungibleTransfer {
        return
            try PerRecipientNonFungibleTransfer(
                useTryDepositOrAbort: FfiConverterBool.read(from: &buf),
                localIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PerRecipientNonFungibleTransfer, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.useTryDepositOrAbort, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.localIds, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
    }
}

public func FfiConverterTypePerRecipientNonFungibleTransfer_lift(_ buf: RustBuffer) throws -> PerRecipientNonFungibleTransfer {
    return try FfiConverterTypePerRecipientNonFungibleTransfer.lift(buf)
}

public func FfiConverterTypePerRecipientNonFungibleTransfer_lower(_ value: PerRecipientNonFungibleTransfer) -> RustBuffer {
    return FfiConverterTypePerRecipientNonFungibleTransfer.lower(value)
}

/**
 * A Persona is an identity a user chooses to login to a dApp with, using
 * RadixConnect - Radix decentralized login solution. A persona is very
 * similar to [`Account`]s, in the sense that they are On-Network/On-Ledger
 * components, with a unique network dependent address ([`IdentityAddress`])
 * and with a security state (see [`EntitySecurityState`]) knowing which
 * factor instances that control this component, but with one important
 * difference: a Persona cannot hold funds. It is impossible to transfer
 * any asset to a Persona. The On-Network component representation of
 * the Persona is called `Identity`. The concept "Persona" is a Radix
 * Wallet (Profile) *application* of an Identity.
 *
 * Personas have data (see [`PersonaData`]), which is personal information
 * a user has associated with a this Persona, of different kinds, such as name,
 * email address(es) or phone number(s). The `PersonaData` is **never** uploaded
 * to the Radix Network, i.e. it is a pure Radix Wallet (Profile) construct,
 * On-Network Identities does not know of PersonaData, and never will (well
 * technically, nothing stops a user from building their own wallet and uploading
 * personal information to the metadata of the Identity component... but `Sargon`
 * never will, nor will the Radix Wallet.).
 */
public struct Persona {
    /**
     * The ID of the network this account can be used with.
     */
    public var networkId: NetworkId
    /**
     * The address of an identity, used by Personas, a bech32 encoding of a public key hash
     * that starts with the prefix `"identity_"`, dependent on NetworkID, meaning the same
     * public key used for two IdentityAddresses on two different networks will not have
     * the same address.
     */
    public var address: IdentityAddress
    /**
     * An off-ledger display name or description chosen by the user when they
     * created this persona.
     */
    public var displayName: DisplayName
    /**
     * Describes the state this Persona is in, in regards to how
     * the user controls it, i.e. if it is controlled by a single factor (private key)
     * or an `AccessController` with a potential Multi-Factor setup.
     */
    public var securityState: EntitySecurityState
    /**
     * An order set of `EntityFlag`s used to describe certain Off-ledger
     * user state about this Persona, e.g. if it is marked as hidden or not.
     */
    public var flags: [EntityFlag]
    /**
     * Personal information a user has associated with a certain Persona, of different kinds, such as name,
     * email address(es) or phone number(s). This information is only ever stored in Profile and is never
     * uploaded to the Radix Network.
     */
    public var personaData: PersonaData

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network this account can be used with.
         */ networkId: NetworkId,
        /**
            * The address of an identity, used by Personas, a bech32 encoding of a public key hash
            * that starts with the prefix `"identity_"`, dependent on NetworkID, meaning the same
            * public key used for two IdentityAddresses on two different networks will not have
            * the same address.
            */ address: IdentityAddress,
        /**
            * An off-ledger display name or description chosen by the user when they
            * created this persona.
            */ displayName: DisplayName,
        /**
            * Describes the state this Persona is in, in regards to how
            * the user controls it, i.e. if it is controlled by a single factor (private key)
            * or an `AccessController` with a potential Multi-Factor setup.
            */ securityState: EntitySecurityState,
        /**
            * An order set of `EntityFlag`s used to describe certain Off-ledger
            * user state about this Persona, e.g. if it is marked as hidden or not.
            */ flags: [EntityFlag],
        /**
            * Personal information a user has associated with a certain Persona, of different kinds, such as name,
            * email address(es) or phone number(s). This information is only ever stored in Profile and is never
            * uploaded to the Radix Network.
            */ personaData: PersonaData
    ) {
        self.networkId = networkId
        self.address = address
        self.displayName = displayName
        self.securityState = securityState
        self.flags = flags
        self.personaData = personaData
    }
}

extension Persona: Sendable {}
extension Persona: Equatable, Hashable {
    public static func == (lhs: Persona, rhs: Persona) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.address != rhs.address {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.securityState != rhs.securityState {
            return false
        }
        if lhs.flags != rhs.flags {
            return false
        }
        if lhs.personaData != rhs.personaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(address)
        hasher.combine(displayName)
        hasher.combine(securityState)
        hasher.combine(flags)
        hasher.combine(personaData)
    }
}

public struct FfiConverterTypePersona: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Persona {
        return
            try Persona(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                address: FfiConverterTypeIdentityAddress.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                securityState: FfiConverterTypeEntitySecurityState.read(from: &buf),
                flags: FfiConverterSequenceTypeEntityFlag.read(from: &buf),
                personaData: FfiConverterTypePersonaData.read(from: &buf)
            )
    }

    public static func write(_ value: Persona, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeIdentityAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeEntitySecurityState.write(value.securityState, into: &buf)
        FfiConverterSequenceTypeEntityFlag.write(value.flags, into: &buf)
        FfiConverterTypePersonaData.write(value.personaData, into: &buf)
    }
}

public func FfiConverterTypePersona_lift(_ buf: RustBuffer) throws -> Persona {
    return try FfiConverterTypePersona.lift(buf)
}

public func FfiConverterTypePersona_lower(_ value: Persona) -> RustBuffer {
    return FfiConverterTypePersona.lower(value)
}

/**
 * Personal information a user has associated with a certain Persona, of different kinds, such as name,
 * email address(es) or phone number(s). This information is only ever stored in Profile and is never
 * uploaded to the Radix Network.
 *
 * These entries of different kinds can be queried for in a request sent by a dApp, e.g.
 * Radix Dashboard might ask "Give me ongoing access to Name and 2 Email addresses for
 * a Persona" (just a silly example, Radix Dashboard would never ask for that and why 2 email addresses?).
 *
 * The Profile will then use the fact that each Persona Data Entry has a stable ID so that Profile can
 * refer the entry just by the ID, and Profile can thus record which Persona Data Entry a user has selected
 * to share with the dApp, without duplicating the value of that entry (just like how we use FactorSourceIDs).
 * Since a dApp can ask for *ongoing* access next time the user interacts with the same dApp, if user has
 * not revoked the dApps access, the wallet clients will automatically send back the Persona Data Entry values
 * even if they have been updated - the value might have changed but their IDs have not. Thus if a user
 * deletes a Persona Data Entry (e.g. a phone number), and later re-inputs the same phone number, even
 * it the exact same value is used, it will still be treated as a new entry since its ID is new, meaning
 * that the next time the user interacts with a previously authorized dApp the wallet cannot automatically
 * respond back to dApp with the PersonaData, but user will have to re-authorize the request for ongoing
 * access for the requested PersonaData entries.
 */
public struct PersonaData {
    /**
     * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
     * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
     *
     * Note that the type is Option of `PersonaDataIdentifiedName` and not of type [`PersonaDataEntryName`][name],
     * `PersonaDataIdentifiedName` is essentially a tuple of `(Uuid, PersonaDataEntryName)`.
     *
     * [name]: PersonaDataEntryName
     */
    public var name: PersonaDataIdentifiedName?
    /**
     * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
     * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
     * contain elements with the same value, but under different IDs.
     */
    public var phoneNumbers: CollectionOfPhoneNumbers
    /**
     * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
     * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
     * contain elements with the same value, but under different IDs.
     */
    public var emailAddresses: CollectionOfEmailAddresses

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
         * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
         *
         * Note that the type is Option of `PersonaDataIdentifiedName` and not of type [`PersonaDataEntryName`][name],
         * `PersonaDataIdentifiedName` is essentially a tuple of `(Uuid, PersonaDataEntryName)`.
         *
         * [name]: PersonaDataEntryName
         */ name: PersonaDataIdentifiedName?,
        /**
            * A collection of [`PersonaDataIdentifiedPhoneNumber`]s, which is essentially a tuple of
            * `(Uuid, PersonaDataEntryPhoneNumber)`, each element is identifiable by its ID. Can be empty, can
            * contain elements with the same value, but under different IDs.
            */ phoneNumbers: CollectionOfPhoneNumbers,
        /**
            * A collection of [`PersonaDataEntryEmailAddress`]s, which is essentially a tuple of
            * `(Uuid, PersonaDataIdentifiedEmailAddress)`, each element is identifiable by its ID. Can be empty, can
            * contain elements with the same value, but under different IDs.
            */ emailAddresses: CollectionOfEmailAddresses
    ) {
        self.name = name
        self.phoneNumbers = phoneNumbers
        self.emailAddresses = emailAddresses
    }
}

extension PersonaData: Sendable {}
extension PersonaData: Equatable, Hashable {
    public static func == (lhs: PersonaData, rhs: PersonaData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(phoneNumbers)
        hasher.combine(emailAddresses)
    }
}

public struct FfiConverterTypePersonaData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaData {
        return
            try PersonaData(
                name: FfiConverterOptionTypePersonaDataIdentifiedName.read(from: &buf),
                phoneNumbers: FfiConverterTypeCollectionOfPhoneNumbers.read(from: &buf),
                emailAddresses: FfiConverterTypeCollectionOfEmailAddresses.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaData, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataIdentifiedName.write(value.name, into: &buf)
        FfiConverterTypeCollectionOfPhoneNumbers.write(value.phoneNumbers, into: &buf)
        FfiConverterTypeCollectionOfEmailAddresses.write(value.emailAddresses, into: &buf)
    }
}

public func FfiConverterTypePersonaData_lift(_ buf: RustBuffer) throws -> PersonaData {
    return try FfiConverterTypePersonaData.lift(buf)
}

public func FfiConverterTypePersonaData_lower(_ value: PersonaData) -> RustBuffer {
    return FfiConverterTypePersonaData.lower(value)
}

/**
 * A persons name they have chosen to associated with a Persona, e.g. "Bruce 'Batman' Wayne" using Western name variant,
 * or `"Jun-fan 'Bruce' Lee"` using Eastern name variant (family name comes before given name(s)).
 *
 * Nickname is optional in the sense that it can be left blank. Family name and given names are never empty.
 *
 * If a name has multiple given names, they all go into the `given_names` String, e.g. Pippi Longstocking's real name -
 * her Swedish name - is in full: "Pippilotta Viktualia Rullgardina Krusmynta Efraimsdotter Långstrump", where her
 * given names: "Pippilotta Viktualia Rullgardina Krusmynta Efraimsdotter" are put in the `given_names` field, and
 * "Långstrump" (Longstocking) is her family name.
 */
public struct PersonaDataEntryName {
    public var variant: PersonaDataNameVariant
    public var familyName: String
    public var givenNames: String
    public var nickname: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(variant: PersonaDataNameVariant, familyName: String, givenNames: String, nickname: String) {
        self.variant = variant
        self.familyName = familyName
        self.givenNames = givenNames
        self.nickname = nickname
    }
}

extension PersonaDataEntryName: Sendable {}
extension PersonaDataEntryName: Equatable, Hashable {
    public static func == (lhs: PersonaDataEntryName, rhs: PersonaDataEntryName) -> Bool {
        if lhs.variant != rhs.variant {
            return false
        }
        if lhs.familyName != rhs.familyName {
            return false
        }
        if lhs.givenNames != rhs.givenNames {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(variant)
        hasher.combine(familyName)
        hasher.combine(givenNames)
        hasher.combine(nickname)
    }
}

public struct FfiConverterTypePersonaDataEntryName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryName {
        return
            try PersonaDataEntryName(
                variant: FfiConverterTypePersonaDataNameVariant.read(from: &buf),
                familyName: FfiConverterString.read(from: &buf),
                givenNames: FfiConverterString.read(from: &buf),
                nickname: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataEntryName, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataNameVariant.write(value.variant, into: &buf)
        FfiConverterString.write(value.familyName, into: &buf)
        FfiConverterString.write(value.givenNames, into: &buf)
        FfiConverterString.write(value.nickname, into: &buf)
    }
}

public func FfiConverterTypePersonaDataEntryName_lift(_ buf: RustBuffer) throws -> PersonaDataEntryName {
    return try FfiConverterTypePersonaDataEntryName.lift(buf)
}

public func FfiConverterTypePersonaDataEntryName_lower(_ value: PersonaDataEntryName) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryName.lower(value)
}

/**
 * A persons telephone number they have chosen to associated with a Persona, e.g.
 * `+46 987 654 321` (don't try calling this number, it does not exist).
 *
 * Current implementation does not validate the phone number other than it
 * cannot be empty, since telephone number validation is tricky.
 */
public struct PersonaDataEntryPhoneNumber {
    public var number: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(number: String) {
        self.number = number
    }
}

extension PersonaDataEntryPhoneNumber: Sendable {}
extension PersonaDataEntryPhoneNumber: Equatable, Hashable {
    public static func == (lhs: PersonaDataEntryPhoneNumber, rhs: PersonaDataEntryPhoneNumber) -> Bool {
        if lhs.number != rhs.number {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(number)
    }
}

public struct FfiConverterTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryPhoneNumber {
        return
            try PersonaDataEntryPhoneNumber(
                number: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataEntryPhoneNumber, into buf: inout [UInt8]) {
        FfiConverterString.write(value.number, into: &buf)
    }
}

public func FfiConverterTypePersonaDataEntryPhoneNumber_lift(_ buf: RustBuffer) throws -> PersonaDataEntryPhoneNumber {
    return try FfiConverterTypePersonaDataEntryPhoneNumber.lift(buf)
}

public func FfiConverterTypePersonaDataEntryPhoneNumber_lower(_ value: PersonaDataEntryPhoneNumber) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryPhoneNumber.lower(value)
}

/**
 * An identifiable Persona email address. Essentially it is a tuple of a
 * [`(PersonaDataEntryEmailAddress, Uuid)`].
 */
public struct PersonaDataIdentifiedEmailAddress {
    public var id: PersonaDataEntryId
    public var value: EmailAddress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PersonaDataEntryId, value: EmailAddress) {
        self.id = id
        self.value = value
    }
}

extension PersonaDataIdentifiedEmailAddress: Sendable {}
extension PersonaDataIdentifiedEmailAddress: Equatable, Hashable {
    public static func == (lhs: PersonaDataIdentifiedEmailAddress, rhs: PersonaDataIdentifiedEmailAddress) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}

public struct FfiConverterTypePersonaDataIdentifiedEmailAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedEmailAddress {
        return
            try PersonaDataIdentifiedEmailAddress(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
                value: FfiConverterTypeEmailAddress.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataIdentifiedEmailAddress, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypeEmailAddress.write(value.value, into: &buf)
    }
}

public func FfiConverterTypePersonaDataIdentifiedEmailAddress_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedEmailAddress {
    return try FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedEmailAddress_lower(_ value: PersonaDataIdentifiedEmailAddress) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedEmailAddress.lower(value)
}

/**
 * An identifiable Persona name. Essentially it is a tuple of a
 * [`(PersonaDataEntryName, Uuid)`].
 */
public struct PersonaDataIdentifiedName {
    public var id: PersonaDataEntryId
    public var value: PersonaDataEntryName

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PersonaDataEntryId, value: PersonaDataEntryName) {
        self.id = id
        self.value = value
    }
}

extension PersonaDataIdentifiedName: Sendable {}
extension PersonaDataIdentifiedName: Equatable, Hashable {
    public static func == (lhs: PersonaDataIdentifiedName, rhs: PersonaDataIdentifiedName) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}

public struct FfiConverterTypePersonaDataIdentifiedName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedName {
        return
            try PersonaDataIdentifiedName(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
                value: FfiConverterTypePersonaDataEntryName.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataIdentifiedName, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypePersonaDataEntryName.write(value.value, into: &buf)
    }
}

public func FfiConverterTypePersonaDataIdentifiedName_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedName {
    return try FfiConverterTypePersonaDataIdentifiedName.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedName_lower(_ value: PersonaDataIdentifiedName) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedName.lower(value)
}

/**
 * An identifiable Persona phone number. Essentially it is a tuple of a
 * [`(PersonaDataEntryPhoneNumber, Uuid)`].
 */
public struct PersonaDataIdentifiedPhoneNumber {
    public var id: PersonaDataEntryId
    public var value: PersonaDataEntryPhoneNumber

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PersonaDataEntryId, value: PersonaDataEntryPhoneNumber) {
        self.id = id
        self.value = value
    }
}

extension PersonaDataIdentifiedPhoneNumber: Sendable {}
extension PersonaDataIdentifiedPhoneNumber: Equatable, Hashable {
    public static func == (lhs: PersonaDataIdentifiedPhoneNumber, rhs: PersonaDataIdentifiedPhoneNumber) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(value)
    }
}

public struct FfiConverterTypePersonaDataIdentifiedPhoneNumber: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataIdentifiedPhoneNumber {
        return
            try PersonaDataIdentifiedPhoneNumber(
                id: FfiConverterTypePersonaDataEntryID.read(from: &buf),
                value: FfiConverterTypePersonaDataEntryPhoneNumber.read(from: &buf)
            )
    }

    public static func write(_ value: PersonaDataIdentifiedPhoneNumber, into buf: inout [UInt8]) {
        FfiConverterTypePersonaDataEntryID.write(value.id, into: &buf)
        FfiConverterTypePersonaDataEntryPhoneNumber.write(value.value, into: &buf)
    }
}

public func FfiConverterTypePersonaDataIdentifiedPhoneNumber_lift(_ buf: RustBuffer) throws -> PersonaDataIdentifiedPhoneNumber {
    return try FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(buf)
}

public func FfiConverterTypePersonaDataIdentifiedPhoneNumber_lower(_ value: PersonaDataIdentifiedPhoneNumber) -> RustBuffer {
    return FfiConverterTypePersonaDataIdentifiedPhoneNumber.lower(value)
}

public struct PlaintextMessage {
    public var mimeType: String
    public var message: MessageContents

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mimeType: String, message: MessageContents) {
        self.mimeType = mimeType
        self.message = message
    }
}

extension PlaintextMessage: Sendable {}
extension PlaintextMessage: Equatable, Hashable {
    public static func == (lhs: PlaintextMessage, rhs: PlaintextMessage) -> Bool {
        if lhs.mimeType != rhs.mimeType {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mimeType)
        hasher.combine(message)
    }
}

public struct FfiConverterTypePlaintextMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PlaintextMessage {
        return
            try PlaintextMessage(
                mimeType: FfiConverterString.read(from: &buf),
                message: FfiConverterTypeMessageContents.read(from: &buf)
            )
    }

    public static func write(_ value: PlaintextMessage, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mimeType, into: &buf)
        FfiConverterTypeMessageContents.write(value.message, into: &buf)
    }
}

public func FfiConverterTypePlaintextMessage_lift(_ buf: RustBuffer) throws -> PlaintextMessage {
    return try FfiConverterTypePlaintextMessage.lift(buf)
}

public func FfiConverterTypePlaintextMessage_lower(_ value: PlaintextMessage) -> RustBuffer {
    return FfiConverterTypePlaintextMessage.lower(value)
}

/**
 * Addresses identifying an OnLedger (OnNetwork) Liquidity Pool (LP) of tokens that users can contribute
 * Liquidity too, e.g.:
 * `"pool_rdx1c325zs6dz3un8ykkjavy9fkvvyzarkaehgsl408qup6f95aup3le3w"`
 *
 * Typically users contribute to Liquidity Pools by using a Dapp and the Radix Wallet.
 *
 * There are fundamentally three different sub-types ([Scrypto's `EntityType`][entt]) of PoolAddresses:
 * * GlobalOneResourcePool
 * * GlobalTwoResourcePool
 * * GlobalMultiResourcePool
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalPoolAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L256-L261
 */
public struct PoolAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}

extension PoolAddress: Sendable {}
extension PoolAddress: Equatable, Hashable {
    public static func == (lhs: PoolAddress, rhs: PoolAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypePoolAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PoolAddress {
        return
            try PoolAddress(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: PoolAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypePoolAddress_lift(_ buf: RustBuffer) throws -> PoolAddress {
    return try FfiConverterTypePoolAddress.lift(buf)
}

public func FfiConverterTypePoolAddress_lower(_ value: PoolAddress) -> RustBuffer {
    return FfiConverterTypePoolAddress.lower(value)
}

/**
 * Pre-Auth analysis enclosed manifest, which does not contain any interactions with the parent manifest,
 * thus its preview can be computed as if it would have been a standalone transaction.
 */
public struct PreAuthEnclosedManifest {
    public var manifest: SubintentManifest
    public var summary: ExecutionSummary

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(manifest: SubintentManifest, summary: ExecutionSummary) {
        self.manifest = manifest
        self.summary = summary
    }
}

extension PreAuthEnclosedManifest: Sendable {}
extension PreAuthEnclosedManifest: Equatable, Hashable {
    public static func == (lhs: PreAuthEnclosedManifest, rhs: PreAuthEnclosedManifest) -> Bool {
        if lhs.manifest != rhs.manifest {
            return false
        }
        if lhs.summary != rhs.summary {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(manifest)
        hasher.combine(summary)
    }
}

public struct FfiConverterTypePreAuthEnclosedManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreAuthEnclosedManifest {
        return
            try PreAuthEnclosedManifest(
                manifest: FfiConverterTypeSubintentManifest.read(from: &buf),
                summary: FfiConverterTypeExecutionSummary.read(from: &buf)
            )
    }

    public static func write(_ value: PreAuthEnclosedManifest, into buf: inout [UInt8]) {
        FfiConverterTypeSubintentManifest.write(value.manifest, into: &buf)
        FfiConverterTypeExecutionSummary.write(value.summary, into: &buf)
    }
}

public func FfiConverterTypePreAuthEnclosedManifest_lift(_ buf: RustBuffer) throws -> PreAuthEnclosedManifest {
    return try FfiConverterTypePreAuthEnclosedManifest.lift(buf)
}

public func FfiConverterTypePreAuthEnclosedManifest_lower(_ value: PreAuthEnclosedManifest) -> RustBuffer {
    return FfiConverterTypePreAuthEnclosedManifest.lower(value)
}

/**
 * Pre-Auth analysis open manifest, which contains multiple interactions with the parent manifest,
 * thus its preview can be computed only based on the static analysis manifest summary
 */
public struct PreAuthOpenManifest {
    public var manifest: SubintentManifest
    public var summary: ManifestSummary

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(manifest: SubintentManifest, summary: ManifestSummary) {
        self.manifest = manifest
        self.summary = summary
    }
}

extension PreAuthOpenManifest: Sendable {}
extension PreAuthOpenManifest: Equatable, Hashable {
    public static func == (lhs: PreAuthOpenManifest, rhs: PreAuthOpenManifest) -> Bool {
        if lhs.manifest != rhs.manifest {
            return false
        }
        if lhs.summary != rhs.summary {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(manifest)
        hasher.combine(summary)
    }
}

public struct FfiConverterTypePreAuthOpenManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreAuthOpenManifest {
        return
            try PreAuthOpenManifest(
                manifest: FfiConverterTypeSubintentManifest.read(from: &buf),
                summary: FfiConverterTypeManifestSummary.read(from: &buf)
            )
    }

    public static func write(_ value: PreAuthOpenManifest, into buf: inout [UInt8]) {
        FfiConverterTypeSubintentManifest.write(value.manifest, into: &buf)
        FfiConverterTypeManifestSummary.write(value.summary, into: &buf)
    }
}

public func FfiConverterTypePreAuthOpenManifest_lift(_ buf: RustBuffer) throws -> PreAuthOpenManifest {
    return try FfiConverterTypePreAuthOpenManifest.lift(buf)
}

public func FfiConverterTypePreAuthOpenManifest_lower(_ value: PreAuthOpenManifest) -> RustBuffer {
    return FfiConverterTypePreAuthOpenManifest.lower(value)
}

public struct PredictedDecimal {
    public var value: Decimal192
    public var instructionIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Decimal192, instructionIndex: UInt64) {
        self.value = value
        self.instructionIndex = instructionIndex
    }
}

extension PredictedDecimal: Sendable {}
extension PredictedDecimal: Equatable, Hashable {
    public static func == (lhs: PredictedDecimal, rhs: PredictedDecimal) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(instructionIndex)
    }
}

public struct FfiConverterTypePredictedDecimal: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredictedDecimal {
        return
            try PredictedDecimal(
                value: FfiConverterTypeDecimal192.read(from: &buf),
                instructionIndex: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: PredictedDecimal, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
    }
}

public func FfiConverterTypePredictedDecimal_lift(_ buf: RustBuffer) throws -> PredictedDecimal {
    return try FfiConverterTypePredictedDecimal.lift(buf)
}

public func FfiConverterTypePredictedDecimal_lower(_ value: PredictedDecimal) -> RustBuffer {
    return FfiConverterTypePredictedDecimal.lower(value)
}

public struct PredictedNonFungibleLocalIds {
    public var value: [NonFungibleLocalId]
    public var instructionIndex: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: [NonFungibleLocalId], instructionIndex: UInt64) {
        self.value = value
        self.instructionIndex = instructionIndex
    }
}

extension PredictedNonFungibleLocalIds: Sendable {}
extension PredictedNonFungibleLocalIds: Equatable, Hashable {
    public static func == (lhs: PredictedNonFungibleLocalIds, rhs: PredictedNonFungibleLocalIds) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
        hasher.combine(instructionIndex)
    }
}

public struct FfiConverterTypePredictedNonFungibleLocalIds: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredictedNonFungibleLocalIds {
        return
            try PredictedNonFungibleLocalIds(
                value: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                instructionIndex: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: PredictedNonFungibleLocalIds, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.value, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
    }
}

public func FfiConverterTypePredictedNonFungibleLocalIds_lift(_ buf: RustBuffer) throws -> PredictedNonFungibleLocalIds {
    return try FfiConverterTypePredictedNonFungibleLocalIds.lift(buf)
}

public func FfiConverterTypePredictedNonFungibleLocalIds_lower(_ value: PredictedNonFungibleLocalIds) -> RustBuffer {
    return FfiConverterTypePredictedNonFungibleLocalIds.lower(value)
}

/**
 * PrimaryRole is used for Signing Transactions.
 */
public struct PrimaryRoleWithFactorInstances {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorInstance]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorInstance],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorInstance]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension PrimaryRoleWithFactorInstances: Sendable {}
extension PrimaryRoleWithFactorInstances: Equatable, Hashable {
    public static func == (lhs: PrimaryRoleWithFactorInstances, rhs: PrimaryRoleWithFactorInstances) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypePrimaryRoleWithFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimaryRoleWithFactorInstances {
        return
            try PrimaryRoleWithFactorInstances(
                thresholdFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf)
            )
    }

    public static func write(_ value: PrimaryRoleWithFactorInstances, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorInstance.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorInstance.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypePrimaryRoleWithFactorInstances_lift(_ buf: RustBuffer) throws -> PrimaryRoleWithFactorInstances {
    return try FfiConverterTypePrimaryRoleWithFactorInstances.lift(buf)
}

public func FfiConverterTypePrimaryRoleWithFactorInstances_lower(_ value: PrimaryRoleWithFactorInstances) -> RustBuffer {
    return FfiConverterTypePrimaryRoleWithFactorInstances.lower(value)
}

/**
 * PrimaryRole is used for Signing Transactions.
 */
public struct PrimaryRoleWithFactorSourceIDs {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorSourceId]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSourceId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorSourceId],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorSourceId]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension PrimaryRoleWithFactorSourceIDs: Sendable {}
extension PrimaryRoleWithFactorSourceIDs: Equatable, Hashable {
    public static func == (lhs: PrimaryRoleWithFactorSourceIDs, rhs: PrimaryRoleWithFactorSourceIDs) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypePrimaryRoleWithFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimaryRoleWithFactorSourceIDs {
        return
            try PrimaryRoleWithFactorSourceIDs(
                thresholdFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
            )
    }

    public static func write(_ value: PrimaryRoleWithFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorSourceID.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSourceID.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypePrimaryRoleWithFactorSourceIDs_lift(_ buf: RustBuffer) throws -> PrimaryRoleWithFactorSourceIDs {
    return try FfiConverterTypePrimaryRoleWithFactorSourceIDs.lift(buf)
}

public func FfiConverterTypePrimaryRoleWithFactorSourceIDs_lower(_ value: PrimaryRoleWithFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypePrimaryRoleWithFactorSourceIDs.lower(value)
}

/**
 * PrimaryRole is used for Signing Transactions.
 */
public struct PrimaryRoleWithFactorSources {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorSource]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorSource],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorSource]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension PrimaryRoleWithFactorSources: Sendable {}
extension PrimaryRoleWithFactorSources: Equatable, Hashable {
    public static func == (lhs: PrimaryRoleWithFactorSources, rhs: PrimaryRoleWithFactorSources) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypePrimaryRoleWithFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimaryRoleWithFactorSources {
        return
            try PrimaryRoleWithFactorSources(
                thresholdFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf)
            )
    }

    public static func write(_ value: PrimaryRoleWithFactorSources, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorSource.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypePrimaryRoleWithFactorSources_lift(_ buf: RustBuffer) throws -> PrimaryRoleWithFactorSources {
    return try FfiConverterTypePrimaryRoleWithFactorSources.lift(buf)
}

public func FfiConverterTypePrimaryRoleWithFactorSources_lower(_ value: PrimaryRoleWithFactorSources) -> RustBuffer {
    return FfiConverterTypePrimaryRoleWithFactorSources.lower(value)
}

public struct PrivateHierarchicalDeterministicFactorSource {
    public var mnemonicWithPassphrase: MnemonicWithPassphrase
    public var factorSource: DeviceFactorSource

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mnemonicWithPassphrase: MnemonicWithPassphrase, factorSource: DeviceFactorSource) {
        self.mnemonicWithPassphrase = mnemonicWithPassphrase
        self.factorSource = factorSource
    }
}

extension PrivateHierarchicalDeterministicFactorSource: Sendable {}
extension PrivateHierarchicalDeterministicFactorSource: Equatable, Hashable {
    public static func == (lhs: PrivateHierarchicalDeterministicFactorSource, rhs: PrivateHierarchicalDeterministicFactorSource) -> Bool {
        if lhs.mnemonicWithPassphrase != rhs.mnemonicWithPassphrase {
            return false
        }
        if lhs.factorSource != rhs.factorSource {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(mnemonicWithPassphrase)
        hasher.combine(factorSource)
    }
}

public struct FfiConverterTypePrivateHierarchicalDeterministicFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrivateHierarchicalDeterministicFactorSource {
        return
            try PrivateHierarchicalDeterministicFactorSource(
                mnemonicWithPassphrase: FfiConverterTypeMnemonicWithPassphrase.read(from: &buf),
                factorSource: FfiConverterTypeDeviceFactorSource.read(from: &buf)
            )
    }

    public static func write(_ value: PrivateHierarchicalDeterministicFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeMnemonicWithPassphrase.write(value.mnemonicWithPassphrase, into: &buf)
        FfiConverterTypeDeviceFactorSource.write(value.factorSource, into: &buf)
    }
}

public func FfiConverterTypePrivateHierarchicalDeterministicFactorSource_lift(_ buf: RustBuffer) throws -> PrivateHierarchicalDeterministicFactorSource {
    return try FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(buf)
}

public func FfiConverterTypePrivateHierarchicalDeterministicFactorSource_lower(_ value: PrivateHierarchicalDeterministicFactorSource) -> RustBuffer {
    return FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lower(value)
}

/**
 * The canonical representation of a users accounts, personas,
 * authorized dapps, security factors, settings and more.
 *
 * This large structure of values is called 'wallet backup data'
 * in user facing tests in host applications, but internally at
 * RDX Works known as "the Profile".
 *
 * ```
 * extern crate sargon;
 * use sargon::prelude::*;
 *
 * assert_eq!(Profile::sample(), Profile::sample())
 * ```
 */
public struct Profile {
    /**
     * The header of a Profile(Snapshot) contains crucial metadata
     * about this Profile, such as which JSON data format it is
     * compatible with and which device was used to create it and
     * a hint about its contents.
     */
    public var header: Header
    /**
     * All sources of factors, used for authorization such as spending funds, contains no
     * secrets.
     */
    public var factorSources: [FactorSource]
    /**
     * Settings for this profile in the app, contains default security configs
     * as well as display settings.
     */
    public var appPreferences: AppPreferences
    /**
     * An ordered mapping of NetworkID -> `Profile.Network`, containing
     * all the users Accounts, Personas and AuthorizedDapps the user
     * has created and interacted with on this network.
     */
    public var networks: [ProfileNetwork]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The header of a Profile(Snapshot) contains crucial metadata
         * about this Profile, such as which JSON data format it is
         * compatible with and which device was used to create it and
         * a hint about its contents.
         */ header: Header,
        /**
            * All sources of factors, used for authorization such as spending funds, contains no
            * secrets.
            */ factorSources: [FactorSource],
        /**
            * Settings for this profile in the app, contains default security configs
            * as well as display settings.
            */ appPreferences: AppPreferences,
        /**
            * An ordered mapping of NetworkID -> `Profile.Network`, containing
            * all the users Accounts, Personas and AuthorizedDapps the user
            * has created and interacted with on this network.
            */ networks: [ProfileNetwork]
    ) {
        self.header = header
        self.factorSources = factorSources
        self.appPreferences = appPreferences
        self.networks = networks
    }
}

extension Profile: Sendable {}
extension Profile: Equatable, Hashable {
    public static func == (lhs: Profile, rhs: Profile) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.factorSources != rhs.factorSources {
            return false
        }
        if lhs.appPreferences != rhs.appPreferences {
            return false
        }
        if lhs.networks != rhs.networks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(factorSources)
        hasher.combine(appPreferences)
        hasher.combine(networks)
    }
}

public struct FfiConverterTypeProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Profile {
        return
            try Profile(
                header: FfiConverterTypeHeader.read(from: &buf),
                factorSources: FfiConverterSequenceTypeFactorSource.read(from: &buf),
                appPreferences: FfiConverterTypeAppPreferences.read(from: &buf),
                networks: FfiConverterSequenceTypeProfileNetwork.read(from: &buf)
            )
    }

    public static func write(_ value: Profile, into buf: inout [UInt8]) {
        FfiConverterTypeHeader.write(value.header, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.factorSources, into: &buf)
        FfiConverterTypeAppPreferences.write(value.appPreferences, into: &buf)
        FfiConverterSequenceTypeProfileNetwork.write(value.networks, into: &buf)
    }
}

public func FfiConverterTypeProfile_lift(_ buf: RustBuffer) throws -> Profile {
    return try FfiConverterTypeProfile.lift(buf)
}

public func FfiConverterTypeProfile_lower(_ value: Profile) -> RustBuffer {
    return FfiConverterTypeProfile.lower(value)
}

/**
 * [`Accounts`], [`Personas`] and [`AuthorizedDapps`] for some [`ProfileNetwork`]
 * which user has created/interacted with, all on the same [Radix Network][`NetworkDefinition`],
 * identified by `id` ([`NetworkID`]).
 */
public struct ProfileNetwork {
    /**
     * The ID of the network that has been used to generate the `accounts` and `personas`
     * and on which the `authorizedDapps` have been deployed on.
     */
    public var id: NetworkId
    /**
     * An ordered set of [`Accounts`]` on this network, which are [`Account`]s
     * the user has created on this network.
     */
    public var accounts: [Account]
    /**
     * An ordered set of [`Personas`] on this network, which are [`Persona`]s
     * the user has created on this network.
     */
    public var personas: [Persona]
    /**
     * An ordered set of [`AuthorizedDapps`] on this network, which are
     * [`AuthorizedDapp`]s that the user has interacted with.
     */
    public var authorizedDapps: [AuthorizedDapp]
    /**
     * Configuration related to resources
     */
    public var resourcePreferences: [ResourceAppPreference]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the network that has been used to generate the `accounts` and `personas`
         * and on which the `authorizedDapps` have been deployed on.
         */ id: NetworkId,
        /**
            * An ordered set of [`Accounts`]` on this network, which are [`Account`]s
            * the user has created on this network.
            */ accounts: [Account],
        /**
            * An ordered set of [`Personas`] on this network, which are [`Persona`]s
            * the user has created on this network.
            */ personas: [Persona],
        /**
            * An ordered set of [`AuthorizedDapps`] on this network, which are
            * [`AuthorizedDapp`]s that the user has interacted with.
            */ authorizedDapps: [AuthorizedDapp],
        /**
            * Configuration related to resources
            */ resourcePreferences: [ResourceAppPreference]
    ) {
        self.id = id
        self.accounts = accounts
        self.personas = personas
        self.authorizedDapps = authorizedDapps
        self.resourcePreferences = resourcePreferences
    }
}

extension ProfileNetwork: Sendable {}
extension ProfileNetwork: Equatable, Hashable {
    public static func == (lhs: ProfileNetwork, rhs: ProfileNetwork) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.personas != rhs.personas {
            return false
        }
        if lhs.authorizedDapps != rhs.authorizedDapps {
            return false
        }
        if lhs.resourcePreferences != rhs.resourcePreferences {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(accounts)
        hasher.combine(personas)
        hasher.combine(authorizedDapps)
        hasher.combine(resourcePreferences)
    }
}

public struct FfiConverterTypeProfileNetwork: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileNetwork {
        return
            try ProfileNetwork(
                id: FfiConverterTypeNetworkID.read(from: &buf),
                accounts: FfiConverterSequenceTypeAccount.read(from: &buf),
                personas: FfiConverterSequenceTypePersona.read(from: &buf),
                authorizedDapps: FfiConverterSequenceTypeAuthorizedDapp.read(from: &buf),
                resourcePreferences: FfiConverterSequenceTypeResourceAppPreference.read(from: &buf)
            )
    }

    public static func write(_ value: ProfileNetwork, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.id, into: &buf)
        FfiConverterSequenceTypeAccount.write(value.accounts, into: &buf)
        FfiConverterSequenceTypePersona.write(value.personas, into: &buf)
        FfiConverterSequenceTypeAuthorizedDapp.write(value.authorizedDapps, into: &buf)
        FfiConverterSequenceTypeResourceAppPreference.write(value.resourcePreferences, into: &buf)
    }
}

public func FfiConverterTypeProfileNetwork_lift(_ buf: RustBuffer) throws -> ProfileNetwork {
    return try FfiConverterTypeProfileNetwork.lift(buf)
}

public func FfiConverterTypeProfileNetwork_lower(_ value: ProfileNetwork) -> RustBuffer {
    return FfiConverterTypeProfileNetwork.lower(value)
}

/**
 * The request received from the dApp that needs to be handled.
 */
public struct RadixConnectMobileSessionRequest {
    /**
     * The id of the session established with the dApp.
     * Needs to be passed back by the Host as to know which session to respond to.
     */
    public var sessionId: SessionId
    /**
     * The interaction received from the dApp.
     */
    public var interaction: DappToWalletInteractionUnvalidated
    /**
     * The origin of the dApp.
     */
    public var origin: DappOrigin
    /**
     * Whether the origin requires validation.
     */
    public var originRequiresValidation: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The id of the session established with the dApp.
         * Needs to be passed back by the Host as to know which session to respond to.
         */ sessionId: SessionId,
        /**
            * The interaction received from the dApp.
            */ interaction: DappToWalletInteractionUnvalidated,
        /**
            * The origin of the dApp.
            */ origin: DappOrigin,
        /**
            * Whether the origin requires validation.
            */ originRequiresValidation: Bool
    ) {
        self.sessionId = sessionId
        self.interaction = interaction
        self.origin = origin
        self.originRequiresValidation = originRequiresValidation
    }
}

extension RadixConnectMobileSessionRequest: Sendable {}
extension RadixConnectMobileSessionRequest: Equatable, Hashable {
    public static func == (lhs: RadixConnectMobileSessionRequest, rhs: RadixConnectMobileSessionRequest) -> Bool {
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.interaction != rhs.interaction {
            return false
        }
        if lhs.origin != rhs.origin {
            return false
        }
        if lhs.originRequiresValidation != rhs.originRequiresValidation {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sessionId)
        hasher.combine(interaction)
        hasher.combine(origin)
        hasher.combine(originRequiresValidation)
    }
}

public struct FfiConverterTypeRadixConnectMobileSessionRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileSessionRequest {
        return
            try RadixConnectMobileSessionRequest(
                sessionId: FfiConverterTypeSessionID.read(from: &buf),
                interaction: FfiConverterTypeDappToWalletInteractionUnvalidated.read(from: &buf),
                origin: FfiConverterTypeDappOrigin.read(from: &buf),
                originRequiresValidation: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: RadixConnectMobileSessionRequest, into buf: inout [UInt8]) {
        FfiConverterTypeSessionID.write(value.sessionId, into: &buf)
        FfiConverterTypeDappToWalletInteractionUnvalidated.write(value.interaction, into: &buf)
        FfiConverterTypeDappOrigin.write(value.origin, into: &buf)
        FfiConverterBool.write(value.originRequiresValidation, into: &buf)
    }
}

public func FfiConverterTypeRadixConnectMobileSessionRequest_lift(_ buf: RustBuffer) throws -> RadixConnectMobileSessionRequest {
    return try FfiConverterTypeRadixConnectMobileSessionRequest.lift(buf)
}

public func FfiConverterTypeRadixConnectMobileSessionRequest_lower(_ value: RadixConnectMobileSessionRequest) -> RustBuffer {
    return FfiConverterTypeRadixConnectMobileSessionRequest.lower(value)
}

public struct RadixConnectMobileWalletResponse {
    public var sessionId: SessionId
    public var response: WalletToDappInteractionResponse

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sessionId: SessionId, response: WalletToDappInteractionResponse) {
        self.sessionId = sessionId
        self.response = response
    }
}

extension RadixConnectMobileWalletResponse: Sendable {}
extension RadixConnectMobileWalletResponse: Equatable, Hashable {
    public static func == (lhs: RadixConnectMobileWalletResponse, rhs: RadixConnectMobileWalletResponse) -> Bool {
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.response != rhs.response {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sessionId)
        hasher.combine(response)
    }
}

public struct FfiConverterTypeRadixConnectMobileWalletResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectMobileWalletResponse {
        return
            try RadixConnectMobileWalletResponse(
                sessionId: FfiConverterTypeSessionID.read(from: &buf),
                response: FfiConverterTypeWalletToDappInteractionResponse.read(from: &buf)
            )
    }

    public static func write(_ value: RadixConnectMobileWalletResponse, into buf: inout [UInt8]) {
        FfiConverterTypeSessionID.write(value.sessionId, into: &buf)
        FfiConverterTypeWalletToDappInteractionResponse.write(value.response, into: &buf)
    }
}

public func FfiConverterTypeRadixConnectMobileWalletResponse_lift(_ buf: RustBuffer) throws -> RadixConnectMobileWalletResponse {
    return try FfiConverterTypeRadixConnectMobileWalletResponse.lift(buf)
}

public func FfiConverterTypeRadixConnectMobileWalletResponse_lower(_ value: RadixConnectMobileWalletResponse) -> RustBuffer {
    return FfiConverterTypeRadixConnectMobileWalletResponse.lower(value)
}

/**
 * The hash of the connection password is used to connect to the Radix Connect Signaling Server,
 * over web sockets. The actual `ConnectionPassword` is used to encrypt all messages sent via
 * the Signaling Server.
 */
public struct RadixConnectPassword {
    public var value: Exactly32Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(value: Exactly32Bytes) {
        self.value = value
    }
}

extension RadixConnectPassword: Sendable {}
extension RadixConnectPassword: Equatable, Hashable {
    public static func == (lhs: RadixConnectPassword, rhs: RadixConnectPassword) -> Bool {
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(value)
    }
}

public struct FfiConverterTypeRadixConnectPassword: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectPassword {
        return
            try RadixConnectPassword(
                value: FfiConverterTypeExactly32Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: RadixConnectPassword, into buf: inout [UInt8]) {
        FfiConverterTypeExactly32Bytes.write(value.value, into: &buf)
    }
}

public func FfiConverterTypeRadixConnectPassword_lift(_ buf: RustBuffer) throws -> RadixConnectPassword {
    return try FfiConverterTypeRadixConnectPassword.lift(buf)
}

public func FfiConverterTypeRadixConnectPassword_lower(_ value: RadixConnectPassword) -> RustBuffer {
    return FfiConverterTypeRadixConnectPassword.lower(value)
}

/**
 * RecoveryRole is used to recover lost access to an entity.
 */
public struct RecoveryRoleWithFactorInstances {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorInstance]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorInstance]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorInstance],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorInstance]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension RecoveryRoleWithFactorInstances: Sendable {}
extension RecoveryRoleWithFactorInstances: Equatable, Hashable {
    public static func == (lhs: RecoveryRoleWithFactorInstances, rhs: RecoveryRoleWithFactorInstances) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypeRecoveryRoleWithFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryRoleWithFactorInstances {
        return
            try RecoveryRoleWithFactorInstances(
                thresholdFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorInstance.read(from: &buf)
            )
    }

    public static func write(_ value: RecoveryRoleWithFactorInstances, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorInstance.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorInstance.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypeRecoveryRoleWithFactorInstances_lift(_ buf: RustBuffer) throws -> RecoveryRoleWithFactorInstances {
    return try FfiConverterTypeRecoveryRoleWithFactorInstances.lift(buf)
}

public func FfiConverterTypeRecoveryRoleWithFactorInstances_lower(_ value: RecoveryRoleWithFactorInstances) -> RustBuffer {
    return FfiConverterTypeRecoveryRoleWithFactorInstances.lower(value)
}

/**
 * RecoveryRole is used to recover lost access to an entity.
 */
public struct RecoveryRoleWithFactorSourceIDs {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorSourceId]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSourceId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorSourceId],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorSourceId]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension RecoveryRoleWithFactorSourceIDs: Sendable {}
extension RecoveryRoleWithFactorSourceIDs: Equatable, Hashable {
    public static func == (lhs: RecoveryRoleWithFactorSourceIDs, rhs: RecoveryRoleWithFactorSourceIDs) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypeRecoveryRoleWithFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryRoleWithFactorSourceIDs {
        return
            try RecoveryRoleWithFactorSourceIDs(
                thresholdFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
            )
    }

    public static func write(_ value: RecoveryRoleWithFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorSourceID.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSourceID.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypeRecoveryRoleWithFactorSourceIDs_lift(_ buf: RustBuffer) throws -> RecoveryRoleWithFactorSourceIDs {
    return try FfiConverterTypeRecoveryRoleWithFactorSourceIDs.lift(buf)
}

public func FfiConverterTypeRecoveryRoleWithFactorSourceIDs_lower(_ value: RecoveryRoleWithFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypeRecoveryRoleWithFactorSourceIDs.lower(value)
}

/**
 * RecoveryRole is used to recover lost access to an entity.
 */
public struct RecoveryRoleWithFactorSources {
    /**
     * Factors which are used in combination with other instances, amounting to at
     * least `threshold` many instances to perform some function with this role.
     *
     * # Implementation
     * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
     * we might wanna use duplicates, allowing us to build a "template"
     * structure where a role might contain two `FactorSourceKind::TrustedContact`,
     * meaning an instance of this template at FactorSource level
     * (`SecurityStructureOfFactorSources`) will contain two different
     * `TrustedContactFactorSource`s.
     */
    public var thresholdFactors: [FactorSource]
    /**
     * How many threshold factors that must be used to perform some function with this role.
     */
    public var threshold: UInt8
    /**
     * Overriding / Super admin / "sudo" / God / factors, **ANY**
     * single of these factor which can perform the function of this role,
     * disregarding of `threshold`.
     */
    public var overrideFactors: [FactorSource]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Factors which are used in combination with other instances, amounting to at
         * least `threshold` many instances to perform some function with this role.
         *
         * # Implementation
         * Must allow duplicates, thus using `Vec` since at FactorSourceKind level
         * we might wanna use duplicates, allowing us to build a "template"
         * structure where a role might contain two `FactorSourceKind::TrustedContact`,
         * meaning an instance of this template at FactorSource level
         * (`SecurityStructureOfFactorSources`) will contain two different
         * `TrustedContactFactorSource`s.
         */ thresholdFactors: [FactorSource],
        /**
            * How many threshold factors that must be used to perform some function with this role.
            */ threshold: UInt8,
        /**
            * Overriding / Super admin / "sudo" / God / factors, **ANY**
            * single of these factor which can perform the function of this role,
            * disregarding of `threshold`.
            */ overrideFactors: [FactorSource]
    ) {
        self.thresholdFactors = thresholdFactors
        self.threshold = threshold
        self.overrideFactors = overrideFactors
    }
}

extension RecoveryRoleWithFactorSources: Sendable {}
extension RecoveryRoleWithFactorSources: Equatable, Hashable {
    public static func == (lhs: RecoveryRoleWithFactorSources, rhs: RecoveryRoleWithFactorSources) -> Bool {
        if lhs.thresholdFactors != rhs.thresholdFactors {
            return false
        }
        if lhs.threshold != rhs.threshold {
            return false
        }
        if lhs.overrideFactors != rhs.overrideFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thresholdFactors)
        hasher.combine(threshold)
        hasher.combine(overrideFactors)
    }
}

public struct FfiConverterTypeRecoveryRoleWithFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryRoleWithFactorSources {
        return
            try RecoveryRoleWithFactorSources(
                thresholdFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf),
                threshold: FfiConverterUInt8.read(from: &buf),
                overrideFactors: FfiConverterSequenceTypeFactorSource.read(from: &buf)
            )
    }

    public static func write(_ value: RecoveryRoleWithFactorSources, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFactorSource.write(value.thresholdFactors, into: &buf)
        FfiConverterUInt8.write(value.threshold, into: &buf)
        FfiConverterSequenceTypeFactorSource.write(value.overrideFactors, into: &buf)
    }
}

public func FfiConverterTypeRecoveryRoleWithFactorSources_lift(_ buf: RustBuffer) throws -> RecoveryRoleWithFactorSources {
    return try FfiConverterTypeRecoveryRoleWithFactorSources.lift(buf)
}

public func FfiConverterTypeRecoveryRoleWithFactorSources_lower(_ value: RecoveryRoleWithFactorSources) -> RustBuffer {
    return FfiConverterTypeRecoveryRoleWithFactorSources.lower(value)
}

/**
 * A requested (by Dapp) quantity, e.g. "I want AT LEAST 3 account addresses" or
 * "I want EXACTLY 2 email addresses".
 */
public struct RequestedQuantity {
    public var quantifier: RequestedNumberQuantifier
    public var quantity: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(quantifier: RequestedNumberQuantifier, quantity: UInt16) {
        self.quantifier = quantifier
        self.quantity = quantity
    }
}

extension RequestedQuantity: Sendable {}
extension RequestedQuantity: Equatable, Hashable {
    public static func == (lhs: RequestedQuantity, rhs: RequestedQuantity) -> Bool {
        if lhs.quantifier != rhs.quantifier {
            return false
        }
        if lhs.quantity != rhs.quantity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(quantifier)
        hasher.combine(quantity)
    }
}

public struct FfiConverterTypeRequestedQuantity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedQuantity {
        return
            try RequestedQuantity(
                quantifier: FfiConverterTypeRequestedNumberQuantifier.read(from: &buf),
                quantity: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: RequestedQuantity, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedNumberQuantifier.write(value.quantifier, into: &buf)
        FfiConverterUInt16.write(value.quantity, into: &buf)
    }
}

public func FfiConverterTypeRequestedQuantity_lift(_ buf: RustBuffer) throws -> RequestedQuantity {
    return try FfiConverterTypeRequestedQuantity.lift(buf)
}

public func FfiConverterTypeRequestedQuantity_lower(_ value: RequestedQuantity) -> RustBuffer {
    return FfiConverterTypeRequestedQuantity.lower(value)
}

/**
 * Addresses identifying an asset, either fungible (Token) or non_fungible (NFT), on the Radix network, e.g.
 * `"resource_rdx1tknxxxxxxxxxradxrdxxxxxxxxx009923554798xxxxxxxxxradxrd"`
 * Being the unique identifier of the Radix Token, the Rad, on mainnet.
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of ResourceAddresses:
 * * GlobalFungibleResourceManager
 * * GlobalNonFungibleResourceManager
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalResourceAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L236-L239
 */
public struct ResourceAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}

extension ResourceAddress: Sendable {}
extension ResourceAddress: Equatable, Hashable {
    public static func == (lhs: ResourceAddress, rhs: ResourceAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeResourceAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAddress {
        return
            try ResourceAddress(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: ResourceAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeResourceAddress_lift(_ buf: RustBuffer) throws -> ResourceAddress {
    return try FfiConverterTypeResourceAddress.lift(buf)
}

public func FfiConverterTypeResourceAddress_lower(_ value: ResourceAddress) -> RustBuffer {
    return FfiConverterTypeResourceAddress.lower(value)
}

/**
 * A preference the user has configured off-ledger for a given resource.
 * Allows users, for example, to hide a given resource on their accounts.
 *
 * Named like this to differ from RET's `ResourcePreference`.
 */
public struct ResourceAppPreference {
    /**
     * The resource for which the preference is set up.
     */
    public var resource: ResourceIdentifier
    /**
     * The visibility of the resource (hidden or visible).
     */
    public var visibility: ResourceVisibility

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The resource for which the preference is set up.
         */ resource: ResourceIdentifier,
        /**
            * The visibility of the resource (hidden or visible).
            */ visibility: ResourceVisibility
    ) {
        self.resource = resource
        self.visibility = visibility
    }
}

extension ResourceAppPreference: Sendable {}
extension ResourceAppPreference: Equatable, Hashable {
    public static func == (lhs: ResourceAppPreference, rhs: ResourceAppPreference) -> Bool {
        if lhs.resource != rhs.resource {
            return false
        }
        if lhs.visibility != rhs.visibility {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resource)
        hasher.combine(visibility)
    }
}

public struct FfiConverterTypeResourceAppPreference: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceAppPreference {
        return
            try ResourceAppPreference(
                resource: FfiConverterTypeResourceIdentifier.read(from: &buf),
                visibility: FfiConverterTypeResourceVisibility.read(from: &buf)
            )
    }

    public static func write(_ value: ResourceAppPreference, into buf: inout [UInt8]) {
        FfiConverterTypeResourceIdentifier.write(value.resource, into: &buf)
        FfiConverterTypeResourceVisibility.write(value.visibility, into: &buf)
    }
}

public func FfiConverterTypeResourceAppPreference_lift(_ buf: RustBuffer) throws -> ResourceAppPreference {
    return try FfiConverterTypeResourceAppPreference.lift(buf)
}

public func FfiConverterTypeResourceAppPreference_lower(_ value: ResourceAppPreference) -> RustBuffer {
    return FfiConverterTypeResourceAppPreference.lower(value)
}

public struct SargonBuildInformation {
    public var sargonVersion: String
    public var dependencies: SargonDependencies

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(sargonVersion: String, dependencies: SargonDependencies) {
        self.sargonVersion = sargonVersion
        self.dependencies = dependencies
    }
}

extension SargonBuildInformation: Sendable {}
extension SargonBuildInformation: Equatable, Hashable {
    public static func == (lhs: SargonBuildInformation, rhs: SargonBuildInformation) -> Bool {
        if lhs.sargonVersion != rhs.sargonVersion {
            return false
        }
        if lhs.dependencies != rhs.dependencies {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sargonVersion)
        hasher.combine(dependencies)
    }
}

public struct FfiConverterTypeSargonBuildInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonBuildInformation {
        return
            try SargonBuildInformation(
                sargonVersion: FfiConverterString.read(from: &buf),
                dependencies: FfiConverterTypeSargonDependencies.read(from: &buf)
            )
    }

    public static func write(_ value: SargonBuildInformation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.sargonVersion, into: &buf)
        FfiConverterTypeSargonDependencies.write(value.dependencies, into: &buf)
    }
}

public func FfiConverterTypeSargonBuildInformation_lift(_ buf: RustBuffer) throws -> SargonBuildInformation {
    return try FfiConverterTypeSargonBuildInformation.lift(buf)
}

public func FfiConverterTypeSargonBuildInformation_lower(_ value: SargonBuildInformation) -> RustBuffer {
    return FfiConverterTypeSargonBuildInformation.lower(value)
}

public struct SargonDependencies {
    public var radixEngineToolkit: DependencyInformation
    public var scryptoRadixEngine: DependencyInformation

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(radixEngineToolkit: DependencyInformation, scryptoRadixEngine: DependencyInformation) {
        self.radixEngineToolkit = radixEngineToolkit
        self.scryptoRadixEngine = scryptoRadixEngine
    }
}

extension SargonDependencies: Sendable {}
extension SargonDependencies: Equatable, Hashable {
    public static func == (lhs: SargonDependencies, rhs: SargonDependencies) -> Bool {
        if lhs.radixEngineToolkit != rhs.radixEngineToolkit {
            return false
        }
        if lhs.scryptoRadixEngine != rhs.scryptoRadixEngine {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(radixEngineToolkit)
        hasher.combine(scryptoRadixEngine)
    }
}

public struct FfiConverterTypeSargonDependencies: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SargonDependencies {
        return
            try SargonDependencies(
                radixEngineToolkit: FfiConverterTypeDependencyInformation.read(from: &buf),
                scryptoRadixEngine: FfiConverterTypeDependencyInformation.read(from: &buf)
            )
    }

    public static func write(_ value: SargonDependencies, into buf: inout [UInt8]) {
        FfiConverterTypeDependencyInformation.write(value.radixEngineToolkit, into: &buf)
        FfiConverterTypeDependencyInformation.write(value.scryptoRadixEngine, into: &buf)
    }
}

public func FfiConverterTypeSargonDependencies_lift(_ buf: RustBuffer) throws -> SargonDependencies {
    return try FfiConverterTypeSargonDependencies.lift(buf)
}

public func FfiConverterTypeSargonDependencies_lower(_ value: SargonDependencies) -> RustBuffer {
    return FfiConverterTypeSargonDependencies.lower(value)
}

/**
 * The currently used Gateway and a collection of other by user added
 * or predefined Gateways the user can switch to.
 */
public struct SavedGateways {
    /**
     * The currently used Gateway, when a user query's asset balances of
     * accounts or submits transactions, this Gateway will be used.
     */
    public var current: Gateway
    /**
     * Other by user added or predefined Gateways the user can switch to.
     * It might be Gateways with different URLs on the SAME network, or
     * other networks, the identifier of a Gateway is the URL.
     */
    public var other: [Gateway]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The currently used Gateway, when a user query's asset balances of
         * accounts or submits transactions, this Gateway will be used.
         */ current: Gateway,
        /**
            * Other by user added or predefined Gateways the user can switch to.
            * It might be Gateways with different URLs on the SAME network, or
            * other networks, the identifier of a Gateway is the URL.
            */ other: [Gateway]
    ) {
        self.current = current
        self.other = other
    }
}

extension SavedGateways: Sendable {}
extension SavedGateways: Equatable, Hashable {
    public static func == (lhs: SavedGateways, rhs: SavedGateways) -> Bool {
        if lhs.current != rhs.current {
            return false
        }
        if lhs.other != rhs.other {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(current)
        hasher.combine(other)
    }
}

public struct FfiConverterTypeSavedGateways: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SavedGateways {
        return
            try SavedGateways(
                current: FfiConverterTypeGateway.read(from: &buf),
                other: FfiConverterSequenceTypeGateway.read(from: &buf)
            )
    }

    public static func write(_ value: SavedGateways, into buf: inout [UInt8]) {
        FfiConverterTypeGateway.write(value.current, into: &buf)
        FfiConverterSequenceTypeGateway.write(value.other, into: &buf)
    }
}

public func FfiConverterTypeSavedGateways_lift(_ buf: RustBuffer) throws -> SavedGateways {
    return try FfiConverterTypeSavedGateways.lift(buf)
}

public func FfiConverterTypeSavedGateways_lower(_ value: SavedGateways) -> RustBuffer {
    return FfiConverterTypeSavedGateways.lower(value)
}

/**
 * A `secp256k1` public key used to verify cryptographic signatures (ECDSA signatures).
 */
public struct Secp256k1PublicKey {
    fileprivate let secretMagic: BagOfBytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: BagOfBytes) {
        self.secretMagic = secretMagic
    }
}

extension Secp256k1PublicKey: Sendable {}
extension Secp256k1PublicKey: Equatable, Hashable {
    public static func == (lhs: Secp256k1PublicKey, rhs: Secp256k1PublicKey) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeSecp256k1PublicKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1PublicKey {
        return
            try Secp256k1PublicKey(
                secretMagic: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
    }

    public static func write(_ value: Secp256k1PublicKey, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeSecp256k1PublicKey_lift(_ buf: RustBuffer) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(buf)
}

public func FfiConverterTypeSecp256k1PublicKey_lower(_ value: Secp256k1PublicKey) -> RustBuffer {
    return FfiConverterTypeSecp256k1PublicKey.lower(value)
}

/**
 * Represents an Secp256k1 signature.
 */
public struct Secp256k1Signature {
    public var bytes: Exactly65Bytes

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(bytes: Exactly65Bytes) {
        self.bytes = bytes
    }
}

extension Secp256k1Signature: Sendable {}
extension Secp256k1Signature: Equatable, Hashable {
    public static func == (lhs: Secp256k1Signature, rhs: Secp256k1Signature) -> Bool {
        if lhs.bytes != rhs.bytes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bytes)
    }
}

public struct FfiConverterTypeSecp256k1Signature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Secp256k1Signature {
        return
            try Secp256k1Signature(
                bytes: FfiConverterTypeExactly65Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: Secp256k1Signature, into buf: inout [UInt8]) {
        FfiConverterTypeExactly65Bytes.write(value.bytes, into: &buf)
    }
}

public func FfiConverterTypeSecp256k1Signature_lift(_ buf: RustBuffer) throws -> Secp256k1Signature {
    return try FfiConverterTypeSecp256k1Signature.lift(buf)
}

public func FfiConverterTypeSecp256k1Signature_lower(_ value: Secp256k1Signature) -> RustBuffer {
    return FfiConverterTypeSecp256k1Signature.lower(value)
}

/**
 * Advanced security control of an entity which has been "securified",
 * meaning an MFA security structure (`SecurityStructureOfFactorSources`)
 * which user has created has been applied to it.
 */
public struct SecuredEntityControl {
    /**
     * The address of the access controller which controls this entity.
     *
     * Looking up the public key (hashes) set in the key-value store at
     * this address reveils the true factors (public keys) used to protect
     * this entity. It will be the same as the ones in `security_structure`
     * if we have not changed them locally, which we should not do unless
     * we are sure the Ledger corresponds to the values in `security_structure`.
     */
    public var accessControllerAddress: AccessControllerAddress
    /**
     * The believed-to-be-current security structure of FactorInstances which
     * secures this entity.
     */
    public var securityStructure: SecurityStructureOfFactorInstances

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The address of the access controller which controls this entity.
         *
         * Looking up the public key (hashes) set in the key-value store at
         * this address reveils the true factors (public keys) used to protect
         * this entity. It will be the same as the ones in `security_structure`
         * if we have not changed them locally, which we should not do unless
         * we are sure the Ledger corresponds to the values in `security_structure`.
         */ accessControllerAddress: AccessControllerAddress,
        /**
            * The believed-to-be-current security structure of FactorInstances which
            * secures this entity.
            */ securityStructure: SecurityStructureOfFactorInstances
    ) {
        self.accessControllerAddress = accessControllerAddress
        self.securityStructure = securityStructure
    }
}

extension SecuredEntityControl: Sendable {}
extension SecuredEntityControl: Equatable, Hashable {
    public static func == (lhs: SecuredEntityControl, rhs: SecuredEntityControl) -> Bool {
        if lhs.accessControllerAddress != rhs.accessControllerAddress {
            return false
        }
        if lhs.securityStructure != rhs.securityStructure {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accessControllerAddress)
        hasher.combine(securityStructure)
    }
}

public struct FfiConverterTypeSecuredEntityControl: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecuredEntityControl {
        return
            try SecuredEntityControl(
                accessControllerAddress: FfiConverterTypeAccessControllerAddress.read(from: &buf),
                securityStructure: FfiConverterTypeSecurityStructureOfFactorInstances.read(from: &buf)
            )
    }

    public static func write(_ value: SecuredEntityControl, into buf: inout [UInt8]) {
        FfiConverterTypeAccessControllerAddress.write(value.accessControllerAddress, into: &buf)
        FfiConverterTypeSecurityStructureOfFactorInstances.write(value.securityStructure, into: &buf)
    }
}

public func FfiConverterTypeSecuredEntityControl_lift(_ buf: RustBuffer) throws -> SecuredEntityControl {
    return try FfiConverterTypeSecuredEntityControl.lift(buf)
}

public func FfiConverterTypeSecuredEntityControl_lower(_ value: SecuredEntityControl) -> RustBuffer {
    return FfiConverterTypeSecuredEntityControl.lower(value)
}

public struct SecurifiedU30 {
    fileprivate let secretMagic: U30

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: U30) {
        self.secretMagic = secretMagic
    }
}

extension SecurifiedU30: Sendable {}
extension SecurifiedU30: Equatable, Hashable {
    public static func == (lhs: SecurifiedU30, rhs: SecurifiedU30) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeSecurifiedU30: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurifiedU30 {
        return
            try SecurifiedU30(
                secretMagic: FfiConverterTypeU30.read(from: &buf)
            )
    }

    public static func write(_ value: SecurifiedU30, into buf: inout [UInt8]) {
        FfiConverterTypeU30.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeSecurifiedU30_lift(_ buf: RustBuffer) throws -> SecurifiedU30 {
    return try FfiConverterTypeSecurifiedU30.lift(buf)
}

public func FfiConverterTypeSecurifiedU30_lower(_ value: SecurifiedU30) -> RustBuffer {
    return FfiConverterTypeSecurifiedU30.lower(value)
}

/**
 * Controls e.g. if Profile Snapshot gets synced to iCloud or not, and whether
 * developer mode is enabled or not. In future (MFA) we will also save a list of
 * MFA security structure configurations.
 */
public struct Security {
    public var isCloudProfileSyncEnabled: Bool
    public var isDeveloperModeEnabled: Bool
    public var isAdvancedLockEnabled: Bool
    public var securityStructuresOfFactorSourceIds: [SecurityStructureOfFactorSourceIDs]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(isCloudProfileSyncEnabled: Bool, isDeveloperModeEnabled: Bool, isAdvancedLockEnabled: Bool, securityStructuresOfFactorSourceIds: [SecurityStructureOfFactorSourceIDs]) {
        self.isCloudProfileSyncEnabled = isCloudProfileSyncEnabled
        self.isDeveloperModeEnabled = isDeveloperModeEnabled
        self.isAdvancedLockEnabled = isAdvancedLockEnabled
        self.securityStructuresOfFactorSourceIds = securityStructuresOfFactorSourceIds
    }
}

extension Security: Sendable {}
extension Security: Equatable, Hashable {
    public static func == (lhs: Security, rhs: Security) -> Bool {
        if lhs.isCloudProfileSyncEnabled != rhs.isCloudProfileSyncEnabled {
            return false
        }
        if lhs.isDeveloperModeEnabled != rhs.isDeveloperModeEnabled {
            return false
        }
        if lhs.isAdvancedLockEnabled != rhs.isAdvancedLockEnabled {
            return false
        }
        if lhs.securityStructuresOfFactorSourceIds != rhs.securityStructuresOfFactorSourceIds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isCloudProfileSyncEnabled)
        hasher.combine(isDeveloperModeEnabled)
        hasher.combine(isAdvancedLockEnabled)
        hasher.combine(securityStructuresOfFactorSourceIds)
    }
}

public struct FfiConverterTypeSecurity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Security {
        return
            try Security(
                isCloudProfileSyncEnabled: FfiConverterBool.read(from: &buf),
                isDeveloperModeEnabled: FfiConverterBool.read(from: &buf),
                isAdvancedLockEnabled: FfiConverterBool.read(from: &buf),
                securityStructuresOfFactorSourceIds: FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.read(from: &buf)
            )
    }

    public static func write(_ value: Security, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isCloudProfileSyncEnabled, into: &buf)
        FfiConverterBool.write(value.isDeveloperModeEnabled, into: &buf)
        FfiConverterBool.write(value.isAdvancedLockEnabled, into: &buf)
        FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.write(value.securityStructuresOfFactorSourceIds, into: &buf)
    }
}

public func FfiConverterTypeSecurity_lift(_ buf: RustBuffer) throws -> Security {
    return try FfiConverterTypeSecurity.lift(buf)
}

public func FfiConverterTypeSecurity_lower(_ value: Security) -> RustBuffer {
    return FfiConverterTypeSecurity.lower(value)
}

/**
 * ❗️ NOT PRODUCTION READY YET ❗️
 * A specification of expected format for an answer to a security question.
 * ❗️ NOT PRODUCTION READY YET ❗️
 */
public struct SecurityQuestionNotProductionReadyExpectedAnswerFormat {
    /**
     * E.g. `"<CITY>, <YEAR>"`
     */
    public var answerStructure: String
    /**
     * An example of a possible answer that matches `answer_structure`.
     * E.g. `"Berlin, 1976"`
     */
    public var exampleAnswer: String
    /**
     * If user is about to select the question:
     * `"What was the name of your first stuffed animal?"`
     *
     * Then we can discourage the user from selecting that question
     * if the answer is in `["Teddy", "Peter Rabbit", "Winnie (the Poh)"]`
     */
    public var unsafeAnswers: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * E.g. `"<CITY>, <YEAR>"`
         */ answerStructure: String,
        /**
            * An example of a possible answer that matches `answer_structure`.
            * E.g. `"Berlin, 1976"`
            */ exampleAnswer: String,
        /**
            * If user is about to select the question:
            * `"What was the name of your first stuffed animal?"`
            *
            * Then we can discourage the user from selecting that question
            * if the answer is in `["Teddy", "Peter Rabbit", "Winnie (the Poh)"]`
            */ unsafeAnswers: [String]
    ) {
        self.answerStructure = answerStructure
        self.exampleAnswer = exampleAnswer
        self.unsafeAnswers = unsafeAnswers
    }
}

extension SecurityQuestionNotProductionReadyExpectedAnswerFormat: Sendable {}
extension SecurityQuestionNotProductionReadyExpectedAnswerFormat: Equatable, Hashable {
    public static func == (lhs: SecurityQuestionNotProductionReadyExpectedAnswerFormat, rhs: SecurityQuestionNotProductionReadyExpectedAnswerFormat) -> Bool {
        if lhs.answerStructure != rhs.answerStructure {
            return false
        }
        if lhs.exampleAnswer != rhs.exampleAnswer {
            return false
        }
        if lhs.unsafeAnswers != rhs.unsafeAnswers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(answerStructure)
        hasher.combine(exampleAnswer)
        hasher.combine(unsafeAnswers)
    }
}

public struct FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionNotProductionReadyExpectedAnswerFormat {
        return
            try SecurityQuestionNotProductionReadyExpectedAnswerFormat(
                answerStructure: FfiConverterString.read(from: &buf),
                exampleAnswer: FfiConverterString.read(from: &buf),
                unsafeAnswers: FfiConverterSequenceString.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityQuestionNotProductionReadyExpectedAnswerFormat, into buf: inout [UInt8]) {
        FfiConverterString.write(value.answerStructure, into: &buf)
        FfiConverterString.write(value.exampleAnswer, into: &buf)
        FfiConverterSequenceString.write(value.unsafeAnswers, into: &buf)
    }
}

public func FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat_lift(_ buf: RustBuffer) throws -> SecurityQuestionNotProductionReadyExpectedAnswerFormat {
    return try FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat.lift(buf)
}

public func FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat_lower(_ value: SecurityQuestionNotProductionReadyExpectedAnswerFormat) -> RustBuffer {
    return FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat.lower(value)
}

/**
 * ❗️ NOT PRODUCTION READY YET ❗️
 * A mnemonic encrypted by answers to security questions
 * ❗️ NOT PRODUCTION READY YET ❗️
 */
public struct SecurityQuestionsSealedNotProductionReadyMnemonic {
    public var securityQuestions: [SecurityNotProductionReadyQuestion]
    /**
     * A versioned Key Derivation Function (KDF) algorithm used to produce a set
     * of Encryption keys from a set of security questions and answers
     */
    public var kdfScheme: SecurityQuestionsNotProductionReadyKdfScheme
    /**
     * The scheme used to encrypt the Security Questions factor source
     * mnemonic using one combination of answers to questions, one of many.
     */
    public var encryptionScheme: EncryptionScheme
    /**
     * The N many encryptions of the mnemonic, where N corresponds to the number of derived keys
     * from the `keyDerivationScheme`
     */
    public var encryptions: [Exactly60Bytes]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(securityQuestions: [SecurityNotProductionReadyQuestion],
                /**
                    * A versioned Key Derivation Function (KDF) algorithm used to produce a set
                    * of Encryption keys from a set of security questions and answers
                    */ kdfScheme: SecurityQuestionsNotProductionReadyKdfScheme,
                /**
                    * The scheme used to encrypt the Security Questions factor source
                    * mnemonic using one combination of answers to questions, one of many.
                    */ encryptionScheme: EncryptionScheme,
                /**
                    * The N many encryptions of the mnemonic, where N corresponds to the number of derived keys
                    * from the `keyDerivationScheme`
                    */ encryptions: [Exactly60Bytes])
    {
        self.securityQuestions = securityQuestions
        self.kdfScheme = kdfScheme
        self.encryptionScheme = encryptionScheme
        self.encryptions = encryptions
    }
}

extension SecurityQuestionsSealedNotProductionReadyMnemonic: Sendable {}
extension SecurityQuestionsSealedNotProductionReadyMnemonic: Equatable, Hashable {
    public static func == (lhs: SecurityQuestionsSealedNotProductionReadyMnemonic, rhs: SecurityQuestionsSealedNotProductionReadyMnemonic) -> Bool {
        if lhs.securityQuestions != rhs.securityQuestions {
            return false
        }
        if lhs.kdfScheme != rhs.kdfScheme {
            return false
        }
        if lhs.encryptionScheme != rhs.encryptionScheme {
            return false
        }
        if lhs.encryptions != rhs.encryptions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(securityQuestions)
        hasher.combine(kdfScheme)
        hasher.combine(encryptionScheme)
        hasher.combine(encryptions)
    }
}

public struct FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsSealedNotProductionReadyMnemonic {
        return
            try SecurityQuestionsSealedNotProductionReadyMnemonic(
                securityQuestions: FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question.read(from: &buf),
                kdfScheme: FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme.read(from: &buf),
                encryptionScheme: FfiConverterTypeEncryptionScheme.read(from: &buf),
                encryptions: FfiConverterSequenceTypeExactly60Bytes.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityQuestionsSealedNotProductionReadyMnemonic, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question.write(value.securityQuestions, into: &buf)
        FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme.write(value.kdfScheme, into: &buf)
        FfiConverterTypeEncryptionScheme.write(value.encryptionScheme, into: &buf)
        FfiConverterSequenceTypeExactly60Bytes.write(value.encryptions, into: &buf)
    }
}

public func FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic_lift(_ buf: RustBuffer) throws -> SecurityQuestionsSealedNotProductionReadyMnemonic {
    return try FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic.lift(buf)
}

public func FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic_lower(_ value: SecurityQuestionsSealedNotProductionReadyMnemonic) -> RustBuffer {
    return FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic.lower(value)
}

/**
 * ❗️ NOT PRODUCTION READY YET ❗️
 * A key derivation function which produces Encryption Keys from a set of
 * key exchange keys, by performing Diffie-Hellman key exchange on each
 * Key Exchange Key in a Set, by "folding" from left to right.
 * ❗️ NOT PRODUCTION READY YET ❗️
 */
public struct SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold: Sendable {}
extension SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold: Equatable, Hashable {
    public static func == (_: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold, _: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold {
        return
            SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold()
    }

    public static func write(_: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold, into _: inout [UInt8]) {}
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold_lower(_ value: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold) -> RustBuffer {
    return FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.lower(value)
}

/**
 * ❗️ NOT PRODUCTION READY YET ❗️
 * A mnemonic "sealed" by "security questions" (personal questions).
 *
 * The user select P personal questions from a set of Q predefined questions,
 * then answers them. The user will be able to "open" (decrypt) the "sealed"
 * (encrypted) mnemonic by providing at least P-1 correct answers to the P,
 * questions, that is to say, she is allowed to input one incorrect answer.
 * This is important since it makes this factor source kind more convenient
 * to use, especially if a significant time has passed between user answering
 * the questions for the first and the second time.
 *
 * In order to make it possible for user to input one incorrect answer, we need
 * to encrypt the mnemonic with many keys, keys being formed from many combinations
 * of question-answer-based input. To do this we use a function `qna2bin`
 * (question and answer to binary), to deterministically form Curve25519 key pairs,
 * P many (one per question/answer pair), and then we combine these keys using
 * ECDH (key exchange) to form composite (symmetric) encryption keys using P-1
 * many Ed25519 keys per composite encryption key.
 *
 * E.g. User selects 6 questions out of 20:
 * Q1: "What was the make and models of your first car?"
 * Q2: "In which town and which year did your parents meet?"
 * Q3: "What was the name of your first stuffed animal?"
 * Q4: "What was the name of the boy or the girl you first kissed?"
 * Q5: "What was the first exam you failed?"
 * Q6: "What is the middle name of your youngest child?"
 *
 * She answers them, forming
 * `let qa: Vec<(Questions, Answer)> = [(q_0, a_0), (q_1, a_1), .., (q_5, a_5)]`
 * question, answer pairs.
 *
 * The answers will be "normalized", trying to make it easier for user to provide
 * the same used answer later in time, we can do this by for example removing
 * whitespace, delimiters and apostrophes, and lowercase all chars.
 *
 * We form 6 binary inputs, call them `bins` using function `qna2bin` taking a
 * question/answer pair as input and outputting 32 bytes.
 * `let bins: Vec<Exactly32Bytes> = qa.iter().map(qna2bin).collect()`
 *
 * We form 6 X25519PrivateKey meant for Diffie-Hellman key exchange from `bin`
 * `let ec_keys: Vec<X25519PrivateKey> = bins.iter().map(bin2key).collect()`
 *
 * We form ["6 choose 4" ("P choose P-1")][choose] = 15 many combinations
 * (e.g. using [`combinations method from itertools`](itertools))
 *
 * ```ignore
 * let k = 4;
 * assert_eq!(ec_keys.len(), 6);
 * let key_combinations = Vec<Vec<X25519PrivateKey>> = ec_keys.combinations(k);
 * assert_eq!(key_combinations.len(), 15);
 * assert_eq!(key_combinations.iter().all(|v| v.len() == k);
 * ```
 *
 * We map the 15 `Vec<X25519PrivateKey>` into `X25519PublicKeys` using `multi_party_ecdh`:
 *
 * ```ignore
 * let ecdh_keys: Vec<X25519PublicKey> = key_combinations.iter().map(multi_party_ecdh).collect();
 * assert_eq!(sec_keys.len(), 15);
 * ```
 *
 * Where `multi_party_ecdh` is a function taking `Vec<X25519PrivateKey>` as input and
 * returning a `Key<Aes256Gcm>` by doing key exchange between all keys, like so:
 *
 * ```ignore
 * fn key_exchange_between_more_than_two_keys(
 * &self,
 * between: Vec<&X25519PrivateKey>,
 * ) -> X25519PublicKey {
 * let mut private_keys = between.clone();
 * assert!(private_keys.len() > 2);
 * let tail = private_keys.split_off(1);
 * let head = private_keys.into_iter().last().unwrap();
 *
 * tail.into_iter().fold(head.public_key(), |acc_pub, x_priv| {
 * let shared_secret = x_priv.diffie_hellman(&acc_pub);
 * X25519PublicKey::from_bytes(shared_secret.to_bytes())
 * })
 * }
 * ```
 *
 * We form 15 Symmetric Encryption keys from the 15 `X25519PublicKey` by simply
 * mapping the data of the public keys into AesGCM keys:
 *
 * ```ignore
 * let sec_keys: Vec<Key<AesGcm>> = ecdh_keys.iter().map(ec2sec).collect()
 * assert_eq!(sec_keys.len(), 15);
 * ```
 *
 * We encrypt the mnemonic 15 times, using each symmetric key in `sec_keys`:
 *
 * ```ignore
 * let encryptions: Vec<AesGcmSealedBox> = sec_keys.iter().map(|x| x.enc)
 * assert_eq!(encryptions.len(), 15);
 * ```
 *
 * Decryption is then the reverse process, trying to decrypt any of the 15
 * encrypted mnemonics with any of the 15 symmetric (de)encryption keys we
 * re-calculate from the answers user gives at this later point in time.
 *
 * Author / Inventor: Alexander Cyon (alex.cyon@gmail.com) in the year 2022.
 *
 * ❗️ NOT PRODUCTION READY YET ❗️
 *
 * [choose]: https://en.wikipedia.org/wiki/Combination
 * [itertools]: https://docs.rs/itertools/latest/itertools/trait.Itertools.html#method.combinations

 */
public struct SecurityQuestionsNotProductionReadyFactorSource {
    /**
     * Unique and stable identifier of this factor source, stemming from the
     * hash of a special child key of the HD root of the mnemonic.
     */
    public var id: FactorSourceIdFromHash
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * The sealed mnemonic containing multiple different encryptions of a
     * mnemonic encrypted by different encryptions keys, being various combinations
     * of questions and answers derived keys, allowing for only 4 out of 6 answers
     * to be correct.
     */
    public var sealedMnemonic: SecurityQuestionsSealedNotProductionReadyMnemonic

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source, stemming from the
         * hash of a special child key of the HD root of the mnemonic.
         */ id: FactorSourceIdFromHash,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon,
        /**
            * The sealed mnemonic containing multiple different encryptions of a
            * mnemonic encrypted by different encryptions keys, being various combinations
            * of questions and answers derived keys, allowing for only 4 out of 6 answers
            * to be correct.
            */ sealedMnemonic: SecurityQuestionsSealedNotProductionReadyMnemonic
    ) {
        self.id = id
        self.common = common
        self.sealedMnemonic = sealedMnemonic
    }
}

extension SecurityQuestionsNotProductionReadyFactorSource: Sendable {}
extension SecurityQuestionsNotProductionReadyFactorSource: Equatable, Hashable {
    public static func == (lhs: SecurityQuestionsNotProductionReadyFactorSource, rhs: SecurityQuestionsNotProductionReadyFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.sealedMnemonic != rhs.sealedMnemonic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(sealedMnemonic)
    }
}

public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyFactorSource {
        return
            try SecurityQuestionsNotProductionReadyFactorSource(
                id: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                sealedMnemonic: FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityQuestionsNotProductionReadyFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromHash.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeSecurityQuestionsSealed_NOT_PRODUCTION_READY_Mnemonic.write(value.sealedMnemonic, into: &buf)
    }
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyFactorSource {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource_lower(_ value: SecurityQuestionsNotProductionReadyFactorSource) -> RustBuffer {
    return FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lower(value)
}

/**
 * ❗️ NOT PRODUCTION READY YET ❗️
 * Version1 of SecurityQuestions KDF, derives encryption keys from security
 * questions and answers, using two "sub-KDFs".
 * ❗️ NOT PRODUCTION READY YET ❗️
 */
public struct SecurityQuestionsNotProductionReadyKdfSchemeVersion1 {
    public var kdfKeyExchangesKeysFromQuestionsAndAnswers: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8
    public var kdfEncryptionKeysFromKeyExchangeKeys: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(kdfKeyExchangesKeysFromQuestionsAndAnswers: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8, kdfEncryptionKeysFromKeyExchangeKeys: SecurityQuestionsNotProductionReadyEncryptionKeysByDiffieHellmanFold) {
        self.kdfKeyExchangesKeysFromQuestionsAndAnswers = kdfKeyExchangesKeysFromQuestionsAndAnswers
        self.kdfEncryptionKeysFromKeyExchangeKeys = kdfEncryptionKeysFromKeyExchangeKeys
    }
}

extension SecurityQuestionsNotProductionReadyKdfSchemeVersion1: Sendable {}
extension SecurityQuestionsNotProductionReadyKdfSchemeVersion1: Equatable, Hashable {
    public static func == (lhs: SecurityQuestionsNotProductionReadyKdfSchemeVersion1, rhs: SecurityQuestionsNotProductionReadyKdfSchemeVersion1) -> Bool {
        if lhs.kdfKeyExchangesKeysFromQuestionsAndAnswers != rhs.kdfKeyExchangesKeysFromQuestionsAndAnswers {
            return false
        }
        if lhs.kdfEncryptionKeysFromKeyExchangeKeys != rhs.kdfEncryptionKeysFromKeyExchangeKeys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kdfKeyExchangesKeysFromQuestionsAndAnswers)
        hasher.combine(kdfEncryptionKeysFromKeyExchangeKeys)
    }
}

public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyKdfSchemeVersion1 {
        return
            try SecurityQuestionsNotProductionReadyKdfSchemeVersion1(
                kdfKeyExchangesKeysFromQuestionsAndAnswers: FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.read(from: &buf),
                kdfEncryptionKeysFromKeyExchangeKeys: FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityQuestionsNotProductionReadyKdfSchemeVersion1, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.write(value.kdfKeyExchangesKeysFromQuestionsAndAnswers, into: &buf)
        FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_EncryptionKeysByDiffieHellmanFold.write(value.kdfEncryptionKeysFromKeyExchangeKeys, into: &buf)
    }
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyKdfSchemeVersion1 {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1_lower(_ value: SecurityQuestionsNotProductionReadyKdfSchemeVersion1) -> RustBuffer {
    return FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1.lower(value)
}

/**
 * ❗️ NOT PRODUCTION READY YET ❗️
 * A Key Derivation Scheme which lowercases, trims and ut8f encodes answers.
 * ❗️ NOT PRODUCTION READY YET ❗️
 */
public struct SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8 {
    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {}
}

extension SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8: Sendable {}
extension SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8: Equatable, Hashable {
    public static func == (_: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8, _: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8) -> Bool {
        return true
    }

    public func hash(into _: inout Hasher) {}
}

public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8: FfiConverterRustBuffer {
    public static func read(from _: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8 {
        return
            SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8()
    }

    public static func write(_: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8, into _: inout [UInt8]) {}
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8 {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8_lower(_ value: SecurityQuestionsNotProductionReadyKeyExchangeKeysFromQandAsLowerTrimUtf8) -> RustBuffer {
    return FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KeyExchangeKeysFromQandAsLowerTrimUtf8.lower(value)
}

public struct SecurityStructureMetadata {
    public var id: SecurityStructureId
    public var displayName: DisplayName
    public var createdOn: Timestamp
    public var lastUpdatedOn: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: SecurityStructureId, displayName: DisplayName, createdOn: Timestamp, lastUpdatedOn: Timestamp) {
        self.id = id
        self.displayName = displayName
        self.createdOn = createdOn
        self.lastUpdatedOn = lastUpdatedOn
    }
}

extension SecurityStructureMetadata: Sendable {}
extension SecurityStructureMetadata: Equatable, Hashable {
    public static func == (lhs: SecurityStructureMetadata, rhs: SecurityStructureMetadata) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.displayName != rhs.displayName {
            return false
        }
        if lhs.createdOn != rhs.createdOn {
            return false
        }
        if lhs.lastUpdatedOn != rhs.lastUpdatedOn {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(displayName)
        hasher.combine(createdOn)
        hasher.combine(lastUpdatedOn)
    }
}

public struct FfiConverterTypeSecurityStructureMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureMetadata {
        return
            try SecurityStructureMetadata(
                id: FfiConverterTypeSecurityStructureID.read(from: &buf),
                displayName: FfiConverterTypeDisplayName.read(from: &buf),
                createdOn: FfiConverterTypeTimestamp.read(from: &buf),
                lastUpdatedOn: FfiConverterTypeTimestamp.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityStructureMetadata, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureID.write(value.id, into: &buf)
        FfiConverterTypeDisplayName.write(value.displayName, into: &buf)
        FfiConverterTypeTimestamp.write(value.createdOn, into: &buf)
        FfiConverterTypeTimestamp.write(value.lastUpdatedOn, into: &buf)
    }
}

public func FfiConverterTypeSecurityStructureMetadata_lift(_ buf: RustBuffer) throws -> SecurityStructureMetadata {
    return try FfiConverterTypeSecurityStructureMetadata.lift(buf)
}

public func FfiConverterTypeSecurityStructureMetadata_lower(_ value: SecurityStructureMetadata) -> RustBuffer {
    return FfiConverterTypeSecurityStructureMetadata.lower(value)
}

public struct SecurityStructureOfFactorInstances {
    /**
     * The ID of the `SecurityStructureOfFactorSourceIDs` in
     * `profile.app_preferences.security.security_structures_of_factor_source_ids`
     * which was used to derive the factor instances in this structure. Or rather:
     * The id of `SecurityStructureOfFactorSources`.
     */
    public var securityStructureId: SecurityStructureId
    /**
     * The structure of factors to use for certain roles, Primary, Recovery
     * and Confirmation role.
     */
    public var matrixOfFactors: MatrixOfFactorInstances

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the `SecurityStructureOfFactorSourceIDs` in
         * `profile.app_preferences.security.security_structures_of_factor_source_ids`
         * which was used to derive the factor instances in this structure. Or rather:
         * The id of `SecurityStructureOfFactorSources`.
         */ securityStructureId: SecurityStructureId,
        /**
            * The structure of factors to use for certain roles, Primary, Recovery
            * and Confirmation role.
            */ matrixOfFactors: MatrixOfFactorInstances
    ) {
        self.securityStructureId = securityStructureId
        self.matrixOfFactors = matrixOfFactors
    }
}

extension SecurityStructureOfFactorInstances: Sendable {}
extension SecurityStructureOfFactorInstances: Equatable, Hashable {
    public static func == (lhs: SecurityStructureOfFactorInstances, rhs: SecurityStructureOfFactorInstances) -> Bool {
        if lhs.securityStructureId != rhs.securityStructureId {
            return false
        }
        if lhs.matrixOfFactors != rhs.matrixOfFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(securityStructureId)
        hasher.combine(matrixOfFactors)
    }
}

public struct FfiConverterTypeSecurityStructureOfFactorInstances: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureOfFactorInstances {
        return
            try SecurityStructureOfFactorInstances(
                securityStructureId: FfiConverterTypeSecurityStructureID.read(from: &buf),
                matrixOfFactors: FfiConverterTypeMatrixOfFactorInstances.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityStructureOfFactorInstances, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureID.write(value.securityStructureId, into: &buf)
        FfiConverterTypeMatrixOfFactorInstances.write(value.matrixOfFactors, into: &buf)
    }
}

public func FfiConverterTypeSecurityStructureOfFactorInstances_lift(_ buf: RustBuffer) throws -> SecurityStructureOfFactorInstances {
    return try FfiConverterTypeSecurityStructureOfFactorInstances.lift(buf)
}

public func FfiConverterTypeSecurityStructureOfFactorInstances_lower(_ value: SecurityStructureOfFactorInstances) -> RustBuffer {
    return FfiConverterTypeSecurityStructureOfFactorInstances.lower(value)
}

/**
 * A security structure at FactorSourceID level, this is
 * what is serialized and store into Profile, we convert
 * into this structure from `SecurityStructureOfFactorSources`.
 */
public struct SecurityStructureOfFactorSourceIDs {
    /**
     * Metadata of this Security Structure, such as globally unique and
     * stable identifier, creation date and user chosen label (name).
     */
    public var metadata: SecurityStructureMetadata
    /**
     * The amount of time until Confirmation Role is automatically
     * exercised, inputted by user in Days in UI, but translate it into
     * epochs ("block time").
     */
    public var numberOfEpochsUntilAutoConfirmation: UInt64
    /**
     * The structure of factors to use for certain roles, Primary, Recovery
     * and Confirmation role.
     */
    public var matrixOfFactors: MatrixOfFactorSourceIDs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Metadata of this Security Structure, such as globally unique and
         * stable identifier, creation date and user chosen label (name).
         */ metadata: SecurityStructureMetadata,
        /**
            * The amount of time until Confirmation Role is automatically
            * exercised, inputted by user in Days in UI, but translate it into
            * epochs ("block time").
            */ numberOfEpochsUntilAutoConfirmation: UInt64,
        /**
            * The structure of factors to use for certain roles, Primary, Recovery
            * and Confirmation role.
            */ matrixOfFactors: MatrixOfFactorSourceIDs
    ) {
        self.metadata = metadata
        self.numberOfEpochsUntilAutoConfirmation = numberOfEpochsUntilAutoConfirmation
        self.matrixOfFactors = matrixOfFactors
    }
}

extension SecurityStructureOfFactorSourceIDs: Sendable {}
extension SecurityStructureOfFactorSourceIDs: Equatable, Hashable {
    public static func == (lhs: SecurityStructureOfFactorSourceIDs, rhs: SecurityStructureOfFactorSourceIDs) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.numberOfEpochsUntilAutoConfirmation != rhs.numberOfEpochsUntilAutoConfirmation {
            return false
        }
        if lhs.matrixOfFactors != rhs.matrixOfFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
        hasher.combine(numberOfEpochsUntilAutoConfirmation)
        hasher.combine(matrixOfFactors)
    }
}

public struct FfiConverterTypeSecurityStructureOfFactorSourceIDs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureOfFactorSourceIDs {
        return
            try SecurityStructureOfFactorSourceIDs(
                metadata: FfiConverterTypeSecurityStructureMetadata.read(from: &buf),
                numberOfEpochsUntilAutoConfirmation: FfiConverterUInt64.read(from: &buf),
                matrixOfFactors: FfiConverterTypeMatrixOfFactorSourceIDs.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityStructureOfFactorSourceIDs, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureMetadata.write(value.metadata, into: &buf)
        FfiConverterUInt64.write(value.numberOfEpochsUntilAutoConfirmation, into: &buf)
        FfiConverterTypeMatrixOfFactorSourceIDs.write(value.matrixOfFactors, into: &buf)
    }
}

public func FfiConverterTypeSecurityStructureOfFactorSourceIDs_lift(_ buf: RustBuffer) throws -> SecurityStructureOfFactorSourceIDs {
    return try FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(buf)
}

public func FfiConverterTypeSecurityStructureOfFactorSourceIDs_lower(_ value: SecurityStructureOfFactorSourceIDs) -> RustBuffer {
    return FfiConverterTypeSecurityStructureOfFactorSourceIDs.lower(value)
}

/**
 * Security structure at `FactorSource` level.
 * This is what user view, creates and manages.
 *
 * Before it gets saved into Profile gets converted into
 * `SecurityStructureOfFactorSourceIDs`
 */
public struct SecurityStructureOfFactorSources {
    /**
     * Metadata of this Security Structure, such as globally unique and
     * stable identifier, creation date and user chosen label (name).
     */
    public var metadata: SecurityStructureMetadata
    /**
     * The amount of time until Confirmation Role is automatically
     * exercised, inputted by user in Days in UI, but translate it into
     * epochs ("block time").
     */
    public var numberOfEpochsUntilAutoConfirmation: UInt64
    /**
     * The structure of factors to use for certain roles, Primary, Recovery
     * and Confirmation role.
     */
    public var matrixOfFactors: MatrixOfFactorSources

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Metadata of this Security Structure, such as globally unique and
         * stable identifier, creation date and user chosen label (name).
         */ metadata: SecurityStructureMetadata,
        /**
            * The amount of time until Confirmation Role is automatically
            * exercised, inputted by user in Days in UI, but translate it into
            * epochs ("block time").
            */ numberOfEpochsUntilAutoConfirmation: UInt64,
        /**
            * The structure of factors to use for certain roles, Primary, Recovery
            * and Confirmation role.
            */ matrixOfFactors: MatrixOfFactorSources
    ) {
        self.metadata = metadata
        self.numberOfEpochsUntilAutoConfirmation = numberOfEpochsUntilAutoConfirmation
        self.matrixOfFactors = matrixOfFactors
    }
}

extension SecurityStructureOfFactorSources: Sendable {}
extension SecurityStructureOfFactorSources: Equatable, Hashable {
    public static func == (lhs: SecurityStructureOfFactorSources, rhs: SecurityStructureOfFactorSources) -> Bool {
        if lhs.metadata != rhs.metadata {
            return false
        }
        if lhs.numberOfEpochsUntilAutoConfirmation != rhs.numberOfEpochsUntilAutoConfirmation {
            return false
        }
        if lhs.matrixOfFactors != rhs.matrixOfFactors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(metadata)
        hasher.combine(numberOfEpochsUntilAutoConfirmation)
        hasher.combine(matrixOfFactors)
    }
}

public struct FfiConverterTypeSecurityStructureOfFactorSources: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureOfFactorSources {
        return
            try SecurityStructureOfFactorSources(
                metadata: FfiConverterTypeSecurityStructureMetadata.read(from: &buf),
                numberOfEpochsUntilAutoConfirmation: FfiConverterUInt64.read(from: &buf),
                matrixOfFactors: FfiConverterTypeMatrixOfFactorSources.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityStructureOfFactorSources, into buf: inout [UInt8]) {
        FfiConverterTypeSecurityStructureMetadata.write(value.metadata, into: &buf)
        FfiConverterUInt64.write(value.numberOfEpochsUntilAutoConfirmation, into: &buf)
        FfiConverterTypeMatrixOfFactorSources.write(value.matrixOfFactors, into: &buf)
    }
}

public func FfiConverterTypeSecurityStructureOfFactorSources_lift(_ buf: RustBuffer) throws -> SecurityStructureOfFactorSources {
    return try FfiConverterTypeSecurityStructureOfFactorSources.lift(buf)
}

public func FfiConverterTypeSecurityStructureOfFactorSources_lower(_ value: SecurityStructureOfFactorSources) -> RustBuffer {
    return FfiConverterTypeSecurityStructureOfFactorSources.lower(value)
}

/**
 * ❗️ NOT PRODUCTION READY YET ❗️
 * A security question
 * ❗️ NOT PRODUCTION READY YET ❗️
 */
public struct SecurityNotProductionReadyQuestion {
    public var id: UInt16
    public var version: UInt8
    public var kind: SecurityQuestionKind
    public var question: String
    public var expectedAnswerFormat: SecurityQuestionNotProductionReadyExpectedAnswerFormat

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt16, version: UInt8, kind: SecurityQuestionKind, question: String, expectedAnswerFormat: SecurityQuestionNotProductionReadyExpectedAnswerFormat) {
        self.id = id
        self.version = version
        self.kind = kind
        self.question = question
        self.expectedAnswerFormat = expectedAnswerFormat
    }
}

extension SecurityNotProductionReadyQuestion: Sendable {}
extension SecurityNotProductionReadyQuestion: Equatable, Hashable {
    public static func == (lhs: SecurityNotProductionReadyQuestion, rhs: SecurityNotProductionReadyQuestion) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.question != rhs.question {
            return false
        }
        if lhs.expectedAnswerFormat != rhs.expectedAnswerFormat {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(version)
        hasher.combine(kind)
        hasher.combine(question)
        hasher.combine(expectedAnswerFormat)
    }
}

public struct FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityNotProductionReadyQuestion {
        return
            try SecurityNotProductionReadyQuestion(
                id: FfiConverterUInt16.read(from: &buf),
                version: FfiConverterUInt8.read(from: &buf),
                kind: FfiConverterTypeSecurityQuestionKind.read(from: &buf),
                question: FfiConverterString.read(from: &buf),
                expectedAnswerFormat: FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityNotProductionReadyQuestion, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.id, into: &buf)
        FfiConverterUInt8.write(value.version, into: &buf)
        FfiConverterTypeSecurityQuestionKind.write(value.kind, into: &buf)
        FfiConverterString.write(value.question, into: &buf)
        FfiConverterTypeSecurityQuestion_NOT_PRODUCTION_READY_ExpectedAnswerFormat.write(value.expectedAnswerFormat, into: &buf)
    }
}

public func FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question_lift(_ buf: RustBuffer) throws -> SecurityNotProductionReadyQuestion {
    return try FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.lift(buf)
}

public func FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question_lower(_ value: SecurityNotProductionReadyQuestion) -> RustBuffer {
    return FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.lower(value)
}

/**
 * ❗️ NOT PRODUCTION READY YET ❗️
 * A pair of security question and answer
 * ❗️ NOT PRODUCTION READY YET ❗️
 */
public struct SecurityNotProductionReadyQuestionAndAnswer {
    public var question: SecurityNotProductionReadyQuestion
    public var answer: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(question: SecurityNotProductionReadyQuestion, answer: String) {
        self.question = question
        self.answer = answer
    }
}

extension SecurityNotProductionReadyQuestionAndAnswer: Sendable {}
extension SecurityNotProductionReadyQuestionAndAnswer: Equatable, Hashable {
    public static func == (lhs: SecurityNotProductionReadyQuestionAndAnswer, rhs: SecurityNotProductionReadyQuestionAndAnswer) -> Bool {
        if lhs.question != rhs.question {
            return false
        }
        if lhs.answer != rhs.answer {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(question)
        hasher.combine(answer)
    }
}

public struct FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityNotProductionReadyQuestionAndAnswer {
        return
            try SecurityNotProductionReadyQuestionAndAnswer(
                question: FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.read(from: &buf),
                answer: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: SecurityNotProductionReadyQuestionAndAnswer, into buf: inout [UInt8]) {
        FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.write(value.question, into: &buf)
        FfiConverterString.write(value.answer, into: &buf)
    }
}

public func FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer_lift(_ buf: RustBuffer) throws -> SecurityNotProductionReadyQuestionAndAnswer {
    return try FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lift(buf)
}

public func FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer_lower(_ value: SecurityNotProductionReadyQuestionAndAnswer) -> RustBuffer {
    return FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lower(value)
}

/**
 * Identities for PersonaData entry values a user have shared with a dApp.
 */
public struct SharedPersonaData {
    /**
     * ID of a `PersonaDataEntryName` the user has shared with some dApp on some network,
     * can be `None`.
     */
    public var name: PersonaDataEntryId?
    /**
     * IDs of a `PersonaDataEntryEmailAddress`es the user has shared with some dApp on some network
     * can be `None`, or can be `Some(<EMPTY>)`.
     */
    public var emailAddresses: SharedToDappWithPersonaIDsOfPersonaDataEntries?
    /**
     * IDs of a `PersonaDataEntryPhoneNumber`s the user has shared with some dApp on some network
     * can be `None`, or can be `Some(<EMPTY>)`.
     */
    public var phoneNumbers: SharedToDappWithPersonaIDsOfPersonaDataEntries?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * ID of a `PersonaDataEntryName` the user has shared with some dApp on some network,
         * can be `None`.
         */ name: PersonaDataEntryId?,
        /**
            * IDs of a `PersonaDataEntryEmailAddress`es the user has shared with some dApp on some network
            * can be `None`, or can be `Some(<EMPTY>)`.
            */ emailAddresses: SharedToDappWithPersonaIDsOfPersonaDataEntries?,
        /**
            * IDs of a `PersonaDataEntryPhoneNumber`s the user has shared with some dApp on some network
            * can be `None`, or can be `Some(<EMPTY>)`.
            */ phoneNumbers: SharedToDappWithPersonaIDsOfPersonaDataEntries?
    ) {
        self.name = name
        self.emailAddresses = emailAddresses
        self.phoneNumbers = phoneNumbers
    }
}

extension SharedPersonaData: Sendable {}
extension SharedPersonaData: Equatable, Hashable {
    public static func == (lhs: SharedPersonaData, rhs: SharedPersonaData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(emailAddresses)
        hasher.combine(phoneNumbers)
    }
}

public struct FfiConverterTypeSharedPersonaData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedPersonaData {
        return
            try SharedPersonaData(
                name: FfiConverterOptionTypePersonaDataEntryID.read(from: &buf),
                emailAddresses: FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf),
                phoneNumbers: FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf)
            )
    }

    public static func write(_ value: SharedPersonaData, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataEntryID.write(value.name, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value.emailAddresses, into: &buf)
        FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value.phoneNumbers, into: &buf)
    }
}

public func FfiConverterTypeSharedPersonaData_lift(_ buf: RustBuffer) throws -> SharedPersonaData {
    return try FfiConverterTypeSharedPersonaData.lift(buf)
}

public func FfiConverterTypeSharedPersonaData_lower(_ value: SharedPersonaData) -> RustBuffer {
    return FfiConverterTypeSharedPersonaData.lower(value)
}

/**
 * IDs that have been shared with an Dapp the user has interacted with
 * that fulfill a Dapp request's specified [`RequestedQuantity`].
 */
public struct SharedToDappWithPersonaAccountAddresses {
    /**
     * The requested quantity to be shared by user, sent by a Dapp.
     */
    public var request: RequestedQuantity
    /**
     * The by user shared IDs of data identifiable data shared with the
     * Dapp.
     */
    public var ids: [AccountAddress]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The requested quantity to be shared by user, sent by a Dapp.
         */ request: RequestedQuantity,
        /**
            * The by user shared IDs of data identifiable data shared with the
            * Dapp.
            */ ids: [AccountAddress]
    ) {
        self.request = request
        self.ids = ids
    }
}

extension SharedToDappWithPersonaAccountAddresses: Sendable {}
extension SharedToDappWithPersonaAccountAddresses: Equatable, Hashable {
    public static func == (lhs: SharedToDappWithPersonaAccountAddresses, rhs: SharedToDappWithPersonaAccountAddresses) -> Bool {
        if lhs.request != rhs.request {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(request)
        hasher.combine(ids)
    }
}

public struct FfiConverterTypeSharedToDappWithPersonaAccountAddresses: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedToDappWithPersonaAccountAddresses {
        return
            try SharedToDappWithPersonaAccountAddresses(
                request: FfiConverterTypeRequestedQuantity.read(from: &buf),
                ids: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
            )
    }

    public static func write(_ value: SharedToDappWithPersonaAccountAddresses, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.request, into: &buf)
        FfiConverterSequenceTypeAccountAddress.write(value.ids, into: &buf)
    }
}

public func FfiConverterTypeSharedToDappWithPersonaAccountAddresses_lift(_ buf: RustBuffer) throws -> SharedToDappWithPersonaAccountAddresses {
    return try FfiConverterTypeSharedToDappWithPersonaAccountAddresses.lift(buf)
}

public func FfiConverterTypeSharedToDappWithPersonaAccountAddresses_lower(_ value: SharedToDappWithPersonaAccountAddresses) -> RustBuffer {
    return FfiConverterTypeSharedToDappWithPersonaAccountAddresses.lower(value)
}

/**
 * IDs that have been shared with an Dapp the user has interacted with
 * that fulfill a Dapp request's specified [`RequestedQuantity`].
 */
public struct SharedToDappWithPersonaIDsOfPersonaDataEntries {
    /**
     * The requested quantity to be shared by user, sent by a Dapp.
     */
    public var request: RequestedQuantity
    /**
     * The by user shared IDs of data identifiable data shared with the
     * Dapp.
     */
    public var ids: [PersonaDataEntryId]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The requested quantity to be shared by user, sent by a Dapp.
         */ request: RequestedQuantity,
        /**
            * The by user shared IDs of data identifiable data shared with the
            * Dapp.
            */ ids: [PersonaDataEntryId]
    ) {
        self.request = request
        self.ids = ids
    }
}

extension SharedToDappWithPersonaIDsOfPersonaDataEntries: Sendable {}
extension SharedToDappWithPersonaIDsOfPersonaDataEntries: Equatable, Hashable {
    public static func == (lhs: SharedToDappWithPersonaIDsOfPersonaDataEntries, rhs: SharedToDappWithPersonaIDsOfPersonaDataEntries) -> Bool {
        if lhs.request != rhs.request {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(request)
        hasher.combine(ids)
    }
}

public struct FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SharedToDappWithPersonaIDsOfPersonaDataEntries {
        return
            try SharedToDappWithPersonaIDsOfPersonaDataEntries(
                request: FfiConverterTypeRequestedQuantity.read(from: &buf),
                ids: FfiConverterSequenceTypePersonaDataEntryID.read(from: &buf)
            )
    }

    public static func write(_ value: SharedToDappWithPersonaIDsOfPersonaDataEntries, into buf: inout [UInt8]) {
        FfiConverterTypeRequestedQuantity.write(value.request, into: &buf)
        FfiConverterSequenceTypePersonaDataEntryID.write(value.ids, into: &buf)
    }
}

public func FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries_lift(_ buf: RustBuffer) throws -> SharedToDappWithPersonaIDsOfPersonaDataEntries {
    return try FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.lift(buf)
}

public func FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries_lower(_ value: SharedToDappWithPersonaIDsOfPersonaDataEntries) -> RustBuffer {
    return FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.lower(value)
}

public struct SignedIntent {
    public var intent: TransactionIntent
    public var intentSignatures: IntentSignatures

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(intent: TransactionIntent, intentSignatures: IntentSignatures) {
        self.intent = intent
        self.intentSignatures = intentSignatures
    }
}

extension SignedIntent: Sendable {}
extension SignedIntent: Equatable, Hashable {
    public static func == (lhs: SignedIntent, rhs: SignedIntent) -> Bool {
        if lhs.intent != rhs.intent {
            return false
        }
        if lhs.intentSignatures != rhs.intentSignatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(intent)
        hasher.combine(intentSignatures)
    }
}

public struct FfiConverterTypeSignedIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedIntent {
        return
            try SignedIntent(
                intent: FfiConverterTypeTransactionIntent.read(from: &buf),
                intentSignatures: FfiConverterTypeIntentSignatures.read(from: &buf)
            )
    }

    public static func write(_ value: SignedIntent, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionIntent.write(value.intent, into: &buf)
        FfiConverterTypeIntentSignatures.write(value.intentSignatures, into: &buf)
    }
}

public func FfiConverterTypeSignedIntent_lift(_ buf: RustBuffer) throws -> SignedIntent {
    return try FfiConverterTypeSignedIntent.lift(buf)
}

public func FfiConverterTypeSignedIntent_lower(_ value: SignedIntent) -> RustBuffer {
    return FfiConverterTypeSignedIntent.lower(value)
}

public struct SignedSubintent {
    public var subintent: Subintent
    public var subintentSignatures: IntentSignatures

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(subintent: Subintent, subintentSignatures: IntentSignatures) {
        self.subintent = subintent
        self.subintentSignatures = subintentSignatures
    }
}

extension SignedSubintent: Sendable {}
extension SignedSubintent: Equatable, Hashable {
    public static func == (lhs: SignedSubintent, rhs: SignedSubintent) -> Bool {
        if lhs.subintent != rhs.subintent {
            return false
        }
        if lhs.subintentSignatures != rhs.subintentSignatures {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(subintent)
        hasher.combine(subintentSignatures)
    }
}

public struct FfiConverterTypeSignedSubintent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedSubintent {
        return
            try SignedSubintent(
                subintent: FfiConverterTypeSubintent.read(from: &buf),
                subintentSignatures: FfiConverterTypeIntentSignatures.read(from: &buf)
            )
    }

    public static func write(_ value: SignedSubintent, into buf: inout [UInt8]) {
        FfiConverterTypeSubintent.write(value.subintent, into: &buf)
        FfiConverterTypeIntentSignatures.write(value.subintentSignatures, into: &buf)
    }
}

public func FfiConverterTypeSignedSubintent_lift(_ buf: RustBuffer) throws -> SignedSubintent {
    return try FfiConverterTypeSignedSubintent.lift(buf)
}

public func FfiConverterTypeSignedSubintent_lower(_ value: SignedSubintent) -> RustBuffer {
    return FfiConverterTypeSignedSubintent.lower(value)
}

/**
 * A Signed Intent Hash is a bech32 encoded string starting with `"signedintent_"
 */
public struct SignedTransactionIntentHash {
    /**
     * Which network this transaction hash is used on
     */
    public var networkId: NetworkId
    /**
     * the hash of the intent
     */
    public var hash: Hash
    /**
     * Bech32 encoded TX id
     */
    public var bech32EncodedTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Which network this transaction hash is used on
         */ networkId: NetworkId,
        /**
            * the hash of the intent
            */ hash: Hash,
        /**
            * Bech32 encoded TX id
            */ bech32EncodedTxId: String
    ) {
        self.networkId = networkId
        self.hash = hash
        self.bech32EncodedTxId = bech32EncodedTxId
    }
}

extension SignedTransactionIntentHash: Sendable {}
extension SignedTransactionIntentHash: Equatable, Hashable {
    public static func == (lhs: SignedTransactionIntentHash, rhs: SignedTransactionIntentHash) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(hash)
        hasher.combine(bech32EncodedTxId)
    }
}

public struct FfiConverterTypeSignedTransactionIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignedTransactionIntentHash {
        return
            try SignedTransactionIntentHash(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                hash: FfiConverterTypeHash.read(from: &buf),
                bech32EncodedTxId: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: SignedTransactionIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeHash.write(value.hash, into: &buf)
        FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
    }
}

public func FfiConverterTypeSignedTransactionIntentHash_lift(_ buf: RustBuffer) throws -> SignedTransactionIntentHash {
    return try FfiConverterTypeSignedTransactionIntentHash.lift(buf)
}

public func FfiConverterTypeSignedTransactionIntentHash_lower(_ value: SignedTransactionIntentHash) -> RustBuffer {
    return FfiConverterTypeSignedTransactionIntentHash.lower(value)
}

/**
 * Represents the bounds for a simple non_fungible resource, which can be either exact or not exact.
 */
public struct SimpleNonFungibleResourceBounds {
    public var certainIds: [NonFungibleLocalId]
    public var additionalAmount: SimpleCountedResourceBounds?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(certainIds: [NonFungibleLocalId], additionalAmount: SimpleCountedResourceBounds?) {
        self.certainIds = certainIds
        self.additionalAmount = additionalAmount
    }
}

extension SimpleNonFungibleResourceBounds: Sendable {}
extension SimpleNonFungibleResourceBounds: Equatable, Hashable {
    public static func == (lhs: SimpleNonFungibleResourceBounds, rhs: SimpleNonFungibleResourceBounds) -> Bool {
        if lhs.certainIds != rhs.certainIds {
            return false
        }
        if lhs.additionalAmount != rhs.additionalAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(certainIds)
        hasher.combine(additionalAmount)
    }
}

public struct FfiConverterTypeSimpleNonFungibleResourceBounds: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleNonFungibleResourceBounds {
        return
            try SimpleNonFungibleResourceBounds(
                certainIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                additionalAmount: FfiConverterOptionTypeSimpleCountedResourceBounds.read(from: &buf)
            )
    }

    public static func write(_ value: SimpleNonFungibleResourceBounds, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.certainIds, into: &buf)
        FfiConverterOptionTypeSimpleCountedResourceBounds.write(value.additionalAmount, into: &buf)
    }
}

public func FfiConverterTypeSimpleNonFungibleResourceBounds_lift(_ buf: RustBuffer) throws -> SimpleNonFungibleResourceBounds {
    return try FfiConverterTypeSimpleNonFungibleResourceBounds.lift(buf)
}

public func FfiConverterTypeSimpleNonFungibleResourceBounds_lower(_ value: SimpleNonFungibleResourceBounds) -> RustBuffer {
    return FfiConverterTypeSimpleNonFungibleResourceBounds.lower(value)
}

public struct StakeClaim {
    public var validatorAddress: ValidatorAddress
    public var resourceAddress: NonFungibleResourceAddress
    public var ids: [NonFungibleLocalId]
    /**
     * The summed claim amount across ids
     */
    public var amount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: ValidatorAddress, resourceAddress: NonFungibleResourceAddress, ids: [NonFungibleLocalId],
                /**
                    * The summed claim amount across ids
                    */ amount: Decimal192)
    {
        self.validatorAddress = validatorAddress
        self.resourceAddress = resourceAddress
        self.ids = ids
        self.amount = amount
    }
}

extension StakeClaim: Sendable {}
extension StakeClaim: Equatable, Hashable {
    public static func == (lhs: StakeClaim, rhs: StakeClaim) -> Bool {
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.ids != rhs.ids {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validatorAddress)
        hasher.combine(resourceAddress)
        hasher.combine(ids)
        hasher.combine(amount)
    }
}

public struct FfiConverterTypeStakeClaim: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StakeClaim {
        return
            try StakeClaim(
                validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf),
                resourceAddress: FfiConverterTypeNonFungibleResourceAddress.read(from: &buf),
                ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                amount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: StakeClaim, into buf: inout [UInt8]) {
        FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeNonFungibleResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.ids, into: &buf)
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
    }
}

public func FfiConverterTypeStakeClaim_lift(_ buf: RustBuffer) throws -> StakeClaim {
    return try FfiConverterTypeStakeClaim.lift(buf)
}

public func FfiConverterTypeStakeClaim_lower(_ value: StakeClaim) -> RustBuffer {
    return FfiConverterTypeStakeClaim.lower(value)
}

public struct Subintent {
    public var header: IntentHeaderV2
    public var manifest: SubintentManifest
    public var message: MessageV2

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(header: IntentHeaderV2, manifest: SubintentManifest, message: MessageV2) {
        self.header = header
        self.manifest = manifest
        self.message = message
    }
}

extension Subintent: Sendable {}
extension Subintent: Equatable, Hashable {
    public static func == (lhs: Subintent, rhs: Subintent) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.manifest != rhs.manifest {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(manifest)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeSubintent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Subintent {
        return
            try Subintent(
                header: FfiConverterTypeIntentHeaderV2.read(from: &buf),
                manifest: FfiConverterTypeSubintentManifest.read(from: &buf),
                message: FfiConverterTypeMessageV2.read(from: &buf)
            )
    }

    public static func write(_ value: Subintent, into buf: inout [UInt8]) {
        FfiConverterTypeIntentHeaderV2.write(value.header, into: &buf)
        FfiConverterTypeSubintentManifest.write(value.manifest, into: &buf)
        FfiConverterTypeMessageV2.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeSubintent_lift(_ buf: RustBuffer) throws -> Subintent {
    return try FfiConverterTypeSubintent.lift(buf)
}

public func FfiConverterTypeSubintent_lower(_ value: Subintent) -> RustBuffer {
    return FfiConverterTypeSubintent.lower(value)
}

/**
 * `IntentHash` used to identify transactions.
 * Representation is bech32 encoded string starting with `txid_` e.g.:
 * `"txid_rdx19rpveua6xuhvz0axu0mwpqk8fywr83atv8mkrugchvw6uuslgppqh9cnj4"`
 */
public struct SubintentHash {
    /**
     * Which network this transaction hash is used on
     */
    public var networkId: NetworkId
    /**
     * the hash of the intent
     */
    public var hash: Hash
    /**
     * Bech32 encoded TX id
     */
    public var bech32EncodedTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Which network this transaction hash is used on
         */ networkId: NetworkId,
        /**
            * the hash of the intent
            */ hash: Hash,
        /**
            * Bech32 encoded TX id
            */ bech32EncodedTxId: String
    ) {
        self.networkId = networkId
        self.hash = hash
        self.bech32EncodedTxId = bech32EncodedTxId
    }
}

extension SubintentHash: Sendable {}
extension SubintentHash: Equatable, Hashable {
    public static func == (lhs: SubintentHash, rhs: SubintentHash) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(hash)
        hasher.combine(bech32EncodedTxId)
    }
}

public struct FfiConverterTypeSubintentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubintentHash {
        return
            try SubintentHash(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                hash: FfiConverterTypeHash.read(from: &buf),
                bech32EncodedTxId: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: SubintentHash, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeHash.write(value.hash, into: &buf)
        FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
    }
}

public func FfiConverterTypeSubintentHash_lift(_ buf: RustBuffer) throws -> SubintentHash {
    return try FfiConverterTypeSubintentHash.lift(buf)
}

public func FfiConverterTypeSubintentHash_lower(_ value: SubintentHash) -> RustBuffer {
    return FfiConverterTypeSubintentHash.lower(value)
}

public struct SubintentManifest {
    public var rawManifest: BagOfBytes
    public var networkId: NetworkId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(rawManifest: BagOfBytes, networkId: NetworkId) {
        self.rawManifest = rawManifest
        self.networkId = networkId
    }
}

extension SubintentManifest: Sendable {}
extension SubintentManifest: Equatable, Hashable {
    public static func == (lhs: SubintentManifest, rhs: SubintentManifest) -> Bool {
        if lhs.rawManifest != rhs.rawManifest {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rawManifest)
        hasher.combine(networkId)
    }
}

public struct FfiConverterTypeSubintentManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubintentManifest {
        return
            try SubintentManifest(
                rawManifest: FfiConverterTypeBagOfBytes.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
            )
    }

    public static func write(_ value: SubintentManifest, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.rawManifest, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
    }
}

public func FfiConverterTypeSubintentManifest_lift(_ buf: RustBuffer) throws -> SubintentManifest {
    return try FfiConverterTypeSubintentManifest.lift(buf)
}

public func FfiConverterTypeSubintentManifest_lower(_ value: SubintentManifest) -> RustBuffer {
    return FfiConverterTypeSubintentManifest.lower(value)
}

/**
 * Controls the ability of third-parties to deposit into a certain account, this is
 * useful for users who wish to not be able to receive airdrops.
 */
public struct ThirdPartyDeposits {
    /**
     * Controls the ability of third-parties to deposit into this account
     */
    public var depositRule: DepositRule
    /**
     * Denies or allows third-party deposits of specific assets by ignoring the `depositMode`
     * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
     * thus the value is unknown.
     */
    public var assetsExceptionList: [AssetException]?
    /**
     * Allows certain third-party depositors to deposit assets freely.
     * Note: There is no `deny` counterpart for this.
     * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
     * thus the value is unknown.
     */
    public var depositorsAllowList: [ResourceOrNonFungible]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Controls the ability of third-parties to deposit into this account
         */ depositRule: DepositRule,
        /**
            * Denies or allows third-party deposits of specific assets by ignoring the `depositMode`
            * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
            * thus the value is unknown.
            */ assetsExceptionList: [AssetException]?,
        /**
            * Allows certain third-party depositors to deposit assets freely.
            * Note: There is no `deny` counterpart for this.
            * `nil` means that the account was "recovered" using "Account Recovery Scan" features,
            * thus the value is unknown.
            */ depositorsAllowList: [ResourceOrNonFungible]?
    ) {
        self.depositRule = depositRule
        self.assetsExceptionList = assetsExceptionList
        self.depositorsAllowList = depositorsAllowList
    }
}

extension ThirdPartyDeposits: Sendable {}
extension ThirdPartyDeposits: Equatable, Hashable {
    public static func == (lhs: ThirdPartyDeposits, rhs: ThirdPartyDeposits) -> Bool {
        if lhs.depositRule != rhs.depositRule {
            return false
        }
        if lhs.assetsExceptionList != rhs.assetsExceptionList {
            return false
        }
        if lhs.depositorsAllowList != rhs.depositorsAllowList {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(depositRule)
        hasher.combine(assetsExceptionList)
        hasher.combine(depositorsAllowList)
    }
}

public struct FfiConverterTypeThirdPartyDeposits: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThirdPartyDeposits {
        return
            try ThirdPartyDeposits(
                depositRule: FfiConverterTypeDepositRule.read(from: &buf),
                assetsExceptionList: FfiConverterOptionSequenceTypeAssetException.read(from: &buf),
                depositorsAllowList: FfiConverterOptionSequenceTypeResourceOrNonFungible.read(from: &buf)
            )
    }

    public static func write(_ value: ThirdPartyDeposits, into buf: inout [UInt8]) {
        FfiConverterTypeDepositRule.write(value.depositRule, into: &buf)
        FfiConverterOptionSequenceTypeAssetException.write(value.assetsExceptionList, into: &buf)
        FfiConverterOptionSequenceTypeResourceOrNonFungible.write(value.depositorsAllowList, into: &buf)
    }
}

public func FfiConverterTypeThirdPartyDeposits_lift(_ buf: RustBuffer) throws -> ThirdPartyDeposits {
    return try FfiConverterTypeThirdPartyDeposits.lift(buf)
}

public func FfiConverterTypeThirdPartyDeposits_lower(_ value: ThirdPartyDeposits) -> RustBuffer {
    return FfiConverterTypeThirdPartyDeposits.lower(value)
}

public struct TokenDefinitionMetadata {
    public var name: String
    public var description: String
    public var symbol: String
    public var iconUrl: String
    public var tags: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, description: String, symbol: String, iconUrl: String, tags: [String]) {
        self.name = name
        self.description = description
        self.symbol = symbol
        self.iconUrl = iconUrl
        self.tags = tags
    }
}

extension TokenDefinitionMetadata: Sendable {}
extension TokenDefinitionMetadata: Equatable, Hashable {
    public static func == (lhs: TokenDefinitionMetadata, rhs: TokenDefinitionMetadata) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.symbol != rhs.symbol {
            return false
        }
        if lhs.iconUrl != rhs.iconUrl {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(symbol)
        hasher.combine(iconUrl)
        hasher.combine(tags)
    }
}

public struct FfiConverterTypeTokenDefinitionMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenDefinitionMetadata {
        return
            try TokenDefinitionMetadata(
                name: FfiConverterString.read(from: &buf),
                description: FfiConverterString.read(from: &buf),
                symbol: FfiConverterString.read(from: &buf),
                iconUrl: FfiConverterString.read(from: &buf),
                tags: FfiConverterSequenceString.read(from: &buf)
            )
    }

    public static func write(_ value: TokenDefinitionMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.symbol, into: &buf)
        FfiConverterString.write(value.iconUrl, into: &buf)
        FfiConverterSequenceString.write(value.tags, into: &buf)
    }
}

public func FfiConverterTypeTokenDefinitionMetadata_lift(_ buf: RustBuffer) throws -> TokenDefinitionMetadata {
    return try FfiConverterTypeTokenDefinitionMetadata.lift(buf)
}

public func FfiConverterTypeTokenDefinitionMetadata_lower(_ value: TokenDefinitionMetadata) -> RustBuffer {
    return FfiConverterTypeTokenDefinitionMetadata.lower(value)
}

/**
 * A contribution to a pool observed in the transaction
 */
public struct TrackedPoolContribution {
    public var poolAddress: PoolAddress
    public var contributedResources: [ResourceAddress: Decimal192]
    public var poolUnitsResourceAddress: ResourceAddress
    public var poolUnitsAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolAddress: PoolAddress, contributedResources: [ResourceAddress: Decimal192], poolUnitsResourceAddress: ResourceAddress, poolUnitsAmount: Decimal192) {
        self.poolAddress = poolAddress
        self.contributedResources = contributedResources
        self.poolUnitsResourceAddress = poolUnitsResourceAddress
        self.poolUnitsAmount = poolUnitsAmount
    }
}

extension TrackedPoolContribution: Sendable {}
extension TrackedPoolContribution: Equatable, Hashable {
    public static func == (lhs: TrackedPoolContribution, rhs: TrackedPoolContribution) -> Bool {
        if lhs.poolAddress != rhs.poolAddress {
            return false
        }
        if lhs.contributedResources != rhs.contributedResources {
            return false
        }
        if lhs.poolUnitsResourceAddress != rhs.poolUnitsResourceAddress {
            return false
        }
        if lhs.poolUnitsAmount != rhs.poolUnitsAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(poolAddress)
        hasher.combine(contributedResources)
        hasher.combine(poolUnitsResourceAddress)
        hasher.combine(poolUnitsAmount)
    }
}

public struct FfiConverterTypeTrackedPoolContribution: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedPoolContribution {
        return
            try TrackedPoolContribution(
                poolAddress: FfiConverterTypePoolAddress.read(from: &buf),
                contributedResources: FfiConverterDictionaryTypeResourceAddressTypeDecimal192.read(from: &buf),
                poolUnitsResourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                poolUnitsAmount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TrackedPoolContribution, into buf: inout [UInt8]) {
        FfiConverterTypePoolAddress.write(value.poolAddress, into: &buf)
        FfiConverterDictionaryTypeResourceAddressTypeDecimal192.write(value.contributedResources, into: &buf)
        FfiConverterTypeResourceAddress.write(value.poolUnitsResourceAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.poolUnitsAmount, into: &buf)
    }
}

public func FfiConverterTypeTrackedPoolContribution_lift(_ buf: RustBuffer) throws -> TrackedPoolContribution {
    return try FfiConverterTypeTrackedPoolContribution.lift(buf)
}

public func FfiConverterTypeTrackedPoolContribution_lower(_ value: TrackedPoolContribution) -> RustBuffer {
    return FfiConverterTypeTrackedPoolContribution.lower(value)
}

/**
 * A pool redemptions observed in the transaction
 */
public struct TrackedPoolRedemption {
    public var poolAddress: PoolAddress
    public var poolUnitsResourceAddress: ResourceAddress
    public var poolUnitsAmount: Decimal192
    public var redeemedResources: [ResourceAddress: Decimal192]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(poolAddress: PoolAddress, poolUnitsResourceAddress: ResourceAddress, poolUnitsAmount: Decimal192, redeemedResources: [ResourceAddress: Decimal192]) {
        self.poolAddress = poolAddress
        self.poolUnitsResourceAddress = poolUnitsResourceAddress
        self.poolUnitsAmount = poolUnitsAmount
        self.redeemedResources = redeemedResources
    }
}

extension TrackedPoolRedemption: Sendable {}
extension TrackedPoolRedemption: Equatable, Hashable {
    public static func == (lhs: TrackedPoolRedemption, rhs: TrackedPoolRedemption) -> Bool {
        if lhs.poolAddress != rhs.poolAddress {
            return false
        }
        if lhs.poolUnitsResourceAddress != rhs.poolUnitsResourceAddress {
            return false
        }
        if lhs.poolUnitsAmount != rhs.poolUnitsAmount {
            return false
        }
        if lhs.redeemedResources != rhs.redeemedResources {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(poolAddress)
        hasher.combine(poolUnitsResourceAddress)
        hasher.combine(poolUnitsAmount)
        hasher.combine(redeemedResources)
    }
}

public struct FfiConverterTypeTrackedPoolRedemption: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedPoolRedemption {
        return
            try TrackedPoolRedemption(
                poolAddress: FfiConverterTypePoolAddress.read(from: &buf),
                poolUnitsResourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                poolUnitsAmount: FfiConverterTypeDecimal192.read(from: &buf),
                redeemedResources: FfiConverterDictionaryTypeResourceAddressTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TrackedPoolRedemption, into buf: inout [UInt8]) {
        FfiConverterTypePoolAddress.write(value.poolAddress, into: &buf)
        FfiConverterTypeResourceAddress.write(value.poolUnitsResourceAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.poolUnitsAmount, into: &buf)
        FfiConverterDictionaryTypeResourceAddressTypeDecimal192.write(value.redeemedResources, into: &buf)
    }
}

public func FfiConverterTypeTrackedPoolRedemption_lift(_ buf: RustBuffer) throws -> TrackedPoolRedemption {
    return try FfiConverterTypeTrackedPoolRedemption.lift(buf)
}

public func FfiConverterTypeTrackedPoolRedemption_lower(_ value: TrackedPoolRedemption) -> RustBuffer {
    return FfiConverterTypeTrackedPoolRedemption.lower(value)
}

/**
 * A validator claim observed in the transaction
 */
public struct TrackedValidatorClaim {
    public var validatorAddress: ValidatorAddress
    public var claimNftAddress: ResourceAddress
    public var claimNftIds: [NonFungibleLocalId]
    public var xrdAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: ValidatorAddress, claimNftAddress: ResourceAddress, claimNftIds: [NonFungibleLocalId], xrdAmount: Decimal192) {
        self.validatorAddress = validatorAddress
        self.claimNftAddress = claimNftAddress
        self.claimNftIds = claimNftIds
        self.xrdAmount = xrdAmount
    }
}

extension TrackedValidatorClaim: Sendable {}
extension TrackedValidatorClaim: Equatable, Hashable {
    public static func == (lhs: TrackedValidatorClaim, rhs: TrackedValidatorClaim) -> Bool {
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.claimNftAddress != rhs.claimNftAddress {
            return false
        }
        if lhs.claimNftIds != rhs.claimNftIds {
            return false
        }
        if lhs.xrdAmount != rhs.xrdAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validatorAddress)
        hasher.combine(claimNftAddress)
        hasher.combine(claimNftIds)
        hasher.combine(xrdAmount)
    }
}

public struct FfiConverterTypeTrackedValidatorClaim: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorClaim {
        return
            try TrackedValidatorClaim(
                validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf),
                claimNftAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                claimNftIds: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf),
                xrdAmount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TrackedValidatorClaim, into buf: inout [UInt8]) {
        FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeResourceAddress.write(value.claimNftAddress, into: &buf)
        FfiConverterSequenceTypeNonFungibleLocalId.write(value.claimNftIds, into: &buf)
        FfiConverterTypeDecimal192.write(value.xrdAmount, into: &buf)
    }
}

public func FfiConverterTypeTrackedValidatorClaim_lift(_ buf: RustBuffer) throws -> TrackedValidatorClaim {
    return try FfiConverterTypeTrackedValidatorClaim.lift(buf)
}

public func FfiConverterTypeTrackedValidatorClaim_lower(_ value: TrackedValidatorClaim) -> RustBuffer {
    return FfiConverterTypeTrackedValidatorClaim.lower(value)
}

/**
 * A validator stake observed in the transaction
 */
public struct TrackedValidatorStake {
    public var validatorAddress: ValidatorAddress
    public var xrdAmount: Decimal192
    public var liquidStakeUnitAddress: ResourceAddress
    public var liquidStakeUnitAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(validatorAddress: ValidatorAddress, xrdAmount: Decimal192, liquidStakeUnitAddress: ResourceAddress, liquidStakeUnitAmount: Decimal192) {
        self.validatorAddress = validatorAddress
        self.xrdAmount = xrdAmount
        self.liquidStakeUnitAddress = liquidStakeUnitAddress
        self.liquidStakeUnitAmount = liquidStakeUnitAmount
    }
}

extension TrackedValidatorStake: Sendable {}
extension TrackedValidatorStake: Equatable, Hashable {
    public static func == (lhs: TrackedValidatorStake, rhs: TrackedValidatorStake) -> Bool {
        if lhs.validatorAddress != rhs.validatorAddress {
            return false
        }
        if lhs.xrdAmount != rhs.xrdAmount {
            return false
        }
        if lhs.liquidStakeUnitAddress != rhs.liquidStakeUnitAddress {
            return false
        }
        if lhs.liquidStakeUnitAmount != rhs.liquidStakeUnitAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(validatorAddress)
        hasher.combine(xrdAmount)
        hasher.combine(liquidStakeUnitAddress)
        hasher.combine(liquidStakeUnitAmount)
    }
}

public struct FfiConverterTypeTrackedValidatorStake: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrackedValidatorStake {
        return
            try TrackedValidatorStake(
                validatorAddress: FfiConverterTypeValidatorAddress.read(from: &buf),
                xrdAmount: FfiConverterTypeDecimal192.read(from: &buf),
                liquidStakeUnitAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                liquidStakeUnitAmount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TrackedValidatorStake, into buf: inout [UInt8]) {
        FfiConverterTypeValidatorAddress.write(value.validatorAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.xrdAmount, into: &buf)
        FfiConverterTypeResourceAddress.write(value.liquidStakeUnitAddress, into: &buf)
        FfiConverterTypeDecimal192.write(value.liquidStakeUnitAmount, into: &buf)
    }
}

public func FfiConverterTypeTrackedValidatorStake_lift(_ buf: RustBuffer) throws -> TrackedValidatorStake {
    return try FfiConverterTypeTrackedValidatorStake.lift(buf)
}

public func FfiConverterTypeTrackedValidatorStake_lower(_ value: TrackedValidatorStake) -> RustBuffer {
    return FfiConverterTypeTrackedValidatorStake.lower(value)
}

public struct TransactionGuarantee {
    /**
     * The guaranteed amount to be obtained on this transaction. For manifest & display purposes.
     */
    public var amount: Decimal192
    /**
     * The percentage the user has selected, which generated the `amount`. For display purposes only.
     */
    public var percentage: Decimal192
    public var instructionIndex: UInt64
    public var resourceAddress: ResourceAddress
    public var resourceDivisibility: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The guaranteed amount to be obtained on this transaction. For manifest & display purposes.
         */ amount: Decimal192,
        /**
            * The percentage the user has selected, which generated the `amount`. For display purposes only.
            */ percentage: Decimal192, instructionIndex: UInt64, resourceAddress: ResourceAddress, resourceDivisibility: UInt8?
    ) {
        self.amount = amount
        self.percentage = percentage
        self.instructionIndex = instructionIndex
        self.resourceAddress = resourceAddress
        self.resourceDivisibility = resourceDivisibility
    }
}

extension TransactionGuarantee: Sendable {}
extension TransactionGuarantee: Equatable, Hashable {
    public static func == (lhs: TransactionGuarantee, rhs: TransactionGuarantee) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.percentage != rhs.percentage {
            return false
        }
        if lhs.instructionIndex != rhs.instructionIndex {
            return false
        }
        if lhs.resourceAddress != rhs.resourceAddress {
            return false
        }
        if lhs.resourceDivisibility != rhs.resourceDivisibility {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(percentage)
        hasher.combine(instructionIndex)
        hasher.combine(resourceAddress)
        hasher.combine(resourceDivisibility)
    }
}

public struct FfiConverterTypeTransactionGuarantee: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionGuarantee {
        return
            try TransactionGuarantee(
                amount: FfiConverterTypeDecimal192.read(from: &buf),
                percentage: FfiConverterTypeDecimal192.read(from: &buf),
                instructionIndex: FfiConverterUInt64.read(from: &buf),
                resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf),
                resourceDivisibility: FfiConverterOptionUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionGuarantee, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.amount, into: &buf)
        FfiConverterTypeDecimal192.write(value.percentage, into: &buf)
        FfiConverterUInt64.write(value.instructionIndex, into: &buf)
        FfiConverterTypeResourceAddress.write(value.resourceAddress, into: &buf)
        FfiConverterOptionUInt8.write(value.resourceDivisibility, into: &buf)
    }
}

public func FfiConverterTypeTransactionGuarantee_lift(_ buf: RustBuffer) throws -> TransactionGuarantee {
    return try FfiConverterTypeTransactionGuarantee.lift(buf)
}

public func FfiConverterTypeTransactionGuarantee_lower(_ value: TransactionGuarantee) -> RustBuffer {
    return FfiConverterTypeTransactionGuarantee.lower(value)
}

public struct TransactionHeader {
    public var networkId: NetworkId
    public var startEpochInclusive: Epoch
    public var endEpochExclusive: Epoch
    public var nonce: Nonce
    public var notaryPublicKey: PublicKey
    public var notaryIsSignatory: Bool
    public var tipPercentage: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkId: NetworkId, startEpochInclusive: Epoch, endEpochExclusive: Epoch, nonce: Nonce, notaryPublicKey: PublicKey, notaryIsSignatory: Bool, tipPercentage: UInt16) {
        self.networkId = networkId
        self.startEpochInclusive = startEpochInclusive
        self.endEpochExclusive = endEpochExclusive
        self.nonce = nonce
        self.notaryPublicKey = notaryPublicKey
        self.notaryIsSignatory = notaryIsSignatory
        self.tipPercentage = tipPercentage
    }
}

extension TransactionHeader: Sendable {}
extension TransactionHeader: Equatable, Hashable {
    public static func == (lhs: TransactionHeader, rhs: TransactionHeader) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.startEpochInclusive != rhs.startEpochInclusive {
            return false
        }
        if lhs.endEpochExclusive != rhs.endEpochExclusive {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.notaryPublicKey != rhs.notaryPublicKey {
            return false
        }
        if lhs.notaryIsSignatory != rhs.notaryIsSignatory {
            return false
        }
        if lhs.tipPercentage != rhs.tipPercentage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(startEpochInclusive)
        hasher.combine(endEpochExclusive)
        hasher.combine(nonce)
        hasher.combine(notaryPublicKey)
        hasher.combine(notaryIsSignatory)
        hasher.combine(tipPercentage)
    }
}

public struct FfiConverterTypeTransactionHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionHeader {
        return
            try TransactionHeader(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                startEpochInclusive: FfiConverterTypeEpoch.read(from: &buf),
                endEpochExclusive: FfiConverterTypeEpoch.read(from: &buf),
                nonce: FfiConverterTypeNonce.read(from: &buf),
                notaryPublicKey: FfiConverterTypePublicKey.read(from: &buf),
                notaryIsSignatory: FfiConverterBool.read(from: &buf),
                tipPercentage: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionHeader, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeEpoch.write(value.startEpochInclusive, into: &buf)
        FfiConverterTypeEpoch.write(value.endEpochExclusive, into: &buf)
        FfiConverterTypeNonce.write(value.nonce, into: &buf)
        FfiConverterTypePublicKey.write(value.notaryPublicKey, into: &buf)
        FfiConverterBool.write(value.notaryIsSignatory, into: &buf)
        FfiConverterUInt16.write(value.tipPercentage, into: &buf)
    }
}

public func FfiConverterTypeTransactionHeader_lift(_ buf: RustBuffer) throws -> TransactionHeader {
    return try FfiConverterTypeTransactionHeader.lift(buf)
}

public func FfiConverterTypeTransactionHeader_lower(_ value: TransactionHeader) -> RustBuffer {
    return FfiConverterTypeTransactionHeader.lower(value)
}

public struct TransactionIntent {
    public var header: TransactionHeader
    public var manifest: TransactionManifest
    public var message: Message

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(header: TransactionHeader, manifest: TransactionManifest, message: Message) {
        self.header = header
        self.manifest = manifest
        self.message = message
    }
}

extension TransactionIntent: Sendable {}
extension TransactionIntent: Equatable, Hashable {
    public static func == (lhs: TransactionIntent, rhs: TransactionIntent) -> Bool {
        if lhs.header != rhs.header {
            return false
        }
        if lhs.manifest != rhs.manifest {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(header)
        hasher.combine(manifest)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeTransactionIntent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionIntent {
        return
            try TransactionIntent(
                header: FfiConverterTypeTransactionHeader.read(from: &buf),
                manifest: FfiConverterTypeTransactionManifest.read(from: &buf),
                message: FfiConverterTypeMessage.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionIntent, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionHeader.write(value.header, into: &buf)
        FfiConverterTypeTransactionManifest.write(value.manifest, into: &buf)
        FfiConverterTypeMessage.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeTransactionIntent_lift(_ buf: RustBuffer) throws -> TransactionIntent {
    return try FfiConverterTypeTransactionIntent.lift(buf)
}

public func FfiConverterTypeTransactionIntent_lower(_ value: TransactionIntent) -> RustBuffer {
    return FfiConverterTypeTransactionIntent.lower(value)
}

/**
 * `IntentHash` used to identify transactions.
 * Representation is bech32 encoded string starting with `txid_` e.g.:
 * `"txid_rdx19rpveua6xuhvz0axu0mwpqk8fywr83atv8mkrugchvw6uuslgppqh9cnj4"`
 */
public struct TransactionIntentHash {
    /**
     * Which network this transaction hash is used on
     */
    public var networkId: NetworkId
    /**
     * the hash of the intent
     */
    public var hash: Hash
    /**
     * Bech32 encoded TX id
     */
    public var bech32EncodedTxId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Which network this transaction hash is used on
         */ networkId: NetworkId,
        /**
            * the hash of the intent
            */ hash: Hash,
        /**
            * Bech32 encoded TX id
            */ bech32EncodedTxId: String
    ) {
        self.networkId = networkId
        self.hash = hash
        self.bech32EncodedTxId = bech32EncodedTxId
    }
}

extension TransactionIntentHash: Sendable {}
extension TransactionIntentHash: Equatable, Hashable {
    public static func == (lhs: TransactionIntentHash, rhs: TransactionIntentHash) -> Bool {
        if lhs.networkId != rhs.networkId {
            return false
        }
        if lhs.hash != rhs.hash {
            return false
        }
        if lhs.bech32EncodedTxId != rhs.bech32EncodedTxId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkId)
        hasher.combine(hash)
        hasher.combine(bech32EncodedTxId)
    }
}

public struct FfiConverterTypeTransactionIntentHash: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionIntentHash {
        return
            try TransactionIntentHash(
                networkId: FfiConverterTypeNetworkID.read(from: &buf),
                hash: FfiConverterTypeHash.read(from: &buf),
                bech32EncodedTxId: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionIntentHash, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
        FfiConverterTypeHash.write(value.hash, into: &buf)
        FfiConverterString.write(value.bech32EncodedTxId, into: &buf)
    }
}

public func FfiConverterTypeTransactionIntentHash_lift(_ buf: RustBuffer) throws -> TransactionIntentHash {
    return try FfiConverterTypeTransactionIntentHash.lift(buf)
}

public func FfiConverterTypeTransactionIntentHash_lower(_ value: TransactionIntentHash) -> RustBuffer {
    return FfiConverterTypeTransactionIntentHash.lower(value)
}

public struct TransactionManifest {
    public var rawManifest: BagOfBytes
    public var networkId: NetworkId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(rawManifest: BagOfBytes, networkId: NetworkId) {
        self.rawManifest = rawManifest
        self.networkId = networkId
    }
}

extension TransactionManifest: Sendable {}
extension TransactionManifest: Equatable, Hashable {
    public static func == (lhs: TransactionManifest, rhs: TransactionManifest) -> Bool {
        if lhs.rawManifest != rhs.rawManifest {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rawManifest)
        hasher.combine(networkId)
    }
}

public struct FfiConverterTypeTransactionManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifest {
        return
            try TransactionManifest(
                rawManifest: FfiConverterTypeBagOfBytes.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionManifest, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.rawManifest, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
    }
}

public func FfiConverterTypeTransactionManifest_lift(_ buf: RustBuffer) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(buf)
}

public func FfiConverterTypeTransactionManifest_lower(_ value: TransactionManifest) -> RustBuffer {
    return FfiConverterTypeTransactionManifest.lower(value)
}

public struct TransactionManifestV2 {
    public var rawManifest: BagOfBytes
    public var networkId: NetworkId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(rawManifest: BagOfBytes, networkId: NetworkId) {
        self.rawManifest = rawManifest
        self.networkId = networkId
    }
}

extension TransactionManifestV2: Sendable {}
extension TransactionManifestV2: Equatable, Hashable {
    public static func == (lhs: TransactionManifestV2, rhs: TransactionManifestV2) -> Bool {
        if lhs.rawManifest != rhs.rawManifest {
            return false
        }
        if lhs.networkId != rhs.networkId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rawManifest)
        hasher.combine(networkId)
    }
}

public struct FfiConverterTypeTransactionManifestV2: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionManifestV2 {
        return
            try TransactionManifestV2(
                rawManifest: FfiConverterTypeBagOfBytes.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionManifestV2, into buf: inout [UInt8]) {
        FfiConverterTypeBagOfBytes.write(value.rawManifest, into: &buf)
        FfiConverterTypeNetworkID.write(value.networkId, into: &buf)
    }
}

public func FfiConverterTypeTransactionManifestV2_lift(_ buf: RustBuffer) throws -> TransactionManifestV2 {
    return try FfiConverterTypeTransactionManifestV2.lift(buf)
}

public func FfiConverterTypeTransactionManifestV2_lower(_ value: TransactionManifestV2) -> RustBuffer {
    return FfiConverterTypeTransactionManifestV2.lower(value)
}

/**
 * User Preferences relating to submission of transactions.
 */
public struct TransactionPreferences {
    /**
     * The deposit guarantee that will automatically be added for
     * all deposits in transactions.
     */
    public var defaultDepositGuarantee: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The deposit guarantee that will automatically be added for
         * all deposits in transactions.
         */ defaultDepositGuarantee: Decimal192
    ) {
        self.defaultDepositGuarantee = defaultDepositGuarantee
    }
}

extension TransactionPreferences: Sendable {}
extension TransactionPreferences: Equatable, Hashable {
    public static func == (lhs: TransactionPreferences, rhs: TransactionPreferences) -> Bool {
        if lhs.defaultDepositGuarantee != rhs.defaultDepositGuarantee {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(defaultDepositGuarantee)
    }
}

public struct FfiConverterTypeTransactionPreferences: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionPreferences {
        return
            try TransactionPreferences(
                defaultDepositGuarantee: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionPreferences, into buf: inout [UInt8]) {
        FfiConverterTypeDecimal192.write(value.defaultDepositGuarantee, into: &buf)
    }
}

public func FfiConverterTypeTransactionPreferences_lift(_ buf: RustBuffer) throws -> TransactionPreferences {
    return try FfiConverterTypeTransactionPreferences.lift(buf)
}

public func FfiConverterTypeTransactionPreferences_lower(_ value: TransactionPreferences) -> RustBuffer {
    return FfiConverterTypeTransactionPreferences.lower(value)
}

/**
 * This is the result of the transaction preview analysis.
 * It contains all the information needed to compute and display the transaction details to the user.
 */
public struct TransactionToReview {
    public var transactionManifest: TransactionManifest
    public var executionSummary: ExecutionSummary

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionManifest: TransactionManifest, executionSummary: ExecutionSummary) {
        self.transactionManifest = transactionManifest
        self.executionSummary = executionSummary
    }
}

extension TransactionToReview: Sendable {}
extension TransactionToReview: Equatable, Hashable {
    public static func == (lhs: TransactionToReview, rhs: TransactionToReview) -> Bool {
        if lhs.transactionManifest != rhs.transactionManifest {
            return false
        }
        if lhs.executionSummary != rhs.executionSummary {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionManifest)
        hasher.combine(executionSummary)
    }
}

public struct FfiConverterTypeTransactionToReview: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionToReview {
        return
            try TransactionToReview(
                transactionManifest: FfiConverterTypeTransactionManifest.read(from: &buf),
                executionSummary: FfiConverterTypeExecutionSummary.read(from: &buf)
            )
    }

    public static func write(_ value: TransactionToReview, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionManifest.write(value.transactionManifest, into: &buf)
        FfiConverterTypeExecutionSummary.write(value.executionSummary, into: &buf)
    }
}

public func FfiConverterTypeTransactionToReview_lift(_ buf: RustBuffer) throws -> TransactionToReview {
    return try FfiConverterTypeTransactionToReview.lift(buf)
}

public func FfiConverterTypeTransactionToReview_lower(_ value: TransactionToReview) -> RustBuffer {
    return FfiConverterTypeTransactionToReview.lower(value)
}

/**
 * A factor source representing a person, company, organization or otherwise
 * entity that the user trusts to help her with recovery, if ever needed.
 */
public struct TrustedContactFactorSource {
    /**
     * Unique and stable identifier of this factor source.
     */
    public var id: FactorSourceIdFromAddress
    /**
     * Common properties shared between FactorSources of different kinds,
     * describing its state, when added, and supported cryptographic parameters.
     */
    public var common: FactorSourceCommon
    /**
     * The contact information about the contact that is 'trusted'.
     */
    public var contact: TrustedContactFactorSourceContact

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique and stable identifier of this factor source.
         */ id: FactorSourceIdFromAddress,
        /**
            * Common properties shared between FactorSources of different kinds,
            * describing its state, when added, and supported cryptographic parameters.
            */ common: FactorSourceCommon,
        /**
            * The contact information about the contact that is 'trusted'.
            */ contact: TrustedContactFactorSourceContact
    ) {
        self.id = id
        self.common = common
        self.contact = contact
    }
}

extension TrustedContactFactorSource: Sendable {}
extension TrustedContactFactorSource: Equatable, Hashable {
    public static func == (lhs: TrustedContactFactorSource, rhs: TrustedContactFactorSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.common != rhs.common {
            return false
        }
        if lhs.contact != rhs.contact {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(common)
        hasher.combine(contact)
    }
}

public struct FfiConverterTypeTrustedContactFactorSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrustedContactFactorSource {
        return
            try TrustedContactFactorSource(
                id: FfiConverterTypeFactorSourceIDFromAddress.read(from: &buf),
                common: FfiConverterTypeFactorSourceCommon.read(from: &buf),
                contact: FfiConverterTypeTrustedContactFactorSourceContact.read(from: &buf)
            )
    }

    public static func write(_ value: TrustedContactFactorSource, into buf: inout [UInt8]) {
        FfiConverterTypeFactorSourceIDFromAddress.write(value.id, into: &buf)
        FfiConverterTypeFactorSourceCommon.write(value.common, into: &buf)
        FfiConverterTypeTrustedContactFactorSourceContact.write(value.contact, into: &buf)
    }
}

public func FfiConverterTypeTrustedContactFactorSource_lift(_ buf: RustBuffer) throws -> TrustedContactFactorSource {
    return try FfiConverterTypeTrustedContactFactorSource.lift(buf)
}

public func FfiConverterTypeTrustedContactFactorSource_lower(_ value: TrustedContactFactorSource) -> RustBuffer {
    return FfiConverterTypeTrustedContactFactorSource.lower(value)
}

/**
 * Hints about the trusted contact.
 */
public struct TrustedContactFactorSourceContact {
    /**
     * The email address of the contact that the user trusts
     */
    public var emailAddress: EmailAddress
    /**
     * The name of the contact that the user trusts
     */
    public var name: DisplayName

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The email address of the contact that the user trusts
         */ emailAddress: EmailAddress,
        /**
            * The name of the contact that the user trusts
            */ name: DisplayName
    ) {
        self.emailAddress = emailAddress
        self.name = name
    }
}

extension TrustedContactFactorSourceContact: Sendable {}
extension TrustedContactFactorSourceContact: Equatable, Hashable {
    public static func == (lhs: TrustedContactFactorSourceContact, rhs: TrustedContactFactorSourceContact) -> Bool {
        if lhs.emailAddress != rhs.emailAddress {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(emailAddress)
        hasher.combine(name)
    }
}

public struct FfiConverterTypeTrustedContactFactorSourceContact: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrustedContactFactorSourceContact {
        return
            try TrustedContactFactorSourceContact(
                emailAddress: FfiConverterTypeEmailAddress.read(from: &buf),
                name: FfiConverterTypeDisplayName.read(from: &buf)
            )
    }

    public static func write(_ value: TrustedContactFactorSourceContact, into buf: inout [UInt8]) {
        FfiConverterTypeEmailAddress.write(value.emailAddress, into: &buf)
        FfiConverterTypeDisplayName.write(value.name, into: &buf)
    }
}

public func FfiConverterTypeTrustedContactFactorSourceContact_lift(_ buf: RustBuffer) throws -> TrustedContactFactorSourceContact {
    return try FfiConverterTypeTrustedContactFactorSourceContact.lift(buf)
}

public func FfiConverterTypeTrustedContactFactorSourceContact_lower(_ value: TrustedContactFactorSourceContact) -> RustBuffer {
    return FfiConverterTypeTrustedContactFactorSourceContact.lower(value)
}

public struct U11 {
    public var inner: UInt16

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inner: UInt16) {
        self.inner = inner
    }
}

extension U11: Sendable {}
extension U11: Equatable, Hashable {
    public static func == (lhs: U11, rhs: U11) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}

public struct FfiConverterTypeU11: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U11 {
        return
            try U11(
                inner: FfiConverterUInt16.read(from: &buf)
            )
    }

    public static func write(_ value: U11, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.inner, into: &buf)
    }
}

public func FfiConverterTypeU11_lift(_ buf: RustBuffer) throws -> U11 {
    return try FfiConverterTypeU11.lift(buf)
}

public func FfiConverterTypeU11_lower(_ value: U11) -> RustBuffer {
    return FfiConverterTypeU11.lower(value)
}

public struct U30 {
    fileprivate let secretMagic: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: UInt32) {
        self.secretMagic = secretMagic
    }
}

extension U30: Sendable {}
extension U30: Equatable, Hashable {
    public static func == (lhs: U30, rhs: U30) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeU30: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U30 {
        return
            try U30(
                secretMagic: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: U30, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeU30_lift(_ buf: RustBuffer) throws -> U30 {
    return try FfiConverterTypeU30.lift(buf)
}

public func FfiConverterTypeU30_lower(_ value: U30) -> RustBuffer {
    return FfiConverterTypeU30.lower(value)
}

public struct U31 {
    fileprivate let secretMagic: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: UInt32) {
        self.secretMagic = secretMagic
    }
}

extension U31: Sendable {}
extension U31: Equatable, Hashable {
    public static func == (lhs: U31, rhs: U31) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeU31: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U31 {
        return
            try U31(
                secretMagic: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: U31, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeU31_lift(_ buf: RustBuffer) throws -> U31 {
    return try FfiConverterTypeU31.lift(buf)
}

public func FfiConverterTypeU31_lower(_ value: U31) -> RustBuffer {
    return FfiConverterTypeU31.lower(value)
}

public struct Unhardened {
    fileprivate let secretMagic: U31

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: U31) {
        self.secretMagic = secretMagic
    }
}

extension Unhardened: Sendable {}
extension Unhardened: Equatable, Hashable {
    public static func == (lhs: Unhardened, rhs: Unhardened) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeUnhardened: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unhardened {
        return
            try Unhardened(
                secretMagic: FfiConverterTypeU31.read(from: &buf)
            )
    }

    public static func write(_ value: Unhardened, into buf: inout [UInt8]) {
        FfiConverterTypeU31.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeUnhardened_lift(_ buf: RustBuffer) throws -> Unhardened {
    return try FfiConverterTypeUnhardened.lift(buf)
}

public func FfiConverterTypeUnhardened_lower(_ value: Unhardened) -> RustBuffer {
    return FfiConverterTypeUnhardened.lower(value)
}

/**
 * Basic security control of an unsecured entity. When said entity
 * is "securified" it will no longer be controlled by this `UnsecuredEntityControl`
 * but rather by an `AccessControl`. It is a name space holding the
 * single factor instance which was used to create
 */
public struct UnsecuredEntityControl {
    public var transactionSigning: HierarchicalDeterministicFactorInstance
    /**
     * The factor instance which can be used for ROLA.
     */
    public var authenticationSigning: HierarchicalDeterministicFactorInstance?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionSigning: HierarchicalDeterministicFactorInstance,
                /**
                    * The factor instance which can be used for ROLA.
                    */ authenticationSigning: HierarchicalDeterministicFactorInstance?)
    {
        self.transactionSigning = transactionSigning
        self.authenticationSigning = authenticationSigning
    }
}

extension UnsecuredEntityControl: Sendable {}
extension UnsecuredEntityControl: Equatable, Hashable {
    public static func == (lhs: UnsecuredEntityControl, rhs: UnsecuredEntityControl) -> Bool {
        if lhs.transactionSigning != rhs.transactionSigning {
            return false
        }
        if lhs.authenticationSigning != rhs.authenticationSigning {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionSigning)
        hasher.combine(authenticationSigning)
    }
}

public struct FfiConverterTypeUnsecuredEntityControl: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsecuredEntityControl {
        return
            try UnsecuredEntityControl(
                transactionSigning: FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf),
                authenticationSigning: FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
            )
    }

    public static func write(_ value: UnsecuredEntityControl, into buf: inout [UInt8]) {
        FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value.transactionSigning, into: &buf)
        FfiConverterOptionTypeHierarchicalDeterministicFactorInstance.write(value.authenticationSigning, into: &buf)
    }
}

public func FfiConverterTypeUnsecuredEntityControl_lift(_ buf: RustBuffer) throws -> UnsecuredEntityControl {
    return try FfiConverterTypeUnsecuredEntityControl.lift(buf)
}

public func FfiConverterTypeUnsecuredEntityControl_lower(_ value: UnsecuredEntityControl) -> RustBuffer {
    return FfiConverterTypeUnsecuredEntityControl.lower(value)
}

public struct UnsecurifiedHardened {
    fileprivate let secretMagic: U30

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: U30) {
        self.secretMagic = secretMagic
    }
}

extension UnsecurifiedHardened: Sendable {}
extension UnsecurifiedHardened: Equatable, Hashable {
    public static func == (lhs: UnsecurifiedHardened, rhs: UnsecurifiedHardened) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeUnsecurifiedHardened: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsecurifiedHardened {
        return
            try UnsecurifiedHardened(
                secretMagic: FfiConverterTypeU30.read(from: &buf)
            )
    }

    public static func write(_ value: UnsecurifiedHardened, into buf: inout [UInt8]) {
        FfiConverterTypeU30.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeUnsecurifiedHardened_lift(_ buf: RustBuffer) throws -> UnsecurifiedHardened {
    return try FfiConverterTypeUnsecurifiedHardened.lift(buf)
}

public func FfiConverterTypeUnsecurifiedHardened_lower(_ value: UnsecurifiedHardened) -> RustBuffer {
    return FfiConverterTypeUnsecurifiedHardened.lower(value)
}

/**
 * The data associated with the various validator claim NFTs
 */
public struct UnstakeData {
    public var name: String
    /**
     * An epoch number at (or after) which the pending unstaked XRD may be claimed.
     */
    public var claimEpoch: Epoch
    /**
     * An XRD amount to be claimed.
     */
    public var claimAmount: Decimal192

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String,
                /**
                    * An epoch number at (or after) which the pending unstaked XRD may be claimed.
                    */ claimEpoch: Epoch,
                /**
                    * An XRD amount to be claimed.
                    */ claimAmount: Decimal192)
    {
        self.name = name
        self.claimEpoch = claimEpoch
        self.claimAmount = claimAmount
    }
}

extension UnstakeData: Sendable {}
extension UnstakeData: Equatable, Hashable {
    public static func == (lhs: UnstakeData, rhs: UnstakeData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.claimEpoch != rhs.claimEpoch {
            return false
        }
        if lhs.claimAmount != rhs.claimAmount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(claimEpoch)
        hasher.combine(claimAmount)
    }
}

public struct FfiConverterTypeUnstakeData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstakeData {
        return
            try UnstakeData(
                name: FfiConverterString.read(from: &buf),
                claimEpoch: FfiConverterTypeEpoch.read(from: &buf),
                claimAmount: FfiConverterTypeDecimal192.read(from: &buf)
            )
    }

    public static func write(_ value: UnstakeData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeEpoch.write(value.claimEpoch, into: &buf)
        FfiConverterTypeDecimal192.write(value.claimAmount, into: &buf)
    }
}

public func FfiConverterTypeUnstakeData_lift(_ buf: RustBuffer) throws -> UnstakeData {
    return try FfiConverterTypeUnstakeData.lift(buf)
}

public func FfiConverterTypeUnstakeData_lower(_ value: UnstakeData) -> RustBuffer {
    return FfiConverterTypeUnstakeData.lower(value)
}

public struct UnvalidatedSubintentManifest {
    public var subintentManifestString: String
    public var blobs: Blobs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(subintentManifestString: String, blobs: Blobs) {
        self.subintentManifestString = subintentManifestString
        self.blobs = blobs
    }
}

extension UnvalidatedSubintentManifest: Sendable {}
extension UnvalidatedSubintentManifest: Equatable, Hashable {
    public static func == (lhs: UnvalidatedSubintentManifest, rhs: UnvalidatedSubintentManifest) -> Bool {
        if lhs.subintentManifestString != rhs.subintentManifestString {
            return false
        }
        if lhs.blobs != rhs.blobs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(subintentManifestString)
        hasher.combine(blobs)
    }
}

public struct FfiConverterTypeUnvalidatedSubintentManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnvalidatedSubintentManifest {
        return
            try UnvalidatedSubintentManifest(
                subintentManifestString: FfiConverterString.read(from: &buf),
                blobs: FfiConverterTypeBlobs.read(from: &buf)
            )
    }

    public static func write(_ value: UnvalidatedSubintentManifest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.subintentManifestString, into: &buf)
        FfiConverterTypeBlobs.write(value.blobs, into: &buf)
    }
}

public func FfiConverterTypeUnvalidatedSubintentManifest_lift(_ buf: RustBuffer) throws -> UnvalidatedSubintentManifest {
    return try FfiConverterTypeUnvalidatedSubintentManifest.lift(buf)
}

public func FfiConverterTypeUnvalidatedSubintentManifest_lower(_ value: UnvalidatedSubintentManifest) -> RustBuffer {
    return FfiConverterTypeUnvalidatedSubintentManifest.lower(value)
}

public struct UnvalidatedTransactionManifest {
    public var transactionManifestString: String
    public var blobs: Blobs

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionManifestString: String, blobs: Blobs) {
        self.transactionManifestString = transactionManifestString
        self.blobs = blobs
    }
}

extension UnvalidatedTransactionManifest: Sendable {}
extension UnvalidatedTransactionManifest: Equatable, Hashable {
    public static func == (lhs: UnvalidatedTransactionManifest, rhs: UnvalidatedTransactionManifest) -> Bool {
        if lhs.transactionManifestString != rhs.transactionManifestString {
            return false
        }
        if lhs.blobs != rhs.blobs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionManifestString)
        hasher.combine(blobs)
    }
}

public struct FfiConverterTypeUnvalidatedTransactionManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnvalidatedTransactionManifest {
        return
            try UnvalidatedTransactionManifest(
                transactionManifestString: FfiConverterString.read(from: &buf),
                blobs: FfiConverterTypeBlobs.read(from: &buf)
            )
    }

    public static func write(_ value: UnvalidatedTransactionManifest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.transactionManifestString, into: &buf)
        FfiConverterTypeBlobs.write(value.blobs, into: &buf)
    }
}

public func FfiConverterTypeUnvalidatedTransactionManifest_lift(_ buf: RustBuffer) throws -> UnvalidatedTransactionManifest {
    return try FfiConverterTypeUnvalidatedTransactionManifest.lift(buf)
}

public func FfiConverterTypeUnvalidatedTransactionManifest_lower(_ value: UnvalidatedTransactionManifest) -> RustBuffer {
    return FfiConverterTypeUnvalidatedTransactionManifest.lower(value)
}

/**
 * Address to a Validator that secures the network by validating transactions, users can stake to these
 * validators (Delegated Proof of Stake) by using the Dashboard and sending a TX to the Radix Wallet to sign;
 * e.g.:
 * `"validator_rdx1sd5368vqdmjk0y2w7ymdts02cz9c52858gpyny56xdvzuheepdeyy0"`
 *
 * A `ValidatorAddress` has the [Scrypto's `EntityType`][entt] `GlobalValidator`.
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalValidatorAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L249-L250
 */
public struct ValidatorAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}

extension ValidatorAddress: Sendable {}
extension ValidatorAddress: Equatable, Hashable {
    public static func == (lhs: ValidatorAddress, rhs: ValidatorAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeValidatorAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidatorAddress {
        return
            try ValidatorAddress(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: ValidatorAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeValidatorAddress_lift(_ buf: RustBuffer) throws -> ValidatorAddress {
    return try FfiConverterTypeValidatorAddress.lift(buf)
}

public func FfiConverterTypeValidatorAddress_lower(_ value: ValidatorAddress) -> RustBuffer {
    return FfiConverterTypeValidatorAddress.lower(value)
}

/**
 * Addresses to a specific vault, owned by a user, holding asset of one kind, either fungible or non_fungible.
 * Identities cannot own assets so they do not have vaults, but Accounts do, e.g.:
 * `"internal_vault_rdx1tz474x29nxxd4k2p2reete9xyz4apawv63dphxkr00qt23vyju49fq"`
 *
 * There are fundamentally two different sub-types ([Scrypto's `EntityType`][entt]) of VaultAddresses:
 * * InternalFungibleVault
 * * InternalNonFungibleVault
 *
 * Implementation wise we wrap [Radix Engine Toolkit's `CanonicalVaultAddress`][ret], and
 * give it UniFFI support, as a ` uniffi::Record` (we also own Serde).
 *
 * [entt]: https://github.com/radixdlt/radixdlt-scrypto/blob/fc196e21aacc19c0a3dbb13f3cd313dccf4327ca/radix-engine-common/src/types/entity_type.rs
 * [ret]: https://github.com/radixdlt/radix-engine-toolkit/blob/34fcc3d5953f4fe131d63d4ee2c41259a087e7a5/crates/radix-engine-toolkit/src/models/canonical_address_types.rs#L251-L255
 */
public struct VaultAddress {
    fileprivate let secretMagic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    fileprivate init(secretMagic: String) {
        self.secretMagic = secretMagic
    }
}

extension VaultAddress: Sendable {}
extension VaultAddress: Equatable, Hashable {
    public static func == (lhs: VaultAddress, rhs: VaultAddress) -> Bool {
        if lhs.secretMagic != rhs.secretMagic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretMagic)
    }
}

public struct FfiConverterTypeVaultAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VaultAddress {
        return
            try VaultAddress(
                secretMagic: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: VaultAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.secretMagic, into: &buf)
    }
}

public func FfiConverterTypeVaultAddress_lift(_ buf: RustBuffer) throws -> VaultAddress {
    return try FfiConverterTypeVaultAddress.lift(buf)
}

public func FfiConverterTypeVaultAddress_lower(_ value: VaultAddress) -> RustBuffer {
    return FfiConverterTypeVaultAddress.lower(value)
}

public struct WalletInteractionWalletAccount {
    public var address: AccountAddress
    public var label: DisplayName
    public var appearanceId: AppearanceId

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: AccountAddress, label: DisplayName, appearanceId: AppearanceId) {
        self.address = address
        self.label = label
        self.appearanceId = appearanceId
    }
}

extension WalletInteractionWalletAccount: Sendable {}
extension WalletInteractionWalletAccount: Equatable, Hashable {
    public static func == (lhs: WalletInteractionWalletAccount, rhs: WalletInteractionWalletAccount) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        if lhs.appearanceId != rhs.appearanceId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(label)
        hasher.combine(appearanceId)
    }
}

public struct FfiConverterTypeWalletInteractionWalletAccount: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionWalletAccount {
        return
            try WalletInteractionWalletAccount(
                address: FfiConverterTypeAccountAddress.read(from: &buf),
                label: FfiConverterTypeDisplayName.read(from: &buf),
                appearanceId: FfiConverterTypeAppearanceID.read(from: &buf)
            )
    }

    public static func write(_ value: WalletInteractionWalletAccount, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.address, into: &buf)
        FfiConverterTypeDisplayName.write(value.label, into: &buf)
        FfiConverterTypeAppearanceID.write(value.appearanceId, into: &buf)
    }
}

public func FfiConverterTypeWalletInteractionWalletAccount_lift(_ buf: RustBuffer) throws -> WalletInteractionWalletAccount {
    return try FfiConverterTypeWalletInteractionWalletAccount.lift(buf)
}

public func FfiConverterTypeWalletInteractionWalletAccount_lower(_ value: WalletInteractionWalletAccount) -> RustBuffer {
    return FfiConverterTypeWalletInteractionWalletAccount.lower(value)
}

public struct WalletToDappInteractionAccountProof {
    public var accountAddress: AccountAddress
    public var proof: WalletToDappInteractionAuthProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accountAddress: AccountAddress, proof: WalletToDappInteractionAuthProof) {
        self.accountAddress = accountAddress
        self.proof = proof
    }
}

extension WalletToDappInteractionAccountProof: Sendable {}
extension WalletToDappInteractionAccountProof: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAccountProof, rhs: WalletToDappInteractionAccountProof) -> Bool {
        if lhs.accountAddress != rhs.accountAddress {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountAddress)
        hasher.combine(proof)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAccountProof {
        return
            try WalletToDappInteractionAccountProof(
                accountAddress: FfiConverterTypeAccountAddress.read(from: &buf),
                proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAccountProof, into buf: inout [UInt8]) {
        FfiConverterTypeAccountAddress.write(value.accountAddress, into: &buf)
        FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAccountProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAccountProof {
    return try FfiConverterTypeWalletToDappInteractionAccountProof.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAccountProof_lower(_ value: WalletToDappInteractionAccountProof) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAccountProof.lower(value)
}

public struct WalletToDappInteractionAccountsRequestResponseItem {
    public var accounts: [WalletInteractionWalletAccount]
    public var challenge: DappToWalletInteractionAuthChallengeNonce?
    public var proofs: [WalletToDappInteractionAccountProof]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(accounts: [WalletInteractionWalletAccount], challenge: DappToWalletInteractionAuthChallengeNonce?, proofs: [WalletToDappInteractionAccountProof]?) {
        self.accounts = accounts
        self.challenge = challenge
        self.proofs = proofs
    }
}

extension WalletToDappInteractionAccountsRequestResponseItem: Sendable {}
extension WalletToDappInteractionAccountsRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAccountsRequestResponseItem, rhs: WalletToDappInteractionAccountsRequestResponseItem) -> Bool {
        if lhs.accounts != rhs.accounts {
            return false
        }
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.proofs != rhs.proofs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accounts)
        hasher.combine(challenge)
        hasher.combine(proofs)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAccountsRequestResponseItem {
        return
            try WalletToDappInteractionAccountsRequestResponseItem(
                accounts: FfiConverterSequenceTypeWalletInteractionWalletAccount.read(from: &buf),
                challenge: FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf),
                proofs: FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAccountsRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeWalletInteractionWalletAccount.write(value.accounts, into: &buf)
        FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
        FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof.write(value.proofs, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAccountsRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem_lower(_ value: WalletToDappInteractionAccountsRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
    public var persona: DappWalletInteractionPersona
    public var challenge: DappToWalletInteractionAuthChallengeNonce
    public var proof: WalletToDappInteractionAuthProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(persona: DappWalletInteractionPersona, challenge: DappToWalletInteractionAuthChallengeNonce, proof: WalletToDappInteractionAuthProof) {
        self.persona = persona
        self.challenge = challenge
        self.proof = proof
    }
}

extension WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: Sendable {}
extension WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem, rhs: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem) -> Bool {
        if lhs.persona != rhs.persona {
            return false
        }
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(persona)
        hasher.combine(challenge)
        hasher.combine(proof)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
        return
            try WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem(
                persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf),
                challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf),
                proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
        FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem_lower(_ value: WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
    public var persona: DappWalletInteractionPersona

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(persona: DappWalletInteractionPersona) {
        self.persona = persona
    }
}

extension WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: Sendable {}
extension WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem, rhs: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem) -> Bool {
        if lhs.persona != rhs.persona {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(persona)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
        return
            try WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem(
                persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem_lower(_ value: WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionAuthProof {
    public var publicKey: PublicKey
    public var curve: Slip10Curve
    public var signature: Signature

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: PublicKey, curve: Slip10Curve, signature: Signature) {
        self.publicKey = publicKey
        self.curve = curve
        self.signature = signature
    }
}

extension WalletToDappInteractionAuthProof: Sendable {}
extension WalletToDappInteractionAuthProof: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthProof, rhs: WalletToDappInteractionAuthProof) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.curve != rhs.curve {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(curve)
        hasher.combine(signature)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthProof {
        return
            try WalletToDappInteractionAuthProof(
                publicKey: FfiConverterTypePublicKey.read(from: &buf),
                curve: FfiConverterTypeSLIP10Curve.read(from: &buf),
                signature: FfiConverterTypeSignature.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthProof, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterTypeSLIP10Curve.write(value.curve, into: &buf)
        FfiConverterTypeSignature.write(value.signature, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthProof {
    return try FfiConverterTypeWalletToDappInteractionAuthProof.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthProof_lower(_ value: WalletToDappInteractionAuthProof) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthProof.lower(value)
}

public struct WalletToDappInteractionAuthUsePersonaRequestResponseItem {
    public var persona: DappWalletInteractionPersona

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(persona: DappWalletInteractionPersona) {
        self.persona = persona
    }
}

extension WalletToDappInteractionAuthUsePersonaRequestResponseItem: Sendable {}
extension WalletToDappInteractionAuthUsePersonaRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthUsePersonaRequestResponseItem, rhs: WalletToDappInteractionAuthUsePersonaRequestResponseItem) -> Bool {
        if lhs.persona != rhs.persona {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(persona)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthUsePersonaRequestResponseItem {
        return
            try WalletToDappInteractionAuthUsePersonaRequestResponseItem(
                persona: FfiConverterTypeDappWalletInteractionPersona.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthUsePersonaRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappWalletInteractionPersona.write(value.persona, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthUsePersonaRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem_lower(_ value: WalletToDappInteractionAuthUsePersonaRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionAuthorizedRequestResponseItems {
    public var auth: WalletToDappInteractionAuthRequestResponseItem
    public var ongoingAccounts: WalletToDappInteractionAccountsRequestResponseItem?
    public var ongoingPersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?
    public var oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?
    public var oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?
    public var proofOfOwnership: WalletToDappInteractionProofOfOwnershipRequestResponseItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(auth: WalletToDappInteractionAuthRequestResponseItem, ongoingAccounts: WalletToDappInteractionAccountsRequestResponseItem?, ongoingPersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?, oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?, oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?, proofOfOwnership: WalletToDappInteractionProofOfOwnershipRequestResponseItem?) {
        self.auth = auth
        self.ongoingAccounts = ongoingAccounts
        self.ongoingPersonaData = ongoingPersonaData
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
        self.proofOfOwnership = proofOfOwnership
    }
}

extension WalletToDappInteractionAuthorizedRequestResponseItems: Sendable {}
extension WalletToDappInteractionAuthorizedRequestResponseItems: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionAuthorizedRequestResponseItems, rhs: WalletToDappInteractionAuthorizedRequestResponseItems) -> Bool {
        if lhs.auth != rhs.auth {
            return false
        }
        if lhs.ongoingAccounts != rhs.ongoingAccounts {
            return false
        }
        if lhs.ongoingPersonaData != rhs.ongoingPersonaData {
            return false
        }
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        if lhs.proofOfOwnership != rhs.proofOfOwnership {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(auth)
        hasher.combine(ongoingAccounts)
        hasher.combine(ongoingPersonaData)
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
        hasher.combine(proofOfOwnership)
    }
}

public struct FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthorizedRequestResponseItems {
        return
            try WalletToDappInteractionAuthorizedRequestResponseItems(
                auth: FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.read(from: &buf),
                ongoingAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf),
                ongoingPersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf),
                oneTimeAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf),
                oneTimePersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf),
                proofOfOwnership: FfiConverterOptionTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionAuthorizedRequestResponseItems, into buf: inout [UInt8]) {
        FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.write(value.auth, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.ongoingAccounts, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.ongoingPersonaData, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.oneTimePersonaData, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.write(value.proofOfOwnership, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthorizedRequestResponseItems {
    return try FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems_lower(_ value: WalletToDappInteractionAuthorizedRequestResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.lower(value)
}

public struct WalletToDappInteractionFailureResponse {
    public var interactionId: WalletInteractionId
    public var error: DappWalletInteractionErrorType
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, error: DappWalletInteractionErrorType, message: String?) {
        self.interactionId = interactionId
        self.error = error
        self.message = message
    }
}

extension WalletToDappInteractionFailureResponse: Sendable {}
extension WalletToDappInteractionFailureResponse: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionFailureResponse, rhs: WalletToDappInteractionFailureResponse) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(error)
        hasher.combine(message)
    }
}

public struct FfiConverterTypeWalletToDappInteractionFailureResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionFailureResponse {
        return
            try WalletToDappInteractionFailureResponse(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                error: FfiConverterTypeDappWalletInteractionErrorType.read(from: &buf),
                message: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionFailureResponse, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeDappWalletInteractionErrorType.write(value.error, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionFailureResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionFailureResponse {
    return try FfiConverterTypeWalletToDappInteractionFailureResponse.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionFailureResponse_lower(_ value: WalletToDappInteractionFailureResponse) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionFailureResponse.lower(value)
}

public struct WalletToDappInteractionPersonaDataRequestResponseItem {
    public var name: PersonaDataEntryName?
    public var emailAddresses: [EmailAddress]?
    public var phoneNumbers: [PersonaDataEntryPhoneNumber]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: PersonaDataEntryName?, emailAddresses: [EmailAddress]?, phoneNumbers: [PersonaDataEntryPhoneNumber]?) {
        self.name = name
        self.emailAddresses = emailAddresses
        self.phoneNumbers = phoneNumbers
    }
}

extension WalletToDappInteractionPersonaDataRequestResponseItem: Sendable {}
extension WalletToDappInteractionPersonaDataRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionPersonaDataRequestResponseItem, rhs: WalletToDappInteractionPersonaDataRequestResponseItem) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.emailAddresses != rhs.emailAddresses {
            return false
        }
        if lhs.phoneNumbers != rhs.phoneNumbers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(emailAddresses)
        hasher.combine(phoneNumbers)
    }
}

public struct FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionPersonaDataRequestResponseItem {
        return
            try WalletToDappInteractionPersonaDataRequestResponseItem(
                name: FfiConverterOptionTypePersonaDataEntryName.read(from: &buf),
                emailAddresses: FfiConverterOptionSequenceTypeEmailAddress.read(from: &buf),
                phoneNumbers: FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionPersonaDataRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterOptionTypePersonaDataEntryName.write(value.name, into: &buf)
        FfiConverterOptionSequenceTypeEmailAddress.write(value.emailAddresses, into: &buf)
        FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber.write(value.phoneNumbers, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionPersonaDataRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem_lower(_ value: WalletToDappInteractionPersonaDataRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionPersonaProof {
    public var identityAddress: IdentityAddress
    public var proof: WalletToDappInteractionAuthProof

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identityAddress: IdentityAddress, proof: WalletToDappInteractionAuthProof) {
        self.identityAddress = identityAddress
        self.proof = proof
    }
}

extension WalletToDappInteractionPersonaProof: Sendable {}
extension WalletToDappInteractionPersonaProof: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionPersonaProof, rhs: WalletToDappInteractionPersonaProof) -> Bool {
        if lhs.identityAddress != rhs.identityAddress {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityAddress)
        hasher.combine(proof)
    }
}

public struct FfiConverterTypeWalletToDappInteractionPersonaProof: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionPersonaProof {
        return
            try WalletToDappInteractionPersonaProof(
                identityAddress: FfiConverterTypeIdentityAddress.read(from: &buf),
                proof: FfiConverterTypeWalletToDappInteractionAuthProof.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionPersonaProof, into buf: inout [UInt8]) {
        FfiConverterTypeIdentityAddress.write(value.identityAddress, into: &buf)
        FfiConverterTypeWalletToDappInteractionAuthProof.write(value.proof, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionPersonaProof_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionPersonaProof {
    return try FfiConverterTypeWalletToDappInteractionPersonaProof.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionPersonaProof_lower(_ value: WalletToDappInteractionPersonaProof) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionPersonaProof.lower(value)
}

public struct WalletToDappInteractionPreAuthorizationResponseItems {
    public var response: WalletToDappInteractionSubintentResponseItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(response: WalletToDappInteractionSubintentResponseItem) {
        self.response = response
    }
}

extension WalletToDappInteractionPreAuthorizationResponseItems: Sendable {}
extension WalletToDappInteractionPreAuthorizationResponseItems: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionPreAuthorizationResponseItems, rhs: WalletToDappInteractionPreAuthorizationResponseItems) -> Bool {
        if lhs.response != rhs.response {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(response)
    }
}

public struct FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionPreAuthorizationResponseItems {
        return
            try WalletToDappInteractionPreAuthorizationResponseItems(
                response: FfiConverterTypeWalletToDappInteractionSubintentResponseItem.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionPreAuthorizationResponseItems, into buf: inout [UInt8]) {
        FfiConverterTypeWalletToDappInteractionSubintentResponseItem.write(value.response, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionPreAuthorizationResponseItems {
    return try FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems_lower(_ value: WalletToDappInteractionPreAuthorizationResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.lower(value)
}

/**
 * A response with the list of proofs of ownership for `Accounts`/`Personas`
 * and the challenge that was signed.
 */
public struct WalletToDappInteractionProofOfOwnershipRequestResponseItem {
    public var challenge: DappToWalletInteractionAuthChallengeNonce
    public var proofs: [WalletToDappInteractionProofOfOwnership]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(challenge: DappToWalletInteractionAuthChallengeNonce, proofs: [WalletToDappInteractionProofOfOwnership]) {
        self.challenge = challenge
        self.proofs = proofs
    }
}

extension WalletToDappInteractionProofOfOwnershipRequestResponseItem: Sendable {}
extension WalletToDappInteractionProofOfOwnershipRequestResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionProofOfOwnershipRequestResponseItem, rhs: WalletToDappInteractionProofOfOwnershipRequestResponseItem) -> Bool {
        if lhs.challenge != rhs.challenge {
            return false
        }
        if lhs.proofs != rhs.proofs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(challenge)
        hasher.combine(proofs)
    }
}

public struct FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionProofOfOwnershipRequestResponseItem {
        return
            try WalletToDappInteractionProofOfOwnershipRequestResponseItem(
                challenge: FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf),
                proofs: FfiConverterSequenceTypeWalletToDappInteractionProofOfOwnership.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionProofOfOwnershipRequestResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value.challenge, into: &buf)
        FfiConverterSequenceTypeWalletToDappInteractionProofOfOwnership.write(value.proofs, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionProofOfOwnershipRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem_lower(_ value: WalletToDappInteractionProofOfOwnershipRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.lower(value)
}

public struct WalletToDappInteractionSendTransactionResponseItem {
    public var transactionIntentHash: TransactionIntentHash

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transactionIntentHash: TransactionIntentHash) {
        self.transactionIntentHash = transactionIntentHash
    }
}

extension WalletToDappInteractionSendTransactionResponseItem: Sendable {}
extension WalletToDappInteractionSendTransactionResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionSendTransactionResponseItem, rhs: WalletToDappInteractionSendTransactionResponseItem) -> Bool {
        if lhs.transactionIntentHash != rhs.transactionIntentHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transactionIntentHash)
    }
}

public struct FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSendTransactionResponseItem {
        return
            try WalletToDappInteractionSendTransactionResponseItem(
                transactionIntentHash: FfiConverterTypeTransactionIntentHash.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionSendTransactionResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionIntentHash.write(value.transactionIntentHash, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSendTransactionResponseItem {
    return try FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem_lower(_ value: WalletToDappInteractionSendTransactionResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.lower(value)
}

public struct WalletToDappInteractionSubintentResponseItem {
    /**
     * A signed subintent
     */
    public var signedSubintent: SignedSubintent
    /**
     * The timestamp at which the subintent expires
     */
    public var expirationTimestamp: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * A signed subintent
         */ signedSubintent: SignedSubintent,
        /**
            * The timestamp at which the subintent expires
            */ expirationTimestamp: Timestamp
    ) {
        self.signedSubintent = signedSubintent
        self.expirationTimestamp = expirationTimestamp
    }
}

extension WalletToDappInteractionSubintentResponseItem: Sendable {}
extension WalletToDappInteractionSubintentResponseItem: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionSubintentResponseItem, rhs: WalletToDappInteractionSubintentResponseItem) -> Bool {
        if lhs.signedSubintent != rhs.signedSubintent {
            return false
        }
        if lhs.expirationTimestamp != rhs.expirationTimestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signedSubintent)
        hasher.combine(expirationTimestamp)
    }
}

public struct FfiConverterTypeWalletToDappInteractionSubintentResponseItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSubintentResponseItem {
        return
            try WalletToDappInteractionSubintentResponseItem(
                signedSubintent: FfiConverterTypeSignedSubintent.read(from: &buf),
                expirationTimestamp: FfiConverterTypeTimestamp.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionSubintentResponseItem, into buf: inout [UInt8]) {
        FfiConverterTypeSignedSubintent.write(value.signedSubintent, into: &buf)
        FfiConverterTypeTimestamp.write(value.expirationTimestamp, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionSubintentResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSubintentResponseItem {
    return try FfiConverterTypeWalletToDappInteractionSubintentResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionSubintentResponseItem_lower(_ value: WalletToDappInteractionSubintentResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionSubintentResponseItem.lower(value)
}

public struct WalletToDappInteractionSuccessResponse {
    public var interactionId: WalletInteractionId
    public var items: WalletToDappInteractionResponseItems

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(interactionId: WalletInteractionId, items: WalletToDappInteractionResponseItems) {
        self.interactionId = interactionId
        self.items = items
    }
}

extension WalletToDappInteractionSuccessResponse: Sendable {}
extension WalletToDappInteractionSuccessResponse: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionSuccessResponse, rhs: WalletToDappInteractionSuccessResponse) -> Bool {
        if lhs.interactionId != rhs.interactionId {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(interactionId)
        hasher.combine(items)
    }
}

public struct FfiConverterTypeWalletToDappInteractionSuccessResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionSuccessResponse {
        return
            try WalletToDappInteractionSuccessResponse(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf),
                items: FfiConverterTypeWalletToDappInteractionResponseItems.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionSuccessResponse, into buf: inout [UInt8]) {
        FfiConverterTypeWalletInteractionId.write(value.interactionId, into: &buf)
        FfiConverterTypeWalletToDappInteractionResponseItems.write(value.items, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionSuccessResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionSuccessResponse {
    return try FfiConverterTypeWalletToDappInteractionSuccessResponse.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionSuccessResponse_lower(_ value: WalletToDappInteractionSuccessResponse) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionSuccessResponse.lower(value)
}

public struct WalletToDappInteractionTransactionResponseItems {
    public var send: WalletToDappInteractionSendTransactionResponseItem

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(send: WalletToDappInteractionSendTransactionResponseItem) {
        self.send = send
    }
}

extension WalletToDappInteractionTransactionResponseItems: Sendable {}
extension WalletToDappInteractionTransactionResponseItems: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionTransactionResponseItems, rhs: WalletToDappInteractionTransactionResponseItems) -> Bool {
        if lhs.send != rhs.send {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(send)
    }
}

public struct FfiConverterTypeWalletToDappInteractionTransactionResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionTransactionResponseItems {
        return
            try WalletToDappInteractionTransactionResponseItems(
                send: FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionTransactionResponseItems, into buf: inout [UInt8]) {
        FfiConverterTypeWalletToDappInteractionSendTransactionResponseItem.write(value.send, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionTransactionResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionTransactionResponseItems {
    return try FfiConverterTypeWalletToDappInteractionTransactionResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionTransactionResponseItems_lower(_ value: WalletToDappInteractionTransactionResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionTransactionResponseItems.lower(value)
}

public struct WalletToDappInteractionUnauthorizedRequestResponseItems {
    public var oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?
    public var oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(oneTimeAccounts: WalletToDappInteractionAccountsRequestResponseItem?, oneTimePersonaData: WalletToDappInteractionPersonaDataRequestResponseItem?) {
        self.oneTimeAccounts = oneTimeAccounts
        self.oneTimePersonaData = oneTimePersonaData
    }
}

extension WalletToDappInteractionUnauthorizedRequestResponseItems: Sendable {}
extension WalletToDappInteractionUnauthorizedRequestResponseItems: Equatable, Hashable {
    public static func == (lhs: WalletToDappInteractionUnauthorizedRequestResponseItems, rhs: WalletToDappInteractionUnauthorizedRequestResponseItems) -> Bool {
        if lhs.oneTimeAccounts != rhs.oneTimeAccounts {
            return false
        }
        if lhs.oneTimePersonaData != rhs.oneTimePersonaData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(oneTimeAccounts)
        hasher.combine(oneTimePersonaData)
    }
}

public struct FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionUnauthorizedRequestResponseItems {
        return
            try WalletToDappInteractionUnauthorizedRequestResponseItems(
                oneTimeAccounts: FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf),
                oneTimePersonaData: FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf)
            )
    }

    public static func write(_ value: WalletToDappInteractionUnauthorizedRequestResponseItems, into buf: inout [UInt8]) {
        FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem.write(value.oneTimeAccounts, into: &buf)
        FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value.oneTimePersonaData, into: &buf)
    }
}

public func FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionUnauthorizedRequestResponseItems {
    return try FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems_lower(_ value: WalletToDappInteractionUnauthorizedRequestResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A claimable resource in an account locker.
 */

public enum AccountLockerClaimableResource {
    /**
     * A fungible resource with a specific claimable amount
     */
    case fungible(resourceAddress: ResourceAddress, amount: Decimal192)
    /**
     * A non_fungible resource with the total number of items that can be claimed
     */
    case nonFungible(resourceAddress: ResourceAddress, numberOfItems: UInt64)
}

public struct FfiConverterTypeAccountLockerClaimableResource: FfiConverterRustBuffer {
    typealias SwiftType = AccountLockerClaimableResource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountLockerClaimableResource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .fungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), amount: FfiConverterTypeDecimal192.read(from: &buf))

        case 2: return try .nonFungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), numberOfItems: FfiConverterUInt64.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountLockerClaimableResource, into buf: inout [UInt8]) {
        switch value {
        case let .fungible(resourceAddress, amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal192.write(amount, into: &buf)

        case let .nonFungible(resourceAddress, numberOfItems):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterUInt64.write(numberOfItems, into: &buf)
        }
    }
}

public func FfiConverterTypeAccountLockerClaimableResource_lift(_ buf: RustBuffer) throws -> AccountLockerClaimableResource {
    return try FfiConverterTypeAccountLockerClaimableResource.lift(buf)
}

public func FfiConverterTypeAccountLockerClaimableResource_lower(_ value: AccountLockerClaimableResource) -> RustBuffer {
    return FfiConverterTypeAccountLockerClaimableResource.lower(value)
}

extension AccountLockerClaimableResource: Sendable {}
extension AccountLockerClaimableResource: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AccountOrAddressOf {
    case profileAccount(value: Account
    )
    case addressOfExternalAccount(value: AccountAddress
    )
}

public struct FfiConverterTypeAccountOrAddressOf: FfiConverterRustBuffer {
    typealias SwiftType = AccountOrAddressOf

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountOrAddressOf {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .profileAccount(value: FfiConverterTypeAccount.read(from: &buf)
            )

        case 2: return try .addressOfExternalAccount(value: FfiConverterTypeAccountAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountOrAddressOf, into buf: inout [UInt8]) {
        switch value {
        case let .profileAccount(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccount.write(value, into: &buf)

        case let .addressOfExternalAccount(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountAddress.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeAccountOrAddressOf_lift(_ buf: RustBuffer) throws -> AccountOrAddressOf {
    return try FfiConverterTypeAccountOrAddressOf.lift(buf)
}

public func FfiConverterTypeAccountOrAddressOf_lower(_ value: AccountOrAddressOf) -> RustBuffer {
    return FfiConverterTypeAccountOrAddressOf.lower(value)
}

extension AccountOrAddressOf: Sendable {}
extension AccountOrAddressOf: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either an `Account` or a `Persona`.
 */

public enum AccountOrPersona {
    /**
     * An `Account`
     *
     * Note:
     * This case/variant can not be named `account`/ `Account` due
     * to Kotlin UniFFI limitation.
     */
    case accountEntity(Account
    )
    /**
     * A `Persona`
     *
     * Note:
     * This is named `personaEntity` / `PersonaEntity` to match
     * `accountEntity` / `AccountEntity` which can not be named
     * `account`/ `Account` due to Kotlin UniFFI limitation.
     */
    case personaEntity(Persona
    )
}

public struct FfiConverterTypeAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = AccountOrPersona

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountOrPersona {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .accountEntity(FfiConverterTypeAccount.read(from: &buf)
            )

        case 2: return try .personaEntity(FfiConverterTypePersona.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountOrPersona, into buf: inout [UInt8]) {
        switch value {
        case let .accountEntity(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccount.write(v1, into: &buf)

        case let .personaEntity(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypePersona.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeAccountOrPersona_lift(_ buf: RustBuffer) throws -> AccountOrPersona {
    return try FfiConverterTypeAccountOrPersona.lift(buf)
}

public func FfiConverterTypeAccountOrPersona_lower(_ value: AccountOrPersona) -> RustBuffer {
    return FfiConverterTypeAccountOrPersona.lower(value)
}

extension AccountOrPersona: Sendable {}
extension AccountOrPersona: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents a withdrawal from an account, either by amount or by specific IDs.
 */

public enum AccountWithdraw {
    /**
     * Withdraw a specific amount from the account.
     */
    case amount(resourceAddress: ResourceAddress, amount: Decimal192)
    /**
     * Withdraw specific IDs from the account.
     */
    case ids(resourceAddress: ResourceAddress, ids: [NonFungibleLocalId])
}

public struct FfiConverterTypeAccountWithdraw: FfiConverterRustBuffer {
    typealias SwiftType = AccountWithdraw

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountWithdraw {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .amount(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), amount: FfiConverterTypeDecimal192.read(from: &buf))

        case 2: return try .ids(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountWithdraw, into buf: inout [UInt8]) {
        switch value {
        case let .amount(resourceAddress, amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal192.write(amount, into: &buf)

        case let .ids(resourceAddress, ids):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
        }
    }
}

public func FfiConverterTypeAccountWithdraw_lift(_ buf: RustBuffer) throws -> AccountWithdraw {
    return try FfiConverterTypeAccountWithdraw.lift(buf)
}

public func FfiConverterTypeAccountWithdraw_lower(_ value: AccountWithdraw) -> RustBuffer {
    return FfiConverterTypeAccountWithdraw.lower(value)
}

extension AccountWithdraw: Sendable {}
extension AccountWithdraw: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of addresses.
 *
 * Does not include `LegacyOlympiaAccountAddress` nor `NonFungibleResourceAddress`
 */

public enum Address {
    case accessController(AccessControllerAddress
    )
    case account(AccountAddress
    )
    case component(ComponentAddress
    )
    case identity(IdentityAddress
    )
    case package(PackageAddress
    )
    case pool(PoolAddress
    )
    case resource(ResourceAddress
    )
    case validator(ValidatorAddress
    )
    case vault(VaultAddress
    )
    case locker(LockerAddress
    )
}

public struct FfiConverterTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = Address

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .accessController(FfiConverterTypeAccessControllerAddress.read(from: &buf)
            )

        case 2: return try .account(FfiConverterTypeAccountAddress.read(from: &buf)
            )

        case 3: return try .component(FfiConverterTypeComponentAddress.read(from: &buf)
            )

        case 4: return try .identity(FfiConverterTypeIdentityAddress.read(from: &buf)
            )

        case 5: return try .package(FfiConverterTypePackageAddress.read(from: &buf)
            )

        case 6: return try .pool(FfiConverterTypePoolAddress.read(from: &buf)
            )

        case 7: return try .resource(FfiConverterTypeResourceAddress.read(from: &buf)
            )

        case 8: return try .validator(FfiConverterTypeValidatorAddress.read(from: &buf)
            )

        case 9: return try .vault(FfiConverterTypeVaultAddress.read(from: &buf)
            )

        case 10: return try .locker(FfiConverterTypeLockerAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        switch value {
        case let .accessController(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccessControllerAddress.write(v1, into: &buf)

        case let .account(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAccountAddress.write(v1, into: &buf)

        case let .component(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeComponentAddress.write(v1, into: &buf)

        case let .identity(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeIdentityAddress.write(v1, into: &buf)

        case let .package(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypePackageAddress.write(v1, into: &buf)

        case let .pool(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypePoolAddress.write(v1, into: &buf)

        case let .resource(v1):
            writeInt(&buf, Int32(7))
            FfiConverterTypeResourceAddress.write(v1, into: &buf)

        case let .validator(v1):
            writeInt(&buf, Int32(8))
            FfiConverterTypeValidatorAddress.write(v1, into: &buf)

        case let .vault(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeVaultAddress.write(v1, into: &buf)

        case let .locker(v1):
            writeInt(&buf, Int32(10))
            FfiConverterTypeLockerAddress.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeAddress_lift(_ buf: RustBuffer) throws -> Address {
    return try FfiConverterTypeAddress.lift(buf)
}

public func FfiConverterTypeAddress_lower(_ value: Address) -> RustBuffer {
    return FfiConverterTypeAddress.lower(value)
}

extension Address: Sendable {}
extension Address: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AddressFormat {
    case full
    case raw
    case `default`
}

public struct FfiConverterTypeAddressFormat: FfiConverterRustBuffer {
    typealias SwiftType = AddressFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .full

        case 2: return .raw

        case 3: return .default

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressFormat, into buf: inout [UInt8]) {
        switch value {
        case .full:
            writeInt(&buf, Int32(1))

        case .raw:
            writeInt(&buf, Int32(2))

        case .default:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeAddressFormat_lift(_ buf: RustBuffer) throws -> AddressFormat {
    return try FfiConverterTypeAddressFormat.lift(buf)
}

public func FfiConverterTypeAddressFormat_lower(_ value: AddressFormat) -> RustBuffer {
    return FfiConverterTypeAddressFormat.lower(value)
}

extension AddressFormat: Sendable {}
extension AddressFormat: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of addresses of either an Account or a Persona (IdentityAddress)
 */

public enum AddressOfAccountOrPersona {
    case account(AccountAddress
    )
    case identity(IdentityAddress
    )
}

public struct FfiConverterTypeAddressOfAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = AddressOfAccountOrPersona

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddressOfAccountOrPersona {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .account(FfiConverterTypeAccountAddress.read(from: &buf)
            )

        case 2: return try .identity(FfiConverterTypeIdentityAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AddressOfAccountOrPersona, into buf: inout [UInt8]) {
        switch value {
        case let .account(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountAddress.write(v1, into: &buf)

        case let .identity(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeIdentityAddress.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeAddressOfAccountOrPersona_lift(_ buf: RustBuffer) throws -> AddressOfAccountOrPersona {
    return try FfiConverterTypeAddressOfAccountOrPersona.lift(buf)
}

public func FfiConverterTypeAddressOfAccountOrPersona_lower(_ value: AddressOfAccountOrPersona) -> RustBuffer {
    return FfiConverterTypeAddressOfAccountOrPersona.lower(value)
}

extension AddressOfAccountOrPersona: Sendable {}
extension AddressOfAccountOrPersona: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The model of a Arculus Card.
 */

public enum ArculusCardModel {
    /**
     * Arculus card model: "Arculus® Cold Storage Wallet",
     * for more info [see][link].
     *
     * [link]: https://www.getarculus.com/products/arculus-cold-storage-wallet.html
     */
    case arculusColdStorageWallet
}

public struct FfiConverterTypeArculusCardModel: FfiConverterRustBuffer {
    typealias SwiftType = ArculusCardModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ArculusCardModel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .arculusColdStorageWallet

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ArculusCardModel, into buf: inout [UInt8]) {
        switch value {
        case .arculusColdStorageWallet:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeArculusCardModel_lift(_ buf: RustBuffer) throws -> ArculusCardModel {
    return try FfiConverterTypeArculusCardModel.lift(buf)
}

public func FfiConverterTypeArculusCardModel_lower(_ value: ArculusCardModel) -> RustBuffer {
    return FfiConverterTypeArculusCardModel.lower(value)
}

extension ArculusCardModel: Sendable {}
extension ArculusCardModel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Indicates whether the Wallet should show direct deposit claims for the given Dapp.
 */

public enum AuthorizedDappPreferenceDeposits {
    case hidden
    case visible
}

public struct FfiConverterTypeAuthorizedDappPreferenceDeposits: FfiConverterRustBuffer {
    typealias SwiftType = AuthorizedDappPreferenceDeposits

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthorizedDappPreferenceDeposits {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .hidden

        case 2: return .visible

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthorizedDappPreferenceDeposits, into buf: inout [UInt8]) {
        switch value {
        case .hidden:
            writeInt(&buf, Int32(1))

        case .visible:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeAuthorizedDappPreferenceDeposits_lift(_ buf: RustBuffer) throws -> AuthorizedDappPreferenceDeposits {
    return try FfiConverterTypeAuthorizedDappPreferenceDeposits.lift(buf)
}

public func FfiConverterTypeAuthorizedDappPreferenceDeposits_lower(_ value: AuthorizedDappPreferenceDeposits) -> RustBuffer {
    return FfiConverterTypeAuthorizedDappPreferenceDeposits.lower(value)
}

extension AuthorizedDappPreferenceDeposits: Sendable {}
extension AuthorizedDappPreferenceDeposits: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * BIP39 entropy, ranging from 16-32 bytes with discrete values being multiples of in between the range.
 */

public enum Bip39Entropy {
    case entropyOf16Bytes(Entropy16Bytes
    )
    case entropyOf20Bytes(Entropy20Bytes
    )
    case entropyOf24Bytes(Entropy24Bytes
    )
    case entropyOf28Bytes(Entropy28Bytes
    )
    case entropyOf32Bytes(Entropy32Bytes
    )
}

public struct FfiConverterTypeBIP39Entropy: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Entropy

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Entropy {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .entropyOf16Bytes(FfiConverterTypeEntropy16Bytes.read(from: &buf)
            )

        case 2: return try .entropyOf20Bytes(FfiConverterTypeEntropy20Bytes.read(from: &buf)
            )

        case 3: return try .entropyOf24Bytes(FfiConverterTypeEntropy24Bytes.read(from: &buf)
            )

        case 4: return try .entropyOf28Bytes(FfiConverterTypeEntropy28Bytes.read(from: &buf)
            )

        case 5: return try .entropyOf32Bytes(FfiConverterTypeEntropy32Bytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Entropy, into buf: inout [UInt8]) {
        switch value {
        case let .entropyOf16Bytes(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEntropy16Bytes.write(v1, into: &buf)

        case let .entropyOf20Bytes(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEntropy20Bytes.write(v1, into: &buf)

        case let .entropyOf24Bytes(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEntropy24Bytes.write(v1, into: &buf)

        case let .entropyOf28Bytes(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeEntropy28Bytes.write(v1, into: &buf)

        case let .entropyOf32Bytes(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEntropy32Bytes.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeBIP39Entropy_lift(_ buf: RustBuffer) throws -> Bip39Entropy {
    return try FfiConverterTypeBIP39Entropy.lift(buf)
}

public func FfiConverterTypeBIP39Entropy_lower(_ value: Bip39Entropy) -> RustBuffer {
    return FfiConverterTypeBIP39Entropy.lower(value)
}

extension Bip39Entropy: Sendable {}
extension Bip39Entropy: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Language to be used for the mnemonic phrase.
 *
 * The English language is always available, other languages are enabled using
 * the compilation features.
 */

public enum Bip39Language {
    /**
     * The English language.
     */
    case english
    /**
     * The French language.
     */
    case french
}

public struct FfiConverterTypeBIP39Language: FfiConverterRustBuffer {
    typealias SwiftType = Bip39Language

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Language {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .english

        case 2: return .french

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39Language, into buf: inout [UInt8]) {
        switch value {
        case .english:
            writeInt(&buf, Int32(1))

        case .french:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeBIP39Language_lift(_ buf: RustBuffer) throws -> Bip39Language {
    return try FfiConverterTypeBIP39Language.lift(buf)
}

public func FfiConverterTypeBIP39Language_lower(_ value: Bip39Language) -> RustBuffer {
    return FfiConverterTypeBIP39Language.lower(value)
}

extension Bip39Language: Sendable {}
extension Bip39Language: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The number of words in the mnemonic of a DeviceFactorSource, according to the BIP39
 * standard, a multiple of 3, from 12 to 24 words. All "Babylon" `DeviceFactorSource`s
 * use 24 words.
 */

public enum Bip39WordCount: UInt8 {
    /**
     * 24 words, used by all "Babylon" `DeviceFactorSource`s
     */
    case twentyFour = 24
    /**
     * 21 words, potentially used by third-party Olympia wallets.
     */
    case twentyOne = 21
    /**
     * 18 words, potentially used by third-party Olympia wallets.
     */
    case eighteen = 18
    /**
     * 15 words, potentially used by third-party Olympia wallets.
     */
    case fifteen = 15
    /**
     * 12 words, used by Radix Olympia legacy wallet.
     */
    case twelve = 12
}

public struct FfiConverterTypeBIP39WordCount: FfiConverterRustBuffer {
    typealias SwiftType = Bip39WordCount

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39WordCount {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .twentyFour

        case 2: return .twentyOne

        case 3: return .eighteen

        case 4: return .fifteen

        case 5: return .twelve

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Bip39WordCount, into buf: inout [UInt8]) {
        switch value {
        case .twentyFour:
            writeInt(&buf, Int32(1))

        case .twentyOne:
            writeInt(&buf, Int32(2))

        case .eighteen:
            writeInt(&buf, Int32(3))

        case .fifteen:
            writeInt(&buf, Int32(4))

        case .twelve:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeBIP39WordCount_lift(_ buf: RustBuffer) throws -> Bip39WordCount {
    return try FfiConverterTypeBIP39WordCount.lift(buf)
}

public func FfiConverterTypeBIP39WordCount_lower(_ value: Bip39WordCount) -> RustBuffer {
    return FfiConverterTypeBIP39WordCount.lower(value)
}

extension Bip39WordCount: Sendable {}
extension Bip39WordCount: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Account or Identity (used by Personas) part of a CAP26 derivation
 * path.
 */

public enum Cap26EntityKind {
    /**
     * An Account entity type
     */
    case account
    /**
     * An Identity entity type (used by Personas)
     */
    case identity
}

public struct FfiConverterTypeCAP26EntityKind: FfiConverterRustBuffer {
    typealias SwiftType = Cap26EntityKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26EntityKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .account

        case 2: return .identity

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26EntityKind, into buf: inout [UInt8]) {
        switch value {
        case .account:
            writeInt(&buf, Int32(1))

        case .identity:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeCAP26EntityKind_lift(_ buf: RustBuffer) throws -> Cap26EntityKind {
    return try FfiConverterTypeCAP26EntityKind.lift(buf)
}

public func FfiConverterTypeCAP26EntityKind_lower(_ value: Cap26EntityKind) -> RustBuffer {
    return FfiConverterTypeCAP26EntityKind.lower(value)
}

extension Cap26EntityKind: Sendable {}
extension Cap26EntityKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Cap26KeyKind {
    /**
     * For a key to be used for signing transactions.
     * The value is the ascii sum of `"TRANSACTION_SIGNING"`
     */
    case transactionSigning
    /**
     * For a key to be used for signing authentication..
     * The value is the ascii sum of `"AUTHENTICATION_SIGNING"`
     */
    case authenticationSigning
    /**
     * For a key to be used for encrypting messages.
     * The value is the ascii sum of `"MESSAGE_ENCRYPTION"`
     */
    case messageEncryption
}

public struct FfiConverterTypeCAP26KeyKind: FfiConverterRustBuffer {
    typealias SwiftType = Cap26KeyKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cap26KeyKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .transactionSigning

        case 2: return .authenticationSigning

        case 3: return .messageEncryption

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Cap26KeyKind, into buf: inout [UInt8]) {
        switch value {
        case .transactionSigning:
            writeInt(&buf, Int32(1))

        case .authenticationSigning:
            writeInt(&buf, Int32(2))

        case .messageEncryption:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeCAP26KeyKind_lift(_ buf: RustBuffer) throws -> Cap26KeyKind {
    return try FfiConverterTypeCAP26KeyKind.lift(buf)
}

public func FfiConverterTypeCAP26KeyKind_lower(_ value: Cap26KeyKind) -> RustBuffer {
    return FfiConverterTypeCAP26KeyKind.lower(value)
}

extension Cap26KeyKind: Sendable {}
extension Cap26KeyKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ChangeGatewayOutcome {
    /**
     * If we did in fact change the gateway, and if the gateway was unknown
     * or known before it was added, i.e. `is_new` will be true iff the gateway
     * was unknown before changing to it.
     */
    case didChange(
        /**
         * If the Gateway we just switched to already was in the `other` list of
         * saved gateways in AppPreferences, or if it was entirely new.
         */ isNew: Bool
    )
    /**
     * We tried to change to the current gateway.
     */
    case noChange
}

public struct FfiConverterTypeChangeGatewayOutcome: FfiConverterRustBuffer {
    typealias SwiftType = ChangeGatewayOutcome

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChangeGatewayOutcome {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .didChange(isNew: FfiConverterBool.read(from: &buf)
            )

        case 2: return .noChange

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChangeGatewayOutcome, into buf: inout [UInt8]) {
        switch value {
        case let .didChange(isNew):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(isNew, into: &buf)

        case .noChange:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeChangeGatewayOutcome_lift(_ buf: RustBuffer) throws -> ChangeGatewayOutcome {
    return try FfiConverterTypeChangeGatewayOutcome.lift(buf)
}

public func FfiConverterTypeChangeGatewayOutcome_lower(_ value: ChangeGatewayOutcome) -> RustBuffer {
    return FfiConverterTypeChangeGatewayOutcome.lower(value)
}

extension ChangeGatewayOutcome: Sendable {}
extension ChangeGatewayOutcome: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Created by the visitor, generally references a particular instruction,
 * or maybe an initial YIELD_TO_PARENT.
 */

public enum ChangeSource {
    case initialYieldFromParent
    case invocation(instructionIndex: UInt64
    )
    case newBucket(instructionIndex: UInt64
    )
    case assertion(instructionIndex: UInt64
    )
}

public struct FfiConverterTypeChangeSource: FfiConverterRustBuffer {
    typealias SwiftType = ChangeSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChangeSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .initialYieldFromParent

        case 2: return try .invocation(instructionIndex: FfiConverterUInt64.read(from: &buf)
            )

        case 3: return try .newBucket(instructionIndex: FfiConverterUInt64.read(from: &buf)
            )

        case 4: return try .assertion(instructionIndex: FfiConverterUInt64.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChangeSource, into buf: inout [UInt8]) {
        switch value {
        case .initialYieldFromParent:
            writeInt(&buf, Int32(1))

        case let .invocation(instructionIndex):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(instructionIndex, into: &buf)

        case let .newBucket(instructionIndex):
            writeInt(&buf, Int32(3))
            FfiConverterUInt64.write(instructionIndex, into: &buf)

        case let .assertion(instructionIndex):
            writeInt(&buf, Int32(4))
            FfiConverterUInt64.write(instructionIndex, into: &buf)
        }
    }
}

public func FfiConverterTypeChangeSource_lift(_ buf: RustBuffer) throws -> ChangeSource {
    return try FfiConverterTypeChangeSource.lift(buf)
}

public func FfiConverterTypeChangeSource_lower(_ value: ChangeSource) -> RustBuffer {
    return FfiConverterTypeChangeSource.lower(value)
}

extension ChangeSource: Sendable {}
extension ChangeSource: Equatable, Hashable {}

public enum CommonError {
    case Unknown
    case InvalidEd25519PrivateKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidEd25519PrivateKeyFromString(badValue: String
    )
    case InvalidSecp256k1PrivateKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidSecp256k1PrivateKeyFromString(badValue: String
    )
    case InvalidEd25519PublicKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidEd25519PublicKeyFromString(badValue: String
    )
    case InvalidSecp256k1PublicKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidSecp256k1PublicKeyFromString(badValue: String
    )
    case InvalidSecp256k1PublicKeyPointNotOnCurve
    case InvalidEd25519PublicKeyPointNotOnCurve
    case StringNotHex(badValue: String
    )
    case InvalidByteCount(expected: UInt64, found: UInt64)
    case InvalidBip32Path(badValue: String
    )
    case InvalidDepthOfBip44Path(expected: UInt64, found: UInt64)
    case InvalidBip44LikePathAccountWasNotHardened
    case InvalidBip44LikePathChangeWasUnexpectedlyHardened
    case InvalidDepthOfCap26Path(expected: UInt64, found: UInt64)
    case NotAllComponentsAreHardened
    case Bip44PurposeNotFound(badValue: UInt32
    )
    case CoinTypeNotFound(badValue: UInt32
    )
    case InvalidNetworkIdExceedsLimit(badValue: UInt32
    )
    case InvalidEntityKind(badValue: UInt32
    )
    case WrongEntityKind(expected: Cap26EntityKind, found: Cap26EntityKind)
    case InvalidKeyKind(badValue: UInt32
    )
    case UnsupportedNetworkId(badValue: UInt8
    )
    case InvalidGetIdPath(badValue: UInt32
    )
    case UnknownBip39Word
    case InvalidMnemonicPhrase
    case InvalidBip39WordCount(badValue: UInt64
    )
    case InvalidAppearanceId(badValue: UInt8
    )
    case InvalidAccountAddress(badValue: String
    )
    case UnsupportedEntityType
    case FailedToDecodeAddressFromBech32(badValue: String
    )
    case MismatchingEntityTypeWhileDecodingAddress
    case MismatchingHrpWhileDecodingAddress
    case UnknownNetworkId(badValue: UInt8
    )
    case InvalidNonFungibleGlobalId(badValue: String
    )
    case FactorSourceCryptoParametersSupportedCurvesInvalidSize
    case BadgeIsNotVirtualHierarchicalDeterministic
    case FactorSourceIdNotFromHash
    case ExpectedAccountPathButGotSomethingElse
    case WrongEntityKindOfInFactorInstancesPath
    case WrongKeyKindOfTransactionSigningFactorInstance
    case WrongKeyKindOfAuthenticationSigningFactorInstance
    case ExpectedDeviceFactorSourceGotSomethingElse
    case ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse
    case UnknownNetworkWithName(badValue: String
    )
    case UnknownNetworkForId(badValue: UInt8
    )
    case GatewaysDiscrepancyOtherShouldNotContainCurrent
    case InvalidGatewaysJsonCurrentNotFoundAmongstSaved
    case InvalidUrl(badValue: String
    )
    case AccountOnWrongNetwork(expected: NetworkId, found: NetworkId)
    case FactorSourcesMustNotBeEmpty
    case UpdateFactorSourceMutateFailed
    case CastFactorSourceWrongKind(expected: FactorSourceKind, found: FactorSourceKind)
    case InvalidLength(expected: UInt64, found: UInt64, data: BagOfBytes)
    case InvalidNonFungibleLocalIdString
    case InvalidNonFungibleLocalIdBytes
    case DecimalError
    case InvalidBip39Index(badValue: UInt16
    )
    case InvalidDisplayNameEmpty
    case SecureStorageAccessError(key: SecureStorageKey, errorKind: SecureStorageAccessErrorKind, errorMessage: String)
    case InvalidIso8601String(badValue: String
    )
    case UnknownAccount
    case SecureStorageReadError
    case UnableToLoadDeviceFactorSourceFromSecureStorage
    case SecureStorageWriteError
    case FailedToSerializeToJson
    case FailedToDeserializeJsonToValue(jsonByteCount: UInt64, typeName: String, serdeMessage: String)
    case InvalidProfileId(badValue: String
    )
    case FailedToLoadProfileHeadersList
    case ProfileDoesNotContainFactorSourceWithId(badValue: FactorSourceId
    )
    case AccountAlreadyPresent(badValue: AccountAddress
    )
    case UnableToAcquireWriteLockForProfile
    case UnableToSaveMnemonicToSecureStorage(badValue: FactorSourceIdFromHash
    )
    case UnableToLoadMnemonicFromSecureStorage(badValue: FactorSourceIdFromHash
    )
    case UnableToSaveFactorSourceToProfile(badValue: FactorSourceId
    )
    case ExpectedIdentityPathButGotSomethingElse
    case PersonaDataInvalidPhoneNumberEmpty
    case EmailAddressEmpty
    case PersonaDataInvalidNameFamilyNameEmpty
    case PersonaDataInvalidNameGivenNamesEmpty
    case InvalidUuiDv4(badValue: String
    )
    case UnrecognizedLocaleIdentifier(badValue: String
    )
    case FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(nodeIdAsHex: String, networkId: NetworkId)
    case InvalidOlympiaAddressString(badValue: String
    )
    case InvalidInstructionsString(underlying: String
    )
    case ExecutionSummaryFail(underlying: String
    )
    case FailedToDecodeEngineToolkitReceipt
    case BytesEmpty
    case TooManyBytes(max: UInt64, found: UInt64)
    case InvalidInstructionsWrongNetwork(foundInInstructions: NetworkId, specifiedToInstructionsCtor: NetworkId)
    case FailedToDecodeBytesToManifestInstructions
    case FailedToDecodeTransactionHash(badValue: String
    )
    case FailedToHashIntent
    case EncryptedMessagesAreNotYetSupported
    case FailedToBech32DecodeTransactionHashAfterHavingTestedAllNetworkId(badValue: String
    )
    case FailedToParseSignatureFromString(badValue: String
    )
    case InvalidSignaturesForIntentSomeDidNotValidateIntentHash
    case FailedToDecompileBytesIntoNotarizedTransaction
    case FailedToRecoverSecp256k1PublicKeyFromSignature
    case FungibleResourceAddressNotAcceptedInNonFungibleContext
    case DecimalOverflow(badValue: String
    )
    case InvalidAddressNotOlympiaMainnet(badValue: String
    )
    case FailedToParseSignatureFromBytes(badValue: String
    )
    case InvalidIntentFailedToEncode(underlying: String
    )
    case InvalidInstructionsFailedToDecompile(underlying: String
    )
    case InvalidTransactionMaxSborDepthExceeded(max: UInt16
    )
    case InvalidSignedIntentFailedToEncode(underlying: String
    )
    case InvalidNotarizedIntentFailedToEncode(underlying: String
    )
    case NetworkResponseBadCode(code: UInt16
    )
    case NetworkResponseEmptyBody
    case NetworkResponseJsonDeserialize(intoType: String
    )
    case NetworkRequestInvalidUrl(badValue: String
    )
    case NetworkRequestGenericFailure(underlying: String
    )
    case GatewaySubmitDuplicateTx(intentHash: String
    )
    case SupportedCurvesMustNotBeEmpty
    case ProfileNetworksMustNotBeEmpty
    case UnknownSlip10Curve(badValue: String
    )
    case AesDecryptionFailed
    case InvalidAesBytesTooShort(expectedAtLeast: UInt64, found: UInt64)
    case InvalidFactorSourceKind(badValue: String
    )
    case InvalidLedgerHardwareWalletModel(badValue: String
    )
    case RadixConnectMobileInvalidRequestUrl(badValue: String
    )
    case RadixConnectMobileInvalidOrigin(badValue: String
    )
    case RadixConnectMobileInvalidSessionId(badValue: String
    )
    case RadixMobileInvalidInteractionId(badValue: String
    )
    case NetworkDiscrepancy(expected: NetworkId, actual: NetworkId)
    case DiscrepancyAuthorizedDappReferencedPersonaWhichDoesNotExist(address: IdentityAddress
    )
    case DiscrepancyAuthorizedDappReferencedAccountWhichDoesNotExist(address: AccountAddress
    )
    case AuthorizedDappReferencesFieldIdThatDoesNotExist
    case ElementDoesNotExist(id: String
    )
    case IdentifiableItemAlreadyExist(id: String
    )
    case InvalidRadixConnectPurpose(badValue: String
    )
    case TxGuaranteeIndexOutOfBounds(index: UInt64, count: UInt64)
    case InvalidKeyAgreementPublicKeyFromHex(badValue: String
    )
    case InvalidKeyAgreementPublicKeyFromBytes(badValue: BagOfBytes
    )
    case InvalidKeyAgreementPrivateKeyFromBytes(badValue: BagOfBytes
    )
    case RadixConnectMobileSessionNotFound(sessionId: SessionId
    )
    case RadixConnectMobileDappRequestNotFound(interactionId: WalletInteractionId
    )
    case RadixConnectMobileDappCallbackPathNotFound(origin: Url
    )
    case InvalidEd25519SignatureFromString(badValue: String
    )
    case RadixConnectMobileDappPublicKeyMismatch
    case RadixConnectMobileDappIdentityMismatch
    case RadixConnectMobileDappOriginMismatch
    case RadixConnectMobileInvalidDappSignature
    case RadixConnectMobileInvalidRequestFormat
    case RadixConnectMobileFailedToCreateNewSession
    case DeferredDeepLinkInvalidValueFormat(badValue: String
    )
    case FailedUpdatingHomeCards
    case EntityNotFound
    case HomeCardsNotFound
    case FailedSavingHomeCards
    case UnableToLoadProfileFromSecureStorage(profileId: ProfileId
    )
    case UnableToSaveHostIdToSecureStorage
    case UnableToAcquireReadLockForProfile
    case UnsafeStorageReadError
    case UnsafeStorageWriteError
    case FailedToCreateFilePathFromString(badValue: String
    )
    case ExpectedNonEmptyCollection
    case UnableToAddAllEntitiesDuplicatesFound
    case ProfileUsedOnOtherDevice(otherDeviceId: DeviceId, thisDeviceId: DeviceId)
    case InvalidDeviceId(badValue: String
    )
    case TriedToUpdateProfileWithOneWithDifferentId
    case InvalidPath(badValue: String
    )
    case FailedToSaveFile(path: String
    )
    case FailedToLoadFile(path: String
    )
    case FailedToDeleteFile(path: String
    )
    case NotPermissionToAccessFile(path: String
    )
    case InvalidArculusCardModel(badValue: String
    )
    case ExpectedArculusCardFactorSourceGotSomethingElse
    case FailedToDeriveKeyAfterMaxAttempts
    case FailedToDecryptSealedMnemonic
    case AnswersToSecurityQuestionsCannotBeEmpty
    case IntegrityViolationMutationOfFactorSourceIsNotAllowedToMutateItsId
    case InvalidSecurityStructureId(badValue: String
    )
    case StructureReferencesUnknownFactorSource(badValue: String
    )
    case InvalidQuestionsAndAnswersCount(expected: UInt16, found: UInt16)
    case ProfileStateNotLoaded(currentState: String
    )
    case FailedToCreateAddressFromGlobalAddressAndNetworkId(globalAddressAsHex: String, networkId: NetworkId)
    case EntitiesNotDerivedByFactorSource
    case NoNetworkInProfile(networkId: NetworkId
    )
    case FactorSourcesOfKindEmptyFactors
    case ExpectedPassphraseFactorSourceGotSomethingElse
    case UnknownPersona
    case InvalidSecurityStructureThresholdExceedsFactors(threshold: UInt8, factors: UInt8)
    case InvalidSecurityStructureFactorInBothThresholdAndOverride
    case OneOfReceivingAccountsDoesNotAllowDeposits
    case FailedTransactionPreview(errorMessage: String
    )
    case FailedToExtractTransactionReceiptBytes
    case ReservedInstructionsNotAllowedInManifest(reservedInstructions: String
    )
    case FailedToDecompileBytesIntoTransactionIntent
    case InvalidManifestFailedToDecompile(underlying: String
    )
    case InvalidSignedPartialTransactionFailedToCompile
    case InvalidSignedPartialTransactionFailedToDecompile
    case InvalidSignedPartialTransactionFailedToEncode(underlying: String
    )
    case FailedToGenerateManifestSummary(underlying: String
    )
    case IndexSecurifiedExpectedUnsecurified
    case IndexUnsecurifiedExpectedSecurified
    case IndexInGlobalKeySpaceIsLowerThanOffset
    case IndexOverflow
    case CannotAddMoreToIndexSinceItWouldChangeKeySpace
    case IndexNotHardened(badValue: UInt32
    )
    case FailedToDecompileBytesIntoSubintent
    case SubintentExpired
    case FreeToUse
    case MaxTransfersPerTransactionReached(amount: UInt64
    )
    case ReservedManifestClass(class: DetailedManifestClassKind
    )
    case FactorInstancesProviderDidNotDeriveEnoughFactors
    case CacheAlreadyContainsFactorInstance(derivationPath: String
    )
    case ExpectedPersonaButGotAccount(address: String
    )
    case AccountNotSecurified(address: String
    )
    case PersonaNotSecurified(address: String
    )
    case EntityOnWrongNetwork(entityKind: String, wrongNetwork: NetworkId, expectedNetwork: NetworkId)
    case SecurityStateNotSecurified
    case SecurityStateSecurifiedButExpectedUnsecurified
    case UnableToAddAllPersonasDuplicatesFound
    case MissingFactorMappingInstancesIntoRole
    case FactorSourceDiscrepancy
    case ExpectedAccountButGotPersona(address: String
    )
    case InvalidFactorSourceIdFromHashStringWrongComponentCount(expected: UInt64, found: UInt64)
    case FileAlreadyExists(path: String
    )
    case FailedToCanonicalize(path: String
    )
    case FactorInstancesDiscrepancy(addressOfEntity1: String, addressOfEntity2: String, factorSourceId: String)
    case UnableToAddAllAccountsDuplicatesFound
    case InvalidIndexAgnosticPathWrongLength
    case InvalidIndexAgnosticPathDoesNotEndWithSuffix
    case FailedToEncodeTransactionPreviewV2(underlying: String
    )
}

public struct FfiConverterTypeCommonError: FfiConverterRustBuffer {
    typealias SwiftType = CommonError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CommonError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .Unknown
        case 2: return try .InvalidEd25519PrivateKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 3: return try .InvalidEd25519PrivateKeyFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 4: return try .InvalidSecp256k1PrivateKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 5: return try .InvalidSecp256k1PrivateKeyFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 6: return try .InvalidEd25519PublicKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 7: return try .InvalidEd25519PublicKeyFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 8: return try .InvalidSecp256k1PublicKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 9: return try .InvalidSecp256k1PublicKeyFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 10: return .InvalidSecp256k1PublicKeyPointNotOnCurve
        case 11: return .InvalidEd25519PublicKeyPointNotOnCurve
        case 12: return try .StringNotHex(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 13: return try .InvalidByteCount(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 14: return try .InvalidBip32Path(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 15: return try .InvalidDepthOfBip44Path(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 16: return .InvalidBip44LikePathAccountWasNotHardened
        case 17: return .InvalidBip44LikePathChangeWasUnexpectedlyHardened
        case 18: return try .InvalidDepthOfCap26Path(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 19: return .NotAllComponentsAreHardened
        case 20: return try .Bip44PurposeNotFound(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 21: return try .CoinTypeNotFound(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 22: return try .InvalidNetworkIdExceedsLimit(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 23: return try .InvalidEntityKind(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 24: return try .WrongEntityKind(
                expected: FfiConverterTypeCAP26EntityKind.read(from: &buf),
                found: FfiConverterTypeCAP26EntityKind.read(from: &buf)
            )
        case 25: return try .InvalidKeyKind(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 26: return try .UnsupportedNetworkId(
                badValue: FfiConverterUInt8.read(from: &buf)
            )
        case 27: return try .InvalidGetIdPath(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 28: return .UnknownBip39Word
        case 29: return .InvalidMnemonicPhrase
        case 30: return try .InvalidBip39WordCount(
                badValue: FfiConverterUInt64.read(from: &buf)
            )
        case 31: return try .InvalidAppearanceId(
                badValue: FfiConverterUInt8.read(from: &buf)
            )
        case 32: return try .InvalidAccountAddress(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 33: return .UnsupportedEntityType
        case 34: return try .FailedToDecodeAddressFromBech32(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 35: return .MismatchingEntityTypeWhileDecodingAddress
        case 36: return .MismatchingHrpWhileDecodingAddress
        case 37: return try .UnknownNetworkId(
                badValue: FfiConverterUInt8.read(from: &buf)
            )
        case 38: return try .InvalidNonFungibleGlobalId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 39: return .FactorSourceCryptoParametersSupportedCurvesInvalidSize
        case 40: return .BadgeIsNotVirtualHierarchicalDeterministic
        case 41: return .FactorSourceIdNotFromHash
        case 42: return .ExpectedAccountPathButGotSomethingElse
        case 43: return .WrongEntityKindOfInFactorInstancesPath
        case 44: return .WrongKeyKindOfTransactionSigningFactorInstance
        case 45: return .WrongKeyKindOfAuthenticationSigningFactorInstance
        case 46: return .ExpectedDeviceFactorSourceGotSomethingElse
        case 47: return .ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse
        case 48: return try .UnknownNetworkWithName(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 49: return try .UnknownNetworkForId(
                badValue: FfiConverterUInt8.read(from: &buf)
            )
        case 50: return .GatewaysDiscrepancyOtherShouldNotContainCurrent
        case 51: return .InvalidGatewaysJsonCurrentNotFoundAmongstSaved
        case 52: return try .InvalidUrl(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 53: return try .AccountOnWrongNetwork(
                expected: FfiConverterTypeNetworkID.read(from: &buf),
                found: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 54: return .FactorSourcesMustNotBeEmpty
        case 55: return .UpdateFactorSourceMutateFailed
        case 56: return try .CastFactorSourceWrongKind(
                expected: FfiConverterTypeFactorSourceKind.read(from: &buf),
                found: FfiConverterTypeFactorSourceKind.read(from: &buf)
            )
        case 57: return try .InvalidLength(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf),
                data: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 58: return .InvalidNonFungibleLocalIdString
        case 59: return .InvalidNonFungibleLocalIdBytes
        case 60: return .DecimalError
        case 61: return try .InvalidBip39Index(
                badValue: FfiConverterUInt16.read(from: &buf)
            )
        case 62: return .InvalidDisplayNameEmpty
        case 63: return try .SecureStorageAccessError(
                key: FfiConverterTypeSecureStorageKey.read(from: &buf),
                errorKind: FfiConverterTypeSecureStorageAccessErrorKind.read(from: &buf),
                errorMessage: FfiConverterString.read(from: &buf)
            )
        case 64: return try .InvalidIso8601String(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 65: return .UnknownAccount
        case 66: return .SecureStorageReadError
        case 67: return .UnableToLoadDeviceFactorSourceFromSecureStorage
        case 68: return .SecureStorageWriteError
        case 69: return .FailedToSerializeToJson
        case 70: return try .FailedToDeserializeJsonToValue(
                jsonByteCount: FfiConverterUInt64.read(from: &buf),
                typeName: FfiConverterString.read(from: &buf),
                serdeMessage: FfiConverterString.read(from: &buf)
            )
        case 71: return try .InvalidProfileId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 72: return .FailedToLoadProfileHeadersList
        case 73: return try .ProfileDoesNotContainFactorSourceWithId(
                badValue: FfiConverterTypeFactorSourceID.read(from: &buf)
            )
        case 74: return try .AccountAlreadyPresent(
                badValue: FfiConverterTypeAccountAddress.read(from: &buf)
            )
        case 75: return .UnableToAcquireWriteLockForProfile
        case 76: return try .UnableToSaveMnemonicToSecureStorage(
                badValue: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )
        case 77: return try .UnableToLoadMnemonicFromSecureStorage(
                badValue: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )
        case 78: return try .UnableToSaveFactorSourceToProfile(
                badValue: FfiConverterTypeFactorSourceID.read(from: &buf)
            )
        case 79: return .ExpectedIdentityPathButGotSomethingElse
        case 80: return .PersonaDataInvalidPhoneNumberEmpty
        case 81: return .EmailAddressEmpty
        case 82: return .PersonaDataInvalidNameFamilyNameEmpty
        case 83: return .PersonaDataInvalidNameGivenNamesEmpty
        case 84: return try .InvalidUuiDv4(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 85: return try .UnrecognizedLocaleIdentifier(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 86: return try .FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(
                nodeIdAsHex: FfiConverterString.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 87: return try .InvalidOlympiaAddressString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 88: return try .InvalidInstructionsString(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 89: return try .ExecutionSummaryFail(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 90: return .FailedToDecodeEngineToolkitReceipt
        case 91: return .BytesEmpty
        case 92: return try .TooManyBytes(
                max: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 93: return try .InvalidInstructionsWrongNetwork(
                foundInInstructions: FfiConverterTypeNetworkID.read(from: &buf),
                specifiedToInstructionsCtor: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 94: return .FailedToDecodeBytesToManifestInstructions
        case 95: return try .FailedToDecodeTransactionHash(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 96: return .FailedToHashIntent
        case 97: return .EncryptedMessagesAreNotYetSupported
        case 98: return try .FailedToBech32DecodeTransactionHashAfterHavingTestedAllNetworkId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 99: return try .FailedToParseSignatureFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 100: return .InvalidSignaturesForIntentSomeDidNotValidateIntentHash
        case 101: return .FailedToDecompileBytesIntoNotarizedTransaction
        case 102: return .FailedToRecoverSecp256k1PublicKeyFromSignature
        case 103: return .FungibleResourceAddressNotAcceptedInNonFungibleContext
        case 104: return try .DecimalOverflow(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 105: return try .InvalidAddressNotOlympiaMainnet(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 106: return try .FailedToParseSignatureFromBytes(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 107: return try .InvalidIntentFailedToEncode(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 108: return try .InvalidInstructionsFailedToDecompile(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 109: return try .InvalidTransactionMaxSborDepthExceeded(
                max: FfiConverterUInt16.read(from: &buf)
            )
        case 110: return try .InvalidSignedIntentFailedToEncode(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 111: return try .InvalidNotarizedIntentFailedToEncode(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 112: return try .NetworkResponseBadCode(
                code: FfiConverterUInt16.read(from: &buf)
            )
        case 113: return .NetworkResponseEmptyBody
        case 114: return try .NetworkResponseJsonDeserialize(
                intoType: FfiConverterString.read(from: &buf)
            )
        case 115: return try .NetworkRequestInvalidUrl(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 116: return try .NetworkRequestGenericFailure(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 117: return try .GatewaySubmitDuplicateTx(
                intentHash: FfiConverterString.read(from: &buf)
            )
        case 118: return .SupportedCurvesMustNotBeEmpty
        case 119: return .ProfileNetworksMustNotBeEmpty
        case 120: return try .UnknownSlip10Curve(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 121: return .AesDecryptionFailed
        case 122: return try .InvalidAesBytesTooShort(
                expectedAtLeast: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 123: return try .InvalidFactorSourceKind(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 124: return try .InvalidLedgerHardwareWalletModel(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 125: return try .RadixConnectMobileInvalidRequestUrl(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 126: return try .RadixConnectMobileInvalidOrigin(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 127: return try .RadixConnectMobileInvalidSessionId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 128: return try .RadixMobileInvalidInteractionId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 129: return try .NetworkDiscrepancy(
                expected: FfiConverterTypeNetworkID.read(from: &buf),
                actual: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 130: return try .DiscrepancyAuthorizedDappReferencedPersonaWhichDoesNotExist(
                address: FfiConverterTypeIdentityAddress.read(from: &buf)
            )
        case 131: return try .DiscrepancyAuthorizedDappReferencedAccountWhichDoesNotExist(
                address: FfiConverterTypeAccountAddress.read(from: &buf)
            )
        case 132: return .AuthorizedDappReferencesFieldIdThatDoesNotExist
        case 133: return try .ElementDoesNotExist(
                id: FfiConverterString.read(from: &buf)
            )
        case 134: return try .IdentifiableItemAlreadyExist(
                id: FfiConverterString.read(from: &buf)
            )
        case 135: return try .InvalidRadixConnectPurpose(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 136: return try .TxGuaranteeIndexOutOfBounds(
                index: FfiConverterUInt64.read(from: &buf),
                count: FfiConverterUInt64.read(from: &buf)
            )
        case 137: return try .InvalidKeyAgreementPublicKeyFromHex(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 138: return try .InvalidKeyAgreementPublicKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 139: return try .InvalidKeyAgreementPrivateKeyFromBytes(
                badValue: FfiConverterTypeBagOfBytes.read(from: &buf)
            )
        case 140: return try .RadixConnectMobileSessionNotFound(
                sessionId: FfiConverterTypeSessionID.read(from: &buf)
            )
        case 141: return try .RadixConnectMobileDappRequestNotFound(
                interactionId: FfiConverterTypeWalletInteractionId.read(from: &buf)
            )
        case 142: return try .RadixConnectMobileDappCallbackPathNotFound(
                origin: FfiConverterTypeUrl.read(from: &buf)
            )
        case 143: return try .InvalidEd25519SignatureFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 144: return .RadixConnectMobileDappPublicKeyMismatch
        case 145: return .RadixConnectMobileDappIdentityMismatch
        case 146: return .RadixConnectMobileDappOriginMismatch
        case 147: return .RadixConnectMobileInvalidDappSignature
        case 148: return .RadixConnectMobileInvalidRequestFormat
        case 149: return .RadixConnectMobileFailedToCreateNewSession
        case 150: return try .DeferredDeepLinkInvalidValueFormat(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 151: return .FailedUpdatingHomeCards
        case 152: return .EntityNotFound
        case 153: return .HomeCardsNotFound
        case 154: return .FailedSavingHomeCards
        case 155: return try .UnableToLoadProfileFromSecureStorage(
                profileId: FfiConverterTypeProfileID.read(from: &buf)
            )
        case 156: return .UnableToSaveHostIdToSecureStorage
        case 157: return .UnableToAcquireReadLockForProfile
        case 158: return .UnsafeStorageReadError
        case 159: return .UnsafeStorageWriteError
        case 160: return try .FailedToCreateFilePathFromString(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 161: return .ExpectedNonEmptyCollection
        case 162: return .UnableToAddAllEntitiesDuplicatesFound
        case 163: return try .ProfileUsedOnOtherDevice(
                otherDeviceId: FfiConverterTypeDeviceID.read(from: &buf),
                thisDeviceId: FfiConverterTypeDeviceID.read(from: &buf)
            )
        case 164: return try .InvalidDeviceId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 165: return .TriedToUpdateProfileWithOneWithDifferentId
        case 166: return try .InvalidPath(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 167: return try .FailedToSaveFile(
                path: FfiConverterString.read(from: &buf)
            )
        case 168: return try .FailedToLoadFile(
                path: FfiConverterString.read(from: &buf)
            )
        case 169: return try .FailedToDeleteFile(
                path: FfiConverterString.read(from: &buf)
            )
        case 170: return try .NotPermissionToAccessFile(
                path: FfiConverterString.read(from: &buf)
            )
        case 171: return try .InvalidArculusCardModel(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 172: return .ExpectedArculusCardFactorSourceGotSomethingElse
        case 173: return .FailedToDeriveKeyAfterMaxAttempts
        case 174: return .FailedToDecryptSealedMnemonic
        case 175: return .AnswersToSecurityQuestionsCannotBeEmpty
        case 176: return .IntegrityViolationMutationOfFactorSourceIsNotAllowedToMutateItsId
        case 177: return try .InvalidSecurityStructureId(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 178: return try .StructureReferencesUnknownFactorSource(
                badValue: FfiConverterString.read(from: &buf)
            )
        case 179: return try .InvalidQuestionsAndAnswersCount(
                expected: FfiConverterUInt16.read(from: &buf),
                found: FfiConverterUInt16.read(from: &buf)
            )
        case 180: return try .ProfileStateNotLoaded(
                currentState: FfiConverterString.read(from: &buf)
            )
        case 181: return try .FailedToCreateAddressFromGlobalAddressAndNetworkId(
                globalAddressAsHex: FfiConverterString.read(from: &buf),
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 182: return .EntitiesNotDerivedByFactorSource
        case 183: return try .NoNetworkInProfile(
                networkId: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 184: return .FactorSourcesOfKindEmptyFactors
        case 185: return .ExpectedPassphraseFactorSourceGotSomethingElse
        case 186: return .UnknownPersona
        case 187: return try .InvalidSecurityStructureThresholdExceedsFactors(
                threshold: FfiConverterUInt8.read(from: &buf),
                factors: FfiConverterUInt8.read(from: &buf)
            )
        case 188: return .InvalidSecurityStructureFactorInBothThresholdAndOverride
        case 189: return .OneOfReceivingAccountsDoesNotAllowDeposits
        case 190: return try .FailedTransactionPreview(
                errorMessage: FfiConverterString.read(from: &buf)
            )
        case 191: return .FailedToExtractTransactionReceiptBytes
        case 192: return try .ReservedInstructionsNotAllowedInManifest(
                reservedInstructions: FfiConverterString.read(from: &buf)
            )
        case 193: return .FailedToDecompileBytesIntoTransactionIntent
        case 194: return try .InvalidManifestFailedToDecompile(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 195: return .InvalidSignedPartialTransactionFailedToCompile
        case 196: return .InvalidSignedPartialTransactionFailedToDecompile
        case 197: return try .InvalidSignedPartialTransactionFailedToEncode(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 198: return try .FailedToGenerateManifestSummary(
                underlying: FfiConverterString.read(from: &buf)
            )
        case 199: return .IndexSecurifiedExpectedUnsecurified
        case 200: return .IndexUnsecurifiedExpectedSecurified
        case 201: return .IndexInGlobalKeySpaceIsLowerThanOffset
        case 202: return .IndexOverflow
        case 203: return .CannotAddMoreToIndexSinceItWouldChangeKeySpace
        case 204: return try .IndexNotHardened(
                badValue: FfiConverterUInt32.read(from: &buf)
            )
        case 205: return .FailedToDecompileBytesIntoSubintent
        case 206: return .SubintentExpired
        case 207: return .FreeToUse
        case 208: return try .MaxTransfersPerTransactionReached(
                amount: FfiConverterUInt64.read(from: &buf)
            )
        case 209: return try .ReservedManifestClass(
                class: FfiConverterTypeDetailedManifestClassKind.read(from: &buf)
            )
        case 210: return .FactorInstancesProviderDidNotDeriveEnoughFactors
        case 211: return try .CacheAlreadyContainsFactorInstance(
                derivationPath: FfiConverterString.read(from: &buf)
            )
        case 212: return try .ExpectedPersonaButGotAccount(
                address: FfiConverterString.read(from: &buf)
            )
        case 213: return try .AccountNotSecurified(
                address: FfiConverterString.read(from: &buf)
            )
        case 214: return try .PersonaNotSecurified(
                address: FfiConverterString.read(from: &buf)
            )
        case 215: return try .EntityOnWrongNetwork(
                entityKind: FfiConverterString.read(from: &buf),
                wrongNetwork: FfiConverterTypeNetworkID.read(from: &buf),
                expectedNetwork: FfiConverterTypeNetworkID.read(from: &buf)
            )
        case 216: return .SecurityStateNotSecurified
        case 217: return .SecurityStateSecurifiedButExpectedUnsecurified
        case 218: return .UnableToAddAllPersonasDuplicatesFound
        case 219: return .MissingFactorMappingInstancesIntoRole
        case 220: return .FactorSourceDiscrepancy
        case 221: return try .ExpectedAccountButGotPersona(
                address: FfiConverterString.read(from: &buf)
            )
        case 222: return try .InvalidFactorSourceIdFromHashStringWrongComponentCount(
                expected: FfiConverterUInt64.read(from: &buf),
                found: FfiConverterUInt64.read(from: &buf)
            )
        case 223: return try .FileAlreadyExists(
                path: FfiConverterString.read(from: &buf)
            )
        case 224: return try .FailedToCanonicalize(
                path: FfiConverterString.read(from: &buf)
            )
        case 225: return try .FactorInstancesDiscrepancy(
                addressOfEntity1: FfiConverterString.read(from: &buf),
                addressOfEntity2: FfiConverterString.read(from: &buf),
                factorSourceId: FfiConverterString.read(from: &buf)
            )
        case 226: return .UnableToAddAllAccountsDuplicatesFound
        case 227: return .InvalidIndexAgnosticPathWrongLength
        case 228: return .InvalidIndexAgnosticPathDoesNotEndWithSuffix
        case 229: return try .FailedToEncodeTransactionPreviewV2(
                underlying: FfiConverterString.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CommonError, into buf: inout [UInt8]) {
        switch value {
        case .Unknown:
            writeInt(&buf, Int32(1))

        case let .InvalidEd25519PrivateKeyFromBytes(badValue):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidEd25519PrivateKeyFromString(badValue):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidSecp256k1PrivateKeyFromBytes(badValue):
            writeInt(&buf, Int32(4))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidSecp256k1PrivateKeyFromString(badValue):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidEd25519PublicKeyFromBytes(badValue):
            writeInt(&buf, Int32(6))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidEd25519PublicKeyFromString(badValue):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidSecp256k1PublicKeyFromBytes(badValue):
            writeInt(&buf, Int32(8))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidSecp256k1PublicKeyFromString(badValue):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(badValue, into: &buf)

        case .InvalidSecp256k1PublicKeyPointNotOnCurve:
            writeInt(&buf, Int32(10))

        case .InvalidEd25519PublicKeyPointNotOnCurve:
            writeInt(&buf, Int32(11))

        case let .StringNotHex(badValue):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidByteCount(expected, found):
            writeInt(&buf, Int32(13))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case let .InvalidBip32Path(badValue):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidDepthOfBip44Path(expected, found):
            writeInt(&buf, Int32(15))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case .InvalidBip44LikePathAccountWasNotHardened:
            writeInt(&buf, Int32(16))

        case .InvalidBip44LikePathChangeWasUnexpectedlyHardened:
            writeInt(&buf, Int32(17))

        case let .InvalidDepthOfCap26Path(expected, found):
            writeInt(&buf, Int32(18))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case .NotAllComponentsAreHardened:
            writeInt(&buf, Int32(19))

        case let .Bip44PurposeNotFound(badValue):
            writeInt(&buf, Int32(20))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .CoinTypeNotFound(badValue):
            writeInt(&buf, Int32(21))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .InvalidNetworkIdExceedsLimit(badValue):
            writeInt(&buf, Int32(22))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .InvalidEntityKind(badValue):
            writeInt(&buf, Int32(23))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .WrongEntityKind(expected, found):
            writeInt(&buf, Int32(24))
            FfiConverterTypeCAP26EntityKind.write(expected, into: &buf)
            FfiConverterTypeCAP26EntityKind.write(found, into: &buf)

        case let .InvalidKeyKind(badValue):
            writeInt(&buf, Int32(25))
            FfiConverterUInt32.write(badValue, into: &buf)

        case let .UnsupportedNetworkId(badValue):
            writeInt(&buf, Int32(26))
            FfiConverterUInt8.write(badValue, into: &buf)

        case let .InvalidGetIdPath(badValue):
            writeInt(&buf, Int32(27))
            FfiConverterUInt32.write(badValue, into: &buf)

        case .UnknownBip39Word:
            writeInt(&buf, Int32(28))

        case .InvalidMnemonicPhrase:
            writeInt(&buf, Int32(29))

        case let .InvalidBip39WordCount(badValue):
            writeInt(&buf, Int32(30))
            FfiConverterUInt64.write(badValue, into: &buf)

        case let .InvalidAppearanceId(badValue):
            writeInt(&buf, Int32(31))
            FfiConverterUInt8.write(badValue, into: &buf)

        case let .InvalidAccountAddress(badValue):
            writeInt(&buf, Int32(32))
            FfiConverterString.write(badValue, into: &buf)

        case .UnsupportedEntityType:
            writeInt(&buf, Int32(33))

        case let .FailedToDecodeAddressFromBech32(badValue):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(badValue, into: &buf)

        case .MismatchingEntityTypeWhileDecodingAddress:
            writeInt(&buf, Int32(35))

        case .MismatchingHrpWhileDecodingAddress:
            writeInt(&buf, Int32(36))

        case let .UnknownNetworkId(badValue):
            writeInt(&buf, Int32(37))
            FfiConverterUInt8.write(badValue, into: &buf)

        case let .InvalidNonFungibleGlobalId(badValue):
            writeInt(&buf, Int32(38))
            FfiConverterString.write(badValue, into: &buf)

        case .FactorSourceCryptoParametersSupportedCurvesInvalidSize:
            writeInt(&buf, Int32(39))

        case .BadgeIsNotVirtualHierarchicalDeterministic:
            writeInt(&buf, Int32(40))

        case .FactorSourceIdNotFromHash:
            writeInt(&buf, Int32(41))

        case .ExpectedAccountPathButGotSomethingElse:
            writeInt(&buf, Int32(42))

        case .WrongEntityKindOfInFactorInstancesPath:
            writeInt(&buf, Int32(43))

        case .WrongKeyKindOfTransactionSigningFactorInstance:
            writeInt(&buf, Int32(44))

        case .WrongKeyKindOfAuthenticationSigningFactorInstance:
            writeInt(&buf, Int32(45))

        case .ExpectedDeviceFactorSourceGotSomethingElse:
            writeInt(&buf, Int32(46))

        case .ExpectedLedgerHardwareWalletFactorSourceGotSomethingElse:
            writeInt(&buf, Int32(47))

        case let .UnknownNetworkWithName(badValue):
            writeInt(&buf, Int32(48))
            FfiConverterString.write(badValue, into: &buf)

        case let .UnknownNetworkForId(badValue):
            writeInt(&buf, Int32(49))
            FfiConverterUInt8.write(badValue, into: &buf)

        case .GatewaysDiscrepancyOtherShouldNotContainCurrent:
            writeInt(&buf, Int32(50))

        case .InvalidGatewaysJsonCurrentNotFoundAmongstSaved:
            writeInt(&buf, Int32(51))

        case let .InvalidUrl(badValue):
            writeInt(&buf, Int32(52))
            FfiConverterString.write(badValue, into: &buf)

        case let .AccountOnWrongNetwork(expected, found):
            writeInt(&buf, Int32(53))
            FfiConverterTypeNetworkID.write(expected, into: &buf)
            FfiConverterTypeNetworkID.write(found, into: &buf)

        case .FactorSourcesMustNotBeEmpty:
            writeInt(&buf, Int32(54))

        case .UpdateFactorSourceMutateFailed:
            writeInt(&buf, Int32(55))

        case let .CastFactorSourceWrongKind(expected, found):
            writeInt(&buf, Int32(56))
            FfiConverterTypeFactorSourceKind.write(expected, into: &buf)
            FfiConverterTypeFactorSourceKind.write(found, into: &buf)

        case let .InvalidLength(expected, found, data):
            writeInt(&buf, Int32(57))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)
            FfiConverterTypeBagOfBytes.write(data, into: &buf)

        case .InvalidNonFungibleLocalIdString:
            writeInt(&buf, Int32(58))

        case .InvalidNonFungibleLocalIdBytes:
            writeInt(&buf, Int32(59))

        case .DecimalError:
            writeInt(&buf, Int32(60))

        case let .InvalidBip39Index(badValue):
            writeInt(&buf, Int32(61))
            FfiConverterUInt16.write(badValue, into: &buf)

        case .InvalidDisplayNameEmpty:
            writeInt(&buf, Int32(62))

        case let .SecureStorageAccessError(key, errorKind, errorMessage):
            writeInt(&buf, Int32(63))
            FfiConverterTypeSecureStorageKey.write(key, into: &buf)
            FfiConverterTypeSecureStorageAccessErrorKind.write(errorKind, into: &buf)
            FfiConverterString.write(errorMessage, into: &buf)

        case let .InvalidIso8601String(badValue):
            writeInt(&buf, Int32(64))
            FfiConverterString.write(badValue, into: &buf)

        case .UnknownAccount:
            writeInt(&buf, Int32(65))

        case .SecureStorageReadError:
            writeInt(&buf, Int32(66))

        case .UnableToLoadDeviceFactorSourceFromSecureStorage:
            writeInt(&buf, Int32(67))

        case .SecureStorageWriteError:
            writeInt(&buf, Int32(68))

        case .FailedToSerializeToJson:
            writeInt(&buf, Int32(69))

        case let .FailedToDeserializeJsonToValue(jsonByteCount, typeName, serdeMessage):
            writeInt(&buf, Int32(70))
            FfiConverterUInt64.write(jsonByteCount, into: &buf)
            FfiConverterString.write(typeName, into: &buf)
            FfiConverterString.write(serdeMessage, into: &buf)

        case let .InvalidProfileId(badValue):
            writeInt(&buf, Int32(71))
            FfiConverterString.write(badValue, into: &buf)

        case .FailedToLoadProfileHeadersList:
            writeInt(&buf, Int32(72))

        case let .ProfileDoesNotContainFactorSourceWithId(badValue):
            writeInt(&buf, Int32(73))
            FfiConverterTypeFactorSourceID.write(badValue, into: &buf)

        case let .AccountAlreadyPresent(badValue):
            writeInt(&buf, Int32(74))
            FfiConverterTypeAccountAddress.write(badValue, into: &buf)

        case .UnableToAcquireWriteLockForProfile:
            writeInt(&buf, Int32(75))

        case let .UnableToSaveMnemonicToSecureStorage(badValue):
            writeInt(&buf, Int32(76))
            FfiConverterTypeFactorSourceIDFromHash.write(badValue, into: &buf)

        case let .UnableToLoadMnemonicFromSecureStorage(badValue):
            writeInt(&buf, Int32(77))
            FfiConverterTypeFactorSourceIDFromHash.write(badValue, into: &buf)

        case let .UnableToSaveFactorSourceToProfile(badValue):
            writeInt(&buf, Int32(78))
            FfiConverterTypeFactorSourceID.write(badValue, into: &buf)

        case .ExpectedIdentityPathButGotSomethingElse:
            writeInt(&buf, Int32(79))

        case .PersonaDataInvalidPhoneNumberEmpty:
            writeInt(&buf, Int32(80))

        case .EmailAddressEmpty:
            writeInt(&buf, Int32(81))

        case .PersonaDataInvalidNameFamilyNameEmpty:
            writeInt(&buf, Int32(82))

        case .PersonaDataInvalidNameGivenNamesEmpty:
            writeInt(&buf, Int32(83))

        case let .InvalidUuiDv4(badValue):
            writeInt(&buf, Int32(84))
            FfiConverterString.write(badValue, into: &buf)

        case let .UnrecognizedLocaleIdentifier(badValue):
            writeInt(&buf, Int32(85))
            FfiConverterString.write(badValue, into: &buf)

        case let .FailedToCreateAddressViaRetAddressFromNodeIdAndNetworkId(nodeIdAsHex, networkId):
            writeInt(&buf, Int32(86))
            FfiConverterString.write(nodeIdAsHex, into: &buf)
            FfiConverterTypeNetworkID.write(networkId, into: &buf)

        case let .InvalidOlympiaAddressString(badValue):
            writeInt(&buf, Int32(87))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidInstructionsString(underlying):
            writeInt(&buf, Int32(88))
            FfiConverterString.write(underlying, into: &buf)

        case let .ExecutionSummaryFail(underlying):
            writeInt(&buf, Int32(89))
            FfiConverterString.write(underlying, into: &buf)

        case .FailedToDecodeEngineToolkitReceipt:
            writeInt(&buf, Int32(90))

        case .BytesEmpty:
            writeInt(&buf, Int32(91))

        case let .TooManyBytes(max, found):
            writeInt(&buf, Int32(92))
            FfiConverterUInt64.write(max, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case let .InvalidInstructionsWrongNetwork(foundInInstructions, specifiedToInstructionsCtor):
            writeInt(&buf, Int32(93))
            FfiConverterTypeNetworkID.write(foundInInstructions, into: &buf)
            FfiConverterTypeNetworkID.write(specifiedToInstructionsCtor, into: &buf)

        case .FailedToDecodeBytesToManifestInstructions:
            writeInt(&buf, Int32(94))

        case let .FailedToDecodeTransactionHash(badValue):
            writeInt(&buf, Int32(95))
            FfiConverterString.write(badValue, into: &buf)

        case .FailedToHashIntent:
            writeInt(&buf, Int32(96))

        case .EncryptedMessagesAreNotYetSupported:
            writeInt(&buf, Int32(97))

        case let .FailedToBech32DecodeTransactionHashAfterHavingTestedAllNetworkId(badValue):
            writeInt(&buf, Int32(98))
            FfiConverterString.write(badValue, into: &buf)

        case let .FailedToParseSignatureFromString(badValue):
            writeInt(&buf, Int32(99))
            FfiConverterString.write(badValue, into: &buf)

        case .InvalidSignaturesForIntentSomeDidNotValidateIntentHash:
            writeInt(&buf, Int32(100))

        case .FailedToDecompileBytesIntoNotarizedTransaction:
            writeInt(&buf, Int32(101))

        case .FailedToRecoverSecp256k1PublicKeyFromSignature:
            writeInt(&buf, Int32(102))

        case .FungibleResourceAddressNotAcceptedInNonFungibleContext:
            writeInt(&buf, Int32(103))

        case let .DecimalOverflow(badValue):
            writeInt(&buf, Int32(104))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidAddressNotOlympiaMainnet(badValue):
            writeInt(&buf, Int32(105))
            FfiConverterString.write(badValue, into: &buf)

        case let .FailedToParseSignatureFromBytes(badValue):
            writeInt(&buf, Int32(106))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidIntentFailedToEncode(underlying):
            writeInt(&buf, Int32(107))
            FfiConverterString.write(underlying, into: &buf)

        case let .InvalidInstructionsFailedToDecompile(underlying):
            writeInt(&buf, Int32(108))
            FfiConverterString.write(underlying, into: &buf)

        case let .InvalidTransactionMaxSborDepthExceeded(max):
            writeInt(&buf, Int32(109))
            FfiConverterUInt16.write(max, into: &buf)

        case let .InvalidSignedIntentFailedToEncode(underlying):
            writeInt(&buf, Int32(110))
            FfiConverterString.write(underlying, into: &buf)

        case let .InvalidNotarizedIntentFailedToEncode(underlying):
            writeInt(&buf, Int32(111))
            FfiConverterString.write(underlying, into: &buf)

        case let .NetworkResponseBadCode(code):
            writeInt(&buf, Int32(112))
            FfiConverterUInt16.write(code, into: &buf)

        case .NetworkResponseEmptyBody:
            writeInt(&buf, Int32(113))

        case let .NetworkResponseJsonDeserialize(intoType):
            writeInt(&buf, Int32(114))
            FfiConverterString.write(intoType, into: &buf)

        case let .NetworkRequestInvalidUrl(badValue):
            writeInt(&buf, Int32(115))
            FfiConverterString.write(badValue, into: &buf)

        case let .NetworkRequestGenericFailure(underlying):
            writeInt(&buf, Int32(116))
            FfiConverterString.write(underlying, into: &buf)

        case let .GatewaySubmitDuplicateTx(intentHash):
            writeInt(&buf, Int32(117))
            FfiConverterString.write(intentHash, into: &buf)

        case .SupportedCurvesMustNotBeEmpty:
            writeInt(&buf, Int32(118))

        case .ProfileNetworksMustNotBeEmpty:
            writeInt(&buf, Int32(119))

        case let .UnknownSlip10Curve(badValue):
            writeInt(&buf, Int32(120))
            FfiConverterString.write(badValue, into: &buf)

        case .AesDecryptionFailed:
            writeInt(&buf, Int32(121))

        case let .InvalidAesBytesTooShort(expectedAtLeast, found):
            writeInt(&buf, Int32(122))
            FfiConverterUInt64.write(expectedAtLeast, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case let .InvalidFactorSourceKind(badValue):
            writeInt(&buf, Int32(123))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidLedgerHardwareWalletModel(badValue):
            writeInt(&buf, Int32(124))
            FfiConverterString.write(badValue, into: &buf)

        case let .RadixConnectMobileInvalidRequestUrl(badValue):
            writeInt(&buf, Int32(125))
            FfiConverterString.write(badValue, into: &buf)

        case let .RadixConnectMobileInvalidOrigin(badValue):
            writeInt(&buf, Int32(126))
            FfiConverterString.write(badValue, into: &buf)

        case let .RadixConnectMobileInvalidSessionId(badValue):
            writeInt(&buf, Int32(127))
            FfiConverterString.write(badValue, into: &buf)

        case let .RadixMobileInvalidInteractionId(badValue):
            writeInt(&buf, Int32(128))
            FfiConverterString.write(badValue, into: &buf)

        case let .NetworkDiscrepancy(expected, actual):
            writeInt(&buf, Int32(129))
            FfiConverterTypeNetworkID.write(expected, into: &buf)
            FfiConverterTypeNetworkID.write(actual, into: &buf)

        case let .DiscrepancyAuthorizedDappReferencedPersonaWhichDoesNotExist(address):
            writeInt(&buf, Int32(130))
            FfiConverterTypeIdentityAddress.write(address, into: &buf)

        case let .DiscrepancyAuthorizedDappReferencedAccountWhichDoesNotExist(address):
            writeInt(&buf, Int32(131))
            FfiConverterTypeAccountAddress.write(address, into: &buf)

        case .AuthorizedDappReferencesFieldIdThatDoesNotExist:
            writeInt(&buf, Int32(132))

        case let .ElementDoesNotExist(id):
            writeInt(&buf, Int32(133))
            FfiConverterString.write(id, into: &buf)

        case let .IdentifiableItemAlreadyExist(id):
            writeInt(&buf, Int32(134))
            FfiConverterString.write(id, into: &buf)

        case let .InvalidRadixConnectPurpose(badValue):
            writeInt(&buf, Int32(135))
            FfiConverterString.write(badValue, into: &buf)

        case let .TxGuaranteeIndexOutOfBounds(index, count):
            writeInt(&buf, Int32(136))
            FfiConverterUInt64.write(index, into: &buf)
            FfiConverterUInt64.write(count, into: &buf)

        case let .InvalidKeyAgreementPublicKeyFromHex(badValue):
            writeInt(&buf, Int32(137))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidKeyAgreementPublicKeyFromBytes(badValue):
            writeInt(&buf, Int32(138))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .InvalidKeyAgreementPrivateKeyFromBytes(badValue):
            writeInt(&buf, Int32(139))
            FfiConverterTypeBagOfBytes.write(badValue, into: &buf)

        case let .RadixConnectMobileSessionNotFound(sessionId):
            writeInt(&buf, Int32(140))
            FfiConverterTypeSessionID.write(sessionId, into: &buf)

        case let .RadixConnectMobileDappRequestNotFound(interactionId):
            writeInt(&buf, Int32(141))
            FfiConverterTypeWalletInteractionId.write(interactionId, into: &buf)

        case let .RadixConnectMobileDappCallbackPathNotFound(origin):
            writeInt(&buf, Int32(142))
            FfiConverterTypeUrl.write(origin, into: &buf)

        case let .InvalidEd25519SignatureFromString(badValue):
            writeInt(&buf, Int32(143))
            FfiConverterString.write(badValue, into: &buf)

        case .RadixConnectMobileDappPublicKeyMismatch:
            writeInt(&buf, Int32(144))

        case .RadixConnectMobileDappIdentityMismatch:
            writeInt(&buf, Int32(145))

        case .RadixConnectMobileDappOriginMismatch:
            writeInt(&buf, Int32(146))

        case .RadixConnectMobileInvalidDappSignature:
            writeInt(&buf, Int32(147))

        case .RadixConnectMobileInvalidRequestFormat:
            writeInt(&buf, Int32(148))

        case .RadixConnectMobileFailedToCreateNewSession:
            writeInt(&buf, Int32(149))

        case let .DeferredDeepLinkInvalidValueFormat(badValue):
            writeInt(&buf, Int32(150))
            FfiConverterString.write(badValue, into: &buf)

        case .FailedUpdatingHomeCards:
            writeInt(&buf, Int32(151))

        case .EntityNotFound:
            writeInt(&buf, Int32(152))

        case .HomeCardsNotFound:
            writeInt(&buf, Int32(153))

        case .FailedSavingHomeCards:
            writeInt(&buf, Int32(154))

        case let .UnableToLoadProfileFromSecureStorage(profileId):
            writeInt(&buf, Int32(155))
            FfiConverterTypeProfileID.write(profileId, into: &buf)

        case .UnableToSaveHostIdToSecureStorage:
            writeInt(&buf, Int32(156))

        case .UnableToAcquireReadLockForProfile:
            writeInt(&buf, Int32(157))

        case .UnsafeStorageReadError:
            writeInt(&buf, Int32(158))

        case .UnsafeStorageWriteError:
            writeInt(&buf, Int32(159))

        case let .FailedToCreateFilePathFromString(badValue):
            writeInt(&buf, Int32(160))
            FfiConverterString.write(badValue, into: &buf)

        case .ExpectedNonEmptyCollection:
            writeInt(&buf, Int32(161))

        case .UnableToAddAllEntitiesDuplicatesFound:
            writeInt(&buf, Int32(162))

        case let .ProfileUsedOnOtherDevice(otherDeviceId, thisDeviceId):
            writeInt(&buf, Int32(163))
            FfiConverterTypeDeviceID.write(otherDeviceId, into: &buf)
            FfiConverterTypeDeviceID.write(thisDeviceId, into: &buf)

        case let .InvalidDeviceId(badValue):
            writeInt(&buf, Int32(164))
            FfiConverterString.write(badValue, into: &buf)

        case .TriedToUpdateProfileWithOneWithDifferentId:
            writeInt(&buf, Int32(165))

        case let .InvalidPath(badValue):
            writeInt(&buf, Int32(166))
            FfiConverterString.write(badValue, into: &buf)

        case let .FailedToSaveFile(path):
            writeInt(&buf, Int32(167))
            FfiConverterString.write(path, into: &buf)

        case let .FailedToLoadFile(path):
            writeInt(&buf, Int32(168))
            FfiConverterString.write(path, into: &buf)

        case let .FailedToDeleteFile(path):
            writeInt(&buf, Int32(169))
            FfiConverterString.write(path, into: &buf)

        case let .NotPermissionToAccessFile(path):
            writeInt(&buf, Int32(170))
            FfiConverterString.write(path, into: &buf)

        case let .InvalidArculusCardModel(badValue):
            writeInt(&buf, Int32(171))
            FfiConverterString.write(badValue, into: &buf)

        case .ExpectedArculusCardFactorSourceGotSomethingElse:
            writeInt(&buf, Int32(172))

        case .FailedToDeriveKeyAfterMaxAttempts:
            writeInt(&buf, Int32(173))

        case .FailedToDecryptSealedMnemonic:
            writeInt(&buf, Int32(174))

        case .AnswersToSecurityQuestionsCannotBeEmpty:
            writeInt(&buf, Int32(175))

        case .IntegrityViolationMutationOfFactorSourceIsNotAllowedToMutateItsId:
            writeInt(&buf, Int32(176))

        case let .InvalidSecurityStructureId(badValue):
            writeInt(&buf, Int32(177))
            FfiConverterString.write(badValue, into: &buf)

        case let .StructureReferencesUnknownFactorSource(badValue):
            writeInt(&buf, Int32(178))
            FfiConverterString.write(badValue, into: &buf)

        case let .InvalidQuestionsAndAnswersCount(expected, found):
            writeInt(&buf, Int32(179))
            FfiConverterUInt16.write(expected, into: &buf)
            FfiConverterUInt16.write(found, into: &buf)

        case let .ProfileStateNotLoaded(currentState):
            writeInt(&buf, Int32(180))
            FfiConverterString.write(currentState, into: &buf)

        case let .FailedToCreateAddressFromGlobalAddressAndNetworkId(globalAddressAsHex, networkId):
            writeInt(&buf, Int32(181))
            FfiConverterString.write(globalAddressAsHex, into: &buf)
            FfiConverterTypeNetworkID.write(networkId, into: &buf)

        case .EntitiesNotDerivedByFactorSource:
            writeInt(&buf, Int32(182))

        case let .NoNetworkInProfile(networkId):
            writeInt(&buf, Int32(183))
            FfiConverterTypeNetworkID.write(networkId, into: &buf)

        case .FactorSourcesOfKindEmptyFactors:
            writeInt(&buf, Int32(184))

        case .ExpectedPassphraseFactorSourceGotSomethingElse:
            writeInt(&buf, Int32(185))

        case .UnknownPersona:
            writeInt(&buf, Int32(186))

        case let .InvalidSecurityStructureThresholdExceedsFactors(threshold, factors):
            writeInt(&buf, Int32(187))
            FfiConverterUInt8.write(threshold, into: &buf)
            FfiConverterUInt8.write(factors, into: &buf)

        case .InvalidSecurityStructureFactorInBothThresholdAndOverride:
            writeInt(&buf, Int32(188))

        case .OneOfReceivingAccountsDoesNotAllowDeposits:
            writeInt(&buf, Int32(189))

        case let .FailedTransactionPreview(errorMessage):
            writeInt(&buf, Int32(190))
            FfiConverterString.write(errorMessage, into: &buf)

        case .FailedToExtractTransactionReceiptBytes:
            writeInt(&buf, Int32(191))

        case let .ReservedInstructionsNotAllowedInManifest(reservedInstructions):
            writeInt(&buf, Int32(192))
            FfiConverterString.write(reservedInstructions, into: &buf)

        case .FailedToDecompileBytesIntoTransactionIntent:
            writeInt(&buf, Int32(193))

        case let .InvalidManifestFailedToDecompile(underlying):
            writeInt(&buf, Int32(194))
            FfiConverterString.write(underlying, into: &buf)

        case .InvalidSignedPartialTransactionFailedToCompile:
            writeInt(&buf, Int32(195))

        case .InvalidSignedPartialTransactionFailedToDecompile:
            writeInt(&buf, Int32(196))

        case let .InvalidSignedPartialTransactionFailedToEncode(underlying):
            writeInt(&buf, Int32(197))
            FfiConverterString.write(underlying, into: &buf)

        case let .FailedToGenerateManifestSummary(underlying):
            writeInt(&buf, Int32(198))
            FfiConverterString.write(underlying, into: &buf)

        case .IndexSecurifiedExpectedUnsecurified:
            writeInt(&buf, Int32(199))

        case .IndexUnsecurifiedExpectedSecurified:
            writeInt(&buf, Int32(200))

        case .IndexInGlobalKeySpaceIsLowerThanOffset:
            writeInt(&buf, Int32(201))

        case .IndexOverflow:
            writeInt(&buf, Int32(202))

        case .CannotAddMoreToIndexSinceItWouldChangeKeySpace:
            writeInt(&buf, Int32(203))

        case let .IndexNotHardened(badValue):
            writeInt(&buf, Int32(204))
            FfiConverterUInt32.write(badValue, into: &buf)

        case .FailedToDecompileBytesIntoSubintent:
            writeInt(&buf, Int32(205))

        case .SubintentExpired:
            writeInt(&buf, Int32(206))

        case .FreeToUse:
            writeInt(&buf, Int32(207))

        case let .MaxTransfersPerTransactionReached(amount):
            writeInt(&buf, Int32(208))
            FfiConverterUInt64.write(amount, into: &buf)

        case let .ReservedManifestClass(`class`):
            writeInt(&buf, Int32(209))
            FfiConverterTypeDetailedManifestClassKind.write(`class`, into: &buf)

        case .FactorInstancesProviderDidNotDeriveEnoughFactors:
            writeInt(&buf, Int32(210))

        case let .CacheAlreadyContainsFactorInstance(derivationPath):
            writeInt(&buf, Int32(211))
            FfiConverterString.write(derivationPath, into: &buf)

        case let .ExpectedPersonaButGotAccount(address):
            writeInt(&buf, Int32(212))
            FfiConverterString.write(address, into: &buf)

        case let .AccountNotSecurified(address):
            writeInt(&buf, Int32(213))
            FfiConverterString.write(address, into: &buf)

        case let .PersonaNotSecurified(address):
            writeInt(&buf, Int32(214))
            FfiConverterString.write(address, into: &buf)

        case let .EntityOnWrongNetwork(entityKind, wrongNetwork, expectedNetwork):
            writeInt(&buf, Int32(215))
            FfiConverterString.write(entityKind, into: &buf)
            FfiConverterTypeNetworkID.write(wrongNetwork, into: &buf)
            FfiConverterTypeNetworkID.write(expectedNetwork, into: &buf)

        case .SecurityStateNotSecurified:
            writeInt(&buf, Int32(216))

        case .SecurityStateSecurifiedButExpectedUnsecurified:
            writeInt(&buf, Int32(217))

        case .UnableToAddAllPersonasDuplicatesFound:
            writeInt(&buf, Int32(218))

        case .MissingFactorMappingInstancesIntoRole:
            writeInt(&buf, Int32(219))

        case .FactorSourceDiscrepancy:
            writeInt(&buf, Int32(220))

        case let .ExpectedAccountButGotPersona(address):
            writeInt(&buf, Int32(221))
            FfiConverterString.write(address, into: &buf)

        case let .InvalidFactorSourceIdFromHashStringWrongComponentCount(expected, found):
            writeInt(&buf, Int32(222))
            FfiConverterUInt64.write(expected, into: &buf)
            FfiConverterUInt64.write(found, into: &buf)

        case let .FileAlreadyExists(path):
            writeInt(&buf, Int32(223))
            FfiConverterString.write(path, into: &buf)

        case let .FailedToCanonicalize(path):
            writeInt(&buf, Int32(224))
            FfiConverterString.write(path, into: &buf)

        case let .FactorInstancesDiscrepancy(addressOfEntity1, addressOfEntity2, factorSourceId):
            writeInt(&buf, Int32(225))
            FfiConverterString.write(addressOfEntity1, into: &buf)
            FfiConverterString.write(addressOfEntity2, into: &buf)
            FfiConverterString.write(factorSourceId, into: &buf)

        case .UnableToAddAllAccountsDuplicatesFound:
            writeInt(&buf, Int32(226))

        case .InvalidIndexAgnosticPathWrongLength:
            writeInt(&buf, Int32(227))

        case .InvalidIndexAgnosticPathDoesNotEndWithSuffix:
            writeInt(&buf, Int32(228))

        case let .FailedToEncodeTransactionPreviewV2(underlying):
            writeInt(&buf, Int32(229))
            FfiConverterString.write(underlying, into: &buf)
        }
    }
}

extension CommonError: Equatable, Hashable {}

extension CommonError: Swift.Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappToWalletInteractionAuthRequestItem {
    case loginWithChallenge(DappToWalletInteractionAuthLoginWithChallengeRequestItem
    )
    case loginWithoutChallenge
    case usePersona(DappToWalletInteractionAuthUsePersonaRequestItem
    )
}

public struct FfiConverterTypeDappToWalletInteractionAuthRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionAuthRequestItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthRequestItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .loginWithChallenge(FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.read(from: &buf)
            )

        case 2: return .loginWithoutChallenge

        case 3: return try .usePersona(FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappToWalletInteractionAuthRequestItem, into buf: inout [UInt8]) {
        switch value {
        case let .loginWithChallenge(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDappToWalletInteractionAuthLoginWithChallengeRequestItem.write(v1, into: &buf)

        case .loginWithoutChallenge:
            writeInt(&buf, Int32(2))

        case let .usePersona(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDappToWalletInteractionAuthUsePersonaRequestItem.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthRequestItem_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionAuthRequestItem {
    return try FfiConverterTypeDappToWalletInteractionAuthRequestItem.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionAuthRequestItem_lower(_ value: DappToWalletInteractionAuthRequestItem) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthRequestItem.lower(value)
}

extension DappToWalletInteractionAuthRequestItem: Sendable {}
extension DappToWalletInteractionAuthRequestItem: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappToWalletInteractionItems {
    case unauthorizedRequest(DappToWalletInteractionUnauthorizedRequestItems
    )
    case authorizedRequest(DappToWalletInteractionAuthorizedRequestItems
    )
    case transaction(DappToWalletInteractionTransactionItems
    )
    case preAuthorization(DappToWalletInteractionPreAuthorizationItems
    )
}

public struct FfiConverterTypeDappToWalletInteractionItems: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionItems

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionItems {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .unauthorizedRequest(FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.read(from: &buf)
            )

        case 2: return try .authorizedRequest(FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.read(from: &buf)
            )

        case 3: return try .transaction(FfiConverterTypeDappToWalletInteractionTransactionItems.read(from: &buf)
            )

        case 4: return try .preAuthorization(FfiConverterTypeDappToWalletInteractionPreAuthorizationItems.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappToWalletInteractionItems, into buf: inout [UInt8]) {
        switch value {
        case let .unauthorizedRequest(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDappToWalletInteractionUnauthorizedRequestItems.write(v1, into: &buf)

        case let .authorizedRequest(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDappToWalletInteractionAuthorizedRequestItems.write(v1, into: &buf)

        case let .transaction(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDappToWalletInteractionTransactionItems.write(v1, into: &buf)

        case let .preAuthorization(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeDappToWalletInteractionPreAuthorizationItems.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeDappToWalletInteractionItems_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionItems {
    return try FfiConverterTypeDappToWalletInteractionItems.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionItems_lower(_ value: DappToWalletInteractionItems) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionItems.lower(value)
}

extension DappToWalletInteractionItems: Sendable {}
extension DappToWalletInteractionItems: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum that represents the different ways a subintent can expire.
 */

public enum DappToWalletInteractionSubintentExpiration {
    /**
     * The subintent expires at a specific fixed timestamp.
     *
     * For example, a dApp sends a subintent for `User A` to approve sending 100 XRD before 5:00 PM,
     * and a subintent for `User B` to approve sending 2 USDT with same expiration.
     *
     * If both users sign their subintents before 5:00 PM, the transaction to exchange
     * 100 XRD over 2 USDT will succeed. Otherwise, it would fail.
     */
    case atTime(DappToWalletInteractionSubintentExpireAtTime
    )
    /**
     * The subintent expires X seconds after its signature.
     *
     * For example, a dApp sends a subintent for `User A` to approve sending 100 XRD with 1 hour expiration,
     * and a subintent for `User B` to approve sending 2 USDT with same expiration.
     *
     * If both users sign their subintents within one hour from each other, the transaction to exchange
     * 100 XRD over 2 USDT will succeed. Otherwise, it would fail.
     */
    case afterDelay(DappToWalletInteractionSubintentExpireAfterDelay
    )
}

public struct FfiConverterTypeDappToWalletInteractionSubintentExpiration: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionSubintentExpiration

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentExpiration {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .atTime(FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime.read(from: &buf)
            )

        case 2: return try .afterDelay(FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappToWalletInteractionSubintentExpiration, into buf: inout [UInt8]) {
        switch value {
        case let .atTime(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDappToWalletInteractionSubintentExpireAtTime.write(v1, into: &buf)

        case let .afterDelay(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDappToWalletInteractionSubintentExpireAfterDelay.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpiration_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentExpiration {
    return try FfiConverterTypeDappToWalletInteractionSubintentExpiration.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpiration_lower(_ value: DappToWalletInteractionSubintentExpiration) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSubintentExpiration.lower(value)
}

extension DappToWalletInteractionSubintentExpiration: Sendable {}
extension DappToWalletInteractionSubintentExpiration: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum that represents the expiration status of a subintent at a given time.
 *
 * Useful for determining if a subintent is still valid at the moment the Host apps
 * receive the corresponding request.
 */

public enum DappToWalletInteractionSubintentExpirationStatus {
    /**
     * The subintent hasn't expired yet
     */
    case valid
    /**
     * The subintent is too close to its expiration. Although it hasn't expired yet, the Host apps
     * shouldn't allow the user dealing with it.
     */
    case expirationTooClose
    /**
     * The subintent has already expired.
     */
    case expired
}

public struct FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionSubintentExpirationStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionSubintentExpirationStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .valid

        case 2: return .expirationTooClose

        case 3: return .expired

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappToWalletInteractionSubintentExpirationStatus, into buf: inout [UInt8]) {
        switch value {
        case .valid:
            writeInt(&buf, Int32(1))

        case .expirationTooClose:
            writeInt(&buf, Int32(2))

        case .expired:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus_lift(_ buf: RustBuffer) throws -> DappToWalletInteractionSubintentExpirationStatus {
    return try FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus.lift(buf)
}

public func FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus_lower(_ value: DappToWalletInteractionSubintentExpirationStatus) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus.lower(value)
}

extension DappToWalletInteractionSubintentExpirationStatus: Sendable {}
extension DappToWalletInteractionSubintentExpirationStatus: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DappWalletInteractionErrorType {
    case rejectedByUser
    case wrongNetwork
    case failedToPrepareTransaction
    case failedToCompileTransaction
    case failedToSignTransaction
    case failedToSubmitTransaction
    case failedToPollSubmittedTransaction
    case failedToFindAccountWithEnoughFundsToLockFee
    case submittedTransactionWasDuplicate
    case submittedTransactionHasFailedTransactionStatus
    case submittedTransactionHasRejectedTransactionStatus
    case wrongAccountType
    case unknownWebsite
    case invalidOriginUrl
    case radixJsonNotFound
    case radixJsonUnknownFileFormat
    case unknownDappDefinitionAddress
    case invalidPersona
    case invalidRequest
    case incompatibleVersion
    case failedToSignAuthChallenge
    case invalidPersonaOrAccounts
    case expiredSubintent
    case subintentExpirationTooClose
}

public struct FfiConverterTypeDappWalletInteractionErrorType: FfiConverterRustBuffer {
    typealias SwiftType = DappWalletInteractionErrorType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappWalletInteractionErrorType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .rejectedByUser

        case 2: return .wrongNetwork

        case 3: return .failedToPrepareTransaction

        case 4: return .failedToCompileTransaction

        case 5: return .failedToSignTransaction

        case 6: return .failedToSubmitTransaction

        case 7: return .failedToPollSubmittedTransaction

        case 8: return .failedToFindAccountWithEnoughFundsToLockFee

        case 9: return .submittedTransactionWasDuplicate

        case 10: return .submittedTransactionHasFailedTransactionStatus

        case 11: return .submittedTransactionHasRejectedTransactionStatus

        case 12: return .wrongAccountType

        case 13: return .unknownWebsite

        case 14: return .invalidOriginUrl

        case 15: return .radixJsonNotFound

        case 16: return .radixJsonUnknownFileFormat

        case 17: return .unknownDappDefinitionAddress

        case 18: return .invalidPersona

        case 19: return .invalidRequest

        case 20: return .incompatibleVersion

        case 21: return .failedToSignAuthChallenge

        case 22: return .invalidPersonaOrAccounts

        case 23: return .expiredSubintent

        case 24: return .subintentExpirationTooClose

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DappWalletInteractionErrorType, into buf: inout [UInt8]) {
        switch value {
        case .rejectedByUser:
            writeInt(&buf, Int32(1))

        case .wrongNetwork:
            writeInt(&buf, Int32(2))

        case .failedToPrepareTransaction:
            writeInt(&buf, Int32(3))

        case .failedToCompileTransaction:
            writeInt(&buf, Int32(4))

        case .failedToSignTransaction:
            writeInt(&buf, Int32(5))

        case .failedToSubmitTransaction:
            writeInt(&buf, Int32(6))

        case .failedToPollSubmittedTransaction:
            writeInt(&buf, Int32(7))

        case .failedToFindAccountWithEnoughFundsToLockFee:
            writeInt(&buf, Int32(8))

        case .submittedTransactionWasDuplicate:
            writeInt(&buf, Int32(9))

        case .submittedTransactionHasFailedTransactionStatus:
            writeInt(&buf, Int32(10))

        case .submittedTransactionHasRejectedTransactionStatus:
            writeInt(&buf, Int32(11))

        case .wrongAccountType:
            writeInt(&buf, Int32(12))

        case .unknownWebsite:
            writeInt(&buf, Int32(13))

        case .invalidOriginUrl:
            writeInt(&buf, Int32(14))

        case .radixJsonNotFound:
            writeInt(&buf, Int32(15))

        case .radixJsonUnknownFileFormat:
            writeInt(&buf, Int32(16))

        case .unknownDappDefinitionAddress:
            writeInt(&buf, Int32(17))

        case .invalidPersona:
            writeInt(&buf, Int32(18))

        case .invalidRequest:
            writeInt(&buf, Int32(19))

        case .incompatibleVersion:
            writeInt(&buf, Int32(20))

        case .failedToSignAuthChallenge:
            writeInt(&buf, Int32(21))

        case .invalidPersonaOrAccounts:
            writeInt(&buf, Int32(22))

        case .expiredSubintent:
            writeInt(&buf, Int32(23))

        case .subintentExpirationTooClose:
            writeInt(&buf, Int32(24))
        }
    }
}

public func FfiConverterTypeDappWalletInteractionErrorType_lift(_ buf: RustBuffer) throws -> DappWalletInteractionErrorType {
    return try FfiConverterTypeDappWalletInteractionErrorType.lift(buf)
}

public func FfiConverterTypeDappWalletInteractionErrorType_lower(_ value: DappWalletInteractionErrorType) -> RustBuffer {
    return FfiConverterTypeDappWalletInteractionErrorType.lower(value)
}

extension DappWalletInteractionErrorType: Sendable {}
extension DappWalletInteractionErrorType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DependencyInformation {
    case version(String
    )
    case tag(String
    )
    case branch(String
    )
    case rev(String
    )
}

public struct FfiConverterTypeDependencyInformation: FfiConverterRustBuffer {
    typealias SwiftType = DependencyInformation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DependencyInformation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .version(FfiConverterString.read(from: &buf)
            )

        case 2: return try .tag(FfiConverterString.read(from: &buf)
            )

        case 3: return try .branch(FfiConverterString.read(from: &buf)
            )

        case 4: return try .rev(FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DependencyInformation, into buf: inout [UInt8]) {
        switch value {
        case let .version(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)

        case let .tag(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)

        case let .branch(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)

        case let .rev(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeDependencyInformation_lift(_ buf: RustBuffer) throws -> DependencyInformation {
    return try FfiConverterTypeDependencyInformation.lift(buf)
}

public func FfiConverterTypeDependencyInformation_lower(_ value: DependencyInformation) -> RustBuffer {
    return FfiConverterTypeDependencyInformation.lower(value)
}

extension DependencyInformation: Sendable {}
extension DependencyInformation: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The exception kind for deposit address
 */

public enum DepositAddressExceptionRule {
    /**
     * A resource can always be deposited in to the account by third-parties
     */
    case allow
    /**
     * A resource can never be deposited in to the account by third-parties
     */
    case deny
}

public struct FfiConverterTypeDepositAddressExceptionRule: FfiConverterRustBuffer {
    typealias SwiftType = DepositAddressExceptionRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositAddressExceptionRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .allow

        case 2: return .deny

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositAddressExceptionRule, into buf: inout [UInt8]) {
        switch value {
        case .allow:
            writeInt(&buf, Int32(1))

        case .deny:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeDepositAddressExceptionRule_lift(_ buf: RustBuffer) throws -> DepositAddressExceptionRule {
    return try FfiConverterTypeDepositAddressExceptionRule.lift(buf)
}

public func FfiConverterTypeDepositAddressExceptionRule_lower(_ value: DepositAddressExceptionRule) -> RustBuffer {
    return FfiConverterTypeDepositAddressExceptionRule.lower(value)
}

extension DepositAddressExceptionRule: Sendable {}
extension DepositAddressExceptionRule: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The general deposit rule to apply
 */

public enum DepositRule {
    /**
     * The account accepts **all** assets by default, except for exceptions (if any) which might not deposit/be deposited into this account.
     */
    case acceptKnown
    /**
     * The account accepts **known** assets by default, except for exceptions (if any) which might not deposit/be deposited into this account. By known we mean assets this account has received in the past.
     */
    case acceptAll
    /**
     * The account denies **all** assets by default, except for exceptions (if any) which might in fact deposit/be deposited into this account.
     */
    case denyAll
}

public struct FfiConverterTypeDepositRule: FfiConverterRustBuffer {
    typealias SwiftType = DepositRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DepositRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .acceptKnown

        case 2: return .acceptAll

        case 3: return .denyAll

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DepositRule, into buf: inout [UInt8]) {
        switch value {
        case .acceptKnown:
            writeInt(&buf, Int32(1))

        case .acceptAll:
            writeInt(&buf, Int32(2))

        case .denyAll:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeDepositRule_lift(_ buf: RustBuffer) throws -> DepositRule {
    return try FfiConverterTypeDepositRule.lift(buf)
}

public func FfiConverterTypeDepositRule_lower(_ value: DepositRule) -> RustBuffer {
    return FfiConverterTypeDepositRule.lower(value)
}

extension DepositRule: Sendable {}
extension DepositRule: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A derivation path on either supported schemes, either Babylon (CAP26) or Olympia (BIP44Like).
 */

public enum DerivationPath {
    case account(value: AccountPath
    )
    case identity(value: IdentityPath
    )
    case bip44Like(value: Bip44LikePath
    )
}

public struct FfiConverterTypeDerivationPath: FfiConverterRustBuffer {
    typealias SwiftType = DerivationPath

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPath {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .account(value: FfiConverterTypeAccountPath.read(from: &buf)
            )

        case 2: return try .identity(value: FfiConverterTypeIdentityPath.read(from: &buf)
            )

        case 3: return try .bip44Like(value: FfiConverterTypeBIP44LikePath.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivationPath, into buf: inout [UInt8]) {
        switch value {
        case let .account(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountPath.write(value, into: &buf)

        case let .identity(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeIdentityPath.write(value, into: &buf)

        case let .bip44Like(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeBIP44LikePath.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeDerivationPath_lift(_ buf: RustBuffer) throws -> DerivationPath {
    return try FfiConverterTypeDerivationPath.lift(buf)
}

public func FfiConverterTypeDerivationPath_lower(_ value: DerivationPath) -> RustBuffer {
    return FfiConverterTypeDerivationPath.lower(value)
}

extension DerivationPath: Sendable {}
extension DerivationPath: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Which derivation path to used for some particular HD operations
 * such as signing or public key derivation. Radix Babylon introduces
 * a new scheme call Cap26 but we also need to support BIP44-like used
 * by Olympia.
 */

public enum DerivationPathScheme {
    /**
     * A BIP32 based derivation path scheme, using SLIP10.
     */
    case cap26
    /**
     * A BIP32 based similar to BIP44, but not strict BIP44 since the
     * last path component is hardened (a mistake made during Olympia),
     * used to support legacy accounts imported from Olympia wallet.
     */
    case bip44Olympia
}

public struct FfiConverterTypeDerivationPathScheme: FfiConverterRustBuffer {
    typealias SwiftType = DerivationPathScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPathScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .cap26

        case 2: return .bip44Olympia

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivationPathScheme, into buf: inout [UInt8]) {
        switch value {
        case .cap26:
            writeInt(&buf, Int32(1))

        case .bip44Olympia:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeDerivationPathScheme_lift(_ buf: RustBuffer) throws -> DerivationPathScheme {
    return try FfiConverterTypeDerivationPathScheme.lift(buf)
}

public func FfiConverterTypeDerivationPathScheme_lower(_ value: DerivationPathScheme) -> RustBuffer {
    return FfiConverterTypeDerivationPathScheme.lower(value)
}

extension DerivationPathScheme: Sendable {}
extension DerivationPathScheme: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The execution summary process not only determines the class of the manifest,
 * but also includes additional information about this class that the wallet
 * requires to display to the user.
 */

public enum DetailedManifestClass {
    /**
     * A general manifest that involves any amount of arbitrary components
     * and packages where nothing more concrete can be said about the manifest
     * and its nature.
     *
     * No additional information is required beyond what the execution summary
     * will provide.
     */
    case general
    /**
     * A manifest of a 1-to-1 transfer to a one-to-many transfer of resources.
     */
    case transfer(
        /**
         * When `true`, then this is a one-to-one transfer and the wallet can
         * regard this as a "simple transfer" and communicate this information
         * to the ledger hardware wallet. Otherwise, if `false`, then this is
         * not a one-to-one transfer.
         */ isOneToOne: Bool
    )
    /**
     * A manifest where XRD is claimed from one or more validators.
     */
    case validatorClaim(
        /**
         * The addresses of validators in the transaction
         */ validatorAddresses: [ValidatorAddress],
        /**
            * The claims observed in the transaction
            */ validatorClaims: [TrackedValidatorClaim]
    )
    /**
     * A manifest where XRD is staked to one or more validators.
     */
    case validatorStake(
        /**
         * The addresses of validators in the transaction
         */ validatorAddresses: [ValidatorAddress],
        /**
            * The stake observed in the transaction
            */ validatorStakes: [TrackedValidatorStake]
    )
    /**
     * A manifest where XRD is unstaked from one or more validators.
     */
    case validatorUnstake(
        /**
         * The addresses of validators in the transaction
         */ validatorAddresses: [ValidatorAddress],
        /**
            * The data associated with the various claim NFTs
            */ claimsNonFungibleData: [NonFungibleGlobalId: UnstakeData]
    )
    /**
     * A manifest that updated the deposit settings of the account.
     */
    case accountDepositSettingsUpdate(
        /**
         * Updates to the resource preferences of the account deposit settings.
         * account_address -> (resource_address -> Update<new_preference>)
         */ resourcePreferencesUpdates: [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]],
        /**
            * Changes to the account's deposit mode.
            * account_address -> new_default_deposit_mode
            */ depositModeUpdates: [AccountAddress: DepositRule],
        /**
            * Additions to the authorized depositors
            */ authorizedDepositorsAdded: [AccountAddress: [ResourceOrNonFungible]],
        /**
            * Removals from the authorized depositors
            */ authorizedDepositorsRemoved: [AccountAddress: [ResourceOrNonFungible]]
    )
    /**
     * A manifest that contributed some amount of resources to a liquidity
     * pool that can be a one-resource pool, two-resource pool, or a
     * multi-resource pool.
     */
    case poolContribution(
        /**
         * The addresses of the pools in the transaction
         */ poolAddresses: [PoolAddress],
        /**
            * The contribution observed in the transaction
            */ poolContributions: [TrackedPoolContribution]
    )
    /**
     * A manifest that redeemed resources from a liquidity pool. Similar to
     * contributions, this can be any of the three pool blueprints available
     * in the pool package.
     */
    case poolRedemption(
        /**
         * The addresses of the pools in the transaction
         */ poolAddresses: [PoolAddress],
        /**
            * The redemptions observed in the transaction
            */ poolRedemptions: [TrackedPoolRedemption]
    )
    /**
     * A manifest that deletes accounts.
     */
    case deleteAccounts(
        /**
         * The addresses of the accounts that are being deleted
         */ accountAddresses: [AccountAddress]
    )
}

public struct FfiConverterTypeDetailedManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = DetailedManifestClass

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DetailedManifestClass {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .general

        case 2: return try .transfer(isOneToOne: FfiConverterBool.read(from: &buf)
            )

        case 3: return try .validatorClaim(validatorAddresses: FfiConverterSequenceTypeValidatorAddress.read(from: &buf), validatorClaims: FfiConverterSequenceTypeTrackedValidatorClaim.read(from: &buf))

        case 4: return try .validatorStake(validatorAddresses: FfiConverterSequenceTypeValidatorAddress.read(from: &buf), validatorStakes: FfiConverterSequenceTypeTrackedValidatorStake.read(from: &buf))

        case 5: return try .validatorUnstake(validatorAddresses: FfiConverterSequenceTypeValidatorAddress.read(from: &buf), claimsNonFungibleData: FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData.read(from: &buf))

        case 6: return try .accountDepositSettingsUpdate(resourcePreferencesUpdates: FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.read(from: &buf), depositModeUpdates: FfiConverterDictionaryTypeAccountAddressTypeDepositRule.read(from: &buf), authorizedDepositorsAdded: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.read(from: &buf), authorizedDepositorsRemoved: FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.read(from: &buf))

        case 7: return try .poolContribution(poolAddresses: FfiConverterSequenceTypePoolAddress.read(from: &buf), poolContributions: FfiConverterSequenceTypeTrackedPoolContribution.read(from: &buf))

        case 8: return try .poolRedemption(poolAddresses: FfiConverterSequenceTypePoolAddress.read(from: &buf), poolRedemptions: FfiConverterSequenceTypeTrackedPoolRedemption.read(from: &buf))

        case 9: return try .deleteAccounts(accountAddresses: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DetailedManifestClass, into buf: inout [UInt8]) {
        switch value {
        case .general:
            writeInt(&buf, Int32(1))

        case let .transfer(isOneToOne):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(isOneToOne, into: &buf)

        case let .validatorClaim(validatorAddresses, validatorClaims):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedValidatorClaim.write(validatorClaims, into: &buf)

        case let .validatorStake(validatorAddresses, validatorStakes):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedValidatorStake.write(validatorStakes, into: &buf)

        case let .validatorUnstake(validatorAddresses, claimsNonFungibleData):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeValidatorAddress.write(validatorAddresses, into: &buf)
            FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData.write(claimsNonFungibleData, into: &buf)

        case let .accountDepositSettingsUpdate(resourcePreferencesUpdates, depositModeUpdates, authorizedDepositorsAdded, authorizedDepositorsRemoved):
            writeInt(&buf, Int32(6))
            FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.write(resourcePreferencesUpdates, into: &buf)
            FfiConverterDictionaryTypeAccountAddressTypeDepositRule.write(depositModeUpdates, into: &buf)
            FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.write(authorizedDepositorsAdded, into: &buf)
            FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible.write(authorizedDepositorsRemoved, into: &buf)

        case let .poolContribution(poolAddresses, poolContributions):
            writeInt(&buf, Int32(7))
            FfiConverterSequenceTypePoolAddress.write(poolAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedPoolContribution.write(poolContributions, into: &buf)

        case let .poolRedemption(poolAddresses, poolRedemptions):
            writeInt(&buf, Int32(8))
            FfiConverterSequenceTypePoolAddress.write(poolAddresses, into: &buf)
            FfiConverterSequenceTypeTrackedPoolRedemption.write(poolRedemptions, into: &buf)

        case let .deleteAccounts(accountAddresses):
            writeInt(&buf, Int32(9))
            FfiConverterSequenceTypeAccountAddress.write(accountAddresses, into: &buf)
        }
    }
}

public func FfiConverterTypeDetailedManifestClass_lift(_ buf: RustBuffer) throws -> DetailedManifestClass {
    return try FfiConverterTypeDetailedManifestClass.lift(buf)
}

public func FfiConverterTypeDetailedManifestClass_lower(_ value: DetailedManifestClass) -> RustBuffer {
    return FfiConverterTypeDetailedManifestClass.lower(value)
}

extension DetailedManifestClass: Sendable {}
extension DetailedManifestClass: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A discriminator type for the `DetailedManifestClass` enum.
 */

public enum DetailedManifestClassKind {
    case general
    case transfer
    case validatorClaim
    case validatorStake
    case validatorUnstake
    case accountDepositSettingsUpdate
    case poolContribution
    case poolRedemption
    case deleteAccounts
}

public struct FfiConverterTypeDetailedManifestClassKind: FfiConverterRustBuffer {
    typealias SwiftType = DetailedManifestClassKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DetailedManifestClassKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .general

        case 2: return .transfer

        case 3: return .validatorClaim

        case 4: return .validatorStake

        case 5: return .validatorUnstake

        case 6: return .accountDepositSettingsUpdate

        case 7: return .poolContribution

        case 8: return .poolRedemption

        case 9: return .deleteAccounts

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DetailedManifestClassKind, into buf: inout [UInt8]) {
        switch value {
        case .general:
            writeInt(&buf, Int32(1))

        case .transfer:
            writeInt(&buf, Int32(2))

        case .validatorClaim:
            writeInt(&buf, Int32(3))

        case .validatorStake:
            writeInt(&buf, Int32(4))

        case .validatorUnstake:
            writeInt(&buf, Int32(5))

        case .accountDepositSettingsUpdate:
            writeInt(&buf, Int32(6))

        case .poolContribution:
            writeInt(&buf, Int32(7))

        case .poolRedemption:
            writeInt(&buf, Int32(8))

        case .deleteAccounts:
            writeInt(&buf, Int32(9))
        }
    }
}

public func FfiConverterTypeDetailedManifestClassKind_lift(_ buf: RustBuffer) throws -> DetailedManifestClassKind {
    return try FfiConverterTypeDetailedManifestClassKind.lift(buf)
}

public func FfiConverterTypeDetailedManifestClassKind_lower(_ value: DetailedManifestClassKind) -> RustBuffer {
    return FfiConverterTypeDetailedManifestClassKind.lower(value)
}

extension DetailedManifestClassKind: Sendable {}
extension DetailedManifestClassKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * If we wanna create an Olympia DeviceFactorSource or
 * a Babylon one, either main or not.
 */

public enum DeviceFactorSourceType {
    case babylon(isMain: Bool
    )
    case olympia
}

public struct FfiConverterTypeDeviceFactorSourceType: FfiConverterRustBuffer {
    typealias SwiftType = DeviceFactorSourceType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceFactorSourceType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .babylon(isMain: FfiConverterBool.read(from: &buf)
            )

        case 2: return .olympia

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DeviceFactorSourceType, into buf: inout [UInt8]) {
        switch value {
        case let .babylon(isMain):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(isMain, into: &buf)

        case .olympia:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeDeviceFactorSourceType_lift(_ buf: RustBuffer) throws -> DeviceFactorSourceType {
    return try FfiConverterTypeDeviceFactorSourceType.lift(buf)
}

public func FfiConverterTypeDeviceFactorSourceType_lower(_ value: DeviceFactorSourceType) -> RustBuffer {
    return FfiConverterTypeDeviceFactorSourceType.lower(value)
}

extension DeviceFactorSourceType: Sendable {}
extension DeviceFactorSourceType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EncryptionScheme {
    /**
     * AES GCM 256 encryption
     */
    case version1(AesGcm256
    )
}

public struct FfiConverterTypeEncryptionScheme: FfiConverterRustBuffer {
    typealias SwiftType = EncryptionScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptionScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .version1(FfiConverterTypeAesGcm256.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptionScheme, into buf: inout [UInt8]) {
        switch value {
        case let .version1(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesGcm256.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeEncryptionScheme_lift(_ buf: RustBuffer) throws -> EncryptionScheme {
    return try FfiConverterTypeEncryptionScheme.lift(buf)
}

public func FfiConverterTypeEncryptionScheme_lower(_ value: EncryptionScheme) -> RustBuffer {
    return FfiConverterTypeEncryptionScheme.lower(value)
}

extension EncryptionScheme: Sendable {}
extension EncryptionScheme: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Flags used to mark state of an Account or Persona such as whether
 * user has marked it as deleted or not.
 */

public enum EntityFlag {
    /**
     * The entity is marked as hidden by user. Entity should still be kept in Profile
     * The user can "unhide" the entity and continue involving it in transactions on ledger.
     */
    case hiddenByUser
    /**
     * The entity is marked as tombstoned by the user. Entity should still be kept in Profile
     * Such an entity cannot be involved in any transaction anymore.
     */
    case tombstonedByUser
}

public struct FfiConverterTypeEntityFlag: FfiConverterRustBuffer {
    typealias SwiftType = EntityFlag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityFlag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .hiddenByUser

        case 2: return .tombstonedByUser

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityFlag, into buf: inout [UInt8]) {
        switch value {
        case .hiddenByUser:
            writeInt(&buf, Int32(1))

        case .tombstonedByUser:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeEntityFlag_lift(_ buf: RustBuffer) throws -> EntityFlag {
    return try FfiConverterTypeEntityFlag.lift(buf)
}

public func FfiConverterTypeEntityFlag_lower(_ value: EntityFlag) -> RustBuffer {
    return FfiConverterTypeEntityFlag.lower(value)
}

extension EntityFlag: Sendable {}
extension EntityFlag: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EntityKind {
    case account
    case persona
}

public struct FfiConverterTypeEntityKind: FfiConverterRustBuffer {
    typealias SwiftType = EntityKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .account

        case 2: return .persona

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntityKind, into buf: inout [UInt8]) {
        switch value {
        case .account:
            writeInt(&buf, Int32(1))

        case .persona:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeEntityKind_lift(_ buf: RustBuffer) throws -> EntityKind {
    return try FfiConverterTypeEntityKind.lift(buf)
}

public func FfiConverterTypeEntityKind_lower(_ value: EntityKind) -> RustBuffer {
    return FfiConverterTypeEntityKind.lower(value)
}

extension EntityKind: Sendable {}
extension EntityKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the state an entity - Account or Persona - is in, in regards to how
 * the user controls it, i.e. if it is controlled by a single factor (private key)
 * or an `AccessController` with a potential Multi-Factor setup.
 */

public enum EntitySecurityState {
    /**
     * The account is controlled by a single factor (private key)
     */
    case unsecured(value: UnsecuredEntityControl
    )
}

public struct FfiConverterTypeEntitySecurityState: FfiConverterRustBuffer {
    typealias SwiftType = EntitySecurityState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntitySecurityState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .unsecured(value: FfiConverterTypeUnsecuredEntityControl.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EntitySecurityState, into buf: inout [UInt8]) {
        switch value {
        case let .unsecured(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUnsecuredEntityControl.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeEntitySecurityState_lift(_ buf: RustBuffer) throws -> EntitySecurityState {
    return try FfiConverterTypeEntitySecurityState.lift(buf)
}

public func FfiConverterTypeEntitySecurityState_lower(_ value: EntitySecurityState) -> RustBuffer {
    return FfiConverterTypeEntitySecurityState.lower(value)
}

extension EntitySecurityState: Sendable {}
extension EntitySecurityState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * SargonOS event contain information about something of interest that has
 * happened to the SargonOS, most prominently to the Profile. Host device
 * can subscribe to these events by use of `EventBusDriver`.
 */

public enum Event {
    /**
     * The SargonOS just booted.
     */
    case booted
    /**
     * Current Gateway changed
     */
    case gatewayChangedCurrent(to: Gateway, isNew: Bool)
    /**
     * Profile has been saved, typically it has been modified and the new
     * changed Profile got persisted into secure storage.
     */
    case profileSaved
    /**
     * A profile has been imported and has been set to active profile,
     * and saved into secure storage.
     */
    case profileImported(id: ProfileId
    )
    /**
     * The active profile has been modified (might not have been saved yet).
     */
    case profileModified(change: EventProfileModified
    )
    /**
     * The Profile was last used on another device, user ought to claim it.
     */
    case profileUsedOnOtherDevice(DeviceInfo
    )
}

public struct FfiConverterTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .booted

        case 2: return try .gatewayChangedCurrent(to: FfiConverterTypeGateway.read(from: &buf), isNew: FfiConverterBool.read(from: &buf))

        case 3: return .profileSaved

        case 4: return try .profileImported(id: FfiConverterTypeProfileID.read(from: &buf)
            )

        case 5: return try .profileModified(change: FfiConverterTypeEventProfileModified.read(from: &buf)
            )

        case 6: return try .profileUsedOnOtherDevice(FfiConverterTypeDeviceInfo.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        switch value {
        case .booted:
            writeInt(&buf, Int32(1))

        case let .gatewayChangedCurrent(to, isNew):
            writeInt(&buf, Int32(2))
            FfiConverterTypeGateway.write(to, into: &buf)
            FfiConverterBool.write(isNew, into: &buf)

        case .profileSaved:
            writeInt(&buf, Int32(3))

        case let .profileImported(id):
            writeInt(&buf, Int32(4))
            FfiConverterTypeProfileID.write(id, into: &buf)

        case let .profileModified(change):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEventProfileModified.write(change, into: &buf)

        case let .profileUsedOnOtherDevice(v1):
            writeInt(&buf, Int32(6))
            FfiConverterTypeDeviceInfo.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeEvent_lift(_ buf: RustBuffer) throws -> Event {
    return try FfiConverterTypeEvent.lift(buf)
}

public func FfiConverterTypeEvent_lower(_ value: Event) -> RustBuffer {
    return FfiConverterTypeEvent.lower(value)
}

extension Event: Sendable {}
extension Event: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A discriminator identifying the kind of `Event`, this has no associated
 * values and flattens the otherwise nested `Event` enum.
 */

public enum EventKind {
    /**
     * Profile updated with a new account.
     */
    case accountAdded
    /**
     * Profile updated with new accounts.
     */
    case accountsAdded
    /**
     * An existing account has been updated
     */
    case accountUpdated
    /**
     * Existing accounts have been updated
     */
    case accountsUpdated
    /**
     * SargonOS did boot.
     */
    case booted
    /**
     * Current Gateway changed
     */
    case gatewayChangedCurrent
    /**
     * Profile updated with a new persona.
     */
    case personaAdded
    /**
     * Profile updated with new personas.
     */
    case personasAdded
    /**
     * An existing persona has been updated
     */
    case personaUpdated
    /**
     * Existing personas have been updated
     */
    case personasUpdated
    /**
     * Profile was saved.
     */
    case profileSaved
    /**
     * A profile has been imported and has been set to active profile,
     * and saved into secure storage.
     */
    case profileImported
    /**
     * Profile was last used on another device.
     */
    case profileUsedOnOtherDevice
    /**
     * Profile updated with a new factor source.
     */
    case factorSourceAdded
    /**
     * Profile updated with multiple new factor sources.
     */
    case factorSourcesAdded
    /**
     * An existing factor source has been updated
     */
    case factorSourceUpdated
    /**
     * Profile updated with a new Security Structure.
     */
    case securityStructureAdded
}

public struct FfiConverterTypeEventKind: FfiConverterRustBuffer {
    typealias SwiftType = EventKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .accountAdded

        case 2: return .accountsAdded

        case 3: return .accountUpdated

        case 4: return .accountsUpdated

        case 5: return .booted

        case 6: return .gatewayChangedCurrent

        case 7: return .personaAdded

        case 8: return .personasAdded

        case 9: return .personaUpdated

        case 10: return .personasUpdated

        case 11: return .profileSaved

        case 12: return .profileImported

        case 13: return .profileUsedOnOtherDevice

        case 14: return .factorSourceAdded

        case 15: return .factorSourcesAdded

        case 16: return .factorSourceUpdated

        case 17: return .securityStructureAdded

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventKind, into buf: inout [UInt8]) {
        switch value {
        case .accountAdded:
            writeInt(&buf, Int32(1))

        case .accountsAdded:
            writeInt(&buf, Int32(2))

        case .accountUpdated:
            writeInt(&buf, Int32(3))

        case .accountsUpdated:
            writeInt(&buf, Int32(4))

        case .booted:
            writeInt(&buf, Int32(5))

        case .gatewayChangedCurrent:
            writeInt(&buf, Int32(6))

        case .personaAdded:
            writeInt(&buf, Int32(7))

        case .personasAdded:
            writeInt(&buf, Int32(8))

        case .personaUpdated:
            writeInt(&buf, Int32(9))

        case .personasUpdated:
            writeInt(&buf, Int32(10))

        case .profileSaved:
            writeInt(&buf, Int32(11))

        case .profileImported:
            writeInt(&buf, Int32(12))

        case .profileUsedOnOtherDevice:
            writeInt(&buf, Int32(13))

        case .factorSourceAdded:
            writeInt(&buf, Int32(14))

        case .factorSourcesAdded:
            writeInt(&buf, Int32(15))

        case .factorSourceUpdated:
            writeInt(&buf, Int32(16))

        case .securityStructureAdded:
            writeInt(&buf, Int32(17))
        }
    }
}

public func FfiConverterTypeEventKind_lift(_ buf: RustBuffer) throws -> EventKind {
    return try FfiConverterTypeEventKind.lift(buf)
}

public func FfiConverterTypeEventKind_lower(_ value: EventKind) -> RustBuffer {
    return FfiConverterTypeEventKind.lower(value)
}

extension EventKind: Sendable {}
extension EventKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The active profile has been modified (might not have been saved yet).
 */

public enum EventProfileModified {
    /**
     * A new account with `address` was inserted into the active profile
     */
    case accountAdded(address: AccountAddress
    )
    /**
     * New accounts with `addresses` were inserted into the active profile
     */
    case accountsAdded(addresses: [AccountAddress]
    )
    /**
     * An existing account has been updated
     */
    case accountUpdated(address: AccountAddress
    )
    /**
     * Existing accounts have been updated
     */
    case accountsUpdated(addresses: [AccountAddress]
    )
    /**
     * Profile updated with a new factor source.
     */
    case factorSourceAdded(id: FactorSourceId
    )
    /**
     * Profile updated with many new factor sources.
     */
    case factorSourcesAdded(ids: [FactorSourceId]
    )
    /**
     * An existing factor source has been updated
     */
    case factorSourceUpdated(id: FactorSourceId
    )
    /**
     * A new persona with `address` was inserted into the active profile
     */
    case personaAdded(address: IdentityAddress
    )
    /**
     * New personas with `addresses` were inserted into the active profile
     */
    case personasAdded(addresses: [IdentityAddress]
    )
    /**
     * An existing persona has been updated
     */
    case personaUpdated(address: IdentityAddress
    )
    /**
     * Existing personas have been updated
     */
    case personasUpdated(addresses: [IdentityAddress]
    )
    /**
     * Profile updated with a new Security Structure.
     */
    case securityStructureAdded(id: SecurityStructureId
    )
}

public struct FfiConverterTypeEventProfileModified: FfiConverterRustBuffer {
    typealias SwiftType = EventProfileModified

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventProfileModified {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .accountAdded(address: FfiConverterTypeAccountAddress.read(from: &buf)
            )

        case 2: return try .accountsAdded(addresses: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
            )

        case 3: return try .accountUpdated(address: FfiConverterTypeAccountAddress.read(from: &buf)
            )

        case 4: return try .accountsUpdated(addresses: FfiConverterSequenceTypeAccountAddress.read(from: &buf)
            )

        case 5: return try .factorSourceAdded(id: FfiConverterTypeFactorSourceID.read(from: &buf)
            )

        case 6: return try .factorSourcesAdded(ids: FfiConverterSequenceTypeFactorSourceID.read(from: &buf)
            )

        case 7: return try .factorSourceUpdated(id: FfiConverterTypeFactorSourceID.read(from: &buf)
            )

        case 8: return try .personaAdded(address: FfiConverterTypeIdentityAddress.read(from: &buf)
            )

        case 9: return try .personasAdded(addresses: FfiConverterSequenceTypeIdentityAddress.read(from: &buf)
            )

        case 10: return try .personaUpdated(address: FfiConverterTypeIdentityAddress.read(from: &buf)
            )

        case 11: return try .personasUpdated(addresses: FfiConverterSequenceTypeIdentityAddress.read(from: &buf)
            )

        case 12: return try .securityStructureAdded(id: FfiConverterTypeSecurityStructureID.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventProfileModified, into buf: inout [UInt8]) {
        switch value {
        case let .accountAdded(address):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAccountAddress.write(address, into: &buf)

        case let .accountsAdded(addresses):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeAccountAddress.write(addresses, into: &buf)

        case let .accountUpdated(address):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAccountAddress.write(address, into: &buf)

        case let .accountsUpdated(addresses):
            writeInt(&buf, Int32(4))
            FfiConverterSequenceTypeAccountAddress.write(addresses, into: &buf)

        case let .factorSourceAdded(id):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFactorSourceID.write(id, into: &buf)

        case let .factorSourcesAdded(ids):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeFactorSourceID.write(ids, into: &buf)

        case let .factorSourceUpdated(id):
            writeInt(&buf, Int32(7))
            FfiConverterTypeFactorSourceID.write(id, into: &buf)

        case let .personaAdded(address):
            writeInt(&buf, Int32(8))
            FfiConverterTypeIdentityAddress.write(address, into: &buf)

        case let .personasAdded(addresses):
            writeInt(&buf, Int32(9))
            FfiConverterSequenceTypeIdentityAddress.write(addresses, into: &buf)

        case let .personaUpdated(address):
            writeInt(&buf, Int32(10))
            FfiConverterTypeIdentityAddress.write(address, into: &buf)

        case let .personasUpdated(addresses):
            writeInt(&buf, Int32(11))
            FfiConverterSequenceTypeIdentityAddress.write(addresses, into: &buf)

        case let .securityStructureAdded(id):
            writeInt(&buf, Int32(12))
            FfiConverterTypeSecurityStructureID.write(id, into: &buf)
        }
    }
}

public func FfiConverterTypeEventProfileModified_lift(_ buf: RustBuffer) throws -> EventProfileModified {
    return try FfiConverterTypeEventProfileModified.lift(buf)
}

public func FfiConverterTypeEventProfileModified_lower(_ value: EventProfileModified) -> RustBuffer {
    return FfiConverterTypeEventProfileModified.lower(value)
}

extension EventProfileModified: Sendable {}
extension EventProfileModified: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either a "physical" badge (resource) or some source for recreation of a producer
 * of a virtual badge (signature), e.g. a HD derivation path, from which a private key
 * is derived which produces virtual badges (signatures).
 */

public enum FactorInstanceBadge {
    case virtual(value: FactorInstanceBadgeVirtualSource
    )
    case physical(value: ResourceAddress
    )
}

public struct FfiConverterTypeFactorInstanceBadge: FfiConverterRustBuffer {
    typealias SwiftType = FactorInstanceBadge

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceBadge {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .virtual(value: FfiConverterTypeFactorInstanceBadgeVirtualSource.read(from: &buf)
            )

        case 2: return try .physical(value: FfiConverterTypeResourceAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorInstanceBadge, into buf: inout [UInt8]) {
        switch value {
        case let .virtual(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFactorInstanceBadgeVirtualSource.write(value, into: &buf)

        case let .physical(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorInstanceBadge_lift(_ buf: RustBuffer) throws -> FactorInstanceBadge {
    return try FfiConverterTypeFactorInstanceBadge.lift(buf)
}

public func FfiConverterTypeFactorInstanceBadge_lower(_ value: FactorInstanceBadge) -> RustBuffer {
    return FfiConverterTypeFactorInstanceBadge.lower(value)
}

extension FactorInstanceBadge: Sendable {}
extension FactorInstanceBadge: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FactorInstanceBadgeVirtualSource {
    case hierarchicalDeterministic(value: HierarchicalDeterministicPublicKey
    )
}

public struct FfiConverterTypeFactorInstanceBadgeVirtualSource: FfiConverterRustBuffer {
    typealias SwiftType = FactorInstanceBadgeVirtualSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorInstanceBadgeVirtualSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .hierarchicalDeterministic(value: FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorInstanceBadgeVirtualSource, into buf: inout [UInt8]) {
        switch value {
        case let .hierarchicalDeterministic(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeHierarchicalDeterministicPublicKey.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorInstanceBadgeVirtualSource_lift(_ buf: RustBuffer) throws -> FactorInstanceBadgeVirtualSource {
    return try FfiConverterTypeFactorInstanceBadgeVirtualSource.lift(buf)
}

public func FfiConverterTypeFactorInstanceBadgeVirtualSource_lower(_ value: FactorInstanceBadgeVirtualSource) -> RustBuffer {
    return FfiConverterTypeFactorInstanceBadgeVirtualSource.lower(value)
}

extension FactorInstanceBadgeVirtualSource: Sendable {}
extension FactorInstanceBadgeVirtualSource: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FactorSource {
    case device(value: DeviceFactorSource
    )
    case ledger(value: LedgerHardwareWalletFactorSource
    )
    case offDeviceMnemonic(value: OffDeviceMnemonicFactorSource
    )
    case arculusCard(value: ArculusCardFactorSource
    )
    case securityQuestions(value: SecurityQuestionsNotProductionReadyFactorSource
    )
    case trustedContact(value: TrustedContactFactorSource
    )
    case passphrase(value: PassphraseFactorSource
    )
}

public struct FfiConverterTypeFactorSource: FfiConverterRustBuffer {
    typealias SwiftType = FactorSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .device(value: FfiConverterTypeDeviceFactorSource.read(from: &buf)
            )

        case 2: return try .ledger(value: FfiConverterTypeLedgerHardwareWalletFactorSource.read(from: &buf)
            )

        case 3: return try .offDeviceMnemonic(value: FfiConverterTypeOffDeviceMnemonicFactorSource.read(from: &buf)
            )

        case 4: return try .arculusCard(value: FfiConverterTypeArculusCardFactorSource.read(from: &buf)
            )

        case 5: return try .securityQuestions(value: FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.read(from: &buf)
            )

        case 6: return try .trustedContact(value: FfiConverterTypeTrustedContactFactorSource.read(from: &buf)
            )

        case 7: return try .passphrase(value: FfiConverterTypePassphraseFactorSource.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSource, into buf: inout [UInt8]) {
        switch value {
        case let .device(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDeviceFactorSource.write(value, into: &buf)

        case let .ledger(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLedgerHardwareWalletFactorSource.write(value, into: &buf)

        case let .offDeviceMnemonic(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeOffDeviceMnemonicFactorSource.write(value, into: &buf)

        case let .arculusCard(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeArculusCardFactorSource.write(value, into: &buf)

        case let .securityQuestions(value):
            writeInt(&buf, Int32(5))
            FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.write(value, into: &buf)

        case let .trustedContact(value):
            writeInt(&buf, Int32(6))
            FfiConverterTypeTrustedContactFactorSource.write(value, into: &buf)

        case let .passphrase(value):
            writeInt(&buf, Int32(7))
            FfiConverterTypePassphraseFactorSource.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorSource_lift(_ buf: RustBuffer) throws -> FactorSource {
    return try FfiConverterTypeFactorSource.lift(buf)
}

public func FfiConverterTypeFactorSource_lower(_ value: FactorSource) -> RustBuffer {
    return FfiConverterTypeFactorSource.lower(value)
}

extension FactorSource: Sendable {}
extension FactorSource: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Flags which describe a certain state a FactorSource might be in, primarily used
 * by DeviceFactorSource's to mark which "Babylon" FactorSource is the **main** one.
 */

public enum FactorSourceFlag {
    /**
     * Used to mark a "babylon" `.device` FactorSource as "main". All new accounts
     * and Personas are created using the `main` `DeviceFactorSource`.
     *
     * We can only ever have one.
     * We might have zero `main` flags across all  `DeviceFactorSource`s if and only if we have only one  `DeviceFactorSource`s. If we have two or more  `DeviceFactorSource`s one of them MUST
     * be marked with `main`.
     */
    case main
    /**
     * Until we have implemented "proper" deletion, we will "flag" a
     * FactorSource as deleted by the user and hide it, meaning e.g.
     * that in Multi-Factor Setup flows it will not show up.
     */
    case deletedByUser
}

public struct FfiConverterTypeFactorSourceFlag: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceFlag

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceFlag {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .main

        case 2: return .deletedByUser

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceFlag, into buf: inout [UInt8]) {
        switch value {
        case .main:
            writeInt(&buf, Int32(1))

        case .deletedByUser:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeFactorSourceFlag_lift(_ buf: RustBuffer) throws -> FactorSourceFlag {
    return try FfiConverterTypeFactorSourceFlag.lift(buf)
}

public func FfiConverterTypeFactorSourceFlag_lower(_ value: FactorSourceFlag) -> RustBuffer {
    return FfiConverterTypeFactorSourceFlag.lower(value)
}

extension FactorSourceFlag: Sendable {}
extension FactorSourceFlag: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A unique and stable identifier of a FactorSource, e.g. a
 * DeviceFactorSource being a mnemonic securely stored in a
 * device (phone), where the ID of it is the hash of a special
 * key derived near the root of it.
 */

public enum FactorSourceId {
    /**
     * FactorSourceID from the blake2b hash of the special HD public key derived at `CAP26::GetID`,
     * for a certain `FactorSourceKind`
     */
    case hash(value: FactorSourceIdFromHash
    )
    /**
     * FactorSourceID from an AccountAddress, typically used by `trustedContact` FactorSource.
     */
    case address(value: FactorSourceIdFromAddress
    )
}

public struct FfiConverterTypeFactorSourceID: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .hash(value: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )

        case 2: return try .address(value: FfiConverterTypeFactorSourceIDFromAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceId, into buf: inout [UInt8]) {
        switch value {
        case let .hash(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFactorSourceIDFromHash.write(value, into: &buf)

        case let .address(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFactorSourceIDFromAddress.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeFactorSourceID_lift(_ buf: RustBuffer) throws -> FactorSourceId {
    return try FfiConverterTypeFactorSourceID.lift(buf)
}

public func FfiConverterTypeFactorSourceID_lower(_ value: FactorSourceId) -> RustBuffer {
    return FfiConverterTypeFactorSourceID.lower(value)
}

extension FactorSourceId: Sendable {}
extension FactorSourceId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The **kind** (or "type") of FactorSource describes how it is used.
 */

public enum FactorSourceKind {
    /**
     * A user owned unencrypted mnemonic (and optional BIP39 passphrase) stored on device,
     * thus directly usable. This kind is used as the standard factor source for all new
     * wallet users.
     *
     * Attributes:
     * * Mine
     * * On device
     * * Hierarchical deterministic (Mnemonic)
     * * Entity creating
     */
    case device
    /**
     * A user owned hardware wallet by vendor Ledger HQ, most commonly
     * a Ledger Nano S or Ledger Nano X. Less common models are Ledger Nano S Plus
     * Ledger Stax.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hardware (requires Browser Connector Extension to communicate with wallet)
     * * Hierarchical deterministic
     * * Entity creating (accounts only)
     */
    case ledgerHqHardwareWallet
    /**
     * A user owned mnemonic (and optional BIP39 passphrase) user has to input when used,
     * e.g. during signing.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic  (Mnemonic)
     */
    case offDeviceMnemonic
    /**
     * A contact, friend, company, organization or otherwise third party the user trusts enough
     * to be given a recovery token user has minted and sent the this contact.
     *
     * Attributes:
     * * **Not** mine
     * * Off device
     */
    case trustedContact
    /**
     * An encrypted user owned mnemonic (*never* any BIP39 passphrase) which can
     * be decrypted by answers to **security question**, which are personal questions
     * that should be only known to the user.
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic  (**Encrypted** mnemonic)
     */
    case securityQuestions
    /**
     * An Arculus card, in credit card size, communicating with host using NFC.
     *
     * For more info see [link]
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic  (**Encrypted** mnemonic)\
     * * Hardware (communicates with host using NFC)
     *
     * [link]: https://www.getarculus.com/
     */
    case arculusCard
    /**
     * Input key material for mnemonic (and optional BIP39 passphrase).
     *
     * Attributes:
     * * Mine
     * * Off device
     * * Hierarchical deterministic (IKM -> HKDF -> Mnemonic)
     */
    case passphrase
}

public struct FfiConverterTypeFactorSourceKind: FfiConverterRustBuffer {
    typealias SwiftType = FactorSourceKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorSourceKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .device

        case 2: return .ledgerHqHardwareWallet

        case 3: return .offDeviceMnemonic

        case 4: return .trustedContact

        case 5: return .securityQuestions

        case 6: return .arculusCard

        case 7: return .passphrase

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorSourceKind, into buf: inout [UInt8]) {
        switch value {
        case .device:
            writeInt(&buf, Int32(1))

        case .ledgerHqHardwareWallet:
            writeInt(&buf, Int32(2))

        case .offDeviceMnemonic:
            writeInt(&buf, Int32(3))

        case .trustedContact:
            writeInt(&buf, Int32(4))

        case .securityQuestions:
            writeInt(&buf, Int32(5))

        case .arculusCard:
            writeInt(&buf, Int32(6))

        case .passphrase:
            writeInt(&buf, Int32(7))
        }
    }
}

public func FfiConverterTypeFactorSourceKind_lift(_ buf: RustBuffer) throws -> FactorSourceKind {
    return try FfiConverterTypeFactorSourceKind.lift(buf)
}

public func FfiConverterTypeFactorSourceKind_lower(_ value: FactorSourceKind) -> RustBuffer {
    return FfiConverterTypeFactorSourceKind.lower(value)
}

extension FactorSourceKind: Sendable {}
extension FactorSourceKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Fiat currency to measure and display the value of some XRD or other Radix assets value/worth in.
 */

public enum FiatCurrency {
    /**
     * American dollars.
     */
    case usd
    /**
     * Swedish krona.
     */
    case sek
}

public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = FiatCurrency

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .usd

        case 2: return .sek

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        switch value {
        case .usd:
            writeInt(&buf, Int32(1))

        case .sek:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(buf)
}

public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
    return FfiConverterTypeFiatCurrency.lower(value)
}

extension FiatCurrency: Sendable {}
extension FiatCurrency: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FungibleResourceIndicator {
    case guaranteed(decimal: Decimal192
    )
    case predicted(predictedDecimal: PredictedDecimal
    )
}

public struct FfiConverterTypeFungibleResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = FungibleResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FungibleResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .guaranteed(decimal: FfiConverterTypeDecimal192.read(from: &buf)
            )

        case 2: return try .predicted(predictedDecimal: FfiConverterTypePredictedDecimal.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FungibleResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        case let .guaranteed(decimal):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal192.write(decimal, into: &buf)

        case let .predicted(predictedDecimal):
            writeInt(&buf, Int32(2))
            FfiConverterTypePredictedDecimal.write(predictedDecimal, into: &buf)
        }
    }
}

public func FfiConverterTypeFungibleResourceIndicator_lift(_ buf: RustBuffer) throws -> FungibleResourceIndicator {
    return try FfiConverterTypeFungibleResourceIndicator.lift(buf)
}

public func FfiConverterTypeFungibleResourceIndicator_lower(_ value: FungibleResourceIndicator) -> RustBuffer {
    return FfiConverterTypeFungibleResourceIndicator.lower(value)
}

extension FungibleResourceIndicator: Sendable {}
extension FungibleResourceIndicator: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HdPathComponent {
    case unsecurifiedComponent(Unsecurified
    )
    case securifiedComponent(SecurifiedU30
    )
}

public struct FfiConverterTypeHDPathComponent: FfiConverterRustBuffer {
    typealias SwiftType = HdPathComponent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HdPathComponent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .unsecurifiedComponent(FfiConverterTypeUnsecurified.read(from: &buf)
            )

        case 2: return try .securifiedComponent(FfiConverterTypeSecurifiedU30.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HdPathComponent, into buf: inout [UInt8]) {
        switch value {
        case let .unsecurifiedComponent(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUnsecurified.write(v1, into: &buf)

        case let .securifiedComponent(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecurifiedU30.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeHDPathComponent_lift(_ buf: RustBuffer) throws -> HdPathComponent {
    return try FfiConverterTypeHDPathComponent.lift(buf)
}

public func FfiConverterTypeHDPathComponent_lower(_ value: HdPathComponent) -> RustBuffer {
    return FfiConverterTypeHDPathComponent.lower(value)
}

extension HdPathComponent: Sendable {}
extension HdPathComponent: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Hardened {
    case unsecurified(UnsecurifiedHardened
    )
    case securified(SecurifiedU30
    )
}

public struct FfiConverterTypeHardened: FfiConverterRustBuffer {
    typealias SwiftType = Hardened

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hardened {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .unsecurified(FfiConverterTypeUnsecurifiedHardened.read(from: &buf)
            )

        case 2: return try .securified(FfiConverterTypeSecurifiedU30.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Hardened, into buf: inout [UInt8]) {
        switch value {
        case let .unsecurified(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUnsecurifiedHardened.write(v1, into: &buf)

        case let .securified(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecurifiedU30.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeHardened_lift(_ buf: RustBuffer) throws -> Hardened {
    return try FfiConverterTypeHardened.lift(buf)
}

public func FfiConverterTypeHardened_lower(_ value: Hardened) -> RustBuffer {
    return FfiConverterTypeHardened.lower(value)
}

extension Hardened: Sendable {}
extension Hardened: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum describing the different cards that Wallet can display on home page.
 * Each card has an associated content and optional action.
 */

public enum HomeCard {
    /**
     * Content: "Start RadQuest, learn about Radix, earn XRD and collectibles."
     * Action: Redirect user to RadQuest.
     */
    case startRadQuest
    /**
     * Content: "Continue your Radix journey in your browser. Tap to dismiss."
     * Action: None.
     */
    case continueRadQuest
    /**
     * Content: "You can now connect with your Radix Wallet. Tap to dismiss."
     * Action: None.
     */
    case dapp(iconUrl: Url?
    )
    /**
     * Content: "To use Radix Wallet with desktop browsers, finish setup by visiting wallet.radixdlt.com"
     * Action: None
     */
    case connector
    /**
     * Content: "Start digging into Web3 dApps on the Radix Ecosystem directory."
     * Action: Redirect user to Radix Ecosystem.
     */
    case discoverRadixDapps
}

public struct FfiConverterTypeHomeCard: FfiConverterRustBuffer {
    typealias SwiftType = HomeCard

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeCard {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .startRadQuest

        case 2: return .continueRadQuest

        case 3: return try .dapp(iconUrl: FfiConverterOptionTypeUrl.read(from: &buf)
            )

        case 4: return .connector

        case 5: return .discoverRadixDapps

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HomeCard, into buf: inout [UInt8]) {
        switch value {
        case .startRadQuest:
            writeInt(&buf, Int32(1))

        case .continueRadQuest:
            writeInt(&buf, Int32(2))

        case let .dapp(iconUrl):
            writeInt(&buf, Int32(3))
            FfiConverterOptionTypeUrl.write(iconUrl, into: &buf)

        case .connector:
            writeInt(&buf, Int32(4))

        case .discoverRadixDapps:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeHomeCard_lift(_ buf: RustBuffer) throws -> HomeCard {
    return try FfiConverterTypeHomeCard.lift(buf)
}

public func FfiConverterTypeHomeCard_lower(_ value: HomeCard) -> RustBuffer {
    return FfiConverterTypeHomeCard.lower(value)
}

extension HomeCard: Sendable {}
extension HomeCard: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Describes the type of the Host machine and its version. Currently, as it stands at runtime
 * the possible values will be IOS or Android. Other is in place to facilitate unit tests
 * and to make sargon host agnostic.
 */

public enum HostOs {
    case ios(version: String
    )
    case android(vendor: String, version: String)
    case other(name: String, vendor: String, version: String)
}

public struct FfiConverterTypeHostOS: FfiConverterRustBuffer {
    typealias SwiftType = HostOs

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HostOs {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .ios(version: FfiConverterString.read(from: &buf)
            )

        case 2: return try .android(vendor: FfiConverterString.read(from: &buf), version: FfiConverterString.read(from: &buf))

        case 3: return try .other(name: FfiConverterString.read(from: &buf), vendor: FfiConverterString.read(from: &buf), version: FfiConverterString.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HostOs, into buf: inout [UInt8]) {
        switch value {
        case let .ios(version):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(version, into: &buf)

        case let .android(vendor, version):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(vendor, into: &buf)
            FfiConverterString.write(version, into: &buf)

        case let .other(name, vendor, version):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(name, into: &buf)
            FfiConverterString.write(vendor, into: &buf)
            FfiConverterString.write(version, into: &buf)
        }
    }
}

public func FfiConverterTypeHostOS_lift(_ buf: RustBuffer) throws -> HostOs {
    return try FfiConverterTypeHostOS.lift(buf)
}

public func FfiConverterTypeHostOS_lower(_ value: HostOs) -> RustBuffer {
    return FfiConverterTypeHostOS.lower(value)
}

extension HostOs: Sendable {}
extension HostOs: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A discriminator of an `HDPathComponent`.
 */

public enum KeySpace {
    case unsecurified(isHardened: Bool
    )
    case securified
}

public struct FfiConverterTypeKeySpace: FfiConverterRustBuffer {
    typealias SwiftType = KeySpace

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeySpace {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .unsecurified(isHardened: FfiConverterBool.read(from: &buf)
            )

        case 2: return .securified

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeySpace, into buf: inout [UInt8]) {
        switch value {
        case let .unsecurified(isHardened):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(isHardened, into: &buf)

        case .securified:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeKeySpace_lift(_ buf: RustBuffer) throws -> KeySpace {
    return try FfiConverterTypeKeySpace.lift(buf)
}

public func FfiConverterTypeKeySpace_lower(_ value: KeySpace) -> RustBuffer {
    return FfiConverterTypeKeySpace.lower(value)
}

extension KeySpace: Sendable {}
extension KeySpace: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The model of a Ledger HQ hardware wallet NanoS, e.g.
 * *Ledger Nano S+*.
 */

public enum LedgerHardwareWalletModel {
    case nanoS
    case nanoSPlus
    case nanoX
}

public struct FfiConverterTypeLedgerHardwareWalletModel: FfiConverterRustBuffer {
    typealias SwiftType = LedgerHardwareWalletModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LedgerHardwareWalletModel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .nanoS

        case 2: return .nanoSPlus

        case 3: return .nanoX

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LedgerHardwareWalletModel, into buf: inout [UInt8]) {
        switch value {
        case .nanoS:
            writeInt(&buf, Int32(1))

        case .nanoSPlus:
            writeInt(&buf, Int32(2))

        case .nanoX:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeLedgerHardwareWalletModel_lift(_ buf: RustBuffer) throws -> LedgerHardwareWalletModel {
    return try FfiConverterTypeLedgerHardwareWalletModel.lift(buf)
}

public func FfiConverterTypeLedgerHardwareWalletModel_lower(_ value: LedgerHardwareWalletModel) -> RustBuffer {
    return FfiConverterTypeLedgerHardwareWalletModel.lower(value)
}

extension LedgerHardwareWalletModel: Sendable {}
extension LedgerHardwareWalletModel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogFilter: UInt8 {
    /**
     * Logging is turned off
     */
    case off = 0
    /**
     * The "error" level.
     *
     * Designates very serious errors.
     */
    case error = 1
    /**
     * The "warn" level.
     *
     * Designates hazardous situations.
     */
    case warn = 2
    /**
     * The "info" level.
     *
     * Designates useful information.
     */
    case info = 3
    /**
     * The "debug" level.
     *
     * Designates lower priority information.
     */
    case debug = 4
    /**
     * The "trace" level.
     *
     * Designates very low priority, often extremely verbose, information.
     */
    case trace = 5
}

public struct FfiConverterTypeLogFilter: FfiConverterRustBuffer {
    typealias SwiftType = LogFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .off

        case 2: return .error

        case 3: return .warn

        case 4: return .info

        case 5: return .debug

        case 6: return .trace

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogFilter, into buf: inout [UInt8]) {
        switch value {
        case .off:
            writeInt(&buf, Int32(1))

        case .error:
            writeInt(&buf, Int32(2))

        case .warn:
            writeInt(&buf, Int32(3))

        case .info:
            writeInt(&buf, Int32(4))

        case .debug:
            writeInt(&buf, Int32(5))

        case .trace:
            writeInt(&buf, Int32(6))
        }
    }
}

public func FfiConverterTypeLogFilter_lift(_ buf: RustBuffer) throws -> LogFilter {
    return try FfiConverterTypeLogFilter.lift(buf)
}

public func FfiConverterTypeLogFilter_lower(_ value: LogFilter) -> RustBuffer {
    return FfiConverterTypeLogFilter.lower(value)
}

extension LogFilter: Sendable {}
extension LogFilter: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel: UInt8 {
    /**
     * The "error" level.
     *
     * Designates very serious errors.
     */
    case error = 1
    /**
     * The "warn" level.
     *
     * Designates hazardous situations.
     */
    case warn = 2
    /**
     * The "info" level.
     *
     * Designates useful information.
     */
    case info = 3
    /**
     * The "debug" level.
     *
     * Designates lower priority information.
     */
    case debug = 4
    /**
     * The "trace" level.
     *
     * Designates very low priority, often extremely verbose, information.
     */
    case trace = 5
}

public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .error

        case 2: return .warn

        case 3: return .info

        case 4: return .debug

        case 5: return .trace

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        case .error:
            writeInt(&buf, Int32(1))

        case .warn:
            writeInt(&buf, Int32(2))

        case .info:
            writeInt(&buf, Int32(3))

        case .debug:
            writeInt(&buf, Int32(4))

        case .trace:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}

extension LogLevel: Sendable {}
extension LogLevel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of all the encountered addresses in the manifest.
 * This is to be primarily used for the "using dApps" section of the wallet's tx review screen.
 */

public enum ManifestEncounteredComponentAddress {
    case component(ComponentAddress
    )
    case locker(LockerAddress
    )
}

public struct FfiConverterTypeManifestEncounteredComponentAddress: FfiConverterRustBuffer {
    typealias SwiftType = ManifestEncounteredComponentAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestEncounteredComponentAddress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .component(FfiConverterTypeComponentAddress.read(from: &buf)
            )

        case 2: return try .locker(FfiConverterTypeLockerAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ManifestEncounteredComponentAddress, into buf: inout [UInt8]) {
        switch value {
        case let .component(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeComponentAddress.write(v1, into: &buf)

        case let .locker(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLockerAddress.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeManifestEncounteredComponentAddress_lift(_ buf: RustBuffer) throws -> ManifestEncounteredComponentAddress {
    return try FfiConverterTypeManifestEncounteredComponentAddress.lift(buf)
}

public func FfiConverterTypeManifestEncounteredComponentAddress_lower(_ value: ManifestEncounteredComponentAddress) -> RustBuffer {
    return FfiConverterTypeManifestEncounteredComponentAddress.lower(value)
}

extension ManifestEncounteredComponentAddress: Sendable {}
extension ManifestEncounteredComponentAddress: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Message {
    case plainText(plaintext: PlaintextMessage
    )
    case none
}

public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .plainText(plaintext: FfiConverterTypePlaintextMessage.read(from: &buf)
            )

        case 2: return .none

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        switch value {
        case let .plainText(plaintext):
            writeInt(&buf, Int32(1))
            FfiConverterTypePlaintextMessage.write(plaintext, into: &buf)

        case .none:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}

extension Message: Sendable {}
extension Message: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * We explicitly mark content as either String or Bytes - this distinguishes (along with the mime type)
 * whether the message is intended to be displayable as text, or not.
 *
 * This data model ensures that messages intended to be displayable as text are valid unicode strings.
 */

public enum MessageContents {
    case stringMessage(string: String
    )
    case binaryMessage(bagOfBytes: BagOfBytes
    )
}

public struct FfiConverterTypeMessageContents: FfiConverterRustBuffer {
    typealias SwiftType = MessageContents

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageContents {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .stringMessage(string: FfiConverterString.read(from: &buf)
            )

        case 2: return try .binaryMessage(bagOfBytes: FfiConverterTypeBagOfBytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageContents, into buf: inout [UInt8]) {
        switch value {
        case let .stringMessage(string):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(string, into: &buf)

        case let .binaryMessage(bagOfBytes):
            writeInt(&buf, Int32(2))
            FfiConverterTypeBagOfBytes.write(bagOfBytes, into: &buf)
        }
    }
}

public func FfiConverterTypeMessageContents_lift(_ buf: RustBuffer) throws -> MessageContents {
    return try FfiConverterTypeMessageContents.lift(buf)
}

public func FfiConverterTypeMessageContents_lower(_ value: MessageContents) -> RustBuffer {
    return FfiConverterTypeMessageContents.lower(value)
}

extension MessageContents: Sendable {}
extension MessageContents: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageV2 {
    case plainText(plaintext: PlaintextMessage
    )
    case none
}

public struct FfiConverterTypeMessageV2: FfiConverterRustBuffer {
    typealias SwiftType = MessageV2

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageV2 {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .plainText(plaintext: FfiConverterTypePlaintextMessage.read(from: &buf)
            )

        case 2: return .none

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageV2, into buf: inout [UInt8]) {
        switch value {
        case let .plainText(plaintext):
            writeInt(&buf, Int32(1))
            FfiConverterTypePlaintextMessage.write(plaintext, into: &buf)

        case .none:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeMessageV2_lift(_ buf: RustBuffer) throws -> MessageV2 {
    return try FfiConverterTypeMessageV2.lift(buf)
}

public func FfiConverterTypeMessageV2_lower(_ value: MessageV2) -> RustBuffer {
    return FfiConverterTypeMessageV2.lower(value)
}

extension MessageV2: Sendable {}
extension MessageV2: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NetworkId: UInt8 {
    /**
     * Mainnet (0x01 / 0d01)
     *
     * The Radix public network.
     *
     * https://github.com/radixdlt/radixdlt-scrypto/blob/v1.0.1/radix-engine-common/src/network/mod.rs#L79
     */
    case mainnet = 1
    /**
     * Stokenet (0x02 / 0d02)
     *
     * The public testnet for Radix.
     *
     * https://github.com/radixdlt/radixdlt-scrypto/blob/v1.0.1/radix-engine-common/src/network/mod.rs#L71
     */
    case stokenet = 2
    /**
     * Adapanet (0x0a / 0d10
     */
    case adapanet = 10
    /**
     * Nebunet (0x0b / 0d11 )
     *
     * The first Betanet of Babylon
     */
    case nebunet = 11
    /**
     * Kisharnet (0x0c / 0d12)
     *
     * The first release candidate of Babylon (RCnet v1)
     */
    case kisharnet = 12
    /**
     * Ansharnet (0x0d / 0d13)
     *
     * The second release candidate of Babylon (RCnet v2)
     */
    case ansharnet = 13
    /**
     * Zabanet (0x0e / 0d14)
     *
     * The third release candidate of Babylon (RCnet v3)
     */
    case zabanet = 14
    /**
     * Enkinet (0x21 / 0d33)
     *
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L94
     */
    case enkinet = 33
    /**
     * Hammunet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L95
     * Decimal value: 34
     */
    case hammunet = 34
    /**
     * Nergalnet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L96
     * Decimal value: 35
     */
    case nergalnet = 35
    /**
     * Mardunet
     * https://github.com/radixdlt/babylon-node/blob/main/common/src/main/java/com/radixdlt/networks/Network.java#L97
     * Decimal value: 36
     */
    case mardunet = 36
    /**
     * Simulator (0xf2 / 0d242)
     */
    case simulator = 242
}

public struct FfiConverterTypeNetworkID: FfiConverterRustBuffer {
    typealias SwiftType = NetworkId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .mainnet

        case 2: return .stokenet

        case 3: return .adapanet

        case 4: return .nebunet

        case 5: return .kisharnet

        case 6: return .ansharnet

        case 7: return .zabanet

        case 8: return .enkinet

        case 9: return .hammunet

        case 10: return .nergalnet

        case 11: return .mardunet

        case 12: return .simulator

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NetworkId, into buf: inout [UInt8]) {
        switch value {
        case .mainnet:
            writeInt(&buf, Int32(1))

        case .stokenet:
            writeInt(&buf, Int32(2))

        case .adapanet:
            writeInt(&buf, Int32(3))

        case .nebunet:
            writeInt(&buf, Int32(4))

        case .kisharnet:
            writeInt(&buf, Int32(5))

        case .ansharnet:
            writeInt(&buf, Int32(6))

        case .zabanet:
            writeInt(&buf, Int32(7))

        case .enkinet:
            writeInt(&buf, Int32(8))

        case .hammunet:
            writeInt(&buf, Int32(9))

        case .nergalnet:
            writeInt(&buf, Int32(10))

        case .mardunet:
            writeInt(&buf, Int32(11))

        case .simulator:
            writeInt(&buf, Int32(12))
        }
    }
}

public func FfiConverterTypeNetworkID_lift(_ buf: RustBuffer) throws -> NetworkId {
    return try FfiConverterTypeNetworkID.lift(buf)
}

public func FfiConverterTypeNetworkID_lower(_ value: NetworkId) -> RustBuffer {
    return FfiConverterTypeNetworkID.lower(value)
}

extension NetworkId: Sendable {}
extension NetworkId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NetworkMethod {
    case post
    case get
    case head
}

public struct FfiConverterTypeNetworkMethod: FfiConverterRustBuffer {
    typealias SwiftType = NetworkMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .post

        case 2: return .get

        case 3: return .head

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NetworkMethod, into buf: inout [UInt8]) {
        switch value {
        case .post:
            writeInt(&buf, Int32(1))

        case .get:
            writeInt(&buf, Int32(2))

        case .head:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeNetworkMethod_lift(_ buf: RustBuffer) throws -> NetworkMethod {
    return try FfiConverterTypeNetworkMethod.lift(buf)
}

public func FfiConverterTypeNetworkMethod_lower(_ value: NetworkMethod) -> RustBuffer {
    return FfiConverterTypeNetworkMethod.lower(value)
}

extension NetworkMethod: Sendable {}
extension NetworkMethod: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NonFungibleLocalId {
    /**
     * Unsigned integers, up to u64.
     *
     * Create using `NonFungibleLocalId::integer(...)`.
     */
    case integer(value: UInt64
    )
    /**
     * String matching `[_0-9a-zA-Z]{1,64}`.
     *
     * Create using `NonFungibleLocalId::string(...).unwrap()`.
     */
    case str(value: NonFungibleLocalIdString
    )
    /**
     * Bytes, of length between 1 and 64.
     *
     * Create using `NonFungibleLocalId::bytes(...).unwrap()`.
     */
    case bytes(value: NonEmptyMax64Bytes
    )
    /**
     * RUID, v4, variant 1, big endian. See https://www.rfc-editor.org/rfc/rfc4122
     *
     * Create using `NonFungibleLocalId::ruid(...).unwrap()`.
     */
    case ruid(value: Exactly32Bytes
    )
}

public struct FfiConverterTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleLocalId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleLocalId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .integer(value: FfiConverterUInt64.read(from: &buf)
            )

        case 2: return try .str(value: FfiConverterTypeNonFungibleLocalIdString.read(from: &buf)
            )

        case 3: return try .bytes(value: FfiConverterTypeNonEmptyMax64Bytes.read(from: &buf)
            )

        case 4: return try .ruid(value: FfiConverterTypeExactly32Bytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleLocalId, into buf: inout [UInt8]) {
        switch value {
        case let .integer(value):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(value, into: &buf)

        case let .str(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNonFungibleLocalIdString.write(value, into: &buf)

        case let .bytes(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNonEmptyMax64Bytes.write(value, into: &buf)

        case let .ruid(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeExactly32Bytes.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeNonFungibleLocalId_lift(_ buf: RustBuffer) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(buf)
}

public func FfiConverterTypeNonFungibleLocalId_lower(_ value: NonFungibleLocalId) -> RustBuffer {
    return FfiConverterTypeNonFungibleLocalId.lower(value)
}

extension NonFungibleLocalId: Sendable {}
extension NonFungibleLocalId: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NonFungibleResourceIndicator {
    case byAll(predictedAmount: PredictedDecimal, predictedIds: PredictedNonFungibleLocalIds)
    case byAmount(amount: Decimal192, predictedIds: PredictedNonFungibleLocalIds)
    case byIds(ids: [NonFungibleLocalId]
    )
}

public struct FfiConverterTypeNonFungibleResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = NonFungibleResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NonFungibleResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .byAll(predictedAmount: FfiConverterTypePredictedDecimal.read(from: &buf), predictedIds: FfiConverterTypePredictedNonFungibleLocalIds.read(from: &buf))

        case 2: return try .byAmount(amount: FfiConverterTypeDecimal192.read(from: &buf), predictedIds: FfiConverterTypePredictedNonFungibleLocalIds.read(from: &buf))

        case 3: return try .byIds(ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NonFungibleResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        case let .byAll(predictedAmount, predictedIds):
            writeInt(&buf, Int32(1))
            FfiConverterTypePredictedDecimal.write(predictedAmount, into: &buf)
            FfiConverterTypePredictedNonFungibleLocalIds.write(predictedIds, into: &buf)

        case let .byAmount(amount, predictedIds):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDecimal192.write(amount, into: &buf)
            FfiConverterTypePredictedNonFungibleLocalIds.write(predictedIds, into: &buf)

        case let .byIds(ids):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
        }
    }
}

public func FfiConverterTypeNonFungibleResourceIndicator_lift(_ buf: RustBuffer) throws -> NonFungibleResourceIndicator {
    return try FfiConverterTypeNonFungibleResourceIndicator.lift(buf)
}

public func FfiConverterTypeNonFungibleResourceIndicator_lower(_ value: NonFungibleResourceIndicator) -> RustBuffer {
    return FfiConverterTypeNonFungibleResourceIndicator.lower(value)
}

extension NonFungibleResourceIndicator: Sendable {}
extension NonFungibleResourceIndicator: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PersonaDataNameVariant {
    case western
    case eastern
}

public struct FfiConverterTypePersonaDataNameVariant: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataNameVariant

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataNameVariant {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .western

        case 2: return .eastern

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PersonaDataNameVariant, into buf: inout [UInt8]) {
        switch value {
        case .western:
            writeInt(&buf, Int32(1))

        case .eastern:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypePersonaDataNameVariant_lift(_ buf: RustBuffer) throws -> PersonaDataNameVariant {
    return try FfiConverterTypePersonaDataNameVariant.lift(buf)
}

public func FfiConverterTypePersonaDataNameVariant_lower(_ value: PersonaDataNameVariant) -> RustBuffer {
    return FfiConverterTypePersonaDataNameVariant.lower(value)
}

extension PersonaDataNameVariant: Sendable {}
extension PersonaDataNameVariant: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The kind of the Pool, either One, Two or Multi resources.
 */

public enum PoolKind {
    /**
     * A Pool to which user can contribute liquidity of a single
     * resource kind.
     */
    case oneResource
    /**
     * A Pool to which user can contribute liquidity of two different
     * resources
     */
    case twoResources
    /**
     * A Pool to which user can contribute liquidity of many different
     * resources
     */
    case multiResources
}

public struct FfiConverterTypePoolKind: FfiConverterRustBuffer {
    typealias SwiftType = PoolKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PoolKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .oneResource

        case 2: return .twoResources

        case 3: return .multiResources

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PoolKind, into buf: inout [UInt8]) {
        switch value {
        case .oneResource:
            writeInt(&buf, Int32(1))

        case .twoResources:
            writeInt(&buf, Int32(2))

        case .multiResources:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypePoolKind_lift(_ buf: RustBuffer) throws -> PoolKind {
    return try FfiConverterTypePoolKind.lift(buf)
}

public func FfiConverterTypePoolKind_lower(_ value: PoolKind) -> RustBuffer {
    return FfiConverterTypePoolKind.lower(value)
}

extension PoolKind: Sendable {}
extension PoolKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * This is the result of the Pre-Auth preview analysis.
 * It contains all the information needed to compute and display the transaction details to the user.
 */

public enum PreAuthToReview {
    case open(PreAuthOpenManifest
    )
    case enclosed(PreAuthEnclosedManifest
    )
}

public struct FfiConverterTypePreAuthToReview: FfiConverterRustBuffer {
    typealias SwiftType = PreAuthToReview

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreAuthToReview {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .open(FfiConverterTypePreAuthOpenManifest.read(from: &buf)
            )

        case 2: return try .enclosed(FfiConverterTypePreAuthEnclosedManifest.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PreAuthToReview, into buf: inout [UInt8]) {
        switch value {
        case let .open(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypePreAuthOpenManifest.write(v1, into: &buf)

        case let .enclosed(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypePreAuthEnclosedManifest.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypePreAuthToReview_lift(_ buf: RustBuffer) throws -> PreAuthToReview {
    return try FfiConverterTypePreAuthToReview.lift(buf)
}

public func FfiConverterTypePreAuthToReview_lower(_ value: PreAuthToReview) -> RustBuffer {
    return FfiConverterTypePreAuthToReview.lower(value)
}

extension PreAuthToReview: Sendable {}
extension PreAuthToReview: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * This is the result of the Pre-Authorization status polling for a given Subintent.
 */

public enum PreAuthorizationStatus {
    /**
     * The Pre-Authorization has successfully been submitted in a transaction with the given intent hash.
     */
    case success(intentHash: TransactionIntentHash
    )
    /**
     * The Pre-Authorization has expired before being successfully submitted.
     */
    case expired
}

public struct FfiConverterTypePreAuthorizationStatus: FfiConverterRustBuffer {
    typealias SwiftType = PreAuthorizationStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PreAuthorizationStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .success(intentHash: FfiConverterTypeTransactionIntentHash.read(from: &buf)
            )

        case 2: return .expired

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PreAuthorizationStatus, into buf: inout [UInt8]) {
        switch value {
        case let .success(intentHash):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTransactionIntentHash.write(intentHash, into: &buf)

        case .expired:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypePreAuthorizationStatus_lift(_ buf: RustBuffer) throws -> PreAuthorizationStatus {
    return try FfiConverterTypePreAuthorizationStatus.lift(buf)
}

public func FfiConverterTypePreAuthorizationStatus_lower(_ value: PreAuthorizationStatus) -> RustBuffer {
    return FfiConverterTypePreAuthorizationStatus.lower(value)
}

extension PreAuthorizationStatus: Sendable {}
extension PreAuthorizationStatus: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of analyzing a file (bytes), containing either a Profile
 * which we were able to successfully JSON deserialize from the bytes,
 * or EncryptedProfile for which wallets will continue prompting the
 * user for an encryption password and then call JSON deserialize
 * of `EncryptedProfileSnapshot` using [`Profile::new_from_encryption_bytes`](Profile::new_from_encryption_bytes)
 * or if we failed to parse as Profile and `EncryptedProfileSnapshot`
 * then `NotProfile` is used, indicating that the bytes is not at all
 * a Profile.
 */

public enum ProfileFileContents {
    /**
     * The JSON deserialized Profile from some bytes.
     */
    case plaintextProfile(Profile
    )
    /**
     * We successfully JSON deserialized the bytes into
     * `EncryptedProfileSnapshot`, the wallets should proceed
     * with asking the user for the decryption password.
     */
    case encryptedProfile
    /**
     * The bytes is neither a valid `Profile` nor `EncryptedProfile`,
     * it is either a corrupt file or it is not at all a Profile file,
     * contrary to the users beliefs (or the user accidentally selected
     * a random file...)
     */
    case notProfile
}

public struct FfiConverterTypeProfileFileContents: FfiConverterRustBuffer {
    typealias SwiftType = ProfileFileContents

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileFileContents {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .plaintextProfile(FfiConverterTypeProfile.read(from: &buf)
            )

        case 2: return .encryptedProfile

        case 3: return .notProfile

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileFileContents, into buf: inout [UInt8]) {
        switch value {
        case let .plaintextProfile(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeProfile.write(v1, into: &buf)

        case .encryptedProfile:
            writeInt(&buf, Int32(2))

        case .notProfile:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeProfileFileContents_lift(_ buf: RustBuffer) throws -> ProfileFileContents {
    return try FfiConverterTypeProfileFileContents.lift(buf)
}

public func FfiConverterTypeProfileFileContents_lower(_ value: ProfileFileContents) -> RustBuffer {
    return FfiConverterTypeProfileFileContents.lower(value)
}

extension ProfileFileContents: Sendable {}
extension ProfileFileContents: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The version of the Profile Snapshot data format (JSON).
 */

public enum ProfileSnapshotVersion: UInt16 {
    /**
     * The version we went live with on Babylon mainnet 2023-09-28,
     * shipped with iOS 1.0.0 (7) and Android v 1.0.0.
     */
    case v100 = 100
}

public struct FfiConverterTypeProfileSnapshotVersion: FfiConverterRustBuffer {
    typealias SwiftType = ProfileSnapshotVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileSnapshotVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .v100

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileSnapshotVersion, into buf: inout [UInt8]) {
        switch value {
        case .v100:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeProfileSnapshotVersion_lift(_ buf: RustBuffer) throws -> ProfileSnapshotVersion {
    return try FfiConverterTypeProfileSnapshotVersion.lift(buf)
}

public func FfiConverterTypeProfileSnapshotVersion_lower(_ value: ProfileSnapshotVersion) -> RustBuffer {
    return FfiConverterTypeProfileSnapshotVersion.lower(value)
}

extension ProfileSnapshotVersion: Sendable {}
extension ProfileSnapshotVersion: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ProfileState {
    /**
     * When no profile exists in secure storage when OS is booted.
     */
    case none
    /**
     * When the profile snapshot retrieved from secure storage failed to convert into a
     * valid Profile.
     */
    case incompatible(CommonError
    )
    /**
     * When a valid 'Profile' exists. This can either happen when the os boots, or a profile is
     * restored, or the user creates a new profile.
     */
    case loaded(Profile
    )
}

public struct FfiConverterTypeProfileState: FfiConverterRustBuffer {
    typealias SwiftType = ProfileState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .none

        case 2: return try .incompatible(FfiConverterTypeCommonError.read(from: &buf)
            )

        case 3: return try .loaded(FfiConverterTypeProfile.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileState, into buf: inout [UInt8]) {
        switch value {
        case .none:
            writeInt(&buf, Int32(1))

        case let .incompatible(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeCommonError.write(v1, into: &buf)

        case let .loaded(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeProfile.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeProfileState_lift(_ buf: RustBuffer) throws -> ProfileState {
    return try FfiConverterTypeProfileState.lift(buf)
}

public func FfiConverterTypeProfileState_lower(_ value: ProfileState) -> RustBuffer {
    return FfiConverterTypeProfileState.lower(value)
}

extension ProfileState: Sendable {}
extension ProfileState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A tagged union of supported public keys on different curves, supported
 * curves are `secp256k1` and `Curve25519`
 */

public enum PublicKey {
    /**
     * An Ed25519 public key used to verify cryptographic signatures.
     */
    case ed25519(Ed25519PublicKey
    )
    /**
     * A secp256k1 public key used to verify cryptographic signatures (ECDSA signatures).
     */
    case secp256k1(Secp256k1PublicKey
    )
}

public struct FfiConverterTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .ed25519(FfiConverterTypeEd25519PublicKey.read(from: &buf)
            )

        case 2: return try .secp256k1(FfiConverterTypeSecp256k1PublicKey.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        switch value {
        case let .ed25519(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEd25519PublicKey.write(v1, into: &buf)

        case let .secp256k1(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSecp256k1PublicKey.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypePublicKey_lift(_ buf: RustBuffer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(buf)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> RustBuffer {
    return FfiConverterTypePublicKey.lower(value)
}

extension PublicKey: Sendable {}
extension PublicKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Hashes of public keys, either Ed25519PublicKey or Secp256k1PublicKey
 */

public enum PublicKeyHash {
    case ed25519(value: Exactly29Bytes
    )
    case secp256k1(value: Exactly29Bytes
    )
}

public struct FfiConverterTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = PublicKeyHash

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKeyHash {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .ed25519(value: FfiConverterTypeExactly29Bytes.read(from: &buf)
            )

        case 2: return try .secp256k1(value: FfiConverterTypeExactly29Bytes.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicKeyHash, into buf: inout [UInt8]) {
        switch value {
        case let .ed25519(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeExactly29Bytes.write(value, into: &buf)

        case let .secp256k1(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeExactly29Bytes.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypePublicKeyHash_lift(_ buf: RustBuffer) throws -> PublicKeyHash {
    return try FfiConverterTypePublicKeyHash.lift(buf)
}

public func FfiConverterTypePublicKeyHash_lower(_ value: PublicKeyHash) -> RustBuffer {
    return FfiConverterTypePublicKeyHash.lower(value)
}

extension PublicKeyHash: Sendable {}
extension PublicKeyHash: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The purpose of the connection, set by the other client, typically Connector Extension or dApp.
 * As part of the initial linking flow, user will be prompted about kind of link they're trying to make.
 * The user needs to make a conscious decision about general purpose links (because it comes with security risk).
 */

public enum RadixConnectPurpose {
    case general
    case unknown
}

public struct FfiConverterTypeRadixConnectPurpose: FfiConverterRustBuffer {
    typealias SwiftType = RadixConnectPurpose

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RadixConnectPurpose {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .general

        case 2: return .unknown

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RadixConnectPurpose, into buf: inout [UInt8]) {
        switch value {
        case .general:
            writeInt(&buf, Int32(1))

        case .unknown:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeRadixConnectPurpose_lift(_ buf: RustBuffer) throws -> RadixConnectPurpose {
    return try FfiConverterTypeRadixConnectPurpose.lift(buf)
}

public func FfiConverterTypeRadixConnectPurpose_lower(_ value: RadixConnectPurpose) -> RustBuffer {
    return FfiConverterTypeRadixConnectPurpose.lower(value)
}

extension RadixConnectPurpose: Sendable {}
extension RadixConnectPurpose: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A quantifier of a quantity, either `atLeast` or `exactly`, as in
 * "I want AT LEAST 3" or "I want EXACTLY 10".
 *
 * This is typically sent by a Dapp when requesting access to accounts
 * or PersonaData.
 */

public enum RequestedNumberQuantifier {
    /**
     * (Request access to) *exactly* N many of something, where quantity `N` is
     * not part of this enum, e.g. "I want EXACTLY 2 accounts"
     */
    case exactly
    /**
     * (Request access to) *at least* N many of something, where quantity `N` is
     * not part of this enum, e.g. "I want AT LEAST 3 accounts"
     */
    case atLeast
}

public struct FfiConverterTypeRequestedNumberQuantifier: FfiConverterRustBuffer {
    typealias SwiftType = RequestedNumberQuantifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedNumberQuantifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .exactly

        case 2: return .atLeast

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestedNumberQuantifier, into buf: inout [UInt8]) {
        switch value {
        case .exactly:
            writeInt(&buf, Int32(1))

        case .atLeast:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeRequestedNumberQuantifier_lift(_ buf: RustBuffer) throws -> RequestedNumberQuantifier {
    return try FfiConverterTypeRequestedNumberQuantifier.lift(buf)
}

public func FfiConverterTypeRequestedNumberQuantifier_lower(_ value: RequestedNumberQuantifier) -> RustBuffer {
    return FfiConverterTypeRequestedNumberQuantifier.lower(value)
}

extension RequestedNumberQuantifier: Sendable {}
extension RequestedNumberQuantifier: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The set of instructions that is only allowed in manifests created by the
 * wallet itself.
 */

public enum ReservedInstruction {
    case accountLockFee
    case accountSecurify
    case identitySecurify
    case accessControllerMethod
}

public struct FfiConverterTypeReservedInstruction: FfiConverterRustBuffer {
    typealias SwiftType = ReservedInstruction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReservedInstruction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .accountLockFee

        case 2: return .accountSecurify

        case 3: return .identitySecurify

        case 4: return .accessControllerMethod

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReservedInstruction, into buf: inout [UInt8]) {
        switch value {
        case .accountLockFee:
            writeInt(&buf, Int32(1))

        case .accountSecurify:
            writeInt(&buf, Int32(2))

        case .identitySecurify:
            writeInt(&buf, Int32(3))

        case .accessControllerMethod:
            writeInt(&buf, Int32(4))
        }
    }
}

public func FfiConverterTypeReservedInstruction_lift(_ buf: RustBuffer) throws -> ReservedInstruction {
    return try FfiConverterTypeReservedInstruction.lift(buf)
}

public func FfiConverterTypeReservedInstruction_lower(_ value: ReservedInstruction) -> RustBuffer {
    return FfiConverterTypeReservedInstruction.lower(value)
}

extension ReservedInstruction: Sendable {}
extension ReservedInstruction: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An enum representation of an resource for which the user can set up its preferences.
 */

public enum ResourceIdentifier {
    case fungible(ResourceAddress
    )
    case nonFungible(ResourceAddress
    )
    case poolUnit(PoolAddress
    )
}

public struct FfiConverterTypeResourceIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = ResourceIdentifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceIdentifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .fungible(FfiConverterTypeResourceAddress.read(from: &buf)
            )

        case 2: return try .nonFungible(FfiConverterTypeResourceAddress.read(from: &buf)
            )

        case 3: return try .poolUnit(FfiConverterTypePoolAddress.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceIdentifier, into buf: inout [UInt8]) {
        switch value {
        case let .fungible(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(v1, into: &buf)

        case let .nonFungible(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(v1, into: &buf)

        case let .poolUnit(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypePoolAddress.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeResourceIdentifier_lift(_ buf: RustBuffer) throws -> ResourceIdentifier {
    return try FfiConverterTypeResourceIdentifier.lift(buf)
}

public func FfiConverterTypeResourceIdentifier_lower(_ value: ResourceIdentifier) -> RustBuffer {
    return FfiConverterTypeResourceIdentifier.lower(value)
}

extension ResourceIdentifier: Sendable {}
extension ResourceIdentifier: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourceIndicator {
    case fungible(resourceAddress: ResourceAddress, indicator: FungibleResourceIndicator)
    case nonFungible(resourceAddress: ResourceAddress, indicator: NonFungibleResourceIndicator)
}

public struct FfiConverterTypeResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = ResourceIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .fungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), indicator: FfiConverterTypeFungibleResourceIndicator.read(from: &buf))

        case 2: return try .nonFungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), indicator: FfiConverterTypeNonFungibleResourceIndicator.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceIndicator, into buf: inout [UInt8]) {
        switch value {
        case let .fungible(resourceAddress, indicator):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeFungibleResourceIndicator.write(indicator, into: &buf)

        case let .nonFungible(resourceAddress, indicator):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeNonFungibleResourceIndicator.write(indicator, into: &buf)
        }
    }
}

public func FfiConverterTypeResourceIndicator_lift(_ buf: RustBuffer) throws -> ResourceIndicator {
    return try FfiConverterTypeResourceIndicator.lift(buf)
}

public func FfiConverterTypeResourceIndicator_lower(_ value: ResourceIndicator) -> RustBuffer {
    return FfiConverterTypeResourceIndicator.lower(value)
}

extension ResourceIndicator: Sendable {}
extension ResourceIndicator: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The addresses that can be added as exception to the `DepositRule`
 */

public enum ResourceOrNonFungible {
    case resource(value: ResourceAddress
    )
    case nonFungible(value: NonFungibleGlobalId
    )
}

public struct FfiConverterTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = ResourceOrNonFungible

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceOrNonFungible {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .resource(value: FfiConverterTypeResourceAddress.read(from: &buf)
            )

        case 2: return try .nonFungible(value: FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceOrNonFungible, into buf: inout [UInt8]) {
        switch value {
        case let .resource(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(value, into: &buf)

        case let .nonFungible(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNonFungibleGlobalId.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeResourceOrNonFungible_lift(_ buf: RustBuffer) throws -> ResourceOrNonFungible {
    return try FfiConverterTypeResourceOrNonFungible.lift(buf)
}

public func FfiConverterTypeResourceOrNonFungible_lower(_ value: ResourceOrNonFungible) -> RustBuffer {
    return FfiConverterTypeResourceOrNonFungible.lower(value)
}

extension ResourceOrNonFungible: Sendable {}
extension ResourceOrNonFungible: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourcePreference {
    case allowed
    case disallowed
}

public struct FfiConverterTypeResourcePreference: FfiConverterRustBuffer {
    typealias SwiftType = ResourcePreference

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreference {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .allowed

        case 2: return .disallowed

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourcePreference, into buf: inout [UInt8]) {
        switch value {
        case .allowed:
            writeInt(&buf, Int32(1))

        case .disallowed:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeResourcePreference_lift(_ buf: RustBuffer) throws -> ResourcePreference {
    return try FfiConverterTypeResourcePreference.lift(buf)
}

public func FfiConverterTypeResourcePreference_lower(_ value: ResourcePreference) -> RustBuffer {
    return FfiConverterTypeResourcePreference.lower(value)
}

extension ResourcePreference: Sendable {}
extension ResourcePreference: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourcePreferenceUpdate {
    case set(value: ResourcePreference
    )
    case remove
}

public struct FfiConverterTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    typealias SwiftType = ResourcePreferenceUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourcePreferenceUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .set(value: FfiConverterTypeResourcePreference.read(from: &buf)
            )

        case 2: return .remove

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourcePreferenceUpdate, into buf: inout [UInt8]) {
        switch value {
        case let .set(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourcePreference.write(value, into: &buf)

        case .remove:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeResourcePreferenceUpdate_lift(_ buf: RustBuffer) throws -> ResourcePreferenceUpdate {
    return try FfiConverterTypeResourcePreferenceUpdate.lift(buf)
}

public func FfiConverterTypeResourcePreferenceUpdate_lower(_ value: ResourcePreferenceUpdate) -> RustBuffer {
    return FfiConverterTypeResourcePreferenceUpdate.lower(value)
}

extension ResourcePreferenceUpdate: Sendable {}
extension ResourcePreferenceUpdate: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ResourceSpecifier {
    case fungible(resourceAddress: ResourceAddress, amount: Decimal192)
    case nonFungible(resourceAddress: ResourceAddress, ids: [NonFungibleLocalId])
}

public struct FfiConverterTypeResourceSpecifier: FfiConverterRustBuffer {
    typealias SwiftType = ResourceSpecifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceSpecifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .fungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), amount: FfiConverterTypeDecimal192.read(from: &buf))

        case 2: return try .nonFungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), ids: FfiConverterSequenceTypeNonFungibleLocalId.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceSpecifier, into buf: inout [UInt8]) {
        switch value {
        case let .fungible(resourceAddress, amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeDecimal192.write(amount, into: &buf)

        case let .nonFungible(resourceAddress, ids):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterSequenceTypeNonFungibleLocalId.write(ids, into: &buf)
        }
    }
}

public func FfiConverterTypeResourceSpecifier_lift(_ buf: RustBuffer) throws -> ResourceSpecifier {
    return try FfiConverterTypeResourceSpecifier.lift(buf)
}

public func FfiConverterTypeResourceSpecifier_lower(_ value: ResourceSpecifier) -> RustBuffer {
    return FfiConverterTypeResourceSpecifier.lower(value)
}

extension ResourceSpecifier: Sendable {}
extension ResourceSpecifier: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Indicates the visibility of a resource.
 */

public enum ResourceVisibility {
    case hidden
    case visible
}

public struct FfiConverterTypeResourceVisibility: FfiConverterRustBuffer {
    typealias SwiftType = ResourceVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResourceVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .hidden

        case 2: return .visible

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResourceVisibility, into buf: inout [UInt8]) {
        switch value {
        case .hidden:
            writeInt(&buf, Int32(1))

        case .visible:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeResourceVisibility_lift(_ buf: RustBuffer) throws -> ResourceVisibility {
    return try FfiConverterTypeResourceVisibility.lift(buf)
}

public func FfiConverterTypeResourceVisibility_lower(_ value: ResourceVisibility) -> RustBuffer {
    return FfiConverterTypeResourceVisibility.lower(value)
}

extension ResourceVisibility: Sendable {}
extension ResourceVisibility: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Defines the rounding strategy used when you round e.g. `Decimal192`.
 *
 * Following the same naming convention as https://docs.rs/rust_decimal/latest/rust_decimal/enum.RoundingStrategy.html.
 */

public enum RoundingMode {
    /**
     * The number is always rounded toward positive infinity, e.g. `3.1 -> 4`, `-3.1 -> -3`.
     */
    case toPositiveInfinity
    /**
     * The number is always rounded toward negative infinity, e.g. `3.1 -> 3`, `-3.1 -> -4`.
     */
    case toNegativeInfinity
    /**
     * The number is always rounded toward zero, e.g. `3.1 -> 3`, `-3.1 -> -3`.
     */
    case toZero
    /**
     * The number is always rounded away from zero, e.g. `3.1 -> 4`, `-3.1 -> -4`.
     */
    case awayFromZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded toward zero, e.g. `3.5 -> 3`, `-3.5 -> -3`.
     */
    case toNearestMidpointTowardZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded away from zero, e.g. `3.5 -> 4`, `-3.5 -> -4`.
     */
    case toNearestMidpointAwayFromZero
    /**
     * The number is rounded to the nearest, and when it is halfway between two others, it's rounded toward the nearest even number. Also known as "Bankers Rounding".
     */
    case toNearestMidpointToEven
}

public struct FfiConverterTypeRoundingMode: FfiConverterRustBuffer {
    typealias SwiftType = RoundingMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoundingMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .toPositiveInfinity

        case 2: return .toNegativeInfinity

        case 3: return .toZero

        case 4: return .awayFromZero

        case 5: return .toNearestMidpointTowardZero

        case 6: return .toNearestMidpointAwayFromZero

        case 7: return .toNearestMidpointToEven

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoundingMode, into buf: inout [UInt8]) {
        switch value {
        case .toPositiveInfinity:
            writeInt(&buf, Int32(1))

        case .toNegativeInfinity:
            writeInt(&buf, Int32(2))

        case .toZero:
            writeInt(&buf, Int32(3))

        case .awayFromZero:
            writeInt(&buf, Int32(4))

        case .toNearestMidpointTowardZero:
            writeInt(&buf, Int32(5))

        case .toNearestMidpointAwayFromZero:
            writeInt(&buf, Int32(6))

        case .toNearestMidpointToEven:
            writeInt(&buf, Int32(7))
        }
    }
}

public func FfiConverterTypeRoundingMode_lift(_ buf: RustBuffer) throws -> RoundingMode {
    return try FfiConverterTypeRoundingMode.lift(buf)
}

public func FfiConverterTypeRoundingMode_lower(_ value: RoundingMode) -> RustBuffer {
    return FfiConverterTypeRoundingMode.lower(value)
}

extension RoundingMode: Sendable {}
extension RoundingMode: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Elliptic Curves which the SLIP10 derivation algorithm supports.
 *
 * We use SLIP10 for hierarchical deterministic derivation since we
 * prefer using Curve25519 - which is incompatible with BIP32 (BIP44).
 *
 * For for information see [SLIP10 reference](https://github.com/satoshilabs/slips/blob/master/slip-0010.md)
 */

public enum Slip10Curve {
    /**
     * Curve25519 which we use for Ed25519 for EdDSA signatures.
     */
    case curve25519
    /**
     * The bitcoin curve, used by Radix Olympia and still valid
     * to support legacy accounts.
     */
    case secp256k1
}

public struct FfiConverterTypeSLIP10Curve: FfiConverterRustBuffer {
    typealias SwiftType = Slip10Curve

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Slip10Curve {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .curve25519

        case 2: return .secp256k1

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Slip10Curve, into buf: inout [UInt8]) {
        switch value {
        case .curve25519:
            writeInt(&buf, Int32(1))

        case .secp256k1:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeSLIP10Curve_lift(_ buf: RustBuffer) throws -> Slip10Curve {
    return try FfiConverterTypeSLIP10Curve.lift(buf)
}

public func FfiConverterTypeSLIP10Curve_lower(_ value: Slip10Curve) -> RustBuffer {
    return FfiConverterTypeSLIP10Curve.lower(value)
}

extension Slip10Curve: Sendable {}
extension Slip10Curve: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An error kind that might be returned during access to secure storage driver. These errors are
 * android specific and are defined [here](https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt#constants_1)
 * Hosts, can print the error message provided by the system, and can ignore the error if
 * it `is_manual_cancellation`.
 */

public enum SecureStorageAccessErrorKind {
    /**
     * The hardware is unavailable. Try again later.
     */
    case hardwareUnavailable
    /**
     * The sensor was unable to process the current image.
     */
    case unableToProcess
    /**
     * The current operation has been running too long and has timed out.
     */
    case timeout
    /**
     * The operation can't be completed because there is not enough device storage remaining.
     */
    case noSpace
    /**
     * The operation was canceled because the biometric sensor is unavailable.
     * This may happen when the user is switched, the device is locked, or another
     * pending operation prevents it.
     */
    case cancelled
    /**
     * The operation was canceled because the API is locked out due to too many attempts.
     * This occurs after 5 failed attempts, and lasts for 30 seconds.
     */
    case lockout
    /**
     * The operation failed due to a vendor-specific error.
     * This error kind may be used by hardware vendors to extend this list to cover
     * errors that don't fall under one of the other predefined categories. Vendors are
     * responsible for providing the strings for these errors.
     *
     * These messages are typically reserved for internal operations such as enrollment
     * but may be used to express any error that is not otherwise covered.
     * In this case, applications are expected to show the error message, but they are advised
     * not to rely on the message ID, since this may vary by vendor and device.
     */
    case vendor
    /**
     * The operation was canceled because `Lockout` occurred too many times. Biometric
     * authentication is disabled until the user unlocks with their device credential
     * (i.e. PIN, pattern, or password).
     */
    case lockoutPermanent
    /**
     * The user canceled the operation.
     * Upon receiving this, applications should use alternate authentication, such as a password.
     * The application should also provide the user a way of returning to biometric authentication,
     * such as a button.
     */
    case userCancelled
    /**
     * The user does not have any biometrics enrolled.
     */
    case noBiometrics
    /**
     * The device does not have the required authentication hardware.
     */
    case hardwareNotPresent
    /**
     * The user pressed the negative button.
     */
    case negativeButton
    /**
     * The device does not have pin, pattern, or password set up.
     */
    case noDeviceCredential
}

public struct FfiConverterTypeSecureStorageAccessErrorKind: FfiConverterRustBuffer {
    typealias SwiftType = SecureStorageAccessErrorKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageAccessErrorKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .hardwareUnavailable

        case 2: return .unableToProcess

        case 3: return .timeout

        case 4: return .noSpace

        case 5: return .cancelled

        case 6: return .lockout

        case 7: return .vendor

        case 8: return .lockoutPermanent

        case 9: return .userCancelled

        case 10: return .noBiometrics

        case 11: return .hardwareNotPresent

        case 12: return .negativeButton

        case 13: return .noDeviceCredential

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecureStorageAccessErrorKind, into buf: inout [UInt8]) {
        switch value {
        case .hardwareUnavailable:
            writeInt(&buf, Int32(1))

        case .unableToProcess:
            writeInt(&buf, Int32(2))

        case .timeout:
            writeInt(&buf, Int32(3))

        case .noSpace:
            writeInt(&buf, Int32(4))

        case .cancelled:
            writeInt(&buf, Int32(5))

        case .lockout:
            writeInt(&buf, Int32(6))

        case .vendor:
            writeInt(&buf, Int32(7))

        case .lockoutPermanent:
            writeInt(&buf, Int32(8))

        case .userCancelled:
            writeInt(&buf, Int32(9))

        case .noBiometrics:
            writeInt(&buf, Int32(10))

        case .hardwareNotPresent:
            writeInt(&buf, Int32(11))

        case .negativeButton:
            writeInt(&buf, Int32(12))

        case .noDeviceCredential:
            writeInt(&buf, Int32(13))
        }
    }
}

public func FfiConverterTypeSecureStorageAccessErrorKind_lift(_ buf: RustBuffer) throws -> SecureStorageAccessErrorKind {
    return try FfiConverterTypeSecureStorageAccessErrorKind.lift(buf)
}

public func FfiConverterTypeSecureStorageAccessErrorKind_lower(_ value: SecureStorageAccessErrorKind) -> RustBuffer {
    return FfiConverterTypeSecureStorageAccessErrorKind.lower(value)
}

extension SecureStorageAccessErrorKind: Sendable {}
extension SecureStorageAccessErrorKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SecureStorageKey {
    case hostId
    case deviceFactorSourceMnemonic(factorSourceId: FactorSourceIdFromHash
    )
    case profileSnapshot(profileId: ProfileId
    )
}

public struct FfiConverterTypeSecureStorageKey: FfiConverterRustBuffer {
    typealias SwiftType = SecureStorageKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureStorageKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .hostId

        case 2: return try .deviceFactorSourceMnemonic(factorSourceId: FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            )

        case 3: return try .profileSnapshot(profileId: FfiConverterTypeProfileID.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecureStorageKey, into buf: inout [UInt8]) {
        switch value {
        case .hostId:
            writeInt(&buf, Int32(1))

        case let .deviceFactorSourceMnemonic(factorSourceId):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFactorSourceIDFromHash.write(factorSourceId, into: &buf)

        case let .profileSnapshot(profileId):
            writeInt(&buf, Int32(3))
            FfiConverterTypeProfileID.write(profileId, into: &buf)
        }
    }
}

public func FfiConverterTypeSecureStorageKey_lift(_ buf: RustBuffer) throws -> SecureStorageKey {
    return try FfiConverterTypeSecureStorageKey.lift(buf)
}

public func FfiConverterTypeSecureStorageKey_lower(_ value: SecureStorageKey) -> RustBuffer {
    return FfiConverterTypeSecureStorageKey.lower(value)
}

extension SecureStorageKey: Sendable {}
extension SecureStorageKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SecurityQuestionKind {
    case freeform
}

public struct FfiConverterTypeSecurityQuestionKind: FfiConverterRustBuffer {
    typealias SwiftType = SecurityQuestionKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .freeform

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecurityQuestionKind, into buf: inout [UInt8]) {
        switch value {
        case .freeform:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeSecurityQuestionKind_lift(_ buf: RustBuffer) throws -> SecurityQuestionKind {
    return try FfiConverterTypeSecurityQuestionKind.lift(buf)
}

public func FfiConverterTypeSecurityQuestionKind_lower(_ value: SecurityQuestionKind) -> RustBuffer {
    return FfiConverterTypeSecurityQuestionKind.lower(value)
}

extension SecurityQuestionKind: Sendable {}
extension SecurityQuestionKind: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * ❗️ NOT PRODUCTION READY YET ❗️
 * The KDF algorithm used to derive the decryption key from a combination of answers to security questions.
 *
 * N.B. Not to be confused with the much simpler password based Key Derivation used
 * to encrypt Profile part of manual file export.
 * ❗️ NOT PRODUCTION READY YET ❗️
 */

public enum SecurityQuestionsNotProductionReadyKdfScheme {
    /**
     * ❗️ NOT PRODUCTION READY YET ❗️
     * First iteration of KDF for SecurityQuestions
     * ❗️ NOT PRODUCTION READY YET ❗️
     */
    case version1(SecurityQuestionsNotProductionReadyKdfSchemeVersion1
    )
}

public struct FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme: FfiConverterRustBuffer {
    typealias SwiftType = SecurityQuestionsNotProductionReadyKdfScheme

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityQuestionsNotProductionReadyKdfScheme {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .version1(FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecurityQuestionsNotProductionReadyKdfScheme, into buf: inout [UInt8]) {
        switch value {
        case let .version1(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFSchemeVersion1.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme_lift(_ buf: RustBuffer) throws -> SecurityQuestionsNotProductionReadyKdfScheme {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme.lift(buf)
}

public func FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme_lower(_ value: SecurityQuestionsNotProductionReadyKdfScheme) -> RustBuffer {
    return FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_KDFScheme.lower(value)
}

extension SecurityQuestionsNotProductionReadyKdfScheme: Sendable {}
extension SecurityQuestionsNotProductionReadyKdfScheme: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Either a Signature on `Curve25519` or `Secp256k1`
 */

public enum Signature {
    case secp256k1(value: Secp256k1Signature
    )
    case ed25519(value: Ed25519Signature
    )
}

public struct FfiConverterTypeSignature: FfiConverterRustBuffer {
    typealias SwiftType = Signature

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Signature {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(value: FfiConverterTypeSecp256k1Signature.read(from: &buf)
            )

        case 2: return try .ed25519(value: FfiConverterTypeEd25519Signature.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Signature, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecp256k1Signature.write(value, into: &buf)

        case let .ed25519(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEd25519Signature.write(value, into: &buf)
        }
    }
}

public func FfiConverterTypeSignature_lift(_ buf: RustBuffer) throws -> Signature {
    return try FfiConverterTypeSignature.lift(buf)
}

public func FfiConverterTypeSignature_lower(_ value: Signature) -> RustBuffer {
    return FfiConverterTypeSignature.lower(value)
}

extension Signature: Sendable {}
extension Signature: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents any natively supported signature, including public key.
 */

public enum SignatureWithPublicKey {
    case secp256k1(publicKey: Secp256k1PublicKey, signature: Secp256k1Signature)
    case ed25519(publicKey: Ed25519PublicKey, signature: Ed25519Signature)
}

public struct FfiConverterTypeSignatureWithPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = SignatureWithPublicKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureWithPublicKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .secp256k1(publicKey: FfiConverterTypeSecp256k1PublicKey.read(from: &buf), signature: FfiConverterTypeSecp256k1Signature.read(from: &buf))

        case 2: return try .ed25519(publicKey: FfiConverterTypeEd25519PublicKey.read(from: &buf), signature: FfiConverterTypeEd25519Signature.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureWithPublicKey, into buf: inout [UInt8]) {
        switch value {
        case let .secp256k1(publicKey, signature):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecp256k1PublicKey.write(publicKey, into: &buf)
            FfiConverterTypeSecp256k1Signature.write(signature, into: &buf)

        case let .ed25519(publicKey, signature):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEd25519PublicKey.write(publicKey, into: &buf)
            FfiConverterTypeEd25519Signature.write(signature, into: &buf)
        }
    }
}

public func FfiConverterTypeSignatureWithPublicKey_lift(_ buf: RustBuffer) throws -> SignatureWithPublicKey {
    return try FfiConverterTypeSignatureWithPublicKey.lift(buf)
}

public func FfiConverterTypeSignatureWithPublicKey_lower(_ value: SignatureWithPublicKey) -> RustBuffer {
    return FfiConverterTypeSignatureWithPublicKey.lower(value)
}

extension SignatureWithPublicKey: Sendable {}
extension SignatureWithPublicKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the bounds for a simple fungible resource, which can
 * be exact, at most, at least, between, or unknown amount.
 */

public enum SimpleCountedResourceBounds {
    case exact(amount: Decimal192
    )
    case atMost(amount: Decimal192
    )
    case atLeast(amount: Decimal192
    )
    case between(minAmount: Decimal192, maxAmount: Decimal192)
    case unknownAmount
}

public struct FfiConverterTypeSimpleCountedResourceBounds: FfiConverterRustBuffer {
    typealias SwiftType = SimpleCountedResourceBounds

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleCountedResourceBounds {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .exact(amount: FfiConverterTypeDecimal192.read(from: &buf)
            )

        case 2: return try .atMost(amount: FfiConverterTypeDecimal192.read(from: &buf)
            )

        case 3: return try .atLeast(amount: FfiConverterTypeDecimal192.read(from: &buf)
            )

        case 4: return try .between(minAmount: FfiConverterTypeDecimal192.read(from: &buf), maxAmount: FfiConverterTypeDecimal192.read(from: &buf))

        case 5: return .unknownAmount

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SimpleCountedResourceBounds, into buf: inout [UInt8]) {
        switch value {
        case let .exact(amount):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDecimal192.write(amount, into: &buf)

        case let .atMost(amount):
            writeInt(&buf, Int32(2))
            FfiConverterTypeDecimal192.write(amount, into: &buf)

        case let .atLeast(amount):
            writeInt(&buf, Int32(3))
            FfiConverterTypeDecimal192.write(amount, into: &buf)

        case let .between(minAmount, maxAmount):
            writeInt(&buf, Int32(4))
            FfiConverterTypeDecimal192.write(minAmount, into: &buf)
            FfiConverterTypeDecimal192.write(maxAmount, into: &buf)

        case .unknownAmount:
            writeInt(&buf, Int32(5))
        }
    }
}

public func FfiConverterTypeSimpleCountedResourceBounds_lift(_ buf: RustBuffer) throws -> SimpleCountedResourceBounds {
    return try FfiConverterTypeSimpleCountedResourceBounds.lift(buf)
}

public func FfiConverterTypeSimpleCountedResourceBounds_lower(_ value: SimpleCountedResourceBounds) -> RustBuffer {
    return FfiConverterTypeSimpleCountedResourceBounds.lower(value)
}

extension SimpleCountedResourceBounds: Sendable {}
extension SimpleCountedResourceBounds: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the bounds for a simple resource, which can be either fungible or non_fungible.
 */

public enum SimpleResourceBounds {
    case fungible(resourceAddress: ResourceAddress, bounds: SimpleCountedResourceBounds)
    case nonFungible(resourceAddress: ResourceAddress, bounds: SimpleNonFungibleResourceBounds)
}

public struct FfiConverterTypeSimpleResourceBounds: FfiConverterRustBuffer {
    typealias SwiftType = SimpleResourceBounds

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleResourceBounds {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .fungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), bounds: FfiConverterTypeSimpleCountedResourceBounds.read(from: &buf))

        case 2: return try .nonFungible(resourceAddress: FfiConverterTypeResourceAddress.read(from: &buf), bounds: FfiConverterTypeSimpleNonFungibleResourceBounds.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SimpleResourceBounds, into buf: inout [UInt8]) {
        switch value {
        case let .fungible(resourceAddress, bounds):
            writeInt(&buf, Int32(1))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeSimpleCountedResourceBounds.write(bounds, into: &buf)

        case let .nonFungible(resourceAddress, bounds):
            writeInt(&buf, Int32(2))
            FfiConverterTypeResourceAddress.write(resourceAddress, into: &buf)
            FfiConverterTypeSimpleNonFungibleResourceBounds.write(bounds, into: &buf)
        }
    }
}

public func FfiConverterTypeSimpleResourceBounds_lift(_ buf: RustBuffer) throws -> SimpleResourceBounds {
    return try FfiConverterTypeSimpleResourceBounds.lift(buf)
}

public func FfiConverterTypeSimpleResourceBounds_lower(_ value: SimpleResourceBounds) -> RustBuffer {
    return FfiConverterTypeSimpleResourceBounds.lower(value)
}

extension SimpleResourceBounds: Sendable {}
extension SimpleResourceBounds: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionStatus {
    /**
     * The transaction has been successfully processed and is now final.
     */
    case success
    /**
     * The transaction has been permanently rejected with the given `reason`.
     */
    case permanentlyRejected(reason: TransactionStatusReason
    )
    /**
     * The transaction has been temporarily rejected and may be processed in the future.
     */
    case temporarilyRejected(currentEpoch: Epoch
    )
    /**
     * The transaction has failed with the given `reason`.
     */
    case failed(reason: TransactionStatusReason
    )
}

public struct FfiConverterTypeTransactionStatus: FfiConverterRustBuffer {
    typealias SwiftType = TransactionStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .success

        case 2: return try .permanentlyRejected(reason: FfiConverterTypeTransactionStatusReason.read(from: &buf)
            )

        case 3: return try .temporarilyRejected(currentEpoch: FfiConverterTypeEpoch.read(from: &buf)
            )

        case 4: return try .failed(reason: FfiConverterTypeTransactionStatusReason.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionStatus, into buf: inout [UInt8]) {
        switch value {
        case .success:
            writeInt(&buf, Int32(1))

        case let .permanentlyRejected(reason):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTransactionStatusReason.write(reason, into: &buf)

        case let .temporarilyRejected(currentEpoch):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEpoch.write(currentEpoch, into: &buf)

        case let .failed(reason):
            writeInt(&buf, Int32(4))
            FfiConverterTypeTransactionStatusReason.write(reason, into: &buf)
        }
    }
}

public func FfiConverterTypeTransactionStatus_lift(_ buf: RustBuffer) throws -> TransactionStatus {
    return try FfiConverterTypeTransactionStatus.lift(buf)
}

public func FfiConverterTypeTransactionStatus_lower(_ value: TransactionStatus) -> RustBuffer {
    return FfiConverterTypeTransactionStatus.lower(value)
}

extension TransactionStatus: Sendable {}
extension TransactionStatus: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionStatusReason {
    /**
     * The transaction was rejected for an unknown reason.
     */
    case unknown
    /**
     * The transaction was rejected because there was an application error in the worktop.
     */
    case worktopError
}

public struct FfiConverterTypeTransactionStatusReason: FfiConverterRustBuffer {
    typealias SwiftType = TransactionStatusReason

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionStatusReason {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .unknown

        case 2: return .worktopError

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionStatusReason, into buf: inout [UInt8]) {
        switch value {
        case .unknown:
            writeInt(&buf, Int32(1))

        case .worktopError:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeTransactionStatusReason_lift(_ buf: RustBuffer) throws -> TransactionStatusReason {
    return try FfiConverterTypeTransactionStatusReason.lift(buf)
}

public func FfiConverterTypeTransactionStatusReason_lower(_ value: TransactionStatusReason) -> RustBuffer {
    return FfiConverterTypeTransactionStatusReason.lower(value)
}

extension TransactionStatusReason: Sendable {}
extension TransactionStatusReason: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UnsafeStorageKey {
    case factorSourceUserHasWrittenDown
}

public struct FfiConverterTypeUnsafeStorageKey: FfiConverterRustBuffer {
    typealias SwiftType = UnsafeStorageKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsafeStorageKey {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .factorSourceUserHasWrittenDown

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UnsafeStorageKey, into buf: inout [UInt8]) {
        switch value {
        case .factorSourceUserHasWrittenDown:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeUnsafeStorageKey_lift(_ buf: RustBuffer) throws -> UnsafeStorageKey {
    return try FfiConverterTypeUnsafeStorageKey.lift(buf)
}

public func FfiConverterTypeUnsafeStorageKey_lower(_ value: UnsafeStorageKey) -> RustBuffer {
    return FfiConverterTypeUnsafeStorageKey.lower(value)
}

extension UnsafeStorageKey: Sendable {}
extension UnsafeStorageKey: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Unsecurified {
    case unhardenedComponent(Unhardened
    )
    case hardenedComponent(UnsecurifiedHardened
    )
}

public struct FfiConverterTypeUnsecurified: FfiConverterRustBuffer {
    typealias SwiftType = Unsecurified

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unsecurified {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .unhardenedComponent(FfiConverterTypeUnhardened.read(from: &buf)
            )

        case 2: return try .hardenedComponent(FfiConverterTypeUnsecurifiedHardened.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Unsecurified, into buf: inout [UInt8]) {
        switch value {
        case let .unhardenedComponent(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeUnhardened.write(v1, into: &buf)

        case let .hardenedComponent(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeUnsecurifiedHardened.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeUnsecurified_lift(_ buf: RustBuffer) throws -> Unsecurified {
    return try FfiConverterTypeUnsecurified.lift(buf)
}

public func FfiConverterTypeUnsecurified_lower(_ value: Unsecurified) -> RustBuffer {
    return FfiConverterTypeUnsecurified.lower(value)
}

extension Unsecurified: Sendable {}
extension Unsecurified: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents unspecified resources, which can be either none present or
 * may be present with a list of change sources.
 */

public enum UnspecifiedResources {
    /**
     * There are no unspecified resources present
     */
    case nonePresent
    /**
     * There might be non-zero balances of unspecified resources present
     */
    case mayBePresent
}

public struct FfiConverterTypeUnspecifiedResources: FfiConverterRustBuffer {
    typealias SwiftType = UnspecifiedResources

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnspecifiedResources {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .nonePresent

        case 2: return .mayBePresent

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UnspecifiedResources, into buf: inout [UInt8]) {
        switch value {
        case .nonePresent:
            writeInt(&buf, Int32(1))

        case .mayBePresent:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeUnspecifiedResources_lift(_ buf: RustBuffer) throws -> UnspecifiedResources {
    return try FfiConverterTypeUnspecifiedResources.lift(buf)
}

public func FfiConverterTypeUnspecifiedResources_lower(_ value: UnspecifiedResources) -> RustBuffer {
    return FfiConverterTypeUnspecifiedResources.lower(value)
}

extension UnspecifiedResources: Sendable {}
extension UnspecifiedResources: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VectorImageType {
    case svg
    case pdf
}

public struct FfiConverterTypeVectorImageType: FfiConverterRustBuffer {
    typealias SwiftType = VectorImageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VectorImageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .svg

        case 2: return .pdf

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VectorImageType, into buf: inout [UInt8]) {
        switch value {
        case .svg:
            writeInt(&buf, Int32(1))

        case .pdf:
            writeInt(&buf, Int32(2))
        }
    }
}

public func FfiConverterTypeVectorImageType_lift(_ buf: RustBuffer) throws -> VectorImageType {
    return try FfiConverterTypeVectorImageType.lift(buf)
}

public func FfiConverterTypeVectorImageType_lower(_ value: VectorImageType) -> RustBuffer {
    return FfiConverterTypeVectorImageType.lower(value)
}

extension VectorImageType: Sendable {}
extension VectorImageType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionAuthRequestResponseItem {
    case usePersona(WalletToDappInteractionAuthUsePersonaRequestResponseItem
    )
    case loginWithoutChallenge(WalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem
    )
    case loginWithChallenge(WalletToDappInteractionAuthLoginWithChallengeRequestResponseItem
    )
}

public struct FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionAuthRequestResponseItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionAuthRequestResponseItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .usePersona(FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.read(from: &buf)
            )

        case 2: return try .loginWithoutChallenge(FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.read(from: &buf)
            )

        case 3: return try .loginWithChallenge(FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionAuthRequestResponseItem, into buf: inout [UInt8]) {
        switch value {
        case let .usePersona(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionAuthUsePersonaRequestResponseItem.write(v1, into: &buf)

        case let .loginWithoutChallenge(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionAuthLoginWithoutChallengeRequestResponseItem.write(v1, into: &buf)

        case let .loginWithChallenge(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletToDappInteractionAuthLoginWithChallengeRequestResponseItem.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionAuthRequestResponseItem {
    return try FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem_lower(_ value: WalletToDappInteractionAuthRequestResponseItem) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionAuthRequestResponseItem.lower(value)
}

extension WalletToDappInteractionAuthRequestResponseItem: Sendable {}
extension WalletToDappInteractionAuthRequestResponseItem: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A proof of ownership of either an `Account` or a `Persona`.
 */

public enum WalletToDappInteractionProofOfOwnership {
    case account(WalletToDappInteractionAccountProof
    )
    case persona(WalletToDappInteractionPersonaProof
    )
}

public struct FfiConverterTypeWalletToDappInteractionProofOfOwnership: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionProofOfOwnership

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionProofOfOwnership {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .account(FfiConverterTypeWalletToDappInteractionAccountProof.read(from: &buf)
            )

        case 2: return try .persona(FfiConverterTypeWalletToDappInteractionPersonaProof.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionProofOfOwnership, into buf: inout [UInt8]) {
        switch value {
        case let .account(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionAccountProof.write(v1, into: &buf)

        case let .persona(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionPersonaProof.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletToDappInteractionProofOfOwnership_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionProofOfOwnership {
    return try FfiConverterTypeWalletToDappInteractionProofOfOwnership.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionProofOfOwnership_lower(_ value: WalletToDappInteractionProofOfOwnership) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionProofOfOwnership.lower(value)
}

extension WalletToDappInteractionProofOfOwnership: Sendable {}
extension WalletToDappInteractionProofOfOwnership: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionResponse {
    case success(WalletToDappInteractionSuccessResponse
    )
    case failure(WalletToDappInteractionFailureResponse
    )
}

public struct FfiConverterTypeWalletToDappInteractionResponse: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionResponse

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionResponse {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .success(FfiConverterTypeWalletToDappInteractionSuccessResponse.read(from: &buf)
            )

        case 2: return try .failure(FfiConverterTypeWalletToDappInteractionFailureResponse.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionResponse, into buf: inout [UInt8]) {
        switch value {
        case let .success(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionSuccessResponse.write(v1, into: &buf)

        case let .failure(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionFailureResponse.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletToDappInteractionResponse_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionResponse {
    return try FfiConverterTypeWalletToDappInteractionResponse.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionResponse_lower(_ value: WalletToDappInteractionResponse) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionResponse.lower(value)
}

extension WalletToDappInteractionResponse: Sendable {}
extension WalletToDappInteractionResponse: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum WalletToDappInteractionResponseItems {
    case authorizedRequest(WalletToDappInteractionAuthorizedRequestResponseItems
    )
    case unauthorizedRequest(WalletToDappInteractionUnauthorizedRequestResponseItems
    )
    case transaction(WalletToDappInteractionTransactionResponseItems
    )
    case preAuthorization(WalletToDappInteractionPreAuthorizationResponseItems
    )
}

public struct FfiConverterTypeWalletToDappInteractionResponseItems: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionResponseItems

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletToDappInteractionResponseItems {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .authorizedRequest(FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.read(from: &buf)
            )

        case 2: return try .unauthorizedRequest(FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.read(from: &buf)
            )

        case 3: return try .transaction(FfiConverterTypeWalletToDappInteractionTransactionResponseItems.read(from: &buf)
            )

        case 4: return try .preAuthorization(FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletToDappInteractionResponseItems, into buf: inout [UInt8]) {
        switch value {
        case let .authorizedRequest(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeWalletToDappInteractionAuthorizedRequestResponseItems.write(v1, into: &buf)

        case let .unauthorizedRequest(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeWalletToDappInteractionUnauthorizedRequestResponseItems.write(v1, into: &buf)

        case let .transaction(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeWalletToDappInteractionTransactionResponseItems.write(v1, into: &buf)

        case let .preAuthorization(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.write(v1, into: &buf)
        }
    }
}

public func FfiConverterTypeWalletToDappInteractionResponseItems_lift(_ buf: RustBuffer) throws -> WalletToDappInteractionResponseItems {
    return try FfiConverterTypeWalletToDappInteractionResponseItems.lift(buf)
}

public func FfiConverterTypeWalletToDappInteractionResponseItems_lower(_ value: WalletToDappInteractionResponseItems) -> RustBuffer {
    return FfiConverterTypeWalletToDappInteractionResponseItems.lower(value)
}

extension WalletToDappInteractionResponseItems: Sendable {}
extension WalletToDappInteractionResponseItems: Equatable, Hashable {}

private struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeAccountAddress: FfiConverterRustBuffer {
    typealias SwiftType = AccountAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAccountAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAccountAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDappToWalletInteractionAccountsRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionAccountsRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionAccountsRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionAccountsRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDappToWalletInteractionPersonaDataRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionPersonaDataRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionPersonaDataRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDappToWalletInteractionProofOfOwnershipRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionProofOfOwnershipRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionProofOfOwnershipRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDappToWalletInteractionResetRequestItem: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionResetRequestItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionResetRequestItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionResetRequestItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDecimal192: FfiConverterRustBuffer {
    typealias SwiftType = Decimal192?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDecimal192.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDecimal192.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDisplayName: FfiConverterRustBuffer {
    typealias SwiftType = DisplayName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDisplayName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDisplayName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeHierarchicalDeterministicFactorInstance: FfiConverterRustBuffer {
    typealias SwiftType = HierarchicalDeterministicFactorInstance?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHierarchicalDeterministicFactorInstance.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHierarchicalDeterministicFactorInstance.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeIdentityAddress: FfiConverterRustBuffer {
    typealias SwiftType = IdentityAddress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIdentityAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIdentityAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeInstant: FfiConverterRustBuffer {
    typealias SwiftType = Instant?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInstant.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInstant.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePersonaDataEntryName: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataEntryName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataEntryName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataEntryName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePersonaDataIdentifiedName: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataIdentifiedName?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataIdentifiedName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataIdentifiedName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeRequestedQuantity: FfiConverterRustBuffer {
    typealias SwiftType = RequestedQuantity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRequestedQuantity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRequestedQuantity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSharedToDappWithPersonaAccountAddresses: FfiConverterRustBuffer {
    typealias SwiftType = SharedToDappWithPersonaAccountAddresses?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSharedToDappWithPersonaAccountAddresses.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSharedToDappWithPersonaAccountAddresses.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSharedToDappWithPersonaIDsOfPersonaDataEntries: FfiConverterRustBuffer {
    typealias SwiftType = SharedToDappWithPersonaIDsOfPersonaDataEntries?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSharedToDappWithPersonaIDsOfPersonaDataEntries.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeWalletToDappInteractionAccountsRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionAccountsRequestResponseItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletToDappInteractionAccountsRequestResponseItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeWalletToDappInteractionPersonaDataRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionPersonaDataRequestResponseItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletToDappInteractionPersonaDataRequestResponseItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem: FfiConverterRustBuffer {
    typealias SwiftType = WalletToDappInteractionProofOfOwnershipRequestResponseItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWalletToDappInteractionProofOfOwnershipRequestResponseItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSimpleCountedResourceBounds: FfiConverterRustBuffer {
    typealias SwiftType = SimpleCountedResourceBounds?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSimpleCountedResourceBounds.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSimpleCountedResourceBounds.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeAccountAddress: FfiConverterRustBuffer {
    typealias SwiftType = [AccountAddress]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAccountAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAccountAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeAccountForDisplay: FfiConverterRustBuffer {
    typealias SwiftType = [AccountForDisplay]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAccountForDisplay.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAccountForDisplay.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeAssetException: FfiConverterRustBuffer {
    typealias SwiftType = [AssetException]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAssetException.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAssetException.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [EmailAddress]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeEmailAddress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeEmailAddress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryPhoneNumber]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePersonaDataEntryPhoneNumber.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePersonaDataEntryPhoneNumber.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
    typealias SwiftType = [WalletToDappInteractionAccountProof]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeWalletToDappInteractionAccountProof.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeWalletToDappInteractionAccountProof.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceOrNonFungible]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeResourceOrNonFungible.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeBagOfBytes: FfiConverterRustBuffer {
    typealias SwiftType = BagOfBytes?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBagOfBytes.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBagOfBytes.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeDappToWalletInteractionAuthChallengeNonce: FfiConverterRustBuffer {
    typealias SwiftType = DappToWalletInteractionAuthChallengeNonce?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypePersonaDataEntryID: FfiConverterRustBuffer {
    typealias SwiftType = PersonaDataEntryId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePersonaDataEntryID.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePersonaDataEntryID.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeUrl: FfiConverterRustBuffer {
    typealias SwiftType = Url?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUrl.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUrl.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceInt8: FfiConverterRustBuffer {
    typealias SwiftType = [Int8]

    public static func write(_ value: [Int8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Int8] {
        let len: Int32 = try readInt(&buf)
        var seq = [Int8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccount: FfiConverterRustBuffer {
    typealias SwiftType = [Account]

    public static func write(_ value: [Account], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Account] {
        let len: Int32 = try readInt(&buf)
        var seq = [Account]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccount.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountAddress: FfiConverterRustBuffer {
    typealias SwiftType = [AccountAddress]

    public static func write(_ value: [AccountAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountForDisplay: FfiConverterRustBuffer {
    typealias SwiftType = [AccountForDisplay]

    public static func write(_ value: [AccountForDisplay], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountForDisplay.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountForDisplay] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountForDisplay]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountForDisplay.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAppearanceID: FfiConverterRustBuffer {
    typealias SwiftType = [AppearanceId]

    public static func write(_ value: [AppearanceId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAppearanceID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AppearanceId] {
        let len: Int32 = try readInt(&buf)
        var seq = [AppearanceId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAppearanceID.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAssetException: FfiConverterRustBuffer {
    typealias SwiftType = [AssetException]

    public static func write(_ value: [AssetException], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAssetException.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetException] {
        let len: Int32 = try readInt(&buf)
        var seq = [AssetException]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAssetException.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAuthorizedDapp: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedDapp]

    public static func write(_ value: [AuthorizedDapp], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedDapp.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedDapp] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedDapp]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAuthorizedDapp.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAuthorizedPersonaDetailed: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedPersonaDetailed]

    public static func write(_ value: [AuthorizedPersonaDetailed], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedPersonaDetailed.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedPersonaDetailed] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedPersonaDetailed]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAuthorizedPersonaDetailed.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAuthorizedPersonaSimple: FfiConverterRustBuffer {
    typealias SwiftType = [AuthorizedPersonaSimple]

    public static func write(_ value: [AuthorizedPersonaSimple], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAuthorizedPersonaSimple.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AuthorizedPersonaSimple] {
        let len: Int32 = try readInt(&buf)
        var seq = [AuthorizedPersonaSimple]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAuthorizedPersonaSimple.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeBIP39Word: FfiConverterRustBuffer {
    typealias SwiftType = [Bip39Word]

    public static func write(_ value: [Bip39Word], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBIP39Word.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip39Word] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bip39Word]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeBIP39Word.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeBlob: FfiConverterRustBuffer {
    typealias SwiftType = [Blob]

    public static func write(_ value: [Blob], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBlob.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Blob] {
        let len: Int32 = try readInt(&buf)
        var seq = [Blob]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeBlob.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [EmailAddress]

    public static func write(_ value: [EmailAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEmailAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EmailAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [EmailAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeEmailAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeExactly60Bytes: FfiConverterRustBuffer {
    typealias SwiftType = [Exactly60Bytes]

    public static func write(_ value: [Exactly60Bytes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeExactly60Bytes.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Exactly60Bytes] {
        let len: Int32 = try readInt(&buf)
        var seq = [Exactly60Bytes]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeExactly60Bytes.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorInstance: FfiConverterRustBuffer {
    typealias SwiftType = [FactorInstance]

    public static func write(_ value: [FactorInstance], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorInstance.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorInstance] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorInstance]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorInstance.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorInstanceForDebugPurposes: FfiConverterRustBuffer {
    typealias SwiftType = [FactorInstanceForDebugPurposes]

    public static func write(_ value: [FactorInstanceForDebugPurposes], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorInstanceForDebugPurposes.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorInstanceForDebugPurposes] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorInstanceForDebugPurposes]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorInstanceForDebugPurposes.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeGateway: FfiConverterRustBuffer {
    typealias SwiftType = [Gateway]

    public static func write(_ value: [Gateway], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGateway.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Gateway] {
        let len: Int32 = try readInt(&buf)
        var seq = [Gateway]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeGateway.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHierarchicalDeterministicPublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [HierarchicalDeterministicPublicKey]

    public static func write(_ value: [HierarchicalDeterministicPublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHierarchicalDeterministicPublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HierarchicalDeterministicPublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [HierarchicalDeterministicPublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeHierarchicalDeterministicPublicKey.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeIdentityAddress: FfiConverterRustBuffer {
    typealias SwiftType = [IdentityAddress]

    public static func write(_ value: [IdentityAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIdentityAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IdentityAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [IdentityAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeIdentityAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeIntentSignature: FfiConverterRustBuffer {
    typealias SwiftType = [IntentSignature]

    public static func write(_ value: [IntentSignature], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIntentSignature.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IntentSignature] {
        let len: Int32 = try readInt(&buf)
        var seq = [IntentSignature]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeIntentSignature.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNonFungibleGlobalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleGlobalId]

    public static func write(_ value: [NonFungibleGlobalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleGlobalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleGlobalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNonFungibleGlobalId.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeP2PLink: FfiConverterRustBuffer {
    typealias SwiftType = [P2pLink]

    public static func write(_ value: [P2pLink], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeP2PLink.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [P2pLink] {
        let len: Int32 = try readInt(&buf)
        var seq = [P2pLink]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeP2PLink.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerAssetFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetFungibleTransfer]

    public static func write(_ value: [PerAssetFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerAssetFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerAssetNonFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetNonFungibleTransfer]

    public static func write(_ value: [PerAssetNonFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetNonFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetNonFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetNonFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerAssetNonFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerAssetTransfersOfFungibleResource: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetTransfersOfFungibleResource]

    public static func write(_ value: [PerAssetTransfersOfFungibleResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetTransfersOfFungibleResource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetTransfersOfFungibleResource] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetTransfersOfFungibleResource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerAssetTransfersOfFungibleResource.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerAssetTransfersOfNonFungibleResource: FfiConverterRustBuffer {
    typealias SwiftType = [PerAssetTransfersOfNonFungibleResource]

    public static func write(_ value: [PerAssetTransfersOfNonFungibleResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerAssetTransfersOfNonFungibleResource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerAssetTransfersOfNonFungibleResource] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerAssetTransfersOfNonFungibleResource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerAssetTransfersOfNonFungibleResource.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerRecipientAssetTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerRecipientAssetTransfer]

    public static func write(_ value: [PerRecipientAssetTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerRecipientAssetTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientAssetTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerRecipientAssetTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerRecipientAssetTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerRecipientFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerRecipientFungibleTransfer]

    public static func write(_ value: [PerRecipientFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerRecipientFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerRecipientFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerRecipientFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePerRecipientNonFungibleTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [PerRecipientNonFungibleTransfer]

    public static func write(_ value: [PerRecipientNonFungibleTransfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerRecipientNonFungibleTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PerRecipientNonFungibleTransfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PerRecipientNonFungibleTransfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePerRecipientNonFungibleTransfer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersona: FfiConverterRustBuffer {
    typealias SwiftType = [Persona]

    public static func write(_ value: [Persona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Persona] {
        let len: Int32 = try readInt(&buf)
        var seq = [Persona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersona.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataEntryPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryPhoneNumber]

    public static func write(_ value: [PersonaDataEntryPhoneNumber], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataEntryPhoneNumber.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataEntryPhoneNumber] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataEntryPhoneNumber]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataEntryPhoneNumber.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataIdentifiedEmailAddress: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataIdentifiedEmailAddress]

    public static func write(_ value: [PersonaDataIdentifiedEmailAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataIdentifiedEmailAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataIdentifiedEmailAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataIdentifiedEmailAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataIdentifiedEmailAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataIdentifiedPhoneNumber: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataIdentifiedPhoneNumber]

    public static func write(_ value: [PersonaDataIdentifiedPhoneNumber], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataIdentifiedPhoneNumber.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataIdentifiedPhoneNumber] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataIdentifiedPhoneNumber]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataIdentifiedPhoneNumber.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePoolAddress: FfiConverterRustBuffer {
    typealias SwiftType = [PoolAddress]

    public static func write(_ value: [PoolAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePoolAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PoolAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [PoolAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePoolAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeProfileNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [ProfileNetwork]

    public static func write(_ value: [ProfileNetwork], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProfileNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ProfileNetwork] {
        let len: Int32 = try readInt(&buf)
        var seq = [ProfileNetwork]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeProfileNetwork.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceAddress: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceAddress]

    public static func write(_ value: [ResourceAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceAppPreference: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceAppPreference]

    public static func write(_ value: [ResourceAppPreference], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceAppPreference.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAppPreference] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceAppPreference]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceAppPreference.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityStructureOfFactorSourceIDs]

    public static func write(_ value: [SecurityStructureOfFactorSourceIDs], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurityStructureOfFactorSourceIDs.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityStructureOfFactorSourceIDs] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityStructureOfFactorSourceIDs]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSecurityStructureOfFactorSourceIDs.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSecurityStructureOfFactorSources: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityStructureOfFactorSources]

    public static func write(_ value: [SecurityStructureOfFactorSources], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurityStructureOfFactorSources.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityStructureOfFactorSources] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityStructureOfFactorSources]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSecurityStructureOfFactorSources.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityNotProductionReadyQuestion]

    public static func write(_ value: [SecurityNotProductionReadyQuestion], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityNotProductionReadyQuestion] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityNotProductionReadyQuestion]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSecurity_NOT_PRODUCTION_READY_Question.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer: FfiConverterRustBuffer {
    typealias SwiftType = [SecurityNotProductionReadyQuestionAndAnswer]

    public static func write(_ value: [SecurityNotProductionReadyQuestionAndAnswer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SecurityNotProductionReadyQuestionAndAnswer] {
        let len: Int32 = try readInt(&buf)
        var seq = [SecurityNotProductionReadyQuestionAndAnswer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeStakeClaim: FfiConverterRustBuffer {
    typealias SwiftType = [StakeClaim]

    public static func write(_ value: [StakeClaim], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStakeClaim.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [StakeClaim] {
        let len: Int32 = try readInt(&buf)
        var seq = [StakeClaim]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeStakeClaim.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTrackedPoolContribution: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedPoolContribution]

    public static func write(_ value: [TrackedPoolContribution], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedPoolContribution.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedPoolContribution] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedPoolContribution]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTrackedPoolContribution.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTrackedPoolRedemption: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedPoolRedemption]

    public static func write(_ value: [TrackedPoolRedemption], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedPoolRedemption.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedPoolRedemption] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedPoolRedemption]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTrackedPoolRedemption.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTrackedValidatorClaim: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedValidatorClaim]

    public static func write(_ value: [TrackedValidatorClaim], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedValidatorClaim.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorClaim] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedValidatorClaim]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTrackedValidatorClaim.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTrackedValidatorStake: FfiConverterRustBuffer {
    typealias SwiftType = [TrackedValidatorStake]

    public static func write(_ value: [TrackedValidatorStake], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTrackedValidatorStake.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TrackedValidatorStake] {
        let len: Int32 = try readInt(&buf)
        var seq = [TrackedValidatorStake]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTrackedValidatorStake.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeTransactionGuarantee: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionGuarantee]

    public static func write(_ value: [TransactionGuarantee], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionGuarantee.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionGuarantee] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionGuarantee]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTransactionGuarantee.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeValidatorAddress: FfiConverterRustBuffer {
    typealias SwiftType = [ValidatorAddress]

    public static func write(_ value: [ValidatorAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeValidatorAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ValidatorAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [ValidatorAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeValidatorAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeWalletInteractionWalletAccount: FfiConverterRustBuffer {
    typealias SwiftType = [WalletInteractionWalletAccount]

    public static func write(_ value: [WalletInteractionWalletAccount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletInteractionWalletAccount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletInteractionWalletAccount] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletInteractionWalletAccount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeWalletInteractionWalletAccount.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeWalletToDappInteractionAccountProof: FfiConverterRustBuffer {
    typealias SwiftType = [WalletToDappInteractionAccountProof]

    public static func write(_ value: [WalletToDappInteractionAccountProof], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletToDappInteractionAccountProof.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletToDappInteractionAccountProof] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletToDappInteractionAccountProof]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeWalletToDappInteractionAccountProof.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountLockerClaimableResource: FfiConverterRustBuffer {
    typealias SwiftType = [AccountLockerClaimableResource]

    public static func write(_ value: [AccountLockerClaimableResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountLockerClaimableResource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountLockerClaimableResource] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountLockerClaimableResource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountLockerClaimableResource.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = [AccountOrPersona]

    public static func write(_ value: [AccountOrPersona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountOrPersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountOrPersona] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountOrPersona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountOrPersona.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAccountWithdraw: FfiConverterRustBuffer {
    typealias SwiftType = [AccountWithdraw]

    public static func write(_ value: [AccountWithdraw], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAccountWithdraw.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountWithdraw] {
        let len: Int32 = try readInt(&buf)
        var seq = [AccountWithdraw]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAccountWithdraw.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAddress: FfiConverterRustBuffer {
    typealias SwiftType = [Address]

    public static func write(_ value: [Address], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Address] {
        let len: Int32 = try readInt(&buf)
        var seq = [Address]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAddressOfAccountOrPersona: FfiConverterRustBuffer {
    typealias SwiftType = [AddressOfAccountOrPersona]

    public static func write(_ value: [AddressOfAccountOrPersona], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAddressOfAccountOrPersona.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AddressOfAccountOrPersona] {
        let len: Int32 = try readInt(&buf)
        var seq = [AddressOfAccountOrPersona]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAddressOfAccountOrPersona.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeBIP39WordCount: FfiConverterRustBuffer {
    typealias SwiftType = [Bip39WordCount]

    public static func write(_ value: [Bip39WordCount], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeBIP39WordCount.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Bip39WordCount] {
        let len: Int32 = try readInt(&buf)
        var seq = [Bip39WordCount]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeBIP39WordCount.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeDerivationPath: FfiConverterRustBuffer {
    typealias SwiftType = [DerivationPath]

    public static func write(_ value: [DerivationPath], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivationPath.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationPath] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivationPath]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeDerivationPath.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeDerivationPathScheme: FfiConverterRustBuffer {
    typealias SwiftType = [DerivationPathScheme]

    public static func write(_ value: [DerivationPathScheme], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivationPathScheme.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationPathScheme] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivationPathScheme]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeDerivationPathScheme.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeDetailedManifestClass: FfiConverterRustBuffer {
    typealias SwiftType = [DetailedManifestClass]

    public static func write(_ value: [DetailedManifestClass], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDetailedManifestClass.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DetailedManifestClass] {
        let len: Int32 = try readInt(&buf)
        var seq = [DetailedManifestClass]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeDetailedManifestClass.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeEntityFlag: FfiConverterRustBuffer {
    typealias SwiftType = [EntityFlag]

    public static func write(_ value: [EntityFlag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEntityFlag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityFlag] {
        let len: Int32 = try readInt(&buf)
        var seq = [EntityFlag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeEntityFlag.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeEventKind: FfiConverterRustBuffer {
    typealias SwiftType = [EventKind]

    public static func write(_ value: [EventKind], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEventKind.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EventKind] {
        let len: Int32 = try readInt(&buf)
        var seq = [EventKind]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeEventKind.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorSource: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSource]

    public static func write(_ value: [FactorSource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSource] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorSource.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorSourceFlag: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSourceFlag]

    public static func write(_ value: [FactorSourceFlag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSourceFlag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceFlag] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSourceFlag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorSourceFlag.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeFactorSourceID: FfiConverterRustBuffer {
    typealias SwiftType = [FactorSourceId]

    public static func write(_ value: [FactorSourceId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFactorSourceID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceId] {
        let len: Int32 = try readInt(&buf)
        var seq = [FactorSourceId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeFactorSourceID.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHDPathComponent: FfiConverterRustBuffer {
    typealias SwiftType = [HdPathComponent]

    public static func write(_ value: [HdPathComponent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHDPathComponent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HdPathComponent] {
        let len: Int32 = try readInt(&buf)
        var seq = [HdPathComponent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeHDPathComponent.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeHomeCard: FfiConverterRustBuffer {
    typealias SwiftType = [HomeCard]

    public static func write(_ value: [HomeCard], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHomeCard.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HomeCard] {
        let len: Int32 = try readInt(&buf)
        var seq = [HomeCard]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeHomeCard.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeLogFilter: FfiConverterRustBuffer {
    typealias SwiftType = [LogFilter]

    public static func write(_ value: [LogFilter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLogFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LogFilter] {
        let len: Int32 = try readInt(&buf)
        var seq = [LogFilter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeLogFilter.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = [LogLevel]

    public static func write(_ value: [LogLevel], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLogLevel.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LogLevel] {
        let len: Int32 = try readInt(&buf)
        var seq = [LogLevel]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeLogLevel.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeManifestEncounteredComponentAddress: FfiConverterRustBuffer {
    typealias SwiftType = [ManifestEncounteredComponentAddress]

    public static func write(_ value: [ManifestEncounteredComponentAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeManifestEncounteredComponentAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ManifestEncounteredComponentAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [ManifestEncounteredComponentAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeManifestEncounteredComponentAddress.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNetworkID: FfiConverterRustBuffer {
    typealias SwiftType = [NetworkId]

    public static func write(_ value: [NetworkId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNetworkID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NetworkId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NetworkId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNetworkID.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeNonFungibleLocalId: FfiConverterRustBuffer {
    typealias SwiftType = [NonFungibleLocalId]

    public static func write(_ value: [NonFungibleLocalId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNonFungibleLocalId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleLocalId] {
        let len: Int32 = try readInt(&buf)
        var seq = [NonFungibleLocalId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNonFungibleLocalId.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePublicKeyHash: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKeyHash]

    public static func write(_ value: [PublicKeyHash], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKeyHash.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKeyHash] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKeyHash]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePublicKeyHash.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeReservedInstruction: FfiConverterRustBuffer {
    typealias SwiftType = [ReservedInstruction]

    public static func write(_ value: [ReservedInstruction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReservedInstruction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReservedInstruction] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReservedInstruction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeReservedInstruction.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceIdentifier]

    public static func write(_ value: [ResourceIdentifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceIdentifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceIdentifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceIdentifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceIdentifier.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceIndicator: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceIndicator]

    public static func write(_ value: [ResourceIndicator], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceIndicator.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceIndicator] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceIndicator]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceIndicator.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceOrNonFungible]

    public static func write(_ value: [ResourceOrNonFungible], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceOrNonFungible.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceOrNonFungible] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceOrNonFungible]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceOrNonFungible.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeResourceSpecifier: FfiConverterRustBuffer {
    typealias SwiftType = [ResourceSpecifier]

    public static func write(_ value: [ResourceSpecifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeResourceSpecifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceSpecifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [ResourceSpecifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeResourceSpecifier.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSLIP10Curve: FfiConverterRustBuffer {
    typealias SwiftType = [Slip10Curve]

    public static func write(_ value: [Slip10Curve], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSLIP10Curve.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Slip10Curve] {
        let len: Int32 = try readInt(&buf)
        var seq = [Slip10Curve]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSLIP10Curve.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeSimpleResourceBounds: FfiConverterRustBuffer {
    typealias SwiftType = [SimpleResourceBounds]

    public static func write(_ value: [SimpleResourceBounds], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSimpleResourceBounds.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SimpleResourceBounds] {
        let len: Int32 = try readInt(&buf)
        var seq = [SimpleResourceBounds]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSimpleResourceBounds.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeWalletToDappInteractionProofOfOwnership: FfiConverterRustBuffer {
    typealias SwiftType = [WalletToDappInteractionProofOfOwnership]

    public static func write(_ value: [WalletToDappInteractionProofOfOwnership], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWalletToDappInteractionProofOfOwnership.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WalletToDappInteractionProofOfOwnership] {
        let len: Int32 = try readInt(&buf)
        var seq = [WalletToDappInteractionProofOfOwnership]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeWalletToDappInteractionProofOfOwnership.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceSequenceTypeFactorInstanceForDebugPurposes: FfiConverterRustBuffer {
    typealias SwiftType = [[FactorInstanceForDebugPurposes]]

    public static func write(_ value: [[FactorInstanceForDebugPurposes]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceTypeFactorInstanceForDebugPurposes.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[FactorInstanceForDebugPurposes]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[FactorInstanceForDebugPurposes]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterSequenceTypeFactorInstanceForDebugPurposes.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypePersonaDataEntryID: FfiConverterRustBuffer {
    typealias SwiftType = [PersonaDataEntryId]

    public static func write(_ value: [PersonaDataEntryId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePersonaDataEntryID.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PersonaDataEntryId] {
        let len: Int32 = try readInt(&buf)
        var seq = [PersonaDataEntryId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePersonaDataEntryID.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressBool: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressTypeAccountDeposits: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: AccountDeposits], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterTypeAccountDeposits.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: AccountDeposits] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: AccountDeposits]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterTypeAccountDeposits.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressTypeDepositRule: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: DepositRule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterTypeDepositRule.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: DepositRule] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: DepositRule]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterTypeDepositRule.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressSequenceTypeAccountWithdraw: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [AccountWithdraw]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterSequenceTypeAccountWithdraw.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [AccountWithdraw]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [AccountWithdraw]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterSequenceTypeAccountWithdraw.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceIndicator: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [ResourceIndicator]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterSequenceTypeResourceIndicator.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceIndicator]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [ResourceIndicator]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceIndicator.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressSequenceTypeResourceOrNonFungible: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [ResourceOrNonFungible]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterSequenceTypeResourceOrNonFungible.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceOrNonFungible]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [ResourceOrNonFungible]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterSequenceTypeResourceOrNonFungible.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeAccountAddressDictionaryTypeResourceAddressTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    public static func write(_ value: [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeAccountAddress.write(key, into: &buf)
            FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]] {
        let len: Int32 = try readInt(&buf)
        var dict = [AccountAddress: [ResourceAddress: ResourcePreferenceUpdate]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeAccountAddress.read(from: &buf)
            let value = try FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeFactorSourceIDFromHashSequenceSequenceTypeFactorInstanceForDebugPurposes: FfiConverterRustBuffer {
    public static func write(_ value: [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeFactorSourceIDFromHash.write(key, into: &buf)
            FfiConverterSequenceSequenceTypeFactorInstanceForDebugPurposes.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]] {
        let len: Int32 = try readInt(&buf)
        var dict = [FactorSourceIdFromHash: [[FactorInstanceForDebugPurposes]]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeFactorSourceIDFromHash.read(from: &buf)
            let value = try FfiConverterSequenceSequenceTypeFactorInstanceForDebugPurposes.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeNonFungibleGlobalIdTypeUnstakeData: FfiConverterRustBuffer {
    public static func write(_ value: [NonFungibleGlobalId: UnstakeData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeNonFungibleGlobalId.write(key, into: &buf)
            FfiConverterTypeUnstakeData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NonFungibleGlobalId: UnstakeData] {
        let len: Int32 = try readInt(&buf)
        var dict = [NonFungibleGlobalId: UnstakeData]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeNonFungibleGlobalId.read(from: &buf)
            let value = try FfiConverterTypeUnstakeData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeResourceAddressTypeDecimal192: FfiConverterRustBuffer {
    public static func write(_ value: [ResourceAddress: Decimal192], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeResourceAddress.write(key, into: &buf)
            FfiConverterTypeDecimal192.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: Decimal192] {
        let len: Int32 = try readInt(&buf)
        var dict = [ResourceAddress: Decimal192]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeResourceAddress.read(from: &buf)
            let value = try FfiConverterTypeDecimal192.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeResourceAddressTypeNewlyCreatedResource: FfiConverterRustBuffer {
    public static func write(_ value: [ResourceAddress: NewlyCreatedResource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeResourceAddress.write(key, into: &buf)
            FfiConverterTypeNewlyCreatedResource.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: NewlyCreatedResource] {
        let len: Int32 = try readInt(&buf)
        var dict = [ResourceAddress: NewlyCreatedResource]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeResourceAddress.read(from: &buf)
            let value = try FfiConverterTypeNewlyCreatedResource.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private struct FfiConverterDictionaryTypeResourceAddressTypeResourcePreferenceUpdate: FfiConverterRustBuffer {
    public static func write(_ value: [ResourceAddress: ResourcePreferenceUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeResourceAddress.write(key, into: &buf)
            FfiConverterTypeResourcePreferenceUpdate.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ResourceAddress: ResourcePreferenceUpdate] {
        let len: Int32 = try readInt(&buf)
        var dict = [ResourceAddress: ResourcePreferenceUpdate]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterTypeResourceAddress.read(from: &buf)
            let value = try FfiConverterTypeResourcePreferenceUpdate.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Bip39Passphrase = String
public struct FfiConverterTypeBIP39Passphrase: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bip39Passphrase {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Bip39Passphrase, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Bip39Passphrase {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Bip39Passphrase) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeBIP39Passphrase_lift(_ value: RustBuffer) throws -> Bip39Passphrase {
    return try FfiConverterTypeBIP39Passphrase.lift(value)
}

public func FfiConverterTypeBIP39Passphrase_lower(_ value: Bip39Passphrase) -> RustBuffer {
    return FfiConverterTypeBIP39Passphrase.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BagOfBytes = Data

public struct FfiConverterTypeBagOfBytes: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BagOfBytes {
        let builtinValue = try FfiConverterSequenceInt8.read(from: &buf)
        return Data(builtinValue.map { i8 in UInt8(bitPattern: i8) })
    }

    public static func write(_ value: BagOfBytes, into buf: inout [UInt8]) {
        let builtinValue = value.map { u8 in Int8(bitPattern: u8) }
        return FfiConverterSequenceInt8.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BagOfBytes {
        let builtinValue = try FfiConverterSequenceInt8.lift(value)
        return Data(builtinValue.map { i8 in UInt8(bitPattern: i8) })
    }

    public static func lower(_ value: BagOfBytes) -> RustBuffer {
        let builtinValue = value.map { u8 in Int8(bitPattern: u8) }
        return FfiConverterSequenceInt8.lower(builtinValue)
    }
}

public func FfiConverterTypeBagOfBytes_lift(_ value: RustBuffer) throws -> BagOfBytes {
    return try FfiConverterTypeBagOfBytes.lift(value)
}

public func FfiConverterTypeBagOfBytes_lower(_ value: BagOfBytes) -> RustBuffer {
    return FfiConverterTypeBagOfBytes.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DappOrigin = String
public struct FfiConverterTypeDappOrigin: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappOrigin {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: DappOrigin, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DappOrigin {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: DappOrigin) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeDappOrigin_lift(_ value: RustBuffer) throws -> DappOrigin {
    return try FfiConverterTypeDappOrigin.lift(value)
}

public func FfiConverterTypeDappOrigin_lower(_ value: DappOrigin) -> RustBuffer {
    return FfiConverterTypeDappOrigin.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DappToWalletInteractionAuthChallengeNonce = Exactly32Bytes
public struct FfiConverterTypeDappToWalletInteractionAuthChallengeNonce: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DappToWalletInteractionAuthChallengeNonce {
        return try FfiConverterTypeExactly32Bytes.read(from: &buf)
    }

    public static func write(_ value: DappToWalletInteractionAuthChallengeNonce, into buf: inout [UInt8]) {
        return FfiConverterTypeExactly32Bytes.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DappToWalletInteractionAuthChallengeNonce {
        return try FfiConverterTypeExactly32Bytes.lift(value)
    }

    public static func lower(_ value: DappToWalletInteractionAuthChallengeNonce) -> RustBuffer {
        return FfiConverterTypeExactly32Bytes.lower(value)
    }
}

public func FfiConverterTypeDappToWalletInteractionAuthChallengeNonce_lift(_ value: RustBuffer) throws -> DappToWalletInteractionAuthChallengeNonce {
    return try FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.lift(value)
}

public func FfiConverterTypeDappToWalletInteractionAuthChallengeNonce_lower(_ value: DappToWalletInteractionAuthChallengeNonce) -> RustBuffer {
    return FfiConverterTypeDappToWalletInteractionAuthChallengeNonce.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DeviceId = Uuid
public struct FfiConverterTypeDeviceID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: DeviceId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DeviceId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: DeviceId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypeDeviceID_lift(_ value: RustBuffer) throws -> DeviceId {
    return try FfiConverterTypeDeviceID.lift(value)
}

public func FfiConverterTypeDeviceID_lower(_ value: DeviceId) -> RustBuffer {
    return FfiConverterTypeDeviceID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Epoch = UInt64
public struct FfiConverterTypeEpoch: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Epoch {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: Epoch, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> Epoch {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: Epoch) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}

public func FfiConverterTypeEpoch_lift(_ value: UInt64) throws -> Epoch {
    return try FfiConverterTypeEpoch.lift(value)
}

public func FfiConverterTypeEpoch_lower(_ value: Epoch) -> UInt64 {
    return FfiConverterTypeEpoch.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PersonaDataEntryId = Uuid
public struct FfiConverterTypePersonaDataEntryID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PersonaDataEntryId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: PersonaDataEntryId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PersonaDataEntryId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: PersonaDataEntryId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypePersonaDataEntryID_lift(_ value: RustBuffer) throws -> PersonaDataEntryId {
    return try FfiConverterTypePersonaDataEntryID.lift(value)
}

public func FfiConverterTypePersonaDataEntryID_lower(_ value: PersonaDataEntryId) -> RustBuffer {
    return FfiConverterTypePersonaDataEntryID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ProfileId = Uuid
public struct FfiConverterTypeProfileID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: ProfileId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ProfileId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: ProfileId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypeProfileID_lift(_ value: RustBuffer) throws -> ProfileId {
    return try FfiConverterTypeProfileID.lift(value)
}

public func FfiConverterTypeProfileID_lower(_ value: ProfileId) -> RustBuffer {
    return FfiConverterTypeProfileID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SecurityStructureId = Uuid
public struct FfiConverterTypeSecurityStructureID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecurityStructureId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: SecurityStructureId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> SecurityStructureId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: SecurityStructureId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypeSecurityStructureID_lift(_ value: RustBuffer) throws -> SecurityStructureId {
    return try FfiConverterTypeSecurityStructureID.lift(value)
}

public func FfiConverterTypeSecurityStructureID_lower(_ value: SecurityStructureId) -> RustBuffer {
    return FfiConverterTypeSecurityStructureID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SessionId = Uuid
public struct FfiConverterTypeSessionID: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionId {
        return try FfiConverterTypeUuid.read(from: &buf)
    }

    public static func write(_ value: SessionId, into buf: inout [UInt8]) {
        return FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> SessionId {
        return try FfiConverterTypeUuid.lift(value)
    }

    public static func lower(_ value: SessionId) -> RustBuffer {
        return FfiConverterTypeUuid.lower(value)
    }
}

public func FfiConverterTypeSessionID_lift(_ value: RustBuffer) throws -> SessionId {
    return try FfiConverterTypeSessionID.lift(value)
}

public func FfiConverterTypeSessionID_lower(_ value: SessionId) -> RustBuffer {
    return FfiConverterTypeSessionID.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias SubintentVersion = UInt64
public struct FfiConverterTypeSubintentVersion: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SubintentVersion {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: SubintentVersion, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> SubintentVersion {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: SubintentVersion) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}

public func FfiConverterTypeSubintentVersion_lift(_ value: UInt64) throws -> SubintentVersion {
    return try FfiConverterTypeSubintentVersion.lift(value)
}

public func FfiConverterTypeSubintentVersion_lower(_ value: SubintentVersion) -> UInt64 {
    return FfiConverterTypeSubintentVersion.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias TxVersion = UInt64
public struct FfiConverterTypeTXVersion: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TxVersion {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: TxVersion, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> TxVersion {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: TxVersion) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}

public func FfiConverterTypeTXVersion_lift(_ value: UInt64) throws -> TxVersion {
    return try FfiConverterTypeTXVersion.lift(value)
}

public func FfiConverterTypeTXVersion_lower(_ value: TxVersion) -> UInt64 {
    return FfiConverterTypeTXVersion.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Timestamp = Date

public struct FfiConverterTypeTimestamp: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timestamp {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return {
            let stringToDeserialize = builtinValue // this is UniFFIs counterpart to `$0`
            let formatter = ISO8601DateFormatter()
            let formatOptionMS = ISO8601DateFormatter.Options.withFractionalSeconds
            formatter.formatOptions.insert(formatOptionMS)

            func format() -> Date? {
                formatter.date(from: stringToDeserialize)
            }

            if let date = format() {
                return date
            }

            // try without fractional seconds
            formatter.formatOptions.remove(formatOptionMS)
            return format()!
        }()
    }

    public static func write(_ value: Timestamp, into buf: inout [UInt8]) {
        let builtinValue = {
            let dateToSerialize = value // this is UniFFIs counterpart to `$0`
            let formatter = ISO8601DateFormatter()
            formatter.formatOptions.insert(.withFractionalSeconds)
            return formatter.string(from: dateToSerialize)
        }()

        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Timestamp {
        let builtinValue = try FfiConverterString.lift(value)
        return {
            let stringToDeserialize = builtinValue // this is UniFFIs counterpart to `$0`
            let formatter = ISO8601DateFormatter()
            let formatOptionMS = ISO8601DateFormatter.Options.withFractionalSeconds
            formatter.formatOptions.insert(formatOptionMS)

            func format() -> Date? {
                formatter.date(from: stringToDeserialize)
            }

            if let date = format() {
                return date
            }

            // try without fractional seconds
            formatter.formatOptions.remove(formatOptionMS)
            return format()!
        }()
    }

    public static func lower(_ value: Timestamp) -> RustBuffer {
        let builtinValue = {
            let dateToSerialize = value // this is UniFFIs counterpart to `$0`
            let formatter = ISO8601DateFormatter()
            formatter.formatOptions.insert(.withFractionalSeconds)
            return formatter.string(from: dateToSerialize)
        }()

        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeTimestamp_lift(_ value: RustBuffer) throws -> Timestamp {
    return try FfiConverterTypeTimestamp.lift(value)
}

public func FfiConverterTypeTimestamp_lower(_ value: Timestamp) -> RustBuffer {
    return FfiConverterTypeTimestamp.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Url = URL

public struct FfiConverterTypeUrl: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Url {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return URL(string: builtinValue)!
    }

    public static func write(_ value: Url, into buf: inout [UInt8]) {
        let builtinValue = String(describing: value)
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Url {
        let builtinValue = try FfiConverterString.lift(value)
        return URL(string: builtinValue)!
    }

    public static func lower(_ value: Url) -> RustBuffer {
        let builtinValue = String(describing: value)
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeUrl_lift(_ value: RustBuffer) throws -> Url {
    return try FfiConverterTypeUrl.lift(value)
}

public func FfiConverterTypeUrl_lower(_ value: Url) -> RustBuffer {
    return FfiConverterTypeUrl.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Uuid = UUID

public struct FfiConverterTypeUuid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
        let builtinValue = try FfiConverterString.read(from: &buf)
        return UUID(uuidString: builtinValue)!
    }

    public static func write(_ value: Uuid, into buf: inout [UInt8]) {
        let builtinValue = value.uuidString
        return FfiConverterString.write(builtinValue, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Uuid {
        let builtinValue = try FfiConverterString.lift(value)
        return UUID(uuidString: builtinValue)!
    }

    public static func lower(_ value: Uuid) -> RustBuffer {
        let builtinValue = value.uuidString
        return FfiConverterString.lower(builtinValue)
    }
}

public func FfiConverterTypeUuid_lift(_ value: RustBuffer) throws -> Uuid {
    return try FfiConverterTypeUuid.lift(value)
}

public func FfiConverterTypeUuid_lower(_ value: Uuid) -> RustBuffer {
    return FfiConverterTypeUuid.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletInteractionId = String
public struct FfiConverterTypeWalletInteractionId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: WalletInteractionId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> WalletInteractionId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: WalletInteractionId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}

public func FfiConverterTypeWalletInteractionId_lift(_ value: RustBuffer) throws -> WalletInteractionId {
    return try FfiConverterTypeWalletInteractionId.lift(value)
}

public func FfiConverterTypeWalletInteractionId_lower(_ value: WalletInteractionId) -> RustBuffer {
    return FfiConverterTypeWalletInteractionId.lower(value)
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias WalletInteractionVersion = UInt64
public struct FfiConverterTypeWalletInteractionVersion: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletInteractionVersion {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: WalletInteractionVersion, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> WalletInteractionVersion {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: WalletInteractionVersion) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}

public func FfiConverterTypeWalletInteractionVersion_lift(_ value: UInt64) throws -> WalletInteractionVersion {
    return try FfiConverterTypeWalletInteractionVersion.lift(value)
}

public func FfiConverterTypeWalletInteractionVersion_lower(_ value: WalletInteractionVersion) -> UInt64 {
    return FfiConverterTypeWalletInteractionVersion.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

private func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> Void,
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> Void,
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> Void,
    handleError: @escaping (Int8, RustBuffer) -> Void
) -> UniffiForeignFuture {
    let task = Task {
        do {
            try handleSuccess(await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> Void,
    handleError: @escaping (Int8, RustBuffer) -> Void,
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            try handleSuccess(await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
private var UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountSargon() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}

public func accessControllerAddressBech32Address(address: AccessControllerAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_access_controller_address_bech32_address(
            FfiConverterTypeAccessControllerAddress.lower(address), $0
        )
    })
}

public func accessControllerAddressFormatted(address: AccessControllerAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_access_controller_address_formatted(
            FfiConverterTypeAccessControllerAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func accessControllerAddressMapToNetwork(address: AccessControllerAddress, networkId: NetworkId) -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_access_controller_address_map_to_network(
            FfiConverterTypeAccessControllerAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func accessControllerAddressNetworkId(address: AccessControllerAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_access_controller_address_network_id(
            FfiConverterTypeAccessControllerAddress.lower(address), $0
        )
    })
}

public func accountAddressBech32Address(address: AccountAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_account_address_bech32_address(
            FfiConverterTypeAccountAddress.lower(address), $0
        )
    })
}

public func accountAddressFormatted(address: AccountAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_account_address_formatted(
            FfiConverterTypeAccountAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns `false` for all addresses created with `Ed25519PublicKey`s, i.e.
 * for all accounts created by the Babylon Radix Wallets.
 * Returns `true` for all addresses created with `Secp256k1PublicKey`s, i.e.
 * imported from the legacy Olympia desktop application.
 */
public func accountAddressIsLegacy(address: AccountAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_account_address_is_legacy(
            FfiConverterTypeAccountAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func accountAddressMapToNetwork(address: AccountAddress, networkId: NetworkId) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_account_address_map_to_network(
            FfiConverterTypeAccountAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func accountAddressNetworkId(address: AccountAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_account_address_network_id(
            FfiConverterTypeAccountAddress.lower(address), $0
        )
    })
}

public func accountOrAddressOfAccountAddress(recipient: AccountOrAddressOf) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_account_or_address_of_account_address(
            FfiConverterTypeAccountOrAddressOf.lower(recipient), $0
        )
    })
}

public func accountOrPersonaGetId(entity: AccountOrPersona) -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_account_or_persona_get_id(
            FfiConverterTypeAccountOrPersona.lower(entity), $0
        )
    })
}

public func addressFormatted(address: Address, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_address_formatted(
            FfiConverterTypeAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func addressMapToNetwork(address: Address, networkId: NetworkId) -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_address_map_to_network(
            FfiConverterTypeAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func addressNetworkId(address: Address) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_address_network_id(
            FfiConverterTypeAddress.lower(address), $0
        )
    })
}

public func addressOfAccountOrPersonaFormatted(address: AddressOfAccountOrPersona, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_formatted(
            FfiConverterTypeAddressOfAccountOrPersona.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func addressOfAccountOrPersonaMapToNetwork(address: AddressOfAccountOrPersona, networkId: NetworkId) -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_map_to_network(
            FfiConverterTypeAddressOfAccountOrPersona.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func addressOfAccountOrPersonaNetworkId(address: AddressOfAccountOrPersona) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_network_id(
            FfiConverterTypeAddressOfAccountOrPersona.lower(address), $0
        )
    })
}

public func addressOfAccountOrPersonaSampleValuesAll() -> [AddressOfAccountOrPersona] {
    return try! FfiConverterSequenceTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_sample_values_all($0
        )
    })
}

public func addressOfAccountOrPersonaToString(address: AddressOfAccountOrPersona) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_address_of_account_or_persona_to_string(
            FfiConverterTypeAddressOfAccountOrPersona.lower(address), $0
        )
    })
}

public func addressSampleValuesAll() -> [Address] {
    return try! FfiConverterSequenceTypeAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_address_sample_values_all($0
        )
    })
}

public func addressToString(address: Address) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_address_to_string(
            FfiConverterTypeAddress.lower(address), $0
        )
    })
}

public func androidNotarizeHashWithPrivateKeyBytes(privateKeyBytes: Exactly32Bytes, signedIntentHash: SignedTransactionIntentHash) throws -> NotarySignature {
    return try FfiConverterTypeNotarySignature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_android_notarize_hash_with_private_key_bytes(
            FfiConverterTypeExactly32Bytes.lower(privateKeyBytes),
            FfiConverterTypeSignedTransactionIntentHash.lower(signedIntentHash), $0
        )
    })
}

public func androidSecretKeyGetPublicKeyFromPrivateKeyBytes(privateKeyBytes: Exactly32Bytes) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_android_secret_key_get_public_key_from_private_key_bytes(
            FfiConverterTypeExactly32Bytes.lower(privateKeyBytes), $0
        )
    })
}

public func androidSignHashWithPrivateKeyBytes(privateKeyBytes: Exactly32Bytes, hash: Hash) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_android_sign_hash_with_private_key_bytes(
            FfiConverterTypeExactly32Bytes.lower(privateKeyBytes),
            FfiConverterTypeHash.lower(hash), $0
        )
    })
}

public func appPreferencesHasGatewayWithUrl(appPreferences: AppPreferences, url: FfiUrl) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_app_preferences_has_gateway_with_url(
            FfiConverterTypeAppPreferences.lower(appPreferences),
            FfiConverterTypeFfiUrl.lower(url), $0
        )
    })
}

public func appearanceIdsAll() -> [AppearanceId] {
    return try! FfiConverterSequenceTypeAppearanceID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_appearance_ids_all($0
        )
    })
}

public func arculusCardModelToString(model: ArculusCardModel) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_arculus_card_model_to_string(
            FfiConverterTypeArculusCardModel.lower(model), $0
        )
    })
}

public func authorizedDappToJsonBytes(authorizedDapp: AuthorizedDapp) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_authorized_dapp_to_json_bytes(
            FfiConverterTypeAuthorizedDapp.lower(authorizedDapp), $0
        )
    })
}

public func bIP39SeedToBytes(bytes: Bip39Seed) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_b_i_p39_seed_to_bytes(
            FfiConverterTypeBIP39Seed.lower(bytes), $0
        )
    })
}

public func bagOfBytesAppendCafe(to: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_bag_of_bytes_append_cafe(
            FfiConverterTypeBagOfBytes.lower(to), $0
        )
    })
}

public func bagOfBytesAppendDeadbeef(to: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_bag_of_bytes_append_deadbeef(
            FfiConverterTypeBagOfBytes.lower(to), $0
        )
    })
}

public func bagOfBytesPrependCafe(inFrontOf: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_bag_of_bytes_prepend_cafe(
            FfiConverterTypeBagOfBytes.lower(inFrontOf), $0
        )
    })
}

public func bagOfBytesPrependDeadbeef(inFrontOf: BagOfBytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_bag_of_bytes_prepend_deadbeef(
            FfiConverterTypeBagOfBytes.lower(inFrontOf), $0
        )
    })
}

public func bip32ConstantGlobalOffsetHardened() -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_bip32_constant_global_offset_hardened($0
        )
    })
}

public func bip32ConstantGlobalOffsetSecurified() -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_bip32_constant_global_offset_securified($0
        )
    })
}

public func bip39LanguageWordlist(language: Bip39Language) -> [Bip39Word] {
    return try! FfiConverterSequenceTypeBIP39Word.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_bip39_language_wordlist(
            FfiConverterTypeBIP39Language.lower(language), $0
        )
    })
}

public func bip39WordCountAll() -> [Bip39WordCount] {
    return try! FfiConverterSequenceTypeBIP39WordCount.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_bip39_word_count_all($0
        )
    })
}

public func bip44LikePathGetAddressIndex(path: Bip44LikePath) -> HdPathComponent {
    return try! FfiConverterTypeHDPathComponent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_bip44_like_path_get_address_index(
            FfiConverterTypeBIP44LikePath.lower(path), $0
        )
    })
}

public func bip44LikePathToString(path: Bip44LikePath) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_bip44_like_path_to_string(
            FfiConverterTypeBIP44LikePath.lower(path), $0
        )
    })
}

public func blobToBytes(blob: Blob) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_blob_to_bytes(
            FfiConverterTypeBlob.lower(blob), $0
        )
    })
}

public func blobToString(blob: Blob) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_blob_to_string(
            FfiConverterTypeBlob.lower(blob), $0
        )
    })
}

public func blobsListOfBlobs(blobs: Blobs) -> [Blob] {
    return try! FfiConverterSequenceTypeBlob.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_blobs_list_of_blobs(
            FfiConverterTypeBlobs.lower(blobs), $0
        )
    })
}

public func buildInformation() -> SargonBuildInformation {
    return try! FfiConverterTypeSargonBuildInformation.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_build_information($0
        )
    })
}

public func checkIfEncryptedProfileJsonContainsLegacyP2pLinks(jsonStr: String, password: String) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_check_if_encrypted_profile_json_contains_legacy_p2p_links(
            FfiConverterString.lower(jsonStr),
            FfiConverterString.lower(password), $0
        )
    })
}

public func checkIfProfileJsonContainsLegacyP2pLinks(jsonStr: String) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_check_if_profile_json_contains_legacy_p2p_links(
            FfiConverterString.lower(jsonStr), $0
        )
    })
}

public func compiledNotarizedIntentGetBytes(compiledNotarizedIntent: CompiledNotarizedIntent) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_compiled_notarized_intent_get_bytes(
            FfiConverterTypeCompiledNotarizedIntent.lower(compiledNotarizedIntent), $0
        )
    })
}

public func compiledSubintentBytes(compiledIntent: CompiledSubintent) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_compiled_subintent_bytes(
            FfiConverterTypeCompiledSubintent.lower(compiledIntent), $0
        )
    })
}

public func compiledSubintentDecompile(compiledIntent: CompiledSubintent) -> Subintent {
    return try! FfiConverterTypeSubintent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_compiled_subintent_decompile(
            FfiConverterTypeCompiledSubintent.lower(compiledIntent), $0
        )
    })
}

public func compiledTransactionIntentBytes(compiledIntent: CompiledTransactionIntent) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_compiled_transaction_intent_bytes(
            FfiConverterTypeCompiledTransactionIntent.lower(compiledIntent), $0
        )
    })
}

public func compiledTransactionIntentDecompile(compiledIntent: CompiledTransactionIntent) -> TransactionIntent {
    return try! FfiConverterTypeTransactionIntent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_compiled_transaction_intent_decompile(
            FfiConverterTypeCompiledTransactionIntent.lower(compiledIntent), $0
        )
    })
}

public func componentAddressBech32Address(address: ComponentAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_component_address_bech32_address(
            FfiConverterTypeComponentAddress.lower(address), $0
        )
    })
}

public func componentAddressFormatted(address: ComponentAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_component_address_formatted(
            FfiConverterTypeComponentAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns `true` if the ComponentAddress is `global` (i.e. not `internal`)
 */
public func componentAddressIsGlobal(address: ComponentAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_component_address_is_global(
            FfiConverterTypeComponentAddress.lower(address), $0
        )
    })
}

/**
 * Returns `true` if the ComponentAddress is `internal` (i.e. not `global`)
 */
public func componentAddressIsInternal(address: ComponentAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_component_address_is_internal(
            FfiConverterTypeComponentAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func componentAddressMapToNetwork(address: ComponentAddress, networkId: NetworkId) -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_component_address_map_to_network(
            FfiConverterTypeComponentAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func componentAddressNetworkId(address: ComponentAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_component_address_network_id(
            FfiConverterTypeComponentAddress.lower(address), $0
        )
    })
}

public func constantEntityNameMaxLength() -> UInt64 {
    return try! FfiConverterUInt64.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_constant_entity_name_max_length($0
        )
    })
}

public func constantMinRequiredXrdForAccountDeletion() -> Double {
    return try! FfiConverterDouble.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_constant_min_required_xrd_for_account_deletion($0
        )
    })
}

public func dappToWalletInteractionUnvalidatedToJsonBytes(dappToWalletInteractionUnvalidated: DappToWalletInteractionUnvalidated) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_dapp_to_wallet_interaction_unvalidated_to_json_bytes(
            FfiConverterTypeDappToWalletInteractionUnvalidated.lower(dappToWalletInteractionUnvalidated), $0
        )
    })
}

public func dappToWalletInteractionUnvalidatedToJsonString(interactionUnvalidated: DappToWalletInteractionUnvalidated) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_dapp_to_wallet_interaction_unvalidated_to_json_string(
            FfiConverterTypeDappToWalletInteractionUnvalidated.lower(interactionUnvalidated), $0
        )
    })
}

public func debugPrintCompiledNotarizedIntent(compiled: CompiledNotarizedIntent) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_debug_print_compiled_notarized_intent(
            FfiConverterTypeCompiledNotarizedIntent.lower(compiled), $0
        )
    })
}

/**
 * Returns `decimal.abs()`, panics if `decimal` is `Decimal192::MIN`
 */
public func decimalAbs(decimal: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_abs(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * `lhs + rhs``
 */
public func decimalAdd(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_add(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * Clamps `decimal` to zero, i.e. `max(decimal, 0)`
 */
public func decimalClampedToZero(decimal: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_clamped_to_zero(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * `lhs / rhs``
 */
public func decimalDiv(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_div(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

public func decimalFormatted(decimal: Decimal192, locale: LocaleConfig, totalPlaces: UInt8, useGroupingSeparator: Bool) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_formatted(
            FfiConverterTypeDecimal192.lower(decimal),
            FfiConverterTypeLocaleConfig.lower(locale),
            FfiConverterUInt8.lower(totalPlaces),
            FfiConverterBool.lower(useGroupingSeparator), $0
        )
    })
}

/**
 * A human readable, locale respecting string. Does not perform any rounding or truncation.
 */
public func decimalFormattedPlain(decimal: Decimal192, locale: LocaleConfig, useGroupingSeparator: Bool) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_formatted_plain(
            FfiConverterTypeDecimal192.lower(decimal),
            FfiConverterTypeLocaleConfig.lower(locale),
            FfiConverterBool.lower(useGroupingSeparator), $0
        )
    })
}

/**
 * `lhs > rhs`
 */
public func decimalGreaterThan(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_greater_than(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * `lhs >= rhs`
 */
public func decimalGreaterThanOrEqual(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_greater_than_or_equal(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * Whether this decimal is negative.
 */
public func decimalIsNegative(decimal: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_is_negative(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * Whether this decimal is positive.
 */
public func decimalIsPositive(decimal: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_is_positive(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * Whether this decimal is zero.
 */
public func decimalIsZero(decimal: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_is_zero(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * `lhs < rhs`
 */
public func decimalLessThan(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_less_than(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * `lhs <= rhs`
 */
public func decimalLessThanOrEqual(lhs: Decimal192, rhs: Decimal192) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_less_than_or_equal(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * The maximum possible value of `Decimal192`, being:
 * `3138550867693340381917894711603833208051.177722232017256447`
 */
public func decimalMax() -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_max($0
        )
    })
}

/**
 * The minimum possible value of `Decimal192`, being:
 * `-3138550867693340381917894711603833208051.177722232017256448`
 */
public func decimalMin() -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_min($0
        )
    })
}

/**
 * `lhs * rhs``
 */
public func decimalMul(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_mul(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * Negates the `decimal`
 */
public func decimalNeg(decimal: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_neg(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

/**
 * Rounds this number to the specified decimal places.
 *
 * # Panics
 * - Panic if the number of decimal places is not within [0..SCALE(=18)]
 */
public func decimalRound(decimal: Decimal192, decimalPlaces: UInt8, roundingMode: RoundingMode) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_decimal_round(
            FfiConverterTypeDecimal192.lower(decimal),
            FfiConverterUInt8.lower(decimalPlaces),
            FfiConverterTypeRoundingMode.lower(roundingMode), $0
        )
    })
}

/**
 * `lhs - rhs``
 */
public func decimalSub(lhs: Decimal192, rhs: Decimal192) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_sub(
            FfiConverterTypeDecimal192.lower(lhs),
            FfiConverterTypeDecimal192.lower(rhs), $0
        )
    })
}

/**
 * `decimal.to_string()`
 */
public func decimalToString(decimal: Decimal192) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_decimal_to_string(
            FfiConverterTypeDecimal192.lower(decimal), $0
        )
    })
}

public func dependencyInformationToString(info: DependencyInformation) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_dependency_information_to_string(
            FfiConverterTypeDependencyInformation.lower(info), $0
        )
    })
}

public func depositRuleToJsonString(depositRule: DepositRule) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_deposit_rule_to_json_string(
            FfiConverterTypeDepositRule.lower(depositRule), $0
        )
    })
}

public func derivationPathToHdPath(path: DerivationPath) -> HdPath {
    return try! FfiConverterTypeHDPath.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_derivation_path_to_hd_path(
            FfiConverterTypeDerivationPath.lower(path), $0
        )
    })
}

public func derivationPathToString(path: DerivationPath) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_derivation_path_to_string(
            FfiConverterTypeDerivationPath.lower(path), $0
        )
    })
}

public func deviceFactorSourceIsMainBdfs(deviceFactorSource: DeviceFactorSource) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_device_factor_source_is_main_bdfs(
            FfiConverterTypeDeviceFactorSource.lower(deviceFactorSource), $0
        )
    })
}

public func deviceInfoDescriptionToString(deviceInfoDescription: DeviceInfoDescription) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_device_info_description_to_string(
            FfiConverterTypeDeviceInfoDescription.lower(deviceInfoDescription), $0
        )
    })
}

public func deviceInfoToJsonBytes(deviceInfo: DeviceInfo) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_device_info_to_json_bytes(
            FfiConverterTypeDeviceInfo.lower(deviceInfo), $0
        )
    })
}

public func displayNameToJsonString(displayName: DisplayName) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_display_name_to_json_string(
            FfiConverterTypeDisplayName.lower(displayName), $0
        )
    })
}

public func ed25519PublicKeyToBytes(publicKey: Ed25519PublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_ed25519_public_key_to_bytes(
            FfiConverterTypeEd25519PublicKey.lower(publicKey), $0
        )
    })
}

/**
 * Encodes the `Ed25519PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"b7a3c12dc0c8c748ab07525b701122b88bd78f600c76342d27f25e5f92444cde"`
 */
public func ed25519PublicKeyToHex(publicKey: Ed25519PublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_ed25519_public_key_to_hex(
            FfiConverterTypeEd25519PublicKey.lower(publicKey), $0
        )
    })
}

public func ed25519PublicKeyToJsonString(ed25519PublicKey: Ed25519PublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_ed25519_public_key_to_json_string(
            FfiConverterTypeEd25519PublicKey.lower(ed25519PublicKey), $0
        )
    })
}

public func ed25519SignatureToJsonString(ed25519Signature: Ed25519Signature) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_ed25519_signature_to_json_string(
            FfiConverterTypeEd25519Signature.lower(ed25519Signature), $0
        )
    })
}

public func ed25519SignatureToString(signature: Ed25519Signature) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_ed25519_signature_to_string(
            FfiConverterTypeEd25519Signature.lower(signature), $0
        )
    })
}

public func entropy16BytesToBytes(bytes: Entropy16Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_entropy16_bytes_to_bytes(
            FfiConverterTypeEntropy16Bytes.lower(bytes), $0
        )
    })
}

public func entropy20BytesToBytes(bytes: Entropy20Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_entropy20_bytes_to_bytes(
            FfiConverterTypeEntropy20Bytes.lower(bytes), $0
        )
    })
}

public func entropy24BytesToBytes(bytes: Entropy24Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_entropy24_bytes_to_bytes(
            FfiConverterTypeEntropy24Bytes.lower(bytes), $0
        )
    })
}

public func entropy28BytesToBytes(bytes: Entropy28Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_entropy28_bytes_to_bytes(
            FfiConverterTypeEntropy28Bytes.lower(bytes), $0
        )
    })
}

public func entropy32BytesToBytes(bytes: Entropy32Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_entropy32_bytes_to_bytes(
            FfiConverterTypeEntropy32Bytes.lower(bytes), $0
        )
    })
}

public func errorCodeFromError(error: CommonError) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_error_code_from_error(
            FfiConverterTypeCommonError.lower(error), $0
        )
    })
}

public func errorMessageFromError(error: CommonError) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_error_message_from_error(
            FfiConverterTypeCommonError.lower(error), $0
        )
    })
}

public func eventKind(event: Event) -> EventKind {
    return try! FfiConverterTypeEventKind.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_event_kind(
            FfiConverterTypeEvent.lower(event), $0
        )
    })
}

public func eventKindAffectsCurrentAccounts(eventKind: EventKind) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_event_kind_affects_current_accounts(
            FfiConverterTypeEventKind.lower(eventKind), $0
        )
    })
}

public func eventKindAffectsCurrentNetwork(eventKind: EventKind) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_event_kind_affects_current_network(
            FfiConverterTypeEventKind.lower(eventKind), $0
        )
    })
}

public func eventKindAffectsFactorSources(eventKind: EventKind) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_event_kind_affects_factor_sources(
            FfiConverterTypeEventKind.lower(eventKind), $0
        )
    })
}

public func eventKindAffectsSavedGateways(eventKind: EventKind) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_event_kind_affects_saved_gateways(
            FfiConverterTypeEventKind.lower(eventKind), $0
        )
    })
}

public func eventKindAffectsSecurityStructures(eventKind: EventKind) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_event_kind_affects_security_structures(
            FfiConverterTypeEventKind.lower(eventKind), $0
        )
    })
}

public func eventKindAll() -> [EventKind] {
    return try! FfiConverterSequenceTypeEventKind.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_event_kind_all($0
        )
    })
}

public func exactly12BytesToJsonString(exactly12Bytes: Exactly12Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly12_bytes_to_json_string(
            FfiConverterTypeExactly12Bytes.lower(exactly12Bytes), $0
        )
    })
}

public func exactly29BytesToJsonString(exactly29Bytes: Exactly29Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly29_bytes_to_json_string(
            FfiConverterTypeExactly29Bytes.lower(exactly29Bytes), $0
        )
    })
}

public func exactly32BytesToJsonString(exactly32Bytes: Exactly32Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly32_bytes_to_json_string(
            FfiConverterTypeExactly32Bytes.lower(exactly32Bytes), $0
        )
    })
}

public func exactly33BytesToJsonString(exactly33Bytes: Exactly33Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly33_bytes_to_json_string(
            FfiConverterTypeExactly33Bytes.lower(exactly33Bytes), $0
        )
    })
}

public func exactly60BytesToJsonString(exactly60Bytes: Exactly60Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly60_bytes_to_json_string(
            FfiConverterTypeExactly60Bytes.lower(exactly60Bytes), $0
        )
    })
}

public func exactly64BytesToJsonString(exactly64Bytes: Exactly64Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly64_bytes_to_json_string(
            FfiConverterTypeExactly64Bytes.lower(exactly64Bytes), $0
        )
    })
}

public func exactly65BytesToJsonString(exactly65Bytes: Exactly65Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly65_bytes_to_json_string(
            FfiConverterTypeExactly65Bytes.lower(exactly65Bytes), $0
        )
    })
}

public func exactly12BytesToBytes(bytes: Exactly12Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_12_bytes_to_bytes(
            FfiConverterTypeExactly12Bytes.lower(bytes), $0
        )
    })
}

public func exactly12BytesToHex(bytes: Exactly12Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_12_bytes_to_hex(
            FfiConverterTypeExactly12Bytes.lower(bytes), $0
        )
    })
}

public func exactly29BytesToBytes(bytes: Exactly29Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_29_bytes_to_bytes(
            FfiConverterTypeExactly29Bytes.lower(bytes), $0
        )
    })
}

public func exactly29BytesToHex(bytes: Exactly29Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_29_bytes_to_hex(
            FfiConverterTypeExactly29Bytes.lower(bytes), $0
        )
    })
}

public func exactly32BytesToBytes(bytes: Exactly32Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_32_bytes_to_bytes(
            FfiConverterTypeExactly32Bytes.lower(bytes), $0
        )
    })
}

public func exactly32BytesToHex(bytes: Exactly32Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_32_bytes_to_hex(
            FfiConverterTypeExactly32Bytes.lower(bytes), $0
        )
    })
}

public func exactly33BytesToBytes(bytes: Exactly33Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_33_bytes_to_bytes(
            FfiConverterTypeExactly33Bytes.lower(bytes), $0
        )
    })
}

public func exactly33BytesToHex(bytes: Exactly33Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_33_bytes_to_hex(
            FfiConverterTypeExactly33Bytes.lower(bytes), $0
        )
    })
}

public func exactly60BytesToBytes(bytes: Exactly60Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_60_bytes_to_bytes(
            FfiConverterTypeExactly60Bytes.lower(bytes), $0
        )
    })
}

public func exactly60BytesToHex(bytes: Exactly60Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_60_bytes_to_hex(
            FfiConverterTypeExactly60Bytes.lower(bytes), $0
        )
    })
}

public func exactly64BytesToBytes(bytes: Exactly64Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_64_bytes_to_bytes(
            FfiConverterTypeExactly64Bytes.lower(bytes), $0
        )
    })
}

public func exactly64BytesToHex(bytes: Exactly64Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_64_bytes_to_hex(
            FfiConverterTypeExactly64Bytes.lower(bytes), $0
        )
    })
}

public func exactly65BytesToBytes(bytes: Exactly65Bytes) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_65_bytes_to_bytes(
            FfiConverterTypeExactly65Bytes.lower(bytes), $0
        )
    })
}

public func exactly65BytesToHex(bytes: Exactly65Bytes) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_exactly_65_bytes_to_hex(
            FfiConverterTypeExactly65Bytes.lower(bytes), $0
        )
    })
}

public func factorSourceCryptoParametersSupportsBabylon(parameters: FactorSourceCryptoParameters) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_factor_source_crypto_parameters_supports_babylon(
            FfiConverterTypeFactorSourceCryptoParameters.lower(parameters), $0
        )
    })
}

public func factorSourceCryptoParametersSupportsOlympia(parameters: FactorSourceCryptoParameters) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_factor_source_crypto_parameters_supports_olympia(
            FfiConverterTypeFactorSourceCryptoParameters.lower(parameters), $0
        )
    })
}

public func factorSourceIDFromAddressToJsonBytes(factorSourceIDFromAddress: FactorSourceIdFromAddress) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_factor_source_i_d_from_address_to_json_bytes(
            FfiConverterTypeFactorSourceIDFromAddress.lower(factorSourceIDFromAddress), $0
        )
    })
}

public func factorSourceIDFromHashToJsonBytes(factorSourceIDFromHash: FactorSourceIdFromHash) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_factor_source_i_d_from_hash_to_json_bytes(
            FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceIDFromHash), $0
        )
    })
}

public func factorSourceIdFromAddressToString(factorSourceId: FactorSourceIdFromAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_factor_source_id_from_address_to_string(
            FfiConverterTypeFactorSourceIDFromAddress.lower(factorSourceId), $0
        )
    })
}

public func factorSourceIdFromHashToString(factorSourceId: FactorSourceIdFromHash) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_factor_source_id_from_hash_to_string(
            FfiConverterTypeFactorSourceIDFromHash.lower(factorSourceId), $0
        )
    })
}

public func factorSourceIdToString(factorSourceId: FactorSourceId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_factor_source_id_to_string(
            FfiConverterTypeFactorSourceID.lower(factorSourceId), $0
        )
    })
}

public func factorSourceKindToString(kind: FactorSourceKind) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_factor_source_kind_to_string(
            FfiConverterTypeFactorSourceKind.lower(kind), $0
        )
    })
}

public func factorSourceSupportsBabylon(factorSource: FactorSource) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_factor_source_supports_babylon(
            FfiConverterTypeFactorSource.lower(factorSource), $0
        )
    })
}

public func factorSourceSupportsOlympia(factorSource: FactorSource) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_factor_source_supports_olympia(
            FfiConverterTypeFactorSource.lower(factorSource), $0
        )
    })
}

public func factorSourceToString(factorSource: FactorSource) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_factor_source_to_string(
            FfiConverterTypeFactorSource.lower(factorSource), $0
        )
    })
}

public func factorSourcesAllSampleValues() -> [FactorSource] {
    return try! FfiConverterSequenceTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_factor_sources_all_sample_values($0
        )
    })
}

public func ffiUrlGetUrl(ffiUrl: FfiUrl) -> Url {
    return try! FfiConverterTypeUrl.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_ffi_url_get_url(
            FfiConverterTypeFfiUrl.lower(ffiUrl), $0
        )
    })
}

public func fiatCurrencyToJsonString(fiatCurrency: FiatCurrency) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_fiat_currency_to_json_string(
            FfiConverterTypeFiatCurrency.lower(fiatCurrency), $0
        )
    })
}

public func fungibleResourceIndicatorGetAmount(indicator: FungibleResourceIndicator) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_fungible_resource_indicator_get_amount(
            FfiConverterTypeFungibleResourceIndicator.lower(indicator), $0
        )
    })
}

public func gatewayId(gateway: Gateway) -> Url {
    return try! FfiConverterTypeUrl.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_gateway_id(
            FfiConverterTypeGateway.lower(gateway), $0
        )
    })
}

public func gatewayIsWellknown(gateway: Gateway) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_gateway_is_wellknown(
            FfiConverterTypeGateway.lower(gateway), $0
        )
    })
}

public func gatewayMainnet() -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_gateway_mainnet($0
        )
    })
}

public func gatewayStokenet() -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_gateway_stokenet($0
        )
    })
}

public func gatewayToString(gateway: Gateway) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_gateway_to_string(
            FfiConverterTypeGateway.lower(gateway), $0
        )
    })
}

public func gatewayWellknownGateways() -> [Gateway] {
    return try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_gateway_wellknown_gateways($0
        )
    })
}

public func getSubintentExpirationStatus(expiration: DappToWalletInteractionSubintentExpiration) -> DappToWalletInteractionSubintentExpirationStatus {
    return try! FfiConverterTypeDappToWalletInteractionSubintentExpirationStatus.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_get_subintent_expiration_status(
            FfiConverterTypeDappToWalletInteractionSubintentExpiration.lower(expiration), $0
        )
    })
}

public func hash(data: BagOfBytes) -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_hash(
            FfiConverterTypeBagOfBytes.lower(data), $0
        )
    })
}

public func hashGetBytes(hash: Hash) -> Exactly32Bytes {
    return try! FfiConverterTypeExactly32Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_hash_get_bytes(
            FfiConverterTypeHash.lower(hash), $0
        )
    })
}

public func hdPathComponentGetKeySpace(component: HdPathComponent) -> KeySpace {
    return try! FfiConverterTypeKeySpace.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_hd_path_component_get_key_space(
            FfiConverterTypeHDPathComponent.lower(component), $0
        )
    })
}

public func hdPathComponentIndexInGlobalKeySpace(component: HdPathComponent) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_hd_path_component_index_in_global_key_space(
            FfiConverterTypeHDPathComponent.lower(component), $0
        )
    })
}

public func hdPathComponentIndexInLocalKeySpace(component: HdPathComponent) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_hd_path_component_index_in_local_key_space(
            FfiConverterTypeHDPathComponent.lower(component), $0
        )
    })
}

public func hdPathComponentToBip32String(component: HdPathComponent) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_hd_path_component_to_bip32_string(
            FfiConverterTypeHDPathComponent.lower(component), $0
        )
    })
}

public func hdPathComponentToBip32StringDebug(component: HdPathComponent) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_hd_path_component_to_bip32_string_debug(
            FfiConverterTypeHDPathComponent.lower(component), $0
        )
    })
}

public func hdPathComponentToHardened(component: HdPathComponent) throws -> Hardened {
    return try FfiConverterTypeHardened.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_hd_path_component_to_hardened(
            FfiConverterTypeHDPathComponent.lower(component), $0
        )
    })
}

public func headerToJsonBytes(header: Header) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_header_to_json_bytes(
            FfiConverterTypeHeader.lower(header), $0
        )
    })
}

public func hierarchicalDeterministicPublicKeyIsValidSignatureForHash(key: HierarchicalDeterministicPublicKey, signature: Signature, hash: Hash) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_hierarchical_deterministic_public_key_is_valid_signature_for_hash(
            FfiConverterTypeHierarchicalDeterministicPublicKey.lower(key),
            FfiConverterTypeSignature.lower(signature),
            FfiConverterTypeHash.lower(hash), $0
        )
    })
}

public func hostIdToJsonBytes(hostId: HostId) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_host_id_to_json_bytes(
            FfiConverterTypeHostId.lower(hostId), $0
        )
    })
}

public func hostOsGetName(hostOs: HostOs) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_host_os_get_name(
            FfiConverterTypeHostOS.lower(hostOs), $0
        )
    })
}

public func hostOsGetVendor(hostOs: HostOs) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_host_os_get_vendor(
            FfiConverterTypeHostOS.lower(hostOs), $0
        )
    })
}

public func hostOsGetVersion(hostOs: HostOs) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_host_os_get_version(
            FfiConverterTypeHostOS.lower(hostOs), $0
        )
    })
}

public func identityAddressBech32Address(address: IdentityAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_identity_address_bech32_address(
            FfiConverterTypeIdentityAddress.lower(address), $0
        )
    })
}

public func identityAddressFormatted(address: IdentityAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_identity_address_formatted(
            FfiConverterTypeIdentityAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func identityAddressMapToNetwork(address: IdentityAddress, networkId: NetworkId) -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_identity_address_map_to_network(
            FfiConverterTypeIdentityAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func identityAddressNetworkId(address: IdentityAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_identity_address_network_id(
            FfiConverterTypeIdentityAddress.lower(address), $0
        )
    })
}

public func imageUrlUtilsIsVectorImage(url: String, imageType: VectorImageType) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_image_url_utils_is_vector_image(
            FfiConverterString.lower(url),
            FfiConverterTypeVectorImageType.lower(imageType), $0
        )
    })
}

public func imageUrlUtilsMakeImageUrl(url: String, imageServiceUrl: String, width: UInt32, height: UInt32) throws -> Url {
    return try FfiConverterTypeUrl.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_image_url_utils_make_image_url(
            FfiConverterString.lower(url),
            FfiConverterString.lower(imageServiceUrl),
            FfiConverterUInt32.lower(width),
            FfiConverterUInt32.lower(height), $0
        )
    })
}

public func intentDiscriminatorGetValue(intentDiscriminator: IntentDiscriminator) -> UInt64 {
    return try! FfiConverterUInt64.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_intent_discriminator_get_value(
            FfiConverterTypeIntentDiscriminator.lower(intentDiscriminator), $0
        )
    })
}

public func intentSignatureGetSignatureWithPublicKey(intentSignature: IntentSignature) -> SignatureWithPublicKey {
    return try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_intent_signature_get_signature_with_public_key(
            FfiConverterTypeIntentSignature.lower(intentSignature), $0
        )
    })
}

public func isSafeToShowErrorMessageFromError(error: CommonError) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_is_safe_to_show_error_message_from_error(
            FfiConverterTypeCommonError.lower(error), $0
        )
    })
}

/**
 * Returns the public key on **compressed** form (33 bytes)
 */
public func keyAgreementPublicKeyToBytes(publicKey: KeyAgreementPublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_key_agreement_public_key_to_bytes(
            FfiConverterTypeKeyAgreementPublicKey.lower(publicKey), $0
        )
    })
}

/**
 * Encodes the compressed form (33 bytes) of a `Secp256k1PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"033083620d1596d3f8988ff3270e42970dd2a031e2b9b6488052a4170ff999f3e8"`
 */
public func keyAgreementPublicKeyToHex(publicKey: KeyAgreementPublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_key_agreement_public_key_to_hex(
            FfiConverterTypeKeyAgreementPublicKey.lower(publicKey), $0
        )
    })
}

public func ledgerHwWalletModelToString(model: LedgerHardwareWalletModel) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_ledger_hw_wallet_model_to_string(
            FfiConverterTypeLedgerHardwareWalletModel.lower(model), $0
        )
    })
}

public func legacyOlympiaAccountAddressFormatted(address: LegacyOlympiaAccountAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_legacy_olympia_account_address_formatted(
            FfiConverterTypeLegacyOlympiaAccountAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func legacyOlympiaAccountAddressIsLegacyOfBabylon(legacyOlympiaAddress: LegacyOlympiaAccountAddress, babylonAccountAddress: AccountAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_legacy_olympia_account_address_is_legacy_of_babylon(
            FfiConverterTypeLegacyOlympiaAccountAddress.lower(legacyOlympiaAddress),
            FfiConverterTypeAccountAddress.lower(babylonAccountAddress), $0
        )
    })
}

public func legacyOlympiaAccountAddressToBabylonAccountAddress(address: LegacyOlympiaAccountAddress) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_legacy_olympia_account_address_to_babylon_account_address(
            FfiConverterTypeLegacyOlympiaAccountAddress.lower(address), $0
        )
    })
}

public func legacyOlympiaAccountAddressToString(address: LegacyOlympiaAccountAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_legacy_olympia_account_address_to_string(
            FfiConverterTypeLegacyOlympiaAccountAddress.lower(address), $0
        )
    })
}

public func linkConnectionQRDataToJsonBytes(linkConnectionQRData: LinkConnectionQrData) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_link_connection_q_r_data_to_json_bytes(
            FfiConverterTypeLinkConnectionQRData.lower(linkConnectionQRData), $0
        )
    })
}

public func lockerAddressBech32Address(address: LockerAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_locker_address_bech32_address(
            FfiConverterTypeLockerAddress.lower(address), $0
        )
    })
}

public func lockerAddressFormatted(address: LockerAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_locker_address_formatted(
            FfiConverterTypeLockerAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func lockerAddressMapToNetwork(address: LockerAddress, networkId: NetworkId) -> LockerAddress {
    return try! FfiConverterTypeLockerAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_locker_address_map_to_network(
            FfiConverterTypeLockerAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func lockerAddressNetworkId(address: LockerAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_locker_address_network_id(
            FfiConverterTypeLockerAddress.lower(address), $0
        )
    })
}

public func manifestAccountLockerClaim(lockerAddress: LockerAddress, claimant: AccountAddress, claimableResources: [AccountLockerClaimableResource]) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_account_locker_claim(
            FfiConverterTypeLockerAddress.lower(lockerAddress),
            FfiConverterTypeAccountAddress.lower(claimant),
            FfiConverterSequenceTypeAccountLockerClaimableResource.lower(claimableResources), $0
        )
    })
}

public func manifestCreateFungibleToken(addressOfOwner: AccountAddress) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_create_fungible_token(
            FfiConverterTypeAccountAddress.lower(addressOfOwner), $0
        )
    })
}

public func manifestCreateFungibleTokenWithMetadata(addressOfOwner: AccountAddress, initialSupply: Decimal192, metadata: TokenDefinitionMetadata) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_create_fungible_token_with_metadata(
            FfiConverterTypeAccountAddress.lower(addressOfOwner),
            FfiConverterTypeDecimal192.lower(initialSupply),
            FfiConverterTypeTokenDefinitionMetadata.lower(metadata), $0
        )
    })
}

/**
 * Creates many fungible tokens, with initial supply, to be owned by `address_of_owner`.
 *
 * # Panics
 * Panics if `address_of_owner` is on `Mainnet`, use a testnet instead.
 * Panics if `count` is zero or is greater than the number of token metadata defined in `sample_resource_definition_metadata` (25)
 */
public func manifestCreateMultipleFungibleTokens(addressOfOwner: AccountAddress, count: UInt8?) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_create_multiple_fungible_tokens(
            FfiConverterTypeAccountAddress.lower(addressOfOwner),
            FfiConverterOptionUInt8.lower(count), $0
        )
    })
}

public func manifestCreateMultipleNonFungibleTokens(addressOfOwner: AccountAddress, collectionCount: UInt8?, nftsPerCollection: UInt8?) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_create_multiple_non_fungible_tokens(
            FfiConverterTypeAccountAddress.lower(addressOfOwner),
            FfiConverterOptionUInt8.lower(collectionCount),
            FfiConverterOptionUInt8.lower(nftsPerCollection), $0
        )
    })
}

public func manifestCreateNonFungibleToken(addressOfOwner: AccountAddress, nftsPerCollection: UInt8?) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_create_non_fungible_token(
            FfiConverterTypeAccountAddress.lower(addressOfOwner),
            FfiConverterOptionUInt8.lower(nftsPerCollection), $0
        )
    })
}

public func manifestEncounteredComponentAddressFormatted(address: ManifestEncounteredComponentAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_formatted(
            FfiConverterTypeManifestEncounteredComponentAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func manifestEncounteredComponentAddressMapToNetwork(address: ManifestEncounteredComponentAddress, networkId: NetworkId) -> ManifestEncounteredComponentAddress {
    return try! FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_map_to_network(
            FfiConverterTypeManifestEncounteredComponentAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func manifestEncounteredComponentAddressNetworkId(address: ManifestEncounteredComponentAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_network_id(
            FfiConverterTypeManifestEncounteredComponentAddress.lower(address), $0
        )
    })
}

public func manifestEncounteredComponentAddressSampleValuesAll() -> [ManifestEncounteredComponentAddress] {
    return try! FfiConverterSequenceTypeManifestEncounteredComponentAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_sample_values_all($0
        )
    })
}

public func manifestEncounteredComponentAddressToString(address: ManifestEncounteredComponentAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_encountered_component_address_to_string(
            FfiConverterTypeManifestEncounteredComponentAddress.lower(address), $0
        )
    })
}

public func manifestForFaucet(includeLockFeeInstruction: Bool, addressOfReceivingAccount: AccountAddress) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_for_faucet(
            FfiConverterBool.lower(includeLockFeeInstruction),
            FfiConverterTypeAccountAddress.lower(addressOfReceivingAccount), $0
        )
    })
}

public func manifestMarkingAccountAsDappDefinitionType(accountAddress: AccountAddress) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_marking_account_as_dapp_definition_type(
            FfiConverterTypeAccountAddress.lower(accountAddress), $0
        )
    })
}

public func manifestPerAssetTransfers(transfers: PerAssetTransfers) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_per_asset_transfers(
            FfiConverterTypePerAssetTransfers.lower(transfers), $0
        )
    })
}

/**
 * Uses `per_asset_transfers` after having transposed the `PerRecipientAssetTransfers`
 * into `PerAssetTransfers`. We always use `PerAssetTransfers` when building the manifest
 * since it is more efficient (allows a single withdraw per resource) => fewer instruction =>
 * cheaper TX fee for user.
 */
public func manifestPerRecipientTransfers(transfers: PerRecipientAssetTransfers) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_per_recipient_transfers(
            FfiConverterTypePerRecipientAssetTransfers.lower(transfers), $0
        )
    })
}

public func manifestSetOwnerKeysHashes(addressOfAccountOrPersona: AddressOfAccountOrPersona, ownerKeyHashes: [PublicKeyHash]) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_set_owner_keys_hashes(
            FfiConverterTypeAddressOfAccountOrPersona.lower(addressOfAccountOrPersona),
            FfiConverterSequenceTypePublicKeyHash.lower(ownerKeyHashes), $0
        )
    })
}

public func manifestStakesClaim(accountAddress: AccountAddress, stakeClaims: [StakeClaim]) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_stakes_claim(
            FfiConverterTypeAccountAddress.lower(accountAddress),
            FfiConverterSequenceTypeStakeClaim.lower(stakeClaims), $0
        )
    })
}

public func manifestThirdPartyDepositUpdate(accountAddress: AccountAddress, from: ThirdPartyDeposits, to: ThirdPartyDeposits) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_manifest_third_party_deposit_update(
            FfiConverterTypeAccountAddress.lower(accountAddress),
            FfiConverterTypeThirdPartyDeposits.lower(from),
            FfiConverterTypeThirdPartyDeposits.lower(to), $0
        )
    })
}

public func messageAsPlaintext(message: Message) -> String? {
    return try! FfiConverterOptionString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_message_as_plaintext(
            FfiConverterTypeMessage.lower(message), $0
        )
    })
}

public func messageV2AsPlaintext(message: MessageV2) -> String? {
    return try! FfiConverterOptionString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_message_v2_as_plaintext(
            FfiConverterTypeMessageV2.lower(message), $0
        )
    })
}

/**
 * Returns the words of a mnemonic as a String joined by spaces, e.g. "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo wrong"
 */
public func mnemonicPhrase(from: Mnemonic) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_mnemonic_phrase(
            FfiConverterTypeMnemonic.lower(from), $0
        )
    })
}

public func mnemonicWithPassphraseDerivePublicKeys(mnemonicWithPassphrase: MnemonicWithPassphrase, derivationPaths: [DerivationPath]) -> [HierarchicalDeterministicPublicKey] {
    return try! FfiConverterSequenceTypeHierarchicalDeterministicPublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_mnemonic_with_passphrase_derive_public_keys(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterSequenceTypeDerivationPath.lower(derivationPaths), $0
        )
    })
}

public func mnemonicWithPassphraseSign(mnemonicWithPassphrase: MnemonicWithPassphrase, derivationPath: DerivationPath, hashToSign: Hash) -> SignatureWithPublicKey {
    return try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_mnemonic_with_passphrase_sign(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeDerivationPath.lower(derivationPath),
            FfiConverterTypeHash.lower(hashToSign), $0
        )
    })
}

public func mnemonicWithPassphraseToJsonBytes(mnemonicWithPassphrase: MnemonicWithPassphrase) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_mnemonic_with_passphrase_to_json_bytes(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase), $0
        )
    })
}

/**
 * Returns `true` if this MnemonicWithPassphrase successfully validates all `hd_keys`, that is to say,
 * that all the HierarchicalDeterministicPublicKey were indeed crated by this MnemonicWithPassphrase.
 */
public func mnemonicWithPassphraseValidatePublicKeys(mnemonicWithPassphrase: MnemonicWithPassphrase, hdKeys: [HierarchicalDeterministicPublicKey]) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_mnemonic_with_passphrase_validate_public_keys(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterSequenceTypeHierarchicalDeterministicPublicKey.lower(hdKeys), $0
        )
    })
}

/**
 * Modifies `manifest` by inserting transaction "guarantees", which is the wallet
 * term for `assert_worktop_contains`.
 */
public func modifyManifestAddGuarantees(manifest: TransactionManifest, guarantees: [TransactionGuarantee]) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_modify_manifest_add_guarantees(
            FfiConverterTypeTransactionManifest.lower(manifest),
            FfiConverterSequenceTypeTransactionGuarantee.lower(guarantees), $0
        )
    })
}

public func modifyManifestLockFee(manifest: TransactionManifest, addressOfFeePayer: AccountAddress, fee: Decimal192?) -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_modify_manifest_lock_fee(
            FfiConverterTypeTransactionManifest.lower(manifest),
            FfiConverterTypeAccountAddress.lower(addressOfFeePayer),
            FfiConverterOptionTypeDecimal192.lower(fee), $0
        )
    })
}

public func networkIdDiscriminant(id: NetworkId) -> UInt8 {
    return try! FfiConverterUInt8.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_network_id_discriminant(
            FfiConverterTypeNetworkID.lower(id), $0
        )
    })
}

public func networkIdToString(id: NetworkId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_network_id_to_string(
            FfiConverterTypeNetworkID.lower(id), $0
        )
    })
}

public func networkIdsAll() -> [NetworkId] {
    return try! FfiConverterSequenceTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_network_ids_all($0
        )
    })
}

public func networkMethodToString(method: NetworkMethod) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_network_method_to_string(
            FfiConverterTypeNetworkMethod.lower(method), $0
        )
    })
}

public func newAccessControllerAddress(bech32: String) throws -> AccessControllerAddress {
    return try FfiConverterTypeAccessControllerAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_access_controller_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newAccessControllerAddressRandom(networkId: NetworkId) -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_access_controller_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newAccessControllerAddressSampleMainnet() -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_access_controller_address_sample_mainnet($0
        )
    })
}

public func newAccessControllerAddressSampleMainnetOther() -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_access_controller_address_sample_mainnet_other($0
        )
    })
}

public func newAccessControllerAddressSampleStokenet() -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_access_controller_address_sample_stokenet($0
        )
    })
}

public func newAccessControllerAddressSampleStokenetOther() -> AccessControllerAddress {
    return try! FfiConverterTypeAccessControllerAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_access_controller_address_sample_stokenet_other($0
        )
    })
}

public func newAccountAddress(bech32: String) throws -> AccountAddress {
    return try FfiConverterTypeAccountAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_account_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

public func newAccountAddressFrom(publicKey: PublicKey, networkId: NetworkId) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_address_from(
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newAccountAddressRandom(networkId: NetworkId) -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newAccountAddressSampleMainnet() -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_address_sample_mainnet($0
        )
    })
}

public func newAccountAddressSampleMainnetOther() -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_address_sample_mainnet_other($0
        )
    })
}

public func newAccountAddressSampleStokenet() -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_address_sample_stokenet($0
        )
    })
}

public func newAccountAddressSampleStokenetOther() -> AccountAddress {
    return try! FfiConverterTypeAccountAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_address_sample_stokenet_other($0
        )
    })
}

public func newAccountForDisplayFromAccount(account: Account) -> AccountForDisplay {
    return try! FfiConverterTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_for_display_from_account(
            FfiConverterTypeAccount.lower(account), $0
        )
    })
}

public func newAccountForDisplaySample() -> AccountForDisplay {
    return try! FfiConverterTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_for_display_sample($0
        )
    })
}

public func newAccountForDisplaySampleOther() -> AccountForDisplay {
    return try! FfiConverterTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_for_display_sample_other($0
        )
    })
}

public func newAccountLockerClaimableResourceSample() -> AccountLockerClaimableResource {
    return try! FfiConverterTypeAccountLockerClaimableResource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_locker_claimable_resource_sample($0
        )
    })
}

public func newAccountLockerClaimableResourceSampleOther() -> AccountLockerClaimableResource {
    return try! FfiConverterTypeAccountLockerClaimableResource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_locker_claimable_resource_sample_other($0
        )
    })
}

public func newAccountOrAddressOfSample() -> AccountOrAddressOf {
    return try! FfiConverterTypeAccountOrAddressOf.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_or_address_of_sample($0
        )
    })
}

public func newAccountOrAddressOfSampleOther() -> AccountOrAddressOf {
    return try! FfiConverterTypeAccountOrAddressOf.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_or_address_of_sample_other($0
        )
    })
}

public func newAccountOrPersonaSampleMainnet() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_mainnet($0
        )
    })
}

public func newAccountOrPersonaSampleMainnetOther() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_mainnet_other($0
        )
    })
}

public func newAccountOrPersonaSampleMainnetThird() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_mainnet_third($0
        )
    })
}

public func newAccountOrPersonaSampleStokenet() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_stokenet($0
        )
    })
}

public func newAccountOrPersonaSampleStokenetOther() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_stokenet_other($0
        )
    })
}

public func newAccountOrPersonaSampleStokenetThird() -> AccountOrPersona {
    return try! FfiConverterTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_or_persona_sample_stokenet_third($0
        )
    })
}

public func newAccountPath(networkId: NetworkId, keyKind: Cap26KeyKind, index: Hardened) -> AccountPath {
    return try! FfiConverterTypeAccountPath.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_path(
            FfiConverterTypeNetworkID.lower(networkId),
            FfiConverterTypeCAP26KeyKind.lower(keyKind),
            FfiConverterTypeHardened.lower(index), $0
        )
    })
}

public func newAccountPathSample() -> AccountPath {
    return try! FfiConverterTypeAccountPath.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_path_sample($0
        )
    })
}

public func newAccountPathSampleOther() -> AccountPath {
    return try! FfiConverterTypeAccountPath.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_path_sample_other($0
        )
    })
}

public func newAccountSampleMainnetAlice() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_sample_mainnet_alice($0
        )
    })
}

public func newAccountSampleMainnetBob() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_sample_mainnet_bob($0
        )
    })
}

public func newAccountSampleMainnetCarol() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_sample_mainnet_carol($0
        )
    })
}

public func newAccountSampleMainnetDiana() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_sample_mainnet_diana($0
        )
    })
}

public func newAccountSampleStokenetNadia() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_sample_stokenet_nadia($0
        )
    })
}

public func newAccountSampleStokenetOlivia() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_sample_stokenet_olivia($0
        )
    })
}

public func newAccountSampleStokenetPaige() -> Account {
    return try! FfiConverterTypeAccount.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_account_sample_stokenet_paige($0
        )
    })
}

public func newAccountsForDisplaySample() -> [AccountForDisplay] {
    return try! FfiConverterSequenceTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_accounts_for_display_sample($0
        )
    })
}

public func newAccountsForDisplaySampleOther() -> [AccountForDisplay] {
    return try! FfiConverterSequenceTypeAccountForDisplay.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_accounts_for_display_sample_other($0
        )
    })
}

public func newAccountsOrPersonasSample() -> [AccountOrPersona] {
    return try! FfiConverterSequenceTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_accounts_or_personas_sample($0
        )
    })
}

public func newAccountsOrPersonasSampleOther() -> [AccountOrPersona] {
    return try! FfiConverterSequenceTypeAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_accounts_or_personas_sample_other($0
        )
    })
}

public func newAccountsSample() -> [Account] {
    return try! FfiConverterSequenceTypeAccount.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_accounts_sample($0
        )
    })
}

public func newAccountsSampleOther() -> [Account] {
    return try! FfiConverterSequenceTypeAccount.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_accounts_sample_other($0
        )
    })
}

public func newAddressFromBech32(string: String) throws -> Address {
    return try FfiConverterTypeAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_address_from_bech32(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newAddressOfAccountOrPersonaFromBech32(string: String) throws -> AddressOfAccountOrPersona {
    return try FfiConverterTypeAddressOfAccountOrPersona.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_from_bech32(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleMainnet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_sample_mainnet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleMainnetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_sample_mainnet_other($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleStokenet() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_sample_stokenet($0
        )
    })
}

public func newAddressOfAccountOrPersonaSampleStokenetOther() -> AddressOfAccountOrPersona {
    return try! FfiConverterTypeAddressOfAccountOrPersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_address_of_account_or_persona_sample_stokenet_other($0
        )
    })
}

public func newAddressSampleMainnet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_address_sample_mainnet($0
        )
    })
}

public func newAddressSampleMainnetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_address_sample_mainnet_other($0
        )
    })
}

public func newAddressSampleStokenet() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_address_sample_stokenet($0
        )
    })
}

public func newAddressSampleStokenetOther() -> Address {
    return try! FfiConverterTypeAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_address_sample_stokenet_other($0
        )
    })
}

public func newAppPreferencesDefault() -> AppPreferences {
    return try! FfiConverterTypeAppPreferences.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_app_preferences_default($0
        )
    })
}

public func newAppPreferencesSample() -> AppPreferences {
    return try! FfiConverterTypeAppPreferences.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_app_preferences_sample($0
        )
    })
}

public func newAppPreferencesSampleOther() -> AppPreferences {
    return try! FfiConverterTypeAppPreferences.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_app_preferences_sample_other($0
        )
    })
}

public func newAppearanceId(validating: UInt8) throws -> AppearanceId {
    return try FfiConverterTypeAppearanceID.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_appearance_id(
            FfiConverterUInt8.lower(validating), $0
        )
    })
}

public func newAppearanceIdFromNumberOfAccountsOnNetwork(count: UInt64) -> AppearanceId {
    return try! FfiConverterTypeAppearanceID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_appearance_id_from_number_of_accounts_on_network(
            FfiConverterUInt64.lower(count), $0
        )
    })
}

public func newAppearanceIdSample() -> AppearanceId {
    return try! FfiConverterTypeAppearanceID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_appearance_id_sample($0
        )
    })
}

public func newAppearanceIdSampleOther() -> AppearanceId {
    return try! FfiConverterTypeAppearanceID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_appearance_id_sample_other($0
        )
    })
}

public func newArculusCardFactorSourceFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: ArculusCardHint) -> ArculusCardFactorSource {
    return try! FfiConverterTypeArculusCardFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_arculus_card_factor_source_from_mnemonic_with_passphrase(
            FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
            FfiConverterTypeArculusCardHint.lower(hint), $0
        )
    })
}

public func newArculusCardFactorSourceSample() -> ArculusCardFactorSource {
    return try! FfiConverterTypeArculusCardFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_arculus_card_factor_source_sample($0
        )
    })
}

public func newArculusCardFactorSourceSampleOther() -> ArculusCardFactorSource {
    return try! FfiConverterTypeArculusCardFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_arculus_card_factor_source_sample_other($0
        )
    })
}

public func newAssetExceptionSample() -> AssetException {
    return try! FfiConverterTypeAssetException.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_asset_exception_sample($0
        )
    })
}

public func newAssetExceptionSampleOther() -> AssetException {
    return try! FfiConverterTypeAssetException.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_asset_exception_sample_other($0
        )
    })
}

public func newAssetsExceptionListSample() -> [AssetException] {
    return try! FfiConverterSequenceTypeAssetException.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_assets_exception_list_sample($0
        )
    })
}

public func newAssetsExceptionListSampleOther() -> [AssetException] {
    return try! FfiConverterSequenceTypeAssetException.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_assets_exception_list_sample_other($0
        )
    })
}

public func newAuthorizedDappDetailedSample() -> AuthorizedDappDetailed {
    return try! FfiConverterTypeAuthorizedDappDetailed.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_dapp_detailed_sample($0
        )
    })
}

public func newAuthorizedDappDetailedSampleOther() -> AuthorizedDappDetailed {
    return try! FfiConverterTypeAuthorizedDappDetailed.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_dapp_detailed_sample_other($0
        )
    })
}

public func newAuthorizedDappFromJsonBytes(jsonBytes: BagOfBytes) throws -> AuthorizedDapp {
    return try FfiConverterTypeAuthorizedDapp.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_authorized_dapp_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newAuthorizedDappSampleMainnetDashboard() -> AuthorizedDapp {
    return try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_dapp_sample_mainnet_dashboard($0
        )
    })
}

public func newAuthorizedDappSampleMainnetGumballclub() -> AuthorizedDapp {
    return try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_dapp_sample_mainnet_gumballclub($0
        )
    })
}

public func newAuthorizedDappSampleStokenetDevconsole() -> AuthorizedDapp {
    return try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_dapp_sample_stokenet_devconsole($0
        )
    })
}

public func newAuthorizedDappSampleStokenetSandbox() -> AuthorizedDapp {
    return try! FfiConverterTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_dapp_sample_stokenet_sandbox($0
        )
    })
}

public func newAuthorizedDappsSample() -> [AuthorizedDapp] {
    return try! FfiConverterSequenceTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_dapps_sample($0
        )
    })
}

public func newAuthorizedDappsSampleOther() -> [AuthorizedDapp] {
    return try! FfiConverterSequenceTypeAuthorizedDapp.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_dapps_sample_other($0
        )
    })
}

public func newAuthorizedPersonaDetailedSample() -> AuthorizedPersonaDetailed {
    return try! FfiConverterTypeAuthorizedPersonaDetailed.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_persona_detailed_sample($0
        )
    })
}

public func newAuthorizedPersonaDetailedSampleOther() -> AuthorizedPersonaDetailed {
    return try! FfiConverterTypeAuthorizedPersonaDetailed.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_persona_detailed_sample_other($0
        )
    })
}

public func newAuthorizedPersonaSimpleSampleMainnet() -> AuthorizedPersonaSimple {
    return try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_persona_simple_sample_mainnet($0
        )
    })
}

public func newAuthorizedPersonaSimpleSampleMainnetOther() -> AuthorizedPersonaSimple {
    return try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_persona_simple_sample_mainnet_other($0
        )
    })
}

public func newAuthorizedPersonaSimpleSampleStokenet() -> AuthorizedPersonaSimple {
    return try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_persona_simple_sample_stokenet($0
        )
    })
}

public func newAuthorizedPersonaSimpleSampleStokenetOther() -> AuthorizedPersonaSimple {
    return try! FfiConverterTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_authorized_persona_simple_sample_stokenet_other($0
        )
    })
}

public func newBIP39SeedFromBytes(bytes: BagOfBytes) throws -> Bip39Seed {
    return try FfiConverterTypeBIP39Seed.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_b_i_p39_seed_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newBIP39SeedSample() -> Bip39Seed {
    return try! FfiConverterTypeBIP39Seed.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_b_i_p39_seed_sample($0
        )
    })
}

public func newBIP39SeedSampleOther() -> Bip39Seed {
    return try! FfiConverterTypeBIP39Seed.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_b_i_p39_seed_sample_other($0
        )
    })
}

public func newBagOfBytesFrom(bytes: Data) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_from(
            FfiConverterData.lower(bytes), $0
        )
    })
}

public func newBagOfBytesSampleAced() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_aced($0
        )
    })
}

public func newBagOfBytesSampleBabe() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_babe($0
        )
    })
}

public func newBagOfBytesSampleCafe() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_cafe($0
        )
    })
}

public func newBagOfBytesSampleDead() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_dead($0
        )
    })
}

public func newBagOfBytesSampleEcad() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_ecad($0
        )
    })
}

public func newBagOfBytesSampleFade() -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bag_of_bytes_sample_fade($0
        )
    })
}

public func newBip39LanguageSample() -> Bip39Language {
    return try! FfiConverterTypeBIP39Language.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bip39_language_sample($0
        )
    })
}

public func newBip39LanguageSampleOther() -> Bip39Language {
    return try! FfiConverterTypeBIP39Language.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bip39_language_sample_other($0
        )
    })
}

public func newBip39WordSample() -> Bip39Word {
    return try! FfiConverterTypeBIP39Word.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bip39_word_sample($0
        )
    })
}

public func newBip39WordSampleOther() -> Bip39Word {
    return try! FfiConverterTypeBIP39Word.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bip39_word_sample_other($0
        )
    })
}

public func newBip44LikePathFromIndex(index: HdPathComponent) -> Bip44LikePath {
    return try! FfiConverterTypeBIP44LikePath.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bip44_like_path_from_index(
            FfiConverterTypeHDPathComponent.lower(index), $0
        )
    })
}

public func newBip44LikePathFromString(string: String) throws -> Bip44LikePath {
    return try FfiConverterTypeBIP44LikePath.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_bip44_like_path_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newBip44LikePathSample() -> Bip44LikePath {
    return try! FfiConverterTypeBIP44LikePath.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bip44_like_path_sample($0
        )
    })
}

public func newBip44LikePathSampleOther() -> Bip44LikePath {
    return try! FfiConverterTypeBIP44LikePath.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_bip44_like_path_sample_other($0
        )
    })
}

public func newBlobFromBytes(bytes: BagOfBytes) -> Blob {
    return try! FfiConverterTypeBlob.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_blob_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newBlobsFromBlobList(blobs: [Blob]) -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_blobs_from_blob_list(
            FfiConverterSequenceTypeBlob.lower(blobs), $0
        )
    })
}

public func newBlobsSample() -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_blobs_sample($0
        )
    })
}

public func newBlobsSampleOther() -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_blobs_sample_other($0
        )
    })
}

public func newCompiledNotarizedIntentSample() -> CompiledNotarizedIntent {
    return try! FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_compiled_notarized_intent_sample($0
        )
    })
}

public func newCompiledNotarizedIntentSampleOther() -> CompiledNotarizedIntent {
    return try! FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_compiled_notarized_intent_sample_other($0
        )
    })
}

public func newCompiledSubintentSample() -> CompiledSubintent {
    return try! FfiConverterTypeCompiledSubintent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_compiled_subintent_sample($0
        )
    })
}

public func newCompiledSubintentSampleOther() -> CompiledSubintent {
    return try! FfiConverterTypeCompiledSubintent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_compiled_subintent_sample_other($0
        )
    })
}

public func newCompiledTransactionIntentSample() -> CompiledTransactionIntent {
    return try! FfiConverterTypeCompiledTransactionIntent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_compiled_transaction_intent_sample($0
        )
    })
}

public func newCompiledTransactionIntentSampleOther() -> CompiledTransactionIntent {
    return try! FfiConverterTypeCompiledTransactionIntent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_compiled_transaction_intent_sample_other($0
        )
    })
}

public func newComponentAddress(bech32: String) throws -> ComponentAddress {
    return try FfiConverterTypeComponentAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_component_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newComponentAddressRandom(networkId: NetworkId) -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_component_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Sample to a mainnet ComponentAddress (global)
 */
public func newComponentAddressSampleMainnetGlobal() -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_component_address_sample_mainnet_global($0
        )
    })
}

/**
 * Sample to a mainnet ComponentAddress (internal)
 */
public func newComponentAddressSampleMainnetInternal() -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_component_address_sample_mainnet_internal($0
        )
    })
}

/**
 * Sample to a stokenet ComponentAddress (global)
 */
public func newComponentAddressSampleStokenetGlobal() -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_component_address_sample_stokenet_global($0
        )
    })
}

/**
 * Sample to a stokenet ComponentAddress (internal)
 */
public func newComponentAddressSampleStokenetInternal() -> ComponentAddress {
    return try! FfiConverterTypeComponentAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_component_address_sample_stokenet_internal($0
        )
    })
}

public func newDappToWalletInteractionUnvalidatedFromJsonBytes(jsonBytes: BagOfBytes) throws -> DappToWalletInteractionUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionUnvalidated.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_unvalidated_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newDappToWalletInteractionUnvalidatedFromJsonString(jsonStr: String) throws -> DappToWalletInteractionUnvalidated {
    return try FfiConverterTypeDappToWalletInteractionUnvalidated.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_unvalidated_from_json_string(
            FfiConverterString.lower(jsonStr), $0
        )
    })
}

public func newDappToWalletInteractionUnvalidatedSample() -> DappToWalletInteractionUnvalidated {
    return try! FfiConverterTypeDappToWalletInteractionUnvalidated.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_unvalidated_sample($0
        )
    })
}

public func newDappToWalletInteractionUnvalidatedSampleOther() -> DappToWalletInteractionUnvalidated {
    return try! FfiConverterTypeDappToWalletInteractionUnvalidated.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_dapp_to_wallet_interaction_unvalidated_sample_other($0
        )
    })
}

/**
 * Creates the Decimal192 `10^exponent`
 */
public func newDecimalExponent(exponent: UInt8) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_decimal_exponent(
            FfiConverterUInt8.lower(exponent), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a f32 float. Will
 * fail if the f32 cannot be losslessly represented
 * by the underlying Decimal from Scrypto.
 *
 * ```
 * extern crate sargon_uniffi;
 * use sargon_uniffi::prelude::*;
 *
 * assert!(new_decimal_from_f32(208050.17).to_string() == "208050.17");
 *
 * assert!(new_decimal_from_f32(f32::MIN_POSITIVE).to_string() == "0");
 * ```
 */
public func newDecimalFromF32(value: Float) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_decimal_from_f32(
            FfiConverterFloat.lower(value), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a f64 float. Will
 * fail if the f64 cannot be losslessly represented
 * by the underlying Decimal from Scrypto.
 *
 * ```
 * extern crate sargon_uniffi;
 * use sargon_uniffi::prelude::*;
 *
 * assert!(new_decimal_from_f64(208050.17).is_ok());
 *
 * assert!(new_decimal_from_f64(f64::MIN_POSITIVE).is_ok());
 * ```
 */
public func newDecimalFromF64(value: Double) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_decimal_from_f64(
            FfiConverterDouble.lower(value), $0
        )
    })
}

/**
 * Tries to creates a new `Decimal192` from a formatted String for
 * a specific locale.
 */
public func newDecimalFromFormattedString(formattedString: String, locale: LocaleConfig) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_decimal_from_formatted_string(
            FfiConverterString.lower(formattedString),
            FfiConverterTypeLocaleConfig.lower(locale), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a i32 integer.
 */
public func newDecimalFromI32(value: Int32) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_decimal_from_i32(
            FfiConverterInt32.lower(value), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a i64 integer.
 */
public func newDecimalFromI64(value: Int64) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_decimal_from_i64(
            FfiConverterInt64.lower(value), $0
        )
    })
}

/**
 * Tries to creates a new `Decimal192` from a String, throws a `CommonError`
 * if the `string` was not a valid Decimal192.
 */
public func newDecimalFromString(string: String) throws -> Decimal192 {
    return try FfiConverterTypeDecimal192.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_decimal_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a u32 integer.
 */
public func newDecimalFromU32(value: UInt32) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_decimal_from_u32(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

/**
 * Creates a new `Decimal192` from a u64 integer.
 */
public func newDecimalFromU64(value: UInt64) -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_decimal_from_u64(
            FfiConverterUInt64.lower(value), $0
        )
    })
}

public func newDependencyInformationSample() -> DependencyInformation {
    return try! FfiConverterTypeDependencyInformation.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_dependency_information_sample($0
        )
    })
}

public func newDependencyInformationSampleOther() -> DependencyInformation {
    return try! FfiConverterTypeDependencyInformation.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_dependency_information_sample_other($0
        )
    })
}

public func newDepositRuleFromJsonString(jsonString: String) throws -> DepositRule {
    return try FfiConverterTypeDepositRule.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_deposit_rule_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newDepositRuleSample() -> DepositRule {
    return try! FfiConverterTypeDepositRule.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_deposit_rule_sample($0
        )
    })
}

public func newDepositRuleSampleOther() -> DepositRule {
    return try! FfiConverterTypeDepositRule.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_deposit_rule_sample_other($0
        )
    })
}

public func newDepositorsAllowListSample() -> [ResourceOrNonFungible] {
    return try! FfiConverterSequenceTypeResourceOrNonFungible.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_depositors_allow_list_sample($0
        )
    })
}

public func newDepositorsAllowListSampleOther() -> [ResourceOrNonFungible] {
    return try! FfiConverterSequenceTypeResourceOrNonFungible.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_depositors_allow_list_sample_other($0
        )
    })
}

public func newDerivationPathFromString(string: String) throws -> DerivationPath {
    return try FfiConverterTypeDerivationPath.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_derivation_path_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newDerivationPathSample() -> DerivationPath {
    return try! FfiConverterTypeDerivationPath.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_derivation_path_sample($0
        )
    })
}

public func newDerivationPathSampleOther() -> DerivationPath {
    return try! FfiConverterTypeDerivationPath.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_derivation_path_sample_other($0
        )
    })
}

public func newDetailedAuthorizedPersonasSample() -> [AuthorizedPersonaDetailed] {
    return try! FfiConverterSequenceTypeAuthorizedPersonaDetailed.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_detailed_authorized_personas_sample($0
        )
    })
}

public func newDetailedAuthorizedPersonasSampleOther() -> [AuthorizedPersonaDetailed] {
    return try! FfiConverterSequenceTypeAuthorizedPersonaDetailed.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_detailed_authorized_personas_sample_other($0
        )
    })
}

public func newDeviceFactorSourceBabylon(isMain: Bool, mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> DeviceFactorSource {
    return try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_device_factor_source_babylon(
            FfiConverterBool.lower(isMain),
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newDeviceFactorSourceOlympia(mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> DeviceFactorSource {
    return try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_device_factor_source_olympia(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newDeviceFactorSourceSample() -> DeviceFactorSource {
    return try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_device_factor_source_sample($0
        )
    })
}

public func newDeviceFactorSourceSampleOther() -> DeviceFactorSource {
    return try! FfiConverterTypeDeviceFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_device_factor_source_sample_other($0
        )
    })
}

public func newDeviceInfoDescriptionSample() -> DeviceInfoDescription {
    return try! FfiConverterTypeDeviceInfoDescription.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_device_info_description_sample($0
        )
    })
}

public func newDeviceInfoDescriptionSampleOther() -> DeviceInfoDescription {
    return try! FfiConverterTypeDeviceInfoDescription.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_device_info_description_sample_other($0
        )
    })
}

public func newDeviceInfoFromHostInfo(hostId: HostId, hostInfo: HostInfo) -> DeviceInfo {
    return try! FfiConverterTypeDeviceInfo.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_device_info_from_host_info(
            FfiConverterTypeHostId.lower(hostId),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newDeviceInfoFromJsonBytes(jsonBytes: BagOfBytes) throws -> DeviceInfo {
    return try FfiConverterTypeDeviceInfo.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_device_info_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newDeviceInfoSample() -> DeviceInfo {
    return try! FfiConverterTypeDeviceInfo.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_device_info_sample($0
        )
    })
}

public func newDeviceInfoSampleOther() -> DeviceInfo {
    return try! FfiConverterTypeDeviceInfo.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_device_info_sample_other($0
        )
    })
}

public func newDisplayName(name: String) throws -> DisplayName {
    return try FfiConverterTypeDisplayName.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_display_name(
            FfiConverterString.lower(name), $0
        )
    })
}

public func newDisplayNameFromJsonString(jsonString: String) throws -> DisplayName {
    return try FfiConverterTypeDisplayName.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_display_name_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newDisplayNameSample() -> DisplayName {
    return try! FfiConverterTypeDisplayName.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_display_name_sample($0
        )
    })
}

public func newDisplayNameSampleOther() -> DisplayName {
    return try! FfiConverterTypeDisplayName.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_display_name_sample_other($0
        )
    })
}

public func newEd25519PublicKeyFromBytes(bytes: BagOfBytes) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEd25519PublicKeyFromHex(hex: String) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_from_hex(
            FfiConverterString.lower(hex), $0
        )
    })
}

public func newEd25519PublicKeyFromJsonString(jsonString: String) throws -> Ed25519PublicKey {
    return try FfiConverterTypeEd25519PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newEd25519PublicKeySample() -> Ed25519PublicKey {
    return try! FfiConverterTypeEd25519PublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_sample($0
        )
    })
}

public func newEd25519PublicKeySampleOther() -> Ed25519PublicKey {
    return try! FfiConverterTypeEd25519PublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_ed25519_public_key_sample_other($0
        )
    })
}

public func newEd25519SignatureFromBytes(bytes: BagOfBytes) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_ed25519_signature_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEd25519SignatureFromExactly64Bytes(bytes: Exactly64Bytes) -> Ed25519Signature {
    return try! FfiConverterTypeEd25519Signature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_ed25519_signature_from_exactly_64_bytes(
            FfiConverterTypeExactly64Bytes.lower(bytes), $0
        )
    })
}

public func newEd25519SignatureFromJsonString(jsonString: String) throws -> Ed25519Signature {
    return try FfiConverterTypeEd25519Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_ed25519_signature_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newEd25519SignatureSample() -> Ed25519Signature {
    return try! FfiConverterTypeEd25519Signature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_ed25519_signature_sample($0
        )
    })
}

public func newEd25519SignatureSampleOther() -> Ed25519Signature {
    return try! FfiConverterTypeEd25519Signature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_ed25519_signature_sample_other($0
        )
    })
}

public func newEmailAddressSample() -> EmailAddress {
    return try! FfiConverterTypeEmailAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_email_address_sample($0
        )
    })
}

public func newEmailAddressSampleOther() -> EmailAddress {
    return try! FfiConverterTypeEmailAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_email_address_sample_other($0
        )
    })
}

public func newEntityFlagSample() -> EntityFlag {
    return try! FfiConverterTypeEntityFlag.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entity_flag_sample($0
        )
    })
}

public func newEntityFlagSampleOther() -> EntityFlag {
    return try! FfiConverterTypeEntityFlag.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entity_flag_sample_other($0
        )
    })
}

public func newEntityFlagsSample() -> [EntityFlag] {
    return try! FfiConverterSequenceTypeEntityFlag.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entity_flags_sample($0
        )
    })
}

public func newEntityFlagsSampleOther() -> [EntityFlag] {
    return try! FfiConverterSequenceTypeEntityFlag.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entity_flags_sample_other($0
        )
    })
}

public func newEntitySecurityStateSample() -> EntitySecurityState {
    return try! FfiConverterTypeEntitySecurityState.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entity_security_state_sample($0
        )
    })
}

public func newEntitySecurityStateSampleOther() -> EntitySecurityState {
    return try! FfiConverterTypeEntitySecurityState.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entity_security_state_sample_other($0
        )
    })
}

public func newEntropy16BytesFromBytes(bytes: BagOfBytes) throws -> Entropy16Bytes {
    return try FfiConverterTypeEntropy16Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_entropy16_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy16BytesSample() -> Entropy16Bytes {
    return try! FfiConverterTypeEntropy16Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entropy16_bytes_sample($0
        )
    })
}

public func newEntropy16BytesSampleOther() -> Entropy16Bytes {
    return try! FfiConverterTypeEntropy16Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entropy16_bytes_sample_other($0
        )
    })
}

public func newEntropy20BytesFromBytes(bytes: BagOfBytes) throws -> Entropy20Bytes {
    return try FfiConverterTypeEntropy20Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_entropy20_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy20BytesSample() -> Entropy20Bytes {
    return try! FfiConverterTypeEntropy20Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entropy20_bytes_sample($0
        )
    })
}

public func newEntropy20BytesSampleOther() -> Entropy20Bytes {
    return try! FfiConverterTypeEntropy20Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entropy20_bytes_sample_other($0
        )
    })
}

public func newEntropy24BytesFromBytes(bytes: BagOfBytes) throws -> Entropy24Bytes {
    return try FfiConverterTypeEntropy24Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_entropy24_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy24BytesSample() -> Entropy24Bytes {
    return try! FfiConverterTypeEntropy24Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entropy24_bytes_sample($0
        )
    })
}

public func newEntropy24BytesSampleOther() -> Entropy24Bytes {
    return try! FfiConverterTypeEntropy24Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entropy24_bytes_sample_other($0
        )
    })
}

public func newEntropy28BytesFromBytes(bytes: BagOfBytes) throws -> Entropy28Bytes {
    return try FfiConverterTypeEntropy28Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_entropy28_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy28BytesSample() -> Entropy28Bytes {
    return try! FfiConverterTypeEntropy28Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entropy28_bytes_sample($0
        )
    })
}

public func newEntropy28BytesSampleOther() -> Entropy28Bytes {
    return try! FfiConverterTypeEntropy28Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entropy28_bytes_sample_other($0
        )
    })
}

public func newEntropy32BytesFromBytes(bytes: BagOfBytes) throws -> Entropy32Bytes {
    return try FfiConverterTypeEntropy32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_entropy32_bytes_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newEntropy32BytesSample() -> Entropy32Bytes {
    return try! FfiConverterTypeEntropy32Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entropy32_bytes_sample($0
        )
    })
}

public func newEntropy32BytesSampleOther() -> Entropy32Bytes {
    return try! FfiConverterTypeEntropy32Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_entropy32_bytes_sample_other($0
        )
    })
}

public func newExactly12BytesFromJsonString(jsonString: String) throws -> Exactly12Bytes {
    return try FfiConverterTypeExactly12Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly12_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly29BytesFromJsonString(jsonString: String) throws -> Exactly29Bytes {
    return try FfiConverterTypeExactly29Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly29_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly32BytesFromJsonString(jsonString: String) throws -> Exactly32Bytes {
    return try FfiConverterTypeExactly32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly32_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly33BytesFromJsonString(jsonString: String) throws -> Exactly33Bytes {
    return try FfiConverterTypeExactly33Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly33_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly60BytesFromJsonString(jsonString: String) throws -> Exactly60Bytes {
    return try FfiConverterTypeExactly60Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly60_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly64BytesFromJsonString(jsonString: String) throws -> Exactly64Bytes {
    return try FfiConverterTypeExactly64Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly64_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly65BytesFromJsonString(jsonString: String) throws -> Exactly65Bytes {
    return try FfiConverterTypeExactly65Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly65_bytes_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newExactly12Bytes(bytes: BagOfBytes) throws -> Exactly12Bytes {
    return try FfiConverterTypeExactly12Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly_12_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly12BytesSample() -> Exactly12Bytes {
    return try! FfiConverterTypeExactly12Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_12_bytes_sample($0
        )
    })
}

public func newExactly12BytesSampleOther() -> Exactly12Bytes {
    return try! FfiConverterTypeExactly12Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_12_bytes_sample_other($0
        )
    })
}

public func newExactly29Bytes(bytes: BagOfBytes) throws -> Exactly29Bytes {
    return try FfiConverterTypeExactly29Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly_29_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly29BytesSample() -> Exactly29Bytes {
    return try! FfiConverterTypeExactly29Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_29_bytes_sample($0
        )
    })
}

public func newExactly29BytesSampleOther() -> Exactly29Bytes {
    return try! FfiConverterTypeExactly29Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_29_bytes_sample_other($0
        )
    })
}

public func newExactly32Bytes(bytes: BagOfBytes) throws -> Exactly32Bytes {
    return try FfiConverterTypeExactly32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly_32_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly32BytesSample() -> Exactly32Bytes {
    return try! FfiConverterTypeExactly32Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_32_bytes_sample($0
        )
    })
}

public func newExactly32BytesSampleOther() -> Exactly32Bytes {
    return try! FfiConverterTypeExactly32Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_32_bytes_sample_other($0
        )
    })
}

public func newExactly33Bytes(bytes: BagOfBytes) throws -> Exactly33Bytes {
    return try FfiConverterTypeExactly33Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly_33_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly33BytesSample() -> Exactly33Bytes {
    return try! FfiConverterTypeExactly33Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_33_bytes_sample($0
        )
    })
}

public func newExactly33BytesSampleOther() -> Exactly33Bytes {
    return try! FfiConverterTypeExactly33Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_33_bytes_sample_other($0
        )
    })
}

public func newExactly60Bytes(bytes: BagOfBytes) throws -> Exactly60Bytes {
    return try FfiConverterTypeExactly60Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly_60_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly60BytesSample() -> Exactly60Bytes {
    return try! FfiConverterTypeExactly60Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_60_bytes_sample($0
        )
    })
}

public func newExactly60BytesSampleOther() -> Exactly60Bytes {
    return try! FfiConverterTypeExactly60Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_60_bytes_sample_other($0
        )
    })
}

public func newExactly64Bytes(bytes: BagOfBytes) throws -> Exactly64Bytes {
    return try FfiConverterTypeExactly64Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly_64_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly64BytesSample() -> Exactly64Bytes {
    return try! FfiConverterTypeExactly64Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_64_bytes_sample($0
        )
    })
}

public func newExactly64BytesSampleOther() -> Exactly64Bytes {
    return try! FfiConverterTypeExactly64Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_64_bytes_sample_other($0
        )
    })
}

public func newExactly65Bytes(bytes: BagOfBytes) throws -> Exactly65Bytes {
    return try FfiConverterTypeExactly65Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_exactly_65_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newExactly65BytesSample() -> Exactly65Bytes {
    return try! FfiConverterTypeExactly65Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_65_bytes_sample($0
        )
    })
}

public func newExactly65BytesSampleOther() -> Exactly65Bytes {
    return try! FfiConverterTypeExactly65Bytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_exactly_65_bytes_sample_other($0
        )
    })
}

public func newFactorSourceCommonBabylon() -> FactorSourceCommon {
    return try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_common_babylon($0
        )
    })
}

public func newFactorSourceCommonBdfs(isMain: Bool) -> FactorSourceCommon {
    return try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_common_bdfs(
            FfiConverterBool.lower(isMain), $0
        )
    })
}

public func newFactorSourceCommonOlympia() -> FactorSourceCommon {
    return try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_common_olympia($0
        )
    })
}

public func newFactorSourceCommonSample() -> FactorSourceCommon {
    return try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_common_sample($0
        )
    })
}

public func newFactorSourceCommonSampleOther() -> FactorSourceCommon {
    return try! FfiConverterTypeFactorSourceCommon.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_common_sample_other($0
        )
    })
}

public func newFactorSourceCryptoParametersPresetBabylonOlympiaCompatible() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_preset_babylon_olympia_compatible($0
        )
    })
}

public func newFactorSourceCryptoParametersPresetBabylonOnly() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_preset_babylon_only($0
        )
    })
}

public func newFactorSourceCryptoParametersPresetOlympiaOnly() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_preset_olympia_only($0
        )
    })
}

public func newFactorSourceCryptoParametersSample() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_sample($0
        )
    })
}

public func newFactorSourceCryptoParametersSampleOther() -> FactorSourceCryptoParameters {
    return try! FfiConverterTypeFactorSourceCryptoParameters.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_crypto_parameters_sample_other($0
        )
    })
}

public func newFactorSourceIDFromAddressFromJsonBytes(jsonBytes: BagOfBytes) throws -> FactorSourceIdFromAddress {
    return try FfiConverterTypeFactorSourceIDFromAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_factor_source_i_d_from_address_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newFactorSourceIDFromHashFromJsonBytes(jsonBytes: BagOfBytes) throws -> FactorSourceIdFromHash {
    return try FfiConverterTypeFactorSourceIDFromHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_factor_source_i_d_from_hash_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newFactorSourceIdFromAddressSample() -> FactorSourceIdFromAddress {
    return try! FfiConverterTypeFactorSourceIDFromAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_address_sample($0
        )
    })
}

public func newFactorSourceIdFromAddressSampleOther() -> FactorSourceIdFromAddress {
    return try! FfiConverterTypeFactorSourceIDFromAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_address_sample_other($0
        )
    })
}

public func newFactorSourceIdFromHashFromMnemonicWithPassphrase(factorSourceKind: FactorSourceKind, mnemonicWithPassphrase: MnemonicWithPassphrase) -> FactorSourceIdFromHash {
    return try! FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_hash_from_mnemonic_with_passphrase(
            FfiConverterTypeFactorSourceKind.lower(factorSourceKind),
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase), $0
        )
    })
}

public func newFactorSourceIdFromHashSample() -> FactorSourceIdFromHash {
    return try! FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_hash_sample($0
        )
    })
}

public func newFactorSourceIdFromHashSampleOther() -> FactorSourceIdFromHash {
    return try! FfiConverterTypeFactorSourceIDFromHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_id_from_hash_sample_other($0
        )
    })
}

public func newFactorSourceIdSample() -> FactorSourceId {
    return try! FfiConverterTypeFactorSourceID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_id_sample($0
        )
    })
}

public func newFactorSourceIdSampleOther() -> FactorSourceId {
    return try! FfiConverterTypeFactorSourceID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_id_sample_other($0
        )
    })
}

public func newFactorSourceKindFromString(string: String) throws -> FactorSourceKind {
    return try FfiConverterTypeFactorSourceKind.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_factor_source_kind_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newFactorSourceKindSample() -> FactorSourceKind {
    return try! FfiConverterTypeFactorSourceKind.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_kind_sample($0
        )
    })
}

public func newFactorSourceKindSampleOther() -> FactorSourceKind {
    return try! FfiConverterTypeFactorSourceKind.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_kind_sample_other($0
        )
    })
}

public func newFactorSourceSample() -> FactorSource {
    return try! FfiConverterTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_sample($0
        )
    })
}

public func newFactorSourceSampleOther() -> FactorSource {
    return try! FfiConverterTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_source_sample_other($0
        )
    })
}

public func newFactorSourcesSample() -> [FactorSource] {
    return try! FfiConverterSequenceTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_sources_sample($0
        )
    })
}

public func newFactorSourcesSampleOther() -> [FactorSource] {
    return try! FfiConverterSequenceTypeFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_factor_sources_sample_other($0
        )
    })
}

public func newFiatCurrencyFromJsonString(jsonString: String) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_fiat_currency_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newFiatCurrencySample() -> FiatCurrency {
    return try! FfiConverterTypeFiatCurrency.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_fiat_currency_sample($0
        )
    })
}

public func newFiatCurrencySampleOther() -> FiatCurrency {
    return try! FfiConverterTypeFiatCurrency.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_fiat_currency_sample_other($0
        )
    })
}

public func newFungibleResourceIndicatorSample() -> FungibleResourceIndicator {
    return try! FfiConverterTypeFungibleResourceIndicator.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_fungible_resource_indicator_sample($0
        )
    })
}

public func newFungibleResourceIndicatorSampleOther() -> FungibleResourceIndicator {
    return try! FfiConverterTypeFungibleResourceIndicator.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_fungible_resource_indicator_sample_other($0
        )
    })
}

public func newGatewayForNetworkId(networkId: NetworkId) -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_gateway_for_network_id(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newGatewaySample() -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_gateway_sample($0
        )
    })
}

public func newGatewaySampleOther() -> Gateway {
    return try! FfiConverterTypeGateway.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_gateway_sample_other($0
        )
    })
}

public func newGatewayWithUrlOnNetwork(url: String, networkId: NetworkId) throws -> Gateway {
    return try FfiConverterTypeGateway.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_gateway_with_url_on_network(
            FfiConverterString.lower(url),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newGatewaysSample() -> [Gateway] {
    return try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_gateways_sample($0
        )
    })
}

public func newGatewaysSampleOther() -> [Gateway] {
    return try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_gateways_sample_other($0
        )
    })
}

public func newHardenedSample() -> Hardened {
    return try! FfiConverterTypeHardened.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hardened_sample($0
        )
    })
}

public func newHardenedSampleOther() -> Hardened {
    return try! FfiConverterTypeHardened.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hardened_sample_other($0
        )
    })
}

public func newHashFromBytes(bytes: Exactly32Bytes) -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hash_from_bytes(
            FfiConverterTypeExactly32Bytes.lower(bytes), $0
        )
    })
}

public func newHashFromString(string: String) throws -> Hash {
    return try FfiConverterTypeHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_hash_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newHashSample() -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hash_sample($0
        )
    })
}

public func newHashSampleOther() -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hash_sample_other($0
        )
    })
}

public func newHdPathComponentFromGlobalKeySpace(value: UInt32) -> HdPathComponent {
    return try! FfiConverterTypeHDPathComponent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hd_path_component_from_global_key_space(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

public func newHdPathComponentFromLocalKeySpace(value: UInt32, keySpace: KeySpace) throws -> HdPathComponent {
    return try FfiConverterTypeHDPathComponent.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_hd_path_component_from_local_key_space(
            FfiConverterUInt32.lower(value),
            FfiConverterTypeKeySpace.lower(keySpace), $0
        )
    })
}

public func newHdPathComponentSample() -> HdPathComponent {
    return try! FfiConverterTypeHDPathComponent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hd_path_component_sample($0
        )
    })
}

public func newHdPathComponentSampleOther() -> HdPathComponent {
    return try! FfiConverterTypeHDPathComponent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hd_path_component_sample_other($0
        )
    })
}

public func newHeaderFromJsonBytes(jsonBytes: BagOfBytes) throws -> Header {
    return try FfiConverterTypeHeader.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_header_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newHeaderSample() -> Header {
    return try! FfiConverterTypeHeader.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_header_sample($0
        )
    })
}

public func newHeaderSampleOther() -> Header {
    return try! FfiConverterTypeHeader.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_header_sample_other($0
        )
    })
}

/**
 * Instantiates a new `Header` with creating and last used on `DeviceInfo` with
 * "Unknown device" as description, and empty content hint
 */
public func newHeaderWithCreatingDevice(creatingDevice: DeviceInfo) -> Header {
    return try! FfiConverterTypeHeader.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_header_with_creating_device(
            FfiConverterTypeDeviceInfo.lower(creatingDevice), $0
        )
    })
}

public func newHiddenResourcesSample() -> [ResourceIdentifier] {
    return try! FfiConverterSequenceTypeResourceIdentifier.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hidden_resources_sample($0
        )
    })
}

public func newHiddenResourcesSampleOther() -> [ResourceIdentifier] {
    return try! FfiConverterSequenceTypeResourceIdentifier.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hidden_resources_sample_other($0
        )
    })
}

public func newHierarchicalDeterministicFactorInstanceSample() -> HierarchicalDeterministicFactorInstance {
    return try! FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hierarchical_deterministic_factor_instance_sample($0
        )
    })
}

public func newHierarchicalDeterministicFactorInstanceSampleOther() -> HierarchicalDeterministicFactorInstance {
    return try! FfiConverterTypeHierarchicalDeterministicFactorInstance.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hierarchical_deterministic_factor_instance_sample_other($0
        )
    })
}

public func newHierarchicalDeterministicPublicKeySample() -> HierarchicalDeterministicPublicKey {
    return try! FfiConverterTypeHierarchicalDeterministicPublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hierarchical_deterministic_public_key_sample($0
        )
    })
}

public func newHierarchicalDeterministicPublicKeySampleOther() -> HierarchicalDeterministicPublicKey {
    return try! FfiConverterTypeHierarchicalDeterministicPublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_hierarchical_deterministic_public_key_sample_other($0
        )
    })
}

public func newHostIdFromJsonBytes(jsonBytes: BagOfBytes) throws -> HostId {
    return try FfiConverterTypeHostId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_host_id_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newHostIdSample() -> HostId {
    return try! FfiConverterTypeHostId.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_host_id_sample($0
        )
    })
}

public func newHostIdSampleOther() -> HostId {
    return try! FfiConverterTypeHostId.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_host_id_sample_other($0
        )
    })
}

public func newHostInfoSample() -> HostInfo {
    return try! FfiConverterTypeHostInfo.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_host_info_sample($0
        )
    })
}

public func newHostInfoSampleOther() -> HostInfo {
    return try! FfiConverterTypeHostInfo.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_host_info_sample_other($0
        )
    })
}

public func newHostOsAndroid(vendor: String, version: String) -> HostOs {
    return try! FfiConverterTypeHostOS.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_host_os_android(
            FfiConverterString.lower(vendor),
            FfiConverterString.lower(version), $0
        )
    })
}

public func newHostOsIos(version: String) -> HostOs {
    return try! FfiConverterTypeHostOS.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_host_os_ios(
            FfiConverterString.lower(version), $0
        )
    })
}

public func newHostOsOther(name: String, vendor: String, version: String) -> HostOs {
    return try! FfiConverterTypeHostOS.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_host_os_other(
            FfiConverterString.lower(name),
            FfiConverterString.lower(vendor),
            FfiConverterString.lower(version), $0
        )
    })
}

public func newHostOsSample() -> HostOs {
    return try! FfiConverterTypeHostOS.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_host_os_sample($0
        )
    })
}

public func newHostOsSampleOther() -> HostOs {
    return try! FfiConverterTypeHostOS.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_host_os_sample_other($0
        )
    })
}

public func newIdentityAddress(bech32: String) throws -> IdentityAddress {
    return try FfiConverterTypeIdentityAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_identity_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

public func newIdentityAddressFrom(publicKey: PublicKey, networkId: NetworkId) -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_identity_address_from(
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newIdentityAddressRandom(networkId: NetworkId) -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_identity_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newIdentityAddressSampleMainnet() -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_identity_address_sample_mainnet($0
        )
    })
}

public func newIdentityAddressSampleMainnetOther() -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_identity_address_sample_mainnet_other($0
        )
    })
}

public func newIdentityAddressSampleStokenet() -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_identity_address_sample_stokenet($0
        )
    })
}

public func newIdentityAddressSampleStokenetOther() -> IdentityAddress {
    return try! FfiConverterTypeIdentityAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_identity_address_sample_stokenet_other($0
        )
    })
}

public func newIdentityPath(networkId: NetworkId, keyKind: Cap26KeyKind, index: Hardened) -> IdentityPath {
    return try! FfiConverterTypeIdentityPath.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_identity_path(
            FfiConverterTypeNetworkID.lower(networkId),
            FfiConverterTypeCAP26KeyKind.lower(keyKind),
            FfiConverterTypeHardened.lower(index), $0
        )
    })
}

public func newIdentityPathSample() -> IdentityPath {
    return try! FfiConverterTypeIdentityPath.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_identity_path_sample($0
        )
    })
}

public func newIdentityPathSampleOther() -> IdentityPath {
    return try! FfiConverterTypeIdentityPath.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_identity_path_sample_other($0
        )
    })
}

public func newIntentDiscriminatorFromU64(value: UInt64) -> IntentDiscriminator {
    return try! FfiConverterTypeIntentDiscriminator.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_intent_discriminator_from_u64(
            FfiConverterUInt64.lower(value), $0
        )
    })
}

public func newIntentDiscriminatorRandom() -> IntentDiscriminator {
    return try! FfiConverterTypeIntentDiscriminator.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_intent_discriminator_random($0
        )
    })
}

public func newIntentDiscriminatorSample() -> IntentDiscriminator {
    return try! FfiConverterTypeIntentDiscriminator.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_intent_discriminator_sample($0
        )
    })
}

public func newIntentDiscriminatorSampleOther() -> IntentDiscriminator {
    return try! FfiConverterTypeIntentDiscriminator.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_intent_discriminator_sample_other($0
        )
    })
}

public func newIntentHeaderV2Sample() -> IntentHeaderV2 {
    return try! FfiConverterTypeIntentHeaderV2.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_intent_header_v2_sample($0
        )
    })
}

public func newIntentHeaderV2SampleOther() -> IntentHeaderV2 {
    return try! FfiConverterTypeIntentHeaderV2.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_intent_header_v2_sample_other($0
        )
    })
}

public func newIntentSignatureFromSignatureWithPublicKey(signatureWithPublicKey: SignatureWithPublicKey) -> IntentSignature {
    return try! FfiConverterTypeIntentSignature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_intent_signature_from_signature_with_public_key(
            FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey), $0
        )
    })
}

public func newIntentSignatureSample() -> IntentSignature {
    return try! FfiConverterTypeIntentSignature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_intent_signature_sample($0
        )
    })
}

public func newIntentSignatureSampleOther() -> IntentSignature {
    return try! FfiConverterTypeIntentSignature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_intent_signature_sample_other($0
        )
    })
}

/**
 * Creates a Secp256k1PublicKey from either compressed form (33 bytes) or
 * from uncompressed form (65 bytes).
 */
public func newKeyAgreementPublicKeyFromBytes(bytes: BagOfBytes) throws -> KeyAgreementPublicKey {
    return try FfiConverterTypeKeyAgreementPublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_key_agreement_public_key_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newKeyAgreementPublicKeyFromHex(hex: String) throws -> KeyAgreementPublicKey {
    return try FfiConverterTypeKeyAgreementPublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_key_agreement_public_key_from_hex(
            FfiConverterString.lower(hex), $0
        )
    })
}

public func newKeyAgreementPublicKeySample() -> KeyAgreementPublicKey {
    return try! FfiConverterTypeKeyAgreementPublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_key_agreement_public_key_sample($0
        )
    })
}

public func newKeyAgreementPublicKeySampleOther() -> KeyAgreementPublicKey {
    return try! FfiConverterTypeKeyAgreementPublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_key_agreement_public_key_sample_other($0
        )
    })
}

public func newKeySpaceSample() -> KeySpace {
    return try! FfiConverterTypeKeySpace.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_key_space_sample($0
        )
    })
}

public func newKeySpaceSampleOther() -> KeySpace {
    return try! FfiConverterTypeKeySpace.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_key_space_sample_other($0
        )
    })
}

public func newLedgerHardwareWalletFactorSourceSample() -> LedgerHardwareWalletFactorSource {
    return try! FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_ledger_hardware_wallet_factor_source_sample($0
        )
    })
}

public func newLedgerHardwareWalletFactorSourceSampleOther() -> LedgerHardwareWalletFactorSource {
    return try! FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_ledger_hardware_wallet_factor_source_sample_other($0
        )
    })
}

public func newLedgerHardwareWalletFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: LedgerHardwareWalletHint, common: FactorSourceCommon) -> LedgerHardwareWalletFactorSource {
    return try! FfiConverterTypeLedgerHardwareWalletFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_ledger_hardware_wallet_from_mnemonic_with_passphrase(
            FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
            FfiConverterTypeLedgerHardwareWalletHint.lower(hint),
            FfiConverterTypeFactorSourceCommon.lower(common), $0
        )
    })
}

public func newLedgerHwWalletModelFromString(string: String) throws -> LedgerHardwareWalletModel {
    return try FfiConverterTypeLedgerHardwareWalletModel.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_ledger_hw_wallet_model_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newLedgerHwWalletModelSample() -> LedgerHardwareWalletModel {
    return try! FfiConverterTypeLedgerHardwareWalletModel.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_ledger_hw_wallet_model_sample($0
        )
    })
}

public func newLedgerHwWalletModelSampleOther() -> LedgerHardwareWalletModel {
    return try! FfiConverterTypeLedgerHardwareWalletModel.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_ledger_hw_wallet_model_sample_other($0
        )
    })
}

public func newLegacyOlympiaAccountAddressFromPublicKey(publicKey: Secp256k1PublicKey) -> LegacyOlympiaAccountAddress {
    return try! FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_legacy_olympia_account_address_from_public_key(
            FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
        )
    })
}

public func newLegacyOlympiaAccountAddressFromString(string: String) throws -> LegacyOlympiaAccountAddress {
    return try FfiConverterTypeLegacyOlympiaAccountAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_legacy_olympia_account_address_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newLegacyOlympiaAccountAddressSample() -> LegacyOlympiaAccountAddress {
    return try! FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_legacy_olympia_account_address_sample($0
        )
    })
}

public func newLegacyOlympiaAccountAddressSampleOther() -> LegacyOlympiaAccountAddress {
    return try! FfiConverterTypeLegacyOlympiaAccountAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_legacy_olympia_account_address_sample_other($0
        )
    })
}

public func newLinkConnectionQRDataFromJsonBytes(jsonBytes: BagOfBytes) throws -> LinkConnectionQrData {
    return try FfiConverterTypeLinkConnectionQRData.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_link_connection_q_r_data_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newLinkConnectionQrDataSample() -> LinkConnectionQrData {
    return try! FfiConverterTypeLinkConnectionQRData.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_link_connection_qr_data_sample($0
        )
    })
}

public func newLinkConnectionQrDataSampleOther() -> LinkConnectionQrData {
    return try! FfiConverterTypeLinkConnectionQRData.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_link_connection_qr_data_sample_other($0
        )
    })
}

public func newLockerAddress(bech32: String) throws -> LockerAddress {
    return try FfiConverterTypeLockerAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_locker_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newLockerAddressRandom(networkId: NetworkId) -> LockerAddress {
    return try! FfiConverterTypeLockerAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_locker_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newLockerAddressSampleMainnet() -> LockerAddress {
    return try! FfiConverterTypeLockerAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_locker_address_sample_mainnet($0
        )
    })
}

public func newLockerAddressSampleMainnetOther() -> LockerAddress {
    return try! FfiConverterTypeLockerAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_locker_address_sample_mainnet_other($0
        )
    })
}

public func newLockerAddressSampleStokenet() -> LockerAddress {
    return try! FfiConverterTypeLockerAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_locker_address_sample_stokenet($0
        )
    })
}

public func newLockerAddressSampleStokenetOther() -> LockerAddress {
    return try! FfiConverterTypeLockerAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_locker_address_sample_stokenet_other($0
        )
    })
}

public func newManifestEncounteredComponentAddressFromBech32(string: String) throws -> ManifestEncounteredComponentAddress {
    return try FfiConverterTypeManifestEncounteredComponentAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_from_bech32(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newManifestEncounteredComponentAddressSampleMainnet() -> ManifestEncounteredComponentAddress {
    return try! FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_sample_mainnet($0
        )
    })
}

public func newManifestEncounteredComponentAddressSampleMainnetOther() -> ManifestEncounteredComponentAddress {
    return try! FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_sample_mainnet_other($0
        )
    })
}

public func newManifestEncounteredComponentAddressSampleStokenet() -> ManifestEncounteredComponentAddress {
    return try! FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_sample_stokenet($0
        )
    })
}

public func newManifestEncounteredComponentAddressSampleStokenetOther() -> ManifestEncounteredComponentAddress {
    return try! FfiConverterTypeManifestEncounteredComponentAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_manifest_encountered_component_address_sample_stokenet_other($0
        )
    })
}

public func newMatrixOfFactorSourcesSample() -> MatrixOfFactorSources {
    return try! FfiConverterTypeMatrixOfFactorSources.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_matrix_of_factor_sources_sample($0
        )
    })
}

public func newMatrixOfFactorSourcesSampleOther() -> MatrixOfFactorSources {
    return try! FfiConverterTypeMatrixOfFactorSources.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_matrix_of_factor_sources_sample_other($0
        )
    })
}

public func newMessagePlaintextSample() -> Message {
    return try! FfiConverterTypeMessage.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_message_plaintext_sample($0
        )
    })
}

public func newMessagePlaintextSampleOther() -> Message {
    return try! FfiConverterTypeMessage.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_message_plaintext_sample_other($0
        )
    })
}

public func newMessagePlaintextString(string: String) -> Message {
    return try! FfiConverterTypeMessage.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_message_plaintext_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newMessageV2PlaintextSample() -> MessageV2 {
    return try! FfiConverterTypeMessageV2.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_message_v2_plaintext_sample($0
        )
    })
}

public func newMessageV2PlaintextSampleOther() -> MessageV2 {
    return try! FfiConverterTypeMessageV2.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_message_v2_plaintext_sample_other($0
        )
    })
}

public func newMessageV2PlaintextString(string: String) -> MessageV2 {
    return try! FfiConverterTypeMessageV2.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_message_v2_plaintext_string(
            FfiConverterString.lower(string), $0
        )
    })
}

/**
 * Returns new mnemonic from a string of words
 */
public func newMnemonicFromPhrase(phrase: String) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_from_phrase(
            FfiConverterString.lower(phrase), $0
        )
    })
}

public func newMnemonicFromPhraseLanguage(phrase: String, language: Bip39Language) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_from_phrase_language(
            FfiConverterString.lower(phrase),
            FfiConverterTypeBIP39Language.lower(language), $0
        )
    })
}

public func newMnemonicFromWords(words: [Bip39Word]) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_from_words(
            FfiConverterSequenceTypeBIP39Word.lower(words), $0
        )
    })
}

public func newMnemonicGenerateWithEntropy(entropy: Bip39Entropy, language: Bip39Language) -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_generate_with_entropy(
            FfiConverterTypeBIP39Entropy.lower(entropy),
            FfiConverterTypeBIP39Language.lower(language), $0
        )
    })
}

public func newMnemonicSample() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample($0
        )
    })
}

public func newMnemonicSampleArculus() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_arculus($0
        )
    })
}

public func newMnemonicSampleArculusOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_arculus_other($0
        )
    })
}

public func newMnemonicSampleDevice() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_device($0
        )
    })
}

public func newMnemonicSampleDevice12Words() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_device_12_words($0
        )
    })
}

public func newMnemonicSampleDevice12WordsOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_device_12_words_other($0
        )
    })
}

public func newMnemonicSampleDeviceOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_device_other($0
        )
    })
}

public func newMnemonicSampleLedger() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_ledger($0
        )
    })
}

public func newMnemonicSampleLedgerOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_ledger_other($0
        )
    })
}

public func newMnemonicSampleOffDevice() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_off_device($0
        )
    })
}

public func newMnemonicSampleOffDeviceOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_off_device_other($0
        )
    })
}

public func newMnemonicSampleOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_other($0
        )
    })
}

public func newMnemonicSamplePassphrase() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_passphrase($0
        )
    })
}

public func newMnemonicSamplePassphraseOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_passphrase_other($0
        )
    })
}

public func newMnemonicSampleSecurityQuestions() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_security_questions($0
        )
    })
}

public func newMnemonicSampleSecurityQuestionsOther() -> Mnemonic {
    return try! FfiConverterTypeMnemonic.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_sample_security_questions_other($0
        )
    })
}

public func newMnemonicWithPassphraseFromJsonBytes(jsonBytes: BagOfBytes) throws -> MnemonicWithPassphrase {
    return try FfiConverterTypeMnemonicWithPassphrase.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_with_passphrase_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newMnemonicWithPassphraseSample() -> MnemonicWithPassphrase {
    return try! FfiConverterTypeMnemonicWithPassphrase.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_with_passphrase_sample($0
        )
    })
}

public func newMnemonicWithPassphraseSampleOther() -> MnemonicWithPassphrase {
    return try! FfiConverterTypeMnemonicWithPassphrase.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_mnemonic_with_passphrase_sample_other($0
        )
    })
}

public func newNetworkDefinitionLookupByName(logicalName: String) throws -> NetworkDefinition {
    return try FfiConverterTypeNetworkDefinition.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_network_definition_lookup_by_name(
            FfiConverterString.lower(logicalName), $0
        )
    })
}

public func newNetworkDefinitionSample() -> NetworkDefinition {
    return try! FfiConverterTypeNetworkDefinition.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_network_definition_sample($0
        )
    })
}

public func newNetworkDefinitionSampleOther() -> NetworkDefinition {
    return try! FfiConverterTypeNetworkDefinition.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_network_definition_sample_other($0
        )
    })
}

public func newNetworkIdFromDiscriminant(discriminant: UInt8) throws -> NetworkId {
    return try FfiConverterTypeNetworkID.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_network_id_from_discriminant(
            FfiConverterUInt8.lower(discriminant), $0
        )
    })
}

public func newNetworkMethodSample() -> NetworkMethod {
    return try! FfiConverterTypeNetworkMethod.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_network_method_sample($0
        )
    })
}

public func newNetworkMethodSampleOther() -> NetworkMethod {
    return try! FfiConverterTypeNetworkMethod.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_network_method_sample_other($0
        )
    })
}

public func newNetworkRequestSample() -> NetworkRequest {
    return try! FfiConverterTypeNetworkRequest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_network_request_sample($0
        )
    })
}

public func newNetworkRequestSampleOther() -> NetworkRequest {
    return try! FfiConverterTypeNetworkRequest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_network_request_sample_other($0
        )
    })
}

public func newNonEmptyMax32Bytes(bagOfBytes: BagOfBytes) throws -> NonEmptyMax32Bytes {
    return try FfiConverterTypeNonEmptyMax32Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_non_empty_max_32_bytes(
            FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
        )
    })
}

public func newNonEmptyMax64Bytes(bagOfBytes: BagOfBytes) throws -> NonEmptyMax64Bytes {
    return try FfiConverterTypeNonEmptyMax64Bytes.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_non_empty_max_64_bytes(
            FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
        )
    })
}

public func newNonFungibleGlobalIdFromString(string: String) throws -> NonFungibleGlobalId {
    return try FfiConverterTypeNonFungibleGlobalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_global_id_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newNonFungibleGlobalIdSample() -> NonFungibleGlobalId {
    return try! FfiConverterTypeNonFungibleGlobalId.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_global_id_sample($0
        )
    })
}

public func newNonFungibleGlobalIdSampleOther() -> NonFungibleGlobalId {
    return try! FfiConverterTypeNonFungibleGlobalId.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_global_id_sample_other($0
        )
    })
}

public func newNonFungibleLocalIdBytes(bytes: BagOfBytes) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newNonFungibleLocalIdFromString(localId: String) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_from_string(
            FfiConverterString.lower(localId), $0
        )
    })
}

public func newNonFungibleLocalIdInt(value: UInt64) -> NonFungibleLocalId {
    return try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_int(
            FfiConverterUInt64.lower(value), $0
        )
    })
}

public func newNonFungibleLocalIdRandom() -> NonFungibleLocalId {
    return try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_random($0
        )
    })
}

public func newNonFungibleLocalIdRuid(bytes: BagOfBytes) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_ruid(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newNonFungibleLocalIdSample() -> NonFungibleLocalId {
    return try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_sample($0
        )
    })
}

public func newNonFungibleLocalIdSampleOther() -> NonFungibleLocalId {
    return try! FfiConverterTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_sample_other($0
        )
    })
}

public func newNonFungibleLocalIdString(string: String) throws -> NonFungibleLocalId {
    return try FfiConverterTypeNonFungibleLocalId.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newNonFungibleLocalIdStringFromStr(string: String) throws -> NonFungibleLocalIdString {
    return try FfiConverterTypeNonFungibleLocalIdString.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_local_id_string_from_str(
            FfiConverterString.lower(string), $0
        )
    })
}

/**
 * Tries to bech32 decode the string into a specialized address.
 */
public func newNonFungibleResourceAddress(bech32: String) throws -> NonFungibleResourceAddress {
    return try FfiConverterTypeNonFungibleResourceAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newNonFungibleResourceAddressRandom(networkId: NetworkId) -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newNonFungibleResourceAddressSampleMainnet() -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_sample_mainnet($0
        )
    })
}

public func newNonFungibleResourceAddressSampleMainnetOther() -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_sample_mainnet_other($0
        )
    })
}

public func newNonFungibleResourceAddressSampleStokenet() -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_sample_stokenet($0
        )
    })
}

public func newNonFungibleResourceAddressSampleStokenetOther() -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_address_sample_stokenet_other($0
        )
    })
}

public func newNonFungibleResourceIndicatorSample() -> NonFungibleResourceIndicator {
    return try! FfiConverterTypeNonFungibleResourceIndicator.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_indicator_sample($0
        )
    })
}

public func newNonFungibleResourceIndicatorSampleOther() -> NonFungibleResourceIndicator {
    return try! FfiConverterTypeNonFungibleResourceIndicator.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_non_fungible_resource_indicator_sample_other($0
        )
    })
}

public func newNonceFromU32(value: UInt32) -> Nonce {
    return try! FfiConverterTypeNonce.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_nonce_from_u32(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

public func newNonceRandom() -> Nonce {
    return try! FfiConverterTypeNonce.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_nonce_random($0
        )
    })
}

public func newNonceSample() -> Nonce {
    return try! FfiConverterTypeNonce.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_nonce_sample($0
        )
    })
}

public func newNonceSampleOther() -> Nonce {
    return try! FfiConverterTypeNonce.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_nonce_sample_other($0
        )
    })
}

public func newNotarizedTransactionSample() -> NotarizedTransaction {
    return try! FfiConverterTypeNotarizedTransaction.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_notarized_transaction_sample($0
        )
    })
}

public func newNotarizedTransactionSampleOther() -> NotarizedTransaction {
    return try! FfiConverterTypeNotarizedTransaction.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_notarized_transaction_sample_other($0
        )
    })
}

public func newNotarySignature(signature: Signature) -> NotarySignature {
    return try! FfiConverterTypeNotarySignature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_notary_signature(
            FfiConverterTypeSignature.lower(signature), $0
        )
    })
}

public func newNotarySignatureSample() -> NotarySignature {
    return try! FfiConverterTypeNotarySignature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_notary_signature_sample($0
        )
    })
}

public func newNotarySignatureSampleOther() -> NotarySignature {
    return try! FfiConverterTypeNotarySignature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_notary_signature_sample_other($0
        )
    })
}

public func newOffDeviceMnemonicFactorSourceFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase, hint: OffDeviceMnemonicHint) -> OffDeviceMnemonicFactorSource {
    return try! FfiConverterTypeOffDeviceMnemonicFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_off_device_mnemonic_factor_source_from_mnemonic_with_passphrase(
            FfiConverterTypeMnemonicWithPassphrase.lower(mwp),
            FfiConverterTypeOffDeviceMnemonicHint.lower(hint), $0
        )
    })
}

public func newOffDeviceMnemonicFactorSourceSample() -> OffDeviceMnemonicFactorSource {
    return try! FfiConverterTypeOffDeviceMnemonicFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_off_device_mnemonic_factor_source_sample($0
        )
    })
}

public func newOffDeviceMnemonicFactorSourceSampleOther() -> OffDeviceMnemonicFactorSource {
    return try! FfiConverterTypeOffDeviceMnemonicFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_off_device_mnemonic_factor_source_sample_other($0
        )
    })
}

public func newOnLedgerSettingsDefault() -> OnLedgerSettings {
    return try! FfiConverterTypeOnLedgerSettings.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_on_ledger_settings_default($0
        )
    })
}

public func newOnLedgerSettingsSample() -> OnLedgerSettings {
    return try! FfiConverterTypeOnLedgerSettings.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_on_ledger_settings_sample($0
        )
    })
}

public func newOnLedgerSettingsSampleOther() -> OnLedgerSettings {
    return try! FfiConverterTypeOnLedgerSettings.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_on_ledger_settings_sample_other($0
        )
    })
}

public func newP2PLinkFromJsonBytes(jsonBytes: BagOfBytes) throws -> P2pLink {
    return try FfiConverterTypeP2PLink.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_p2_p_link_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newP2PLinksSample() -> [P2pLink] {
    return try! FfiConverterSequenceTypeP2PLink.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_p2_p_links_sample($0
        )
    })
}

public func newP2PLinksSampleOther() -> [P2pLink] {
    return try! FfiConverterSequenceTypeP2PLink.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_p2_p_links_sample_other($0
        )
    })
}

public func newP2pLinkSample() -> P2pLink {
    return try! FfiConverterTypeP2PLink.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_p2p_link_sample($0
        )
    })
}

public func newP2pLinkSampleOther() -> P2pLink {
    return try! FfiConverterTypeP2PLink.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_p2p_link_sample_other($0
        )
    })
}

public func newP2pLinksFromJsonBytes(jsonBytes: BagOfBytes) throws -> [P2pLink] {
    return try FfiConverterSequenceTypeP2PLink.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_p2p_links_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newPackageAddress(bech32: String) throws -> PackageAddress {
    return try FfiConverterTypePackageAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_package_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newPackageAddressRandom(networkId: NetworkId) -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_package_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newPackageAddressSampleMainnet() -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_package_address_sample_mainnet($0
        )
    })
}

public func newPackageAddressSampleMainnetOther() -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_package_address_sample_mainnet_other($0
        )
    })
}

public func newPackageAddressSampleStokenet() -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_package_address_sample_stokenet($0
        )
    })
}

public func newPackageAddressSampleStokenetOther() -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_package_address_sample_stokenet_other($0
        )
    })
}

public func newPassphraseFactorSourceFromMnemonicWithPassphrase(mwp: MnemonicWithPassphrase) -> PassphraseFactorSource {
    return try! FfiConverterTypePassphraseFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_passphrase_factor_source_from_mnemonic_with_passphrase(
            FfiConverterTypeMnemonicWithPassphrase.lower(mwp), $0
        )
    })
}

public func newPassphraseFactorSourceSample() -> PassphraseFactorSource {
    return try! FfiConverterTypePassphraseFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_passphrase_factor_source_sample($0
        )
    })
}

public func newPassphraseFactorSourceSampleOther() -> PassphraseFactorSource {
    return try! FfiConverterTypePassphraseFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_passphrase_factor_source_sample_other($0
        )
    })
}

public func newPerAssetTransfersSample() -> PerAssetTransfers {
    return try! FfiConverterTypePerAssetTransfers.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_per_asset_transfers_sample($0
        )
    })
}

public func newPerAssetTransfersSampleOther() -> PerAssetTransfers {
    return try! FfiConverterTypePerAssetTransfers.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_per_asset_transfers_sample_other($0
        )
    })
}

public func newPersonaDataEntryEmailAddressFromJsonString(jsonString: String) throws -> EmailAddress {
    return try FfiConverterTypeEmailAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_persona_data_entry_email_address_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newPersonaDataEntryEmailAddressSample() -> EmailAddress {
    return try! FfiConverterTypeEmailAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_data_entry_email_address_sample($0
        )
    })
}

public func newPersonaDataEntryEmailAddressSampleOther() -> EmailAddress {
    return try! FfiConverterTypeEmailAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_data_entry_email_address_sample_other($0
        )
    })
}

public func newPersonaDataEntryNameFromJsonBytes(jsonBytes: BagOfBytes) throws -> PersonaDataEntryName {
    return try FfiConverterTypePersonaDataEntryName.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_persona_data_entry_name_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newPersonaDataEntryNameSample() -> PersonaDataEntryName {
    return try! FfiConverterTypePersonaDataEntryName.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_data_entry_name_sample($0
        )
    })
}

public func newPersonaDataEntryNameSampleOther() -> PersonaDataEntryName {
    return try! FfiConverterTypePersonaDataEntryName.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_data_entry_name_sample_other($0
        )
    })
}

public func newPersonaDataEntryPhoneNumberFromJsonString(jsonString: String) throws -> PersonaDataEntryPhoneNumber {
    return try FfiConverterTypePersonaDataEntryPhoneNumber.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_persona_data_entry_phone_number_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newPersonaDataEntryPhoneNumberSample() -> PersonaDataEntryPhoneNumber {
    return try! FfiConverterTypePersonaDataEntryPhoneNumber.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_data_entry_phone_number_sample($0
        )
    })
}

public func newPersonaDataEntryPhoneNumberSampleOther() -> PersonaDataEntryPhoneNumber {
    return try! FfiConverterTypePersonaDataEntryPhoneNumber.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_data_entry_phone_number_sample_other($0
        )
    })
}

public func newPersonaDataSample() -> PersonaData {
    return try! FfiConverterTypePersonaData.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_data_sample($0
        )
    })
}

public func newPersonaDataSampleOther() -> PersonaData {
    return try! FfiConverterTypePersonaData.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_data_sample_other($0
        )
    })
}

public func newPersonaSample() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_sample($0
        )
    })
}

public func newPersonaSampleMainnetBatman() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_sample_mainnet_batman($0
        )
    })
}

public func newPersonaSampleMainnetRipley() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_sample_mainnet_ripley($0
        )
    })
}

public func newPersonaSampleMainnetSatoshi() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_sample_mainnet_satoshi($0
        )
    })
}

public func newPersonaSampleMainnetTuring() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_sample_mainnet_turing($0
        )
    })
}

public func newPersonaSampleOther() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_sample_other($0
        )
    })
}

public func newPersonaSampleStokenetConnor() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_sample_stokenet_connor($0
        )
    })
}

public func newPersonaSampleStokenetHermione() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_sample_stokenet_hermione($0
        )
    })
}

public func newPersonaSampleStokenetLeiaSkywalker() -> Persona {
    return try! FfiConverterTypePersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_persona_sample_stokenet_leia_skywalker($0
        )
    })
}

public func newPersonasSample() -> [Persona] {
    return try! FfiConverterSequenceTypePersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_personas_sample($0
        )
    })
}

public func newPersonasSampleOther() -> [Persona] {
    return try! FfiConverterSequenceTypePersona.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_personas_sample_other($0
        )
    })
}

public func newPoolAddress(bech32: String) throws -> PoolAddress {
    return try FfiConverterTypePoolAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_pool_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newPoolAddressRandom(networkId: NetworkId) -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_pool_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Sample to a mainnet PoolAddress with three resources.
 */
public func newPoolAddressSampleMainnetMulti() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_pool_address_sample_mainnet_multi($0
        )
    })
}

/**
 * Sample to a mainnet PoolAddress with single resource.
 */
public func newPoolAddressSampleMainnetSingle() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_pool_address_sample_mainnet_single($0
        )
    })
}

/**
 * Sample to a mainnet PoolAddress with two resources.
 */
public func newPoolAddressSampleMainnetTwo() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_pool_address_sample_mainnet_two($0
        )
    })
}

/**
 * Sample to a stokenet PoolAddress with three resources.
 */
public func newPoolAddressSampleStokenetMulti() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_pool_address_sample_stokenet_multi($0
        )
    })
}

/**
 * Sample to a stokenet PoolAddress with single resource.
 */
public func newPoolAddressSampleStokenetSingle() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_pool_address_sample_stokenet_single($0
        )
    })
}

/**
 * Sample to a stokenet PoolAddress with two resources.
 */
public func newPoolAddressSampleStokenetTwo() -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_pool_address_sample_stokenet_two($0
        )
    })
}

public func newPrivateHdFactorSourceBabylon(isMain: Bool, entropy: NonEmptyMax32Bytes, hostInfo: HostInfo) throws -> PrivateHierarchicalDeterministicFactorSource {
    return try FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_babylon(
            FfiConverterBool.lower(isMain),
            FfiConverterTypeNonEmptyMax32Bytes.lower(entropy),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newPrivateHdFactorSourceBabylonFromMnemonicWithPassphrase(isMain: Bool, mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> PrivateHierarchicalDeterministicFactorSource {
    return try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_babylon_from_mnemonic_with_passphrase(
            FfiConverterBool.lower(isMain),
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newPrivateHdFactorSourceOlympiaFromMnemonicWithPassphrase(mnemonicWithPassphrase: MnemonicWithPassphrase, hostInfo: HostInfo) -> PrivateHierarchicalDeterministicFactorSource {
    return try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_olympia_from_mnemonic_with_passphrase(
            FfiConverterTypeMnemonicWithPassphrase.lower(mnemonicWithPassphrase),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newPrivateHdFactorSourceSample() -> PrivateHierarchicalDeterministicFactorSource {
    return try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_sample($0
        )
    })
}

public func newPrivateHdFactorSourceSampleOther() -> PrivateHierarchicalDeterministicFactorSource {
    return try! FfiConverterTypePrivateHierarchicalDeterministicFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_private_hd_factor_source_sample_other($0
        )
    })
}

/**
 * # Panics
 * Panics if `device_factor_source` is not a main BDFS.
 */
public func newProfile(deviceFactorSource: DeviceFactorSource, hostId: HostId, hostInfo: HostInfo) -> Profile {
    return try! FfiConverterTypeProfile.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_profile(
            FfiConverterTypeDeviceFactorSource.lower(deviceFactorSource),
            FfiConverterTypeHostId.lower(hostId),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

public func newProfileFileContentsSample() -> ProfileFileContents {
    return try! FfiConverterTypeProfileFileContents.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_profile_file_contents_sample($0
        )
    })
}

public func newProfileFileContentsSampleOther() -> ProfileFileContents {
    return try! FfiConverterTypeProfileFileContents.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_profile_file_contents_sample_other($0
        )
    })
}

public func newProfileFromEncryptionBytes(jsonString: String, decryptionPassword: String) throws -> Profile {
    return try FfiConverterTypeProfile.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_profile_from_encryption_bytes(
            FfiConverterString.lower(jsonString),
            FfiConverterString.lower(decryptionPassword), $0
        )
    })
}

public func newProfileFromJsonString(jsonStr: String) throws -> Profile {
    return try FfiConverterTypeProfile.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_profile_from_json_string(
            FfiConverterString.lower(jsonStr), $0
        )
    })
}

public func newProfileIdSample() -> ProfileId {
    return try! FfiConverterTypeProfileID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_profile_id_sample($0
        )
    })
}

public func newProfileIdSampleOther() -> ProfileId {
    return try! FfiConverterTypeProfileID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_profile_id_sample_other($0
        )
    })
}

public func newProfileNetworkSample() -> ProfileNetwork {
    return try! FfiConverterTypeProfileNetwork.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_profile_network_sample($0
        )
    })
}

public func newProfileNetworkSampleOther() -> ProfileNetwork {
    return try! FfiConverterTypeProfileNetwork.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_profile_network_sample_other($0
        )
    })
}

public func newProfileNetworksSample() -> [ProfileNetwork] {
    return try! FfiConverterSequenceTypeProfileNetwork.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_profile_networks_sample($0
        )
    })
}

public func newProfileNetworksSampleOther() -> [ProfileNetwork] {
    return try! FfiConverterSequenceTypeProfileNetwork.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_profile_networks_sample_other($0
        )
    })
}

public func newProfileSample() -> Profile {
    return try! FfiConverterTypeProfile.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_profile_sample($0
        )
    })
}

public func newProfileSampleOther() -> Profile {
    return try! FfiConverterTypeProfile.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_profile_sample_other($0
        )
    })
}

public func newProfileWithMnemonic(mnemonic: Mnemonic, hostId: HostId, hostInfo: HostInfo) -> Profile {
    return try! FfiConverterTypeProfile.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_profile_with_mnemonic(
            FfiConverterTypeMnemonic.lower(mnemonic),
            FfiConverterTypeHostId.lower(hostId),
            FfiConverterTypeHostInfo.lower(hostInfo), $0
        )
    })
}

/**
 * Tries to create a PublicKey from the bytes
 */
public func newPublicKeyFromBytes(bagOfBytes: BagOfBytes) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_public_key_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bagOfBytes), $0
        )
    })
}

/**
 * Tries to create a PublicKey from the hex string
 */
public func newPublicKeyFromHex(hex: String) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_public_key_from_hex(
            FfiConverterString.lower(hex), $0
        )
    })
}

public func newPublicKeyHashOfKey(publicKey: PublicKey) -> PublicKeyHash {
    return try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_public_key_hash_of_key(
            FfiConverterTypePublicKey.lower(publicKey), $0
        )
    })
}

public func newPublicKeyHashSample() -> PublicKeyHash {
    return try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_public_key_hash_sample($0
        )
    })
}

public func newPublicKeyHashSampleOther() -> PublicKeyHash {
    return try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_public_key_hash_sample_other($0
        )
    })
}

public func newPublicKeySample() -> PublicKey {
    return try! FfiConverterTypePublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_public_key_sample($0
        )
    })
}

public func newPublicKeySampleOther() -> PublicKey {
    return try! FfiConverterTypePublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_public_key_sample_other($0
        )
    })
}

public func newRadixConnectMobileSessionRequestFromJsonBytes(jsonBytes: BagOfBytes) throws -> RadixConnectMobileSessionRequest {
    return try FfiConverterTypeRadixConnectMobileSessionRequest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_radix_connect_mobile_session_request_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newRadixConnectMobileSessionRequestSample() -> RadixConnectMobileSessionRequest {
    return try! FfiConverterTypeRadixConnectMobileSessionRequest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_radix_connect_mobile_session_request_sample($0
        )
    })
}

public func newRadixConnectMobileSessionRequestSampleOther() -> RadixConnectMobileSessionRequest {
    return try! FfiConverterTypeRadixConnectMobileSessionRequest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_radix_connect_mobile_session_request_sample_other($0
        )
    })
}

public func newRadixConnectPassword(bytes: Exactly32Bytes) -> RadixConnectPassword {
    return try! FfiConverterTypeRadixConnectPassword.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_radix_connect_password(
            FfiConverterTypeExactly32Bytes.lower(bytes), $0
        )
    })
}

public func newRadixConnectPasswordFromJsonString(jsonString: String) throws -> RadixConnectPassword {
    return try FfiConverterTypeRadixConnectPassword.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_radix_connect_password_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newRadixConnectPasswordSample() -> RadixConnectPassword {
    return try! FfiConverterTypeRadixConnectPassword.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_radix_connect_password_sample($0
        )
    })
}

public func newRadixConnectPasswordSampleOther() -> RadixConnectPassword {
    return try! FfiConverterTypeRadixConnectPassword.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_radix_connect_password_sample_other($0
        )
    })
}

public func newRadixConnectPurposeFromJsonString(jsonString: String) throws -> RadixConnectPurpose {
    return try FfiConverterTypeRadixConnectPurpose.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_radix_connect_purpose_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newRadixConnectPurposeFromString(string: String) -> RadixConnectPurpose {
    return try! FfiConverterTypeRadixConnectPurpose.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_radix_connect_purpose_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newRadixConnectPurposeSample() -> RadixConnectPurpose {
    return try! FfiConverterTypeRadixConnectPurpose.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_radix_connect_purpose_sample($0
        )
    })
}

public func newRadixConnectPurposeSampleOther() -> RadixConnectPurpose {
    return try! FfiConverterTypeRadixConnectPurpose.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_radix_connect_purpose_sample_other($0
        )
    })
}

public func newReferencesToAuthorizedPersonasSample() -> [AuthorizedPersonaSimple] {
    return try! FfiConverterSequenceTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_references_to_authorized_personas_sample($0
        )
    })
}

public func newReferencesToAuthorizedPersonasSampleOther() -> [AuthorizedPersonaSimple] {
    return try! FfiConverterSequenceTypeAuthorizedPersonaSimple.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_references_to_authorized_personas_sample_other($0
        )
    })
}

public func newRequestedQuantityFromJsonBytes(jsonBytes: BagOfBytes) throws -> RequestedQuantity {
    return try FfiConverterTypeRequestedQuantity.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_requested_quantity_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newRequestedQuantitySample() -> RequestedQuantity {
    return try! FfiConverterTypeRequestedQuantity.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_requested_quantity_sample($0
        )
    })
}

public func newRequestedQuantitySampleOther() -> RequestedQuantity {
    return try! FfiConverterTypeRequestedQuantity.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_requested_quantity_sample_other($0
        )
    })
}

public func newResourceAddress(bech32: String) throws -> ResourceAddress {
    return try FfiConverterTypeResourceAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_resource_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newResourceAddressRandom(networkId: NetworkId) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newResourceAddressSampleMainnetCandy() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_address_sample_mainnet_candy($0
        )
    })
}

public func newResourceAddressSampleMainnetNftGcMembership() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_address_sample_mainnet_nft_gc_membership($0
        )
    })
}

public func newResourceAddressSampleMainnetXrd() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_address_sample_mainnet_xrd($0
        )
    })
}

public func newResourceAddressSampleStokenetCandy() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_address_sample_stokenet_candy($0
        )
    })
}

public func newResourceAddressSampleStokenetGcTokens() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_address_sample_stokenet_gc_tokens($0
        )
    })
}

public func newResourceAddressSampleStokenetGum() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_address_sample_stokenet_gum($0
        )
    })
}

public func newResourceAddressSampleStokenetXrd() -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_address_sample_stokenet_xrd($0
        )
    })
}

public func newResourceIndicatorSample() -> ResourceIndicator {
    return try! FfiConverterTypeResourceIndicator.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_indicator_sample($0
        )
    })
}

public func newResourceIndicatorSampleOther() -> ResourceIndicator {
    return try! FfiConverterTypeResourceIndicator.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_indicator_sample_other($0
        )
    })
}

public func newResourceOrNonFungibleSample() -> ResourceOrNonFungible {
    return try! FfiConverterTypeResourceOrNonFungible.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_or_non_fungible_sample($0
        )
    })
}

public func newResourceOrNonFungibleSampleOther() -> ResourceOrNonFungible {
    return try! FfiConverterTypeResourceOrNonFungible.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_or_non_fungible_sample_other($0
        )
    })
}

public func newResourcePreferencesSample() -> [ResourceAppPreference] {
    return try! FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_preferences_sample($0
        )
    })
}

public func newResourcePreferencesSampleOther() -> [ResourceAppPreference] {
    return try! FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_preferences_sample_other($0
        )
    })
}

public func newResourceSpecifierSample() -> ResourceSpecifier {
    return try! FfiConverterTypeResourceSpecifier.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_specifier_sample($0
        )
    })
}

public func newResourceSpecifierSampleOther() -> ResourceSpecifier {
    return try! FfiConverterTypeResourceSpecifier.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_resource_specifier_sample_other($0
        )
    })
}

public func newSLIP10CurveFromJsonString(jsonString: String) throws -> Slip10Curve {
    return try FfiConverterTypeSLIP10Curve.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_s_l_i_p10_curve_from_json_string(
            FfiConverterString.lower(jsonString), $0
        )
    })
}

public func newSargonBuildInformationSample() -> SargonBuildInformation {
    return try! FfiConverterTypeSargonBuildInformation.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_sargon_build_information_sample($0
        )
    })
}

public func newSargonBuildInformationSampleOther() -> SargonBuildInformation {
    return try! FfiConverterTypeSargonBuildInformation.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_sargon_build_information_sample_other($0
        )
    })
}

/**
 * Constructs `Gateways` with `current` set as active Gateway.
 */
public func newSavedGateways(current: Gateway) -> SavedGateways {
    return try! FfiConverterTypeSavedGateways.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_saved_gateways(
            FfiConverterTypeGateway.lower(current), $0
        )
    })
}

public func newSavedGatewaysChangingCurrent(to: Gateway, gateways: SavedGateways) throws -> SavedGateways {
    return try FfiConverterTypeSavedGateways.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_saved_gateways_changing_current(
            FfiConverterTypeGateway.lower(to),
            FfiConverterTypeSavedGateways.lower(gateways), $0
        )
    })
}

/**
 * Constructs `Gateways` with default preset values.
 */
public func newSavedGatewaysDefault() -> SavedGateways {
    return try! FfiConverterTypeSavedGateways.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_saved_gateways_default($0
        )
    })
}

/**
 * A sample value useful for tests and previews.
 */
public func newSavedGatewaysSample() -> SavedGateways {
    return try! FfiConverterTypeSavedGateways.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_saved_gateways_sample($0
        )
    })
}

/**
 * A sample value useful for tests and previews.
 */
public func newSavedGatewaysSampleOther() -> SavedGateways {
    return try! FfiConverterTypeSavedGateways.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_saved_gateways_sample_other($0
        )
    })
}

/**
 * Creates a Secp256k1PublicKey from either compressed form (33 bytes) or
 * from uncompressed form (65 bytes).
 */
public func newSecp256k1PublicKeyFromBytes(bytes: BagOfBytes) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_secp256k1_public_key_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newSecp256k1PublicKeyFromHex(hex: String) throws -> Secp256k1PublicKey {
    return try FfiConverterTypeSecp256k1PublicKey.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_secp256k1_public_key_from_hex(
            FfiConverterString.lower(hex), $0
        )
    })
}

public func newSecp256k1PublicKeySample() -> Secp256k1PublicKey {
    return try! FfiConverterTypeSecp256k1PublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_secp256k1_public_key_sample($0
        )
    })
}

public func newSecp256k1PublicKeySampleOther() -> Secp256k1PublicKey {
    return try! FfiConverterTypeSecp256k1PublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_secp256k1_public_key_sample_other($0
        )
    })
}

public func newSecp256k1SignatureFromBytes(bytes: BagOfBytes) throws -> Secp256k1Signature {
    return try FfiConverterTypeSecp256k1Signature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_secp256k1_signature_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newSecp256k1SignatureFromExactly65Bytes(bytes: Exactly65Bytes) -> Secp256k1Signature {
    return try! FfiConverterTypeSecp256k1Signature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_secp256k1_signature_from_exactly_65_bytes(
            FfiConverterTypeExactly65Bytes.lower(bytes), $0
        )
    })
}

public func newSecp256k1SignatureSample() -> Secp256k1Signature {
    return try! FfiConverterTypeSecp256k1Signature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_secp256k1_signature_sample($0
        )
    })
}

public func newSecp256k1SignatureSampleOther() -> Secp256k1Signature {
    return try! FfiConverterTypeSecp256k1Signature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_secp256k1_signature_sample_other($0
        )
    })
}

public func newSecurified(u30: U30) -> SecurifiedU30 {
    return try! FfiConverterTypeSecurifiedU30.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_securified(
            FfiConverterTypeU30.lower(u30), $0
        )
    })
}

public func newSecurifiedFromGlobalKeySpace(value: UInt32) throws -> SecurifiedU30 {
    return try FfiConverterTypeSecurifiedU30.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_securified_from_global_key_space(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

public func newSecurifiedFromLocalKeySpace(value: UInt32) throws -> SecurifiedU30 {
    return try FfiConverterTypeSecurifiedU30.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_securified_from_local_key_space(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

public func newSecurifiedSample() -> SecurifiedU30 {
    return try! FfiConverterTypeSecurifiedU30.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_securified_sample($0
        )
    })
}

public func newSecurifiedSampleOther() -> SecurifiedU30 {
    return try! FfiConverterTypeSecurifiedU30.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_securified_sample_other($0
        )
    })
}

public func newSecurityNOTPRODUCTIONREADYQuestionsAndAnswersSample() -> [SecurityNotProductionReadyQuestionAndAnswer] {
    return try! FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_and_answers_sample($0
        )
    })
}

public func newSecurityNOTPRODUCTIONREADYQuestionsAndAnswersSampleOther() -> [SecurityNotProductionReadyQuestionAndAnswer] {
    return try! FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_and_answers_sample_other($0
        )
    })
}

public func newSecurityQuestionsFactorSourceByEncryptingMnemonic(mnemonic: Mnemonic, with: [SecurityNotProductionReadyQuestionAndAnswer]) throws -> SecurityQuestionsNotProductionReadyFactorSource {
    return try FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_security_questions_factor_source_by_encrypting_mnemonic(
            FfiConverterTypeMnemonic.lower(mnemonic),
            FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lower(with), $0
        )
    })
}

public func newSecurityQuestionsFactorSourceSample() -> SecurityQuestionsNotProductionReadyFactorSource {
    return try! FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_questions_factor_source_sample($0
        )
    })
}

public func newSecurityQuestionsFactorSourceSampleOther() -> SecurityQuestionsNotProductionReadyFactorSource {
    return try! FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_questions_factor_source_sample_other($0
        )
    })
}

public func newSecurityStructureMetadataNamed(name: DisplayName) -> SecurityStructureMetadata {
    return try! FfiConverterTypeSecurityStructureMetadata.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_structure_metadata_named(
            FfiConverterTypeDisplayName.lower(name), $0
        )
    })
}

public func newSecurityStructureMetadataSample() -> SecurityStructureMetadata {
    return try! FfiConverterTypeSecurityStructureMetadata.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_structure_metadata_sample($0
        )
    })
}

public func newSecurityStructureMetadataSampleOther() -> SecurityStructureMetadata {
    return try! FfiConverterTypeSecurityStructureMetadata.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_structure_metadata_sample_other($0
        )
    })
}

public func newSecurityStructureOfFactorSourceIdsSample() -> SecurityStructureOfFactorSourceIDs {
    return try! FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_source_ids_sample($0
        )
    })
}

public func newSecurityStructureOfFactorSourceIdsSampleOther() -> SecurityStructureOfFactorSourceIDs {
    return try! FfiConverterTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_source_ids_sample_other($0
        )
    })
}

public func newSecurityStructureOfFactorSourcesAutoInDays(metadata: SecurityStructureMetadata, numberOfDaysUntilAutoConfirmation: UInt16, matrixOfFactors: MatrixOfFactorSources) -> SecurityStructureOfFactorSources {
    return try! FfiConverterTypeSecurityStructureOfFactorSources.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_sources_auto_in_days(
            FfiConverterTypeSecurityStructureMetadata.lower(metadata),
            FfiConverterUInt16.lower(numberOfDaysUntilAutoConfirmation),
            FfiConverterTypeMatrixOfFactorSources.lower(matrixOfFactors), $0
        )
    })
}

public func newSecurityStructureOfFactorSourcesSample() -> SecurityStructureOfFactorSources {
    return try! FfiConverterTypeSecurityStructureOfFactorSources.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_sources_sample($0
        )
    })
}

public func newSecurityStructureOfFactorSourcesSampleOther() -> SecurityStructureOfFactorSources {
    return try! FfiConverterTypeSecurityStructureOfFactorSources.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_structure_of_factor_sources_sample_other($0
        )
    })
}

public func newSecurityStructuresOfFactorSourceIDsSample() -> [SecurityStructureOfFactorSourceIDs] {
    return try! FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_structures_of_factor_source_i_ds_sample($0
        )
    })
}

public func newSecurityStructuresOfFactorSourceIDsSampleOther() -> [SecurityStructureOfFactorSourceIDs] {
    return try! FfiConverterSequenceTypeSecurityStructureOfFactorSourceIDs.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_security_structures_of_factor_source_i_ds_sample_other($0
        )
    })
}

public func newSharedPersonaDataSample() -> SharedPersonaData {
    return try! FfiConverterTypeSharedPersonaData.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_shared_persona_data_sample($0
        )
    })
}

public func newSharedPersonaDataSampleOther() -> SharedPersonaData {
    return try! FfiConverterTypeSharedPersonaData.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_shared_persona_data_sample_other($0
        )
    })
}

public func newSignatureFromBytes(bytes: BagOfBytes) throws -> Signature {
    return try FfiConverterTypeSignature.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_signature_from_bytes(
            FfiConverterTypeBagOfBytes.lower(bytes), $0
        )
    })
}

public func newSignatureSample() -> Signature {
    return try! FfiConverterTypeSignature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_signature_sample($0
        )
    })
}

public func newSignatureSampleOther() -> Signature {
    return try! FfiConverterTypeSignature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_signature_sample_other($0
        )
    })
}

public func newSignatureWithPublicKeySample() -> SignatureWithPublicKey {
    return try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_signature_with_public_key_sample($0
        )
    })
}

public func newSignatureWithPublicKeySampleOther() -> SignatureWithPublicKey {
    return try! FfiConverterTypeSignatureWithPublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_signature_with_public_key_sample_other($0
        )
    })
}

public func newSignedIntentHashSample() -> SignedTransactionIntentHash {
    return try! FfiConverterTypeSignedTransactionIntentHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_signed_intent_hash_sample($0
        )
    })
}

public func newSignedIntentHashSampleOther() -> SignedTransactionIntentHash {
    return try! FfiConverterTypeSignedTransactionIntentHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_signed_intent_hash_sample_other($0
        )
    })
}

public func newSignedIntentSample() -> SignedIntent {
    return try! FfiConverterTypeSignedIntent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_signed_intent_sample($0
        )
    })
}

public func newSignedIntentSampleOther() -> SignedIntent {
    return try! FfiConverterTypeSignedIntent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_signed_intent_sample_other($0
        )
    })
}

public func newSignedTransactionIntentHashFromString(string: String) throws -> SignedTransactionIntentHash {
    return try FfiConverterTypeSignedTransactionIntentHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_signed_transaction_intent_hash_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newSlip10CurveFromString(curve: String) throws -> Slip10Curve {
    return try FfiConverterTypeSLIP10Curve.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_slip10_curve_from_string(
            FfiConverterString.lower(curve), $0
        )
    })
}

public func newStakeClaimSample() -> StakeClaim {
    return try! FfiConverterTypeStakeClaim.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_stake_claim_sample($0
        )
    })
}

public func newStakeClaimSampleOther() -> StakeClaim {
    return try! FfiConverterTypeStakeClaim.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_stake_claim_sample_other($0
        )
    })
}

public func newSubintent(header: IntentHeaderV2, manifest: SubintentManifest, message: MessageV2) throws -> Subintent {
    return try FfiConverterTypeSubintent.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_subintent(
            FfiConverterTypeIntentHeaderV2.lower(header),
            FfiConverterTypeSubintentManifest.lower(manifest),
            FfiConverterTypeMessageV2.lower(message), $0
        )
    })
}

public func newSubintentHashFromString(string: String) throws -> SubintentHash {
    return try FfiConverterTypeSubintentHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_subintent_hash_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newSubintentHashSample() -> SubintentHash {
    return try! FfiConverterTypeSubintentHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_subintent_hash_sample($0
        )
    })
}

public func newSubintentHashSampleOther() -> SubintentHash {
    return try! FfiConverterTypeSubintentHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_subintent_hash_sample_other($0
        )
    })
}

public func newSubintentManifestSample() -> SubintentManifest {
    return try! FfiConverterTypeSubintentManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_subintent_manifest_sample($0
        )
    })
}

public func newSubintentManifestSampleOther() -> SubintentManifest {
    return try! FfiConverterTypeSubintentManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_subintent_manifest_sample_other($0
        )
    })
}

public func newSubintentSample() -> Subintent {
    return try! FfiConverterTypeSubintent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_subintent_sample($0
        )
    })
}

public func newSubintentSampleOther() -> Subintent {
    return try! FfiConverterTypeSubintent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_subintent_sample_other($0
        )
    })
}

public func newSupportedCurvesSample() -> [Slip10Curve] {
    return try! FfiConverterSequenceTypeSLIP10Curve.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_supported_curves_sample($0
        )
    })
}

public func newSupportedCurvesSampleOther() -> [Slip10Curve] {
    return try! FfiConverterSequenceTypeSLIP10Curve.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_supported_curves_sample_other($0
        )
    })
}

public func newThirdPartyDepositsDefault() -> ThirdPartyDeposits {
    return try! FfiConverterTypeThirdPartyDeposits.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_third_party_deposits_default($0
        )
    })
}

public func newThirdPartyDepositsSample() -> ThirdPartyDeposits {
    return try! FfiConverterTypeThirdPartyDeposits.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_third_party_deposits_sample($0
        )
    })
}

public func newThirdPartyDepositsSampleOther() -> ThirdPartyDeposits {
    return try! FfiConverterTypeThirdPartyDeposits.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_third_party_deposits_sample_other($0
        )
    })
}

public func newTransactionHeaderSample() -> TransactionHeader {
    return try! FfiConverterTypeTransactionHeader.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_transaction_header_sample($0
        )
    })
}

public func newTransactionHeaderSampleOther() -> TransactionHeader {
    return try! FfiConverterTypeTransactionHeader.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_transaction_header_sample_other($0
        )
    })
}

public func newTransactionIntentHashFromString(string: String) throws -> TransactionIntentHash {
    return try FfiConverterTypeTransactionIntentHash.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_transaction_intent_hash_from_string(
            FfiConverterString.lower(string), $0
        )
    })
}

public func newTransactionIntentHashSample() -> TransactionIntentHash {
    return try! FfiConverterTypeTransactionIntentHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_transaction_intent_hash_sample($0
        )
    })
}

public func newTransactionIntentHashSampleOther() -> TransactionIntentHash {
    return try! FfiConverterTypeTransactionIntentHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_transaction_intent_hash_sample_other($0
        )
    })
}

public func newTransactionIntentSample() -> TransactionIntent {
    return try! FfiConverterTypeTransactionIntent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_transaction_intent_sample($0
        )
    })
}

public func newTransactionIntentSampleOther() -> TransactionIntent {
    return try! FfiConverterTypeTransactionIntent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_transaction_intent_sample_other($0
        )
    })
}

public func newTransactionManifestFromInstructionsStringAndBlobs(instructionsString: String, networkId: NetworkId, blobs: Blobs) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_transaction_manifest_from_instructions_string_and_blobs(
            FfiConverterString.lower(instructionsString),
            FfiConverterTypeNetworkID.lower(networkId),
            FfiConverterTypeBlobs.lower(blobs), $0
        )
    })
}

public func newTransactionManifestFromUnvalidatedTransactionManifest(unvalidatedTransactionManifest: UnvalidatedTransactionManifest, networkId: NetworkId) throws -> TransactionManifest {
    return try FfiConverterTypeTransactionManifest.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_transaction_manifest_from_unvalidated_transaction_manifest(
            FfiConverterTypeUnvalidatedTransactionManifest.lower(unvalidatedTransactionManifest),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newTransactionManifestSample() -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_transaction_manifest_sample($0
        )
    })
}

public func newTransactionManifestSampleOther() -> TransactionManifest {
    return try! FfiConverterTypeTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_transaction_manifest_sample_other($0
        )
    })
}

public func newTransactionManifestV2Sample() -> TransactionManifestV2 {
    return try! FfiConverterTypeTransactionManifestV2.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_transaction_manifest_v2_sample($0
        )
    })
}

public func newTransactionManifestV2SampleOther() -> TransactionManifestV2 {
    return try! FfiConverterTypeTransactionManifestV2.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_transaction_manifest_v2_sample_other($0
        )
    })
}

public func newTrustedContactFactorSourceContactSample() -> TrustedContactFactorSourceContact {
    return try! FfiConverterTypeTrustedContactFactorSourceContact.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_trusted_contact_factor_source_contact_sample($0
        )
    })
}

public func newTrustedContactFactorSourceContactSampleOther() -> TrustedContactFactorSourceContact {
    return try! FfiConverterTypeTrustedContactFactorSourceContact.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_trusted_contact_factor_source_contact_sample_other($0
        )
    })
}

public func newTrustedContactFactorSourceFromAddressAndContact(accountAddress: AccountAddress, contact: TrustedContactFactorSourceContact) -> TrustedContactFactorSource {
    return try! FfiConverterTypeTrustedContactFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_trusted_contact_factor_source_from_address_and_contact(
            FfiConverterTypeAccountAddress.lower(accountAddress),
            FfiConverterTypeTrustedContactFactorSourceContact.lower(contact), $0
        )
    })
}

public func newTrustedContactFactorSourceSample() -> TrustedContactFactorSource {
    return try! FfiConverterTypeTrustedContactFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_trusted_contact_factor_source_sample($0
        )
    })
}

public func newTrustedContactFactorSourceSampleOther() -> TrustedContactFactorSource {
    return try! FfiConverterTypeTrustedContactFactorSource.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_trusted_contact_factor_source_sample_other($0
        )
    })
}

public func newU30(value: UInt32) throws -> U30 {
    return try FfiConverterTypeU30.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_u30(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

public func newU30Sample() -> U30 {
    return try! FfiConverterTypeU30.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_u30_sample($0
        )
    })
}

public func newU30SampleOther() -> U30 {
    return try! FfiConverterTypeU30.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_u30_sample_other($0
        )
    })
}

public func newU31(value: UInt32) throws -> U31 {
    return try FfiConverterTypeU31.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_u31(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

public func newU31Sample() -> U31 {
    return try! FfiConverterTypeU31.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_u31_sample($0
        )
    })
}

public func newU31SampleOther() -> U31 {
    return try! FfiConverterTypeU31.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_u31_sample_other($0
        )
    })
}

public func newUnhardened(u31: U31) -> Unhardened {
    return try! FfiConverterTypeUnhardened.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unhardened(
            FfiConverterTypeU31.lower(u31), $0
        )
    })
}

public func newUnhardenedFromGlobalKeySpace(value: UInt32) throws -> Unhardened {
    return try FfiConverterTypeUnhardened.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_unhardened_from_global_key_space(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

public func newUnhardenedFromLocalKeySpace(value: UInt32) throws -> Unhardened {
    return try FfiConverterTypeUnhardened.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_unhardened_from_local_key_space(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

public func newUnhardenedSample() -> Unhardened {
    return try! FfiConverterTypeUnhardened.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unhardened_sample($0
        )
    })
}

public func newUnhardenedSampleOther() -> Unhardened {
    return try! FfiConverterTypeUnhardened.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unhardened_sample_other($0
        )
    })
}

public func newUnsecuredEntityControlSample() -> UnsecuredEntityControl {
    return try! FfiConverterTypeUnsecuredEntityControl.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unsecured_entity_control_sample($0
        )
    })
}

public func newUnsecuredEntityControlSampleOther() -> UnsecuredEntityControl {
    return try! FfiConverterTypeUnsecuredEntityControl.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unsecured_entity_control_sample_other($0
        )
    })
}

public func newUnsecurifiedHardened(u30: U30) -> UnsecurifiedHardened {
    return try! FfiConverterTypeUnsecurifiedHardened.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened(
            FfiConverterTypeU30.lower(u30), $0
        )
    })
}

public func newUnsecurifiedHardenedFromGlobalKeySpace(value: UInt32) throws -> UnsecurifiedHardened {
    return try FfiConverterTypeUnsecurifiedHardened.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened_from_global_key_space(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

public func newUnsecurifiedHardenedFromLocalKeySpace(value: UInt32) throws -> UnsecurifiedHardened {
    return try FfiConverterTypeUnsecurifiedHardened.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened_from_local_key_space(
            FfiConverterUInt32.lower(value), $0
        )
    })
}

public func newUnsecurifiedHardenedSample() -> UnsecurifiedHardened {
    return try! FfiConverterTypeUnsecurifiedHardened.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened_sample($0
        )
    })
}

public func newUnsecurifiedHardenedSampleOther() -> UnsecurifiedHardened {
    return try! FfiConverterTypeUnsecurifiedHardened.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unsecurified_hardened_sample_other($0
        )
    })
}

public func newUnsecurifiedSample() -> Unsecurified {
    return try! FfiConverterTypeUnsecurified.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unsecurified_sample($0
        )
    })
}

public func newUnsecurifiedSampleOther() -> Unsecurified {
    return try! FfiConverterTypeUnsecurified.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unsecurified_sample_other($0
        )
    })
}

public func newUnvalidatedSubintentManifestFromSubintentManifest(subintentManifest: SubintentManifest) -> UnvalidatedSubintentManifest {
    return try! FfiConverterTypeUnvalidatedSubintentManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unvalidated_subintent_manifest_from_subintent_manifest(
            FfiConverterTypeSubintentManifest.lower(subintentManifest), $0
        )
    })
}

public func newUnvalidatedSubintentManifestSample() -> UnvalidatedSubintentManifest {
    return try! FfiConverterTypeUnvalidatedSubintentManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unvalidated_subintent_manifest_sample($0
        )
    })
}

public func newUnvalidatedSubintentManifestSampleOther() -> UnvalidatedSubintentManifest {
    return try! FfiConverterTypeUnvalidatedSubintentManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unvalidated_subintent_manifest_sample_other($0
        )
    })
}

public func newUnvalidatedTransactionManifestFromTransactionManifest(transactionManifest: TransactionManifest) -> UnvalidatedTransactionManifest {
    return try! FfiConverterTypeUnvalidatedTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unvalidated_transaction_manifest_from_transaction_manifest(
            FfiConverterTypeTransactionManifest.lower(transactionManifest), $0
        )
    })
}

public func newUnvalidatedTransactionManifestSample() -> UnvalidatedTransactionManifest {
    return try! FfiConverterTypeUnvalidatedTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unvalidated_transaction_manifest_sample($0
        )
    })
}

public func newUnvalidatedTransactionManifestSampleOther() -> UnvalidatedTransactionManifest {
    return try! FfiConverterTypeUnvalidatedTransactionManifest.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_unvalidated_transaction_manifest_sample_other($0
        )
    })
}

public func newValidatorAddress(bech32: String) throws -> ValidatorAddress {
    return try FfiConverterTypeValidatorAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_validator_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newValidatorAddressRandom(networkId: NetworkId) -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_validator_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newValidatorAddressSampleMainnet() -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_validator_address_sample_mainnet($0
        )
    })
}

public func newValidatorAddressSampleMainnetOther() -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_validator_address_sample_mainnet_other($0
        )
    })
}

public func newValidatorAddressSampleStokenet() -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_validator_address_sample_stokenet($0
        )
    })
}

public func newValidatorAddressSampleStokenetOther() -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_validator_address_sample_stokenet_other($0
        )
    })
}

public func newVaultAddress(bech32: String) throws -> VaultAddress {
    return try FfiConverterTypeVaultAddress.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_vault_address(
            FfiConverterString.lower(bech32), $0
        )
    })
}

/**
 * Returns a random address in `network_id` as Network
 */
public func newVaultAddressRandom(networkId: NetworkId) -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_vault_address_random(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func newVaultAddressSampleMainnetFungible() -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_vault_address_sample_mainnet_fungible($0
        )
    })
}

public func newVaultAddressSampleMainnetNonFungible() -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_vault_address_sample_mainnet_non_fungible($0
        )
    })
}

public func newVaultAddressSampleStokenetFungible() -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_vault_address_sample_stokenet_fungible($0
        )
    })
}

public func newVaultAddressSampleStokenetNonFungible() -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_vault_address_sample_stokenet_non_fungible($0
        )
    })
}

public func newVectorImageTypeSample() -> VectorImageType {
    return try! FfiConverterTypeVectorImageType.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_vector_image_type_sample($0
        )
    })
}

public func newVectorImageTypeSampleOther() -> VectorImageType {
    return try! FfiConverterTypeVectorImageType.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_vector_image_type_sample_other($0
        )
    })
}

public func newWalletInteractionVersionCurrent() -> WalletInteractionVersion {
    return try! FfiConverterTypeWalletInteractionVersion.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_wallet_interaction_version_current($0
        )
    })
}

public func newWalletInteractionWalletAccountFromJsonBytes(jsonBytes: BagOfBytes) throws -> WalletInteractionWalletAccount {
    return try FfiConverterTypeWalletInteractionWalletAccount.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_wallet_interaction_wallet_account_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newWalletInteractionWalletAccountSample() -> WalletInteractionWalletAccount {
    return try! FfiConverterTypeWalletInteractionWalletAccount.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_wallet_interaction_wallet_account_sample($0
        )
    })
}

public func newWalletInteractionWalletAccountSampleOther() -> WalletInteractionWalletAccount {
    return try! FfiConverterTypeWalletInteractionWalletAccount.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_wallet_interaction_wallet_account_sample_other($0
        )
    })
}

public func newWalletToDappInteractionPreAuthorizationResponseItems(signedSubintent: SignedSubintent, expirationTimestamp: Timestamp) -> WalletToDappInteractionPreAuthorizationResponseItems {
    return try! FfiConverterTypeWalletToDappInteractionPreAuthorizationResponseItems.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_pre_authorization_response_items(
            FfiConverterTypeSignedSubintent.lower(signedSubintent),
            FfiConverterTypeTimestamp.lower(expirationTimestamp), $0
        )
    })
}

public func newWalletToDappInteractionResponseFromJsonBytes(jsonBytes: BagOfBytes) throws -> WalletToDappInteractionResponse {
    return try FfiConverterTypeWalletToDappInteractionResponse.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_response_from_json_bytes(
            FfiConverterTypeBagOfBytes.lower(jsonBytes), $0
        )
    })
}

public func newWalletToDappInteractionResponseSample() -> WalletToDappInteractionResponse {
    return try! FfiConverterTypeWalletToDappInteractionResponse.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_response_sample($0
        )
    })
}

public func newWalletToDappInteractionResponseSampleOther() -> WalletToDappInteractionResponse {
    return try! FfiConverterTypeWalletToDappInteractionResponse.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_new_wallet_to_dapp_interaction_response_sample_other($0
        )
    })
}

public func nonFungibleGlobalIdFormatted(globalId: NonFungibleGlobalId, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_non_fungible_global_id_formatted(
            FfiConverterTypeNonFungibleGlobalId.lower(globalId),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func nonFungibleGlobalIdToString(globalId: NonFungibleGlobalId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_non_fungible_global_id_to_string(
            FfiConverterTypeNonFungibleGlobalId.lower(globalId), $0
        )
    })
}

public func nonFungibleLocalIdAsStr(id: NonFungibleLocalId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_non_fungible_local_id_as_str(
            FfiConverterTypeNonFungibleLocalId.lower(id), $0
        )
    })
}

public func nonFungibleLocalIdFormatted(id: NonFungibleLocalId, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_non_fungible_local_id_formatted(
            FfiConverterTypeNonFungibleLocalId.lower(id),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func nonFungibleLocalIdToUserFacingString(id: NonFungibleLocalId) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_non_fungible_local_id_to_user_facing_string(
            FfiConverterTypeNonFungibleLocalId.lower(id), $0
        )
    })
}

/**
 * Returns the base address of this specialized address.
 */
public func nonFungibleResourceAddressAsResourceAddress(address: NonFungibleResourceAddress) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_non_fungible_resource_address_as_resource_address(
            FfiConverterTypeNonFungibleResourceAddress.lower(address), $0
        )
    })
}

/**
 * Returns the bech32 encoding of this address
 */
public func nonFungibleResourceAddressBech32Address(address: NonFungibleResourceAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_non_fungible_resource_address_bech32_address(
            FfiConverterTypeNonFungibleResourceAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func nonFungibleResourceAddressMapToNetwork(address: NonFungibleResourceAddress, networkId: NetworkId) -> NonFungibleResourceAddress {
    return try! FfiConverterTypeNonFungibleResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_non_fungible_resource_address_map_to_network(
            FfiConverterTypeNonFungibleResourceAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

/**
 * Returns the network id this address
 */
public func nonFungibleResourceAddressNetworkId(address: NonFungibleResourceAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_non_fungible_resource_address_network_id(
            FfiConverterTypeNonFungibleResourceAddress.lower(address), $0
        )
    })
}

public func nonFungibleResourceIndicatorGetIds(indicator: NonFungibleResourceIndicator) -> [NonFungibleLocalId] {
    return try! FfiConverterSequenceTypeNonFungibleLocalId.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_non_fungible_resource_indicator_get_ids(
            FfiConverterTypeNonFungibleResourceIndicator.lower(indicator), $0
        )
    })
}

public func nonceGetValue(nonce: Nonce) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_nonce_get_value(
            FfiConverterTypeNonce.lower(nonce), $0
        )
    })
}

public func notarizedTransactionCompile(notarizedTransaction: NotarizedTransaction) -> CompiledNotarizedIntent {
    return try! FfiConverterTypeCompiledNotarizedIntent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_notarized_transaction_compile(
            FfiConverterTypeNotarizedTransaction.lower(notarizedTransaction), $0
        )
    })
}

public func notarySignatureGetSignature(notarySignature: NotarySignature) -> Signature {
    return try! FfiConverterTypeSignature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_notary_signature_get_signature(
            FfiConverterTypeNotarySignature.lower(notarySignature), $0
        )
    })
}

public func p2PLinkToJsonBytes(p2PLink: P2pLink) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_p2_p_link_to_json_bytes(
            FfiConverterTypeP2PLink.lower(p2PLink), $0
        )
    })
}

public func p2pLinkId(link: P2pLink) -> PublicKeyHash {
    return try! FfiConverterTypePublicKeyHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_p2p_link_id(
            FfiConverterTypeP2PLink.lower(link), $0
        )
    })
}

public func p2pLinksToJsonBytes(p2pLinks: [P2pLink]) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_p2p_links_to_json_bytes(
            FfiConverterSequenceTypeP2PLink.lower(p2pLinks), $0
        )
    })
}

public func packageAddressBech32Address(address: PackageAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_package_address_bech32_address(
            FfiConverterTypePackageAddress.lower(address), $0
        )
    })
}

public func packageAddressFormatted(address: PackageAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_package_address_formatted(
            FfiConverterTypePackageAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func packageAddressMapToNetwork(address: PackageAddress, networkId: NetworkId) -> PackageAddress {
    return try! FfiConverterTypePackageAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_package_address_map_to_network(
            FfiConverterTypePackageAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func packageAddressNetworkId(address: PackageAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_package_address_network_id(
            FfiConverterTypePackageAddress.lower(address), $0
        )
    })
}

public func personaDataEntryEmailAddressToJsonString(personaDataEntryEmailAddress: EmailAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_persona_data_entry_email_address_to_json_string(
            FfiConverterTypeEmailAddress.lower(personaDataEntryEmailAddress), $0
        )
    })
}

public func personaDataEntryNameToJsonBytes(personaDataEntryName: PersonaDataEntryName) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_persona_data_entry_name_to_json_bytes(
            FfiConverterTypePersonaDataEntryName.lower(personaDataEntryName), $0
        )
    })
}

public func personaDataEntryPhoneNumberToJsonString(personaDataEntryPhoneNumber: PersonaDataEntryPhoneNumber) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_persona_data_entry_phone_number_to_json_string(
            FfiConverterTypePersonaDataEntryPhoneNumber.lower(personaDataEntryPhoneNumber), $0
        )
    })
}

public func personaDataIdentifiedEmailAddressSample() -> PersonaDataIdentifiedEmailAddress {
    return try! FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_persona_data_identified_email_address_sample($0
        )
    })
}

public func personaDataIdentifiedEmailAddressSampleOther() -> PersonaDataIdentifiedEmailAddress {
    return try! FfiConverterTypePersonaDataIdentifiedEmailAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_persona_data_identified_email_address_sample_other($0
        )
    })
}

public func personaDataIdentifiedNameSample() -> PersonaDataIdentifiedName {
    return try! FfiConverterTypePersonaDataIdentifiedName.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_persona_data_identified_name_sample($0
        )
    })
}

public func personaDataIdentifiedNameSampleOther() -> PersonaDataIdentifiedName {
    return try! FfiConverterTypePersonaDataIdentifiedName.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_persona_data_identified_name_sample_other($0
        )
    })
}

public func personaDataIdentifiedPhoneNumberSample() -> PersonaDataIdentifiedPhoneNumber {
    return try! FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_persona_data_identified_phone_number_sample($0
        )
    })
}

public func personaDataIdentifiedPhoneNumberSampleOther() -> PersonaDataIdentifiedPhoneNumber {
    return try! FfiConverterTypePersonaDataIdentifiedPhoneNumber.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_persona_data_identified_phone_number_sample_other($0
        )
    })
}

public func poolAddressBech32Address(address: PoolAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_pool_address_bech32_address(
            FfiConverterTypePoolAddress.lower(address), $0
        )
    })
}

public func poolAddressFormatted(address: PoolAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_pool_address_formatted(
            FfiConverterTypePoolAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns the kind of pool, either 1, 2 or Multi resources.
 */
public func poolAddressKind(address: PoolAddress) -> PoolKind {
    return try! FfiConverterTypePoolKind.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_pool_address_kind(
            FfiConverterTypePoolAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func poolAddressMapToNetwork(address: PoolAddress, networkId: NetworkId) -> PoolAddress {
    return try! FfiConverterTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_pool_address_map_to_network(
            FfiConverterTypePoolAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func poolAddressNetworkId(address: PoolAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_pool_address_network_id(
            FfiConverterTypePoolAddress.lower(address), $0
        )
    })
}

public func profileAnalyzeContentsOfFile(contents: String) -> ProfileFileContents {
    return try! FfiConverterTypeProfileFileContents.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_profile_analyze_contents_of_file(
            FfiConverterString.lower(contents), $0
        )
    })
}

public func profileEncryptWithPassword(profile: Profile, encryptionPassword: String) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_profile_encrypt_with_password(
            FfiConverterTypeProfile.lower(profile),
            FfiConverterString.lower(encryptionPassword), $0
        )
    })
}

public func profileNetworkDetailsForAuthorizedDapp(profileNetwork: ProfileNetwork, dapp: AuthorizedDapp) throws -> AuthorizedDappDetailed {
    return try FfiConverterTypeAuthorizedDappDetailed.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_profile_network_details_for_authorized_dapp(
            FfiConverterTypeProfileNetwork.lower(profileNetwork),
            FfiConverterTypeAuthorizedDapp.lower(dapp), $0
        )
    })
}

public func profileToDebugString(profile: Profile) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_profile_to_debug_string(
            FfiConverterTypeProfile.lower(profile), $0
        )
    })
}

public func profileToJsonString(profile: Profile, prettyPrinted: Bool) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_profile_to_json_string(
            FfiConverterTypeProfile.lower(profile),
            FfiConverterBool.lower(prettyPrinted), $0
        )
    })
}

public func profileToString(profile: Profile) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_profile_to_string(
            FfiConverterTypeProfile.lower(profile), $0
        )
    })
}

/**
 * Verifies an Elliptic Curve signature over either Curve25519 or Secp256k1
 */
public func publicKeyIsValidSignatureForHash(publicKey: PublicKey, signature: Signature, hash: Hash) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_public_key_is_valid_signature_for_hash(
            FfiConverterTypePublicKey.lower(publicKey),
            FfiConverterTypeSignature.lower(signature),
            FfiConverterTypeHash.lower(hash), $0
        )
    })
}

public func publicKeyToBytes(publicKey: PublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_public_key_to_bytes(
            FfiConverterTypePublicKey.lower(publicKey), $0
        )
    })
}

public func publicKeyToHex(publicKey: PublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_public_key_to_hex(
            FfiConverterTypePublicKey.lower(publicKey), $0
        )
    })
}

public func radixConnectMobileSessionRequestToJsonBytes(radixConnectMobileSessionRequest: RadixConnectMobileSessionRequest) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_radix_connect_mobile_session_request_to_json_bytes(
            FfiConverterTypeRadixConnectMobileSessionRequest.lower(radixConnectMobileSessionRequest), $0
        )
    })
}

public func radixConnectPasswordMessageHash(password: RadixConnectPassword) -> Hash {
    return try! FfiConverterTypeHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_radix_connect_password_message_hash(
            FfiConverterTypeRadixConnectPassword.lower(password), $0
        )
    })
}

public func radixConnectPasswordToJsonString(radixConnectPassword: RadixConnectPassword) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_radix_connect_password_to_json_string(
            FfiConverterTypeRadixConnectPassword.lower(radixConnectPassword), $0
        )
    })
}

public func radixConnectPurposeToJsonString(radixConnectPurpose: RadixConnectPurpose) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_radix_connect_purpose_to_json_string(
            FfiConverterTypeRadixConnectPurpose.lower(radixConnectPurpose), $0
        )
    })
}

/**
 * Checks `number_of_ids` can fulfill the [`RequestedQuantity`] (self), `number_of_ids` is
 * considered to be fulfilling the requested quantity:
 * * if: quantifier == ::Exactly && number_of_ids == quantity // ✅ fulfills
 * * else if: quantifier == ::AtLeast && number_of_ids >= quantity // ✅ fulfills
 * * else false // ❌ does NOT fulfill
 */
public func requestedQuantityIsFulfilledByIds(requestedQuantity: RequestedQuantity, numberOfIds: UInt64) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_requested_quantity_is_fulfilled_by_ids(
            FfiConverterTypeRequestedQuantity.lower(requestedQuantity),
            FfiConverterUInt64.lower(numberOfIds), $0
        )
    })
}

public func requestedQuantityIsValid(requestedQuantity: RequestedQuantity) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_requested_quantity_is_valid(
            FfiConverterTypeRequestedQuantity.lower(requestedQuantity), $0
        )
    })
}

public func requestedQuantityToJsonBytes(requestedQuantity: RequestedQuantity) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_requested_quantity_to_json_bytes(
            FfiConverterTypeRequestedQuantity.lower(requestedQuantity), $0
        )
    })
}

public func resourceAddressBech32Address(address: ResourceAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_resource_address_bech32_address(
            FfiConverterTypeResourceAddress.lower(address), $0
        )
    })
}

public func resourceAddressFormatted(address: ResourceAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_resource_address_formatted(
            FfiConverterTypeResourceAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func resourceAddressIsFungible(address: ResourceAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_resource_address_is_fungible(
            FfiConverterTypeResourceAddress.lower(address), $0
        )
    })
}

public func resourceAddressIsNonFungible(address: ResourceAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_resource_address_is_non_fungible(
            FfiConverterTypeResourceAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func resourceAddressMapToNetwork(address: ResourceAddress, networkId: NetworkId) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_resource_address_map_to_network(
            FfiConverterTypeResourceAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func resourceAddressNetworkId(address: ResourceAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_resource_address_network_id(
            FfiConverterTypeResourceAddress.lower(address), $0
        )
    })
}

public func resourceIndicatorGetAddress(indicator: ResourceIndicator) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_resource_indicator_get_address(
            FfiConverterTypeResourceIndicator.lower(indicator), $0
        )
    })
}

public func resourcePreferencesGetHiddenResources(resourcePreferences: [ResourceAppPreference]) -> [ResourceIdentifier] {
    return try! FfiConverterSequenceTypeResourceIdentifier.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_resource_preferences_get_hidden_resources(
            FfiConverterSequenceTypeResourceAppPreference.lower(resourcePreferences), $0
        )
    })
}

public func resourcePreferencesHideResource(resourcePreferences: [ResourceAppPreference], resource: ResourceIdentifier) -> [ResourceAppPreference] {
    return try! FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_resource_preferences_hide_resource(
            FfiConverterSequenceTypeResourceAppPreference.lower(resourcePreferences),
            FfiConverterTypeResourceIdentifier.lower(resource), $0
        )
    })
}

public func resourcePreferencesUnhideResource(resourcePreferences: [ResourceAppPreference], resource: ResourceIdentifier) -> [ResourceAppPreference] {
    return try! FfiConverterSequenceTypeResourceAppPreference.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_resource_preferences_unhide_resource(
            FfiConverterSequenceTypeResourceAppPreference.lower(resourcePreferences),
            FfiConverterTypeResourceIdentifier.lower(resource), $0
        )
    })
}

public func resourceSpecifierGetAddress(specifier: ResourceSpecifier) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_resource_specifier_get_address(
            FfiConverterTypeResourceSpecifier.lower(specifier), $0
        )
    })
}

/**
 * Returns every supported LogFilter
 */
public func rustLoggerGetAllFilters() -> [LogFilter] {
    return try! FfiConverterSequenceTypeLogFilter.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_rust_logger_get_all_filters($0
        )
    })
}

/**
 * Returns every supported LogLevel
 */
public func rustLoggerGetAllLevels() -> [LogLevel] {
    return try! FfiConverterSequenceTypeLogLevel.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_rust_logger_get_all_levels($0
        )
    })
}

public func rustLoggerGetLevel() -> LogFilter {
    return try! FfiConverterTypeLogFilter.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_rust_logger_get_level($0
        )
    })
}

public func rustLoggerLogAtEveryLevel() { try! rustCall {
    uniffi_sargon_uniffi_fn_func_rust_logger_log_at_every_level($0
    )
}
}

public func rustLoggerSetLevel(level: LogFilter) { try! rustCall {
    uniffi_sargon_uniffi_fn_func_rust_logger_set_level(
        FfiConverterTypeLogFilter.lower(level), $0
    )
}
}

public func sLIP10CurveToJsonString(sLIP10Curve: Slip10Curve) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_s_l_i_p10_curve_to_json_string(
            FfiConverterTypeSLIP10Curve.lower(sLIP10Curve), $0
        )
    })
}

/**
 * Returns the current and the other gateways of `gateways`.
 */
public func savedGatewaysGetAllElements(gateways: SavedGateways) -> [Gateway] {
    return try! FfiConverterSequenceTypeGateway.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_saved_gateways_get_all_elements(
            FfiConverterTypeSavedGateways.lower(gateways), $0
        )
    })
}

/**
 * Returns the public key on **compressed** form (33 bytes)
 */
public func secp256k1PublicKeyToBytes(publicKey: Secp256k1PublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_secp256k1_public_key_to_bytes(
            FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
        )
    })
}

/**
 * Returns the public key on **uncompressed** form (65 bytes)
 */
public func secp256k1PublicKeyToBytesUncompressed(publicKey: Secp256k1PublicKey) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_secp256k1_public_key_to_bytes_uncompressed(
            FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
        )
    })
}

/**
 * Encodes the compressed form (33 bytes) of a `Secp256k1PublicKey` to a hexadecimal string, lowercased, without any `0x` prefix, e.g.
 * `"033083620d1596d3f8988ff3270e42970dd2a031e2b9b6488052a4170ff999f3e8"`
 */
public func secp256k1PublicKeyToHex(publicKey: Secp256k1PublicKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_secp256k1_public_key_to_hex(
            FfiConverterTypeSecp256k1PublicKey.lower(publicKey), $0
        )
    })
}

public func secp256k1SignatureToString(signature: Secp256k1Signature) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_secp256k1_signature_to_string(
            FfiConverterTypeSecp256k1Signature.lower(signature), $0
        )
    })
}

public func secureStorageAccessErrorKindIsManualCancellation(kind: SecureStorageAccessErrorKind) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_secure_storage_access_error_kind_is_manual_cancellation(
            FfiConverterTypeSecureStorageAccessErrorKind.lower(kind), $0
        )
    })
}

public func secureStorageKeyIdentifier(key: SecureStorageKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_secure_storage_key_identifier(
            FfiConverterTypeSecureStorageKey.lower(key), $0
        )
    })
}

public func securifiedIndexInGlobalKeySpace(securified: SecurifiedU30) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_securified_index_in_global_key_space(
            FfiConverterTypeSecurifiedU30.lower(securified), $0
        )
    })
}

public func securifiedIndexInLocalKeySpace(securified: SecurifiedU30) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_securified_index_in_local_key_space(
            FfiConverterTypeSecurifiedU30.lower(securified), $0
        )
    })
}

public func securityQuestionsAll() -> [SecurityNotProductionReadyQuestion] {
    return try! FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_Question.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_security_questions_all($0
        )
    })
}

public func securityQuestionsFactorSourceDecrypt(factorSource: SecurityQuestionsNotProductionReadyFactorSource, with: [SecurityNotProductionReadyQuestionAndAnswer]) throws -> Mnemonic {
    return try FfiConverterTypeMnemonic.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_security_questions_factor_source_decrypt(
            FfiConverterTypeSecurityQuestions_NOT_PRODUCTION_READY_FactorSource.lower(factorSource),
            FfiConverterSequenceTypeSecurity_NOT_PRODUCTION_READY_QuestionAndAnswer.lower(with), $0
        )
    })
}

public func signatureToBytes(signature: Signature) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_signature_to_bytes(
            FfiConverterTypeSignature.lower(signature), $0
        )
    })
}

public func signatureToString(signature: Signature) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_signature_to_string(
            FfiConverterTypeSignature.lower(signature), $0
        )
    })
}

public func signatureWithPublicKeyGetPublicKey(signatureWithPublicKey: SignatureWithPublicKey) -> PublicKey {
    return try! FfiConverterTypePublicKey.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_signature_with_public_key_get_public_key(
            FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey), $0
        )
    })
}

public func signatureWithPublicKeyGetSignature(signatureWithPublicKey: SignatureWithPublicKey) -> Signature {
    return try! FfiConverterTypeSignature.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_signature_with_public_key_get_signature(
            FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey), $0
        )
    })
}

public func signatureWithPublicKeyIsValid(signatureWithPublicKey: SignatureWithPublicKey, forHash: Hash) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_signature_with_public_key_is_valid(
            FfiConverterTypeSignatureWithPublicKey.lower(signatureWithPublicKey),
            FfiConverterTypeHash.lower(forHash), $0
        )
    })
}

public func signedIntentHash(signedIntent: SignedIntent) -> SignedTransactionIntentHash {
    return try! FfiConverterTypeSignedTransactionIntentHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_signed_intent_hash(
            FfiConverterTypeSignedIntent.lower(signedIntent), $0
        )
    })
}

public func signedTransactionIntentHashFormatted(address: SignedTransactionIntentHash, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_signed_transaction_intent_hash_formatted(
            FfiConverterTypeSignedTransactionIntentHash.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func slip10CurveToString(curve: Slip10Curve) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_slip10_curve_to_string(
            FfiConverterTypeSLIP10Curve.lower(curve), $0
        )
    })
}

public func subintentCompile(subintent: Subintent) -> CompiledSubintent {
    return try! FfiConverterTypeCompiledSubintent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_subintent_compile(
            FfiConverterTypeSubintent.lower(subintent), $0
        )
    })
}

public func subintentHash(subintent: Subintent) -> SubintentHash {
    return try! FfiConverterTypeSubintentHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_subintent_hash(
            FfiConverterTypeSubintent.lower(subintent), $0
        )
    })
}

public func subintentHashFormatted(address: SubintentHash, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_subintent_hash_formatted(
            FfiConverterTypeSubintentHash.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func subintentManifestBlobs(manifest: SubintentManifest) -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_subintent_manifest_blobs(
            FfiConverterTypeSubintentManifest.lower(manifest), $0
        )
    })
}

public func subintentManifestInvolvedPoolAddresses(manifest: SubintentManifest) -> [PoolAddress] {
    return try! FfiConverterSequenceTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_subintent_manifest_involved_pool_addresses(
            FfiConverterTypeSubintentManifest.lower(manifest), $0
        )
    })
}

public func subintentManifestInvolvedResourceAddresses(manifest: SubintentManifest) -> [ResourceAddress] {
    return try! FfiConverterSequenceTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_subintent_manifest_involved_resource_addresses(
            FfiConverterTypeSubintentManifest.lower(manifest), $0
        )
    })
}

public func subintentManifestNetworkId(manifest: SubintentManifest) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_subintent_manifest_network_id(
            FfiConverterTypeSubintentManifest.lower(manifest), $0
        )
    })
}

public func subintentManifestString(manifest: SubintentManifest) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_subintent_manifest_string(
            FfiConverterTypeSubintentManifest.lower(manifest), $0
        )
    })
}

public func subintentManifestSummary(manifest: SubintentManifest) -> ManifestSummary {
    return try! FfiConverterTypeManifestSummary.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_subintent_manifest_summary(
            FfiConverterTypeSubintentManifest.lower(manifest), $0
        )
    })
}

/**
 * The standard transaction fee
 */
public func transactionFeePreset() -> Decimal192 {
    return try! FfiConverterTypeDecimal192.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_fee_preset($0
        )
    })
}

public func transactionIntentCompile(intent: TransactionIntent) -> CompiledTransactionIntent {
    return try! FfiConverterTypeCompiledTransactionIntent.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_intent_compile(
            FfiConverterTypeTransactionIntent.lower(intent), $0
        )
    })
}

public func transactionIntentHash(intent: TransactionIntent) -> TransactionIntentHash {
    return try! FfiConverterTypeTransactionIntentHash.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_intent_hash(
            FfiConverterTypeTransactionIntent.lower(intent), $0
        )
    })
}

public func transactionIntentHashFormatted(address: TransactionIntentHash, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_intent_hash_formatted(
            FfiConverterTypeTransactionIntentHash.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func transactionManifestBlobs(manifest: TransactionManifest) -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_blobs(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestBlobsV2(manifest: TransactionManifestV2) -> Blobs {
    return try! FfiConverterTypeBlobs.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_blobs_v2(
            FfiConverterTypeTransactionManifestV2.lower(manifest), $0
        )
    })
}

public func transactionManifestInstructionsString(manifest: TransactionManifest) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_instructions_string(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestInvolvedPoolAddresses(manifest: TransactionManifest) -> [PoolAddress] {
    return try! FfiConverterSequenceTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_involved_pool_addresses(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestInvolvedPoolAddressesV2(manifest: TransactionManifestV2) -> [PoolAddress] {
    return try! FfiConverterSequenceTypePoolAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_involved_pool_addresses_v2(
            FfiConverterTypeTransactionManifestV2.lower(manifest), $0
        )
    })
}

public func transactionManifestInvolvedResourceAddresses(manifest: TransactionManifest) -> [ResourceAddress] {
    return try! FfiConverterSequenceTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_involved_resource_addresses(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestInvolvedResourceAddressesV2(manifest: TransactionManifestV2) -> [ResourceAddress] {
    return try! FfiConverterSequenceTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_involved_resource_addresses_v2(
            FfiConverterTypeTransactionManifestV2.lower(manifest), $0
        )
    })
}

public func transactionManifestNetworkId(manifest: TransactionManifest) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_network_id(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestNetworkIdV2(manifest: TransactionManifestV2) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_network_id_v2(
            FfiConverterTypeTransactionManifestV2.lower(manifest), $0
        )
    })
}

public func transactionManifestString(manifest: TransactionManifest) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_string(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestStringV2(manifest: TransactionManifestV2) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_string_v2(
            FfiConverterTypeTransactionManifestV2.lower(manifest), $0
        )
    })
}

public func transactionManifestSummary(manifest: TransactionManifest) -> ManifestSummary {
    return try! FfiConverterTypeManifestSummary.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_summary(
            FfiConverterTypeTransactionManifest.lower(manifest), $0
        )
    })
}

public func transactionManifestSummaryV2(manifest: TransactionManifestV2) throws -> ManifestSummary {
    return try FfiConverterTypeManifestSummary.lift(rustCallWithError(FfiConverterTypeCommonError.lift) {
        uniffi_sargon_uniffi_fn_func_transaction_manifest_summary_v2(
            FfiConverterTypeTransactionManifestV2.lower(manifest), $0
        )
    })
}

public func trimSecurityQuestionsAnswer(answer: String) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_trim_security_questions_answer(
            FfiConverterString.lower(answer), $0
        )
    })
}

public func u30GetValue(u30: U30) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_u30_get_value(
            FfiConverterTypeU30.lower(u30), $0
        )
    })
}

public func u31GetValue(u31: U31) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_u31_get_value(
            FfiConverterTypeU31.lower(u31), $0
        )
    })
}

public func unhardenedIndexInGlobalKeySpace(unhardened: Unhardened) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_unhardened_index_in_global_key_space(
            FfiConverterTypeUnhardened.lower(unhardened), $0
        )
    })
}

public func unhardenedIndexInLocalKeySpace(unhardened: Unhardened) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_unhardened_index_in_local_key_space(
            FfiConverterTypeUnhardened.lower(unhardened), $0
        )
    })
}

public func unsafeStorageKeyIdentifier(key: UnsafeStorageKey) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_unsafe_storage_key_identifier(
            FfiConverterTypeUnsafeStorageKey.lower(key), $0
        )
    })
}

public func unsecurifiedHardenedIndexInGlobalKeySpace(unsecurifiedHardened: UnsecurifiedHardened) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_unsecurified_hardened_index_in_global_key_space(
            FfiConverterTypeUnsecurifiedHardened.lower(unsecurifiedHardened), $0
        )
    })
}

public func unsecurifiedHardenedIndexInLocalKeySpace(unsecurifiedHardened: UnsecurifiedHardened) -> UInt32 {
    return try! FfiConverterUInt32.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_unsecurified_hardened_index_in_local_key_space(
            FfiConverterTypeUnsecurifiedHardened.lower(unsecurifiedHardened), $0
        )
    })
}

public func validatorAddressBech32Address(address: ValidatorAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_validator_address_bech32_address(
            FfiConverterTypeValidatorAddress.lower(address), $0
        )
    })
}

public func validatorAddressFormatted(address: ValidatorAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_validator_address_formatted(
            FfiConverterTypeValidatorAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func validatorAddressMapToNetwork(address: ValidatorAddress, networkId: NetworkId) -> ValidatorAddress {
    return try! FfiConverterTypeValidatorAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_validator_address_map_to_network(
            FfiConverterTypeValidatorAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func validatorAddressNetworkId(address: ValidatorAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_validator_address_network_id(
            FfiConverterTypeValidatorAddress.lower(address), $0
        )
    })
}

public func vaultAddressBech32Address(address: VaultAddress) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_vault_address_bech32_address(
            FfiConverterTypeVaultAddress.lower(address), $0
        )
    })
}

public func vaultAddressFormatted(address: VaultAddress, format: AddressFormat) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_vault_address_formatted(
            FfiConverterTypeVaultAddress.lower(address),
            FfiConverterTypeAddressFormat.lower(format), $0
        )
    })
}

public func vaultAddressIsFungible(address: VaultAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_vault_address_is_fungible(
            FfiConverterTypeVaultAddress.lower(address), $0
        )
    })
}

public func vaultAddressIsNonFungible(address: VaultAddress) -> Bool {
    return try! FfiConverterBool.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_vault_address_is_non_fungible(
            FfiConverterTypeVaultAddress.lower(address), $0
        )
    })
}

/**
 * Returns a new address, with the same node_id, but using `network_id` as
 * network.
 */
public func vaultAddressMapToNetwork(address: VaultAddress, networkId: NetworkId) -> VaultAddress {
    return try! FfiConverterTypeVaultAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_vault_address_map_to_network(
            FfiConverterTypeVaultAddress.lower(address),
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

public func vaultAddressNetworkId(address: VaultAddress) -> NetworkId {
    return try! FfiConverterTypeNetworkID.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_vault_address_network_id(
            FfiConverterTypeVaultAddress.lower(address), $0
        )
    })
}

public func vectorImageTypeDataUrlType(imageType: VectorImageType) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_vector_image_type_data_url_type(
            FfiConverterTypeVectorImageType.lower(imageType), $0
        )
    })
}

public func vectorImageTypeUrlExtension(imageType: VectorImageType) -> String {
    return try! FfiConverterString.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_vector_image_type_url_extension(
            FfiConverterTypeVectorImageType.lower(imageType), $0
        )
    })
}

public func walletInteractionWalletAccountToJsonBytes(walletInteractionWalletAccount: WalletInteractionWalletAccount) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_wallet_interaction_wallet_account_to_json_bytes(
            FfiConverterTypeWalletInteractionWalletAccount.lower(walletInteractionWalletAccount), $0
        )
    })
}

public func walletToDappInteractionResponseToJsonBytes(walletToDappInteractionResponse: WalletToDappInteractionResponse) -> BagOfBytes {
    return try! FfiConverterTypeBagOfBytes.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_wallet_to_dapp_interaction_response_to_json_bytes(
            FfiConverterTypeWalletToDappInteractionResponse.lower(walletToDappInteractionResponse), $0
        )
    })
}

public func xrdAddressOfNetwork(networkId: NetworkId) -> ResourceAddress {
    return try! FfiConverterTypeResourceAddress.lift(try! rustCall {
        uniffi_sargon_uniffi_fn_func_xrd_address_of_network(
            FfiConverterTypeNetworkID.lower(networkId), $0
        )
    })
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_sargon_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_access_controller_address_bech32_address() != 16739 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_access_controller_address_formatted() != 5192 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_access_controller_address_map_to_network() != 7986 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_access_controller_address_network_id() != 20657 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_account_address_bech32_address() != 41480 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_account_address_formatted() != 36270 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_account_address_is_legacy() != 9809 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_account_address_map_to_network() != 36939 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_account_address_network_id() != 25986 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_account_or_address_of_account_address() != 5968 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_account_or_persona_get_id() != 53085 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_address_formatted() != 51517 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_address_map_to_network() != 36071 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_address_network_id() != 58584 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_formatted() != 44847 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_map_to_network() != 5970 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_network_id() != 33299 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_sample_values_all() != 42804 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_address_of_account_or_persona_to_string() != 54683 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_address_sample_values_all() != 26979 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_address_to_string() != 39924 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_android_notarize_hash_with_private_key_bytes() != 11907 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_android_secret_key_get_public_key_from_private_key_bytes() != 5694 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_android_sign_hash_with_private_key_bytes() != 43322 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_app_preferences_has_gateway_with_url() != 26937 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_appearance_ids_all() != 47723 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_arculus_card_model_to_string() != 6670 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_authorized_dapp_to_json_bytes() != 4956 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_b_i_p39_seed_to_bytes() != 31312 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_bag_of_bytes_append_cafe() != 7653 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_bag_of_bytes_append_deadbeef() != 18671 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_bag_of_bytes_prepend_cafe() != 12603 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_bag_of_bytes_prepend_deadbeef() != 11612 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_bip32_constant_global_offset_hardened() != 56838 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_bip32_constant_global_offset_securified() != 26205 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_bip39_language_wordlist() != 53356 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_bip39_word_count_all() != 21883 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_bip44_like_path_get_address_index() != 14802 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_bip44_like_path_to_string() != 64740 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_blob_to_bytes() != 2709 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_blob_to_string() != 56091 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_blobs_list_of_blobs() != 58647 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_build_information() != 25206 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_check_if_encrypted_profile_json_contains_legacy_p2p_links() != 56950 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_check_if_profile_json_contains_legacy_p2p_links() != 13443 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_compiled_notarized_intent_get_bytes() != 35568 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_compiled_subintent_bytes() != 55048 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_compiled_subintent_decompile() != 22909 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_compiled_transaction_intent_bytes() != 5074 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_compiled_transaction_intent_decompile() != 5413 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_component_address_bech32_address() != 19756 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_component_address_formatted() != 14442 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_component_address_is_global() != 49734 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_component_address_is_internal() != 48259 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_component_address_map_to_network() != 27675 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_component_address_network_id() != 51835 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_constant_entity_name_max_length() != 19522 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_constant_min_required_xrd_for_account_deletion() != 45958 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_dapp_to_wallet_interaction_unvalidated_to_json_bytes() != 61820 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_dapp_to_wallet_interaction_unvalidated_to_json_string() != 63502 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_debug_print_compiled_notarized_intent() != 16677 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_abs() != 29764 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_add() != 32856 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_clamped_to_zero() != 27082 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_div() != 51913 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_formatted() != 34425 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_formatted_plain() != 59743 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_greater_than() != 8443 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_greater_than_or_equal() != 20591 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_is_negative() != 12023 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_is_positive() != 31461 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_is_zero() != 7222 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_less_than() != 3979 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_less_than_or_equal() != 14807 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_max() != 18055 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_min() != 41483 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_mul() != 7996 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_neg() != 25523 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_round() != 34421 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_sub() != 16671 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_decimal_to_string() != 36217 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_dependency_information_to_string() != 39562 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_deposit_rule_to_json_string() != 9778 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_derivation_path_to_hd_path() != 40437 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_derivation_path_to_string() != 62433 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_device_factor_source_is_main_bdfs() != 29295 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_device_info_description_to_string() != 41352 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_device_info_to_json_bytes() != 65074 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_display_name_to_json_string() != 21695 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_ed25519_public_key_to_bytes() != 32366 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_ed25519_public_key_to_hex() != 56150 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_ed25519_public_key_to_json_string() != 45791 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_ed25519_signature_to_json_string() != 34112 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_ed25519_signature_to_string() != 3491 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_entropy16_bytes_to_bytes() != 10147 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_entropy20_bytes_to_bytes() != 6787 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_entropy24_bytes_to_bytes() != 2461 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_entropy28_bytes_to_bytes() != 261 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_entropy32_bytes_to_bytes() != 52294 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_error_code_from_error() != 29726 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_error_message_from_error() != 21055 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_event_kind() != 60428 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_event_kind_affects_current_accounts() != 42399 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_event_kind_affects_current_network() != 33132 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_event_kind_affects_factor_sources() != 48330 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_event_kind_affects_saved_gateways() != 55144 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_event_kind_affects_security_structures() != 29273 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_event_kind_all() != 41590 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly12_bytes_to_json_string() != 53379 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly29_bytes_to_json_string() != 40034 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly32_bytes_to_json_string() != 25695 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly33_bytes_to_json_string() != 49844 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly60_bytes_to_json_string() != 61148 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly64_bytes_to_json_string() != 15251 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly65_bytes_to_json_string() != 35639 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_12_bytes_to_bytes() != 1500 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_12_bytes_to_hex() != 46640 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_29_bytes_to_bytes() != 43740 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_29_bytes_to_hex() != 11033 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_32_bytes_to_bytes() != 30445 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_32_bytes_to_hex() != 21548 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_33_bytes_to_bytes() != 32587 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_33_bytes_to_hex() != 35227 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_60_bytes_to_bytes() != 21333 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_60_bytes_to_hex() != 34978 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_64_bytes_to_bytes() != 41324 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_64_bytes_to_hex() != 4596 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_65_bytes_to_bytes() != 38987 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_exactly_65_bytes_to_hex() != 59590 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_factor_source_crypto_parameters_supports_babylon() != 19739 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_factor_source_crypto_parameters_supports_olympia() != 46978 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_factor_source_i_d_from_address_to_json_bytes() != 28180 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_factor_source_i_d_from_hash_to_json_bytes() != 50855 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_factor_source_id_from_address_to_string() != 15403 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_factor_source_id_from_hash_to_string() != 2950 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_factor_source_id_to_string() != 26529 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_factor_source_kind_to_string() != 30143 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_factor_source_supports_babylon() != 5064 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_factor_source_supports_olympia() != 44230 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_factor_source_to_string() != 23127 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_factor_sources_all_sample_values() != 29519 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_ffi_url_get_url() != 13501 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_fiat_currency_to_json_string() != 29262 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_fungible_resource_indicator_get_amount() != 57502 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_gateway_id() != 62787 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_gateway_is_wellknown() != 12190 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_gateway_mainnet() != 50357 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_gateway_stokenet() != 60555 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_gateway_to_string() != 45466 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_gateway_wellknown_gateways() != 24662 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_get_subintent_expiration_status() != 706 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_hash() != 40399 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_hash_get_bytes() != 17430 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_hd_path_component_get_key_space() != 16341 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_hd_path_component_index_in_global_key_space() != 2568 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_hd_path_component_index_in_local_key_space() != 1876 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_hd_path_component_to_bip32_string() != 11237 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_hd_path_component_to_bip32_string_debug() != 39488 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_hd_path_component_to_hardened() != 60319 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_header_to_json_bytes() != 30120 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_hierarchical_deterministic_public_key_is_valid_signature_for_hash() != 44394 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_host_id_to_json_bytes() != 46400 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_host_os_get_name() != 65043 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_host_os_get_vendor() != 52670 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_host_os_get_version() != 50713 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_identity_address_bech32_address() != 6747 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_identity_address_formatted() != 57900 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_identity_address_map_to_network() != 21479 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_identity_address_network_id() != 22178 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_image_url_utils_is_vector_image() != 7296 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_image_url_utils_make_image_url() != 11016 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_intent_discriminator_get_value() != 49816 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_intent_signature_get_signature_with_public_key() != 55591 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_is_safe_to_show_error_message_from_error() != 48490 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_key_agreement_public_key_to_bytes() != 27363 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_key_agreement_public_key_to_hex() != 57749 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_ledger_hw_wallet_model_to_string() != 6623 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_legacy_olympia_account_address_formatted() != 37355 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_legacy_olympia_account_address_is_legacy_of_babylon() != 12089 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_legacy_olympia_account_address_to_babylon_account_address() != 64098 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_legacy_olympia_account_address_to_string() != 586 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_link_connection_q_r_data_to_json_bytes() != 19222 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_locker_address_bech32_address() != 37513 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_locker_address_formatted() != 24320 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_locker_address_map_to_network() != 24957 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_locker_address_network_id() != 17185 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_account_locker_claim() != 51896 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_create_fungible_token() != 53492 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_create_fungible_token_with_metadata() != 24893 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_create_multiple_fungible_tokens() != 21380 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_create_multiple_non_fungible_tokens() != 43838 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_create_non_fungible_token() != 3479 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_formatted() != 23567 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_map_to_network() != 58015 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_network_id() != 10681 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_sample_values_all() != 52471 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_encountered_component_address_to_string() != 44296 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_for_faucet() != 39443 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_marking_account_as_dapp_definition_type() != 54702 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_per_asset_transfers() != 20320 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_per_recipient_transfers() != 29446 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_set_owner_keys_hashes() != 19176 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_stakes_claim() != 28927 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_manifest_third_party_deposit_update() != 44888 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_message_as_plaintext() != 37029 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_message_v2_as_plaintext() != 5171 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_mnemonic_phrase() != 26344 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_mnemonic_with_passphrase_derive_public_keys() != 51123 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_mnemonic_with_passphrase_sign() != 60558 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_mnemonic_with_passphrase_to_json_bytes() != 43384 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_mnemonic_with_passphrase_validate_public_keys() != 42595 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_modify_manifest_add_guarantees() != 54480 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_modify_manifest_lock_fee() != 37364 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_network_id_discriminant() != 60399 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_network_id_to_string() != 9901 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_network_ids_all() != 12196 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_network_method_to_string() != 56251 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_access_controller_address() != 43372 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_access_controller_address_random() != 53067 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_access_controller_address_sample_mainnet() != 55321 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_access_controller_address_sample_mainnet_other() != 53259 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_access_controller_address_sample_stokenet() != 62042 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_access_controller_address_sample_stokenet_other() != 48145 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_address() != 65018 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_address_from() != 13571 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_address_random() != 62190 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_address_sample_mainnet() != 22922 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_address_sample_mainnet_other() != 53879 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_address_sample_stokenet() != 13145 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_address_sample_stokenet_other() != 3741 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_for_display_from_account() != 54146 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_for_display_sample() != 46449 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_for_display_sample_other() != 25799 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_locker_claimable_resource_sample() != 44473 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_locker_claimable_resource_sample_other() != 49877 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_or_address_of_sample() != 40406 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_or_address_of_sample_other() != 58713 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_mainnet() != 20540 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_mainnet_other() != 19137 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_mainnet_third() != 55355 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_stokenet() != 30858 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_stokenet_other() != 22043 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_or_persona_sample_stokenet_third() != 61696 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_path() != 60462 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_path_sample() != 54597 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_path_sample_other() != 39697 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_sample_mainnet_alice() != 25345 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_sample_mainnet_bob() != 29866 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_sample_mainnet_carol() != 42248 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_sample_mainnet_diana() != 36079 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_sample_stokenet_nadia() != 30043 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_sample_stokenet_olivia() != 27591 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_account_sample_stokenet_paige() != 5383 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_accounts_for_display_sample() != 58677 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_accounts_for_display_sample_other() != 27502 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_accounts_or_personas_sample() != 12183 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_accounts_or_personas_sample_other() != 58257 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_accounts_sample() != 56236 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_accounts_sample_other() != 6814 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_address_from_bech32() != 21331 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_from_bech32() != 21850 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_sample_mainnet() != 33734 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_sample_mainnet_other() != 6476 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_sample_stokenet() != 64912 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_address_of_account_or_persona_sample_stokenet_other() != 51988 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_address_sample_mainnet() != 7887 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_address_sample_mainnet_other() != 61417 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_address_sample_stokenet() != 19240 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_address_sample_stokenet_other() != 6756 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_app_preferences_default() != 14693 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_app_preferences_sample() != 54060 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_app_preferences_sample_other() != 4957 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_appearance_id() != 45858 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_appearance_id_from_number_of_accounts_on_network() != 17795 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_appearance_id_sample() != 30621 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_appearance_id_sample_other() != 52854 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_arculus_card_factor_source_from_mnemonic_with_passphrase() != 63140 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_arculus_card_factor_source_sample() != 59637 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_arculus_card_factor_source_sample_other() != 30228 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_asset_exception_sample() != 55301 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_asset_exception_sample_other() != 55082 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_assets_exception_list_sample() != 47074 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_assets_exception_list_sample_other() != 39085 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_detailed_sample() != 38954 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_detailed_sample_other() != 11486 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_from_json_bytes() != 10178 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_sample_mainnet_dashboard() != 54023 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_sample_mainnet_gumballclub() != 62709 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_sample_stokenet_devconsole() != 45066 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_dapp_sample_stokenet_sandbox() != 14923 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_dapps_sample() != 40678 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_dapps_sample_other() != 44743 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_persona_detailed_sample() != 22358 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_persona_detailed_sample_other() != 16247 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_persona_simple_sample_mainnet() != 5111 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_persona_simple_sample_mainnet_other() != 4841 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_persona_simple_sample_stokenet() != 17795 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_authorized_persona_simple_sample_stokenet_other() != 33729 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_b_i_p39_seed_from_bytes() != 22381 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_b_i_p39_seed_sample() != 61518 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_b_i_p39_seed_sample_other() != 21682 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_from() != 2776 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_aced() != 16822 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_babe() != 63067 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_cafe() != 19146 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_dead() != 30477 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_ecad() != 8414 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bag_of_bytes_sample_fade() != 25865 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bip39_language_sample() != 35094 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bip39_language_sample_other() != 12099 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bip39_word_sample() != 36954 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bip39_word_sample_other() != 21194 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bip44_like_path_from_index() != 41704 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bip44_like_path_from_string() != 38941 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bip44_like_path_sample() != 62302 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_bip44_like_path_sample_other() != 53938 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_blob_from_bytes() != 4046 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_blobs_from_blob_list() != 47310 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_blobs_sample() != 51393 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_blobs_sample_other() != 1358 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_compiled_notarized_intent_sample() != 351 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_compiled_notarized_intent_sample_other() != 30738 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_compiled_subintent_sample() != 50175 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_compiled_subintent_sample_other() != 29258 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_compiled_transaction_intent_sample() != 25544 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_compiled_transaction_intent_sample_other() != 35639 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_component_address() != 6748 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_component_address_random() != 166 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_component_address_sample_mainnet_global() != 62491 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_component_address_sample_mainnet_internal() != 12637 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_component_address_sample_stokenet_global() != 18747 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_component_address_sample_stokenet_internal() != 50419 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_unvalidated_from_json_bytes() != 30691 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_unvalidated_from_json_string() != 6002 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_unvalidated_sample() != 7739 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_dapp_to_wallet_interaction_unvalidated_sample_other() != 25552 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_decimal_exponent() != 12846 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_decimal_from_f32() != 53578 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_decimal_from_f64() != 53652 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_decimal_from_formatted_string() != 42489 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_decimal_from_i32() != 16943 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_decimal_from_i64() != 31040 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_decimal_from_string() != 33537 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_decimal_from_u32() != 19405 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_decimal_from_u64() != 36062 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_dependency_information_sample() != 49066 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_dependency_information_sample_other() != 43626 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_deposit_rule_from_json_string() != 25423 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_deposit_rule_sample() != 8201 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_deposit_rule_sample_other() != 54410 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_depositors_allow_list_sample() != 8727 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_depositors_allow_list_sample_other() != 7481 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_derivation_path_from_string() != 11067 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_derivation_path_sample() != 60817 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_derivation_path_sample_other() != 4393 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_detailed_authorized_personas_sample() != 46157 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_detailed_authorized_personas_sample_other() != 58210 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_device_factor_source_babylon() != 27263 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_device_factor_source_olympia() != 17238 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_device_factor_source_sample() != 7799 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_device_factor_source_sample_other() != 21308 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_device_info_description_sample() != 45889 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_device_info_description_sample_other() != 48984 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_device_info_from_host_info() != 29629 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_device_info_from_json_bytes() != 20094 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_device_info_sample() != 39892 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_device_info_sample_other() != 57142 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_display_name() != 39164 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_display_name_from_json_string() != 65092 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_display_name_sample() != 29614 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_display_name_sample_other() != 43371 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_from_bytes() != 14056 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_from_hex() != 48187 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_from_json_string() != 53635 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_sample() != 8979 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ed25519_public_key_sample_other() != 31532 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_from_bytes() != 14357 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_from_exactly_64_bytes() != 61100 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_from_json_string() != 47403 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_sample() != 35097 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ed25519_signature_sample_other() != 29669 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_email_address_sample() != 52899 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_email_address_sample_other() != 53375 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entity_flag_sample() != 53250 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entity_flag_sample_other() != 46309 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entity_flags_sample() != 40234 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entity_flags_sample_other() != 6490 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entity_security_state_sample() != 1724 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entity_security_state_sample_other() != 54559 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy16_bytes_from_bytes() != 3405 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy16_bytes_sample() != 63418 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy16_bytes_sample_other() != 10505 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy20_bytes_from_bytes() != 56880 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy20_bytes_sample() != 15341 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy20_bytes_sample_other() != 44987 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy24_bytes_from_bytes() != 13630 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy24_bytes_sample() != 56974 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy24_bytes_sample_other() != 27016 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy28_bytes_from_bytes() != 47298 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy28_bytes_sample() != 22081 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy28_bytes_sample_other() != 56854 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy32_bytes_from_bytes() != 23680 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy32_bytes_sample() != 42841 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_entropy32_bytes_sample_other() != 48183 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly12_bytes_from_json_string() != 39752 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly29_bytes_from_json_string() != 52829 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly32_bytes_from_json_string() != 24841 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly33_bytes_from_json_string() != 46155 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly60_bytes_from_json_string() != 41288 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly64_bytes_from_json_string() != 62020 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly65_bytes_from_json_string() != 64582 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_12_bytes() != 53376 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_12_bytes_sample() != 12822 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_12_bytes_sample_other() != 28820 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_29_bytes() != 51192 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_29_bytes_sample() != 53557 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_29_bytes_sample_other() != 47703 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_32_bytes() != 64310 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_32_bytes_sample() != 45472 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_32_bytes_sample_other() != 18845 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_33_bytes() != 52850 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_33_bytes_sample() != 2208 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_33_bytes_sample_other() != 63205 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_60_bytes() != 6398 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_60_bytes_sample() != 9877 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_60_bytes_sample_other() != 65036 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_64_bytes() != 45996 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_64_bytes_sample() != 33155 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_64_bytes_sample_other() != 39984 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_65_bytes() != 61939 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_65_bytes_sample() != 36105 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_exactly_65_bytes_sample_other() != 14805 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_common_babylon() != 60986 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_common_bdfs() != 23312 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_common_olympia() != 55674 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_common_sample() != 18551 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_common_sample_other() != 15753 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_preset_babylon_olympia_compatible() != 46508 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_preset_babylon_only() != 34472 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_preset_olympia_only() != 15990 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_sample() != 7491 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_crypto_parameters_sample_other() != 4781 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_i_d_from_address_from_json_bytes() != 28530 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_i_d_from_hash_from_json_bytes() != 30633 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_address_sample() != 21401 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_address_sample_other() != 31544 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_hash_from_mnemonic_with_passphrase() != 21191 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_hash_sample() != 11669 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_from_hash_sample_other() != 60302 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_sample() != 22280 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_id_sample_other() != 40497 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_kind_from_string() != 5930 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_kind_sample() != 29958 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_kind_sample_other() != 57561 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_sample() != 48469 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_source_sample_other() != 42128 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_sources_sample() != 54455 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_factor_sources_sample_other() != 15671 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_fiat_currency_from_json_string() != 31917 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_fiat_currency_sample() != 44623 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_fiat_currency_sample_other() != 47859 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_fungible_resource_indicator_sample() != 32253 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_fungible_resource_indicator_sample_other() != 1830 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_gateway_for_network_id() != 2039 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_gateway_sample() != 65248 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_gateway_sample_other() != 19812 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_gateway_with_url_on_network() != 34352 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_gateways_sample() != 26136 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_gateways_sample_other() != 14701 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hardened_sample() != 23609 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hardened_sample_other() != 12456 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hash_from_bytes() != 53909 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hash_from_string() != 29142 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hash_sample() != 14961 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hash_sample_other() != 44845 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hd_path_component_from_global_key_space() != 15222 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hd_path_component_from_local_key_space() != 37980 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hd_path_component_sample() != 35319 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hd_path_component_sample_other() != 21010 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_header_from_json_bytes() != 60561 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_header_sample() != 26875 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_header_sample_other() != 21914 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_header_with_creating_device() != 23900 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hidden_resources_sample() != 13060 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hidden_resources_sample_other() != 27518 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hierarchical_deterministic_factor_instance_sample() != 19729 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hierarchical_deterministic_factor_instance_sample_other() != 59419 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hierarchical_deterministic_public_key_sample() != 17515 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_hierarchical_deterministic_public_key_sample_other() != 45174 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_host_id_from_json_bytes() != 50705 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_host_id_sample() != 14792 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_host_id_sample_other() != 15608 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_host_info_sample() != 55060 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_host_info_sample_other() != 32825 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_host_os_android() != 64596 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_host_os_ios() != 47748 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_host_os_other() != 18747 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_host_os_sample() != 43842 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_host_os_sample_other() != 49140 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_identity_address() != 37512 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_identity_address_from() != 6311 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_identity_address_random() != 3026 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_identity_address_sample_mainnet() != 10751 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_identity_address_sample_mainnet_other() != 52448 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_identity_address_sample_stokenet() != 20666 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_identity_address_sample_stokenet_other() != 29131 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_identity_path() != 34862 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_identity_path_sample() != 10679 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_identity_path_sample_other() != 9827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_intent_discriminator_from_u64() != 53541 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_intent_discriminator_random() != 38983 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_intent_discriminator_sample() != 36765 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_intent_discriminator_sample_other() != 27108 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_intent_header_v2_sample() != 62553 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_intent_header_v2_sample_other() != 52012 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_intent_signature_from_signature_with_public_key() != 17724 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_intent_signature_sample() != 32994 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_intent_signature_sample_other() != 32199 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_key_agreement_public_key_from_bytes() != 57828 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_key_agreement_public_key_from_hex() != 26295 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_key_agreement_public_key_sample() != 28131 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_key_agreement_public_key_sample_other() != 3360 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_key_space_sample() != 47298 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_key_space_sample_other() != 16330 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ledger_hardware_wallet_factor_source_sample() != 48515 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ledger_hardware_wallet_factor_source_sample_other() != 51985 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ledger_hardware_wallet_from_mnemonic_with_passphrase() != 44413 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ledger_hw_wallet_model_from_string() != 37370 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ledger_hw_wallet_model_sample() != 17004 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_ledger_hw_wallet_model_sample_other() != 18014 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_legacy_olympia_account_address_from_public_key() != 49238 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_legacy_olympia_account_address_from_string() != 51151 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_legacy_olympia_account_address_sample() != 51720 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_legacy_olympia_account_address_sample_other() != 2909 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_link_connection_q_r_data_from_json_bytes() != 63075 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_link_connection_qr_data_sample() != 390 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_link_connection_qr_data_sample_other() != 48462 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_locker_address() != 41694 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_locker_address_random() != 47028 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_locker_address_sample_mainnet() != 41128 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_locker_address_sample_mainnet_other() != 15582 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_locker_address_sample_stokenet() != 22220 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_locker_address_sample_stokenet_other() != 49931 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_from_bech32() != 20959 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_sample_mainnet() != 18081 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_sample_mainnet_other() != 42631 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_sample_stokenet() != 16081 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_manifest_encountered_component_address_sample_stokenet_other() != 59943 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_matrix_of_factor_sources_sample() != 44278 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_matrix_of_factor_sources_sample_other() != 20016 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_message_plaintext_sample() != 5016 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_message_plaintext_sample_other() != 22181 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_message_plaintext_string() != 61136 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_message_v2_plaintext_sample() != 23768 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_message_v2_plaintext_sample_other() != 16 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_message_v2_plaintext_string() != 27580 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_from_phrase() != 56600 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_from_phrase_language() != 4694 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_from_words() != 65034 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_generate_with_entropy() != 60360 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample() != 488 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_arculus() != 22101 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_arculus_other() != 16183 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_device() != 9748 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_device_12_words() != 400 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_device_12_words_other() != 11940 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_device_other() != 18760 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_ledger() != 29417 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_ledger_other() != 44988 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_off_device() != 58644 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_off_device_other() != 36452 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_other() != 10990 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_passphrase() != 57688 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_passphrase_other() != 55603 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_security_questions() != 29566 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_sample_security_questions_other() != 40755 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_with_passphrase_from_json_bytes() != 33065 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_with_passphrase_sample() != 13986 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_mnemonic_with_passphrase_sample_other() != 44196 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_network_definition_lookup_by_name() != 20559 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_network_definition_sample() != 6748 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_network_definition_sample_other() != 20321 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_network_id_from_discriminant() != 40833 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_network_method_sample() != 61115 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_network_method_sample_other() != 7620 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_network_request_sample() != 44220 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_network_request_sample_other() != 35449 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_empty_max_32_bytes() != 10326 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_empty_max_64_bytes() != 6712 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_global_id_from_string() != 8625 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_global_id_sample() != 14915 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_global_id_sample_other() != 31589 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_bytes() != 7239 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_from_string() != 17202 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_int() != 24222 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_random() != 7654 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_ruid() != 28939 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_sample() != 56159 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_sample_other() != 35518 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_string() != 14957 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_local_id_string_from_str() != 8847 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address() != 8188 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_random() != 56930 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_sample_mainnet() != 1509 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_sample_mainnet_other() != 61508 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_sample_stokenet() != 32156 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_address_sample_stokenet_other() != 50028 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_indicator_sample() != 20517 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_non_fungible_resource_indicator_sample_other() != 15310 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_nonce_from_u32() != 6600 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_nonce_random() != 3824 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_nonce_sample() != 50716 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_nonce_sample_other() != 11696 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_notarized_transaction_sample() != 3580 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_notarized_transaction_sample_other() != 8227 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_notary_signature() != 8639 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_notary_signature_sample() != 25191 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_notary_signature_sample_other() != 9617 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_off_device_mnemonic_factor_source_from_mnemonic_with_passphrase() != 53315 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_off_device_mnemonic_factor_source_sample() != 7141 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_off_device_mnemonic_factor_source_sample_other() != 60614 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_on_ledger_settings_default() != 27043 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_on_ledger_settings_sample() != 61885 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_on_ledger_settings_sample_other() != 12898 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_p2_p_link_from_json_bytes() != 16669 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_p2_p_links_sample() != 37944 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_p2_p_links_sample_other() != 23031 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_p2p_link_sample() != 51168 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_p2p_link_sample_other() != 60728 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_p2p_links_from_json_bytes() != 5830 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_package_address() != 28930 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_package_address_random() != 41825 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_package_address_sample_mainnet() != 37012 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_package_address_sample_mainnet_other() != 13811 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_package_address_sample_stokenet() != 49912 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_package_address_sample_stokenet_other() != 2264 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_passphrase_factor_source_from_mnemonic_with_passphrase() != 20208 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_passphrase_factor_source_sample() != 63822 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_passphrase_factor_source_sample_other() != 44302 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_per_asset_transfers_sample() != 57477 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_per_asset_transfers_sample_other() != 54472 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_email_address_from_json_string() != 17266 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_email_address_sample() != 16240 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_email_address_sample_other() != 31225 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_name_from_json_bytes() != 48047 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_name_sample() != 31330 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_name_sample_other() != 45091 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_phone_number_from_json_string() != 63307 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_phone_number_sample() != 23998 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_data_entry_phone_number_sample_other() != 64155 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_data_sample() != 15395 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_data_sample_other() != 17421 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_sample() != 11862 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_sample_mainnet_batman() != 60447 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_sample_mainnet_ripley() != 15174 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_sample_mainnet_satoshi() != 57136 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_sample_mainnet_turing() != 64235 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_sample_other() != 52731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_sample_stokenet_connor() != 12681 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_sample_stokenet_hermione() != 43143 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_persona_sample_stokenet_leia_skywalker() != 32626 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_personas_sample() != 41264 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_personas_sample_other() != 59167 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_pool_address() != 37194 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_pool_address_random() != 2609 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_mainnet_multi() != 60014 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_mainnet_single() != 56079 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_mainnet_two() != 49886 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_stokenet_multi() != 13647 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_stokenet_single() != 22732 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_pool_address_sample_stokenet_two() != 26088 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_babylon() != 2417 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_babylon_from_mnemonic_with_passphrase() != 30453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_olympia_from_mnemonic_with_passphrase() != 18078 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_sample() != 32540 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_private_hd_factor_source_sample_other() != 12390 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile() != 58363 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_file_contents_sample() != 61888 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_file_contents_sample_other() != 16774 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_from_encryption_bytes() != 50411 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_from_json_string() != 61261 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_id_sample() != 20711 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_id_sample_other() != 44986 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_network_sample() != 47064 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_network_sample_other() != 25587 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_networks_sample() != 59335 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_networks_sample_other() != 2779 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_sample() != 23215 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_sample_other() != 52859 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_profile_with_mnemonic() != 25823 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_public_key_from_bytes() != 13924 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_public_key_from_hex() != 37374 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_public_key_hash_of_key() != 59602 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_public_key_hash_sample() != 42850 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_public_key_hash_sample_other() != 38629 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_public_key_sample() != 31874 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_public_key_sample_other() != 61084 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_radix_connect_mobile_session_request_from_json_bytes() != 572 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_radix_connect_mobile_session_request_sample() != 10993 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_radix_connect_mobile_session_request_sample_other() != 14869 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_radix_connect_password() != 20733 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_radix_connect_password_from_json_string() != 12504 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_radix_connect_password_sample() != 48289 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_radix_connect_password_sample_other() != 55376 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_radix_connect_purpose_from_json_string() != 6704 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_radix_connect_purpose_from_string() != 53702 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_radix_connect_purpose_sample() != 40644 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_radix_connect_purpose_sample_other() != 6326 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_references_to_authorized_personas_sample() != 64338 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_references_to_authorized_personas_sample_other() != 58733 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_requested_quantity_from_json_bytes() != 63420 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_requested_quantity_sample() != 4279 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_requested_quantity_sample_other() != 8374 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_address() != 38401 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_address_random() != 16846 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_mainnet_candy() != 21546 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_mainnet_nft_gc_membership() != 41107 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_mainnet_xrd() != 19705 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_stokenet_candy() != 20717 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_stokenet_gc_tokens() != 62696 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_stokenet_gum() != 7006 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_address_sample_stokenet_xrd() != 6601 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_indicator_sample() != 45770 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_indicator_sample_other() != 28357 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_or_non_fungible_sample() != 62731 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_or_non_fungible_sample_other() != 60028 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_preferences_sample() != 782 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_preferences_sample_other() != 39619 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_specifier_sample() != 58427 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_resource_specifier_sample_other() != 8185 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_s_l_i_p10_curve_from_json_string() != 20445 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_sargon_build_information_sample() != 41647 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_sargon_build_information_sample_other() != 25347 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_saved_gateways() != 44618 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_saved_gateways_changing_current() != 3541 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_saved_gateways_default() != 14470 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_saved_gateways_sample() != 46435 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_saved_gateways_sample_other() != 36343 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_secp256k1_public_key_from_bytes() != 56517 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_secp256k1_public_key_from_hex() != 19768 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_secp256k1_public_key_sample() != 32902 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_secp256k1_public_key_sample_other() != 15984 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_secp256k1_signature_from_bytes() != 14670 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_secp256k1_signature_from_exactly_65_bytes() != 49202 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_secp256k1_signature_sample() != 25467 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_secp256k1_signature_sample_other() != 17125 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_securified() != 35174 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_securified_from_global_key_space() != 4183 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_securified_from_local_key_space() != 19115 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_securified_sample() != 29424 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_securified_sample_other() != 29224 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_and_answers_sample() != 39363 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_n_o_t_p_r_o_d_u_c_t_i_o_n_r_e_a_d_y_questions_and_answers_sample_other() != 57147 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_questions_factor_source_by_encrypting_mnemonic() != 63012 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_questions_factor_source_sample() != 15654 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_questions_factor_source_sample_other() != 20505 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_structure_metadata_named() != 59028 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_structure_metadata_sample() != 45001 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_structure_metadata_sample_other() != 16304 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_source_ids_sample() != 15528 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_source_ids_sample_other() != 9760 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_sources_auto_in_days() != 61082 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_sources_sample() != 11104 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_structure_of_factor_sources_sample_other() != 49794 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_structures_of_factor_source_i_ds_sample() != 8648 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_security_structures_of_factor_source_i_ds_sample_other() != 52262 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_shared_persona_data_sample() != 52679 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_shared_persona_data_sample_other() != 27739 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_signature_from_bytes() != 61714 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_signature_sample() != 41998 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_signature_sample_other() != 19832 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_signature_with_public_key_sample() != 50602 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_signature_with_public_key_sample_other() != 24400 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_signed_intent_hash_sample() != 33808 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_signed_intent_hash_sample_other() != 11367 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_signed_intent_sample() != 52370 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_signed_intent_sample_other() != 19689 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_signed_transaction_intent_hash_from_string() != 52650 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_slip10_curve_from_string() != 17182 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_stake_claim_sample() != 50908 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_stake_claim_sample_other() != 20345 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_subintent() != 21688 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_subintent_hash_from_string() != 27930 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_subintent_hash_sample() != 20745 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_subintent_hash_sample_other() != 42752 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_subintent_manifest_sample() != 40795 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_subintent_manifest_sample_other() != 21745 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_subintent_sample() != 41412 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_subintent_sample_other() != 56550 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_supported_curves_sample() != 27270 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_supported_curves_sample_other() != 38978 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_third_party_deposits_default() != 64655 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_third_party_deposits_sample() != 43880 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_third_party_deposits_sample_other() != 8564 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_header_sample() != 8723 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_header_sample_other() != 30841 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_intent_hash_from_string() != 22744 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_intent_hash_sample() != 57397 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_intent_hash_sample_other() != 46815 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_intent_sample() != 10516 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_intent_sample_other() != 3301 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_from_instructions_string_and_blobs() != 47709 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_from_unvalidated_transaction_manifest() != 17099 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_sample() != 45718 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_sample_other() != 25709 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_v2_sample() != 55947 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_transaction_manifest_v2_sample_other() != 20151 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_trusted_contact_factor_source_contact_sample() != 60450 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_trusted_contact_factor_source_contact_sample_other() != 42014 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_trusted_contact_factor_source_from_address_and_contact() != 53920 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_trusted_contact_factor_source_sample() != 42422 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_trusted_contact_factor_source_sample_other() != 55827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_u30() != 20628 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_u30_sample() != 63676 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_u30_sample_other() != 28749 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_u31() != 39523 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_u31_sample() != 46555 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_u31_sample_other() != 18620 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unhardened() != 42441 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unhardened_from_global_key_space() != 17468 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unhardened_from_local_key_space() != 50711 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unhardened_sample() != 4452 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unhardened_sample_other() != 27835 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unsecured_entity_control_sample() != 42906 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unsecured_entity_control_sample_other() != 44199 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened() != 9613 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened_from_global_key_space() != 34523 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened_from_local_key_space() != 30021 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened_sample() != 22376 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unsecurified_hardened_sample_other() != 47742 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unsecurified_sample() != 15554 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unsecurified_sample_other() != 42044 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unvalidated_subintent_manifest_from_subintent_manifest() != 11045 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unvalidated_subintent_manifest_sample() != 19014 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unvalidated_subintent_manifest_sample_other() != 53324 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unvalidated_transaction_manifest_from_transaction_manifest() != 60621 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unvalidated_transaction_manifest_sample() != 3220 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_unvalidated_transaction_manifest_sample_other() != 19780 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_validator_address() != 7330 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_validator_address_random() != 17013 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_validator_address_sample_mainnet() != 1396 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_validator_address_sample_mainnet_other() != 60189 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_validator_address_sample_stokenet() != 6182 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_validator_address_sample_stokenet_other() != 59150 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_vault_address() != 46722 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_vault_address_random() != 5168 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_vault_address_sample_mainnet_fungible() != 59977 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_vault_address_sample_mainnet_non_fungible() != 3625 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_vault_address_sample_stokenet_fungible() != 35213 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_vault_address_sample_stokenet_non_fungible() != 40105 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_vector_image_type_sample() != 35643 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_vector_image_type_sample_other() != 15343 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_wallet_interaction_version_current() != 1306 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_wallet_interaction_wallet_account_from_json_bytes() != 8284 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_wallet_interaction_wallet_account_sample() != 28027 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_wallet_interaction_wallet_account_sample_other() != 51107 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_pre_authorization_response_items() != 1128 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_response_from_json_bytes() != 18042 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_response_sample() != 43665 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_new_wallet_to_dapp_interaction_response_sample_other() != 7044 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_non_fungible_global_id_formatted() != 44995 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_non_fungible_global_id_to_string() != 65080 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_non_fungible_local_id_as_str() != 50881 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_non_fungible_local_id_formatted() != 4044 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_non_fungible_local_id_to_user_facing_string() != 11431 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_non_fungible_resource_address_as_resource_address() != 12948 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_non_fungible_resource_address_bech32_address() != 2811 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_non_fungible_resource_address_map_to_network() != 21266 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_non_fungible_resource_address_network_id() != 64552 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_non_fungible_resource_indicator_get_ids() != 31374 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_nonce_get_value() != 20204 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_notarized_transaction_compile() != 55244 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_notary_signature_get_signature() != 60673 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_p2_p_link_to_json_bytes() != 41559 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_p2p_link_id() != 17801 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_p2p_links_to_json_bytes() != 51949 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_package_address_bech32_address() != 48492 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_package_address_formatted() != 56063 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_package_address_map_to_network() != 54791 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_package_address_network_id() != 60577 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_persona_data_entry_email_address_to_json_string() != 24703 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_persona_data_entry_name_to_json_bytes() != 805 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_persona_data_entry_phone_number_to_json_string() != 38100 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_persona_data_identified_email_address_sample() != 27809 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_persona_data_identified_email_address_sample_other() != 10133 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_persona_data_identified_name_sample() != 41542 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_persona_data_identified_name_sample_other() != 34961 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_persona_data_identified_phone_number_sample() != 42681 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_persona_data_identified_phone_number_sample_other() != 35376 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_pool_address_bech32_address() != 21761 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_pool_address_formatted() != 34929 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_pool_address_kind() != 51942 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_pool_address_map_to_network() != 48099 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_pool_address_network_id() != 15737 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_profile_analyze_contents_of_file() != 20322 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_profile_encrypt_with_password() != 56521 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_profile_network_details_for_authorized_dapp() != 61437 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_profile_to_debug_string() != 61571 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_profile_to_json_string() != 5512 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_profile_to_string() != 33764 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_public_key_is_valid_signature_for_hash() != 41618 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_public_key_to_bytes() != 19143 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_public_key_to_hex() != 1275 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_radix_connect_mobile_session_request_to_json_bytes() != 26170 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_radix_connect_password_message_hash() != 9189 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_radix_connect_password_to_json_string() != 43380 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_radix_connect_purpose_to_json_string() != 38744 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_requested_quantity_is_fulfilled_by_ids() != 17442 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_requested_quantity_is_valid() != 38263 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_requested_quantity_to_json_bytes() != 42575 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_resource_address_bech32_address() != 38422 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_resource_address_formatted() != 46367 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_resource_address_is_fungible() != 43471 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_resource_address_is_non_fungible() != 12360 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_resource_address_map_to_network() != 45971 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_resource_address_network_id() != 50531 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_resource_indicator_get_address() != 46615 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_resource_preferences_get_hidden_resources() != 50458 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_resource_preferences_hide_resource() != 58708 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_resource_preferences_unhide_resource() != 26953 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_resource_specifier_get_address() != 40064 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_rust_logger_get_all_filters() != 59506 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_rust_logger_get_all_levels() != 43258 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_rust_logger_get_level() != 10949 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_rust_logger_log_at_every_level() != 22900 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_rust_logger_set_level() != 59954 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_s_l_i_p10_curve_to_json_string() != 1233 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_saved_gateways_get_all_elements() != 41603 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_secp256k1_public_key_to_bytes() != 2554 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_secp256k1_public_key_to_bytes_uncompressed() != 53526 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_secp256k1_public_key_to_hex() != 38671 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_secp256k1_signature_to_string() != 25123 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_secure_storage_access_error_kind_is_manual_cancellation() != 13245 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_secure_storage_key_identifier() != 23785 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_securified_index_in_global_key_space() != 28299 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_securified_index_in_local_key_space() != 30746 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_security_questions_all() != 28899 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_security_questions_factor_source_decrypt() != 46069 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_signature_to_bytes() != 49339 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_signature_to_string() != 22537 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_signature_with_public_key_get_public_key() != 61540 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_signature_with_public_key_get_signature() != 9548 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_signature_with_public_key_is_valid() != 107 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_signed_intent_hash() != 57483 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_signed_transaction_intent_hash_formatted() != 46686 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_slip10_curve_to_string() != 16528 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_subintent_compile() != 36589 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_subintent_hash() != 30194 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_subintent_hash_formatted() != 8825 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_subintent_manifest_blobs() != 54689 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_subintent_manifest_involved_pool_addresses() != 17290 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_subintent_manifest_involved_resource_addresses() != 4954 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_subintent_manifest_network_id() != 60401 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_subintent_manifest_string() != 25812 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_subintent_manifest_summary() != 62264 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_fee_preset() != 28642 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_intent_compile() != 55102 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_intent_hash() != 16628 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_intent_hash_formatted() != 35303 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_blobs() != 28370 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_blobs_v2() != 40013 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_instructions_string() != 59187 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_involved_pool_addresses() != 8119 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_involved_pool_addresses_v2() != 10052 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_involved_resource_addresses() != 33205 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_involved_resource_addresses_v2() != 44106 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_network_id() != 55152 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_network_id_v2() != 22658 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_string() != 62178 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_string_v2() != 20762 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_summary() != 11082 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_transaction_manifest_summary_v2() != 46195 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_trim_security_questions_answer() != 42711 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_u30_get_value() != 3367 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_u31_get_value() != 47596 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_unhardened_index_in_global_key_space() != 4106 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_unhardened_index_in_local_key_space() != 2650 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_unsafe_storage_key_identifier() != 18953 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_unsecurified_hardened_index_in_global_key_space() != 33739 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_unsecurified_hardened_index_in_local_key_space() != 42716 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_validator_address_bech32_address() != 3797 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_validator_address_formatted() != 45882 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_validator_address_map_to_network() != 18403 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_validator_address_network_id() != 28726 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_vault_address_bech32_address() != 3749 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_vault_address_formatted() != 13985 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_vault_address_is_fungible() != 5264 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_vault_address_is_non_fungible() != 49838 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_vault_address_map_to_network() != 13880 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_vault_address_network_id() != 60554 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_vector_image_type_data_url_type() != 50668 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_vector_image_type_url_extension() != 62035 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_wallet_interaction_wallet_account_to_json_bytes() != 29015 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_wallet_to_dapp_interaction_response_to_json_bytes() != 1762 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_func_xrd_address_of_network() != 54555 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_entropyproviderdriver_generate_secure_random_bytes() != 51230 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_eventbusdriver_handle_event_notification() != 37374 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_filesystemdriver_writable_app_dir_path() != 57918 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_filesystemdriver_load_from_file() != 11291 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_filesystemdriver_save_to_file() != 18612 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_filesystemdriver_delete_file() != 25840 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_homecardsmanager_bootstrap() != 47142 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_homecardsmanager_card_dismissed() != 31707 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_homecardsmanager_deferred_deep_link_received() != 22766 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_homecardsmanager_wallet_created() != 15111 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_homecardsmanager_wallet_reset() != 17223 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_homecardsmanager_wallet_restored() != 49189 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_homecardsobserver_handle_cards_update() != 48356 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_homecardsstorage_save_cards() != 64998 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_homecardsstorage_load_cards() != 44873 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_hostinfodriver_host_os() != 34576 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_hostinfodriver_host_device_name() != 1219 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_hostinfodriver_host_app_version() != 51009 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_hostinfodriver_host_device_model() != 4852 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_loggingdriver_log() != 28387 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_networkingdriver_execute_network_request() != 8345 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_profilestatechangedriver_handle_profile_state_change() != 36142 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_radixconnectmobile_handle_deep_link() != 23213 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_radixconnectmobile_send_dapp_interaction_response() != 58808 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_radixconnectmobilesessionstorage_save_session() != 63828 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_radixconnectmobilesessionstorage_load_session() != 30386 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos___debug_factor_instances_in_cache() != 37483 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_account_by_address() != 619 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_accounts_for_display_on_current_network() != 24966 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_accounts_on_current_network() != 29433 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_add_account() != 33935 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_add_accounts() != 9567 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_add_factor_source() != 9597 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_add_factor_sources() != 28512 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_add_security_structure_of_factor_sources() != 33450 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_analyse_pre_auth_preview() != 17171 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_analyse_transaction_preview() != 50307 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_batch_create_many_accounts_then_save_once() != 21395 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_batch_create_unsaved_accounts() != 5785 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_bdfs() != 58200 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_change_current_gateway() != 14313 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_check_accounts_deleted_on_ledger() != 10981 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_create_and_save_new_account() != 32186 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_create_and_save_new_mainnet_account() != 59433 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_create_and_save_new_unnamed_mainnet_account() != 24175 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_create_delete_account_manifest() != 35129 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_create_device_factor_source() != 46144 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_create_subintent() != 23952 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_create_unsaved_account() != 49171 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_create_unsaved_mainnet_account() != 18380 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_create_unsaved_unnamed_mainnet_account() != 43992 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_current_gateway() != 45208 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_current_network() != 40067 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_current_network_id() != 22921 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_debug_add_all_sample_factors() != 44243 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_delete_wallet() != 60762 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_factor_sources() != 27882 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_gateways() != 28077 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_has_any_account_on_any_network() != 7423 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_has_any_network() != 24883 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_import_profile() != 20464 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_import_wallet() != 47395 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_load_private_device_factor_source_by_id() != 39798 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_mark_account_as_hidden() != 1751 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_mark_account_as_tombstoned() != 45283 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_new_wallet() != 14573 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_new_wallet_with_derived_bdfs() != 32247 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_poll_pre_authorization_status() != 22017 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_poll_transaction_status() != 29304 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_profile() != 35851 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_resolve_host_id() != 28341 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_resolve_host_info() != 9680 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_security_structure_of_factor_sources_from_security_structure_of_factor_source_ids() != 60940 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_security_structures_of_factor_source_ids() != 9607 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_security_structures_of_factor_sources() != 63952 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_set_profile() != 55953 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_submit_transaction() != 2200 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_sync_accounts_deleted_on_ledger() != 59978 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_update_account() != 47089 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_sargonos_update_factor_source() != 2367 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_securestoragedriver_load_data() != 39397 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_securestoragedriver_save_data() != 9973 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_securestoragedriver_delete_data_for_key() != 20787 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_unsafestoragedriver_load_data() != 30438 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_unsafestoragedriver_save_data() != 2167 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_method_unsafestoragedriver_delete_data_for_key() != 25005 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_constructor_bios_new() != 55108 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_constructor_drivers_new() != 24202 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_constructor_ffiurl_new() != 15814 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_constructor_homecardsmanager_new() != 28682 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_constructor_radixconnectmobile_new() != 51477 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_sargon_uniffi_checksum_constructor_sargonos_boot() != 21616 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitEntropyProviderDriver()
    uniffiCallbackInitEventBusDriver()
    uniffiCallbackInitFileSystemDriver()
    uniffiCallbackInitHomeCardsObserver()
    uniffiCallbackInitHomeCardsStorage()
    uniffiCallbackInitHostInfoDriver()
    uniffiCallbackInitLoggingDriver()
    uniffiCallbackInitNetworkingDriver()
    uniffiCallbackInitProfileStateChangeDriver()
    uniffiCallbackInitRadixConnectMobileSessionStorage()
    uniffiCallbackInitSecureStorageDriver()
    uniffiCallbackInitUnsafeStorageDriver()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
