pub use crate::prelude::*;

/// A random number generated part of an intent header,
/// ensuring every intent is unique even though its
/// transaction manifest might be equal. This intent discriminator is
/// generated by wallets for incoming intents.
///
/// `IntentDiscriminator` is similar to the `IntentDiscriminator32` used in `TransactionHeader`.
#[derive(
    Clone, Copy, PartialEq, Eq, Hash, derive_more::Display, derive_more::Debug,
)]
#[display("{}", self.0)]
#[debug("{}", self.0)]
pub struct IntentDiscriminator(pub u64);

impl From<u64> for IntentDiscriminator {
    fn from(value: u64) -> Self {
        Self(value)
    }
}

impl From<IntentDiscriminator> for u64 {
    fn from(value: IntentDiscriminator) -> Self {
        value.0
    }
}

impl IntentDiscriminator {
    /// Generates 8 random bytes and creates a IntentDiscriminator (u64) from it.
    pub fn random() -> Self {
        let value = u64::from_be_bytes(
            generate_bytes::<8>()
                .as_slice()
                .try_into()
                .expect("It is 8 bytes."),
        );

        Self(value)
    }
}

impl HasSampleValues for IntentDiscriminator {
    fn sample() -> Self {
        Self(123456789)
    }

    fn sample_other() -> Self {
        Self(987654321)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[allow(clippy::upper_case_acronyms)]
    type SUT = IntentDiscriminator;

    #[test]
    fn equality() {
        assert_eq!(SUT::sample(), SUT::sample());
        assert_eq!(SUT::sample_other(), SUT::sample_other());
    }

    #[test]
    fn inequality() {
        assert_ne!(SUT::sample(), SUT::sample_other());
    }

    #[test]
    fn from_u64() {
        let test =
            |u: u64| assert_eq!(u64::from(IntentDiscriminator::from(u)), u);
        test(0);
        test(1);
        test(2);
        test(1337);
    }

    #[test]
    fn display() {
        assert_eq!(format!("{}", SUT::sample()), "123456789");
    }

    #[test]
    fn debug() {
        assert_eq!(format!("{:?}", SUT::sample()), "123456789");
    }

    #[test]
    fn to_u64() {
        let test = |u: u64| {
            assert_eq!(
                u64::from(IntentDiscriminator::from(u64::from(
                    IntentDiscriminator::from(u)
                ))),
                u
            )
        };
        test(0);
        test(1);
        test(2);
        test(1337);
    }

    #[test]
    fn generate_new() {
        let mut set: HashSet<SUT> = HashSet::new();
        let n = 100;
        for _ in 0..n {
            let sut = SUT::random();
            set.insert(sut);
        }
        assert_eq!(set.len(), n); // with a low probability this might fail yes.
    }
}
