pub use crate::prelude::*;

// Generate the FfiConverter needed by UniFFI for newtype `Nonce`.
uniffi::custom_newtype!(NonceSecretMagic, u32);

#[derive(
    Clone, Copy, PartialEq, Eq, Hash, derive_more::Display, derive_more::Debug,
)]
pub struct NonceSecretMagic(pub u32);

impl NonceSecretMagic {
    /// Generates 4 random bytes and creates a Nonce (u32) from it.
    pub fn random() -> Self {
        let value = u32::from_be_bytes(
            generate_bytes::<4>()
                .as_slice()
                .try_into()
                .expect("It is 4 bytes."),
        );

        Self(value)
    }
}

/// A random number generated part of a transaction header,
/// ensuring every transaction os unique even though its
/// transaction manifest might be equal. This nonce is
/// generated by wallets for incoming transactions.
#[derive(
    Clone,
    Copy,
    PartialEq,
    Eq,
    Hash,
    derive_more::Display,
    derive_more::Debug,
    uniffi::Record,
)]
#[display("{}", self.secret_magic)]
#[debug("{}", self.secret_magic)]
pub struct Nonce {
    secret_magic: NonceSecretMagic,
}

impl From<NonceSecretMagic> for Nonce {
    fn from(value: NonceSecretMagic) -> Self {
        Self {
            secret_magic: value,
        }
    }
}

impl From<u32> for Nonce {
    fn from(value: u32) -> Self {
        Self::from(NonceSecretMagic(value))
    }
}

impl From<Nonce> for u32 {
    fn from(value: Nonce) -> Self {
        value.secret_magic.0
    }
}

impl Nonce {
    /// Generates 4 random bytes and creates a Nonce (u32) from it.
    pub fn random() -> Self {
        Self::from(NonceSecretMagic::random())
    }
}

impl HasSampleValues for Nonce {
    fn sample() -> Self {
        Self::from(NonceSecretMagic(123456789))
    }

    fn sample_other() -> Self {
        Self::from(NonceSecretMagic(987654321))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[allow(clippy::upper_case_acronyms)]
    type SUT = Nonce;

    #[test]
    fn equality() {
        assert_eq!(SUT::sample(), SUT::sample());
        assert_eq!(SUT::sample_other(), SUT::sample_other());
    }

    #[test]
    fn inequality() {
        assert_ne!(SUT::sample(), SUT::sample_other());
    }

    #[test]
    fn from_u32() {
        let test = |u: u32| assert_eq!(u32::from(Nonce::from(u)), u);
        test(0);
        test(1);
        test(2);
        test(1337);
    }

    #[test]
    fn display() {
        assert_eq!(format!("{}", SUT::sample()), "123456789");
    }

    #[test]
    fn debug() {
        assert_eq!(format!("{:?}", SUT::sample()), "123456789");
    }

    #[test]
    fn to_u32() {
        let test = |u: u32| {
            assert_eq!(u32::from(Nonce::from(u32::from(Nonce::from(u)))), u)
        };
        test(0);
        test(1);
        test(2);
        test(1337);
    }

    #[test]
    fn generate_new() {
        let mut set: HashSet<SUT> = HashSet::new();
        let n = 100;
        for _ in 0..n {
            let sut = SUT::random();
            set.insert(sut);
        }
        assert_eq!(set.len(), n); // with a low probability this might fail yes.
    }

    #[test]
    fn manual_perform_uniffi_conversion() {
        let sut = SUT::sample();
        let ffi_side =
            <NonceSecretMagic as crate::UniffiCustomTypeConverter>::from_custom(
                sut.secret_magic,
            );
        let from_ffi_side = <NonceSecretMagic as crate::UniffiCustomTypeConverter>::into_custom(ffi_side).unwrap();
        assert_eq!(sut, from_ffi_side.into());
    }
}
