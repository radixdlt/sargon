use crate::prelude::*;

/// An Ed25519 private key used to create cryptographic signatures, using
/// EdDSA scheme.
#[derive(derive_more::Debug)]
#[debug("{}", self.to_hex())]
pub struct Ed25519PrivateKey(ScryptoEd25519PrivateKey);

impl Ed25519PrivateKey {
    /// Generates a new `Ed25519PrivateKey` from random bytes
    /// generated by a CSRNG, note that this is typically never
    /// used by wallets, which tend to rather use a Mnemonic and
    /// derive hierarchical deterministic keys.
    pub fn generate() -> Self {
        Self::from_exactly32_bytes(Exactly32Bytes::generate())
    }
}

impl PartialEq for Ed25519PrivateKey {
    fn eq(&self, other: &Self) -> bool {
        self.to_bytes() == other.to_bytes()
    }
}

impl Eq for Ed25519PrivateKey {}

impl IsPrivateKey<Ed25519PublicKey> for Ed25519PrivateKey {
    fn curve() -> SLIP10Curve {
        SLIP10Curve::Curve25519
    }

    type Signature = Ed25519Signature;

    fn public_key(&self) -> Ed25519PublicKey {
        self.0.public_key().try_into().expect(
            "Public Key from EC scalar multiplication should always be valid.",
        )
    }

    fn sign(&self, msg_hash: &Hash) -> Self::Signature {
        self.0.sign(msg_hash).into()
    }

    fn from_bytes(slice: &[u8]) -> Result<Self> {
        ScryptoEd25519PrivateKey::from_bytes(slice)
            .map_err(|_| CommonError::InvalidEd25519PrivateKeyFromBytes {
                bad_value: hex_encode(slice),
            })
            .map(Self::from_scrypto)
    }
}

impl Ed25519PrivateKey {
    pub fn from_scrypto(scrypto: ScryptoEd25519PrivateKey) -> Self {
        Self(scrypto)
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        self.0.to_bytes().to_vec()
    }

    pub fn to_hex(&self) -> String {
        hex_encode(self.to_bytes())
    }

    pub fn from_vec(bytes: Vec<u8>) -> Result<Self> {
        Self::from_bytes(bytes.as_slice())
    }

    pub fn from_exactly32_bytes(bytes: Exactly32Bytes) -> Self {
        Self::from(bytes)
    }
}

impl From<Exactly32Bytes> for Ed25519PrivateKey {
    fn from(bytes: Exactly32Bytes) -> Self {
        Self::from_vec(bytes.to_vec()).expect("Should always be able to generate a Ed25519PrivateKey from 32 bytes.")
    }
}

impl TryFrom<&[u8]> for Ed25519PrivateKey {
    type Error = crate::CommonError;

    fn try_from(slice: &[u8]) -> Result<Ed25519PrivateKey, Self::Error> {
        Ed25519PrivateKey::from_bytes(slice)
    }
}

impl FromStr for Ed25519PrivateKey {
    type Err = CommonError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Exactly32Bytes::from_hex(s)
            .map_err(|_| CommonError::InvalidEd25519PrivateKeyFromString {
                bad_value: s.to_owned(),
            })
            .and_then(|b| Self::from_bytes(&b.to_vec()))
    }
}

impl HasSampleValues for Ed25519PrivateKey {
    /// A sample used to facilitate unit tests.
    fn sample() -> Self {
        Self::sample_alice()
    }

    /// A sample used to facilitate unit tests.
    fn sample_other() -> Self {
        Self::sample_bob()
    }
}

impl Ed25519PrivateKey {
    /// A sample used to facilitate unit tests.
    ///
    /// `833fe62409237b9d62ec77587520911e9a759cec1d19755b7da901b96dca3d42`
    ///
    /// expected public key:
    /// `ec172b93ad5e563bf4932c70e1245034c35467ef2efd4d64ebf819683467e2bf`
    ///
    /// https://github.com/dalek-cryptography/ed25519-dalek/blob/main/tests/ed25519.rs#L103
    pub fn sample_alice() -> Self {
        Self::from_str(
            "833fe62409237b9d62ec77587520911e9a759cec1d19755b7da901b96dca3d42",
        )
        .unwrap()
    }

    /// A sample used to facilitate unit tests.
    ///
    /// `1498b5467a63dffa2dc9d9e069caf075d16fc33fdd4c3b01bfadae6433767d93``
    ///
    /// expected public key:
    /// `b7a3c12dc0c8c748ab07525b701122b88bd78f600c76342d27f25e5f92444cde`
    ///
    /// https://cryptobook.nakov.com/digital-signatures/eddsa-sign-verify-examples
    pub fn sample_bob() -> Self {
        Self::from_str(
            "1498b5467a63dffa2dc9d9e069caf075d16fc33fdd4c3b01bfadae6433767d93",
        )
        .unwrap()
    }

    /// A sample used to facilitate unit tests.
    ///
    /// `8228aa5b978e3d3c1fac2606e36f746602ccff6288ee0777a7d2917aa8e6cbe8``
    ///
    /// expected public key:
    /// `37842830eca0d08dd684adcb9705b3a473c0c070a322322b53c35e09a1bff298`
    ///
    /// https://cryptobook.nakov.com/digital-signatures/eddsa-sign-verify-examples
    pub fn sample_fade() -> Self {
        Self::from_str(
            "8228aa5b978e3d3c1fac2606e36f746602ccff6288ee0777a7d2917aa8e6cbe8",
        )
        .unwrap()
    }

    /// A sample used to facilitate unit tests.
    ///
    /// `c67e54737780627f85746e3f1becf633f189e7061672a6f6737ba6319a754cbd``
    ///
    /// expected public key:
    /// `49f9cb3e59b6938b434436240690af6c952523c41d831122bb1c2600bf3e0c87`
    ///
    /// https://cryptobook.nakov.com/digital-signatures/eddsa-sign-verify-examples
    pub fn sample_aced() -> Self {
        Self::from_str(
            "c67e54737780627f85746e3f1becf633f189e7061672a6f6737ba6319a754cbd",
        )
        .unwrap()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn equality() {
        assert_eq!(Ed25519PrivateKey::sample(), Ed25519PrivateKey::sample());
        assert_eq!(
            Ed25519PrivateKey::sample_other(),
            Ed25519PrivateKey::sample_other()
        );
    }

    #[test]
    fn inequality() {
        assert_ne!(
            Ed25519PrivateKey::sample(),
            Ed25519PrivateKey::sample_other()
        );
    }

    #[test]
    fn curve() {
        assert_eq!(Ed25519PrivateKey::curve(), SLIP10Curve::Curve25519);
    }

    #[test]
    fn sign_and_verify() {
        let msg = hash_of("Test");
        let sk: Ed25519PrivateKey =
            "0000000000000000000000000000000000000000000000000000000000000001"
                .parse()
                .unwrap();
        let pk = sk.public_key();
        assert_eq!(
            pk.to_hex(),
            "4cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba29"
        );
        let sig_hex = "cf0ca64435609b85ab170da339d415bbac87d678dfd505969be20adc6b5971f4ee4b4620c602bcbc34fd347596546675099d696265f4a42a16df343da1af980e";
        let sig = Ed25519Signature::from_str(sig_hex).unwrap();

        assert_eq!(sk.sign(&msg), sig);
        assert!(pk.is_valid_signature_for_hash(&sig, &msg));
        assert_eq!(sig.to_hex(), sig_hex);
    }

    #[test]
    fn bytes_roundtrip() {
        let bytes = hex_decode(
            "0000000000000000000000000000000000000000000000000000000000000001",
        )
        .unwrap();
        assert_eq!(
            Ed25519PrivateKey::from_bytes(bytes.as_slice())
                .unwrap()
                .to_bytes(),
            bytes.as_slice()
        );
    }

    #[test]
    fn hex_roundtrip() {
        let hex =
            "0000000000000000000000000000000000000000000000000000000000000001";
        assert_eq!(Ed25519PrivateKey::from_str(hex).unwrap().to_hex(), hex);
    }

    #[test]
    fn invalid_hex() {
        assert_eq!(
            Ed25519PrivateKey::from_str("not hex"),
            Err(CommonError::InvalidEd25519PrivateKeyFromString {
                bad_value: "not hex".to_owned()
            })
        );
    }

    #[test]
    fn invalid_hex_too_short() {
        assert_eq!(
            Ed25519PrivateKey::from_str("dead"),
            Err(CommonError::InvalidEd25519PrivateKeyFromString {
                bad_value: "dead".to_owned()
            })
        );
    }

    #[test]
    fn invalid_bytes() {
        assert_eq!(
            Ed25519PrivateKey::from_bytes(&[0u8] as &[u8]),
            Err(CommonError::InvalidEd25519PrivateKeyFromBytes {
                bad_value: "00".to_owned()
            })
        );
    }

    #[test]
    fn debug() {
        let hex =
            "0000000000000000000000000000000000000000000000000000000000000001";
        assert_eq!(
            format!("{:?}", Ed25519PrivateKey::from_str(hex).unwrap()),
            hex
        );
    }

    #[test]
    fn from_vec() {
        let hex =
            "deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
        assert_eq!(
            Ed25519PrivateKey::from_vec(hex_decode(hex).unwrap())
                .unwrap()
                .to_hex(),
            hex
        );
    }

    #[test]
    fn from_exactly32() {
        let hex =
            "deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
        assert_eq!(
            Ed25519PrivateKey::from_exactly32_bytes(
                Exactly32Bytes::from_hex(hex).unwrap()
            )
            .to_hex(),
            hex
        );
    }

    #[test]
    fn generate_new() {
        let mut set: HashSet<Vec<u8>> = HashSet::new();
        let n = 100;
        for _ in 0..n {
            let key = Ed25519PrivateKey::generate();
            let bytes = key.to_bytes();
            assert_eq!(bytes.len(), 32);
            set.insert(bytes);
        }
        assert_eq!(set.len(), n);
    }

    #[test]
    fn from_exactly32_bytes() {
        let str =
            "0000000000000000000000000000000000000000000000000000000000000001";
        let hex32 = Exactly32Bytes::from_hex(str).unwrap();
        let key = Ed25519PrivateKey::from_exactly32_bytes(hex32);
        assert_eq!(key.to_hex(), str);
    }

    #[test]
    fn try_from_bytes() {
        let str =
            "0000000000000000000000000000000000000000000000000000000000000001";
        let vec = hex_decode(str).unwrap();
        let key = Ed25519PrivateKey::try_from(vec.as_slice()).unwrap();
        assert_eq!(key.to_hex(), str);
    }

    #[test]
    fn sample() {
        assert_eq!(
            Ed25519PrivateKey::sample().public_key().to_hex(),
            "ec172b93ad5e563bf4932c70e1245034c35467ef2efd4d64ebf819683467e2bf"
        );
    }
}
